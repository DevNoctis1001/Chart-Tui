tui.util.defineNamespace("fedoc.content", {});
fedoc.content["dataModels_dataProcessor.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview DataProcessor process rawData.\n * rawData.categories --> categories\n * rawData.series --> SeriesDataModel, legendLabels, legendData\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const'),\n    SeriesDataModel = require('../dataModels/seriesDataModel'),\n    SeriesGroup = require('./seriesGroup'),\n    predicate = require('../helpers/predicate'),\n    rawDataHandler = require('../helpers/rawDataHandler'),\n    renderUtil = require('../helpers/renderUtil');\n\nvar concat = Array.prototype.concat;\n\n/**\n * Raw series datum.\n * @typedef {{name: ?string, data: Array.&lt;number>, stack: ?string}} rawSeriesDatum\n */\n\n/**\n * Raw series data.\n * @typedef {Array.&lt;rawSeriesDatum>} rawSeriesData\n */\n\n/**\n * Raw data by user.\n * @typedef {{\n *      categories: ?Array.&lt;string>,\n *      series: (rawSeriesData|{line: ?rawSeriesData, column: ?rawSeriesData})\n * }} rawData\n */\n\n/**\n * SeriesDataModel is base model for drawing graph of chart series area,\n *      and create from rawSeriesData by user,\n * SeriesDataModel.groups has SeriesGroups.\n */\n\n/**\n * SeriesGroup is a element of SeriesDataModel.groups.\n * SeriesGroup.items has SeriesItem.\n */\n\nvar DataProcessor = tui.util.defineClass(/** @lends DataProcessor.prototype */{\n    /**\n     * Data processor.\n     * @constructs DataProcessor\n     * @param {rawData} rawData raw data\n     * @param {string} chartType chart type\n     * @param {object} options options\n     * @param {Array.&lt;string>} seriesChartTypes chart types\n     */\n    init: function(rawData, chartType, options, seriesChartTypes) {\n        var seriesOption = options.series || {};\n\n        /**\n         * original raw data.\n         * @type {{categories: ?Array.&lt;string>, series: Array.&lt;object>}}\n         */\n        this.originalRawData = rawData;\n\n        /**\n         * chart type\n         * @type {string}\n         */\n        this.chartType = chartType;\n\n        /**\n         * chart options\n         * @type {Object}\n         */\n        this.options = options;\n\n        /**\n         * seriesChartTypes is sorted chart types for rendering series area of combo chart.\n         * @type {Array.&lt;string>}\n         */\n        this.seriesChartTypes = seriesChartTypes;\n\n        /**\n         * diverging option\n         * @type {boolean}\n         */\n        this.divergingOption = predicate.isBarTypeChart(options.chartType) &amp;&amp; seriesOption.diverging;\n\n        /**\n         * legend data for rendering legend of group tooltip\n         * @type {Array.&lt;{chartType: string, label: string}>}\n         */\n        this.originalLegendData = null;\n\n        this.initData(rawData);\n    },\n\n    /**\n     * Get original raw data.\n     * @returns {rawData} raw data\n     */\n    getOriginalRawData: function() {\n        return this.originalRawData;\n    },\n\n    /**\n     * Initialize data.\n     * @param {rawData} rawData raw data\n     */\n    initData: function(rawData) {\n        /**\n         * raw data\n         * @type {rawData}\n         */\n        this.rawData = rawData;\n\n        /**\n         * categories\n         * @type {Array.&lt;string>}\n         */\n        this.categories = null;\n\n        /**\n         * stacks\n         * @type {Array.&lt;number>}\n         */\n        this.stacks = null;\n\n        /**\n         * seriesDataModel map\n         * @type {object.&lt;string, SeriesDataModel>}\n         */\n        this.seriesDataModelMap = {};\n\n        /**\n         * SeriesGroups\n         * @type {Array.&lt;SeriesGroup>}\n         */\n        this.seriesGroups = null;\n\n        /**\n         * map of values of SeriesItems\n         * @type {Object.&lt;string, Array.&lt;number>>}\n         */\n        this.valuesMap = {};\n\n        /**\n         * legend labels for rendering legend area\n         * @type {{column: Array.&lt;string>, line: Array.&lt;string> | Array.&lt;string>}}\n         */\n        this.legendLabels = null;\n\n        /**\n         * legend data for rendering legend\n         * @type {Array.&lt;{chartType: string, label: string}>}\n         */\n        this.legendData = null;\n\n        /**\n         * functions for formatting\n         * @type {Array.&lt;function>}\n         */\n        this.formatFunctions = null;\n\n        /**\n         * multiline categories\n         * @type {Array.&lt;string>}\n         */\n        this.multilineCategories = null;\n    },\n\n    /**\n     * Process categories\n     * @returns {Array.&lt;string>} processed categories\n     * @private\n     */\n    _processCategories: function() {\n        return tui.util.map(this.rawData.categories, tui.util.encodeHTMLEntity);\n    },\n\n    /**\n     * Get Categories\n     * @returns {Array.&lt;string>}}\n     */\n    getCategories: function() {\n        if (!this.categories) {\n            this.categories = this._processCategories();\n        }\n\n        return this.categories;\n    },\n\n    /**\n     * Whether has categories or not.\n     * @returns {boolean}\n     */\n    hasCategories: function() {\n        return !!this.getCategories().length;\n    },\n\n    /**\n     * Get category.\n     * @param {number} index index\n     * @returns {string} category\n     */\n    getCategory: function(index) {\n        return this.getCategories()[index];\n    },\n\n    /**\n     * Get stacks.\n     * @returns {Array.&lt;string>}\n     */\n    getStacks: function() {\n        if (!this.stacks) {\n            this.stacks = rawDataHandler.pickStacks(this.rawData.series);\n        }\n\n        return this.stacks;\n    },\n\n    /**\n     * Get stack count.\n     * @returns {Number}\n     */\n    getStackCount: function() {\n        return this.getStacks().length;\n    },\n\n    /**\n     * Find stack index.\n     * @param {string} stack stack\n     * @returns {number}\n     */\n    findStackIndex: function(stack) {\n        return tui.util.inArray(stack, this.getStacks());\n    },\n\n    /**\n     * Get SeriesDataModel.\n     * @param {string} chartType - chart type\n     * @returns {SeriesDataModel}\n     */\n    getSeriesDataModel: function(chartType) {\n        var rawSeriesData;\n\n        if (!this.seriesDataModelMap[chartType]) {\n            rawSeriesData = this.rawData.series[chartType] || this.rawData.series;\n            this.seriesDataModelMap[chartType] = new SeriesDataModel(rawSeriesData, chartType,\n                this.options, this.getFormatFunctions());\n        }\n\n        return this.seriesDataModelMap[chartType];\n    },\n\n    /**\n     * Get group count.\n     * @param {string} chartType chart type\n     * @returns {number}\n     */\n    getGroupCount: function(chartType) {\n        return this.getSeriesDataModel(chartType).getGroupCount();\n    },\n\n    /**\n     * Traverse all SeriesDataModel by seriesChartTypes, and executes iteratee function.\n     * @param {function} iteratee iteratee function\n     * @private\n     */\n    _eachByAllSeriesDataModel: function(iteratee) {\n        var self = this,\n            seriesChartTypes = this.seriesChartTypes || [this.chartType];\n\n        tui.util.forEachArray(seriesChartTypes, function(chartType) {\n            return iteratee(self.getSeriesDataModel(chartType), chartType);\n        });\n    },\n\n    /**\n     * Whether valid all SeriesDataModel or not.\n     * @returns {boolean}\n     */\n    isValidAllSeriesDataModel: function() {\n        var isValid = true;\n\n        this._eachByAllSeriesDataModel(function(seriesDataModel) {\n            isValid = !!seriesDataModel.getGroupCount();\n\n            return isValid;\n        });\n\n        return isValid;\n    },\n\n    /**\n     * Make SeriesGroups.\n     * @returns {Array.&lt;SeriesGroup>}\n     * @private\n     */\n    _makeSeriesGroups: function() {\n        var joinedGroups = [],\n            seriesGroups;\n\n        this._eachByAllSeriesDataModel(function(seriesDataModel) {\n            seriesDataModel.each(function(seriesGroup, index) {\n                if (!joinedGroups[index]) {\n                    joinedGroups[index] = [];\n                }\n                joinedGroups[index] = joinedGroups[index].concat(seriesGroup.items);\n            });\n        });\n\n        seriesGroups = tui.util.map(joinedGroups, function(items) {\n            return new SeriesGroup(items);\n        });\n\n        return seriesGroups;\n    },\n\n    /**\n     * Get SeriesGroups.\n     * @returns {Array.&lt;SeriesGroup>}\n     */\n    getSeriesGroups: function() {\n        if (!this.seriesGroups) {\n            this.seriesGroups = this._makeSeriesGroups();\n        }\n        return this.seriesGroups;\n    },\n\n    /**\n     * Get value.\n     * @param {number} groupIndex group index\n     * @param {number} index index\n     * @param {?string} chartType chart type\n     * @returns {number} value\n     */\n    getValue: function(groupIndex, index, chartType) {\n        return this.getSeriesDataModel(chartType).getValue(groupIndex, index);\n    },\n\n    /**\n     * Create values that picked value from SeriesItems of specific SeriesDataModel.\n     * @param {?string} chartType - type of chart\n     * @param {?string} valueType - type of value like value, x, y, r.\n     * @returns {Array.&lt;number>}\n     * @private\n     */\n    _createValues: function(chartType, valueType) {\n        var values;\n\n        if (chartType === chartConst.DUMMY_KEY) {\n            values = [];\n            this._eachByAllSeriesDataModel(function(seriesDataModel) {\n                values = values.concat(seriesDataModel.getValues(valueType));\n            });\n        } else {\n            values = this.getSeriesDataModel(chartType).getValues(valueType);\n        }\n        return values;\n    },\n\n    /**\n     * Get values from valuesMap.\n     * @param {?string} chartType - type of chart\n     * @param {?string} valueType - type of value like value, x, y, r.\n     * @returns {Array.&lt;number>}\n     */\n    getValues: function(chartType, valueType) {\n        var mapKey;\n\n        chartType = chartType || chartConst.DUMMY_KEY;\n\n        mapKey = chartType + valueType;\n\n        if (!this.valuesMap[mapKey]) {\n            this.valuesMap[mapKey] = this._createValues(chartType, valueType);\n        }\n\n        return this.valuesMap[mapKey];\n    },\n\n    /**\n     * Get max value.\n     * @param {?string} chartType - type of chart\n     * @param {?string} valueType - type of value like value, x, y, r\n     * @returns {number}\n     */\n    getMaxValue: function(chartType, valueType) {\n        return tui.util.max(this.getValues(chartType, valueType));\n    },\n\n    /**\n     * Get formatted max value.\n     * @param {?string} chartType - type of chart\n     * @param {?string} areaType - type of area like circleLegend\n     * @param {?string} valueType - type of value like value, x, y, r\n     * @returns {string | number}\n     */\n    getFormattedMaxValue: function(chartType, areaType, valueType) {\n        var maxValue = this.getMaxValue(chartType, valueType);\n        var formatFunctions = this.getFormatFunctions();\n\n        return renderUtil.formatValue(maxValue, formatFunctions, areaType, valueType);\n    },\n\n    /**\n     * Traverse SeriesGroup of all SeriesDataModel, and executes iteratee function.\n     * @param {function} iteratee iteratee function\n     */\n    eachBySeriesGroup: function(iteratee) {\n        this._eachByAllSeriesDataModel(function(seriesDataModel, chartType) {\n            seriesDataModel.each(function(seriesGroup, groupIndex) {\n                iteratee(seriesGroup, groupIndex, chartType);\n            });\n        });\n    },\n\n    /**\n     * Pick legend label.\n     * @param {object} item item\n     * @returns {string} label\n     * @private\n     */\n    _pickLegendLabel: function(item) {\n        return tui.util.encodeHTMLEntity(item.name);\n    },\n\n    /**\n     * Pick legend labels from raw data.\n     * @returns {string[]} labels\n     */\n    _pickLegendLabels: function() {\n        var self = this,\n            seriesData = this.rawData.series,\n            result;\n        if (tui.util.isArray(seriesData)) {\n            result = tui.util.map(seriesData, this._pickLegendLabel);\n        } else {\n            result = {};\n            tui.util.forEach(seriesData, function(seriesDatum, type) {\n                result[type] = tui.util.map(seriesDatum, self._pickLegendLabel);\n            });\n        }\n\n        return result;\n    },\n\n    /**\n     * Get legend labels.\n     * @param {?string} chartType chart type\n     * @returns {Array.&lt;string> | {column: ?Array.&lt;string>, line: ?Array.&lt;string>}} legend labels\n     */\n    getLegendLabels: function(chartType) {\n        if (!this.legendLabels) {\n            this.legendLabels = this._pickLegendLabels();\n        }\n        return this.legendLabels[chartType] || this.legendLabels;\n    },\n\n    /**\n     * Make legend data.\n     * @returns {Array} labels\n     * @private\n     */\n    _makeLegendData: function() {\n        var legendLabels = this.getLegendLabels(),\n            seriesChartTypes = this.seriesChartTypes || [this.chartType],\n            legendLabelsMap, legendData;\n\n        if (tui.util.isArray(legendLabels)) {\n            legendLabelsMap = [this.chartType];\n            legendLabelsMap[this.chartType] = legendLabels;\n        } else {\n            seriesChartTypes = this.seriesChartTypes;\n            legendLabelsMap = legendLabels;\n        }\n\n        legendData = tui.util.map(seriesChartTypes, function(chartType) {\n            return tui.util.map(legendLabelsMap[chartType], function(label) {\n                return {\n                    chartType: chartType,\n                    label: label\n                };\n            });\n        });\n\n        return concat.apply([], legendData);\n    },\n\n    /**\n     * Get legend data.\n     * @returns {Array.&lt;{chartType: string, label: string}>} legend data\n     */\n    getLegendData: function() {\n        if (!this.legendData) {\n            this.legendData = this._makeLegendData();\n        }\n\n        if (!this.originalLegendData) {\n            this.originalLegendData = this.legendData;\n        }\n\n        return this.legendData;\n    },\n\n    /**\n     * get original legend data.\n     * @returns {Array.&lt;{chartType: string, label: string}>}\n     */\n    getOriginalLegendData: function() {\n        return this.originalLegendData;\n    },\n\n    /**\n     * Get legend item.\n     * @param {number} index index\n     * @returns {{chartType: string, label: string}} legend data\n     */\n    getLegendItem: function(index) {\n        return this.getLegendData()[index];\n    },\n\n    /**\n     * Get format functions.\n     * @returns {Array.&lt;function>} functions\n     */\n    getFormatFunctions: function() {\n        if (!this.formatFunctions) {\n            this.formatFunctions = this._findFormatFunctions();\n        }\n\n        return this.formatFunctions;\n    },\n\n    /**\n     * Get first label of SeriesItem.\n     * @param {?string} chartType chartType\n     * @returns {string} formatted value\n     */\n    getFirstItemLabel: function(chartType) {\n        return this.getSeriesDataModel(chartType).getFirstItemLabel();\n    },\n\n    /**\n     * Pick max length under point.\n     * @param {string[]} values chart values\n     * @returns {number} max length under point\n     * @private\n     */\n    _pickMaxLenUnderPoint: function(values) {\n        var max = 0;\n\n        tui.util.forEachArray(values, function(value) {\n            var len = tui.util.getDecimalLength(value);\n            if (len > max) {\n                max = len;\n            }\n        });\n\n        return max;\n    },\n\n    /**\n     * Whether zero fill format or not.\n     * @param {string} format format\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isZeroFill: function(format) {\n        return format.length > 2 &amp;&amp; format.charAt(0) === '0';\n    },\n\n    /**\n     * Whether decimal format or not.\n     * @param {string} format format\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isDecimal: function(format) {\n        var indexOf = format.indexOf('.');\n\n        return indexOf > -1 &amp;&amp; indexOf &lt; format.length - 1;\n    },\n\n    /**\n     * Whether comma format or not.\n     * @param {string} format format\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isComma: function(format) {\n        return format.indexOf(',') > -1;\n    },\n\n    /**\n     * Format zero fill.\n     * @param {number} len length of result\n     * @param {string} value target value\n     * @returns {string} formatted value\n     * @private\n     */\n    _formatZeroFill: function(len, value) {\n        var isMinus = value &lt; 0;\n\n        value = renderUtil.formatZeroFill(Math.abs(value), len);\n\n        return (isMinus ? '-' : '') + value;\n    },\n\n    /**\n     * Format Decimal.\n     * @param {number} len length of under decimal point\n     * @param {string} value target value\n     * @returns {string} formatted value\n     * @private\n     */\n    _formatDecimal: function(len, value) {\n        return renderUtil.formatDecimal(value, len);\n    },\n\n    /**\n     * Find simple type format functions.\n     * @param {string} format - simple format\n     * @returns {Array.&lt;function>}\n     */\n    _findSimpleTypeFormatFunctions: function(format) {\n        var funcs = [];\n        var len;\n\n        if (this._isDecimal(format)) {\n            len = this._pickMaxLenUnderPoint([format]);\n            funcs = [tui.util.bind(this._formatDecimal, this, len)];\n        } else if (this._isZeroFill(format)) {\n            len = format.length;\n            funcs = [tui.util.bind(this._formatZeroFill, this, len)];\n            return funcs;\n        }\n\n        if (this._isComma(format)) {\n            funcs.push(renderUtil.formatComma);\n        }\n\n        return funcs;\n    },\n\n    /**\n     * Find format functions.\n     * @returns {function[]} functions\n     */\n    _findFormatFunctions: function() {\n        var format = tui.util.pick(this.options, 'chart', 'format');\n        var funcs = [];\n\n        if (tui.util.isFunction(format)) {\n            funcs = [format];\n        } else if (tui.util.isString(format)) {\n            funcs = this._findSimpleTypeFormatFunctions(format);\n        }\n\n        return funcs;\n    },\n\n    /**\n     * Make multiline category.\n     * @param {string} category category\n     * @param {number} limitWidth limit width\n     * @param {object} theme label theme\n     * @returns {string} multiline category\n     * @private\n     */\n    _makeMultilineCategory: function(category, limitWidth, theme) {\n        var words = String(category).split(/\\s+/),\n            lineWords = words[0],\n            lines = [];\n\n        tui.util.forEachArray(words.slice(1), function(word) {\n            var width = renderUtil.getRenderedLabelWidth(lineWords + ' ' + word, theme);\n\n            if (width > limitWidth) {\n                lines.push(lineWords);\n                lineWords = word;\n            } else {\n                lineWords += ' ' + word;\n            }\n        });\n\n        if (lineWords) {\n            lines.push(lineWords);\n        }\n\n        return lines.join('&lt;br>');\n    },\n\n    /**\n     * Get multiline categories.\n     * @param {number} limitWidth limit width\n     * @param {object} theme label theme\n     * @param {Array.&lt;(number | string)>} xAxisLabels labels of xAxis\n     * @returns {Array} multiline categories\n     */\n    getMultilineCategories: function(limitWidth, theme, xAxisLabels) {\n        var self = this;\n\n        if (!this.multilineCategories) {\n            this.multilineCategories = tui.util.map(xAxisLabels, function(category) {\n                return self._makeMultilineCategory(category, limitWidth, theme);\n            });\n        }\n\n        return this.multilineCategories;\n    },\n\n    /**\n     * Add data ratios of pie chart.\n     */\n    addDataRatiosOfPieChart: function() {\n        this.getSeriesDataModel(chartConst.CHART_TYPE_PIE).addDataRatiosOfPieChart();\n    },\n\n    /**\n     * Add data ratios for chart of coordinate type.\n     * @param {{x: {min: number, max: number}, y: {min: number, max: number}}} limitMap - limit map\n     */\n    addDataRatiosForCoordinateType: function(limitMap) {\n        this.getSeriesDataModel(chartConst.CHART_TYPE_BUBBLE).addDataRatiosForCoordinateType(limitMap);\n    },\n\n    /**\n     * Add start value to all series item.\n     * @param {{min: number, max: number}} limit - limit\n     * @param {string} chartType - chart type\n     * @private\n     */\n    _addStartValueToAllSeriesItem: function(limit, chartType) {\n        var start = 0;\n\n        if (limit.min >= 0) {\n            start = limit.min;\n        } else if (limit.max &lt;= 0) {\n            start = limit.max;\n        }\n\n        this.getSeriesDataModel(chartType).addStartValueToAllSeriesItem(start);\n    },\n\n    /**\n     * Register percent values.\n     * @param {{min: number, max: number}} limit axis limit\n     * @param {string} stacked stacked option\n     * @param {string} chartType chart type\n     * @private\n     */\n    addDataRatios: function(limit, stacked, chartType) {\n        var seriesDataModel = this.getSeriesDataModel(chartType);\n\n        this._addStartValueToAllSeriesItem(limit, chartType);\n        seriesDataModel.addDataRatios(limit, stacked);\n    }\n});\n\nmodule.exports = DataProcessor;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"