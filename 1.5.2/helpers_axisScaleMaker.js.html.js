tui.util.defineNamespace("fedoc.content", {});
fedoc.content["helpers_axisScaleMaker.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Axis scale maker.\n * @auth NHN Ent.\n *       FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const'),\n    predicate = require('./predicate'),\n    calculator = require('./calculator'),\n    renderUtil = require('./renderUtil');\n\nvar abs = Math.abs;\n\nvar AxisScaleMaker = tui.util.defineClass(/** @lends AxisScaleMaker.prototype */{\n    /**\n     * Axis scale.\n     * @param {object} params parameters\n     * @constructs AxisScaleMaker\n     */\n    init: function(params) {\n        /**\n         * Data processor\n         * @type {DataProcessor}\n         */\n        this.dataProcessor = params.dataProcessor;\n\n        /**\n         * Bounds maker\n         * @type {BoundsMaker}\n         */\n        this.boundsMaker = params.boundsMaker;\n\n        /**\n         * Options\n         * @type {object}\n         */\n        this.options = params.options || {};\n\n        /**\n         * Chart type\n         * @type {string}\n         */\n        this.chartType = params.chartType;\n\n        /**\n         * type of value like value, x, y, r\n         * @type {string}\n         */\n        this.valueType = params.valueType;\n\n        /**\n         * type of area like yAxis, xAxis\n         * @type {string}\n         */\n        this.areaType = params.areaType;\n\n        /**\n         * Whether vertical type or not.\n         * @type {boolean}\n         */\n        this.isVertical = !!params.isVertical;\n\n        /**\n         * Whether single yAxis or not.\n         * @type {boolean}\n         */\n        this.isSingleYAxis = !!params.isSingleYAxis;\n        /**\n         * Count of scale values.\n         * @type {number}\n         */\n        this.valueCounts = params.valueCount ? [params.valueCount] : null;\n\n        /**\n         * Axis scale\n         * @type {{limit: {min: number, max: number}, step: number}}\n         */\n        this.scale = null;\n\n        /**\n         * Formatted scale values.\n         * @type {Array.&lt;string | number>}\n         */\n        this.formattedValues = null;\n    },\n\n    /**\n     * Get scale.\n     * @returns {{limit: {min: number, max: number}, step: number}}\n     * @private\n     */\n    _getScale: function() {\n        if (!this.scale) {\n            this.scale = this._makeScale();\n        }\n\n        return this.scale;\n    },\n\n    /**\n     * Get limit.\n     * @returns {{min: number, max: number}}\n     */\n    getLimit: function() {\n        return this._getScale().limit;\n    },\n\n    /**\n     * Get step.\n     * @returns {number}\n     */\n    getStep: function() {\n        return this._getScale().step;\n    },\n\n    /**\n     * Whether percent stacked chart or not.\n     * @returns {boolean}\n     * @private\n     */\n    _isPercentStackedChart: function() {\n        var isAllowedStackedOption = predicate.isAllowedStackedOption(this.chartType),\n            isPercentStacked = predicate.isPercentStacked(this.options.stacked);\n\n        return isAllowedStackedOption &amp;&amp; isPercentStacked;\n    },\n\n    /**\n     * Whether normal stacked chart or not.\n     * @returns {boolean}\n     * @private\n     */\n    _isNormalStackedChart: function() {\n        var isAllowedStackedOption = predicate.isAllowedStackedOption(this.chartType),\n            isNormalStacked = predicate.isNormalStacked(this.options.stacked);\n\n        return isAllowedStackedOption &amp;&amp; isNormalStacked;\n    },\n\n    /**\n     * Whether diverging chart or not.\n     * @returns {boolean|*}\n     * @private\n     */\n    _isDivergingChart: function() {\n        return this.options.diverging &amp;&amp; predicate.isBarTypeChart(this.chartType);\n    },\n\n    /**\n     * Get functions for formatting value.\n     * @returns {Array.&lt;function>}\n     * @private\n     */\n    _getFormatFunctions: function() {\n        var formatFunctions;\n\n        if (this._isPercentStackedChart()) {\n            formatFunctions = [function(value) {\n                return value + '%';\n            }];\n        } else {\n            formatFunctions = this.dataProcessor.getFormatFunctions();\n        }\n\n        return formatFunctions;\n    },\n\n    /**\n     * Get scale values.\n     * @returns {Array.&lt;number>}\n     * @private\n     */\n    _getScaleValues: function() {\n        var scale = this._getScale(),\n            values = calculator.makeLabelsFromLimit(scale.limit, scale.step);\n\n        return this._isDivergingChart() ? tui.util.map(values, abs) : values;\n    },\n\n    /**\n     * Get formatted scale values.\n     * @returns {Array.&lt;string|number>|*}\n     */\n    getFormattedScaleValues: function() {\n        var values, formatFunctions;\n\n        if (!this.formattedValues) {\n            values = this._getScaleValues();\n            formatFunctions = this._getFormatFunctions();\n            this.formattedValues = renderUtil.formatValues(values, formatFunctions, this.areaType, this.valueType);\n        }\n\n        return this.formattedValues;\n    },\n\n    /**\n     * Make base values of normal stacked chart.\n     * @returns {Array.&lt;number>}\n     * @private\n     */\n    _makeBaseValuesForNormalStackedChart: function() {\n        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType),\n            baseValues = [];\n\n        seriesDataModel.each(function(seriesGroup) {\n            var valuesMap = seriesGroup._makeValuesMapPerStack();\n\n            tui.util.forEach(valuesMap, function(values) {\n                var plusSum = calculator.sumPlusValues(values),\n                    minusSum = calculator.sumMinusValues(values);\n                baseValues = baseValues.concat([plusSum, minusSum]);\n            });\n        });\n\n        return baseValues;\n    },\n\n    /**\n     * Make base values.\n     * @returns {Array.&lt;number>} base values\n     * @private\n     */\n    _makeBaseValues: function() {\n        var baseValues;\n\n        if (predicate.isMapChart(this.chartType)) {\n            baseValues = this.dataProcessor.getValues();\n        } else if (this.isSingleYAxis) {\n            baseValues = this.dataProcessor.getValues();\n        } else if (this._isNormalStackedChart()) {\n            baseValues = this._makeBaseValuesForNormalStackedChart();\n        } else {\n            baseValues = this.dataProcessor.getValues(this.chartType, this.valueType);\n        }\n\n        return baseValues;\n    },\n\n    /**\n     * Get base size for calculation candidate value counts.\n     * @returns {number} base size\n     * @private\n     */\n    _getBaseSize: function() {\n        var baseSize;\n\n        if (this.isVertical) {\n            baseSize = this.boundsMaker.makeSeriesHeight();\n        } else {\n            baseSize = this.boundsMaker.makeSeriesWidth();\n        }\n\n        return baseSize;\n    },\n\n    /**\n     * Get candidate counts of value.\n     * @memberOf module:axisDataMaker\n     * @returns {Array.&lt;number>} value counts\n     * @private\n     */\n    _getCandidateCountsOfValue: function() {\n        var minStart = 3,\n            valueCounts, baseSize, start, end;\n\n        baseSize = this._getBaseSize();\n        start = Math.max(minStart, parseInt(baseSize / chartConst.MAX_PIXEL_TYPE_STEP_SIZE, 10));\n        end = Math.max(start, parseInt(baseSize / chartConst.MIN_PIXEL_TYPE_STEP_SIZE, 10)) + 1;\n        valueCounts = tui.util.range(start, end);\n\n        return valueCounts;\n    },\n\n    /**\n     * Make limit for diverging option.\n     * @param {{min: number, max: number}} limit limit\n     * @returns {{min: number, max: number}} changed limit\n     * @private\n     */\n    _makeLimitForDivergingOption: function(limit) {\n        var newMax = Math.max(abs(limit.min), abs(limit.max));\n\n        return {\n            min: -newMax,\n            max: newMax\n        };\n    },\n\n    /**\n     * Make integer type scale.\n     * @memberOf module:axisDataMaker\n     * @param {{min: number, max: number}} limit limit\n     * @returns {{\n     *      limit: {min: number, max: number},\n     *      options: {min: number, max: number},\n     *      divideNum: number\n     * }} integer type info\n     * @private\n     */\n    _makeIntegerTypeScale: function(limit) {\n        var options = this.options.limit || {},\n            min = limit.min,\n            max = limit.max,\n            multipleNum, changedOptions;\n\n        if (abs(min) >= 1 || abs(max) >= 1) {\n            return {\n                limit: limit,\n                options: options,\n                divideNum: 1\n            };\n        }\n\n        multipleNum = tui.util.findMultipleNum(min, max);\n        changedOptions = {};\n\n        if (!tui.util.isUndefined(options.min)) {\n            changedOptions.min = options.min * multipleNum;\n        }\n\n        if (!tui.util.isUndefined(options.max)) {\n            changedOptions.max = options.max * multipleNum;\n        }\n\n        return {\n            limit: {\n                min: min * multipleNum,\n                max: max * multipleNum\n            },\n            options: changedOptions,\n            divideNum: multipleNum\n        };\n    },\n\n    /**\n     * Make limit if equal min and max.\n     * @param {{min: number, max: number}} limit limit\n     * @returns {{min: number, max: number}} changed limit\n     * @private\n     */\n    _makeLimitIfEqualMinMax: function(limit) {\n        var min = limit.min,\n            max = limit.max;\n\n        if (min > 0) {\n            min = 0;\n        } else if (min &lt; 0) {\n            max = 0;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    /**\n     * Make base limit\n     * @memberOf module:axisDataMaker\n     * @param {{min: number, max: number}} dataLimit user limit\n     * @param {{min: number, max: number}} options axis options\n     * @returns {{min: number, max: number}} base limit\n     * @private\n     */\n    _makeBaseLimit: function(dataLimit, options) {\n        var isMinusLimit = predicate.isMinusLimit(dataLimit),\n            min = dataLimit.min,\n            max = dataLimit.max,\n            baseLimit, tmpMin;\n\n        if (min === max) {\n            baseLimit = this._makeLimitIfEqualMinMax(dataLimit);\n        } else {\n            if (isMinusLimit) {\n                tmpMin = min;\n                min = -max;\n                max = -tmpMin;\n            }\n\n            baseLimit = calculator.calculateLimit(min, max);\n\n            if (isMinusLimit) {\n                tmpMin = baseLimit.min;\n                baseLimit.min = -baseLimit.max;\n                baseLimit.max = -tmpMin;\n            }\n\n            baseLimit.min = tui.util.isUndefined(options.min) ? baseLimit.min : options.min;\n            baseLimit.max = tui.util.isUndefined(options.max) ? baseLimit.max : options.max;\n        }\n\n        return baseLimit;\n    },\n\n    /**\n     * Normalize min.\n     * @memberOf module:axisDataMaker\n     * @param {number} min original min\n     * @param {number} step scale step\n     * @returns {number} normalized min\n     * @private\n     */\n    _normalizeMin: function(min, step) {\n        var mod = tui.util.mod(min, step),\n            normalized;\n\n        if (mod === 0) {\n            normalized = min;\n        } else {\n            normalized = tui.util.subtraction(min, (min >= 0 ? mod : step + mod));\n        }\n        return normalized;\n    },\n\n    /**\n     * Make normalized max.\n     * @memberOf module:axisDataMaker\n     * @param {{min: number, max: number}} limit limit\n     * @param {number} step scale step\n     * @param {number} valueCount value count\n     * @returns {number} normalized max\n     * @private\n     */\n    _makeNormalizedMax: function(limit, step, valueCount) {\n        var minMaxDiff = tui.util.multiplication(step, valueCount - 1),\n            normalizedMax = tui.util.addition(limit.min, minMaxDiff),\n            maxDiff = limit.max - normalizedMax,\n            modDiff, divideDiff;\n        // normalize된 max값이 원래의 max값 보다 작을 경우 step을 증가시켜 큰 값으로 만들기\n        if (maxDiff > 0) {\n            modDiff = maxDiff % step;\n            divideDiff = Math.floor(maxDiff / step);\n            normalizedMax += step * (modDiff > 0 ? divideDiff + 1 : divideDiff);\n        }\n        return normalizedMax;\n    },\n\n    /**\n     * Normalize limit.\n     * @param {{min: number, max: number}} limit base limit\n     * @param {number} step scale step\n     * @param {number} valueCount value count\n     * @returns {{min: number, max: number}} normalized limit\n     * @private\n     */\n    _normalizeLimit: function(limit, step, valueCount) {\n        limit.min = this._normalizeMin(limit.min, step);\n        limit.max = this._makeNormalizedMax(limit, step, valueCount);\n        return limit;\n    },\n\n    /**\n     * Decrease minimum value by step value,\n     *  when chart type is line or dataMin is minus, options is undefined, minimum values(min, dataMin) are same.\n     * @param {number} min base min\n     * @param {number} dataMin minimum value of user data\n     * @param {number} step scale step\n     * @param {?number} optionMin min option\n     * @returns {number} changed min\n     * @private\n     */\n    _decreaseMinByStep: function(min, dataMin, step, optionMin) {\n        var isLineChart = predicate.isLineChart(this.chartType),\n            isMinusDataMin = dataMin &lt; 0,\n            isUndefinedMinOption = tui.util.isUndefined(optionMin),\n            isSame = (min === dataMin);\n\n        if ((isLineChart || isMinusDataMin) &amp;&amp; isUndefinedMinOption &amp;&amp; isSame) {\n            min -= step;\n        }\n\n        return min;\n    },\n\n    /**\n     * Increase maximum value by step value,\n     *  when chart type is line or dataMin is plus, options is undefined, maximum values(max, dataMax) are same.\n     * @param {number} max base max\n     * @param {number} dataMax maximum value of user data\n     * @param {number} step scale step\n     * @param {?number} optionMax max option\n     * @returns {number} changed max\n     * @private\n     */\n    _increaseMaxByStep: function(max, dataMax, step, optionMax) {\n        var isLineChart = predicate.isLineChart(this.chartType),\n            isPlusDataMax = dataMax > 0,\n            isUndefinedMaxOption = tui.util.isUndefined(optionMax),\n            isSame = (max === dataMax);\n\n        if ((isLineChart || isPlusDataMax) &amp;&amp; isUndefinedMaxOption &amp;&amp; isSame) {\n            max += step;\n        }\n\n        return max;\n    },\n\n    /**\n     * Divide scale step.\n     * @param {{min: number, max: number}} limit limit\n     * @param {number} step step\n     * @param {number} candidateValueCount candidate valueCount\n     * @returns {number} scale step\n     * @private\n     */\n    _divideScaleStep: function(limit, step, candidateValueCount) {\n        var isEvenStep = ((step % 2) === 0),\n            valueCount = calculator.makeLabelsFromLimit(limit, step).length,\n            twiceValueCount = (valueCount * 2) - 1,\n            diffOrg = abs(candidateValueCount - valueCount),\n            diffTwice = abs(candidateValueCount - twiceValueCount);\n\n        // step을 반으로 나누었을 때의 valueCount가 후보로 계산된 candidateValueCount와 인접하면 step을 반으로 나누어 반환합니다.\n        if (isEvenStep &amp;&amp; diffTwice &lt;= diffOrg) {\n            step = step / 2;\n        }\n        return step;\n    },\n\n    /**\n     * Minimize scale limit.\n     * @param {{min: number, max: number}} limit base limit\n     * @param {{min: number, max: number}} dataLimit limit of user data\n     * @param {number} step scale step\n     * @param {number} valueCount value count\n     * @param {{min: number, max:number}} options limit options of axis\n     * @returns {{min: number, max: number}} minimized limit\n     * @private\n     */\n    _minimizeScaleLimit: function(limit, dataLimit, step, valueCount, options) {\n        var min = limit.max,\n            max = limit.min,\n            comparisonMin = tui.util.isUndefined(options.min) ? dataLimit.min - 1 : options.min,\n            comparisonMax = tui.util.isUndefined(options.max) ? dataLimit.max + 1 : options.max;\n\n        tui.util.forEachArray(tui.util.range(1, valueCount), function(valueIndex) {\n            var changingStep = (step * valueIndex),\n                changedMin = max + changingStep,\n                changedMax = min - changingStep;\n\n            // limit이 dataLimit 범위를 넘어갈 것으로 예상되는 경우에 변경을 중단함\n            if (dataLimit.min &lt;= changedMin &amp;&amp; dataLimit.max >= changedMax) {\n                return false;\n            }\n\n            if (comparisonMin >= changedMin) {\n                limit.min = changedMin;\n            }\n\n            if (comparisonMax &lt;= changedMax) {\n                limit.max = changedMax;\n            }\n\n            return true;\n        });\n\n        return limit;\n    },\n\n    /**\n     * Adjust limit for bubble chart.\n     * @param {{min: number, max: number}} limit - limit\n     * @param {number} step - step;\n     * @private\n     */\n    _adjustLimitForBubbleChart: function(limit, step) {\n        var valueType = this.valueType;\n        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType);\n        var maxRadiusValue = seriesDataModel.getMaxValue('r');\n        var isBiggerRatioThanHalfRatio = function(seriesItem) {\n            return (seriesItem.r / maxRadiusValue) > chartConst.HALF_RATIO;\n        };\n        var foundMinItem = seriesDataModel.findMinSeriesItem(valueType, isBiggerRatioThanHalfRatio);\n        var foundMaxItem = seriesDataModel.findMaxSeriesItem(valueType, isBiggerRatioThanHalfRatio);\n\n        if (foundMinItem) {\n            limit.min -= step;\n        }\n\n        if (foundMaxItem) {\n            limit.max += step;\n        }\n    },\n\n    /**\n     * Make candidate axis scale.\n     * @param {{min: number, max: number}} baseLimit base limit\n     * @param {{min: number, max: number}} dataLimit limit of user data\n     * @param {number} valueCount value count\n     * @param {{min: number, max:number}} options limit options of axis\n     * @returns {{\n     *      limit: {min: number, max: number},\n     *      step: number\n     * }} scale\n     * @private\n     */\n    _makeCandidateScale: function(baseLimit, dataLimit, valueCount, options) {\n        var limit = tui.util.extend({}, baseLimit),\n            step;\n\n        // 01. 기본 limit 정보로 step 얻기\n        step = calculator.calculateStepFromLimit(limit, valueCount);\n\n        // 02. step 정규화 시키기 (ex: 0.3 --> 0.5, 7 --> 10)\n        step = calculator.normalizeAxisNumber(step);\n\n        // 03. limit 정규화 시키기\n        limit = this._normalizeLimit(limit, step, valueCount);\n\n        // 04. line차트의 경우 사용자의 min값이 limit의 min값과 같을 경우, min값을 1 step 감소 시킴\n        limit.min = this._decreaseMinByStep(limit.min, dataLimit.min, step, options.min);\n\n        // 04. 사용자의 max값이 scale max와 같을 경우, max값을 1 step 증가 시킴\n        limit.max = this._increaseMaxByStep(limit.max, dataLimit.max, step, options.max);\n\n        // 05. axis limit이 사용자 min, max와 거리가 멀 경우 조절\n        limit = this._minimizeScaleLimit(limit, dataLimit, step, valueCount, options);\n\n        // 06. 조건에 따라 step값을 반으로 나눔\n        step = this._divideScaleStep(limit, step, valueCount);\n\n        if (predicate.isBubbleChart(this.chartType)) {\n            this._adjustLimitForBubbleChart(limit, step);\n        }\n\n        return {\n            limit: limit,\n            step: step,\n            valueCount: abs(limit.max - limit.min) / step\n        };\n    },\n\n    /**\n     * Make candidates about axis scale.\n     * @param {{\n     *      limit: {min: number, max: number},\n     *      options: {min: number, max: number},\n     *      divideNum: number\n     * }} integerTypeScale - integer type axis scale\n     * @param {Array.&lt;number>} valueCounts - candidate counts of value\n     * @returns {Array.&lt;{limit:{min: number, max: number}, stpe: number}>} - candidates scale\n     * @private\n     */\n    _makeCandidateScales: function(integerTypeScale, valueCounts) {\n        var self = this,\n            dataLimit = integerTypeScale.limit,\n            options = integerTypeScale.options,\n            baseLimit = this._makeBaseLimit(dataLimit, options);\n\n        return tui.util.map(valueCounts, function(valueCount) {\n            return self._makeCandidateScale(baseLimit, dataLimit, valueCount, options);\n        });\n    },\n\n    /**\n     * Get comparing value for selecting axis scale.\n     * @param {{min: number, max: number}} baseLimit - limit\n     * @param {Array.&lt;number>} valueCounts - candidate counts of value\n     * @param {{limit: {min: number, max: number}, step: number}} candidateScale - scale\n     * @param {number} index - index\n     * @returns {number} comparing value\n     * @private\n     */\n    _getComparingValue: function(baseLimit, valueCounts, candidateScale, index) {\n        var diffMax = abs(candidateScale.limit.max - baseLimit.max);\n        var diffMin = abs(baseLimit.min - candidateScale.limit.min);\n        // 예상 label count와 차이가 많을 수록 후보 제외 가능성이 높음\n        var diffCount = Math.max(abs(valueCounts[index] - candidateScale.valueCount), 1);\n        // 소수점 이하 길이가 길 수록 후보에서 제외될 가능성이 높음\n        var weight = Math.pow(10, tui.util.getDecimalLength(candidateScale.step));\n\n        return (diffMax + diffMin) * diffCount * weight;\n    },\n\n    /**\n     * Select axis scale.\n     * @param {{min: number, max: number}} baseLimit limit\n     * @param {Array.&lt;{limit: {min: number, max: number}, step: number}>} candidates scale candidates\n     * @param {Array.&lt;number>} valueCounts - label counts\n     * @returns {{limit: {min: number, max: number}, step: number}} selected scale\n     * @private\n     */\n    _selectAxisScale: function(baseLimit, candidates, valueCounts) {\n        var getComparingValue = tui.util.bind(this._getComparingValue, this, baseLimit, valueCounts);\n        var axisScale = tui.util.min(candidates, getComparingValue);\n\n        return axisScale;\n    },\n\n    /**\n     * Restore number state of scale.\n     * @memberOf module:axisDataMaker\n     * @param {{limit: {min: number, max: number}, step: number}} scale scale\n     * @param {number} divideNum divide num\n     * @returns {{limit: {min: number, max: number}, step: number}} restored scale\n     * @private\n     */\n    _restoreNumberState: function(scale, divideNum) {\n        if (divideNum === 1) {\n            return scale;\n        }\n\n        scale.step = tui.util.division(scale.step, divideNum);\n        scale.limit.min = tui.util.division(scale.limit.min, divideNum);\n        scale.limit.max = tui.util.division(scale.limit.max, divideNum);\n\n        return scale;\n    },\n\n    /**\n     * Calculate scale.\n     * @returns {{limit: {min: number, max: number}, step: number}}\n     * @private\n     */\n    _calculateScale: function() {\n        var baseValues = this._makeBaseValues();\n        var dataLimit = {\n            min: tui.util.min(baseValues),\n            max: tui.util.max(baseValues)\n        };\n        var integerTypeScale, valueCounts, candidates, scale;\n\n        if (dataLimit.min === 0 &amp;&amp; dataLimit.max === 0) {\n            dataLimit.max = 5;\n        }\n\n        if (this._isDivergingChart()) {\n            dataLimit = this._makeLimitForDivergingOption(dataLimit);\n        }\n\n        // 01. limit, options 정보를 정수형으로 변경\n        integerTypeScale = this._makeIntegerTypeScale(dataLimit);\n\n        // 02. value count 후보군 얻기\n        valueCounts = this.valueCounts || this._getCandidateCountsOfValue();\n\n        // 03. axis scale 후보군 얻기\n        candidates = this._makeCandidateScales(integerTypeScale, valueCounts);\n\n        // 04. axis scale 후보군 중 하나 선택\n        scale = this._selectAxisScale(integerTypeScale.limit, candidates, valueCounts);\n\n        // 05. 정수형으로 변경했던 scale를 원래 형태로 변경\n        scale = this._restoreNumberState(scale, integerTypeScale.divideNum);\n\n        return scale;\n    },\n\n    /**\n     * Get values for sum.\n     * @returns {Array.&lt;number>}\n     * @private\n     */\n    _getValuesForSum: function() {\n        var values;\n\n        if (this.isSingleYAxis) {\n            values = this.dataProcessor.getValues();\n        } else {\n            values = this.dataProcessor.getValues(this.chartType);\n        }\n\n        return values;\n    },\n\n    /**\n     * Calculate minus sum about group values.\n     * @returns {number}\n     * @private\n     */\n    _calculateMinusSum: function() {\n        var values = this._getValuesForSum();\n\n        return calculator.sumMinusValues(values);\n    },\n\n    /**\n     * Calculate plus sum about group values.\n     * @returns {number}\n     * @private\n     */\n    _calculatePlusSum: function() {\n        var values = this._getValuesForSum();\n\n        return calculator.sumPlusValues(values);\n    },\n\n    /**\n     * Get percent stacked scale.\n     * @returns {{limit: {min:number, max:number}, step: number}}\n     * @private\n     */\n    _getPercentStackedScale: function() {\n        var scale;\n\n        if (this._calculateMinusSum() === 0) {\n            scale = chartConst.PERCENT_STACKED_AXIS_SCALE;\n        } else if (this._calculatePlusSum() === 0) {\n            scale = chartConst.MINUS_PERCENT_STACKED_AXIS_SCALE;\n        } else if (this._isDivergingChart()) {\n            scale = chartConst.DIVERGING_PERCENT_STACKED_AXIS_SCALE;\n        } else {\n            scale = chartConst.DUAL_PERCENT_STACKED_AXIS_SCALE;\n        }\n\n        return scale;\n    },\n\n    /**\n     * Make scale.\n     * @returns {{limit: {min:number, max:number}, step: number}}\n     * @private\n     */\n    _makeScale: function() {\n        var scale;\n\n        if (this._isPercentStackedChart()) {\n            scale = this._getPercentStackedScale();\n        } else {\n            scale = this._calculateScale();\n        }\n\n        return scale;\n    }\n});\n\nmodule.exports = AxisScaleMaker;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"