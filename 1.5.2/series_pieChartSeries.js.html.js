tui.util.defineNamespace("fedoc.content", {});
fedoc.content["series_pieChartSeries.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Pie chart series component.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar Series = require('./series'),\n    chartConst = require('../const'),\n    predicate = require('../helpers/predicate'),\n    renderUtil = require('../helpers/renderUtil');\n\nvar PieChartSeries = tui.util.defineClass(Series, /** @lends PieChartSeries.prototype */ {\n    /**\n     * Line chart series component.\n     * @constructs PieChartSeries\n     * @extends Series\n     * @param {object} params parameters\n     *      @param {object} params.model series model\n     *      @param {object} params.options series options\n     *      @param {object} params.theme series theme\n     */\n    init: function(params) {\n        /**\n         * legend align option.\n         * @type {boolean}\n         */\n        this.legendAlign = params.legendAlign;\n\n        /**\n         * chart background.\n         * @type {string}\n         */\n        this.chartBackground = params.chartBackground;\n\n        Series.call(this, params);\n    },\n\n    /**\n     * Make sectors information.\n     * @param {{cx: number, cy: number, r: number}} circleBound circle bound\n     * @returns {Array.&lt;object>} sectors information\n     * @private\n     */\n    _makeSectorData: function(circleBound) {\n        var self = this,\n            seriesGroup = this.dataProcessor.getSeriesDataModel(this.chartType).getFirstSeriesGroup(),\n            cx = circleBound.cx,\n            cy = circleBound.cy,\n            r = circleBound.r,\n            angle = 0,\n            delta = 10,\n            paths;\n\n        paths = seriesGroup.map(function(seriesItem) {\n            var additionalAngle = chartConst.ANGLE_360 * seriesItem.ratio,\n                endAngle = angle + additionalAngle,\n                popupAngle = angle + (additionalAngle / 2),\n                angles = {\n                    start: {\n                        startAngle: angle,\n                        endAngle: angle\n                    },\n                    end: {\n                        startAngle: angle,\n                        endAngle: endAngle\n                    }\n                },\n                positionData = {\n                    cx: cx,\n                    cy: cy,\n                    angle: popupAngle\n                };\n\n            angle = endAngle;\n\n            return {\n                percentValue: seriesItem.ratio,\n                angles: angles,\n                centerPosition: self._getArcPosition(tui.util.extend({\n                    r: (r / 2) + delta\n                }, positionData)),\n                outerPosition: {\n                    start: self._getArcPosition(tui.util.extend({\n                        r: r\n                    }, positionData)),\n                    middle: self._getArcPosition(tui.util.extend({\n                        r: r + delta\n                    }, positionData))\n                }\n            };\n        });\n\n        return paths;\n    },\n\n    /**\n     * Make series data.\n     * @returns {{\n     *      chartBackground: string,\n     *      circleBound: ({cx: number, cy: number, r: number}),\n     *      sectorData: Array.&lt;object>\n     * }} add data for graph rendering\n     * @private\n     * @override\n     */\n    _makeSeriesData: function() {\n        var circleBound = this._makeCircleBound(this.boundsMaker.getDimension('series'), {\n                showLabel: this.options.showLabel,\n                legendAlign: this.legendAlign\n            }),\n            sectorData = this._makeSectorData(circleBound);\n\n        return {\n            chartBackground: this.chartBackground,\n            circleBound: circleBound,\n            sectorData: sectorData\n        };\n    },\n\n    /**\n     * Make circle bound\n     * @param {{width: number, height:number}} dimension chart dimension\n     * @param {{showLabel: boolean, legendAlign: string}} options options\n     * @returns {{cx: number, cy: number, r: number}} circle bounds\n     * @private\n     */\n    _makeCircleBound: function(dimension, options) {\n        var width = dimension.width,\n            height = dimension.height,\n            isSmallPie = predicate.isLegendAlignOuter(options.legendAlign) &amp;&amp; options.showLabel,\n            radiusRate = isSmallPie ? chartConst.PIE_GRAPH_SMALL_RATE : chartConst.PIE_GRAPH_DEFAULT_RATE,\n            diameter = tui.util.multiplication(Math.min(width, height), radiusRate);\n\n        return {\n            cx: tui.util.division(width, 2),\n            cy: tui.util.division(height, 2),\n            r: tui.util.division(diameter, 2)\n        };\n    },\n\n    /**\n     * Get arc position.\n     * @param {object} params parameters\n     *      @param {number} params.cx center x\n     *      @param {number} params.cy center y\n     *      @param {number} params.r radius\n     *      @param {number} params.angle angle(degree)\n     * @returns {{left: number, top: number}} arc position\n     * @private\n     */\n    _getArcPosition: function(params) {\n        return {\n            left: params.cx + (params.r * Math.sin(params.angle * chartConst.RAD)),\n            top: params.cy - (params.r * Math.cos(params.angle * chartConst.RAD))\n        };\n    },\n\n    /**\n     * Render raphael graph.\n     * @param {{width: number, height: number}} dimension dimension\n     * @param {object} seriesData series data\n     * @private\n     * @override\n     */\n    _renderGraph: function(dimension, seriesData) {\n        var showTootltip = tui.util.bind(this.showTooltip, this, {\n                allowNegativeTooltip: !!this.allowNegativeTooltip,\n                chartType: this.chartType\n            }),\n            callbacks = {\n                showTooltip: showTootltip,\n                hideTooltip: tui.util.bind(this.hideTooltip, this)\n            },\n            params = this._makeParamsForGraphRendering(dimension, seriesData);\n\n        this.graphRenderer.render(this.seriesContainer, params, callbacks);\n    },\n\n    /**\n     * Resize.\n     * @override\n     */\n    resize: function() {\n        Series.prototype.resize.apply(this, arguments);\n        this._moveLegendLines();\n    },\n\n    /**\n     * showTooltip is mouseover event callback on series graph.\n     * @param {object} params parameters\n     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not\n     * @param {{top:number, left: number, width: number, height: number}} bound graph bound information\n     * @param {number} groupIndex group index\n     * @param {number} index index\n     * @param {{left: number, top: number}} mousePosition mouse position\n     */\n    showTooltip: function(params, bound, groupIndex, index, mousePosition) {\n        this.fire('showTooltip', tui.util.extend({\n            indexes: {\n                groupIndex: groupIndex,\n                index: index\n            },\n            mousePosition: mousePosition\n        }, params));\n    },\n\n    /**\n     * hideTooltip is mouseout event callback on series graph.\n     * @param {string} id tooltip id\n     */\n    hideTooltip: function() {\n        this.fire('hideTooltip');\n    },\n\n    /**\n     * Make series data by selection.\n     * @param {number} index index\n     * @returns {{indexes: {index: number, groupIndex: number}}} series data\n     * @private\n     */\n    _makeSeriesDataBySelection: function(index) {\n        return {\n            indexes: {\n                index: index,\n                groupIndex: index\n            }\n        };\n    },\n\n    /**\n     * Get series label.\n     * @param {object} params parameters\n     *      @param {string} params.legend legend\n     *      @param {string} params.label label\n     *      @param {string} params.separator separator\n     *      @param {{legendAlign: ?string, showLabel: boolean}} params.options options\n     * @returns {string} series label\n     * @private\n     */\n    _getSeriesLabel: function(params) {\n        var seriesLabel = '';\n\n        if (this.legendAlign) {\n            seriesLabel = '&lt;span class=\"tui-chart-series-legend\">' + params.legend + '&lt;/span>';\n        }\n\n        if (this.options.showLabel) {\n            seriesLabel += (seriesLabel ? params.separator : '') + params.label;\n        }\n\n        return seriesLabel;\n    },\n\n    /**\n     * Render center legend.\n     * @param {object} params parameters\n     *      @param {Array.&lt;object>} params.positions positions\n     *      @param {string} params.separator separator\n     *      @param {object} params.options options\n     *      @param {function} params.funcMoveToPosition function\n     * @param {HTMLElement} seriesLabelContainer series label area element\n     * @private\n     */\n    _renderLegendLabel: function(params, seriesLabelContainer) {\n        var self = this,\n            positions = params.positions,\n            htmls;\n\n        htmls = tui.util.map(this.dataProcessor.getLegendLabels(), function(legend, index) {\n            var html = '',\n                label, position;\n\n            if (positions[index]) {\n                label = self._getSeriesLabel({\n                    legend: legend,\n                    label: self.dataProcessor.getFirstItemLabel(self.chartType),\n                    separator: params.separator\n                });\n                position = params.funcMoveToPosition(positions[index], label);\n                html = self._makeSeriesLabelHtml(position, label, index);\n            }\n\n            return html;\n        });\n        seriesLabelContainer.innerHTML = htmls.join('');\n    },\n\n    /**\n     * Move to center position.\n     * @param {{left: number, top: number}} position position\n     * @param {string} label label\n     * @returns {{left: number, top: number}} center position\n     * @private\n     */\n    _moveToCenterPosition: function(position, label) {\n        var left = position.left - (renderUtil.getRenderedLabelWidth(label, this.theme.label) / 2),\n            top = position.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);\n\n        return {\n            left: left,\n            top: top\n        };\n    },\n\n    /**\n     * Pick poistions from sector data.\n     * @param {string} positionType position type\n     * @returns {Array} positions\n     * @private\n     */\n    _pickPositionsFromSectorData: function(positionType) {\n        return tui.util.map(this.seriesData.sectorData, function(datum) {\n            return datum.percentValue ? datum[positionType] : null;\n        });\n    },\n\n    /**\n     * Render center legend.\n     * @param {HTMLElement} seriesLabelContainer series label area element\n     * @private\n     */\n    _renderCenterLegend: function(seriesLabelContainer) {\n        this._renderLegendLabel({\n            positions: this._pickPositionsFromSectorData('centerPosition'),\n            funcMoveToPosition: tui.util.bind(this._moveToCenterPosition, this),\n            separator: '&lt;br>'\n        }, seriesLabelContainer);\n    },\n\n    /**\n     * Add end position.\n     * @param {number} centerLeft center left\n     * @param {Array.&lt;object>} positions positions\n     * @private\n     */\n    _addEndPosition: function(centerLeft, positions) {\n        tui.util.forEachArray(positions, function(position) {\n            var end;\n\n            if (!position) {\n                return;\n            }\n\n            end = tui.util.extend({}, position.middle);\n            if (end.left &lt; centerLeft) {\n                end.left -= chartConst.SERIES_OUTER_LABEL_PADDING;\n            } else {\n                end.left += chartConst.SERIES_OUTER_LABEL_PADDING;\n            }\n            position.end = end;\n        });\n    },\n\n    /**\n     * Move to outer position.\n     * @param {number} centerLeft center left\n     * @param {object} position position\n     * @param {string} label label\n     * @returns {{left: number, top: number}} outer position\n     * @private\n     */\n    _moveToOuterPosition: function(centerLeft, position, label) {\n        var positionEnd = position.end,\n            left = positionEnd.left,\n            top = positionEnd.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);\n\n        if (left &lt; centerLeft) {\n            left -= renderUtil.getRenderedLabelWidth(label, this.theme.label) + chartConst.SERIES_LABEL_PADDING;\n        } else {\n            left += chartConst.SERIES_LABEL_PADDING;\n        }\n\n        return {\n            left: left,\n            top: top\n        };\n    },\n\n    /**\n     * Render outer legend.\n     * @param {HTMLElement} seriesLabelContainer series label area element\n     * @private\n     */\n    _renderOuterLegend: function(seriesLabelContainer) {\n        var centerLeft = this.boundsMaker.getDimension('chart').width / 2,\n            outerPositions = this._pickPositionsFromSectorData('outerPosition'),\n            filteredPositions = tui.util.filter(outerPositions, function(position) {\n                return position;\n            });\n\n        this._addEndPosition(centerLeft, filteredPositions);\n        this._renderLegendLabel({\n            positions: outerPositions,\n            funcMoveToPosition: tui.util.bind(this._moveToOuterPosition, this, centerLeft),\n            separator: ':&amp;nbsp;'\n        }, seriesLabelContainer);\n\n        this.graphRenderer.renderLegendLines(filteredPositions);\n    },\n\n    /**\n     * Render series label.\n     * @param {HTMLElement} seriesLabelContainer series label area element\n     * @private\n     */\n    _renderSeriesLabel: function(seriesLabelContainer) {\n        var legendAlign = this.legendAlign;\n\n        if (predicate.isLegendAlignOuter(legendAlign)) {\n            this._renderOuterLegend(seriesLabelContainer);\n        } else {\n            this._renderCenterLegend(seriesLabelContainer);\n        }\n    },\n\n    /**\n     * Animate showing about series label area.\n     * @override\n     */\n    animateShowingAboutSeriesLabelArea: function() {\n        this.graphRenderer.animateLegendLines();\n        Series.prototype.animateShowingAboutSeriesLabelArea.call(this);\n    },\n\n    /**\n     * Move legend lines.\n     * @private\n     * @override\n     */\n    _moveLegendLines: function() {\n        var centerLeft = this.boundsMaker.getDimension('chart').width / 2,\n            outerPositions = this._pickPositionsFromSectorData('outerPosition'),\n            filteredPositions = tui.util.filter(outerPositions, function(position) {\n                return position;\n            });\n\n        this._addEndPosition(centerLeft, filteredPositions);\n        this.graphRenderer.moveLegendLines(filteredPositions);\n    },\n\n    /**\n     * On click series.\n     * @param {{left: number, top: number}} position mouse position\n     */\n    onClickSeries: function(position) {\n        this._executeGraphRenderer(position, 'clickSeries');\n    },\n\n    /**\n     * On move series.\n     * @param {{left: number, top: number}} position mouse position\n     */\n    onMoveSeries: function(position) {\n        this._executeGraphRenderer(position, 'moveMouseOnSeries');\n    }\n});\n\ntui.util.CustomEvents.mixin(PieChartSeries);\n\nmodule.exports = PieChartSeries;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"