<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: plugins/raphaelAxisComponent.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: plugins/raphaelAxisComponent.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Raphael title renderer.
 * @author NHN Ent.
 *         FE Development Lab &lt;dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');
var AXIS_BACKGROUND_RIGHT_PADDING = 4;
var snippet = require('tui-code-snippet');

var RaphaelAxisComponent = snippet.defineClass(/** @lends RaphaelAxisComponent.prototype */ {
    init: function() {
        this.ticks = [];
    },

    /**
     * Render background with plot background color
     * @param {object} paper Raphael paper
     * @param {object} position axis position
     * @param {object} dimension axis dimension
     * @param {object} theme chart theme
     * @returns {Element} - raphael &lt;rect> element
     * @private
     */
    renderBackground: function(paper, position, dimension, theme) {
        var background = ((theme &amp;&amp; theme.background) || {});
        var fillColor = (background.color || '#fff');
        var opacity = (background.opacity || 1);

        return raphaelRenderUtil.renderRect(paper, {
            left: 0,
            top: position.top,
            width: dimension.width + position.left - AXIS_BACKGROUND_RIGHT_PADDING,
            height: dimension.height
        }, {
            fill: fillColor,
            opacity: opacity,
            'stroke-width': 0
        });
    },

    /**
     * Render title
     * @param {object} paper raphael paper
     * @param {object} data rendering data
     * @param {string} data.text text content
     * @param {object} data.theme theme object
     * @param {object} data.rotationInfo object
     * @param {object} data.layout dimension and position
     */
    renderTitle: function(paper, data) {
        var theme = data.theme;
        var attributes = {
            'dominant-baseline': 'auto',
            'font-family': theme.fontFamily,
            'font-size': theme.fontSize,
            'font-weight': theme.fontWeight,
            fill: theme.color,
            'text-anchor': 'middle'
        };
        var position = this.calculatePosition(paper, data);
        var title;

        attributes.transform = getCSSTransform(data.rotationInfo, position);
        title = raphaelRenderUtil.renderText(paper, position, data.text, attributes);

        title.node.style.userSelect = 'none';
        title.node.style.cursor = 'default';

        data.set.push(title);
    },

    /**
     * Render Axis label
     * @param {object} data data for render label
     *       @param {{
     *           left: number,
     *           top: number
     *       }} data.positionTopAndLeft left, top positions
     *       @param {string} data.labelText label text
     *       @param {number} data.labelSize label size
     *       @param {object} data.paper raphael paper
     *       @param {boolean} data.isVertical boolean value of axis is vertical
     *       @param {boolean} data.isPositionRight boolean value of axis is right yAxis
     *       @param {object} data.theme theme of label
     */
    renderLabel: function(data) {
        var positionTopAndLeft = data.positionTopAndLeft;
        var labelText = data.labelText;
        var paper = data.paper;
        var isVertical = data.isVertical;
        var isPositionRight = data.isPositionRight;
        var theme = data.theme;
        var attributes = {
            'dominant-baseline': 'central',
            'font-family': theme.fontFamily,
            'font-size': theme.fontSize,
            'font-weight': theme.fontWeight,
            fill: theme.color
        };
        var textObj;

        if (isPositionRight) {
            attributes['text-anchor'] = 'start';
        } else if (isVertical) {
            attributes['text-anchor'] = 'end';
        } else {
            attributes['text-anchor'] = 'middle';
        }

        textObj = raphaelRenderUtil.renderText(paper, positionTopAndLeft, labelText, attributes);

        textObj.node.style.userSelect = 'none';
        textObj.node.style.cursor = 'default';

        data.set.push(textObj);
        this.ticks.push(textObj);
    },

    /**
     * Render rotated Axis label
     * @param {object} data data for render rotated label
     *       @param {{
     *           left: number,
     *           top: number
     *       }} data.positionTopAndLeft left, top positions
     *       @param {string} data.labelText label text
     *       @param {object} data.paper raphael paper
     *       @param {boolean} data.isVertical boolean value of axis is vertical
     *       @param {object} data.theme theme of label
     *       @param {number} data.degree rotation degree
     */
    renderRotatedLabel: function(data) {
        var positionTopAndLeft = data.positionTopAndLeft;
        var labelText = data.labelText;
        var paper = data.paper;
        var theme = data.theme;
        var textObj = raphaelRenderUtil.renderText(paper, positionTopAndLeft, labelText, {
            'dominant-baseline': 'central',
            'font-family': theme.fontFamily,
            'font-size': theme.fontSize,
            'font-weight': theme.fontWeight,
            fill: theme.color,
            'text-anchor': 'end',
            transform: 'r' + (-data.degree) + ',' + (positionTopAndLeft.left + 20) + ',' + (positionTopAndLeft.top)
        });

        textObj.node.style.userSelect = 'none';
        textObj.node.style.cursor = 'arrow';

        data.set.push(textObj);
        this.ticks.push(textObj);
    },

    /**
     * Render ticks on given paper
     * @param {object} data data for rendering ticks
     */
    renderTicks: function(data) {
        var self = this;
        var paper = data.paper;
        var positions = data.positions;
        var additionalSize = data.additionalSize;
        var isVertical = data.isVertical;
        var isCenter = data.isCenter;
        var isPositionRight = data.isPositionRight;
        var tickColor = data.tickColor;
        var layout = data.layout;
        var rightEdgeOfAxis = layout.position.left + layout.dimension.width;
        var baseTop = layout.position.top;
        var baseLeft = layout.position.left;
        var tick;

        snippet.forEach(positions, function(position) {
            var pathString = 'M';

            position += additionalSize;

            if (position > layout.dimension.width) {
                return;
            }

            if (isVertical) {
                if (isCenter) {
                    pathString += baseLeft + ',' + (baseTop + position);
                    pathString += 'H' + (baseLeft + 5);

                    pathString += 'M' + rightEdgeOfAxis + ',' + (baseTop + position);
                    pathString += 'H' + (rightEdgeOfAxis - 5);
                } else if (isPositionRight) {
                    pathString += baseLeft + ',' + (baseTop + position);
                    pathString += 'H' + (baseLeft + 5);
                } else {
                    pathString += rightEdgeOfAxis + ',' + (baseTop + position);
                    pathString += 'H' + (rightEdgeOfAxis - 5);
                }
            } else {
                pathString += (baseLeft + position) + ',' + baseTop;
                pathString += 'V' + (baseTop + 5);
            }

            if (!isNaN(position)) {
                tick = paper.path(pathString).attr({
                    stroke: tickColor
                });
                data.set.push(tick);
                self.ticks.push(tick);
            }
        });
    },

    /**
     * Render tick line  on given paper
     * @param {number} data data for render tick line
     * @param {number} data.areaSize area size width or height
     * @param {object} data.paper raphael paper
     * @param {boolean} data.isNotDividedXAxis boolean value for XAxis divided or not
     * @param {number} data.additionalSize additional size for position and line length
     * @param {number} data.additionalWidth additional width of tick line paper
     * @param {number} data.additionalHeight additional height of tick line paper
     * @param {boolean} data.isPositionRight boolean value of right yAxis or not
     * @param {boolean} data.isCenter boolean value of center yAxis or not
     * @param {boolean} data.isVertical boolean value of vertical axis or not
     */
    renderTickLine: function(data) {
        var areaSize = data.areaSize;
        var lineSize = areaSize;
        var paper = data.paper;
        var layout = data.layout;
        var isNotDividedXAxis = data.isNotDividedXAxis;
        var additionalSize = data.additionalSize;
        var isPositionRight = data.isPositionRight;
        var isCenter = data.isCenter;
        var isVertical = data.isVertical;
        var tickColor = data.tickColor;
        var pathString = 'M';
        var baseTop = layout.position.top;
        var baseLeft = layout.position.left;
        var verticalTickLineEndYCoord = layout.dimension.height + baseTop;
        var rightEdgeOfAxis = baseLeft + layout.dimension.width;
        var lineStartYCoord, lineEndXCoord, lineEndYCoord;

        if (isPositionRight) {
            pathString += baseLeft + ',' + baseTop;
            pathString += 'V' + verticalTickLineEndYCoord;
        } else if (isVertical) {
            lineStartYCoord = baseTop;
            pathString += rightEdgeOfAxis + ',' + lineStartYCoord;

            if (isCenter) {
                pathString += 'V' + verticalTickLineEndYCoord;
                pathString += 'M' + baseLeft + ',' + lineStartYCoord;
                pathString += 'V' + verticalTickLineEndYCoord;
            } else {
                lineEndYCoord = baseTop + lineSize;
                pathString += 'V' + lineEndYCoord;
            }
        } else {
            if (isNotDividedXAxis) {
                pathString += baseLeft;
            } else {
                pathString += (baseLeft + additionalSize);
            }
            pathString += ',' + baseTop + 'H';

            lineEndXCoord = (baseLeft + lineSize);

            if (!isNotDividedXAxis) {
                lineEndXCoord += additionalSize;
            }
            pathString += lineEndXCoord;
        }

        data.set.push(paper.path(pathString).attr({
            'stroke-width': 1,
            stroke: tickColor
        }));
    },

    /**
     * Animate ticks for adding data
     * @param {number} tickSize tick size of moving
     */
    animateForAddingData: function(tickSize) {
        snippet.forEach(this.ticks, function(tick) {
            tick.animate({
                transform: 't-' + tickSize + ',0'
            }, 300);
        });
    },

    /**
     * Calculate axis title position, and transforma
     * @param {Raphael.paper} paper - paper
     * @param {object} data - options for calcultating title position
     *  @param {object} data.rotationInfo - isCenter, isVertical, isPositionRight
     *  @param {object} data.text - text
     *  @param {object} data.theme - theme
     *  @param {object} data.layout - layout
     * @returns {object} position - top, left
     */
    calculatePosition: function(paper, data) {
        var rotationInfo = data.rotationInfo;
        var textHeight = getTextHeight(data.text, data.theme);
        var layout = data.layout;
        var centerPosition = calculateCenterPosition(
            rotationInfo.isVertical, layout.dimension, layout.position
        );
        var position = {};

        if (rotationInfo.isCenter) {
            position.top = paper.height - (textHeight / 2);
            position.left = layout.position.left + (layout.dimension.width / 2);
        } else if (rotationInfo.isPositionRight) {
            position.top = centerPosition;
            position.left = layout.position.left + layout.dimension.width;
        } else if (rotationInfo.isVertical) {
            position.top = centerPosition;
            position.left = layout.position.left + (textHeight / 2);
        } else {
            position.top = layout.position.top + layout.dimension.height;
            position.left = centerPosition;
        }

        if (!rotationInfo.isCenter) {
            addOffset(position, data.offset);
        }

        return position;
    }
});

/**
 * Get a text height by theme
 * @param {string} text - text
 * @param {object} theme - axis theme
 * @returns {number} text height
 * @ignore
 */
function getTextHeight(text, theme) {
    var titleSize = raphaelRenderUtil.getRenderedTextSize(text, theme.fontSize, theme.fontFamily);

    return titleSize.height;
}

/**
 * Test axis title need to rotate
 * @param {object} rotationInfo - rotationInfo
 * @returns {boolean} - whether it needs to rotate
 * @ignore
 */
function doesTitleRotate(rotationInfo) {
    if (snippet.isExisty(rotationInfo.rotateTitle)) {
        return rotationInfo.rotateTitle === true;
    }

    return true;
}

/**
 * Calculate center position
 * @param {boolean} isVertical - is vertical axis
 * @param {object} dimension - width, height
 * @param {object} position - top, left
 * @returns {number} - center position
 * @ignore
 */
function calculateCenterPosition(isVertical, dimension, position) {
    var size = isVertical ? dimension.height : dimension.width;
    var margin = isVertical ? position.top : position.left;

    return (size / 2) + margin;
}

/**
 * Add offset to position
 * @param {object} position - top, left
 * @param {object} offset - x, y
 * @ignore
 */
function addOffset(position, offset) {
    if (!offset) {
        return;
    }

    if (offset.x) {
        position.left += offset.x;
    }
    if (offset.y) {
        position.top += offset.y;
    }
}

/**
 * Get transform by rotation info
 * @param {object} rotationInfo - isCenter, isVertical, isPositionRight
 * @param {object} position - top, left
 * @returns {string} css transform
 * @ignore
 */
function getCSSTransform(rotationInfo, position) {
    var transform = 'none';
    if (rotationInfo.isPositionRight) {
        transform = 'r90,' + position.left + ',' + position.top;
    } else if (rotationInfo.isVertical &amp;&amp; doesTitleRotate(rotationInfo)) {
        transform = 'r-90,' + position.left + ',' + position.top;
    }

    return transform;
}

module.exports = RaphaelAxisComponent;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AreaChart.html">AreaChart</a></li><li><a href="BarChart.html">BarChart</a></li><li><a href="BoxplotChart.html">BoxplotChart</a></li><li><a href="BubbleChart.html">BubbleChart</a></li><li><a href="ChartBase.html">ChartBase</a></li><li><a href="ColumnChart.html">ColumnChart</a></li><li><a href="ColumnLineComboChart.html">ColumnLineComboChart</a></li><li><a href="HeatmapChart.html">HeatmapChart</a></li><li><a href="LineAreaComboChart.html">LineAreaComboChart</a></li><li><a href="LineChart.html">LineChart</a></li><li><a href="LineScatterComboChart.html">LineScatterComboChart</a></li><li><a href="MapChart.html">MapChart</a></li><li><a href="MapChartMapModel.html">MapChartMapModel</a></li><li><a href="PieChart.html">PieChart</a></li><li><a href="PieDonutComboChart.html">PieDonutComboChart</a></li><li><a href="Plot.html">Plot</a></li><li><a href="RadialChart.html">RadialChart</a></li><li><a href="RaphaelRadialLineSeries.html">RaphaelRadialLineSeries</a></li><li><a href="ScatterChart.html">ScatterChart</a></li><li><a href="SeriesDataModel.html">SeriesDataModel</a></li><li><a href="Title.html">Title</a></li><li><a href="TreemapChart.html">TreemapChart</a></li></ul><h3>Namespaces</h3><ul><li><a href="tui.chart.html">chart</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-example01-01-bar-chart-basic.html">1.1 [Bar Chart] basic</a></li><li><a href="tutorial-example01-02-bar-chart-negative-data.html">1.2 [Bar Chart] negative data</a></li><li><a href="tutorial-example01-03-bar-chart-normal-stack.html">1.3 [Bar Chart] normal stack</a></li><li><a href="tutorial-example01-04-bar-chart-diverging.html">1.4 [Bar Chart] diverging</a></li><li><a href="tutorial-example01-05-bar-chart-diverging-and-center-yaxis.html">1.5 [Bar Chart] diverging and center yAxis</a></li><li><a href="tutorial-example01-06-bar-chart-range-data.html">1.6 [Bar Chart] range data</a></li><li><a href="tutorial-example02-01-column-chart-basic.html">2.1 [Column Chart] basic</a></li><li><a href="tutorial-example02-02-column-chart-negative-data.html">2.2 [Column Chart] negative data</a></li><li><a href="tutorial-example02-03-column-chart-percent-stack.html">2.3 [Column Chart] percent stack</a></li><li><a href="tutorial-example02-04-column-chart-group-stack.html">2.4 [Column Chart] group stack</a></li><li><a href="tutorial-example02-05-column-chart-diverging-and-stacked.html">2.5 [Column Chart] diverging and stacked</a></li><li><a href="tutorial-example03-01-line-chart-basic.html">3.1 [Line Chart] basic</a></li><li><a href="tutorial-example03-02-line-chart-spline.html">3.2 [Line Chart] spline</a></li><li><a href="tutorial-example03-03-line-chart-coordinate-data.html">3.3 [Line Chart] coordinate data</a></li><li><a href="tutorial-example03-04-line-chart-without-series-data.html">3.4 [Line Chart] without series data</a></li><li><a href="tutorial-example03-05-line-chart-synchronized-tooltip.html">3.5 [Line Chart] synchronized tooltip</a></li><li><a href="tutorial-example04-01-area-chart-basic.html">4.1 [Area Chart] basic</a></li><li><a href="tutorial-example04-02-area-chart-normal-stack.html">4.2 [Area Chart] normal stack</a></li><li><a href="tutorial-example04-03-area-chart-range-data.html">4.3 [Area Chart] range data</a></li><li><a href="tutorial-example04-04-area-chart-auto-tick-zoomable.html">4.4 [Area Chart] auto tick and zoomable</a></li><li><a href="tutorial-example04-05-area-chart-merge-overlapping-plotbands.html">4.5 [Area Chart] merge overlapping plotbands</a></li><li><a href="tutorial-example05-01-bubble-chart-basic.html">5.1 [Bubble Chart] basic</a></li><li><a href="tutorial-example06-01-scatter-chart-basic.html">6.1 [Scatter Chart] basic</a></li><li><a href="tutorial-example07-01-pie-chart-basic.html">7.1 [Pie Chart] basic</a></li><li><a href="tutorial-example07-02-pie-chart-center-legend.html">7.2 [Pie Chart] center legend</a></li><li><a href="tutorial-example07-03-pie-chart-outer-legend.html">7.3 [Pie Chart] outer legend</a></li><li><a href="tutorial-example07-04-pie-chart-donut.html">7.4 [Pie Chart] donut</a></li><li><a href="tutorial-example07-05-pie-chart-semi-circle-donut.html">7.5 [Pie Chart] semi circle donut</a></li><li><a href="tutorial-example08-01-combo-chart-column-and-line.html">8.1 [Combo Chart] column and line</a></li><li><a href="tutorial-example08-02-combo-chart-pie-and-donut.html">8.2 [Combo Chart] pie and donut</a></li><li><a href="tutorial-example08-03-combo-chart-line-and-area.html">8.3 [Combo Chart] line and area</a></li><li><a href="tutorial-example08-04-combo-chart-line-and-scatter.html">8.4 [Combo Chart] line and scatter</a></li><li><a href="tutorial-example09-01-map-chart-world-map.html">9.1 [Map chart] world map</a></li><li><a href="tutorial-example09-02-map-chart-south-korea-map.html">9.2 [Map chart] south korea map</a></li><li><a href="tutorial-example09-03-map-chart-usa-map.html">9.3 [Map chart] USA map</a></li><li><a href="tutorial-example09-04-map-chart-china-map.html">9.4 [Map chart] china map</a></li><li><a href="tutorial-example09-05-map-chart-japan-map.html">9.5 [Map chart] japan map</a></li><li><a href="tutorial-example09-06-map-chart-singapore-map.html">9.6 [Map chart] singapore map</a></li><li><a href="tutorial-example09-07-map-chart-thailand-map.html">9.7 [Map chart] thailand map</a></li><li><a href="tutorial-example09-08-map-chart-taiwan-map.html">9.8 [Map chart] taiwan map</a></li><li><a href="tutorial-example10-01-heatmap-chart-basic.html">10.1 [Heatmap chart] basic</a></li><li><a href="tutorial-example11-01-treemap-chart-basic.html">11.1 [Treemap chart] basic</a></li><li><a href="tutorial-example11-02-treemap-chart-useColorValue-option.html">11.2 [Treemap chart] useColorValue option</a></li><li><a href="tutorial-example12-01-dynamic-chart-append-and-shift-data-dynamically.html">12.1 [Dynamic chart] append and shift data dynamically</a></li><li><a href="tutorial-example13-01-radial-chart-basic.html">13.1 [Radial chart] basic</a></li><li><a href="tutorial-example14-01-boxplot-chart-basic.html">14.1 [Boxplot chart] basic</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Thu Jan 04 2018 11:13:14 GMT+0900 (KST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
