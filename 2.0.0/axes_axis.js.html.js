tui.util.defineNamespace("fedoc.content", {});
fedoc.content["axes_axis.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview  Axis component.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar dom = require('../helpers/domHandler'),\n    chartConst = require('../const'),\n    calculator = require('../helpers/calculator'),\n    renderUtil = require('../helpers/renderUtil'),\n    axisTemplate = require('./axisTemplate');\n\nvar Axis = tui.util.defineClass(/** @lends Axis.prototype */ {\n    /**\n     * Axis component.\n     * @constructs Axis\n     * @param {object} params parameters\n     *      @param {{\n     *          labels: Array.&lt;string>,\n     *          tickCount: number,\n     *          isLabelAxis: boolean,\n     *          isVertical: boolean\n     *      }} params.data axis data\n     *      @param {object} params.bound axis bound\n     *      @param {object} params.theme axis theme\n     *      @param {object} params.options axis options\n     */\n    init: function(params) {\n        /**\n         * Axis view className\n         * @type {string}\n         */\n        this.className = 'tui-chart-axis-area';\n\n        /**\n         * Chart type\n         * @type {string}\n         */\n        this.chartType = params.chartType;\n\n        /**\n         * Data processor\n         * @type {DataProcessor}\n         */\n        this.dataProcessor = params.dataProcessor;\n\n        /**\n         * Bounds maker\n         * @type {BoundsMaker}\n         */\n        this.boundsMaker = params.boundsMaker;\n\n        /**\n         * Options\n         * @type {object}\n         */\n        this.options = params.options || {};\n\n        /**\n         * Theme\n         * @type {object}\n         */\n        this.theme = params.theme || {};\n\n        /**\n         * Whether label type or not.\n         * @type {boolean}\n         */\n        this.isLabel = params.isLabel;\n\n        /**\n         * Data for rendering\n         * @type {object}\n         */\n        this.data = {};\n    },\n\n    /**\n     * Make height of x axis area.\n     * @returns {number} height\n     * @private\n     */\n    _makeXAxisHeight: function() {\n        var title = this.options.title;\n        var titleHeight = renderUtil.getRenderedLabelHeight(title, this.theme.title);\n        var titleAreaHeight = titleHeight ? (titleHeight + chartConst.TITLE_PADDING) : 0;\n        var labelHeight = renderUtil.getRenderedLabelHeight(chartConst.MAX_HEIGHT_WORLD, this.theme.label);\n\n        return titleAreaHeight + labelHeight + chartConst.CHART_PADDING;\n    },\n\n    /**\n     * Make width of y axis area.\n     * @param {Array.&lt;string | number>} labels labels\n     * @param {{title: ?string, isCenter: ?boolean, rotateTitle: ?boolean}} options - options\n     * @returns {number}\n     * @private\n     */\n    _makeYAxisWidth: function(labels, options) {\n        var title = options.title || '';\n        var theme = this.theme;\n        var titleAreaWidth = 0;\n        var width = 0;\n\n        if (options.isCenter) {\n            width += chartConst.AXIS_LABEL_PADDING;\n        } else if (options.rotateTitle === false) {\n            titleAreaWidth = renderUtil.getRenderedLabelWidth(title, theme.title) + chartConst.TITLE_PADDING;\n        } else {\n            titleAreaWidth = renderUtil.getRenderedLabelHeight(title, theme.title) + chartConst.TITLE_PADDING;\n        }\n\n        width += renderUtil.getRenderedLabelsMaxWidth(labels, theme.label) + titleAreaWidth +\n            chartConst.AXIS_LABEL_PADDING;\n\n        return width;\n    },\n\n    /**\n     * Whether valid axis or not.\n     * @returns {boolean} whether valid axis or not.\n     * @private\n     */\n    _isValidAxis: function() {\n        var isValid = true;\n\n        if (this.componentName === 'rightYAxis') {\n            isValid = this.dataProcessor.isValidAllSeriesDataModel();\n        }\n\n        return isValid;\n    },\n\n    /**\n     * Register legend dimension to boundsMaker.\n     */\n    registerDimension: function() {\n        var dimension = {};\n\n        if (!this._isValidAxis()) {\n            return;\n        }\n\n        if (this.componentType === 'xAxis') {\n            dimension.height = this._makeXAxisHeight();\n            this.boundsMaker.registerBaseDimension(this.componentName, dimension);\n        } else if (this.isLabel) {\n            dimension.width = this._makeYAxisWidth(this.dataProcessor.getCategories(), this.options);\n            this.boundsMaker.registerBaseDimension(this.componentName, dimension);\n        }\n    },\n\n    /**\n     * Register legend additional dimension to boundsMaker.\n     */\n    registerAdditionalDimension: function() {\n        var axesData = this.boundsMaker.axesData;\n        var dimension, options;\n\n        if (!this._isValidAxis()) {\n            return;\n        }\n\n        if ((this.componentType === 'yAxis') &amp;&amp; !this.isLabel) {\n            if (this.componentName === 'rightYAxis') {\n                options = this.options;\n            } else {\n                options = axesData.yAxis.options;\n            }\n\n            dimension = {\n                width: this._makeYAxisWidth(axesData.yAxis.labels, options)\n            };\n\n            this.boundsMaker.registerBaseDimension(this.componentName, dimension);\n        }\n    },\n\n    /**\n     * Render opposite side tick area.\n     * @param {string} tickHtml tick html\n     * @returns {?HTMLElement} right tick area element\n     * @private\n     */\n    _renderOppositeSideTickArea: function(tickHtml) {\n        var tickContainer;\n\n        if (this.options.isCenter) {\n            tickContainer = dom.create('DIV', 'tui-chart-tick-area opposite-side');\n            tickContainer.innerHTML = tickHtml;\n        }\n\n        return tickContainer;\n    },\n\n    /**\n     * Add css classes.\n     * @param {HTMLElement} axisContainer axis container\n     * @private\n     */\n    _addCssClasses: function(axisContainer) {\n        dom.addClass(axisContainer, this.data.isVertical ? 'vertical' : 'horizontal');\n        dom.addClass(axisContainer, this.options.isCenter ? 'center' : '');\n        dom.addClass(axisContainer, this.options.divided ? 'division' : '');\n        dom.addClass(axisContainer, this.data.isPositionRight ? 'right' : '');\n    },\n\n\n    /**\n     * Render child containers like title area, lable area and tick area.\n     * @param {number} size xAxis width or yAxis height\n     * @param {number} width axis width\n     * @param {number} tickCount tick count\n     * @param {Array.&lt;number|string>} categories categories\n     * @param {number} additionalWidth aditional width\n     * @returns {Array.&lt;HTMLElement>} child containers\n     * @private\n     */\n    _renderChildContainers: function(size, width, tickCount, categories, additionalWidth) {\n        var titleContainer = this._renderTitleArea(size),\n            labelContainer = this._renderLabelArea(size, width, tickCount, categories, additionalWidth),\n            childContainers = [titleContainer, labelContainer],\n            isLineType = this.data.isVertical &amp;&amp; this.data.aligned,\n            tickContainer, oppositeSideTickContainer;\n\n        if (!isLineType) {\n            tickContainer = this._renderTickArea(size, tickCount, categories, additionalWidth);\n            oppositeSideTickContainer = this._renderOppositeSideTickArea(tickContainer.innerHTML);\n            childContainers = childContainers.concat([tickContainer, oppositeSideTickContainer]);\n        }\n\n        return childContainers;\n    },\n\n    /**\n     Render division xAxis area if yAxis rendered in the center.\n     * @param {HTMLElement} axisContainer axis container element\n     * @param {number} width axis area width\n     * @private\n     */\n    _renderDivisionAxisArea: function(axisContainer, width) {\n        var leftWidth = Math.round(width / 2),\n            rightWidth = width - leftWidth,\n            tickCount = this.data.tickCount,\n            halfTickCount = parseInt(tickCount / 2, 10) + 1,\n            categories = this.data.labels,\n            leftCates = categories.slice(0, halfTickCount),\n            rightCates = categories.slice(halfTickCount - 1, tickCount),\n            additionWidth = leftWidth + this.boundsMaker.getDimension('yAxis').width,\n            leftContainers, rightContainers, rightTitleContainer;\n\n        leftContainers = this._renderChildContainers(leftWidth, leftWidth, halfTickCount, leftCates);\n        rightContainers = this._renderChildContainers(rightWidth, rightWidth, halfTickCount, rightCates, additionWidth);\n\n        rightTitleContainer = rightContainers[0];\n        dom.addClass(rightTitleContainer, 'right');\n        dom.append(axisContainer, leftContainers.concat(rightContainers));\n    },\n\n    /**\n     * Render single axis area if yAxis did not rendered in the center.\n     * @param {HTMLElement} axisContainer axis container element\n     * @param {{width: number, height: number}} dimension axis area dimension\n     * @private\n     */\n    _renderSingleAxisArea: function(axisContainer, dimension) {\n        var isVertical = !!this.data.isVertical,\n            size = isVertical ? dimension.height : dimension.width,\n            childContainers = this._renderChildContainers(size, dimension.width, this.data.tickCount, this.data.labels);\n\n        dom.append(axisContainer, childContainers);\n    },\n\n    /**\n     * Render axis area.\n     * @param {HTMLElement} axisContainer axis area element\n     * @param {{isVertical: boolean, isPositionRight: boolean, aligned: aligned}} data rendering data\n     * @private\n     */\n    _renderAxisArea: function(axisContainer) {\n        var dimension = tui.util.extend({}, this.boundsMaker.getDimension(this.componentName));\n\n        this._addCssClasses(axisContainer);\n\n        if (this.options.divided) {\n            this._renderDivisionAxisArea(axisContainer, dimension.width);\n            dimension.width += this.boundsMaker.getDimension('yAxis').width;\n        } else {\n            this._renderSingleAxisArea(axisContainer, dimension);\n            dimension.width += this.options.isCenter ? 2 : 0;\n        }\n\n        renderUtil.renderDimension(axisContainer, dimension);\n        renderUtil.renderPosition(axisContainer, this.boundsMaker.getPosition(this.componentName));\n    },\n\n    /**\n     * Render axis component.\n     * @param {{isVertical: boolean, isPositionRight: boolean, aligned: aligned}} data rendering data\n     * @returns {HTMLElement} axis area base element\n     */\n    render: function(data) {\n        var el = dom.create('DIV', this.className);\n\n        this.data = data;\n        this._renderAxisArea(el);\n        this.axisContainer = el;\n        return el;\n    },\n\n    /**\n     * Rerender axis component.\n     * @param {object} data rendering data\n     */\n    rerender: function(data) {\n        this.axisContainer.innerHTML = '';\n\n        if (this._isValidAxis()) {\n            if (data.options) {\n                this.options = data.options;\n            }\n            this.data = data;\n            this._renderAxisArea(this.axisContainer);\n        }\n    },\n\n    /**\n     * Resize axis component.\n     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound axis bound\n     * @param {object} data rendering data\n     */\n    resize: function(bound, data) {\n        this.rerender(bound, data);\n    },\n\n    /**\n     * Make cssText from position map for css.\n     * @param {object.&lt;string, number>} positionMap - position map for css\n     * @returns {string}\n     * @private\n     */\n    _makeCssTextFromPositionMap: function(positionMap) {\n        return tui.util.map(positionMap, function(value, name) {\n            return renderUtil.concatStr(name, ':', value, 'px');\n        }).join(';');\n    },\n\n    /**\n     * Make position map for center align option of y axis.\n     * @returns {{left: number, bottom: number}}\n     * @private\n     */\n    _makePositionMapForCenterAlign: function() {\n        var titleWidth = renderUtil.getRenderedLabelWidth(this.options.title, this.theme.title);\n        var yAxisWidth = this.boundsMaker.getDimension('yAxis').width;\n        var xAxisHeight = this.boundsMaker.getDimension('xAxis').height;\n\n        return {\n            left: (yAxisWidth - titleWidth) / 2,\n            bottom: -xAxisHeight\n        };\n    },\n\n    /**\n     * Make right position for right y axis.\n     * @param {number} size - width or height\n     * @returns {number}\n     * @private\n     */\n    _makeRightPosition: function(size) {\n        var rightPosition;\n\n        if (renderUtil.isIE7() || this.options.rotateTitle === false) {\n            rightPosition = 0;\n        } else {\n            rightPosition = -size;\n        }\n\n        return rightPosition;\n    },\n\n    /**\n     * Make top position.\n     * @param {number} size - width or height\n     * @returns {?number}\n     * @private\n     */\n    _makeTopPosition: function(size) {\n        var topPosition = null;\n        var titleHeight;\n\n        if (this.options.rotateTitle === false) {\n            titleHeight = renderUtil.getRenderedLabelHeight(this.options.title, this.theme.title);\n            topPosition = (size - titleHeight) / 2;\n        } else if (this.data.isPositionRight) {\n            topPosition = 0;\n        } else if (!renderUtil.isOldBrowser()) {\n            topPosition = size;\n        }\n\n        return topPosition;\n    },\n\n    /**\n     * Make positionMap for not center align.\n     * @param {number} size - width or height\n     * @returns {object.&lt;string, number>}\n     * @private\n     */\n    _makePositionMapForNotCenterAlign: function(size) {\n        var positionMap = {};\n        var topPosition;\n\n        if (this.data.isPositionRight) {\n            positionMap.right = this._makeRightPosition(size);\n        } else {\n            positionMap.left = 0;\n        }\n\n        topPosition = this._makeTopPosition(size);\n\n        if (!tui.util.isNull(topPosition)) {\n            positionMap.top = topPosition;\n        }\n\n        return positionMap;\n    },\n\n    /**\n     * Render css style of title area\n     * @param {HTMLElement} titleContainer title element\n     * @param {number} size width or height\n     * @private\n     */\n    _renderTitleAreaStyle: function(titleContainer, size) {\n        var cssPositionMap;\n        var cssText;\n\n        if (this.options.isCenter) {\n            cssPositionMap = this._makePositionMapForCenterAlign();\n        } else {\n            cssPositionMap = this._makePositionMapForNotCenterAlign(size);\n        }\n\n        if (this.options.rotateTitle !== false) {\n            cssPositionMap.width = size;\n        }\n\n        cssText = this._makeCssTextFromPositionMap(cssPositionMap);\n        titleContainer.style.cssText += ';' + cssText;\n    },\n\n    /**\n     * Title area renderer\n     * @param {?number} size (width or height)\n     * @returns {HTMLElement} title element\n     * @private\n     */\n    _renderTitleArea: function(size) {\n        var titleContainer = renderUtil.renderTitle(this.options.title, this.theme.title, 'tui-chart-title-area');\n\n        if (titleContainer &amp;&amp; this.data.isVertical) {\n            this._renderTitleAreaStyle(titleContainer, size);\n        }\n\n        if (this.options.rotateTitle !== false) {\n            dom.addClass(titleContainer, 'rotation');\n        }\n\n        return titleContainer;\n    },\n\n    /**\n     * Render tick area.\n     * @param {number} size size or height\n     * @param {number} tickCount tick count\n     * @param {Array.&lt;string>} categories categories\n     * @param {?number} additionalSize additional size (width or height)\n     * @returns {HTMLElement} tick area element\n     * @private\n     */\n    _renderTickArea: function(size, tickCount, categories, additionalSize) {\n        var data = this.data,\n            isSingleXAxis = !data.isVertical &amp;&amp; !this.options.divided,\n            tickColor = this.theme.tickColor,\n            positions = calculator.makeTickPixelPositions(size, tickCount),\n            elTickArea = dom.create('DIV', 'tui-chart-tick-area'),\n            template = axisTemplate.tplAxisTick,\n            tickLineExtend = isSingleXAxis ? 1 : 0,\n            posType, lineSizeType, lineHtml, ticksHtml;\n\n        additionalSize = additionalSize || 0;\n\n        if (data.isVertical) {\n            posType = 'bottom';\n            lineSizeType = 'height';\n        } else {\n            posType = 'left';\n            lineSizeType = 'width';\n        }\n\n        lineHtml = axisTemplate.tplTickLine({\n            positionType: posType,\n            positionValue: additionalSize - tickLineExtend,\n            sizeType: lineSizeType,\n            size: size + tickLineExtend\n        });\n\n        ticksHtml = tui.util.map(positions, function(position, index) {\n            var tickHtml, cssTexts;\n\n            position -= (index === 0 &amp;&amp; isSingleXAxis) ? 1 : 0;\n            cssTexts = [\n                renderUtil.concatStr('background-color:', tickColor),\n                renderUtil.concatStr(posType, ': ', additionalSize + position, 'px')\n            ].join(';');\n            tickHtml = template({cssText: cssTexts});\n\n            return tickHtml;\n        }).join('');\n\n        elTickArea.innerHTML = lineHtml + ticksHtml;\n\n        return elTickArea;\n    },\n\n    /**\n     * Make cssText of vertical label.\n     * @param {number} axisWidth axis width\n     * @param {number} titleAreaWidth title area width\n     * @returns {string} cssText\n     * @private\n     */\n    _makeVerticalLabelCssText: function(axisWidth, titleAreaWidth) {\n        return ';width:' + (axisWidth - titleAreaWidth + chartConst.V_LABEL_RIGHT_PADDING) + 'px';\n    },\n\n    /**\n     * Apply css style of label area.\n     * @param {HTMLElement} labelContainer label container\n     * @param {number} axisWidth axis width\n     * @private\n     */\n    _applyLabelAreaStyle: function(labelContainer, axisWidth) {\n        var cssText = renderUtil.makeFontCssText(this.theme.label),\n            titleAreaWidth;\n\n        if (this.data.isVertical) {\n            titleAreaWidth = this._getRenderedTitleHeight() + chartConst.TITLE_AREA_WIDTH_PADDING;\n            cssText += this._makeVerticalLabelCssText(axisWidth, titleAreaWidth);\n        }\n\n        labelContainer.style.cssText = cssText;\n    },\n\n    /**\n     * Render label area.\n     * @param {number} size label area size\n     * @param {number} axisWidth axis area width\n     * @param {number} tickCount tick count\n     * @param {Array.&lt;string>} categories categories\n     * @param {?number} additionalSize additional size (width or height)\n     * @returns {HTMLElement} label area element\n     * @private\n     */\n    _renderLabelArea: function(size, axisWidth, tickCount, categories, additionalSize) {\n        var labelContainer = dom.create('DIV', 'tui-chart-label-area'),\n            tickPixelPositions = calculator.makeTickPixelPositions(size, tickCount),\n            labelSize = tickPixelPositions[1] - tickPixelPositions[0],\n            labelsHtml;\n\n        additionalSize = additionalSize || 0;\n        labelsHtml = this._makeLabelsHtml(tickPixelPositions, categories, labelSize, additionalSize);\n        labelContainer.innerHTML = labelsHtml;\n\n        this._applyLabelAreaStyle(labelContainer, axisWidth);\n        this._changeLabelAreaPosition(labelContainer, labelSize);\n\n        return labelContainer;\n    },\n\n    /**\n     * Get height of title area ;\n     * @returns {number} height\n     * @private\n     */\n    _getRenderedTitleHeight: function() {\n        var title = this.options.title,\n            theme = this.theme.title,\n            result = title ? renderUtil.getRenderedLabelHeight(title, theme) : 0;\n\n        return result;\n    },\n\n    /**\n     * Make cssText of label.\n     * @param {number} labelSize label size (width or height)\n     * @returns {string[]} cssTexts\n     * @private\n     */\n    _makeLabelCssText: function(labelSize) {\n        var isVertical = this.data.isVertical,\n            cssTexts = [];\n\n        if (isVertical &amp;&amp; this.data.isLabelAxis) {\n            cssTexts.push(renderUtil.concatStr('height:', labelSize, 'px'));\n            cssTexts.push(renderUtil.concatStr('line-height:', labelSize, 'px'));\n        } else if (!isVertical) {\n            cssTexts.push(renderUtil.concatStr('width:', labelSize, 'px'));\n        }\n\n        return cssTexts.length ? cssTexts.join(';') + ';' : '';\n    },\n\n    /**\n     * Calculate rotation moving position.\n     * @param {object} params parameters\n     *      @param {number} params.labelHeight label height\n     *      @param {number} params.left normal left\n     *      @param {number} params.moveLeft move left\n     *      @param {number} params.top top\n     * @returns {{top:number, left: number}} position\n     * @private\n     */\n    _calculateRotationMovingPosition: function(params) {\n        var moveLeft = params.moveLeft,\n            degree = this.boundsMaker.xAxisDegree;\n\n        if (degree === chartConst.ANGLE_85) {\n            moveLeft += calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, params.labelHeight / 2);\n        }\n\n        return {\n            top: params.top,\n            left: params.left - moveLeft\n        };\n    },\n\n    /**\n     * Calculate rotation moving position for old browser(IE7, IE8).\n     * @param {object} params parameters\n     *      @param {number} params.labelWidth label width\n     *      @param {number} params.labelHeight label height\n     *      @param {number} params.left normal left\n     *      @param {(string | number)} params.label label\n     *      @param {object} theme label theme\n     * @returns {{top:number, left: number}} position\n     * @private\n     */\n    _calculateRotationMovingPositionForOldBrowser: function(params) {\n        var labelWidth = renderUtil.getRenderedLabelWidth(params.label, params.theme),\n            degree = this.boundsMaker.xAxisDegree,\n            smallAreaWidth = calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, params.labelHeight / 2),\n            newLabelWidth = (calculator.calculateAdjacent(degree, labelWidth / 2) + smallAreaWidth) * 2,\n            changedWidth = renderUtil.isIE7() ? 0 : (labelWidth - newLabelWidth),\n            moveLeft = (params.labelWidth / 2) - (smallAreaWidth * 2);\n\n        if (degree === chartConst.ANGLE_85) {\n            moveLeft += smallAreaWidth;\n        }\n\n        return {\n            top: chartConst.XAXIS_LABEL_TOP_MARGIN,\n            left: params.left + changedWidth - moveLeft\n        };\n    },\n\n    /**\n     * Make cssText for rotation moving.\n     * @param {object} params parameters\n     *      @param {number} params.labelWidth label width\n     *      @param {number} params.labelHeight label height\n     *      @param {number} params.left normal left\n     *      @param {number} params.moveLeft move left\n     *      @param {number} params.top top\n     *      @param {(string | number)} params.label label\n     *      @param {object} theme label theme\n     * @returns {string} cssText\n     * @private\n     */\n    _makeCssTextForRotationMoving: function(params) {\n        var position;\n\n        if (renderUtil.isOldBrowser()) {\n            position = this._calculateRotationMovingPositionForOldBrowser(params);\n        } else {\n            position = this._calculateRotationMovingPosition(params);\n        }\n\n        return renderUtil.concatStr('left:', position.left, 'px', ';top:', position.top, 'px');\n    },\n\n    /**\n     * Make html of rotation labels.\n     * @param {Array.&lt;object>} positions label position array\n     * @param {string[]} categories categories\n     * @param {number} labelSize label size\n     * @param {number} additionalSize additional size\n     * @returns {string} labels html\n     * @private\n     */\n    _makeRotationLabelsHtml: function(positions, categories, labelSize, additionalSize) {\n        var self = this,\n            degree = this.boundsMaker.xAxisDegree,\n            template = axisTemplate.tplAxisLabel,\n            labelHeight = renderUtil.getRenderedLabelHeight(categories[0], this.theme.label),\n            labelCssText = this._makeLabelCssText(labelSize),\n            additionalClass = ' tui-chart-xaxis-rotation tui-chart-xaxis-rotation' + degree,\n            halfWidth = labelSize / 2,\n            moveLeft = calculator.calculateAdjacent(degree, halfWidth),\n            top = calculator.calculateOpposite(degree, halfWidth) +\n                chartConst.XAXIS_LABEL_TOP_MARGIN,\n            spanCssText = (renderUtil.isIE7() &amp;&amp; degree) ? chartConst.IE7_ROTATION_FILTER_STYLE_MAP[degree] : '',\n            labelsHtml;\n\n        additionalSize = additionalSize || 0;\n        labelsHtml = tui.util.map(positions, function(position, index) {\n            var label = categories[index],\n                rotationCssText = self._makeCssTextForRotationMoving({\n                    labelHeight: labelHeight,\n                    labelWidth: labelSize,\n                    top: top,\n                    left: position + additionalSize,\n                    moveLeft: moveLeft,\n                    label: label,\n                    theme: self.theme.label\n                });\n\n            return template({\n                additionalClass: additionalClass,\n                cssText: labelCssText + rotationCssText,\n                spanCssText: spanCssText,\n                label: label\n            });\n        }).join('');\n\n        return labelsHtml;\n    },\n\n    /**\n     * Make html of normal labels.\n     * @param {Array.&lt;object>} positions label position array\n     * @param {string[]} categories categories\n     * @param {number} labelSize label size\n     * @param {number} additionalSize additional size\n     * @returns {string} labels html\n     * @private\n     */\n    _makeNormalLabelsHtml: function(positions, categories, labelSize, additionalSize) {\n        var template = axisTemplate.tplAxisLabel,\n            labelCssText = this._makeLabelCssText(labelSize),\n            posType, labelsHtml;\n\n        additionalSize = additionalSize || 0;\n\n        if (this.data.isVertical) {\n            posType = this.data.isLabelAxis ? 'top' : 'bottom';\n        } else {\n            posType = 'left';\n        }\n\n        labelsHtml = tui.util.map(positions, function(position, index) {\n            var addCssText = renderUtil.concatStr(posType, ':', (position + additionalSize), 'px');\n            return template({\n                additionalClass: '',\n                cssText: labelCssText + addCssText,\n                label: categories[index],\n                spanCssText: ''\n            });\n        }).join('');\n\n        return labelsHtml;\n    },\n\n    /**\n     * Make labels html.\n     * @param {Array.&lt;object>} positions label position array\n     * @param {string[]} categories categories\n     * @param {number} labelSize label size\n     * @param {number} additionalSize additional size\n     * @returns {string} labels html\n     * @private\n     */\n    _makeLabelsHtml: function(positions, categories, labelSize, additionalSize) {\n        var isRotationlessXAxis = !this.data.isVertical &amp;&amp; this.data.isLabelAxis &amp;&amp; this.options.rotateLabel === false,\n            hasRotatedXAxisLabel = this.componentName === 'xAxis' &amp;&amp; this.boundsMaker.xAxisDegree,\n            labelsHtml;\n\n        if (isRotationlessXAxis) {\n            categories = this.dataProcessor.getMultilineCategories();\n        }\n\n        positions.length = categories.length;\n\n        if (hasRotatedXAxisLabel) {\n            labelsHtml = this._makeRotationLabelsHtml(positions, categories, labelSize, additionalSize);\n        } else {\n            labelsHtml = this._makeNormalLabelsHtml(positions, categories, labelSize, additionalSize);\n        }\n\n        return labelsHtml;\n    },\n\n    /**\n     * Change position of label area.\n     * @param {HTMLElement} labelContainer label area element\n     * @param {number} labelSize label size (width or height)\n     * @private\n     */\n    _changeLabelAreaPosition: function(labelContainer, labelSize) {\n        var labelHeight;\n\n        if (this.data.isLabelAxis &amp;&amp; !this.data.aligned) {\n            return;\n        }\n\n        if (this.data.isVertical) {\n            labelHeight = renderUtil.getRenderedLabelHeight('ABC', this.theme.label);\n            labelContainer.style.top = renderUtil.concatStr(parseInt(labelHeight / 2, 10), 'px');\n        } else {\n            labelContainer.style.left = renderUtil.concatStr('-', parseInt(labelSize / 2, 10), 'px');\n        }\n    }\n});\n\nmodule.exports = Axis;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"