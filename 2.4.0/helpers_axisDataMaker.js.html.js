tui.util.defineNamespace("fedoc.content", {});
fedoc.content["helpers_axisDataMaker.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Axis Data Maker\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const');\nvar predicate = require('../helpers/predicate');\nvar renderUtil = require('../helpers/renderUtil');\n\n/**\n * Axis data maker.\n * @module axisDataMaker\n */\nvar axisDataMaker = {\n    /**\n     * Makes labels by labelInterval option.\n     * @param {Array.&lt;string>} labels - labels\n     * @param {number} labelInterval - label interval option\n     * @param {number} [addedDataCount] - added data count\n     * @returns {Array.&lt;string>} labels\n     * @private\n     */\n    _makeLabelsByIntervalOption: function(labels, labelInterval, addedDataCount) {\n        addedDataCount = addedDataCount || 0;\n        labels = tui.util.map(labels, function(label, index) {\n            if (((index + addedDataCount) % labelInterval) !== 0) {\n                label = chartConst.EMPTY_AXIS_LABEL;\n            }\n\n            return label;\n        });\n\n        return labels;\n    },\n\n    /**\n     * Make axis data for label type.\n     * @memberOf module:axisDataMaker\n     * @param {object} params - parameters\n     *      @param {Array.&lt;string>} params.labels - chart labels\n     *      @param {boolean} params.isVertical - whether vertical or not\n     *      @param {boolean} params.aligned - whether align or not\n     *      @param {?boolean} params.addedDataCount - added data count\n     * @returns {{\n     *      labels: Array.&lt;string>,\n     *      tickCount: number,\n     *      validTickCount: number,\n     *      isLabelAxis: boolean,\n     *      isVertical: boolean\n     * }} axis data\n     */\n    makeLabelAxisData: function(params) {\n        var tickCount = params.labels.length;\n        var options = params.options || {};\n        var labels = params.labels;\n\n        if (predicate.isValidLabelInterval(options.labelInterval, options.tickInterval)\n                &amp;&amp; params.labels.length > options.labelInterval) {\n            labels = this._makeLabelsByIntervalOption(params.labels, options.labelInterval, params.addedDataCount);\n        }\n\n        if (predicate.isDatetimeType(options.type)) {\n            labels = renderUtil.formatDates(labels, options.dateFormat);\n        }\n\n        if (!params.aligned) {\n            tickCount += 1;\n        }\n\n        return {\n            labels: labels,\n            tickCount: tickCount,\n            validTickCount: 0,\n            isLabelAxis: true,\n            options: options,\n            isVertical: !!params.isVertical,\n            isPositionRight: !!params.isPositionRight,\n            aligned: !!params.aligned\n        };\n    },\n\n    /**\n     * Make additional data for coordinate line type chart.\n     * @param {Array.&lt;string>} labels - labels\n     * @param {Array.&lt;number>} values - values\n     * @param {{min: number, max: number}} limit - limit\n     * @param {number} step - step\n     * @param {number} tickCount = tickCount\n     * @returns {{\n     *      labels: Array.&lt;string>,\n     *      tickCount: number,\n     *      validTickCount: number,\n     *      limit: {min: number, max: number},\n     *      positionRatio: number,\n     *      sizeRatio: number\n     * }}\n     * @private\n     */\n    _makeAdditionalDataForCoordinateLineType: function(labels, values, limit, step, tickCount) {\n        var sizeRatio = 1;\n        var positionRatio = 0;\n        var min = tui.util.min(values);\n        var max = tui.util.max(values);\n        var distance;\n\n        distance = max - min;\n\n        if (limit.min &lt; min) {\n            limit.min += step;\n            positionRatio = (limit.min - min) / distance;\n            sizeRatio -= positionRatio;\n            tickCount -= 1;\n            labels.shift();\n        }\n\n        if (limit.max > max) {\n            limit.max -= step;\n            sizeRatio -= (max - limit.max) / distance;\n            tickCount -= 1;\n            labels.pop();\n        }\n\n        return {\n            labels: labels,\n            tickCount: tickCount,\n            validTickCount: tickCount,\n            limit: limit,\n            dataMin: min,\n            distance: distance,\n            positionRatio: positionRatio,\n            sizeRatio: sizeRatio\n        };\n    },\n\n    /**\n     * Make data for value type axis.\n     * @memberOf module:axisDataMaker\n     * @param {object} params parameters\n     *      @param {AxisScaleMaker} params.axisScaleMaker chart values\n     *      @param {boolean} params.isVertical whether vertical or not\n     * @returns {{\n     *      labels: Array.&lt;string>,\n     *      tickCount: number,\n     *      validTickCount: number,\n     *      isLabelAxis: boolean,\n     *      limit: {min: number, max: number},\n     *      isVertical: boolean\n     * }} axis data\n     */\n    makeValueAxisData: function(params) {\n        var axisScaleMaker = params.axisScaleMaker;\n        var labels = axisScaleMaker.getFormattedScaleValues();\n        var tickCount = labels.length;\n        var limit = axisScaleMaker.getLimit();\n        var step = axisScaleMaker.getStep();\n        var dataProcessor = params.dataProcessor;\n        var chartType = params.chartType;\n        var axisData = {\n            labels: labels,\n            tickCount: tickCount,\n            validTickCount: tickCount,\n            limit: limit,\n            dataMin: limit.min,\n            distance: limit.max - limit.min,\n            step: step,\n            options: params.options,\n            isVertical: !!params.isVertical,\n            isPositionRight: !!params.isPositionRight,\n            aligned: !!params.aligned\n        };\n        var isVertical = params.isVertical;\n        var hasCategories = dataProcessor.hasCategories();\n        var isCoordinateLineType = !isVertical &amp;&amp; !hasCategories &amp;&amp; predicate.isLineTypeChart(chartType);\n        var values, additionalData;\n\n        if (isCoordinateLineType) {\n            values = dataProcessor.getValues(chartType, 'x');\n            additionalData = this._makeAdditionalDataForCoordinateLineType(labels, values, limit, step, tickCount);\n            tui.util.extend(axisData, additionalData);\n        }\n\n        return axisData;\n    },\n\n    /**\n     * Make adjusting tick interval information.\n     * @param {number} beforeBlockCount - before block count\n     * @param {number} seriesWidth - width of series area\n     * @param {number} blockSize - block size\n     * @returns {null | {blockCount: number, beforeRemainBlockCount: number, interval: number}}\n     * @private\n     */\n    _makeAdjustingIntervalInfo: function(beforeBlockCount, seriesWidth, blockSize) {\n        var newBlockCount = parseInt(seriesWidth / blockSize, 10);\n        // interval : 하나의 새로운 block(tick과 tick 사이의 공간) 영역에 포함되는 이전 block 수\n        var interval = parseInt(beforeBlockCount / newBlockCount, 10);\n        var intervalInfo = null;\n        var remainCount;\n\n        if (interval > 1) {\n            // remainCount : 이전 block들 중 새로운 block으로 채우고 남은 이전 block 수\n            // | | | | | | | | | | | |  - 이전 block\n            // |     |     |     |      - 새로 계산된 block\n            //                   |*|*|  - 남은 이전 block 수\n            remainCount = beforeBlockCount - (interval * newBlockCount);\n\n            if (remainCount >= interval) {\n                newBlockCount += parseInt(remainCount / interval, 0);\n                remainCount = remainCount % interval;\n            }\n\n            intervalInfo = {\n                blockCount: newBlockCount,\n                beforeRemainBlockCount: remainCount,\n                interval: interval\n            };\n        }\n\n        return intervalInfo;\n    },\n\n    /**\n     * Make candidate for adjusting tick interval.\n     * @param {number} beforeBlockCount - before block count\n     * @param {number} seriesWidth - width of series area\n     * @returns {Array.&lt;{newBlockCount: number, remainBlockCount: number, interval: number}>}\n     * @private\n     */\n    _makeCandidatesForAdjustingInterval: function(beforeBlockCount, seriesWidth) {\n        var self = this;\n        var blockSizeRange = tui.util.range(90, 121, 5); // [90, 95, 100, 105, 110, 115, 120]\n        var candidates = tui.util.map(blockSizeRange, function(blockSize) {\n            return self._makeAdjustingIntervalInfo(beforeBlockCount, seriesWidth, blockSize);\n        });\n\n        return tui.util.filter(candidates, function(info) {\n            return !!info;\n        });\n    },\n\n    /**\n     * Calculate adjusting interval information for auto tick interval option.\n     * @param {number} curBlockCount - current block count\n     * @param {number} seriesWidth - series width\n     * @returns {{newBlockCount: number, remainBlockCount: number, interval: number}}\n     * @private\n     */\n    _calculateAdjustingIntervalInfo: function(curBlockCount, seriesWidth) {\n        var candidates = this._makeCandidatesForAdjustingInterval(curBlockCount, seriesWidth);\n        var intervalInfo = null;\n\n        if (candidates.length) {\n            intervalInfo = tui.util.min(candidates, function(candidate) {\n                return candidate.blockCount;\n            });\n        }\n\n        return intervalInfo;\n    },\n\n    /**\n     * Make filtered labels by interval.\n     * @param {Array.&lt;string>} labels - labels\n     * @param {number} startIndex - start index\n     * @param {numbrer} interval - interval\n     * @returns {Array.&lt;string>}\n     * @private\n     */\n    _makeFilteredLabelsByInterval: function(labels, startIndex, interval) {\n        return tui.util.filter(labels.slice(startIndex), function(label, index) {\n            return index % interval === 0;\n        });\n    },\n\n    /**\n     * Update label type axisData for auto tick interval option.\n     * @param {object} axisData - axisData\n     * @param {number} seriesWidth - series width\n     * @param {number} [addedDataCount] - added data count\n     */\n    updateLabelAxisDataForAutoTickInterval: function(axisData, seriesWidth, addedDataCount) {\n        var beforeBlockCount = axisData.tickCount - 1;\n        var intervalInfo = this._calculateAdjustingIntervalInfo(beforeBlockCount, seriesWidth);\n        var adjustingBlockCount, interval, beforeRemainBlockCount, startIndex;\n\n        if (!intervalInfo) {\n            return;\n        }\n\n        adjustingBlockCount = intervalInfo.blockCount;\n        interval = intervalInfo.interval;\n        beforeRemainBlockCount = intervalInfo.beforeRemainBlockCount;\n        axisData.eventTickCount = axisData.tickCount;\n\n        // startIndex는 남은 block수의 반 만큼에서 현재 이동된 tick 수를 뺀 만큼으로 설정함\n        // |     |     |     |*|*|*|    - * 영역이 남은 이전 block 수\n        // |*|*|O    |     |     |*|    - 현재 이동된 tick이 없을 경우 (O 지점이 startIndex = 2)\n        // |*|O    |     |     |*|*|    - tick이 하나 이동 됐을 경우 : O 지점이 startIndex = 1)\n        startIndex = Math.round(beforeRemainBlockCount / 2) - (addedDataCount % interval);\n\n        // startIndex가 0보다 작을 경우 interval만큼 증가시킴\n        if (startIndex &lt; 0) {\n            startIndex += interval;\n        }\n\n        axisData.labels = this._makeFilteredLabelsByInterval(axisData.labels, startIndex, interval);\n\n        tui.util.extend(axisData, {\n            startIndex: startIndex,\n            tickCount: adjustingBlockCount + 1,\n            positionRatio: (startIndex / beforeBlockCount),\n            sizeRatio: 1 - (beforeRemainBlockCount / beforeBlockCount),\n            lineWidth: seriesWidth,\n            interval: interval\n        });\n    },\n\n    /**\n     * Update label type axisData for stacking dynamic data.\n     * @param {object} axisData - axis data\n     * @param {object} prevUpdatedData - previous updated axisData\n     * @param {number} firstTickCount - calculated first tick count\n     */\n    updateLabelAxisDataForStackingDynamicData: function(axisData, prevUpdatedData, firstTickCount) {\n        var interval = prevUpdatedData.interval;\n        var startIndex = prevUpdatedData.startIndex;\n        var beforeBlockCount = axisData.tickCount - 1;\n        var newBlockCount = beforeBlockCount / interval;\n        var firstBlockCount = firstTickCount ? firstTickCount - 1 : 0;\n        var beforeRemainBlockCount;\n\n        // 새로 계산된 block의 수가 최초로 계산된 block 수의 두배수 보다 많아지면 interval 숫자를 두배로 늘림\n        if (firstBlockCount &amp;&amp; ((firstBlockCount * 2) &lt;= newBlockCount)) {\n            interval *= 2;\n        }\n\n        axisData.labels = this._makeFilteredLabelsByInterval(axisData.labels, startIndex, interval);\n        newBlockCount = axisData.labels.length - 1;\n        beforeRemainBlockCount = beforeBlockCount - (interval * newBlockCount);\n\n        tui.util.extend(axisData, {\n            startIndex: startIndex,\n            eventTickCount: axisData.tickCount,\n            tickCount: axisData.labels.length,\n            positionRatio: startIndex / beforeBlockCount,\n            sizeRatio: 1 - (beforeRemainBlockCount / beforeBlockCount),\n            lineWidth: prevUpdatedData.lineWidth,\n            interval: interval\n        });\n    }\n};\n\nmodule.exports = axisDataMaker;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"