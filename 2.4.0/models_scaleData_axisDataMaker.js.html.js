tui.util.defineNamespace("fedoc.content", {});
fedoc.content["models_scaleData_axisDataMaker.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Axis Data Maker\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../../const');\nvar predicate = require('../../helpers/predicate');\nvar calculator = require('../../helpers/calculator');\nvar renderUtil = require('../../helpers/renderUtil');\n\n/**\n * Axis data maker.\n * @module axisDataMaker\n */\nvar axisDataMaker = {\n    /**\n     * Makes labels by labelInterval option.\n     * @param {Array.&lt;string>} labels - labels\n     * @param {number} labelInterval - label interval option\n     * @param {number} [addedDataCount] - added data count\n     * @returns {Array.&lt;string>} labels\n     * @private\n     */\n    _makeLabelsByIntervalOption: function(labels, labelInterval, addedDataCount) {\n        addedDataCount = addedDataCount || 0;\n        labels = tui.util.map(labels, function(label, index) {\n            if (((index + addedDataCount) % labelInterval) !== 0) {\n                label = chartConst.EMPTY_AXIS_LABEL;\n            }\n\n            return label;\n        });\n\n        return labels;\n    },\n\n    /**\n     * Make axis data for label type.\n     * @memberOf module:axisDataMaker\n     * @param {object} params - parameters\n     *      @param {Array.&lt;string>} params.labels - chart labels\n     *      @param {boolean} params.isVertical - whether vertical or not\n     *      @param {boolean} params.aligned - whether align or not\n     *      @param {?boolean} params.addedDataCount - added data count\n     * @returns {{\n     *      labels: Array.&lt;string>,\n     *      tickCount: number,\n     *      validTickCount: number,\n     *      isLabelAxis: boolean,\n     *      options: object,\n     *      isVertical: boolean,\n     *      isPositionRight: boolean,\n     *      aligned: boolean\n     * }}\n     */\n    makeLabelAxisData: function(params) {\n        var tickCount = params.labels.length;\n        var options = params.options || {};\n        var labels = params.labels;\n\n        if (predicate.isValidLabelInterval(options.labelInterval, options.tickInterval)\n                &amp;&amp; params.labels.length > options.labelInterval) {\n            labels = this._makeLabelsByIntervalOption(params.labels, options.labelInterval, params.addedDataCount);\n        }\n\n        if (predicate.isDatetimeType(options.type)) {\n            labels = renderUtil.formatDates(labels, options.dateFormat);\n        }\n\n        if (!params.aligned) {\n            tickCount += 1;\n        }\n\n        return {\n            labels: labels,\n            tickCount: tickCount,\n            validTickCount: 0,\n            isLabelAxis: true,\n            options: options,\n            isVertical: !!params.isVertical,\n            isPositionRight: !!params.isPositionRight,\n            aligned: !!params.aligned\n        };\n    },\n\n    /**\n     * Make data for value type axis.\n     * @memberOf module:axisDataMaker\n     * @param {object} params parameters\n     *      @param {AxisScaleMaker} params.axisScaleMaker chart values\n     *      @param {boolean} params.isVertical whether vertical or not\n     * @returns {{\n     *      labels: Array.&lt;string>,\n     *      tickCount: number,\n     *      validTickCount: number,\n     *      isLabelAxis: boolean,\n     *      limit: {min: number, max: number},\n     *      isVertical: boolean\n     * }} axis data\n     */\n    makeValueAxisData: function(params) {\n        var labels = params.labels;\n        var tickCount = params.tickCount;\n        var limit = params.limit;\n        var axisData = {\n            labels: labels,\n            tickCount: tickCount,\n            validTickCount: tickCount,\n            limit: limit,\n            dataMin: limit.min,\n            distance: limit.max - limit.min,\n            step: params.step,\n            options: params.options,\n            isVertical: !!params.isVertical,\n            isPositionRight: !!params.isPositionRight,\n            aligned: !!params.aligned\n        };\n\n        return axisData;\n    },\n\n    /**\n     * Make additional data for coordinate line type chart.\n     * @param {Array.&lt;string>} labels - labels\n     * @param {Array.&lt;number>} values - values\n     * @param {{min: number, max: number}} limit - limit\n     * @param {number} step - step\n     * @param {number} tickCount = tickCount\n     * @returns {{\n     *      labels: Array.&lt;string>,\n     *      tickCount: number,\n     *      validTickCount: number,\n     *      limit: {min: number, max: number},\n     *      positionRatio: number,\n     *      sizeRatio: number\n     * }}\n     */\n    makeAdditionalDataForCoordinateLineType: function(labels, values, limit, step, tickCount) {\n        var sizeRatio = 1;\n        var positionRatio = 0;\n        var min = tui.util.min(values);\n        var max = tui.util.max(values);\n        var distance;\n\n        distance = max - min;\n\n        if (limit.min &lt; min) {\n            limit.min += step;\n            positionRatio = (limit.min - min) / distance;\n            sizeRatio -= positionRatio;\n            tickCount -= 1;\n            labels.shift();\n        }\n\n        if (limit.max > max) {\n            limit.max -= step;\n            sizeRatio -= (max - limit.max) / distance;\n            tickCount -= 1;\n            labels.pop();\n        }\n\n        return {\n            labels: labels,\n            tickCount: tickCount,\n            validTickCount: tickCount,\n            limit: limit,\n            dataMin: min,\n            distance: distance,\n            positionRatio: positionRatio,\n            sizeRatio: sizeRatio\n        };\n    },\n\n    /**\n     * Make adjusting tick interval information.\n     * @param {number} beforeBlockCount - before block count\n     * @param {number} seriesWidth - width of series area\n     * @param {number} blockSize - block size\n     * @returns {null | {blockCount: number, beforeRemainBlockCount: number, interval: number}}\n     * @private\n     */\n    _makeAdjustingIntervalInfo: function(beforeBlockCount, seriesWidth, blockSize) {\n        var newBlockCount = parseInt(seriesWidth / blockSize, 10);\n        // interval : 하나의 새로운 block(tick과 tick 사이의 공간) 영역에 포함되는 이전 block 수\n        var interval = parseInt(beforeBlockCount / newBlockCount, 10);\n        var intervalInfo = null;\n        var remainCount;\n\n        if (interval > 1) {\n            // remainCount : 이전 block들 중 새로운 block으로 채우고 남은 이전 block 수\n            // | | | | | | | | | | | |  - 이전 block\n            // |     |     |     |      - 새로 계산된 block\n            //                   |*|*|  - 남은 이전 block 수\n            remainCount = beforeBlockCount - (interval * newBlockCount);\n\n            if (remainCount >= interval) {\n                newBlockCount += parseInt(remainCount / interval, 0);\n                remainCount = remainCount % interval;\n            }\n\n            intervalInfo = {\n                blockCount: newBlockCount,\n                beforeRemainBlockCount: remainCount,\n                interval: interval\n            };\n        }\n\n        return intervalInfo;\n    },\n\n    /**\n     * Make candidate for adjusting tick interval.\n     * @param {number} beforeBlockCount - before block count\n     * @param {number} seriesWidth - width of series area\n     * @returns {Array.&lt;{newBlockCount: number, remainBlockCount: number, interval: number}>}\n     * @private\n     */\n    _makeCandidatesForAdjustingInterval: function(beforeBlockCount, seriesWidth) {\n        var self = this;\n        var blockSizeRange = tui.util.range(90, 121, 5); // [90, 95, 100, 105, 110, 115, 120]\n        var candidates = tui.util.map(blockSizeRange, function(blockSize) {\n            return self._makeAdjustingIntervalInfo(beforeBlockCount, seriesWidth, blockSize);\n        });\n\n        return tui.util.filter(candidates, function(info) {\n            return !!info;\n        });\n    },\n\n    /**\n     * Calculate adjusting interval information for auto tick interval option.\n     * @param {number} curBlockCount - current block count\n     * @param {number} seriesWidth - series width\n     * @returns {{newBlockCount: number, remainBlockCount: number, interval: number}}\n     * @private\n     */\n    _calculateAdjustingIntervalInfo: function(curBlockCount, seriesWidth) {\n        var candidates = this._makeCandidatesForAdjustingInterval(curBlockCount, seriesWidth);\n        var intervalInfo = null;\n\n        if (candidates.length) {\n            intervalInfo = tui.util.min(candidates, function(candidate) {\n                return candidate.blockCount;\n            });\n        }\n\n        return intervalInfo;\n    },\n\n    /**\n     * Make filtered labels by interval.\n     * @param {Array.&lt;string>} labels - labels\n     * @param {number} startIndex - start index\n     * @param {numbrer} interval - interval\n     * @returns {Array.&lt;string>}\n     * @private\n     */\n    _makeFilteredLabelsByInterval: function(labels, startIndex, interval) {\n        return tui.util.filter(labels.slice(startIndex), function(label, index) {\n            return index % interval === 0;\n        });\n    },\n\n    /**\n     * Update label type axisData for auto tick interval option.\n     * @param {object} axisData - axisData\n     * @param {number} seriesWidth - series width\n     * @param {?number} addedDataCount - added data count\n     * @param {?boolean} addingDataMode - whether adding data mode or not\n     */\n    updateLabelAxisDataForAutoTickInterval: function(axisData, seriesWidth, addedDataCount, addingDataMode) {\n        var beforeBlockCount, intervalInfo;\n        var adjustingBlockCount, interval, beforeRemainBlockCount, startIndex;\n\n        if (addingDataMode) {\n            axisData.tickCount -= 1;\n            axisData.labels.pop();\n        }\n\n        beforeBlockCount = axisData.tickCount - 1;\n        intervalInfo = this._calculateAdjustingIntervalInfo(beforeBlockCount, seriesWidth);\n\n        if (!intervalInfo) {\n            return;\n        }\n\n        adjustingBlockCount = intervalInfo.blockCount;\n        interval = intervalInfo.interval;\n        beforeRemainBlockCount = intervalInfo.beforeRemainBlockCount;\n        axisData.eventTickCount = axisData.tickCount;\n\n        // startIndex는 남은 block수의 반 만큼에서 현재 이동된 tick 수를 뺀 만큼으로 설정함\n        // |     |     |     |*|*|*|    - * 영역이 남은 이전 block 수\n        // |*|*|O    |     |     |*|    - 현재 이동된 tick이 없을 경우 (O 지점이 startIndex = 2)\n        // |*|O    |     |     |*|*|    - tick이 하나 이동 됐을 경우 : O 지점이 startIndex = 1)\n        startIndex = Math.round(beforeRemainBlockCount / 2) - (addedDataCount % interval);\n\n        // startIndex가 0보다 작을 경우 interval만큼 증가시킴\n        if (startIndex &lt; 0) {\n            startIndex += interval;\n        }\n\n        axisData.labels = this._makeFilteredLabelsByInterval(axisData.labels, startIndex, interval);\n\n        tui.util.extend(axisData, {\n            startIndex: startIndex,\n            tickCount: adjustingBlockCount + 1,\n            positionRatio: (startIndex / beforeBlockCount),\n            sizeRatio: 1 - (beforeRemainBlockCount / beforeBlockCount),\n            interval: interval\n        });\n    },\n\n    /**\n     * Update label type axisData for stacking dynamic data.\n     * @param {object} axisData - axis data\n     * @param {object} prevUpdatedData - previous updated axisData\n     * @param {number} firstTickCount - calculated first tick count\n     */\n    updateLabelAxisDataForStackingDynamicData: function(axisData, prevUpdatedData, firstTickCount) {\n        var interval = prevUpdatedData.interval;\n        var startIndex = prevUpdatedData.startIndex;\n        var beforeBlockCount = axisData.tickCount - 1;\n        var newBlockCount = beforeBlockCount / interval;\n        var firstBlockCount = firstTickCount ? firstTickCount - 1 : 0;\n        var beforeRemainBlockCount;\n\n        // 새로 계산된 block의 수가 최초로 계산된 block 수의 두배수 보다 많아지면 interval 숫자를 두배로 늘림\n        if (firstBlockCount &amp;&amp; ((firstBlockCount * 2) &lt;= newBlockCount)) {\n            interval *= 2;\n        }\n\n        axisData.labels = this._makeFilteredLabelsByInterval(axisData.labels, startIndex, interval);\n        newBlockCount = axisData.labels.length - 1;\n        beforeRemainBlockCount = beforeBlockCount - (interval * newBlockCount);\n\n        tui.util.extend(axisData, {\n            startIndex: startIndex,\n            eventTickCount: axisData.tickCount,\n            tickCount: axisData.labels.length,\n            positionRatio: startIndex / beforeBlockCount,\n            sizeRatio: 1 - (beforeRemainBlockCount / beforeBlockCount),\n            interval: interval\n        });\n    },\n\n    /**\n     * Calculate width for label area for x axis.\n     * @param {boolean} isLabelAxis - whether label type axis or not\n     * @param {number} seriesWidth - series width\n     * @param {number} labelCount - label count\n     * @returns {number} limit width\n     * @private\n     */\n    _calculateXAxisLabelAreaWidth: function(isLabelAxis, seriesWidth, labelCount) {\n        if (!isLabelAxis) {\n            labelCount -= 1;\n        }\n\n        return seriesWidth / labelCount;\n    },\n\n    /**\n     * Create multiline label.\n     * @param {string} label - label\n     * @param {number} limitWidth - limit width\n     * @param {object} theme - label theme\n     * @returns {string}\n     * @private\n     */\n    _createMultilineLabel: function(label, limitWidth, theme) {\n        var words = String(label).split(/\\s+/);\n        var lineWords = words[0];\n        var lines = [];\n\n        tui.util.forEachArray(words.slice(1), function(word) {\n            var width = renderUtil.getRenderedLabelWidth(lineWords + ' ' + word, theme);\n\n            if (width > limitWidth) {\n                lines.push(lineWords);\n                lineWords = word;\n            } else {\n                lineWords += ' ' + word;\n            }\n        });\n\n        if (lineWords) {\n            lines.push(lineWords);\n        }\n\n        return lines.join('&lt;br>');\n    },\n\n    /**\n     * Create multiline labels.\n     * @param {Array.&lt;string>} labels - labels\n     * @param {object} labelTheme - theme for label\n     * @param {number} labelAreaWidth - label area width\n     * @returns {Array}\n     * @private\n     */\n    _createMultilineLabels: function(labels, labelTheme, labelAreaWidth) {\n        var _createMultilineLabel = this._createMultilineLabel;\n\n        return tui.util.map(labels, function(label) {\n            return _createMultilineLabel(label, labelAreaWidth, labelTheme);\n        });\n    },\n\n    /**\n     * Calculate multiline height.\n     * @param {Array.string} multilineLabels - multiline labels\n     * @param {object} labelTheme - theme for label\n     * @param {number} labelAreaWidth - width for label area\n     * @returns {number}\n     * @private\n     */\n    _calculateMultilineHeight: function(multilineLabels, labelTheme, labelAreaWidth) {\n        return renderUtil.getRenderedLabelsMaxHeight(multilineLabels, tui.util.extend({\n            cssText: 'line-height:1.2;width:' + labelAreaWidth + 'px'\n        }, labelTheme));\n    },\n\n    /**\n     * Calculate height difference between origin category and multiline category.\n     * @param {Array.&lt;string>} labels - labels\n     * @param {Array.&lt;string>} validLabelCount - valid label count\n     * @param {object} labelTheme - theme for label\n     * @param {boolean} isLabelAxis - whether label type axis or not\n     * @param {{series: {width: number}, yAxis: {width: number}}} dimensionMap - dimension map\n     * @returns {number}\n     */\n    makeAdditionalDataForMultilineLabels: function(labels, validLabelCount, labelTheme, isLabelAxis, dimensionMap) {\n        var seriesWidth = dimensionMap.series.width;\n        var labelAreaWidth = this._calculateXAxisLabelAreaWidth(isLabelAxis, seriesWidth, validLabelCount);\n        var multilineLabels = this._createMultilineLabels(labels, labelTheme, seriesWidth);\n        var multilineHeight = this._calculateMultilineHeight(multilineLabels, labelTheme, labelAreaWidth);\n        var labelHeight = renderUtil.getRenderedLabelsMaxHeight(labels, labelTheme);\n\n        return {\n            multilineLabels: multilineLabels,\n            overflowHeight: multilineHeight - labelHeight,\n            overflowLeft: (labelAreaWidth / 2) - dimensionMap.yAxis.width\n        };\n    },\n\n    /**\n     * Find rotation degree.\n     * @param {number} labelAreaWidth - limit width\n     * @param {number} labelWidth - label width\n     * @param {number} labelHeight - label height\n     * @returns {number}\n     * @private\n     */\n    _findRotationDegree: function(labelAreaWidth, labelWidth, labelHeight) {\n        var foundDegree = null;\n\n        tui.util.forEachArray(chartConst.DEGREE_CANDIDATES, function(degree) {\n            var compareWidth = calculator.calculateRotatedWidth(degree, labelWidth, labelHeight);\n\n            foundDegree = degree;\n\n            if (compareWidth &lt;= labelAreaWidth + chartConst.XAXIS_LABEL_COMPARE_MARGIN) {\n                return false;\n            }\n\n            return true;\n        });\n\n        return foundDegree;\n    },\n\n    /**\n     * Calculate rotated width.\n     * @param {number} degree - degree for label of x axis\n     * @param {string} firstLabel - first label\n     * @param {number} labelHeight - labelHeight\n     * @param {object} labelTheme - theme for label\n     * @returns {number}\n     * @private\n     */\n    _calculateRotatedWidth: function(degree, firstLabel, labelHeight, labelTheme) {\n        var firstLabelWidth = renderUtil.getRenderedLabelWidth(firstLabel, labelTheme);\n        var newLabelWidth = calculator.calculateRotatedWidth(degree, firstLabelWidth, labelHeight);\n\n        // overflow 체크시에는 우측 상단 꼭지 기준으로 계산해야 함\n        newLabelWidth -= calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, labelHeight / 2);\n\n        return newLabelWidth;\n    },\n\n    /**\n     * Calculate limit width for label\n     * @param {number} yAxisWidth - y axis width\n     * @param {boolean} isLabelAxis - aligned tick and label\n     * @param {number} labelAreaWidth - width for label area\n     * @returns {number}\n     * @private\n     */\n    _calculateLimitWidth: function(yAxisWidth, isLabelAxis, labelAreaWidth) {\n        var limitWidth = yAxisWidth;\n\n        if (isLabelAxis) {\n            limitWidth += (labelAreaWidth / 2);\n        }\n\n        return limitWidth;\n    },\n\n    /**\n     * Make additional data for rotated labels.\n     * @param {Array.&lt;string>} validLabels - valid labels\n     * @param {Array.&lt;string>} validLabelCount - valid label count\n     * @param {object} labelTheme - theme for label\n     * @param {boolean} isLabelAxis - whether label type axis or not\n     * @param {{series: {width: number}, yAxis: {width: number}}} dimensionMap - dimension map\n     * @returns {{degree: number, overflowHeight: number, overflowLeft: number}}\n     */\n    makeAdditionalDataForRotatedLabels: function(validLabels, validLabelCount, labelTheme, isLabelAxis, dimensionMap) {\n        var maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(validLabels, labelTheme);\n        var seriesWidth = dimensionMap.series.width;\n        var labelAreaWidth = this._calculateXAxisLabelAreaWidth(isLabelAxis, seriesWidth, validLabelCount);\n        var additionalData = null;\n        var degree, labelHeight, rotatedHeight, limitWidth, rotatedWidth;\n\n        if (labelAreaWidth &lt; maxLabelWidth) {\n            labelHeight = renderUtil.getRenderedLabelsMaxHeight(validLabels, labelTheme);\n            degree = this._findRotationDegree(labelAreaWidth, maxLabelWidth, labelHeight);\n            rotatedHeight = calculator.calculateRotatedHeight(degree, maxLabelWidth, labelHeight);\n            rotatedWidth = this._calculateRotatedWidth(degree, validLabels[0], labelHeight, labelTheme);\n            limitWidth = this._calculateLimitWidth(dimensionMap.yAxis.width, isLabelAxis, labelAreaWidth);\n\n            additionalData = {\n                degree: degree,\n                overflowHeight: rotatedHeight - labelHeight,\n                overflowLeft: rotatedWidth - limitWidth\n            };\n        } else {\n            labelAreaWidth = renderUtil.getRenderedLabelWidth(validLabels[0], labelTheme) / 2;\n            additionalData = {\n                overflowLeft: labelAreaWidth - dimensionMap.yAxis.width\n            };\n        }\n\n        return additionalData;\n    }\n};\n\nmodule.exports = axisDataMaker;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"