tui.util.defineNamespace("fedoc.content", {});
fedoc.content["components_series_barChartSeries.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Bar chart series component.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar Series = require('./series');\nvar BarTypeSeriesBase = require('./barTypeSeriesBase');\nvar chartConst = require('../../const/');\nvar predicate = require('../../helpers/predicate');\nvar renderUtil = require('../../helpers/renderUtil');\nvar calculator = require('../../helpers/calculator');\n\nvar BarChartSeries = tui.util.defineClass(Series, /** @lends BarChartSeries.prototype */ {\n    /**\n     * Bar chart series component.\n     * @constructs BarChartSeries\n     * @extends Series\n     * @param {object} params parameters\n     *      @param {object} params.model series model\n     *      @param {object} params.options series options\n     *      @param {object} params.theme series theme\n     */\n    init: function() {\n        Series.apply(this, arguments);\n    },\n\n    /**\n     * Make bound of bar chart.\n     * @param {number} width width\n     * @param {number} height height\n     * @param {number} top top position value\n     * @param {number} startLeft start left position value\n     * @param {number} endLeft end left position value\n     * @returns {{\n     *      start: {left: number, top: number, width: number, height: number},\n     *      end: {left: number, top: number, width: number, height: number}\n     * }} column chart bound\n     * @private\n     */\n    _makeBound: function(width, height, top, startLeft, endLeft) {\n        return {\n            start: {\n                top: top,\n                left: startLeft,\n                width: 0,\n                height: height\n            },\n            end: {\n                top: top,\n                left: endLeft,\n                width: width,\n                height: height\n            }\n        };\n    },\n\n    /**\n     * Calculate additional left for divided option.\n     * @param {number} value value\n     * @returns {number}\n     * @private\n     */\n    _calculateAdditionalLeft: function(value) {\n        var additionalLeft = 0;\n\n        if (this.options.divided &amp;&amp; value > 0) {\n            additionalLeft = this.dimensionMap.yAxis.width + chartConst.OVERLAPPING_WIDTH;\n        }\n\n        return additionalLeft;\n    },\n\n    /**\n     * Make bar chart bound.\n     * @param {{\n     *      baseSize: number,\n     *      basePosition: number,\n     *      step: number,\n     *      additionalPosition: ?number,\n     *      barSize: number\n     * }} baseData base data for making bound\n     * @param {{\n     *      baseTop: number,\n     *      top: number,\n     *      plusLeft: number,\n     *      minusLeft: number,\n     *      prevStack: ?string\n     * }} iterationData iteration data\n     * @param {?boolean} isStackType whether stackType option or not.\n     * @param {SeriesItem} seriesItem series item\n     * @param {number} index index\n     * @returns {{\n     *      start: {left: number, top: number, width: number, height: number},\n     *      end: {left: number, top: number, width: number, height: number}\n     * }}\n     * @private\n     */\n    _makeBarChartBound: function(baseData, iterationData, isStackType, seriesItem, index) {\n        var barWidth = baseData.baseBarSize * seriesItem.ratioDistance,\n            additionalLeft = this._calculateAdditionalLeft(seriesItem.value),\n            barStartLeft = baseData.baseBarSize * seriesItem.startRatio,\n            startLeft = baseData.basePosition + barStartLeft + additionalLeft + chartConst.SERIES_EXPAND_SIZE,\n            changedStack = (seriesItem.stack !== iterationData.prevStack),\n            stepCount, endLeft, bound;\n\n        if (!isStackType || (!this.options.diverging &amp;&amp; changedStack)) {\n            stepCount = isStackType ? this.dataProcessor.findStackIndex(seriesItem.stack) : index;\n            iterationData.top = (baseData.step * stepCount) + iterationData.baseTop + baseData.additionalPosition;\n            iterationData.plusLeft = 0;\n            iterationData.minusLeft = 0;\n        }\n\n        if (seriesItem.value >= 0) {\n            endLeft = startLeft + iterationData.plusLeft;\n            iterationData.plusLeft += barWidth;\n        } else {\n            iterationData.minusLeft -= barWidth;\n            endLeft = startLeft + iterationData.minusLeft;\n        }\n\n        iterationData.prevStack = seriesItem.stack;\n\n        bound = this._makeBound(barWidth, baseData.barSize, iterationData.top, startLeft, endLeft);\n\n        return bound;\n    },\n\n    /**\n     * Make bounds of bar chart.\n     * @returns {Array.&lt;Array.&lt;object>>} bounds\n     * @private\n     */\n    _makeBounds: function() {\n        var self = this;\n        var seriesDataModel = this._getSeriesDataModel();\n        var isStacked = predicate.isValidStackOption(this.options.stackType);\n        var dimension = this.layout.dimension;\n        var baseData = this._makeBaseDataForMakingBound(dimension.height, dimension.width);\n\n        return seriesDataModel.map(function(seriesGroup, groupIndex) {\n            var baseTop = (groupIndex * baseData.groupSize) + baseData.firstAdditionalPosition\n                        + chartConst.SERIES_EXPAND_SIZE,\n                iterationData = {\n                    baseTop: baseTop,\n                    top: baseTop,\n                    plusLeft: 0,\n                    minusLeft: 0,\n                    prevStack: null\n                },\n                iteratee = tui.util.bind(self._makeBarChartBound, self, baseData, iterationData, isStacked);\n\n            return seriesGroup.map(iteratee);\n        });\n    },\n\n    /**\n     * Calculate top position of sum label.\n     * @param {{left: number, top: number}} bound bound\n     * @param {number} labelHeight label height\n     * @returns {number} top position value\n     * @private\n     */\n    _calculateTopPositionOfSumLabel: function(bound, labelHeight) {\n        return bound.top + ((bound.height - labelHeight + chartConst.TEXT_PADDING) / 2);\n    },\n\n    /**\n     * Make html of plus sum label.\n     * @param {Array.&lt;number>} values values\n     * @param {{left: number, top: number}} bound bound\n     * @param {number} labelHeight label height\n     * @returns {string} plus sum label html\n     * @private\n     */\n    _makePlusSumLabelHtml: function(values, bound, labelHeight) {\n        var html = '';\n        var sum, formatFunctions, formattedSum;\n\n        if (bound) {\n            sum = calculator.sumPlusValues(values);\n            formatFunctions = this.dataProcessor.getFormatFunctions();\n            formattedSum = renderUtil.formatValue(sum, formatFunctions, this.chartType, 'series');\n            html = this._makeSeriesLabelHtml({\n                left: bound.left + bound.width + chartConst.SERIES_LABEL_PADDING,\n                top: this._calculateTopPositionOfSumLabel(bound, labelHeight)\n            }, formattedSum, -1);\n        }\n\n        return html;\n    },\n\n    /**\n     * Make minus sum label html.\n     * @param {Array.&lt;number>} values values\n     * @param {{left: number, top: number}} bound bound\n     * @param {number} labelHeight label height\n     * @returns {string} plus minus label html\n     * @private\n     */\n    _makeMinusSumLabelHtml: function(values, bound, labelHeight) {\n        var html = '';\n        var sum, formatFunctions, formattedSum, labelWidth;\n\n        if (bound) {\n            sum = calculator.sumMinusValues(values);\n\n            if (this.options.diverging) {\n                sum = Math.abs(sum);\n            }\n\n            formatFunctions = this.dataProcessor.getFormatFunctions();\n            formattedSum = renderUtil.formatValue(sum, formatFunctions, this.chartType, 'series');\n            labelWidth = renderUtil.getRenderedLabelWidth(formattedSum, this.theme.label);\n            html = this._makeSeriesLabelHtml({\n                left: bound.left - labelWidth - chartConst.SERIES_LABEL_PADDING,\n                top: this._calculateTopPositionOfSumLabel(bound, labelHeight)\n            }, formattedSum, -1);\n        }\n\n        return html;\n    }\n});\n\nBarTypeSeriesBase.mixin(BarChartSeries);\n\nmodule.exports = BarChartSeries;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"