tui.util.defineNamespace("fedoc.content", {});
fedoc.content["series_squarifier.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview squarifier create squarified bounds for rendering graph of treemap chart.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar squarifier = {\n    /**\n     * bound map\n     * @type {object.&lt;string, {width: number, height: number, left: number, top: number}>}\n     */\n    boundMap: {},\n\n    /**\n     * Make base bound for calculating bounds.\n     * @param {{width: number, height: number}} dimension - dimension\n     * @returns {{width: number, height: number, left: number, top: number}}\n     * @private\n     */\n    _makeBaseBound: function(dimension) {\n        return tui.util.extend({\n            left: 0,\n            top: 0\n        }, dimension);\n    },\n\n    /**\n     * Calculate scale for calculating weight.\n     * @param {Array.&lt;number>} values - values\n     * @param {number} width - width of series area\n     * @param {number} height - height of series area\n     * @returns {number}\n     * @private\n     */\n    _calculateScale: function(values, width, height) {\n        return (width * height) / tui.util.sum(values);\n    },\n\n    /**\n     * Make base data for creating squarified bounds.\n     * @param {Array.&lt;SeriesItem>} seriesItems - SeriesItems\n     * @param {number} width - width of series area\n     * @param {number} height - height of series area\n     * @returns {Array.&lt;{itme: SeriesItem, weight: number}>}\n     * @private\n     */\n    _makeBaseData: function(seriesItems, width, height) {\n        var scale = this._calculateScale(tui.util.pluck(seriesItems, 'value'), width, height);\n        var data = tui.util.map(seriesItems, function(seriesItem) {\n            return {\n                id: seriesItem.id,\n                weight: seriesItem.value * scale\n            };\n        }).sort(function(a, b) {\n            return b.weight - a.weight;\n        });\n\n        return data;\n    },\n\n    /**\n     * Calculate worst aspect ratio.\n     * Referred function worst() in https://www.win.tue.nl/~vanwijk/stm.pdf\n     * @param {number} sum - sum for weights\n     * @param {number} min - minimum weight\n     * @param {number} max - maximum weight\n     * @param {number} baseSize - base size (width or height)\n     * @returns {number}\n     * @private\n     */\n    _worst: function(sum, min, max, baseSize) {\n        var sumSquare = sum * sum;\n        var sizeSquare = baseSize * baseSize;\n\n        return Math.max((sizeSquare * max) / sumSquare, sumSquare / (sizeSquare * min));\n    },\n\n    /**\n     * Whether changed stack direction or not.\n     * @param {number} sum - sum for weights\n     * @param {Array.&lt;number>} weights - weights\n     * @param {number} baseSize - base size\n     * @param {number} newWeight - new weight\n     * @returns {boolean}\n     * @private\n     */\n    _changedStackDirection: function(sum, weights, baseSize, newWeight) {\n        var min = tui.util.min(weights);\n        var max = tui.util.max(weights);\n        var beforeWorst = this._worst(sum, min, max, baseSize);\n        var newWorst = this._worst(sum + newWeight, Math.min(min, newWeight), Math.max(max, newWeight), baseSize);\n\n        return newWorst >= beforeWorst;\n    },\n\n    /**\n     * Whether type of vertical stack or not.\n     * @param {{width: number, height: number}} baseBound - base bound\n     * @returns {boolean}\n     * @private\n     */\n    _isVerticalStack: function(baseBound) {\n        return baseBound.height &lt; baseBound.width;\n    },\n\n    /**\n     * Select base size from baseBound.\n     * @param {{width: number, height: number}} baseBound - base bound\n     * @returns {number}\n     * @private\n     */\n    _selectBaseSize: function(baseBound) {\n        return this._isVerticalStack(baseBound) ? baseBound.height : baseBound.width;\n    },\n\n    /**\n     * Calculate fixed size.\n     * @param {number} baseSize - base size\n     * @param {number} sum - sum for weights\n     * @param {Array.&lt;{weight: number}>} row - row\n     * @returns {number}\n     * @private\n     */\n    _calculateFixedSize: function(baseSize, sum, row) {\n        var weights;\n\n        if (!sum) {\n            weights = tui.util.pluck(row, 'weight');\n            sum = tui.util.sum(weights);\n        }\n\n        return sum / baseSize;\n    },\n\n    /**\n     * Add bounds.\n     * @param {number} startPosition - start position\n     * @param {Array.&lt;{weight: number}>} row - row\n     * @param {number} fixedSize - fixed size\n     * @param {function} callback - callback function\n     * @private\n     */\n    _addBounds: function(startPosition, row, fixedSize, callback) {\n        tui.util.reduce([startPosition].concat(row), function(storedPosition, rowDatum) {\n            var dynamicSize = rowDatum.weight / fixedSize;\n\n            callback(dynamicSize, storedPosition, rowDatum.id);\n\n            return storedPosition + dynamicSize;\n        });\n    },\n\n    /**\n     * Add bound.\n     * @param {number} left - left position\n     * @param {number} top - top position\n     * @param {number} width - width\n     * @param {number} height - height\n     * @param {string | number} id - id of seriesItem\n     * @private\n     */\n    _addBound: function(left, top, width, height, id) {\n        this.boundMap[id] = {\n            left: left,\n            top: top,\n            width: width,\n            height: height\n        };\n    },\n\n    /**\n     * Add bounds for type of vertical stack.\n     * @param {Array.&lt;{weight: number}>} row - row\n     * @param {{left: number, top: number, width: number, height: number}} baseBound - base bound\n     * @param {number} baseSize - base size\n     * @param {number} sum - sum for weights of row\n     * @private\n     */\n    _addBoundsForVerticalStack: function(row, baseBound, baseSize, sum) {\n        var self = this;\n        var fixedWidth = this._calculateFixedSize(baseSize, sum, row);\n\n        this._addBounds(baseBound.top, row, fixedWidth, function(dynamicHeight, storedTop, id) {\n            self._addBound(baseBound.left, storedTop, fixedWidth, dynamicHeight, id);\n        });\n\n        baseBound.left += fixedWidth;\n        baseBound.width -= fixedWidth;\n    },\n\n    /**\n     * Add bounds for type of horizontal stack.\n     * @param {Array.&lt;{weight: number}>} row - row\n     * @param {{left: number, top: number, width: number, height: number}} baseBound - base bound\n     * @param {number} baseSize - base size\n     * @param {number} sum - sum for weights of row\n     * @private\n     */\n    _addBoundsForHorizontalStack: function(row, baseBound, baseSize, sum) {\n        var self = this;\n        var fixedHeight = this._calculateFixedSize(baseSize, sum, row);\n\n        this._addBounds(baseBound.left, row, fixedHeight, function(dynamicWidth, storedLeft, id) {\n            self._addBound(storedLeft, baseBound.top, dynamicWidth, fixedHeight, id);\n        });\n\n        baseBound.top += fixedHeight;\n        baseBound.height -= fixedHeight;\n    },\n\n    /**\n     * Get adding bounds function.\n     * @param {{width: number, height: number}} baseBound - base bound\n     * @returns {*}\n     * @private\n     */\n    _getAddingBoundsFunction: function(baseBound) {\n        var addBound;\n\n        if (this._isVerticalStack(baseBound)) {\n            addBound = tui.util.bind(this._addBoundsForVerticalStack, this);\n        } else {\n            addBound = tui.util.bind(this._addBoundsForHorizontalStack, this);\n        }\n\n        return addBound;\n    },\n\n    /**\n     * Create squarified bound map for graph rendering.\n     * @param {{width: number, height: number}} dimension - dimension\n     * @param {Array.&lt;SeriesItem>} seriesItems - seriesItems\n     * @returns {object.&lt;string, {width: number, height: number, left: number, top: number}>}\n     */\n    squarify: function(dimension, seriesItems) {\n        var self = this;\n        var baseBound = this._makeBaseBound(dimension);\n        var baseData = this._makeBaseData(seriesItems, baseBound.width, baseBound.height);\n        var row = [];\n        var baseSize, addBounds;\n\n        this.boundMap = {};\n\n        tui.util.forEachArray(baseData, function(datum) {\n            var weights = tui.util.pluck(row, 'weight');\n            var sum = tui.util.sum(weights);\n\n            if (row.length &amp;&amp; self._changedStackDirection(sum, weights, baseSize, datum.weight)) {\n                addBounds(row, baseBound, baseSize, sum);\n                row = [];\n            }\n\n            if (!row.length) {\n                baseSize = self._selectBaseSize(baseBound);\n                addBounds = self._getAddingBoundsFunction(baseBound);\n            }\n\n            row.push(datum);\n        });\n\n        if (row.length) {\n            addBounds(row, baseBound, baseSize);\n        }\n\n        return this.boundMap;\n    }\n};\n\nmodule.exports = squarifier;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"