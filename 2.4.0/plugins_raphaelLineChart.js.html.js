tui.util.defineNamespace("fedoc.content", {});
fedoc.content["plugins_raphaelLineChart.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Raphael line chart renderer.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar RaphaelLineBase = require('./raphaelLineTypeBase'),\n    raphaelRenderUtil = require('./raphaelRenderUtil');\n\nvar EMPHASIS_OPACITY = 1;\nvar DE_EMPHASIS_OPACITY = 0.3;\nvar LEFT_BAR_WIDTH = 10;\nvar ADDING_DATA_ANIMATION_DURATION = 300;\n\nvar raphael = window.Raphael;\n\nvar RaphaelLineChart = tui.util.defineClass(RaphaelLineBase, /** @lends RaphaelLineChart.prototype */ {\n    /**\n     * RaphaelLineCharts is graph renderer for line chart.\n     * @constructs RaphaelLineChart\n     * @extends RaphaelLineTypeBase\n     */\n    init: function() {\n        /**\n         * selected legend index\n         * @type {?number}\n         */\n        this.selectedLegendIndex = null;\n\n        /**\n         * type of chart\n         * @type {string}\n         */\n        this.chartType = 'line';\n    },\n\n    /**\n     * Render function of line chart.\n     * @param {HTMLElement} container container\n     * @param {{groupPositions: Array.&lt;Array>, dimension: object, theme: object, options: object}} data render data\n     * @param {object} [paper] - raphael paper\n     * @returns {object} paper raphael paper\n     */\n    render: function(container, data, paper) {\n        var dimension = data.dimension;\n        var groupPositions = data.groupPositions;\n        var theme = data.theme;\n        var colors = theme.colors;\n        var opacity = data.options.showDot ? 1 : 0;\n        var isSpline = data.options.spline;\n        var groupPaths = isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);\n        var borderStyle = this.makeBorderStyle(theme.borderColor, opacity);\n        var outDotStyle = this.makeOutDotStyle(opacity, borderStyle);\n\n        paper = paper || raphael(container, 1, dimension.height);\n\n        this.paper = paper;\n        this.isSpline = isSpline;\n        this.dimension = dimension;\n\n        this.groupLines = this._renderLines(paper, groupPaths, colors);\n        this.leftBar = this._renderLeftBar(dimension.height, data.chartBackground);\n        this.tooltipLine = this._renderTooltipLine(paper, dimension.height);\n        this.groupDots = this._renderDots(paper, groupPositions, colors, opacity);\n\n        if (data.options.allowSelect) {\n            this.selectionDot = this._makeSelectionDot(paper);\n            this.selectionColor = theme.selectionColor;\n        }\n\n        this.colors = colors;\n        this.borderStyle = borderStyle;\n        this.outDotStyle = outDotStyle;\n        this.groupPositions = groupPositions;\n        this.groupPaths = groupPaths;\n        this.dotOpacity = opacity;\n        delete this.pivotGroupDots;\n\n        return paper;\n    },\n\n    /**\n     * Get lines path.\n     * @param {Array.&lt;Array.&lt;{left: number, top: number, startTop: number}>>} groupPositions positions\n     * @returns {Array.&lt;Array.&lt;string>>} path\n     * @private\n     */\n    _getLinesPath: function(groupPositions) {\n        var self = this;\n\n        return tui.util.map(groupPositions, function(positions) {\n            return self._makeLinesPath(positions);\n        });\n    },\n\n    /**\n     * Get spline lines path.\n     * @param {Array.&lt;Array.&lt;{left: number, top: number, startTop: number}>>} groupPositions positions\n     * @returns {Array} path\n     * @private\n     */\n    _getSplineLinesPath: function(groupPositions) {\n        return tui.util.map(groupPositions, this._makeSplineLinesPath, this);\n    },\n\n    /**\n     * Render lines.\n     * @param {object} paper raphael paper\n     * @param {Array.&lt;Array.&lt;string>>} groupPaths paths\n     * @param {string[]} colors line colors\n     * @param {?number} strokeWidth stroke width\n     * @returns {Array.&lt;Array.&lt;object>>} lines\n     * @private\n     */\n    _renderLines: function(paper, groupPaths, colors, strokeWidth) {\n        return tui.util.map(groupPaths, function(path, groupIndex) {\n            var color = colors[groupIndex] || 'transparent';\n            return raphaelRenderUtil.renderLine(paper, path.join(' '), color, strokeWidth);\n        });\n    },\n\n    /**\n     * Resize graph of line chart.\n     * @param {object} params parameters\n     *      @param {{width: number, height:number}} params.dimension dimension\n     *      @param {Array.&lt;Array.&lt;{left:number, top:number}>>} params.groupPositions group positions\n     */\n    resize: function(params) {\n        var self = this,\n            dimension = params.dimension,\n            groupPositions = params.groupPositions;\n\n        this.groupPositions = groupPositions;\n        this.groupPaths = this.isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);\n        this.paper.setSize(dimension.width, dimension.height);\n        this.tooltipLine.attr({top: dimension.height});\n\n        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {\n            self.groupLines[groupIndex].attr({path: path.join(' ')});\n\n            tui.util.forEachArray(self.groupDots[groupIndex], function(item, index) {\n                self._moveDot(item.endDot.dot, groupPositions[groupIndex][index]);\n            });\n        });\n    },\n\n    /**\n     * Select legend.\n     * @param {?number} legendIndex legend index\n     */\n    selectLegend: function(legendIndex) {\n        var self = this,\n            noneSelected = tui.util.isNull(legendIndex);\n\n        this.selectedLegendIndex = legendIndex;\n\n        tui.util.forEachArray(this.groupLines, function(line, groupIndex) {\n            var opacity = (noneSelected || legendIndex === groupIndex) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;\n\n            line.attr({'stroke-opacity': opacity});\n\n            tui.util.forEachArray(self.groupDots[groupIndex], function(item) {\n                item.opacity = opacity;\n\n                if (self.dotOpacity) {\n                    item.endDot.dot.attr({'fill-opacity': opacity});\n                }\n            });\n        });\n    },\n\n    /**\n     * Animate for adding data.\n     * @param {object} data - data for graph rendering\n     * @param {number} tickSize - tick size\n     * @param {Array.&lt;Array.&lt;object>>} groupPositions - group positions\n     * @param {boolean} [shiftingOption] - shifting option\n     */\n    animateForAddingData: function(data, tickSize, groupPositions, shiftingOption) {\n        var self = this;\n        var isSpline = data.options.spline;\n        var groupPaths = isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);\n        var additionalIndex = 0;\n\n        if (!groupPositions.length) {\n            return;\n        }\n\n        if (shiftingOption) {\n            this.leftBar.animate({\n                width: tickSize + LEFT_BAR_WIDTH\n            }, ADDING_DATA_ANIMATION_DURATION);\n            additionalIndex = 1;\n        }\n\n        tui.util.forEachArray(this.groupLines, function(line, groupIndex) {\n            var dots = self.groupDots[groupIndex];\n            var groupPosition = groupPositions[groupIndex];\n\n            if (shiftingOption) {\n                self._removeFirstDot(dots);\n            }\n\n            tui.util.forEachArray(dots, function(item, index) {\n                var position = groupPosition[index + additionalIndex];\n                self._animateByPosition(item.endDot.dot, position);\n            });\n\n            self._animateByPath(line, groupPaths[groupIndex]);\n        });\n    }\n});\n\nmodule.exports = RaphaelLineChart;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"