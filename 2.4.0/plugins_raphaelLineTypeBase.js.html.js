tui.util.defineNamespace("fedoc.content", {});
fedoc.content["plugins_raphaelLineTypeBase.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview RaphaelLineTypeBase is base class for line type renderer.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar raphaelRenderUtil = require('./raphaelRenderUtil');\n\nvar ANIMATION_DURATION = 700;\nvar DEFAULT_DOT_RADIUS = 3;\nvar HOVER_DOT_RADIUS = 4;\nvar SELECTION_DOT_RADIUS = 7;\nvar DE_EMPHASIS_OPACITY = 0.3;\nvar MOVING_ANIMATION_DURATION = 300;\nvar LEFT_BAR_WIDTH = 10;\n\nvar concat = Array.prototype.concat;\n\n/**\n * @classdesc RaphaelLineTypeBase is base for line type renderer.\n * @class RaphaelLineTypeBase\n */\nvar RaphaelLineTypeBase = tui.util.defineClass(/** @lends RaphaelLineTypeBase.prototype */ {\n    /**\n     * Render left bar for hiding overflow graph.\n     * @param {number} height - area height\n     * @param {string} chartBackground - background style of chart\n     * @private\n     * @returns {object}\n     */\n    _renderLeftBar: function(height, chartBackground) {\n        var bound = {\n            left: 0,\n            top: 0,\n            width: LEFT_BAR_WIDTH,\n            height: height\n        };\n\n        return raphaelRenderUtil.renderRect(this.paper, bound, {\n            fill: chartBackground,\n            stroke: 'none'\n        });\n    },\n\n    /**\n     * Make lines path.\n     * @param {Array.&lt;{left: number, top: number, startTop: number}>} positions positions\n     * @param {?string} posTopType position top type\n     * @returns {Array.&lt;string | number>} paths\n     * @private\n     */\n    _makeLinesPath: function(positions, posTopType) {\n        var path;\n\n        posTopType = posTopType || 'top';\n        path = tui.util.map(positions, function(position) {\n            return ['L', position.left, position[posTopType]];\n        });\n\n        path = concat.apply([], path);\n        path[0] = 'M';\n\n        return path;\n    },\n\n    /**\n     * Get anchor. (http://raphaeljs.com/analytics.js)\n     * @param {{left: number, top: number}} fromPos from position\n     * @param {{left: number, top: number}} pos position\n     * @param {{left: number, top: number}} nextPos next position\n     * @returns {{x1: number, y1: number, x2: number, y2: number}} anchor\n     * @private\n     */\n    _getAnchor: function(fromPos, pos, nextPos) {\n        var l1 = (pos.left - fromPos.left) / 2,\n            l2 = (nextPos.left - pos.left) / 2,\n            a = Math.atan((pos.left - fromPos.left) / Math.abs(pos.top - fromPos.top)),\n            b = Math.atan((nextPos.left - pos.left) / Math.abs(pos.top - nextPos.top)),\n            alpha, dx1, dy1, dx2, dy2;\n\n        a = fromPos.top &lt; pos.top ? Math.PI - a : a;\n        b = nextPos.top &lt; pos.top ? Math.PI - b : b;\n        alpha = Math.PI / 2 - ((a + b) % (Math.PI * 2)) / 2;\n        dx1 = l1 * Math.sin(alpha + a);\n        dy1 = l1 * Math.cos(alpha + a);\n        dx2 = l2 * Math.sin(alpha + b);\n        dy2 = l2 * Math.cos(alpha + b);\n\n        return {\n            x1: pos.left - dx1,\n            y1: pos.top + dy1,\n            x2: pos.left + dx2,\n            y2: pos.top + dy2\n        };\n    },\n\n    /**\n     * Make spline lines path.\n     * @param {Array.&lt;{left: number, top: number, startTop: number}>} positions positions\n     * @returns {Array.&lt;string | number>} paths\n     * @private\n     */\n    _makeSplineLinesPath: function(positions) {\n        var self = this;\n        var firstPos = positions[0];\n        var positionsLen = positions.length;\n        var fromPos = firstPos;\n        var lastPos = positions[positionsLen - 1];\n        var middlePositions = positions.slice(1).slice(0, positionsLen - 2);\n        var path = tui.util.map(middlePositions, function(position, index) {\n            var nextPos = positions[index + 2];\n            var anchor = self._getAnchor(fromPos, position, nextPos);\n\n            fromPos = position;\n\n            return [anchor.x1, anchor.y1, position.left, position.top, anchor.x2, anchor.y2];\n        });\n\n        path.push([lastPos.left, lastPos.top, lastPos.left, lastPos.top]);\n        path.unshift(['M', firstPos.left, firstPos.top, 'C', firstPos.left, firstPos.top]);\n\n        return path;\n    },\n\n    /**\n     * Render tooltip line.\n     * @param {object} paper raphael paper\n     * @param {number} height height\n     * @returns {object} raphael object\n     * @private\n     */\n    _renderTooltipLine: function(paper, height) {\n        var linePath = raphaelRenderUtil.makeLinePath({\n            left: 10,\n            top: height\n        }, {\n            left: 10,\n            top: 0\n        });\n\n        return raphaelRenderUtil.renderLine(paper, linePath, 'transparent', 1);\n    },\n\n    /**\n     * Make border style.\n     * @param {string} borderColor border color\n     * @param {number} opacity opacity\n     * @returns {{stroke: string, stroke-width: number, strike-opacity: number}} border style\n     */\n    makeBorderStyle: function(borderColor, opacity) {\n        var borderStyle;\n\n        if (borderColor) {\n            borderStyle = {\n                stroke: borderColor,\n                'stroke-width': 1,\n                'stroke-opacity': opacity\n            };\n        }\n\n        return borderStyle;\n    },\n\n    /**\n     * Make dot style for mouseout event.\n     * @param {number} opacity opacity\n     * @param {object} borderStyle border style\n     * @returns {{fill-opacity: number, stroke-opacity: number, r: number}} style\n     */\n    makeOutDotStyle: function(opacity, borderStyle) {\n        var outDotStyle = {\n            'fill-opacity': opacity,\n            'stroke-opacity': 0,\n            r: DEFAULT_DOT_RADIUS\n        };\n\n        if (borderStyle) {\n            tui.util.extend(outDotStyle, borderStyle);\n        }\n\n        return outDotStyle;\n    },\n\n    /**\n     * Render dot.\n     * @param {object} paper raphael papaer\n     * @param {{left: number, top: number}} position dot position\n     * @param {string} color dot color\n     * @param {number} opacity opacity\n     * @returns {object} raphael dot\n     */\n    renderDot: function(paper, position, color, opacity) {\n        var dot = paper.circle(position.left, position.top, DEFAULT_DOT_RADIUS),\n            dotStyle = {\n                fill: color,\n                'fill-opacity': opacity,\n                'stroke-opacity': 0\n            };\n\n        dot.attr(dotStyle);\n\n        return {\n            dot: dot,\n            color: color\n        };\n    },\n\n    /**\n     * Move dots to front.\n     * @param {Array.&lt;{startDot: {dot: object}, endDot: {dot: object}}>} dots - dots\n     * @private\n     */\n    _moveDotsToFront: function(dots) {\n        raphaelRenderUtil.forEach2dArray(dots, function(dotInfo) {\n            dotInfo.endDot.dot.toFront();\n            if (dotInfo.startDot) {\n                dotInfo.startDot.dot.toFront();\n            }\n        });\n    },\n\n    /**\n     * Render dots.\n     * @param {object} paper raphael paper\n     * @param {Array.&lt;Array.&lt;object>>} groupPositions positions\n     * @param {string[]} colors colors\n     * @param {number} opacity opacity\n     * @returns {Array.&lt;object>} dots\n     * @private\n     */\n    _renderDots: function(paper, groupPositions, colors, opacity) {\n        var self = this;\n        var dots;\n\n        // 기존에 캐싱된 dot을 다른 도형에 의해 가려지지 않게 하기 위해 제일 앞으로 이동시킴\n        if (paper.dots) {\n            this._moveDotsToFront(paper.dots);\n        }\n\n        dots = tui.util.map(groupPositions, function(positions, groupIndex) {\n            var color = colors[groupIndex];\n\n            return tui.util.map(positions, function(position) {\n                var dotMap = {\n                    endDot: self.renderDot(paper, position, color, opacity)\n                };\n                var startPosition;\n\n                if (self.hasRangeData) {\n                    startPosition = tui.util.extend({}, position);\n                    startPosition.top = startPosition.startTop;\n                    dotMap.startDot = self.renderDot(paper, startPosition, color, opacity);\n                }\n\n                return dotMap;\n            });\n        });\n\n        if (!paper.dots) {\n            paper.dots = [];\n        }\n\n        // 다른 그래프 렌더링 시 앞으로 이동시키기 위해 paper에 캐싱함\n        paper.dots = paper.dots.concat(dots);\n\n        return dots;\n    },\n\n    /**\n     * Get center position\n     * @param {{left: number, top: number}} fromPos from position\n     * @param {{left: number, top: number}} toPos to position\n     * @returns {{left: number, top: number}} position\n     * @private\n     */\n    _getCenter: function(fromPos, toPos) {\n        return {\n            left: (fromPos.left + toPos.left) / 2,\n            top: (fromPos.top + toPos.top) / 2\n        };\n    },\n\n    /**\n     * Show dot.\n     * @param {object} dot raphael object\n     * @private\n     */\n    _showDot: function(dot) {\n        dot.attr({\n            'fill-opacity': 1,\n            'stroke-opacity': 0.3,\n            'stroke-width': 2,\n            r: HOVER_DOT_RADIUS\n        });\n    },\n\n    /**\n     * Update line stroke width.\n     * @param {object} line raphael object\n     * @param {number} strokeWidth stroke width\n     * @private\n     */\n    _updateLineStrokeWidth: function(line, strokeWidth) {\n        line.attr({\n            'stroke-width': strokeWidth\n        });\n    },\n\n    /**\n     * Show animation.\n     * @param {{groupIndex: number, index:number}} data show info\n     */\n    showAnimation: function(data) {\n        var index = data.groupIndex; // Line chart has pivot values.\n        var groupIndex = data.index;\n        var line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex];\n        var item = this.groupDots[groupIndex][index];\n        var strokeWidth, startLine;\n\n        if (!item) {\n            return;\n        }\n\n        if (this.chartType === 'area') {\n            strokeWidth = 2;\n            startLine = line.startLine;\n            line = line.line;\n        } else {\n            strokeWidth = 3;\n        }\n\n        this._updateLineStrokeWidth(line, strokeWidth);\n\n        if (startLine) {\n            this._updateLineStrokeWidth(startLine, strokeWidth);\n        }\n\n        this._showDot(item.endDot.dot);\n\n        if (item.startDot) {\n            this._showDot(item.startDot.dot);\n        }\n    },\n\n    /**\n     * Get pivot group dots.\n     * @returns {Array.&lt;Array>} dots\n     * @private\n     */\n    _getPivotGroupDots: function() {\n        if (!this.pivotGroupDots) {\n            this.pivotGroupDots = tui.util.pivot(this.groupDots);\n        }\n\n        return this.pivotGroupDots;\n    },\n\n    /**\n     * Show group dots.\n     * @param {number} index index\n     * @private\n     */\n    _showGroupDots: function(index) {\n        var self = this;\n        var groupDots = this._getPivotGroupDots();\n\n        if (!groupDots[index]) {\n            return;\n        }\n\n        tui.util.forEachArray(groupDots[index], function(item) {\n            self._showDot(item.endDot.dot);\n\n            if (item.startDot) {\n                self._showDot(item.startDot.dot);\n            }\n        });\n    },\n\n    /**\n     * Show line for group tooltip.\n     * @param {{\n     *      dimension: {width: number, height: number},\n     *      position: {left: number, top: number}\n     * }} bound bound\n     */\n    showGroupTooltipLine: function(bound) {\n        var left = Math.max(bound.position.left, 11);\n        var linePath = raphaelRenderUtil.makeLinePath({\n            left: left,\n            top: bound.position.top + bound.dimension.height\n        }, {\n            left: left,\n            top: bound.position.top\n        });\n\n        this.tooltipLine.attr({\n            path: linePath,\n            stroke: '#999',\n            'stroke-opacity': 1\n        });\n    },\n\n    /**\n     * Show group animation.\n     * @param {number} index index\n     */\n    showGroupAnimation: function(index) {\n        this._showGroupDots(index);\n    },\n\n    /**\n     * Hide dot.\n     * @param {object} dot raphael object\n     * @param {?number} opacity opacity\n     * @private\n     */\n    _hideDot: function(dot, opacity) {\n        var outDotStyle = this.outDotStyle;\n\n        if (!tui.util.isUndefined(opacity)) {\n            outDotStyle = tui.util.extend({}, this.outDotStyle, {\n                'fill-opacity': opacity\n            });\n        }\n\n        dot.attr(outDotStyle);\n    },\n\n    /**\n     * Hide animation.\n     * @param {{groupIndex: number, index:number}} data hide info\n     */\n    hideAnimation: function(data) {\n        var index = data.groupIndex; // Line chart has pivot values.\n        var groupIndex = data.index;\n        var opacity = this.dotOpacity;\n        var groupDot = this.groupDots[groupIndex];\n        var line, item, strokeWidth, startLine;\n\n        if (!groupDot || !groupDot[index]) {\n            return;\n        }\n\n        line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex];\n        item = groupDot[index];\n\n        if (this.chartType === 'area') {\n            strokeWidth = 1;\n            startLine = line.startLine;\n            line = line.line;\n        } else {\n            strokeWidth = 2;\n        }\n\n        if (opacity &amp;&amp; !tui.util.isNull(this.selectedLegendIndex) &amp;&amp; this.selectedLegendIndex !== groupIndex) {\n            opacity = DE_EMPHASIS_OPACITY;\n        }\n\n        if (line) {\n            this._updateLineStrokeWidth(line, strokeWidth);\n        }\n\n        if (startLine) {\n            this._updateLineStrokeWidth(startLine, strokeWidth);\n        }\n\n        if (item) {\n            this._hideDot(item.endDot.dot, opacity);\n\n            if (item.startDot) {\n                this._hideDot(item.startDot.dot, opacity);\n            }\n        }\n    },\n\n    /**\n     * Hide group dots.\n     * @param {number} index index\n     * @private\n     */\n    _hideGroupDots: function(index) {\n        var self = this;\n        var groupDots = this._getPivotGroupDots();\n        var hasSelectedIndex = !tui.util.isNull(this.selectedLegendIndex);\n        var baseOpacity = this.dotOpacity;\n\n        if (!groupDots[index]) {\n            return;\n        }\n\n        tui.util.forEachArray(groupDots[index], function(item, groupIndex) {\n            var opacity = baseOpacity;\n\n            if (opacity &amp;&amp; hasSelectedIndex &amp;&amp; self.selectedLegendIndex !== groupIndex) {\n                opacity = DE_EMPHASIS_OPACITY;\n            }\n\n            self._hideDot(item.endDot.dot, opacity);\n\n            if (item.startDot) {\n                self._hideDot(item.startDot.dot, opacity);\n            }\n        });\n    },\n\n    /**\n     * Hide line for group tooltip.\n     */\n    hideGroupTooltipLine: function() {\n        this.tooltipLine.attr({\n            'stroke-opacity': 0\n        });\n    },\n\n    /**\n     * Hide group animation.\n     * @param {number} index index\n     */\n    hideGroupAnimation: function(index) {\n        this._hideGroupDots(index);\n    },\n\n    /**\n     * Move dot.\n     * @param {object} dot - raphael object\n     * @param {{left: number, top: number}} position - position\n     * @private\n     */\n    _moveDot: function(dot, position) {\n        var dotAttrs = {\n            cx: position.left,\n            cy: position.top\n        };\n\n        if (this.dotOpacity) {\n            dotAttrs = tui.util.extend({'fill-opacity': this.dotOpacity}, dotAttrs, this.borderStyle);\n        }\n\n        dot.attr(dotAttrs);\n    },\n\n    /**\n     * Show graph for zoom.\n     */\n    showGraph: function() {\n        this.paper.setSize(this.dimension.width, this.dimension.height);\n    },\n\n    /**\n     * Animate.\n     * @param {function} onFinish callback\n     */\n    animate: function(onFinish) {\n        var self = this,\n            seriesWidth = this.dimension.width,\n            seriesHeight = this.dimension.height;\n\n        tui.chart.renderUtil.cancelAnimation(this.animation);\n\n        this.animation = tui.chart.renderUtil.startAnimation(ANIMATION_DURATION, function(ratio) {\n            var width = Math.min(seriesWidth * ratio, seriesWidth);\n\n            self.paper.setSize(width, seriesHeight);\n\n            if (ratio === 1) {\n                onFinish();\n            }\n        });\n    },\n\n    /**\n     * Make selection dot.\n     * @param {object} paper raphael paper\n     * @returns {object} selection dot\n     * @private\n     */\n    _makeSelectionDot: function(paper) {\n        var selectionDot = paper.circle(0, 0, SELECTION_DOT_RADIUS);\n\n        selectionDot.attr({\n            'fill': '#ffffff',\n            'fill-opacity': 0,\n            'stroke-opacity': 0,\n            'stroke-width': 2\n        });\n\n        return selectionDot;\n    },\n\n    /**\n     * Select series.\n     * @param {{groupIndex: number, index: number}} indexes indexes\n     */\n    selectSeries: function(indexes) {\n        var item = this.groupDots[indexes.index][indexes.groupIndex],\n            position = this.groupPositions[indexes.index][indexes.groupIndex];\n\n        this.selectedItem = item;\n        this.selectionDot.attr({\n            cx: position.left,\n            cy: position.top,\n            'fill-opacity': 0.5,\n            'stroke-opacity': 1,\n            stroke: this.selectionColor || item.endDot.color\n        });\n\n        if (this.selectionStartDot) {\n            this.selectionStartDot.attr({\n                cx: position.left,\n                cy: position.startTop,\n                'fill-opacity': 0.5,\n                'stroke-opacity': 1,\n                stroke: this.selectionColor || item.startDot.color\n            });\n        }\n    },\n\n    /**\n     * Unselect series.\n     * @param {{groupIndex: number, index: number}} indexes indexes\n     */\n    unselectSeries: function(indexes) {\n        var item = this.groupDots[indexes.index][indexes.groupIndex];\n\n        if (this.selectedItem === item) {\n            this.selectionDot.attr({\n                'fill-opacity': 0,\n                'stroke-opacity': 0\n            });\n        }\n\n        if (this.selectionStartDot) {\n            this.selectionStartDot.attr({\n                'fill-opacity': 0,\n                'stroke-opacity': 0\n            });\n        }\n    },\n\n    /**\n     * Set width or height of paper.\n     * @param {number} width - width\n     * @param {number} height - height\n     */\n    setSize: function(width, height) {\n        width = width || this.dimension.width;\n        height = height || this.dimension.height;\n        this.paper.setSize(width, height);\n    },\n\n    /**\n     * Animate by position.\n     * @param {object} raphaelObj - raphael object\n     * @param {{left: number, top: number}} position - position\n     * @private\n     */\n    _animateByPosition: function(raphaelObj, position) {\n        raphaelObj.animate({\n            cx: position.left,\n            cy: position.top\n        }, MOVING_ANIMATION_DURATION);\n    },\n\n    /**\n     * Animate by path.\n     * @param {object} raphaelObj - raphael object\n     * @param {Array.&lt;string | number>} paths - paths\n     * @private\n     */\n    _animateByPath: function(raphaelObj, paths) {\n        raphaelObj.animate({\n            path: paths.join(' ')\n        }, MOVING_ANIMATION_DURATION);\n    },\n\n    /**\n     * Remove first dot.\n     * @param {Array.&lt;object>} dots - dots\n     * @private\n     */\n    _removeFirstDot: function(dots) {\n        var firstDot = dots.shift();\n\n        firstDot.endDot.dot.remove();\n\n        if (firstDot.startDot) {\n            firstDot.startDot.dot.remove();\n        }\n    },\n\n    /**\n     * Clear paper.\n     */\n    clear: function() {\n        delete this.paper.dots;\n        this.paper.clear();\n    }\n});\n\nmodule.exports = RaphaelLineTypeBase;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"