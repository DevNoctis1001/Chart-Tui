tui.util.defineNamespace("fedoc.content", {});
fedoc.content["customEvents_customEventBase.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview CustomEventBase is base class for event handle layers.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar TickBaseCoordinateModel = require('./tickBaseCoordinateModel');\nvar BoundsBaseCoordinateModel = require('./boundsBaseCoordinateModel');\nvar chartConst = require('../const');\nvar eventListener = require('../helpers/eventListener');\nvar predicate = require('../helpers/predicate');\nvar dom = require('../helpers/domHandler');\nvar renderUtil = require('../helpers/renderUtil');\n\nvar CustomEventBase = tui.util.defineClass(/** @lends CustomEventBase.prototype */ {\n    /**\n     * CustomEventBase is base class for custom event components.\n     * @constructs CustomEventBase\n     * @param {object} params parameters\n     *      @param {{\n     *          dimension: {width: number, height: number},\n     *          position: {left: number, top: number}\n     *      }} params.bound bound\n     *      @param {string} params.chartType chart type\n     *      @param {boolean} params.isVertical whether vertical or not\n     */\n    init: function(params) {\n        var isLineTypeChart;\n\n        /**\n         * type of chart\n         * @type {string}\n         */\n        this.chartType = params.chartType;\n\n        /**\n         * chartTypes is available in combo chart\n         * @type {Array.&lt;string>}\n         */\n        this.chartTypes = params.chartTypes;\n\n        /**\n         * whether vertical or not\n         * @type {boolean}\n         */\n        this.isVertical = params.isVertical;\n\n        /**\n         * data processor\n         * @type {DataProcessor}\n         */\n        this.dataProcessor = params.dataProcessor;\n\n        /**\n         * bounds maker\n         * @type {BoundsMaker}\n         */\n        this.boundsMaker = params.boundsMaker;\n\n        /**\n         * whether allow select series or not\n         */\n        this.allowSelect = params.allowSelect;\n\n        /**\n         * selected series item.\n         * @type {null | object}\n         */\n        this.selectedData = null;\n\n        /**\n         * previous client position of mouse event (clientX, clientY)\n         * @type {null | object}\n         */\n        this.prevClientPosition = null;\n\n        /**\n         * previous found data\n         * @type {null | object}\n         */\n        this.prevFoundData = null;\n\n\n        isLineTypeChart = predicate.isLineTypeChart(this.chartType, this.chartTypes);\n\n        /**\n         * expand size\n         * @type {number}\n         */\n        this.expandSize = isLineTypeChart ? chartConst.SERIES_EXPAND_SIZE : 0;\n\n        /**\n         * container bound\n         * @type {null | {left: number, top: number, right: number, bottom: number}}\n         */\n        this.containerBound = null;\n    },\n\n    /**\n     * Get bound for rendering.\n     * @returns {{\n     *      dimension: {width: number, height: number},\n     *      position: {left: number, top: number}\n     * }}\n     * @private\n     */\n    _getRenderingBound: function() {\n        var renderingBound;\n\n        if (predicate.isLineTypeChart(this.chartType, this.chartTypes)) {\n            renderingBound = renderUtil.expandBound(this.boundsMaker.getBound('customEvent'));\n        } else {\n            renderingBound = this.boundsMaker.getBound('customEvent');\n        }\n\n        return renderingBound;\n    },\n\n    /**\n     * Render event handle layer area.\n     * @param {HTMLElement} customEventContainer - container element for custom event\n     * @param {object} data - data for rendering\n     * @private\n     */\n    _renderCustomEventArea: function(customEventContainer, data) {\n        var dimension = this.boundsMaker.getDimension('customEvent');\n        var renderingBound, tbcm;\n\n        this.dimension = dimension;\n        tbcm = new TickBaseCoordinateModel(dimension, data.tickCount, this.chartType, this.isVertical, this.chartTypes);\n        this.tickBaseCoordinateModel = tbcm;\n        renderingBound = this._getRenderingBound();\n        renderUtil.renderDimension(customEventContainer, renderingBound.dimension);\n        renderUtil.renderPosition(customEventContainer, renderingBound.position);\n    },\n\n    /**\n     * Render for customEvent component.\n     * @param {object} data - data for rendering\n     * @returns {HTMLElement} container for custom event\n     */\n    render: function(data) {\n        var container = dom.create('DIV', 'tui-chart-series-custom-event-area');\n\n        this._renderCustomEventArea(container, data);\n        this.attachEvent(container);\n        this.customEventContainer = container;\n\n        return container;\n    },\n\n    /**\n     * Get container bound.\n     * @returns {ClientRect}\n     * @private\n     */\n    _getContainerBound: function() {\n        if (!this.containerBound) {\n            this.containerBound = this.customEventContainer.getBoundingClientRect();\n        }\n\n        return this.containerBound;\n    },\n\n    /**\n     * Calculate layer position by client position.\n     * @param {number} clientX - clientX\n     * @param {number} [clientY] - clientY\n     * @param {boolean} [checkLimit] - whether check limit or not\n     * @returns {{x: number, y: ?number}}\n     * @private\n     */\n    _calculateLayerPosition: function(clientX, clientY, checkLimit) {\n        var bound = this._getContainerBound();\n        var layerPosition = {};\n        var expandSize = this.expandSize;\n        var maxLeft, minLeft;\n\n        checkLimit = tui.util.isUndefined(checkLimit) ? true : checkLimit;\n\n        if (checkLimit) {\n            maxLeft = bound.right - expandSize;\n            minLeft = bound.left + expandSize;\n            clientX = Math.min(Math.max(clientX, minLeft), maxLeft);\n        }\n\n        layerPosition.x = clientX - bound.left;\n\n        if (!tui.util.isUndefined(clientY)) {\n            layerPosition.y = clientY - bound.top;\n        }\n\n        return layerPosition;\n    },\n\n    /**\n     * Create BoundsBaseCoordinateModel from seriesBounds for custom event.\n     * @param {Array.&lt;object>} seriesBounds - series bounds\n     */\n    initCustomEventData: function(seriesBounds) {\n        this.boundsBaseCoordinateModel = new BoundsBaseCoordinateModel(seriesBounds);\n    },\n\n    /**\n     * Rerender for customEvent component.\n     * @param {{tickCount: number}} data - data for rerendering\n     */\n    rerender: function(data) {\n        this.selectedData = null;\n        this._renderCustomEventArea(this.customEventContainer, data);\n    },\n\n    /**\n     * Resize for customEvent component.\n     * @param {{tickCount: number}} data - data for resizing\n     */\n    resize: function(data) {\n        this.containerBound = null;\n        this.rerender(data);\n    },\n\n    /**\n     * Whether changed select data or not.\n     * @param {object} prev - previous data\n     * @param {object} cur - current data\n     * @returns {boolean}\n     * @private\n     */\n    _isChangedSelectData: function(prev, cur) {\n        return !prev || !cur || prev.chartType !== cur.chartType ||\n            prev.indexes.groupIndex !== cur.indexes.groupIndex || prev.indexes.index !== cur.indexes.index;\n    },\n\n    /**\n     * Find coordinate data from boundsCoordinateModel.\n     * @param {{x: number, y: number}} layerPosition - layer position\n     * @returns {object}\n     * @private\n     */\n    _findDataFromBoundsCoordinateModel: function(layerPosition) {\n        var layerX = layerPosition.x;\n        var layerY = layerPosition.y;\n        var groupIndex;\n\n        if (predicate.isTreemapChart(this.chartType)) {\n            groupIndex = 0;\n        } else {\n            layerX += chartConst.SERIES_EXPAND_SIZE;\n            layerY += chartConst.SERIES_EXPAND_SIZE;\n            groupIndex = this.tickBaseCoordinateModel.findIndex(this.isVertical ? layerX : layerY);\n        }\n\n        return this.boundsBaseCoordinateModel.findData(groupIndex, layerX, layerY);\n    },\n\n    /**\n     * Unselect selected data.\n     * @private\n     */\n    _unselectSelectedData: function() {\n        var eventName = renderUtil.makeCustomEventName('unselect', this.selectedData.chartType, 'series');\n        this.fire(eventName, this.selectedData);\n        this.selectedData = null;\n    },\n\n    /**\n     * Find data.\n     * @param {number} clientX - clientX\n     * @param {number} clientY - clientY\n     * @returns {object}\n     * @private\n     */\n    _findData: function(clientX, clientY) {\n        var layerPosition = this._calculateLayerPosition(clientX, clientY);\n\n        return this._findDataFromBoundsCoordinateModel(layerPosition);\n    },\n\n    /**\n     * Show tooltip\n     * @private\n     * @abstract\n     */\n    _showTooltip: function() {},\n\n    /**\n     * Animate for adding data.\n     */\n    animateForAddingData: function() {\n        var foundData, isMoving;\n\n        if (!this.prevClientPosition) {\n            return;\n        }\n\n        foundData = this._findData(this.prevClientPosition.x, this.prevClientPosition.y);\n\n        if (foundData) {\n            isMoving = this.prevFoundData &amp;&amp; (this.prevFoundData.indexes.groupIndex === foundData.indexes.groupIndex);\n            this._showTooltip(foundData, isMoving);\n        }\n\n        this.prevFoundData = foundData;\n    },\n\n    /**\n     * On mouse event.\n     * @param {string} eventType - custom event type\n     * @param {MouseEvent} e - mouse event\n     * @private\n     */\n    _onMouseEvent: function(eventType, e) {\n        var eventName = renderUtil.makeCustomEventName(eventType, this.chartType, 'series');\n\n        dom.addClass(this.customEventContainer, 'hide');\n        this.fire(eventName, {\n            left: e.clientX,\n            top: e.clientY\n        });\n        dom.removeClass(this.customEventContainer, 'hide');\n    },\n\n    /**\n     * On click\n     * @param {MouseEvent} e - mouse event\n     * @private\n     */\n    _onClick: function(e) {\n        var foundData = this._findData(e.clientX, e.clientY);\n\n        if (!this._isChangedSelectData(this.selectedData, foundData)) {\n            this._unselectSelectedData();\n        } else if (foundData) {\n            if (this.selectedData) {\n                this._unselectSelectedData();\n            }\n\n            this.fire(renderUtil.makeCustomEventName('select', foundData.chartType, 'series'), foundData);\n\n            if (this.allowSelect) {\n                this.selectedData = foundData;\n            }\n        }\n    },\n\n    /**\n     * On mouse down\n     * @private\n     * @abstract\n     */\n    _onMousedown: function() {},\n\n    /**\n     * On mouse up\n     * @private\n     * @abstract\n     */\n    _onMouseup: function() {},\n\n    /**\n     * On mouse move\n     * @param {MouseEvent} e - mouse event\n     * @private\n     */\n    _onMousemove: function(e) {\n        this.prevClientPosition = {\n            x: e.clientX,\n            y: e.clientY\n        };\n    },\n\n    /**\n     * On mouse out\n     * @private\n     */\n    _onMouseout: function() {\n        this.prevClientPosition = null;\n        this.prevFoundData = null;\n    },\n\n    /**\n     * Attach event\n     * @param {HTMLElement} target - target element\n     */\n    attachEvent: function(target) {\n        eventListener.on(target, {\n            click: this._onClick,\n            mousedown: this._onMousedown,\n            mouseup: this._onMouseup,\n            mousemove: this._onMousemove,\n            mouseout: this._onMouseout\n        }, this);\n    }\n});\n\ntui.util.CustomEvents.mixin(CustomEventBase);\n\nmodule.exports = CustomEventBase;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"