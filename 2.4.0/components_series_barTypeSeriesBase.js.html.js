tui.util.defineNamespace("fedoc.content", {});
fedoc.content["components_series_barTypeSeriesBase.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview BarTypeSeriesBase is base class for bar type series.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../../const/');\nvar labelHelper = require('./renderingLabelHelper');\nvar predicate = require('../../helpers/predicate');\nvar renderUtil = require('../../helpers/renderUtil');\n\nvar BarTypeSeriesBase = tui.util.defineClass(/** @lends BarTypeSeriesBase.prototype */ {\n    /**\n     * Make series data.\n     * @returns {object} add data\n     * @private\n     * @override\n     */\n    _makeSeriesData: function() {\n        this.groupBounds = this._makeBounds(this.layout.dimension);\n\n        return {\n            groupBounds: this.groupBounds,\n            seriesDataModel: this._getSeriesDataModel()\n        };\n    },\n\n    /**\n     * Make bar gutter.\n     * @param {number} groupSize bar group size\n     * @param {number} itemCount group item count\n     * @returns {number} bar gutter\n     * @private\n     */\n    _makeBarGutter: function(groupSize, itemCount) {\n        var baseSize = groupSize / (itemCount + 1) / 2;\n        var standardSize = 6;\n        var gutter;\n\n        if (baseSize &lt;= 2) {\n            gutter = 0;\n        } else if (baseSize &lt;= standardSize) {\n            gutter = 2;\n        } else {\n            gutter = 4;\n        }\n\n        return gutter;\n    },\n\n    /**\n     * Make bar size.\n     * @param {number} groupSize bar group size\n     * @param {number} barGutter bar padding\n     * @param {number} itemCount group item count\n     * @returns {number} bar size (width or height)\n     * @private\n     */\n    _makeBarSize: function(groupSize, barGutter, itemCount) {\n        return (groupSize - (barGutter * (itemCount - 1))) / (itemCount + 1);\n    },\n\n    /**\n     * Make option size.\n     * @param {number} barSize bar size\n     * @param {?number} optionBarWidth barWidth option\n     * @returns {number} option size\n     * @private\n     */\n    _makeOptionSize: function(barSize, optionBarWidth) {\n        var optionsSize = 0;\n\n        if (optionBarWidth) {\n            optionsSize = Math.min(barSize, optionBarWidth);\n        }\n\n        return optionsSize;\n    },\n\n    /**\n     * Calculate difference between optionSize and barSize.\n     * @param {number} barSize bar size\n     * @param {number} optionSize option size\n     * @param {number} itemCount item count\n     * @returns {number} addition padding\n     * @private\n     */\n    _calculateAdditionalPosition: function(barSize, optionSize, itemCount) {\n        var additionalPosition = 0;\n\n        if (optionSize &amp;&amp; optionSize &lt; barSize) {\n            additionalPosition = (barSize / 2) + ((barSize - optionSize) * itemCount / 2);\n        }\n\n        return additionalPosition;\n    },\n\n    /**\n     * Make base data for making bound.\n     * @param {number} baseGroupSize base group size\n     * @param {number} baseBarSize base bar size\n     * @returns {{\n     *      baseBarSize: number,\n     *      groupSize: number,\n     *      barSize: number,\n     *      step: number,\n     *      firstAdditionalPosition: number,\n     *      additionalPosition: number,\n     *      basePosition: number\n     * }}\n     * @private\n     */\n    _makeBaseDataForMakingBound: function(baseGroupSize, baseBarSize) {\n        var isStackType = predicate.isValidStackOption(this.options.stackType);\n        var seriesDataModel = this._getSeriesDataModel();\n        var groupSize = baseGroupSize / seriesDataModel.getGroupCount();\n        var firstAdditionalPosition = 0;\n        var itemCount, barGutter, barSize, optionSize, additionalPosition, basePosition;\n\n        if (!isStackType) {\n            itemCount = seriesDataModel.getFirstSeriesGroup().getSeriesItemCount();\n        } else {\n            itemCount = this.options.diverging ? 1 : this.dataProcessor.getStackCount();\n        }\n\n        barGutter = this._makeBarGutter(groupSize, itemCount);\n        barSize = this._makeBarSize(groupSize, barGutter, itemCount);\n        optionSize = this._makeOptionSize(barSize, this.options.barWidth);\n        additionalPosition = this._calculateAdditionalPosition(barSize, optionSize, itemCount);\n        barSize = optionSize || barSize;\n        basePosition = this._getLimitDistanceFromZeroPoint(baseBarSize, this.limit).toMin;\n\n        if (predicate.isColumnChart(this.chartType)) {\n            basePosition = baseBarSize - basePosition;\n        }\n\n        if (!this.options.barWidth || barSize &lt; this.options.barWidth) {\n            firstAdditionalPosition = (barSize / 2) + additionalPosition;\n        }\n\n        return {\n            baseBarSize: baseBarSize,\n            groupSize: groupSize,\n            barSize: barSize,\n            step: barGutter + barSize,\n            firstAdditionalPosition: firstAdditionalPosition,\n            additionalPosition: additionalPosition,\n            basePosition: basePosition\n        };\n    },\n\n    /**\n     * Render normal series label.\n     * @param {HTMLElement} labelContainer series label area element\n     * @private\n     */\n    _renderNormalSeriesLabel: function(labelContainer) {\n        var sdm = this._getSeriesDataModel();\n        var boundsSet = this.seriesData.groupBounds;\n        var labelTheme = this.theme.label;\n        var selectedIndex = this.selectedLegendIndex;\n        var positionsSet, html;\n\n        if (predicate.isBarChart(this.chartType)) {\n            positionsSet = labelHelper.boundsToLabelPositionsForBarChart(sdm, boundsSet, labelTheme);\n        } else {\n            positionsSet = labelHelper.boundsToLabelPositionsForColumnChart(sdm, boundsSet, labelTheme);\n        }\n\n        html = labelHelper.makeLabelsHtmlForBoundType(sdm, positionsSet, labelTheme, selectedIndex);\n\n        labelContainer.innerHTML = html;\n    },\n\n    /**\n     * Make sum values.\n     * @param {Array.&lt;number>} values values\n     * @returns {number} sum result.\n     */\n    _makeSumValues: function(values) {\n        var sum = tui.util.sum(values);\n\n        return renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions(), this.chartType, 'seires');\n    },\n\n    /**\n     * Make stackType label position.\n     * @param {{width: number, height: number, left: number, top: number}} bound element bound\n     * @param {string} label label\n     * @param {number} labelHeight label height\n     * @returns {{left: number, top: number}} position\n     * @private\n     */\n    _makeStackedLabelPosition: function(bound, label, labelHeight) {\n        var labelWidth = renderUtil.getRenderedLabelWidth(label, this.theme.label),\n            left = bound.left + ((bound.width - labelWidth + chartConst.TEXT_PADDING) / 2),\n            top = bound.top + ((bound.height - labelHeight + chartConst.TEXT_PADDING) / 2);\n\n        return {\n            left: left,\n            top: top\n        };\n    },\n\n    /**\n     * Make stackType labels html.\n     * @param {object} params parameters\n     *      @param {number} params.groupIndex group index\n     *      @param {Array.&lt;object>} params.bounds bounds,\n     *      @param {number} params.labelHeight label height\n     * @returns {string} labels html\n     * @private\n     */\n    _makeStackedLabelsHtml: function(params) {\n        var self = this,\n            seriesGroup = params.seriesGroup,\n            labelHeight = params.labelHeight,\n            htmls, plusBound, minusBound, values;\n\n        htmls = seriesGroup.map(function(seriesItem, index) {\n            var bound = params.bounds[index],\n                labelHtml = '',\n                boundEnd, position;\n\n            if (bound &amp;&amp; seriesItem) {\n                boundEnd = bound.end;\n                position = self._makeStackedLabelPosition(boundEnd, seriesItem.label, params.labelHeight);\n                labelHtml = self._makeSeriesLabelHtml(position, seriesItem.label, index);\n            }\n\n            if (seriesItem.value > 0) {\n                plusBound = boundEnd;\n            } else if (seriesItem.value &lt; 0) {\n                minusBound = boundEnd;\n            }\n\n            return labelHtml;\n        });\n\n        if (predicate.isNormalStack(this.options.stackType)) {\n            values = seriesGroup.pluck('value');\n            htmls.push(this._makePlusSumLabelHtml(values, plusBound, labelHeight));\n            htmls.push(this._makeMinusSumLabelHtml(values, minusBound, labelHeight));\n        }\n\n        return htmls.join('');\n    },\n\n    /**\n     * Render stackType series label.\n     * @param {HTMLElement} elSeriesLabelArea series label area element\n     * @private\n     */\n    _renderStackedSeriesLabel: function(elSeriesLabelArea) {\n        var self = this;\n        var groupBounds = this.seriesData.groupBounds;\n        var seriesDataModel = this._getSeriesDataModel();\n        var labelHeight = renderUtil.getRenderedLabelHeight(chartConst.MAX_HEIGHT_WORLD, this.theme.label);\n        var html = seriesDataModel.map(function(seriesGroup, index) {\n            var labelsHtml = self._makeStackedLabelsHtml({\n                groupIndex: index,\n                seriesGroup: seriesGroup,\n                bounds: groupBounds[index],\n                labelHeight: labelHeight\n            });\n\n            return labelsHtml;\n        }).join('');\n\n        elSeriesLabelArea.innerHTML = html;\n    },\n\n    /**\n     * Render series label.\n     * @param {HTMLElement} labelContainer series label area element\n     * @private\n     */\n    _renderSeriesLabel: function(labelContainer) {\n        if (this.options.stackType) {\n            this._renderStackedSeriesLabel(labelContainer);\n        } else {\n            this._renderNormalSeriesLabel(labelContainer);\n        }\n    }\n});\n\nBarTypeSeriesBase.mixin = function(func) {\n    tui.util.extend(func.prototype, BarTypeSeriesBase.prototype);\n};\n\nmodule.exports = BarTypeSeriesBase;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"