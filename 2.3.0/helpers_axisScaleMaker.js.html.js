tui.util.defineNamespace("fedoc.content", {});
fedoc.content["helpers_axisScaleMaker.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview AxisScaleMaker calculates the limit and step into values of processed data and returns it.\n * @auth NHN Ent.\n *       FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const');\nvar predicate = require('./predicate');\nvar calculator = require('./calculator');\nvar renderUtil = require('./renderUtil');\n\nvar abs = Math.abs;\n\nvar AxisScaleMaker = tui.util.defineClass(/** @lends AxisScaleMaker.prototype */{\n    /**\n     * AxisScaleMaker calculates the limit and step into values of processed data and returns it.\n     * @param {object} params parameters\n     * @constructs AxisScaleMaker\n     */\n    init: function(params) {\n        /**\n         * Data processor\n         * @type {DataProcessor}\n         */\n        this.dataProcessor = params.dataProcessor;\n\n        /**\n         * Bounds maker\n         * @type {BoundsMaker}\n         */\n        this.boundsMaker = params.boundsMaker;\n\n        /**\n         * stackType option\n         * @type {?string}\n         */\n        this.stackType = params.stackType;\n\n        /**\n         * diverging option\n         * @type {?boolean}\n         */\n        this.diverging = params.diverging;\n\n        /**\n         * limit option\n         * @type {?{min: number, max: number}}\n         */\n        this.limitOption = params.limitOption;\n\n        /**\n         * axis type\n         * @type {?string}\n         */\n        this.type = params.type;\n\n        /**\n         * date format\n         * @type {?string}\n         */\n        this.dateFormat = params.dateFormat;\n\n        /**\n         * Chart type\n         * @type {string}\n         */\n        this.chartType = params.chartType;\n\n        /**\n         * type of value like value, x, y, r\n         * @type {string}\n         */\n        this.valueType = params.valueType;\n\n        /**\n         * type of area like yAxis, xAxis\n         * @type {string}\n         */\n        this.areaType = params.areaType;\n\n        /**\n         * Whether vertical type or not.\n         * @type {boolean}\n         */\n        this.isVertical = !!params.isVertical;\n\n        /**\n         * Whether single yAxis or not.\n         * @type {boolean}\n         */\n        this.isSingleYAxis = !!params.isSingleYAxis;\n        /**\n         * Count of scale values.\n         * @type {number}\n         */\n        this.valueCounts = params.valueCount ? [params.valueCount] : null;\n\n        /**\n         * Axis scale\n         * @type {{limit: {min: number, max: number}, step: number}}\n         */\n        this.scale = null;\n\n        /**\n         * Formatted scale values.\n         * @type {Array.&lt;string | number>}\n         */\n        this.formattedValues = null;\n    },\n\n    /**\n     * Get scale.\n     * @returns {{limit: {min: number, max: number}, step: number}}\n     * @private\n     */\n    _getScale: function() {\n        if (!this.scale) {\n            this.scale = this._makeScale();\n        }\n\n        return this.scale;\n    },\n\n    /**\n     * Get limit.\n     * @returns {{min: number, max: number}}\n     */\n    getLimit: function() {\n        return this._getScale().limit;\n    },\n\n    /**\n     * Get step.\n     * @returns {number}\n     */\n    getStep: function() {\n        return this._getScale().step;\n    },\n\n    /**\n     * Whether percent stack chart or not.\n     * @returns {boolean}\n     * @private\n     */\n    _isPercentStackChart: function() {\n        var isAllowedStackOption = predicate.isAllowedStackOption(this.chartType),\n            isPercentStack = predicate.isPercentStack(this.stackType);\n\n        return isAllowedStackOption &amp;&amp; isPercentStack;\n    },\n\n    /**\n     * Whether normal stack chart or not.\n     * @returns {boolean}\n     * @private\n     */\n    _isNormalStackChart: function() {\n        var isAllowedStackOption = predicate.isAllowedStackOption(this.chartType),\n            isNormalStack = predicate.isNormalStack(this.stackType);\n\n        return isAllowedStackOption &amp;&amp; isNormalStack;\n    },\n\n    /**\n     * Whether diverging chart or not.\n     * @returns {boolean|*}\n     * @private\n     */\n    _isDivergingChart: function() {\n        return this.diverging &amp;&amp; predicate.isBarTypeChart(this.chartType);\n    },\n\n    /**\n     * Get functions for formatting value.\n     * @returns {Array.&lt;function>}\n     * @private\n     */\n    _getFormatFunctions: function() {\n        var formatFunctions;\n\n        if (this._isPercentStackChart()) {\n            formatFunctions = [function(value) {\n                return value + '%';\n            }];\n        } else {\n            formatFunctions = this.dataProcessor.getFormatFunctions();\n        }\n\n        return formatFunctions;\n    },\n\n    /**\n     * Get scale values.\n     * @returns {Array.&lt;number>}\n     * @private\n     */\n    _getScaleValues: function() {\n        var scale = this._getScale(),\n            values = calculator.makeLabelsFromLimit(scale.limit, scale.step);\n\n        return this._isDivergingChart() ? tui.util.map(values, abs) : values;\n    },\n\n    /**\n     * Get formatted scale values.\n     * @returns {Array.&lt;string|number>|*}\n     */\n    getFormattedScaleValues: function() {\n        var chartType = this.chartType;\n        var areaType = this.areaType;\n        var valueType = this.valueType;\n        var values, formatFunctions;\n\n        if (!this.formattedValues) {\n            values = this._getScaleValues();\n\n            if (predicate.isDatetimeType(this.type)) {\n                this.formattedValues = renderUtil.formatDates(values, this.dateFormat);\n            } else {\n                formatFunctions = this._getFormatFunctions();\n                this.formattedValues = renderUtil.formatValues(values, formatFunctions, chartType, areaType, valueType);\n            }\n        }\n\n        return this.formattedValues;\n    },\n\n    /**\n     * Make base values of normal stackType chart.\n     * @returns {Array.&lt;number>}\n     * @private\n     */\n    _makeBaseValuesForNormalStackedChart: function() {\n        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType);\n        var baseValues = [];\n\n        seriesDataModel.each(function(seriesGroup) {\n            var valuesMap = seriesGroup._makeValuesMapPerStack();\n\n            tui.util.forEach(valuesMap, function(values) {\n                var plusSum = calculator.sumPlusValues(values);\n                var minusSum = calculator.sumMinusValues(values);\n                baseValues = baseValues.concat([plusSum, minusSum]);\n            });\n        });\n\n        return baseValues;\n    },\n\n    /**\n     * Make base values for making axis scale.\n     * @returns {Array.&lt;number>} base values\n     * @private\n     */\n    _makeBaseValues: function() {\n        var baseValues;\n\n        if (this.isSingleYAxis) {\n            baseValues = this.dataProcessor.getValues();\n            if (this._isNormalStackChart()) {\n                baseValues = baseValues.concat(this._makeBaseValuesForNormalStackedChart());\n            }\n        } else if (predicate.isTreemapChart(this.chartType)) {\n            baseValues = this.dataProcessor.getValues(this.chartType, 'colorValue');\n        } else if (predicate.isMapChart(this.chartType)) {\n            baseValues = this.dataProcessor.getValues();\n        } else if (this._isNormalStackChart()) {\n            baseValues = this._makeBaseValuesForNormalStackedChart();\n        } else {\n            baseValues = this.dataProcessor.getValues(this.chartType, this.valueType);\n        }\n\n        return baseValues;\n    },\n\n    /**\n     * Get base size for calculation candidate value counts.\n     * @returns {number} base size\n     * @private\n     */\n    _getBaseSize: function() {\n        var baseSize;\n\n        if (this.isVertical) {\n            baseSize = this.boundsMaker.makeSeriesHeight();\n        } else {\n            baseSize = this.boundsMaker.makeSeriesWidth();\n        }\n\n        return baseSize;\n    },\n\n    /**\n     * Get candidate counts of value.\n     * @memberOf module:axisDataMaker\n     * @returns {Array.&lt;number>} value counts\n     * @private\n     */\n    _getCandidateCountsOfValue: function() {\n        var minStart = 3,\n            valueCounts, baseSize, start, end;\n\n        baseSize = this._getBaseSize();\n        start = Math.max(minStart, parseInt(baseSize / chartConst.MAX_PIXEL_TYPE_STEP_SIZE, 10));\n        end = Math.max(start, parseInt(baseSize / chartConst.MIN_PIXEL_TYPE_STEP_SIZE, 10)) + 1;\n        valueCounts = tui.util.range(start, end);\n\n        return valueCounts;\n    },\n\n    /**\n     * Make limit for diverging option.\n     * @param {{min: number, max: number}} limit limit\n     * @returns {{min: number, max: number}} changed limit\n     * @private\n     */\n    _makeLimitForDivergingOption: function(limit) {\n        var newMax = Math.max(abs(limit.min), abs(limit.max));\n\n        return {\n            min: -newMax,\n            max: newMax\n        };\n    },\n\n    /**\n     * Make integer type scale.\n     * @memberOf module:axisDataMaker\n     * @param {{min: number, max: number}} limit limit\n     * @returns {{\n     *      limit: {min: number, max: number},\n     *      options: {min: number, max: number},\n     *      divideNum: number\n     * }} integer type info\n     * @private\n     */\n    _makeIntegerTypeScale: function(limit) {\n        var options = this.limitOption || {},\n            min = limit.min,\n            max = limit.max,\n            multipleNum, changedOptions;\n\n        if (abs(min) >= 1 || abs(max) >= 1) {\n            return {\n                limit: limit,\n                options: options,\n                divisionNumber: 1\n            };\n        }\n\n        multipleNum = tui.util.findMultipleNum(min, max);\n        changedOptions = {};\n\n        if (!tui.util.isUndefined(options.min)) {\n            changedOptions.min = options.min * multipleNum;\n        }\n\n        if (!tui.util.isUndefined(options.max)) {\n            changedOptions.max = options.max * multipleNum;\n        }\n\n        return {\n            limit: {\n                min: min * multipleNum,\n                max: max * multipleNum\n            },\n            options: changedOptions,\n            divisionNumber: multipleNum\n        };\n    },\n\n    /**\n     * Make limit if equal min and max.\n     * @param {{min: number, max: number}} limit limit\n     * @returns {{min: number, max: number}} changed limit\n     * @private\n     */\n    _makeLimitIfEqualMinMax: function(limit) {\n        var min = limit.min,\n            max = limit.max;\n\n        if (min > 0) {\n            min = 0;\n        } else if (min &lt; 0) {\n            max = 0;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    /**\n     * Make base limit\n     * @memberOf module:axisDataMaker\n     * @param {{min: number, max: number}} dataLimit user limit\n     * @param {{min: number, max: number}} options axis options\n     * @returns {{min: number, max: number}} base limit\n     * @private\n     */\n    _makeBaseLimit: function(dataLimit, options) {\n        var isMinusLimit = predicate.isMinusLimit(dataLimit),\n            min = dataLimit.min,\n            max = dataLimit.max,\n            baseLimit, tmpMin;\n\n        if (min === max) {\n            baseLimit = this._makeLimitIfEqualMinMax(dataLimit);\n        } else {\n            if (isMinusLimit) {\n                tmpMin = min;\n                min = -max;\n                max = -tmpMin;\n            }\n\n            baseLimit = calculator.calculateLimit(min, max);\n\n            if (isMinusLimit) {\n                tmpMin = baseLimit.min;\n                baseLimit.min = -baseLimit.max;\n                baseLimit.max = -tmpMin;\n            }\n\n            baseLimit.min = tui.util.isUndefined(options.min) ? baseLimit.min : options.min;\n            baseLimit.max = tui.util.isUndefined(options.max) ? baseLimit.max : options.max;\n        }\n\n        return baseLimit;\n    },\n\n    /**\n     * Normalize min.\n     * @memberOf module:axisDataMaker\n     * @param {number} min original min\n     * @param {number} step scale step\n     * @returns {number} normalized min\n     * @private\n     */\n    _normalizeMin: function(min, step) {\n        var mod = tui.util.mod(min, step),\n            normalized;\n\n        if (mod === 0) {\n            normalized = min;\n        } else {\n            normalized = tui.util.subtraction(min, (min >= 0 ? mod : step + mod));\n        }\n\n        return normalized;\n    },\n\n    /**\n     * Make normalized max.\n     * @memberOf module:axisDataMaker\n     * @param {{min: number, max: number}} limit limit\n     * @param {number} step scale step\n     * @param {number} valueCount value count\n     * @returns {number} normalized max\n     * @private\n     */\n    _makeNormalizedMax: function(limit, step, valueCount) {\n        var minMaxDiff = tui.util.multiplication(step, valueCount - 1),\n            normalizedMax = tui.util.addition(limit.min, minMaxDiff),\n            maxDiff = limit.max - normalizedMax,\n            modDiff, divideDiff;\n        // normalize된 max값이 원래의 max값 보다 작을 경우 step을 증가시켜 큰 값으로 만들기\n        if (maxDiff > 0) {\n            modDiff = maxDiff % step;\n            divideDiff = Math.floor(maxDiff / step);\n            normalizedMax += step * (modDiff > 0 ? divideDiff + 1 : divideDiff);\n        }\n\n        return normalizedMax;\n    },\n\n    /**\n     * Normalize limit.\n     * @param {{min: number, max: number}} limit base limit\n     * @param {number} step scale step\n     * @param {number} valueCount value count\n     * @returns {{min: number, max: number}} normalized limit\n     * @private\n     */\n    _normalizeLimit: function(limit, step, valueCount) {\n        limit.min = this._normalizeMin(limit.min, step);\n        limit.max = this._makeNormalizedMax(limit, step, valueCount);\n\n        return limit;\n    },\n\n    /**\n     * Decrease minimum value by step value,\n     *  when chart type is line or dataMin is minus, options is undefined, minimum values(min, dataMin) are same.\n     * @param {number} min base min\n     * @param {number} dataMin minimum value of user data\n     * @param {number} step scale step\n     * @param {?number} optionMin min option\n     * @returns {number} changed min\n     * @private\n     */\n    _decreaseMinByStep: function(min, dataMin, step, optionMin) {\n        var isLineChart = predicate.isLineChart(this.chartType);\n        var isAreaChartX = predicate.isAreaChart(this.chartType) &amp;&amp; !this.isVertical;\n        var isMinusDataMin = dataMin &lt; 0;\n        var isUndefinedMinOption = tui.util.isUndefined(optionMin);\n        var isSame = (min === dataMin);\n\n        if ((isLineChart || isAreaChartX || isMinusDataMin) &amp;&amp; isUndefinedMinOption &amp;&amp; isSame) {\n            min -= step;\n        }\n\n        return min;\n    },\n\n    /**\n     * Increase maximum value by step value,\n     *  when chart type is line or dataMin is plus, options is undefined, maximum values(max, dataMax) are same.\n     * @param {number} max base max\n     * @param {number} dataMax maximum value of user data\n     * @param {number} step scale step\n     * @param {?number} optionMax max option\n     * @returns {number} changed max\n     * @private\n     */\n    _increaseMaxByStep: function(max, dataMax, step, optionMax) {\n        var isLineChart = predicate.isLineChart(this.chartType),\n            isPlusDataMax = dataMax > 0,\n            isUndefinedMaxOption = tui.util.isUndefined(optionMax),\n            isSame = (max === dataMax);\n\n        if ((isLineChart || isPlusDataMax) &amp;&amp; isUndefinedMaxOption &amp;&amp; isSame) {\n            max += step;\n        }\n\n        return max;\n    },\n\n    /**\n     * Divide scale step.\n     * @param {{min: number, max: number}} limit limit\n     * @param {number} step step\n     * @param {number} candidateValueCount candidate valueCount\n     * @returns {number} scale step\n     * @private\n     */\n    _divideScaleStep: function(limit, step, candidateValueCount) {\n        var isEvenStep = ((step % 2) === 0),\n            valueCount = calculator.makeLabelsFromLimit(limit, step).length,\n            twiceValueCount = (valueCount * 2) - 1,\n            diffOrg = abs(candidateValueCount - valueCount),\n            diffTwice = abs(candidateValueCount - twiceValueCount);\n\n        // step을 반으로 나누었을 때의 valueCount가 후보로 계산된 candidateValueCount와 인접하면 step을 반으로 나누어 반환합니다.\n        if (isEvenStep &amp;&amp; diffTwice &lt;= diffOrg) {\n            step = step / 2;\n        }\n\n        return step;\n    },\n\n    /**\n     * Minimize scale limit.\n     * @param {{min: number, max: number}} limit base limit\n     * @param {{min: number, max: number}} dataLimit limit of user data\n     * @param {number} step scale step\n     * @param {number} valueCount value count\n     * @param {{min: number, max:number}} options limit options of axis\n     * @returns {{min: number, max: number}} minimized limit\n     * @private\n     */\n    _minimizeScaleLimit: function(limit, dataLimit, step, valueCount, options) {\n        var min = limit.max,\n            max = limit.min,\n            comparisonMin = tui.util.isUndefined(options.min) ? dataLimit.min - 1 : options.min,\n            comparisonMax = tui.util.isUndefined(options.max) ? dataLimit.max + 1 : options.max;\n\n        tui.util.forEachArray(tui.util.range(1, valueCount), function(valueIndex) {\n            var changingStep = (step * valueIndex),\n                changedMin = max + changingStep,\n                changedMax = min - changingStep;\n\n            // limit이 dataLimit 범위를 넘어갈 것으로 예상되는 경우에 변경을 중단함\n            if (dataLimit.min &lt;= changedMin &amp;&amp; dataLimit.max >= changedMax) {\n                return false;\n            }\n\n            if (comparisonMin >= changedMin) {\n                limit.min = changedMin;\n            }\n\n            if (comparisonMax &lt;= changedMax) {\n                limit.max = changedMax;\n            }\n\n            return true;\n        });\n\n        return limit;\n    },\n\n    /**\n     * Adjust limit for bubble chart.\n     * @param {{min: number, max: number}} limit - limit\n     * @param {number} step - step;\n     * @private\n     */\n    _adjustLimitForBubbleChart: function(limit, step) {\n        var valueType = this.valueType;\n        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType);\n        var maxRadiusValue = seriesDataModel.getMaxValue('r');\n        var isBiggerRatioThanHalfRatio = function(seriesItem) {\n            return (seriesItem.r / maxRadiusValue) > chartConst.HALF_RATIO;\n        };\n        var foundMinItem = seriesDataModel.findMinSeriesItem(valueType, isBiggerRatioThanHalfRatio);\n        var foundMaxItem = seriesDataModel.findMaxSeriesItem(valueType, isBiggerRatioThanHalfRatio);\n\n        if (foundMinItem) {\n            limit.min -= step;\n        }\n\n        if (foundMaxItem) {\n            limit.max += step;\n        }\n    },\n\n    /**\n     * Make candidate axis scale.\n     * @param {{min: number, max: number}} baseLimit base limit\n     * @param {{min: number, max: number}} dataLimit limit of user data\n     * @param {number} valueCount value count\n     * @param {{min: number, max:number}} options limit options of axis\n     * @returns {{\n     *      limit: {min: number, max: number},\n     *      step: number\n     * }} scale\n     * @private\n     */\n    _makeCandidateScale: function(baseLimit, dataLimit, valueCount, options) {\n        var limit = tui.util.extend({}, baseLimit),\n            step;\n\n        // 01. 기본 limit 정보로 step 얻기\n        step = calculator.calculateStepFromLimit(limit, valueCount);\n\n        // 02. step 정규화 시키기 (ex: 0.3 --> 0.5, 7 --> 10)\n        step = calculator.normalizeAxisNumber(step);\n\n        // 03. limit 정규화 시키기\n        limit = this._normalizeLimit(limit, step, valueCount);\n\n        // 04. line차트의 경우 사용자의 min값이 limit의 min값과 같을 경우, min값을 1 step 감소 시킴\n        limit.min = this._decreaseMinByStep(limit.min, dataLimit.min, step, options.min);\n\n        // 04. 사용자의 max값이 scale max와 같을 경우, max값을 1 step 증가 시킴\n        limit.max = this._increaseMaxByStep(limit.max, dataLimit.max, step, options.max);\n\n        // 05. axis limit이 사용자 min, max와 거리가 멀 경우 조절\n        limit = this._minimizeScaleLimit(limit, dataLimit, step, valueCount, options);\n\n        // 06. 조건에 따라 step값을 반으로 나눔\n        step = this._divideScaleStep(limit, step, valueCount);\n\n        if (predicate.isBubbleChart(this.chartType)) {\n            this._adjustLimitForBubbleChart(limit, step);\n        }\n\n        return {\n            limit: limit,\n            step: step,\n            valueCount: abs(limit.max - limit.min) / step\n        };\n    },\n\n    /**\n     * Make candidates about axis scale.\n     * @param {{\n     *      limit: {min: number, max: number},\n     *      options: {min: number, max: number},\n     *      divisionNumber: number\n     * }} integerTypeScale - integer type axis scale\n     * @param {Array.&lt;number>} valueCounts - candidate counts of value\n     * @returns {Array.&lt;{limit:{min: number, max: number}, stpe: number}>} - candidates scale\n     * @private\n     */\n    _makeCandidateScales: function(integerTypeScale, valueCounts) {\n        var self = this;\n        var dataLimit = integerTypeScale.limit;\n        var options = integerTypeScale.options;\n        var baseLimit = this._makeBaseLimit(dataLimit, options);\n\n        return tui.util.map(valueCounts, function(valueCount) {\n            return self._makeCandidateScale(baseLimit, dataLimit, valueCount, options);\n        });\n    },\n\n    /**\n     * Get comparing value for selecting axis scale.\n     * @param {{min: number, max: number}} baseLimit - limit\n     * @param {Array.&lt;number>} valueCounts - candidate counts of value\n     * @param {{limit: {min: number, max: number}, step: number}} candidateScale - scale\n     * @param {number} index - index\n     * @returns {number} comparing value\n     * @private\n     */\n    _getComparingValue: function(baseLimit, valueCounts, candidateScale, index) {\n        var diffMax = abs(candidateScale.limit.max - baseLimit.max);\n        var diffMin = abs(baseLimit.min - candidateScale.limit.min);\n        // 예상 label count와 차이가 많을 수록 후보 제외 가능성이 높음\n        var diffCount = Math.max(abs(valueCounts[index] - candidateScale.valueCount), 1);\n        // 소수점 이하 길이가 길 수록 후보에서 제외될 가능성이 높음\n        var weight = Math.pow(10, tui.util.getDecimalLength(candidateScale.step));\n\n        return (diffMax + diffMin) * diffCount * weight;\n    },\n\n    /**\n     * Select axis scale.\n     * @param {{min: number, max: number}} baseLimit limit\n     * @param {Array.&lt;{limit: {min: number, max: number}, step: number}>} candidates scale candidates\n     * @param {Array.&lt;number>} valueCounts - label counts\n     * @returns {{limit: {min: number, max: number}, step: number}} selected scale\n     * @private\n     */\n    _selectAxisScale: function(baseLimit, candidates, valueCounts) {\n        var getComparingValue = tui.util.bind(this._getComparingValue, this, baseLimit, valueCounts);\n        var axisScale = tui.util.min(candidates, getComparingValue);\n\n        return axisScale;\n    },\n\n    /**\n     * Restore number state of scale.\n     * @memberOf module:axisDataMaker\n     * @param {{limit: {min: number, max: number}, step: number}} scale scale\n     * @param {number} divisionNumber divide num\n     * @returns {{limit: {min: number, max: number}, step: number}} restored scale\n     * @private\n     */\n    _restoreNumberState: function(scale, divisionNumber) {\n        if (divisionNumber === 1) {\n            return scale;\n        }\n\n        scale.step = tui.util.division(scale.step, divisionNumber);\n        scale.limit.min = tui.util.division(scale.limit.min, divisionNumber);\n        scale.limit.max = tui.util.division(scale.limit.max, divisionNumber);\n\n        return scale;\n    },\n\n    /**\n     * millisecond map\n     */\n    millisecondMap: {\n        year: 31536000000,\n        month: 2678400000,\n        date: 86400000,\n        hour: 3600000,\n        minute: 60000,\n        second: 1000\n    },\n\n    /**\n     * millisecond types\n     */\n    millisecondTypes: ['year', 'month', 'date', 'hour', 'minute', 'second'],\n\n    /**\n     * Find date type.\n     * @param {{min: number, max: number}} dataLimit - data limit\n     * @param {number} count - data count\n     * @returns {string}\n     * @private\n     */\n    _findDateType: function(dataLimit, count) {\n        var diff = dataLimit.max - dataLimit.min;\n        var millisecondTypes = this.millisecondTypes;\n        var millisecondMap = this.millisecondMap;\n        var lastTypeIndex = millisecondTypes.length - 1;\n        var foundType;\n\n        if (diff) {\n            tui.util.forEachArray(millisecondTypes, function(type, index) {\n                var millisecond = millisecondMap[type];\n                var dividedCount = Math.floor(diff / millisecond);\n                var foundIndex;\n\n                if (dividedCount) {\n                    foundIndex = index &lt; lastTypeIndex &amp;&amp; (dividedCount &lt; count) ? index + 1 : index;\n                    foundType = millisecondTypes[foundIndex];\n                }\n\n                return !tui.util.isExisty(foundIndex);\n            });\n        } else {\n            foundType = chartConst.DATE_TYPE_SECOND;\n        }\n\n        return foundType;\n    },\n\n    /**\n     * Make datetime information\n     * @param {{min: number, max: number}} dataLimit - data limit\n     * @param {number} count - data count\n     * @returns {{divisionNumber: number, minDate: number, dataLimit: {min: number, max: number}}}\n     * @private\n     */\n    _makeDatetimeInfo: function(dataLimit, count) {\n        var dateType = this._findDateType(dataLimit, count);\n        var divisionNumber = this.millisecondMap[dateType];\n        var minDate = tui.util.division(dataLimit.min, divisionNumber);\n        var maxDate = tui.util.division(dataLimit.max, divisionNumber);\n        var max = maxDate - minDate;\n\n        return {\n            divisionNumber: divisionNumber,\n            minDate: minDate,\n            dataLimit: {\n                min: 0,\n                max: max\n            }\n        };\n    },\n\n    /**\n     * Restore scale to datetime type.\n     * @param {{scale: number, limit:{min: number, max: number}}} scale - scale\n     * @param {number} minDate - minimum date\n     * @param {number} divisionNumber - division number\n     * @returns {{step: number, limit: {min: number, max: number}}}\n     * @private\n     */\n    _restoreScaleToDatetimeType: function(scale, minDate, divisionNumber) {\n        var limit = scale.limit;\n\n        scale.step = tui.util.multiplication(scale.step, divisionNumber);\n        limit.min = tui.util.multiplication(tui.util.addition(limit.min, minDate), divisionNumber);\n        limit.max = tui.util.multiplication(tui.util.addition(limit.max, minDate), divisionNumber);\n\n        return scale;\n    },\n\n    /**\n     * Calculate scale.\n     * @returns {{limit: {min: number, max: number}, step: number}}\n     * @private\n     */\n    _calculateScale: function() {\n        var baseValues = this._makeBaseValues();\n        var dataLimit = {\n            min: tui.util.min(baseValues),\n            max: tui.util.max(baseValues)\n        };\n        var datetimeInfo, integerTypeScale, valueCounts, candidates, scale;\n\n        if (predicate.isDatetimeType(this.type)) {\n            datetimeInfo = this._makeDatetimeInfo(dataLimit, baseValues.length);\n            dataLimit = datetimeInfo.dataLimit;\n        }\n\n        if (dataLimit.min === 0 &amp;&amp; dataLimit.max === 0) {\n            dataLimit.max = 5;\n        }\n\n        if (this._isDivergingChart()) {\n            dataLimit = this._makeLimitForDivergingOption(dataLimit);\n        }\n\n        // 01. limit, options 정보를 정수형으로 변경\n        integerTypeScale = this._makeIntegerTypeScale(dataLimit);\n\n        // 02. value count 후보군 얻기\n        valueCounts = this.valueCounts || this._getCandidateCountsOfValue();\n\n        // 03. axis scale 후보군 얻기\n        candidates = this._makeCandidateScales(integerTypeScale, valueCounts);\n\n        // 04. axis scale 후보군 중 하나 선택\n        scale = this._selectAxisScale(integerTypeScale.limit, candidates, valueCounts);\n\n        // 05. 정수형으로 변경했던 scale를 원래 형태로 변경\n        scale = this._restoreNumberState(scale, integerTypeScale.divisionNumber);\n\n        if (predicate.isDatetimeType(this.type)) {\n            scale = this._restoreScaleToDatetimeType(scale, datetimeInfo.minDate, datetimeInfo.divisionNumber);\n        }\n\n        return scale;\n    },\n\n    /**\n     * Get values for sum.\n     * @returns {Array.&lt;number>}\n     * @private\n     */\n    _getValuesForSum: function() {\n        var values;\n\n        if (this.isSingleYAxis) {\n            values = this.dataProcessor.getValues();\n        } else {\n            values = this.dataProcessor.getValues(this.chartType);\n        }\n\n        return values;\n    },\n\n    /**\n     * Calculate minus sum about group values.\n     * @returns {number}\n     * @private\n     */\n    _calculateMinusSum: function() {\n        var values = this._getValuesForSum();\n\n        return calculator.sumMinusValues(values);\n    },\n\n    /**\n     * Calculate plus sum about group values.\n     * @returns {number}\n     * @private\n     */\n    _calculatePlusSum: function() {\n        var values = this._getValuesForSum();\n\n        return calculator.sumPlusValues(values);\n    },\n\n    /**\n     * Get percent stackType scale.\n     * @returns {{limit: {min:number, max:number}, step: number}}\n     * @private\n     */\n    _getPercentStackedScale: function() {\n        var scale;\n\n        if (this._calculateMinusSum() === 0) {\n            scale = chartConst.PERCENT_STACKED_AXIS_SCALE;\n        } else if (this._calculatePlusSum() === 0) {\n            scale = chartConst.MINUS_PERCENT_STACKED_AXIS_SCALE;\n        } else if (this._isDivergingChart()) {\n            scale = chartConst.DIVERGING_PERCENT_STACKED_AXIS_SCALE;\n        } else {\n            scale = chartConst.DUAL_PERCENT_STACKED_AXIS_SCALE;\n        }\n\n        return scale;\n    },\n\n    /**\n     * Make scale.\n     * @returns {{limit: {min:number, max:number}, step: number}}\n     * @private\n     */\n    _makeScale: function() {\n        var scale;\n\n        if (this._isPercentStackChart()) {\n            scale = this._getPercentStackedScale();\n        } else {\n            scale = this._calculateScale();\n        }\n\n        return scale;\n    }\n});\n\nmodule.exports = AxisScaleMaker;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"