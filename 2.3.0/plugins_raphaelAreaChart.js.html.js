tui.util.defineNamespace("fedoc.content", {});
fedoc.content["plugins_raphaelAreaChart.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Raphael area chart renderer.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar RaphaelLineBase = require('./raphaelLineTypeBase');\nvar raphaelRenderUtil = require('./raphaelRenderUtil');\n\nvar EMPHASIS_OPACITY = 1;\nvar DE_EMPHASIS_OPACITY = 0.3;\nvar LEFT_BAR_WIDTH = 10;\nvar ADDING_DATA_ANIMATION_DURATION = 300;\n\nvar raphael = window.Raphael;\nvar concat = Array.prototype.concat;\n\nvar RaphaelAreaChart = tui.util.defineClass(RaphaelLineBase, /** @lends RaphaelAreaChart.prototype */ {\n    /**\n     * RaphaelAreaChart is graph renderer for area chart.\n     * @constructs RaphaelAreaChart\n     * @extends RaphaelLineTypeBase\n     */\n    init: function() {\n        /**\n         * selected legend index\n         * @type {?number}\n         */\n        this.selectedLegendIndex = null;\n\n        /**\n         * type of chart\n         * @type {string}\n         */\n        this.chartType = 'area';\n    },\n\n    /**\n     * Render function of area chart.\n     * @param {HTMLElement} container container\n     * @param {{groupPositions: Array.&lt;Array>, dimension: object, theme: object, options: object}} data render data\n     * @param {object} paper - raphael paper\n     * @returns {object}\n     */\n    render: function(container, data, paper) {\n        var dimension = data.dimension;\n        var groupPositions = data.groupPositions;\n        var theme = data.theme;\n        var colors = theme.colors;\n        var opacity = data.options.showDot ? 1 : 0;\n        var borderStyle = this.makeBorderStyle(theme.borderColor, opacity);\n        var outDotStyle = this.makeOutDotStyle(opacity, borderStyle);\n\n        paper = paper || raphael(container, 1, dimension.height);\n\n        this.paper = paper;\n        this.isSpline = data.options.spline;\n        this.dimension = dimension;\n        this.zeroTop = data.zeroTop;\n        this.hasRangeData = data.hasRangeData;\n\n        this.groupPaths = this._getAreaChartPath(groupPositions);\n        this.groupAreas = this._renderAreas(paper, this.groupPaths, colors);\n        this.leftBar = this._renderLeftBar(dimension.height, data.chartBackground);\n        this.tooltipLine = this._renderTooltipLine(paper, dimension.height);\n        this.groupDots = this._renderDots(paper, groupPositions, colors, opacity);\n\n        if (data.options.allowSelect) {\n            this.selectionDot = this._makeSelectionDot(paper);\n            this.selectionColor = theme.selectionColor;\n\n            if (this.hasRangeData) {\n                this.selectionStartDot = this._makeSelectionDot(paper);\n            }\n        }\n\n        this.outDotStyle = outDotStyle;\n        this.groupPositions = groupPositions;\n        this.dotOpacity = opacity;\n\n        this.pivotGroupDots = null;\n\n        return paper;\n    },\n\n    /**\n     * Get path for area chart.\n     * @param {Array.&lt;Array.&lt;{left: number, top: number, startTop: number}>>} groupPositions - positions\n     * @param {boolean} [hasExtraPath] - whether has extra path or not\n     * @returns {*}\n     * @private\n     */\n    _getAreaChartPath: function(groupPositions, hasExtraPath) {\n        var path;\n\n        if (this.isSpline) {\n            path = this._makeSplineAreaChartPath(groupPositions, hasExtraPath);\n        } else {\n            path = this._makeAreaChartPath(groupPositions, hasExtraPath);\n        }\n\n        return path;\n    },\n\n    /**\n     * Render area graphs.\n     * @param {object} paper paper\n     * @param {Array.&lt;object>} groupPaths group paths\n     * @param {Array.&lt;string>} colors colors\n     * @returns {Array} raphael objects\n     * @private\n     */\n    _renderAreas: function(paper, groupPaths, colors) {\n        var groupAreas;\n\n        colors = colors.slice(0, groupPaths.length);\n        colors.reverse();\n        groupPaths.reverse();\n\n        groupAreas = tui.util.map(groupPaths, function(path, groupIndex) {\n            var areaColor = colors[groupIndex] || 'transparent',\n                lineColor = areaColor,\n                polygons = {\n                    area: raphaelRenderUtil.renderArea(paper, path.area.join(' '), {\n                        fill: areaColor,\n                        opacity: 0.5,\n                        stroke: areaColor\n                    }),\n                    line: raphaelRenderUtil.renderLine(paper, path.line.join(' '), lineColor, 1)\n                };\n\n            if (path.startLine) {\n                polygons.startLine = raphaelRenderUtil.renderLine(paper, path.startLine.join(' '), lineColor, 1);\n            }\n\n            return polygons;\n        });\n\n        return groupAreas.reverse();\n    },\n\n    /**\n     * Make height.\n     * @param {number} top top\n     * @param {number} startTop start top\n     * @returns {number} height\n     * @private\n     */\n    _makeHeight: function(top, startTop) {\n        return Math.abs(top - startTop);\n    },\n\n    /**\n     * Make areas path.\n     * @param {Array.&lt;{left: number, top: number, startTop: number}>} positions positions\n     * @param {boolean} [hasExtraPath] - whether has extra path or not\n     * @returns {Array.&lt;string | number>} path\n     * @private\n     */\n    _makeAreasPath: function(positions, hasExtraPath) {\n        var len = positions.length * 2;\n        var path = [];\n        var targetIndex;\n\n        tui.util.forEachArray(positions, function(position, index) {\n            path[index] = ['L', position.left, position.top];\n            path[len - index - 1] = ['L', position.left, position.startTop];\n        });\n\n        if (hasExtraPath !== false) {\n            targetIndex = positions.length - 1;\n            path.splice(targetIndex + 1, 0, path[targetIndex], path[targetIndex + 1]);\n        }\n\n        path = concat.apply([], path);\n        path[0] = 'M';\n\n        return path;\n    },\n\n    /**\n     * Make path for area chart.\n     * @param {Array.&lt;Array.&lt;{left: number, top: number, startTop: number}>>} groupPositions positions\n     * @param {boolean} [hasExtraPath] - whether has extra path or not\n     * @returns {Array.&lt;{area: Array.&lt;string | number>, line: Array.&lt;string | number>}>} path\n     * @private\n     */\n    _makeAreaChartPath: function(groupPositions, hasExtraPath) {\n        var self = this;\n\n        return tui.util.map(groupPositions, function(positions) {\n            var paths;\n\n            paths = {\n                area: self._makeAreasPath(positions, hasExtraPath),\n                line: self._makeLinesPath(positions)\n            };\n\n            if (self.hasRangeData) {\n                paths.startLine = self._makeLinesPath(positions, 'startTop');\n            }\n\n            return paths;\n        });\n    },\n\n    /**\n     * Make spline area bottom path.\n     * @param {Array.&lt;{left: number, top: number}>} positions positions\n     * @returns {Array.&lt;string | number>} spline area path\n     * @private\n     */\n    _makeSplineAreaBottomPath: function(positions) {\n        var self = this;\n\n        return tui.util.map(positions, function(position) {\n            return ['L', position.left, self.zeroTop];\n        }).reverse();\n    },\n\n    /**\n     * Make spline path for area chart.\n     * @param {Array.&lt;Array.&lt;{left: number, top: number, startTop: number}>>} groupPositions positions\n     * @param {boolean} [hasExtraPath] - whether has extra path or not\n     * @returns {Array.&lt;{area: Array.&lt;string | number>, line: Array.&lt;string | number>}>} path\n     * @private\n     */\n    _makeSplineAreaChartPath: function(groupPositions, hasExtraPath) {\n        var self = this;\n\n        return tui.util.map(groupPositions, function(positions) {\n            var linesPath = self._makeSplineLinesPath(positions);\n            var areaPath = JSON.parse(JSON.stringify(linesPath));\n            var areasBottomPath = self._makeSplineAreaBottomPath(positions);\n            var lastPosition;\n\n            if (hasExtraPath !== false) {\n                lastPosition = positions[positions.length - 1];\n                areaPath.push(['L', lastPosition.left, lastPosition.top]);\n                areasBottomPath.unshift(['L', lastPosition.left, self.zeroTop]);\n            }\n\n            return {\n                area: areaPath.concat(areasBottomPath),\n                line: linesPath\n            };\n        });\n    },\n\n    /**\n     * Resize graph of area chart.\n     * @param {object} params parameters\n     *      @param {{width: number, height:number}} params.dimension dimension\n     *      @param {Array.&lt;Array.&lt;{left:number, top:number}>>} params.groupPositions group positions\n     */\n    resize: function(params) {\n        var self = this,\n            dimension = params.dimension,\n            groupPositions = params.groupPositions;\n\n        this.zeroTop = params.zeroTop;\n        this.groupPositions = groupPositions;\n        this.groupPaths = this._getAreaChartPath(groupPositions);\n        this.paper.setSize(dimension.width, dimension.height);\n        this.tooltipLine.attr({top: dimension.height});\n\n        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {\n            var area = self.groupAreas[groupIndex];\n            area.area.attr({path: path.area.join(' ')});\n            area.line.attr({path: path.line.join(' ')});\n\n            if (area.startLine) {\n                area.startLine.attr({path: path.startLine.join(' ')});\n            }\n\n            tui.util.forEachArray(self.groupDots[groupIndex], function(item, index) {\n                var position = groupPositions[groupIndex][index];\n                var startPositon;\n\n                self._moveDot(item.endDot.dot, position);\n                if (item.startDot) {\n                    startPositon = tui.util.extend({}, position);\n                    startPositon.top = startPositon.startTop;\n                    self._moveDot(item.startDot.dot, startPositon);\n                }\n            });\n        });\n    },\n\n    /**\n     * Select legend.\n     * @param {?number} legendIndex legend index\n     */\n    selectLegend: function(legendIndex) {\n        var self = this,\n            noneSelected = tui.util.isNull(legendIndex);\n\n        this.selectedLegendIndex = legendIndex;\n\n        tui.util.forEachArray(this.groupAreas, function(area, groupIndex) {\n            var opacity = (noneSelected || legendIndex === groupIndex) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;\n\n            area.area.attr({'fill-opacity': opacity});\n            area.line.attr({'stroke-opacity': opacity});\n\n            if (area.startLine) {\n                area.startLine.attr({'stroke-opacity': opacity});\n            }\n\n            tui.util.forEachArray(self.groupDots[groupIndex], function(item) {\n                if (self.dotOpacity) {\n                    item.endDot.dot.attr({'fill-opacity': opacity});\n                    if (item.startDot) {\n                        item.startDot.dot.attr({'fill-opacity': opacity});\n                    }\n                }\n            });\n        });\n    },\n\n    /**\n     * Animate for adding data.\n     * @param {object} data - data for graph rendering\n     * @param {number} tickSize - tick size\n     * @param {Array.&lt;Array.&lt;object>>} groupPositions - group positions\n     * @param {boolean} [shiftingOption] - shifting option\n     * @param {number} zeroTop - position top value for zero point\n     */\n    animateForAddingData: function(data, tickSize, groupPositions, shiftingOption, zeroTop) {\n        var self = this;\n        var additionalIndex = 0;\n        var groupPaths;\n\n        if (!groupPositions.length) {\n            return;\n        }\n\n        this.zeroTop = zeroTop;\n\n        groupPaths = this._getAreaChartPath(groupPositions, false);\n\n        if (shiftingOption) {\n            this.leftBar.animate({\n                width: tickSize + LEFT_BAR_WIDTH\n            }, ADDING_DATA_ANIMATION_DURATION);\n            additionalIndex = 1;\n        }\n\n        tui.util.forEachArray(this.groupAreas, function(area, groupIndex) {\n            var dots = self.groupDots[groupIndex];\n            var groupPosition = groupPositions[groupIndex];\n            var pathMap = groupPaths[groupIndex];\n\n            if (shiftingOption) {\n                self._removeFirstDot(dots);\n            }\n\n            tui.util.forEachArray(dots, function(item, index) {\n                var position = groupPosition[index + additionalIndex];\n\n                self._animateByPosition(item.endDot.dot, position);\n\n                if (item.startDot) {\n                    self._animateByPosition(item.startDot.dot, {\n                        left: position.left,\n                        top: position.startTop\n                    });\n                }\n            });\n\n            self._animateByPath(area.area, pathMap.area);\n            self._animateByPath(area.line, pathMap.line);\n\n            if (area.startLine) {\n                self._animateByPath(area.startLine, pathMap.startLine);\n            }\n        });\n    }\n});\n\nmodule.exports = RaphaelAreaChart;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"