tui.util.defineNamespace("fedoc.content", {});
fedoc.content["legends_legendDimensionModel.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview LegendDimensionModel is model for calculating dimension of legend.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const');\nvar predicate = require('../helpers/predicate');\nvar renderUtil = require('../helpers/renderUtil');\n\nvar LegendDimensionModel = tui.util.defineClass(/** @lends LegendDimensionModel.prototype */ {\n    /**\n     * LegendDimensionModel is model for calculating dimension of legend.\n     * @constructs LegendDimensionModel\n     * @param {object} params parameters\n     *      @param {string} params.chartType - type of chart\n     *      @param {object} params.options - legend options\n     *      @param {object} params.theme - legend theme\n     *      @param {Array.&lt;string | number>} params.legendLabels - legend labels\n     */\n    init: function(params) {\n        this.chartType = params.chartType;\n\n        this.options = params.options;\n\n        this.theme = params.theme;\n\n        this.legendLabels = params.legendLabels;\n\n        this.legendCheckboxWidth = this.options.showCheckbox === false ? 0 : chartConst.LEGEND_CHECKBOX_WIDTH;\n    },\n\n    /**\n     * Make legend width.\n     * @param {number} labelWidth label width\n     * @returns {number}\n     * @private\n     */\n    _makeLegendWidth: function(labelWidth) {\n        return labelWidth + this.legendCheckboxWidth + chartConst.LEGEND_RECT_WIDTH +\n            chartConst.LEGEND_LABEL_LEFT_PADDING + chartConst.LEGEND_AREA_PADDING;\n    },\n\n    /**\n     * Calculate sum of legends width.\n     * @param {Array.&lt;string>} labels legend labels\n     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme\n     * @returns {number}\n     * @private\n     */\n    _calculateLegendsWidthSum: function(labels, labelTheme) {\n        var self = this;\n\n        return tui.util.sum(tui.util.map(labels, function(label) {\n            return self._makeLegendWidth(renderUtil.getRenderedLabelWidth(label, labelTheme));\n        }));\n    },\n\n    /**\n     * Divide legend labels.\n     * @param {Array.&lt;string>} labels legend labels\n     * @param {number} count division count\n     * @returns {Array.&lt;Array.&lt;string>>}\n     * @private\n     */\n    _divideLegendLabels: function(labels, count) {\n        var limitCount = Math.round(labels.length / count),\n            results = [],\n            temp = [];\n\n        tui.util.forEachArray(labels, function(label) {\n            if (temp.length &lt; limitCount) {\n                temp.push(label);\n            } else {\n                results.push(temp);\n                temp = [label];\n            }\n        });\n\n        if (temp.length) {\n            results.push(temp);\n        }\n\n        return results;\n    },\n\n    /**\n     * Get max line width.\n     * @param {Array.&lt;string>} dividedLabels - divided labels\n     * @param {{fontFamily: ?string, fontSize: ?string}} labelTheme - label theme\n     * @returns {number}\n     * @private\n     */\n    _getMaxLineWidth: function(dividedLabels, labelTheme) {\n        var self = this;\n        var lineWidths = tui.util.map(dividedLabels, function(_labels) {\n            return self._calculateLegendsWidthSum(_labels, labelTheme);\n        });\n\n        return tui.util.max(lineWidths);\n    },\n\n    /**\n     * Make division labels and max line width.\n     * @param {Array.&lt;string>} labels legend labels\n     * @param {number} chartWidth chart width\n     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme\n     * @returns {{dividedLabels: Array.&lt;Array.&lt;string>>, maxLineWidth: number}}\n     * @private\n     */\n    _makeDividedLabelsAndMaxLineWidth: function(labels, chartWidth, labelTheme) {\n        var divideCount = 1,\n            maxLineWidth = 0,\n            prevMaxWidth = 0,\n            dividedLabels, prevLabels;\n\n        do {\n            dividedLabels = this._divideLegendLabels(labels, divideCount);\n            maxLineWidth = this._getMaxLineWidth(dividedLabels, labelTheme);\n\n            if (prevMaxWidth === maxLineWidth) {\n                dividedLabels = prevLabels;\n                break;\n            }\n\n            prevMaxWidth = maxLineWidth;\n            prevLabels = dividedLabels;\n            divideCount += 1;\n        } while (maxLineWidth >= chartWidth);\n\n        return {\n            dividedLabels: dividedLabels,\n            maxLineWidth: maxLineWidth\n        };\n    },\n\n    /**\n     * Calculate height of horizontal legend.\n     * @param {Array.&lt;Array.&lt;string>>} dividedLabels divided labels\n     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme\n     * @returns {number}\n     * @private\n     */\n    _calculateHorizontalLegendHeight: function(dividedLabels, labelTheme) {\n        return tui.util.sum(tui.util.map(dividedLabels, function(labels) {\n            return renderUtil.getRenderedLabelsMaxHeight(labels, labelTheme);\n        }));\n    },\n\n    /**\n     * Make dimension of horizontal legend.\n     * @param {number} chartWidth chart width\n     * @returns {{width: number, height: (number)}}\n     * @private\n     */\n    _makeHorizontalDimension: function(chartWidth) {\n        var labelTheme = this.theme.label,\n            labelsAndMaxWidth = this._makeDividedLabelsAndMaxLineWidth(this.legendLabels, chartWidth, labelTheme),\n            horizontalLegendHeight = this._calculateHorizontalLegendHeight(labelsAndMaxWidth.dividedLabels, labelTheme),\n            legendHeight = horizontalLegendHeight + (chartConst.LEGEND_AREA_PADDING * 2);\n\n        return {\n            width: Math.max(labelsAndMaxWidth.maxLineWidth, chartConst.MIN_LEGEND_WIDTH),\n            height: legendHeight\n        };\n    },\n\n    /**\n     * Make dimension of vertical legend.\n     * @returns {{width: (number)}}\n     * @private\n     */\n    _makeVerticalDimension: function() {\n        var maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(this.legendLabels, this.theme.label),\n            legendWidth = this._makeLegendWidth(maxLabelWidth);\n        return {\n            width: legendWidth,\n            height: 0\n        };\n    },\n\n    /**\n     * Make legend dimension.\n     * @param {number} chartWidth chart width\n     * @returns {{width: number, height: number}}\n     */\n    makeDimension: function(chartWidth) {\n        var dimension = {};\n\n        if (!this.options.visible) {\n            dimension.width = 0;\n        } else if (predicate.isHorizontalLegend(this.options.align)) {\n            dimension = this._makeHorizontalDimension(chartWidth);\n        } else {\n            dimension = this._makeVerticalDimension();\n        }\n\n        return dimension;\n    }\n});\n\nmodule.exports = LegendDimensionModel;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"