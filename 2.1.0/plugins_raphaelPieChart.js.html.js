tui.util.defineNamespace("fedoc.content", {});
fedoc.content["plugins_raphaelPieChart.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview RaphaelPieCharts is graph renderer for pie chart.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar raphaelRenderUtil = require('./raphaelRenderUtil');\n\nvar raphael = window.Raphael;\n\nvar DEGREE_180 = 180;\nvar DEGREE_360 = 360;\nvar MIN_DEGREE = 0.01;\nvar RAD = Math.PI / DEGREE_180;\nvar LOADING_ANIMATION_DURATION = 700;\nvar EMPHASIS_OPACITY = 1;\nvar DE_EMPHASIS_OPACITY = 0.3;\nvar DEFAULT_LUMINANC = 0.2;\nvar OVERLAY_ID = 'overlay';\n\n/**\n * @classdesc RaphaelPieCharts is graph renderer for pie chart.\n * @class RaphaelPieChart\n */\nvar RaphaelPieChart = tui.util.defineClass(/** @lends RaphaelPieChart.prototype */ {\n    /**\n     * Render function of pie chart.\n     * @param {HTMLElement} container container\n     * @param {{\n     *      sectorData: Array.&lt;object>,\n     *      circleBound: {cx: number, cy: number, r: number},\n     *      dimension: object, theme: object, options: object\n     * }} data render data\n     * @param {object} callbacks callbacks\n     *      @param {function} callbacks.showTooltip show tooltip function\n     *      @param {function} callbacks.hideTooltip hide tooltip function\n     * @returns {object} paper raphael paper\n     */\n    render: function(container, data, callbacks) {\n        var dimension = data.dimension;\n        var paper;\n\n        /**\n         * raphael object\n         * @type {object}\n         */\n        if (data.paper) {\n            this.paper = paper = data.paper;\n        } else {\n            this.paper = paper = raphael(container, dimension.width, dimension.height);\n        }\n\n        /**\n         * series container\n         * @type {HTMLElement}\n         */\n        this.container = container;\n\n        /**\n         * ratio for hole\n         * @type {number}\n         */\n        this.holeRatio = data.options.radiusRange[0];\n\n        /**\n         * base background\n         * @type {string}\n         */\n        this.chartBackground = data.chartBackground;\n\n        /**\n         * type of chart\n         * @type {string}\n         */\n        this.chartType = data.chartType;\n\n        /**\n         * functions for tooltip control\n         * @type {{showTooltip: Function, hideTooltip: Function}}\n         */\n        this.callbacks = callbacks;\n\n        /**\n         * color for selection\n         * @type {string}\n         */\n        this.selectionColor = data.theme.selectionColor;\n\n        /**\n         * bound for circle\n         * @type {{cx: number, cy: number, r: number}}\n         */\n        this.circleBound = data.circleBound;\n\n        /**\n         * sector attr's name for draw graph\n         * @type {string}\n         */\n        this.sectorName = 'sector_' + this.chartType;\n\n        this._setSectorAttr();\n\n        this.sectorInfos = this._renderPie(data.sectorData, data.theme.colors);\n        this.overlay = this._renderOverlay();\n\n        /**\n         * bound of container\n         * @type {{left: number, top: number}}\n         */\n        this.containerBound = null;\n\n        /**\n         * selected previous sector\n         * @type {object}\n         */\n        this.prevSelectedSector = null;\n\n        /**\n         * previous mouse position\n         * @type {{left: number, top: number}}\n         */\n        this.prevPosition = null;\n\n        /**\n         * previous hover sector\n         * @type {object}\n         */\n        this.prevHoverSector = null;\n\n        return paper;\n    },\n\n    /**\n     * Clear paper.\n     */\n    clear: function() {\n        this.paper.clear();\n    },\n\n    /**\n     * Make sector path.\n     * @param {number} cx center x\n     * @param {number} cy center y\n     * @param {number} r radius\n     * @param {number} startAngle start angle\n     * @param {number} endAngle end angel\n     * @returns {{path: Array}} sector path\n     * @private\n     */\n    _makeSectorPath: function(cx, cy, r, startAngle, endAngle) {\n        var startRadian = startAngle * RAD;\n        var endRadian = endAngle * RAD;\n        var x1 = cx + r * Math.sin(startRadian); // 원 호의 시작 x 좌표\n        var y1 = cy - r * Math.cos(startRadian); // 원 호의 시작 y 좌표\n        var x2 = cx + r * Math.sin(endRadian); // 원 호의 종료 x 좌표\n        var y2 = cy - r * Math.cos(endRadian); // 원 호의 종료 y 좌표\n        var largeArcFlag = endAngle - startAngle > DEGREE_180 ? 1 : 0;\n        var path = ['M', cx, cy,\n            'L', x1, y1,\n            'A', r, r, 0, largeArcFlag, 1, x2, y2,\n            'Z'\n        ];\n        // path에 대한 자세한 설명은 아래 링크를 참고\n        // http://www.w3schools.com/svg/svg_path.asp\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n        return {path: path};\n    },\n\n    /**\n     * Make sector path for donut chart.\n     * @param {number} cx - center x\n     * @param {number} cy - center y\n     * @param {number} r - radius\n     * @param {number} startAngle - start angle\n     * @param {number} endAngle - end angel\n     * @param {number} [holeRadius] - hole radius\n     * @returns {{path: Array}} sector path\n     * @private\n     */\n    _makeDonutSectorPath: function(cx, cy, r, startAngle, endAngle, holeRadius) {\n        /*eslint max-params: [2, 6]*/\n        var startRadian = startAngle * RAD;\n        var endRadian = endAngle * RAD;\n        var r2 = holeRadius || (r * this.holeRatio); // 구멍 반지름\n        var x1 = cx + r * Math.sin(startRadian);\n        var y1 = cy - r * Math.cos(startRadian);\n        var x2 = cx + r2 * Math.sin(startRadian);\n        var y2 = cy - r2 * Math.cos(startRadian);\n        var x3 = cx + r * Math.sin(endRadian);\n        var y3 = cy - r * Math.cos(endRadian);\n        var x4 = cx + r2 * Math.sin(endRadian);\n        var y4 = cy - r2 * Math.cos(endRadian);\n        var largeArcFlag = endAngle - startAngle > DEGREE_180 ? 1 : 0;\n        var path = [\n            'M', x1, y1,\n            'A', r, r, 0, largeArcFlag, 1, x3, y3,\n            'L', x4, y4,\n            'A', r2, r2, 0, largeArcFlag, 0, x2, y2,\n            'Z'\n        ];\n\n        return {path: path};\n    },\n\n    /**\n     * Set sector attribute for raphael paper.\n     * @private\n     */\n    _setSectorAttr: function() {\n        var makeSectorPath;\n\n        if (this.paper.customAttributes[this.sectorName]) {\n            return;\n        }\n\n        if (this.holeRatio) {\n            makeSectorPath = this._makeDonutSectorPath;\n        } else {\n            makeSectorPath = this._makeSectorPath;\n        }\n\n        this.paper.customAttributes[this.sectorName] = tui.util.bind(makeSectorPath, this);\n    },\n\n    /**\n     * Render overlay.\n     * @returns {object} raphael object\n     * @private\n     */\n    _renderOverlay: function() {\n        var params = {\n            paper: this.paper,\n            circleBound: {\n                cx: 0,\n                cy: 0,\n                r: 0\n            },\n            angles: {\n                startAngle: 0,\n                endAngle: 0\n            },\n            attrs: {\n                fill: 'none',\n                opacity: 0,\n                stroke: this.chartBackground,\n                'stroke-width': 1\n            }\n        };\n        var inner = this._renderSector(params);\n\n        inner.data('id', OVERLAY_ID);\n        inner.data('chartType', this.chartType);\n\n        return {\n            inner: inner,\n            outer: this._renderSector(params)\n        };\n    },\n\n    /**\n     * Render sector\n     * @param {object} params parameters\n     *      @param {object} params.paper raphael paper\n     *      @param {{cx: number, cy: number, r:number}} params.circleBound circle bounds\n     *      @param {number} params.startAngle start angle\n     *      @param {number} params.endAngle end angle\n     *      @param {{fill: string, stroke: string, strike-width: string}} params.attrs attrs\n     * @returns {object} raphael object\n     * @private\n     */\n    _renderSector: function(params) {\n        var circleBound = params.circleBound;\n        var angles = params.angles;\n        var attrs = params.attrs;\n\n        attrs[this.sectorName] = [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle];\n\n        return params.paper.path().attr(attrs);\n    },\n\n    /**\n     * Render pie graph.\n     * @param {Array.&lt;object>} sectorData - sectorData\n     * @param {Array.&lt;string>} colors - sector colors\n     * @returns {Array.&lt;object>}\n     * @private\n     */\n    _renderPie: function(sectorData, colors) {\n        var self = this;\n        var circleBound = this.circleBound;\n        var chartBackground = this.chartBackground;\n        var sectorInfos = [];\n\n        tui.util.forEachArray(sectorData, function(sectorDatum, index) {\n            var ratio = sectorDatum.ratio;\n            var color = colors[index];\n            var sector = self._renderSector({\n                paper: self.paper,\n                circleBound: circleBound,\n                angles: sectorDatum.angles.start,\n                attrs: {\n                    fill: chartBackground,\n                    stroke: chartBackground,\n                    'stroke-width': 1\n                }\n            });\n            sector.data('index', index);\n            sector.data('chartType', self.chartType);\n\n            sectorInfos.push({\n                sector: sector,\n                color: color,\n                angles: sectorDatum.angles.end,\n                ratio: ratio\n            });\n        });\n\n        return sectorInfos;\n    },\n\n    /**\n     * Render legend lines.\n     * @param {Array.&lt;object>} outerPositions outer position\n     */\n    renderLegendLines: function(outerPositions) {\n        var paper = this.paper,\n            paths;\n\n        if (!this.legendLines) {\n            paths = this._makeLinePaths(outerPositions);\n            this.legendLines = tui.util.map(paths, function(path) {\n                return raphaelRenderUtil.renderLine(paper, path, 'transparent', 1);\n            });\n        }\n    },\n\n    /**\n     * Make line paths.\n     * @param {Array.&lt;object>} outerPositions outer positions\n     * @returns {Array} line paths.\n     * @private\n     */\n    _makeLinePaths: function(outerPositions) {\n        var paths = tui.util.map(outerPositions, function(positions) {\n            return [\n                raphaelRenderUtil.makeLinePath(positions.start, positions.middle),\n                raphaelRenderUtil.makeLinePath(positions.middle, positions.end),\n                'Z'\n            ].join('');\n        });\n\n        return paths;\n    },\n\n    /**\n     * Show overlay.\n     * @param {number} index - index\n     * @private\n     */\n    _showOverlay: function(index) {\n        var overlay = this.overlay;\n        var sectorInfo = this.sectorInfos[index];\n        var sa = sectorInfo.angles.startAngle;\n        var ea = sectorInfo.angles.endAngle;\n        var cb = this.circleBound;\n        var innerAttrs;\n\n        innerAttrs = {\n            fill: '#fff',\n            opacity: 0.3\n        };\n        innerAttrs[this.sectorName] = [cb.cx, cb.cy, cb.r, sa, ea, cb.r * this.holeRatio];\n        overlay.inner.attr(innerAttrs);\n        overlay.inner.data('index', index);\n        overlay.outer.attr({\n            path: this._makeDonutSectorPath(cb.cx, cb.cy, cb.r + 10, sa, ea, cb.r).path,\n            fill: sectorInfo.color,\n            opacity: 0.3\n        });\n    },\n\n    /**\n     * Hide overlay.\n     * @private\n     */\n    _hideOverlay: function() {\n        var overlay = this.overlay;\n        var attrs = {\n            fill: 'none',\n            opacity: 0\n        };\n\n        overlay.inner.attr(attrs);\n        overlay.outer.attr(attrs);\n    },\n\n    /**\n     * Animate.\n     * @param {function} callback callback\n     */\n    animate: function(callback) {\n        var delayTime = 0;\n        var sectorName = this.sectorName;\n        var circleBound = this.circleBound;\n        var sectorArgs = [circleBound.cx, circleBound.cy, circleBound.r];\n\n        tui.util.forEachArray(this.sectorInfos, function(sectorInfo) {\n            var angles = sectorInfo.angles;\n            var attrMap = {\n                fill: sectorInfo.color\n            };\n            var animationTime = LOADING_ANIMATION_DURATION * sectorInfo.ratio;\n            var anim;\n\n            if ((angles.startAngle === 0) &amp;&amp; (angles.endAngle === DEGREE_360)) {\n                angles.endAngle = DEGREE_360 - MIN_DEGREE;\n            }\n\n            attrMap[sectorName] = sectorArgs.concat([angles.startAngle, angles.endAngle]);\n            anim = raphael.animation(attrMap, animationTime);\n            sectorInfo.sector.animate(anim.delay(delayTime));\n            delayTime += animationTime;\n        });\n\n        if (callback) {\n            setTimeout(callback, delayTime);\n        }\n    },\n\n    /**\n     * Animate legend lines.\n     */\n    animateLegendLines: function() {\n        if (!this.legendLines) {\n            return;\n        }\n\n        tui.util.forEachArray(this.legendLines, function(line) {\n            line.animate({\n                'stroke': 'black',\n                'stroke-opacity': 1\n            });\n        });\n    },\n\n\n    /**\n     * Resize graph of pie chart.\n     * @param {object} params parameters\n     *      @param {{width: number, height:number}} params.dimension dimension\n     *      @param {{cx:number, cy:number, r: number}} params.circleBound circle bound\n     */\n    resize: function(params) {\n        var dimension = params.dimension;\n        var circleBound = params.circleBound;\n        var sectorName = this.sectorName;\n\n        this.circleBound = circleBound;\n        this.paper.setSize(dimension.width, dimension.height);\n        this.containerBound = null;\n\n        tui.util.forEachArray(this.sectorInfos, function(sectorInfo) {\n            var angles = sectorInfo.angles;\n            var attrs = {};\n            attrs[sectorName] = [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle];\n            sectorInfo.sector.attr(attrs);\n        });\n    },\n\n    /**\n     * Move legend lines.\n     * @param {Array.&lt;object>} outerPositions outer positions\n     */\n    moveLegendLines: function(outerPositions) {\n        var paths;\n\n        if (!this.legendLines) {\n            return;\n        }\n\n        paths = this._makeLinePaths(outerPositions);\n        tui.util.forEachArray(this.legendLines, function(line, index) {\n            line.attr({path: paths[index]});\n            return line;\n        });\n    },\n\n    /**\n     * Whether valid sector or not.\n     * @param {object} sector - raphael object\n     * @returns {boolean}\n     * @private\n     */\n    _isValidSector: function(sector) {\n        return sector &amp;&amp; sector.data('chartType') === this.chartType;\n    },\n\n    /**\n     * Whether detected label element or not.\n     * @param {{left: number, top: number}} position - mouse position\n     * @returns {boolean}\n     * @private\n     */\n    _isDetectedLabel: function(position) {\n        var labelElement = document.elementFromPoint(position.left, position.top);\n\n        return tui.util.isString(labelElement.className);\n    },\n\n    /**\n     * Click series.\n     * @param {{left: number, top: number}} position mouse position\n     */\n    clickSeries: function(position) {\n        var sector = this.paper.getElementByPoint(position.left, position.top);\n        var prevSector = this.prevSelectedSector;\n        var sectorIndex;\n\n        if ((sector || this._isDetectedLabel(position)) &amp;&amp; this.prevSelectedSector) {\n            this._unselectSeries(this.prevSelectedSector.data('index'));\n            this.prevSelectedSector = null;\n        }\n\n        if (!this._isValidSector(sector)) {\n            return;\n        }\n\n        sectorIndex = sector.data('index');\n        sector = this.sectorInfos[sectorIndex].sector;\n\n        if (sector !== prevSector) {\n            this._selectSeries(sectorIndex);\n            this.prevSelectedSector = sector;\n        }\n    },\n\n\n    /**\n     * Get series container bound.\n     * @returns {{left: number, top: number}} container bound\n     * @private\n     */\n    _getContainerBound: function() {\n        if (!this.containerBound) {\n            this.containerBound = this.container.getBoundingClientRect();\n        }\n        return this.containerBound;\n    },\n\n    /**\n     * Whether changed or not.\n     * @param {{left: number, top: number}} prevPosition previous position\n     * @param {{left: number, top: number}} position position\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isChangedPosition: function(prevPosition, position) {\n        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;\n    },\n\n    /**\n     * Show tooltip.\n     * @param {object} sector - raphael object\n     * @param {{left: number, top: number}} position - mouse position\n     * @private\n     */\n    _showTooltip: function(sector, position) {\n        var containerBound = this._getContainerBound();\n        var args = [{}, 0, sector.data('index'), {\n            left: position.left - containerBound.left,\n            top: position.top - containerBound.top\n        }];\n        this.callbacks.showTooltip.apply(null, args);\n    },\n\n    /**\n     * Move mouse on series.\n     * @param {{left: number, top: number}} position mouse position\n     */\n    moveMouseOnSeries: function(position) {\n        var sector = this.paper.getElementByPoint(position.left, position.top);\n\n        if (this._isValidSector(sector)) {\n            if (this.prevHoverSector !== sector) {\n                this._showOverlay(sector.data('index'));\n                this.prevHoverSector = sector;\n            }\n\n            if (this._isChangedPosition(this.prevPosition, position)) {\n                this._showTooltip(sector, position);\n            }\n        } else if (this.prevHoverSector) {\n            this._hideOverlay();\n            this.callbacks.hideTooltip();\n            this.prevHoverSector = null;\n        }\n\n        this.prevPosition = position;\n    },\n\n    /**\n     * Select series.\n     * @param {number} index index\n     * @private\n     */\n    _selectSeries: function(index) {\n        var sectorInfo = this.sectorInfos[index];\n        var objColor, color;\n\n        if (!sectorInfo) {\n            return;\n        }\n\n        objColor = raphael.color(sectorInfo.color);\n        color = this.selectionColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC);\n\n        sectorInfo.sector.attr({\n            fill: color\n        });\n    },\n\n    /**\n     * Unelect series.\n     * @param {number} index index\n     * @private\n     */\n    _unselectSeries: function(index) {\n        var sectorInfo = this.sectorInfos[index];\n\n        if (!sectorInfo) {\n            return;\n        }\n\n        sectorInfo.sector.attr({\n            fill: sectorInfo.color\n        });\n    },\n\n    /**\n     * Select legend.\n     * @param {?number} legendIndex legend index\n     */\n    selectLegend: function(legendIndex) {\n        var isNull = tui.util.isNull(legendIndex);\n\n        tui.util.forEachArray(this.sectorInfos, function(sectorInfo, index) {\n            var opacity;\n\n            opacity = (isNull || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;\n\n            sectorInfo.sector.attr({\n                'fill-opacity': opacity\n            });\n        });\n    }\n});\n\nmodule.exports = RaphaelPieChart;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"