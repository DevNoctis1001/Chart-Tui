tui.util.defineNamespace("fedoc.content", {});
fedoc.content["dataModels_seriesGroup.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview SeriesGroup is a element of SeriesDataModel.groups.\n * SeriesGroup.items has SeriesItem.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\n/**\n * SeriesItem is a element of SeriesGroup.items.\n * SeriesItem has processed terminal data like value, ratio, etc.\n */\n\nvar SeriesGroup = tui.util.defineClass(/** @lends SeriesGroup.prototype */{\n    /**\n     * SeriesGroup is a element of SeriesDataModel.groups.\n     * SeriesGroup.items has SeriesItem.\n     * @constructs SeriesGroup\n     * @param {Array.&lt;SeriesItem>} seriesItems - series items\n     */\n    init: function(seriesItems) {\n        /**\n         * items has SeriesItem\n         * @type {Array.&lt;SeriesItem>}\n         */\n        this.items = seriesItems;\n\n        /**\n         * map of values by value type like value, x, y, r.\n         * @type {Array.&lt;number>}\n         */\n        this.valuesMap = {};\n\n        this.valuesMapPerStack = null;\n    },\n\n    /**\n     * Get series item count.\n     * @returns {number}\n     */\n    getSeriesItemCount: function() {\n        return this.items.length;\n    },\n\n    /**\n     * Get series item.\n     * @param {number} index - index of items\n     * @returns {SeriesItem}\n     */\n    getSeriesItem: function(index) {\n        return this.items[index];\n    },\n\n    /**\n     * Get first SeriesItem.\n     * @returns {SeriesItem}\n     */\n    getFirstSeriesItem: function() {\n        return this.getSeriesItem(0);\n    },\n\n    /**\n     * Create values that picked value from SeriesItems.\n     * @param {?string} valueType - type of value\n     * @returns {Array.&lt;number>}\n     * @private\n     */\n    _createValues: function(valueType) {\n        var values = [];\n\n        this.each(function(item) {\n            if (!item) {\n                return;\n            }\n\n            if (tui.util.isExisty(item[valueType])) {\n                values.push(item[valueType]);\n            }\n            if (tui.util.isExisty(item.start)) {\n                values.push(item.start);\n            }\n        });\n\n        return values;\n    },\n\n    /**\n     * Get values from valuesMap.\n     * @param {?string} valueType - type of value\n     * @returns {Array}\n     */\n    getValues: function(valueType) {\n        valueType = valueType || 'value';\n\n        if (!this.valuesMap[valueType]) {\n            this.valuesMap[valueType] = this._createValues(valueType);\n        }\n\n        return this.valuesMap[valueType];\n    },\n\n    /**\n     * Make values map per stack.\n     * @returns {object}\n     * @private\n     */\n    _makeValuesMapPerStack: function() {\n        var valuesMap = {};\n\n        this.each(function(item) {\n            if (!valuesMap[item.stack]) {\n                valuesMap[item.stack] = [];\n            }\n            valuesMap[item.stack].push(item.value);\n        });\n\n        return valuesMap;\n    },\n\n    /**\n     * Get values map per stack.\n     * @returns {*|Object}\n     */\n    getValuesMapPerStack: function() {\n        if (!this.valuesMapPerStack) {\n            this.valuesMapPerStack = this._makeValuesMapPerStack();\n        }\n\n        return this.valuesMapPerStack;\n    },\n\n    /**\n     * Make sum map per stack.\n     * @returns {object} sum map\n     * @private\n     */\n    _makeSumMapPerStack: function() {\n        var valuesMap = this.getValuesMapPerStack(),\n            sumMap = {};\n\n        tui.util.forEach(valuesMap, function(values, key) {\n            sumMap[key] = tui.util.sum(tui.util.map(values, function(value) {\n                return Math.abs(value);\n            }));\n        });\n\n        return sumMap;\n    },\n\n    /**\n     * Add start value to all series item.\n     * @param {number} start start value\n     */\n    addStartValueToAllSeriesItem: function(start) {\n        this.each(function(item) {\n            item.addStart(start);\n        });\n    },\n\n    /**\n     * Add ratios when percent stackType.\n     * @param {number} baseRatio - base ratio\n     */\n    addRatiosWhenPercentStacked: function(baseRatio) {\n        var sumMap = this._makeSumMapPerStack();\n\n        this.each(function(item) {\n            var dividingNumber = sumMap[item.stack];\n\n            item.addRatio(dividingNumber, 0, baseRatio);\n        });\n    },\n\n    /**\n     * Add ratios when diverging stacked.\n     * @param {number} plusSum - sum of plus number\n     * @param {number} minusSum - sum of minus number\n     */\n    addRatiosWhenDivergingStacked: function(plusSum, minusSum) {\n        this.each(function(item) {\n            var dividingNumber = (item.value >= 0) ? plusSum : minusSum;\n\n            item.addRatio(dividingNumber, 0, 0.5);\n        });\n    },\n\n    /**\n     * Add ratios.\n     * @param {number} divNumber dividing number\n     * @param {number} subValue subtraction value\n     */\n    addRatios: function(divNumber, subValue) {\n        this.each(function(item) {\n            item.addRatio(divNumber, subValue);\n        });\n    },\n\n    /**\n     * Whether has range data or not.\n     * @returns {boolean}\n     */\n    hasRangeData: function() {\n        var hasRangeData = false;\n\n        this.each(function(seriesItem) {\n            hasRangeData = seriesItem.isRange;\n            return !hasRangeData;\n        });\n\n        return hasRangeData;\n    },\n\n    /**\n     * Traverse items, and executes iteratee function.\n     * @param {function} iteratee - iteratee function\n     */\n    each: function(iteratee) {\n        tui.util.forEachArray(this.items, iteratee);\n    },\n\n    /**\n     * Traverse items, and returns to results of execution about iteratee function.\n     * @param {function} iteratee - iteratee function\n     * @returns {Array}\n     */\n    map: function(iteratee) {\n        return tui.util.map(this.items, iteratee);\n    },\n\n    /**\n     * Traverse items and returns to picked result at item.\n     * @param {string} key key for pick\n     * @returns {Array}\n     */\n    pluck: function(key) {\n        return tui.util.pluck(this.items, key);\n    },\n\n    /**\n     * Traverse items, and returns to found SeriesItem by condition function.\n     * @param {function} condition - condition function\n     * @returns {SeriesItem|null}\n     */\n    find: function(condition) {\n        var foundItem;\n\n        this.each(function(seriesItem) {\n            if (condition(seriesItem)) {\n                foundItem = seriesItem;\n            }\n            return !foundItem;\n        });\n\n        return foundItem || null;\n    }\n});\n\nmodule.exports = SeriesGroup;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"