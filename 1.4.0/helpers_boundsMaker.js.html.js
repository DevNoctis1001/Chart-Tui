tui.util.defineNamespace("fedoc.content", {});
fedoc.content["helpers_boundsMaker.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Bounds maker.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const'),\n    calculator = require('./calculator'),\n    predicate = require('./predicate'),\n    renderUtil = require('./renderUtil');\n\nvar concat = Array.prototype.concat;\n\n/**\n * Bounds maker.\n * @module boundsMaker\n */\nvar boundsMaker = {\n    /**\n     * Get max label of value axis.\n     * @memberOf module:boundsMaker\n     * @param {string} chartType chart type\n     * @returns {number|string} max label\n     * @private\n     */\n    _getValueAxisMaxLabel: function(chartType) {\n        var values = predicate.isComboChart(chartType) ? this.dataProcessor.getWholeGroupValues() : this.dataProcessor.getGroupValues(chartType),\n            formatFunctions = this.dataProcessor.getFormatFunctions(),\n            flattenValues = concat.apply([], values),\n            min = tui.util.min(flattenValues),\n            max = tui.util.max(flattenValues),\n            limit = calculator.calculateLimit(min, max),\n            minLabel = calculator.normalizeAxisNumber(limit.min),\n            maxLabel = calculator.normalizeAxisNumber(limit.max);\n\n        maxLabel = (minLabel + '').length > (maxLabel + '').length ? minLabel : maxLabel;\n        return renderUtil.formatValue(maxLabel, formatFunctions);\n    },\n\n    /**\n     * Get height of x axis area.\n     * @memberOf module:boundsMaker\n     * @param {object} options x axis options,\n     * @param {array.&lt;string>} labels axis labels\n     * @param {object} theme axis theme\n     * @returns {number} height\n     * @private\n     */\n    _getXAxisHeight: function(options, labels, theme) {\n        var title = options &amp;&amp; options.title,\n            titleAreaHeight = renderUtil.getRenderedLabelHeight(title, theme.title) + chartConst.TITLE_PADDING,\n            height = renderUtil.getRenderedLabelsMaxHeight(labels, theme.label) + titleAreaHeight;\n        return height;\n    },\n\n    /**\n     * Get width about y axis.\n     * @param {object} options y axis options\n     * @param {array.&lt;string>} labels labels\n     * @param {object} theme yAxis theme\n     * @param {number} index options index\n     * @returns {number} y axis width\n     * @private\n     */\n    _getYAxisWidth: function(options, labels, theme, index) {\n        var title = '',\n            titleAreaWidth, width;\n\n        if (options) {\n            options = [].concat(options);\n            title = options[index || 0].title;\n        }\n\n        titleAreaWidth = renderUtil.getRenderedLabelHeight(title, theme.title) + chartConst.TITLE_PADDING;\n        width = renderUtil.getRenderedLabelsMaxWidth(labels, theme.label) + titleAreaWidth + chartConst.AXIS_LABEL_PADDING;\n\n        return width;\n    },\n\n    /**\n     * Get width about right y axis.\n     * @memberOf module:boundsMaker\n     * @param {object} params parameters\n     *      @param {array.&lt;string>} params.chartTypes y axis chart types\n     *      @param {object} params.theme y axis theme\n     *      @param {object} params.options y axis options\n     * @returns {number} y right axis width\n     * @private\n     */\n    _getRightYAxisWidth: function(params) {\n        var chartTypes = params.chartTypes || [],\n            len = chartTypes.length,\n            width = 0,\n            index, chartType, theme, label;\n\n        if (len > 1) {\n            index = len - 1;\n            chartType = chartTypes[index];\n            theme = params.theme[chartType] || params.theme;\n            label = this._getValueAxisMaxLabel(chartType);\n            width = this._getYAxisWidth(params.options, [label], theme, index);\n        }\n        return width;\n    },\n\n    /**\n     * Make axes dimension.\n     * @memberOf module:boundsMaker\n     * @param {object} params parameters\n     *      @param {object} params.theme chart theme\n     *      @param {boolean} params.isVertical whether vertical or not\n     *      @param {object} params.options chart options\n     *      *      @param {object} params.axesLabelInfo axes label info\n     * @returns {{\n     *      yAxis: {width: number},\n     *      rightYAxis: {width: number},\n     *      xAxis: {height: number}\n     * }} axes dimension\n     * @private\n     */\n    _makeAxesDimension: function(params) {\n        var yAxisWidth = 0,\n            xAxisHeight = 0,\n            rightYAxisWidth = 0,\n            axesLabelInfo, chartType;\n\n        // axis 영역이 필요 있는 경우에만 처리\n        if (params.hasAxes) {\n            axesLabelInfo = params.axesLabelInfo;\n            chartType = params.optionChartTypes &amp;&amp; params.optionChartTypes[0] || '';\n            yAxisWidth = this._getYAxisWidth(params.options.yAxis, axesLabelInfo.yAxis, params.theme.yAxis[chartType] || params.theme.yAxis);\n            xAxisHeight = this._getXAxisHeight(params.options.xAxis, axesLabelInfo.xAxis, params.theme.xAxis);\n            rightYAxisWidth = this._getRightYAxisWidth({\n                chartTypes: params.optionChartTypes,\n                theme: params.theme.yAxis,\n                options: params.options.yAxis\n            });\n        }\n\n        return {\n            yAxis: {\n                width: yAxisWidth\n            },\n            rightYAxis: {\n                width: rightYAxisWidth\n            },\n            xAxis: {\n                height: xAxisHeight\n            }\n        };\n    },\n\n    /**\n     * Whether skipped legend sizing or not.\n     * @param {string} chartType chart type\n     * @param {?object} options legend options\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isSkippedLegendSizing: function(chartType, options) {\n        return (predicate.isPieChart(chartType) &amp;&amp; predicate.isPieLegendAlign(options.align)) || options.hidden;\n    },\n\n    /**\n     * Make legend width.\n     * @param {number} labelWidth label width\n     * @returns {number} legend width\n     * @private\n     */\n    _makeLegendWidth: function(labelWidth) {\n        return labelWidth + this.legendCheckboxWidth + chartConst.LEGEND_RECT_WIDTH +\n            chartConst.LEGEND_LABEL_LEFT_PADDING + chartConst.LEGEND_AREA_PADDING;\n    },\n\n    /**\n     * Calculate sum of legends width.\n     * @param {array.&lt;string>} labels legend labels\n     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme\n     * @returns {number} sum of width\n     * @private\n     */\n    _calculateLegendsWidthSum: function(labels, labelTheme) {\n        return tui.util.sum(tui.util.map(labels, function(label) {\n            var labelWidth = this._makeLegendWidth(renderUtil.getRenderedLabelWidth(label, labelTheme));\n            return labelWidth;\n        }, this));\n    },\n\n    /**\n     * Divide legend labels.\n     * @param {array.&lt;string>} labels legend labels\n     * @param {number} count division count\n     * @returns {array.&lt;array.&lt;string>>} divided labels\n     * @private\n     */\n    _divideLegendLabels: function(labels, count) {\n        var limitCount = Math.round(labels.length / count),\n            results = [],\n            temp = [];\n\n        tui.util.forEachArray(labels, function(label) {\n            if (temp.length &lt; limitCount) {\n                temp.push(label);\n            } else {\n                results.push(temp);\n                temp = [label];\n            }\n        });\n\n        if (temp.length) {\n            results.push(temp);\n        }\n\n        return results;\n    },\n\n    /**\n     * Make division labels and max line width.\n     * @param {array.&lt;string>} labels legend labels\n     * @param {number} chartWidth chart width\n     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme\n     * @returns {{dividedLabels: array.&lt;array.&lt;string>>, maxLineWidth: number}} result\n     * @private\n     */\n    _makeDividedLabelsAndMaxLineWidth: function(labels, chartWidth, labelTheme) {\n        var divideCount = 1,\n            maxLineWidth = 0,\n            prevMaxWidth = 0,\n            dividedLabels,\n            prevLabels;\n\n        do {\n            dividedLabels = this._divideLegendLabels(labels, divideCount);\n            maxLineWidth = Math.max.apply(null, tui.util.map(dividedLabels, function(_labels) {\n                return this._calculateLegendsWidthSum(_labels, labelTheme);\n            }, this));\n\n            if (prevMaxWidth === maxLineWidth) {\n                dividedLabels = prevLabels;\n                break;\n            }\n\n            prevMaxWidth = maxLineWidth;\n            prevLabels = dividedLabels;\n            divideCount += 1;\n        } while (maxLineWidth >= chartWidth);\n\n        return {\n            dividedLabels: dividedLabels,\n            maxLineWidth: maxLineWidth\n        };\n    },\n\n    /**\n     * Calculate height of horizontal legend.\n     * @param {array.&lt;array.&lt;string>>} dividedLabels divided labels\n     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme\n     * @returns {number} legend height\n     * @private\n     */\n    _calculateHorizontalLegendHeight: function(dividedLabels, labelTheme) {\n        return tui.util.sum(tui.util.map(dividedLabels, function(labels) {\n            return renderUtil.getRenderedLabelsMaxHeight(labels, labelTheme);\n        }, this));\n    },\n\n    /**\n     * Get whole legend labels.\n     * @returns {array.&lt;string>} labels\n     * @private\n     */\n    _getWholeLegendLabels: function() {\n        return tui.util.map(this.dataProcessor.getWholeLegendData(), function(item) {\n            return item.label;\n        });\n    },\n\n    /**\n     * Make dimension of horizontal legend.\n     * @param {number} chartWidth chart width\n     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme\n     * @returns {{width: number, height: (number)}} dimension of horizontal legend\n     * @private\n     */\n    _makeHorizontalLegendDimension: function(chartWidth, labelTheme) {\n        var labels = this._getWholeLegendLabels(),\n            labelsAndMaxWidth = this._makeDividedLabelsAndMaxLineWidth(labels, chartWidth, labelTheme),\n            legendHeight = this._calculateHorizontalLegendHeight(labelsAndMaxWidth.dividedLabels, labelTheme) + (chartConst.LEGEND_AREA_PADDING * 2);\n\n        return {\n            width: labelsAndMaxWidth.maxLineWidth,\n            height: legendHeight\n        };\n    },\n\n    /**\n     * Make dimension of vertical legend.\n     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme\n     * @returns {{width: (number)}} dimension of vertical legend\n     * @private\n     */\n    _makeVerticalLegendDimension: function(labelTheme) {\n        var labels = this._getWholeLegendLabels(),\n            maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(labels, labelTheme),\n            legendWidth = this._makeLegendWidth(maxLabelWidth);\n        return {\n            width: legendWidth,\n            height: 0\n        };\n    },\n\n    /**\n     * Make legend dimension.\n     * @memberOf module:boundsMaker\n     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme\n     * @param {string} chartType chart type\n     * @param {number} chartWidth chart width\n     * @param {object} legendOptions series option\n     * @returns {{width: number}} legend dimension\n     * @private\n     */\n    _makeLegendDimension: function(labelTheme, chartType, chartWidth, legendOptions) {\n        var dimension = {};\n\n        legendOptions = legendOptions || {};\n\n        if (this._isSkippedLegendSizing(chartType, legendOptions)) {\n            dimension.width = 0;\n        } else if (predicate.isHorizontalLegend(legendOptions.align)) {\n            dimension = this._makeHorizontalLegendDimension(chartWidth, labelTheme);\n        } else {\n            dimension = this._makeVerticalLegendDimension(labelTheme);\n        }\n\n        return dimension;\n    },\n\n    /**\n     * Make series dimension.\n     * @memberOf module:boundsMaker\n     * @param {object} params parameters\n     *      @param {{width: number, height: number}} params.chartDimension chart dimension\n     *      @param {{\n     *          yAxis: {width: number, height:number},\n     *          xAxis: {width: number, height:number},\n     *          rightYAxis: {width: number, height:number}\n     *      }} params.axesDimension axes dimension\n     *      @param {number} params.legendWidth legend width\n     *      @param {number} params.titleHeight title height\n     * @returns {{width: number, height: number}} series dimension\n     * @private\n     */\n    _makeSeriesDimension: function(params) {\n        var axesDimension = params.axesDimension,\n            legendOption = params.legendOption || {},\n            legendWidth = 0,\n            legendHeight = 0,\n            rightAreaWidth, bottomAreaWidth, width, height;\n\n        if (predicate.isHorizontalLegend(legendOption.align)) {\n            legendHeight = params.legendDimension.height;\n        } else {\n            legendWidth = params.legendDimension.width;\n        }\n\n        rightAreaWidth = legendWidth + axesDimension.rightYAxis.width;\n        bottomAreaWidth = legendHeight + axesDimension.xAxis.height;\n        width = params.chartDimension.width - (chartConst.CHART_PADDING * 2) - axesDimension.yAxis.width - rightAreaWidth;\n        height = params.chartDimension.height - (chartConst.CHART_PADDING * 2) - params.titleHeight - bottomAreaWidth;\n\n        return {\n            width: width,\n            height: height\n        };\n    },\n\n    /**\n     * Make chart dimension.\n     * @param {{width: number, height: number}} chartOptions chart options\n     * @returns {{width: (number), height: (number)}} chart dimension\n     * @private\n     */\n    _makeChartDimension: function(chartOptions) {\n        return {\n            width: chartOptions.width || chartConst.CHART_DEFAULT_WIDTH,\n            height: chartOptions.height || chartConst.CHART_DEFAULT_HEIGHT\n        };\n    },\n\n    /**\n     * Make title dimension\n     * @param {string} title chart title\n     * @param {{fontFamily: string, fontSize: number}} theme title theme\n     * @returns {{height: number}} title dimension\n     * @private\n     */\n    _makeTitleDimension: function(title, theme) {\n        return {\n            height: renderUtil.getRenderedLabelHeight(title, theme) + chartConst.TITLE_PADDING\n        };\n    },\n\n    /**\n     * Make plot dimention\n     * @param {{width: number, height: number}} seriesDimension series dimension\n     * @returns {{width: number, height: number}} plot dimension\n     * @private\n     */\n    _makePlotDimension: function(seriesDimension) {\n        return {\n            width: seriesDimension.width + chartConst.HIDDEN_WIDTH,\n            height: seriesDimension.height + chartConst.HIDDEN_WIDTH\n        };\n    },\n\n    /**\n     * Make components dimensions.\n     * @memberOf module:boundsMaker\n     * @param {object} params parameters\n     *      @param {object} params.theme chart theme\n     *      @param {boolean} params.isVertical whether vertical or not\n     *      @param {object} params.options chart options\n     *      @param {object} params.axesLabelInfo axes label info\n     * @returns {Object} components dimensions\n     * @private\n     */\n    _makeComponentsDimensions: function(params) {\n        var chartOptions = params.options.chart || {},\n            chartDimension = this._makeChartDimension(chartOptions),\n            titleDimension = this._makeTitleDimension(chartOptions.title, params.theme.title),\n            axesDimension = this._makeAxesDimension(params),\n            legendDimension = this._makeLegendDimension(params.theme.legend.label, params.options.chartType, chartDimension.width, params.options.legend),\n            seriesDimension = this._makeSeriesDimension({\n                chartDimension: chartDimension,\n                axesDimension: axesDimension,\n                legendDimension: legendDimension,\n                titleHeight: titleDimension.height,\n                legendOption: params.options.legend\n            });\n\n        return tui.util.extend({\n            chart: chartDimension,\n            title: titleDimension,\n            series: seriesDimension,\n            plot: this._makePlotDimension(seriesDimension),\n            legend: legendDimension\n        }, axesDimension);\n    },\n\n    /**\n     * Make basic bound.\n     * @param {{width: number, height: number}} dimension series dimension.\n     * @param {number} top top\n     * @param {number} left left\n     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} series bound.\n     * @private\n     */\n    _makeBasicBound: function(dimension, top, left) {\n        return {\n            dimension: dimension,\n            position: {\n                top: top,\n                left: left\n            }\n        };\n    },\n\n    /**\n     * Make yAxis bound.\n     * @param {{yAxis: {width: number}, plot: {height: number}}} dimensions dimensions\n     * @param {number} top top\n     * @param {number} leftLegendWidth left legend width\n     * @returns {{dimension: {width: number, height: (number)}, position: {top: number, left: number}}} yAxis bound\n     * @private\n     */\n    _makeYAxisBound: function(dimensions, top, leftLegendWidth) {\n        return {\n            dimension: {\n                width: dimensions.yAxis.width,\n                height: dimensions.plot.height\n            },\n            position: {\n                top: top,\n                left: this.chartLeftPadding + leftLegendWidth\n            }\n        };\n    },\n\n    /**\n     * Make xAxis bound.\n     * @param {{xAxis: {height: number}, plot: {width: number}}} dimensions dimensions\n     * @param {number} top top\n     * @param {number} left left\n     * @param {{degree: number}} rotationInfo rotation info\n     * @returns {{dimension: {width: number, height: (number)}, position: {top: number, left: number}}} xAxis bound\n     * @private\n     */\n    _makeXAxisBound: function(dimensions, top, left, rotationInfo) {\n        var bound = {\n            dimension: {\n                width: dimensions.plot.width,\n                height: dimensions.xAxis.height\n            },\n            position: {\n                top: top + dimensions.series.height,\n                left: left - chartConst.HIDDEN_WIDTH\n            }\n        };\n\n        if (rotationInfo) {\n            bound.degree = rotationInfo.degree;\n        }\n\n        return bound;\n    },\n\n    /**\n     * Make right y axis bound.\n     * @param {{rightYAxis: {width: number}, plot: {height: number}, legend: {width: number}}} dimensions dimensions\n     * @param {number} top top\n     * @param {number} leftLegendWidth left legend width\n     * @returns {{dimension: {width: number, height: (number)}, position: {top: number, left: number}}} rightYAxis bound\n     * @private\n     */\n    _makeRightYAxisBound: function(dimensions, top, leftLegendWidth) {\n        return {\n            dimension: {\n                width: dimensions.rightYAxis.width,\n                height: dimensions.plot.height\n            },\n            position: {\n                top: top,\n                left: this.chartLeftPadding + dimensions.yAxis.width + dimensions.series.width + leftLegendWidth - chartConst.HIDDEN_WIDTH\n            }\n        };\n    },\n\n    /**\n     * Make axes bounds.\n     * @memberOf module:boundsMaker\n     * @param {object} params parameters\n     *      @param {boolean} params.hasAxes whether has axed or not\n     *      @param {array.&lt;string>} params.optionChartTypes y axis chart types\n     *      @param {{width: number, height: number}} params.dimension chart dimension\n     *      @param {number} params.top top position\n     *      @param {number} params.right right position\n     *      @param {{degree: number}} params.rotationInfo rotation info\n     * @returns {object} axes bounds\n     * @private\n     */\n    _makeAxesBounds: function(params) {\n        var bounds;\n\n        // pie차트와 같이 axis 영역이 필요 없는 경우에는 빈 값을 반환 함\n        if (!params.hasAxes) {\n            return {};\n        }\n\n        bounds = {\n            plot: this._makeBasicBound(params.dimensions.plot, params.top, params.left - chartConst.HIDDEN_WIDTH),\n            yAxis: this._makeYAxisBound(params.dimensions, params.top, params.leftLegendWidth),\n            xAxis: this._makeXAxisBound(params.dimensions, params.top, params.left, params.rotationInfo)\n        };\n\n        // 우측 y axis 영역 bounds 정보 추가\n        bounds.rightYAxis = this._makeRightYAxisBound(params.dimensions, params.top, params.leftLegendWidth);\n\n        return bounds;\n    },\n\n    /**\n     * Make chart bound.\n     * @param {{width: number, height: number}} dimension chart dimension.\n     * @returns {{dimension: {width: number, height: number}}} chart bound\n     * @private\n     */\n    _makeChartBound: function(dimension) {\n        return {\n            dimension: dimension\n        };\n    },\n\n    /**\n     * Make legend bound.\n     * @param {{title: {height: number}, series: {width: number}, rightYAxis: {width: number}}} dimensions dimensions\n     * @param {{align: ?boolean}} legendOption legend option\n     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} legend bound\n     * @private\n     */\n    _makeLegendBound: function(dimensions, legendOption) {\n        var top = dimensions.title.height,\n            left;\n\n        if (predicate.isBottomLegendAlign(legendOption.align)) {\n            top += dimensions.series.height + dimensions.xAxis.height + chartConst.LEGEND_AREA_PADDING;\n        }\n\n        if (predicate.isHorizontalLegend(legendOption.align)) {\n            left = (dimensions.chart.width - dimensions.legend.width) / 2;\n        } else if (predicate.isLeftLegendAlign(legendOption.align)) {\n            left = 0;\n        } else {\n            left = dimensions.yAxis.width + dimensions.series.width + dimensions.rightYAxis.width + this.chartLeftPadding;\n        }\n\n        return {\n            dimension: dimensions.legend,\n            position: {\n                top: top,\n                left: left\n            }\n        };\n    },\n\n    /**\n     * Make axes label info.\n     * @param {object} params parameters\n     *      @param {boolean} params.hasAxes whether has axes or not\n     *      @param {array} params.optionChartTypes chart types\n     *      @param {boolean} isVertical whether vertical or not\n     * @returns {{xAxis: array, yAxis: array}} label info\n     * @private\n     */\n    _makeAxesLabelInfo: function(params) {\n        var chartType, maxValueLabel, labels, yLabels, xLabels;\n\n        if (!params.hasAxes) {\n            return null;\n        }\n\n        chartType = params.optionChartTypes &amp;&amp; params.optionChartTypes[0] || params.chartType;\n        // value 중 가장 큰 값을 추출하여 value label로 지정 (lable 너비 체크 시 사용)\n        maxValueLabel = this._getValueAxisMaxLabel(chartType);\n        labels = this.dataProcessor.getCategories();\n\n        // 세로옵션에 따라서 x축과 y축에 적용할 레이블 정보 지정\n        if (params.isVertical) {\n            yLabels = [maxValueLabel];\n            xLabels = labels;\n        } else {\n            yLabels = labels;\n            xLabels = [maxValueLabel];\n        }\n\n        return {\n            xAxis: xLabels,\n            yAxis: yLabels\n        };\n    },\n\n    /**\n     * Find rotation degree.\n     * @param {number} limitWidth limit width\n     * @param {number} labelWidth label width\n     * @param {number} labelHeight label height\n     * @param {number} index candidates index\n     * @returns {number} rotation degree\n     * @private\n     */\n    _findRotationDegree: function(limitWidth, labelWidth, labelHeight) {\n        var foundDegree,\n            halfWidth = labelWidth / 2,\n            halfHeight = labelHeight / 2;\n\n        tui.util.forEachArray(chartConst.DEGREE_CANDIDATES, function(degree) {\n            var compareWidth = (calculator.calculateAdjacent(degree, halfWidth) + calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, halfHeight)) * 2;\n            foundDegree = degree;\n            if (compareWidth &lt;= limitWidth + chartConst.XAXIS_LABEL_COMPARE_MARGIN) {\n                return false;\n            }\n        });\n\n        return foundDegree;\n    },\n\n    /**\n     * Make rotation info about horizontal label.\n     * @param {number} limitWidth limit width\n     * @param {array.&lt;string>} labels axis labels\n     * @param {object} theme axis label theme\n     * @returns {?object} rotation info\n     * @private\n     */\n    _makeHorizontalLabelRotationInfo: function(limitWidth, labels, theme) {\n        var maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(labels, theme),\n            degree, labelHeight;\n\n        if (maxLabelWidth &lt;= limitWidth) {\n            return null;\n        }\n\n        labelHeight = renderUtil.getRenderedLabelsMaxHeight(labels, theme);\n        degree = this._findRotationDegree(limitWidth, maxLabelWidth, labelHeight);\n\n        return {\n            maxLabelWidth: maxLabelWidth,\n            labelHeight: labelHeight,\n            degree: degree\n        };\n    },\n\n    /**\n     * Calculate overflow position left.\n     * @param {number} yAxisWidth yAxis width\n     * @param {{degree: number, labelHeight: number}} rotationInfo rotation info\n     * @param {string} firstLabel firstLabel\n     * @param {obejct} theme label theme\n     * @returns {number} overflow position left\n     * @private\n     */\n    _calculateOverflowLeft: function(yAxisWidth, rotationInfo, firstLabel, theme) {\n        var degree = rotationInfo.degree,\n            labelHeight = rotationInfo.labelHeight,\n            firstLabelWidth = renderUtil.getRenderedLabelWidth(firstLabel, theme),\n            newLabelWidth = (calculator.calculateAdjacent(degree, firstLabelWidth / 2) + calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, labelHeight / 2)) * 2,\n            diffLeft = newLabelWidth - yAxisWidth;\n        return diffLeft;\n    },\n\n    /**\n     * Calculate rotated height of xAxis.\n     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info\n     * @returns {number} xAxis height\n     * @private\n     */\n    _calculateXAxisRotatedHeight: function(rotationInfo) {\n        var degree = rotationInfo.degree,\n            maxLabelWidth = rotationInfo.maxLabelWidth,\n            labelHeight = rotationInfo.labelHeight,\n            axisHeight = (calculator.calculateOpposite(degree, maxLabelWidth / 2) + calculator.calculateOpposite(chartConst.ANGLE_90 - degree, labelHeight / 2)) * 2;\n        return axisHeight;\n    },\n\n    /**\n     * Calculate height difference between origin category and rotation category.\n     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info\n     * @returns {number} height difference\n     * @private\n     */\n    _calculateDiffWithRotatedHeight: function(rotationInfo) {\n        var rotatedHeight = this._calculateXAxisRotatedHeight(rotationInfo);\n        return rotatedHeight - rotationInfo.labelHeight;\n    },\n\n    /**\n     * Update degree of rotationInfo.\n     * @param {number} seriesWidth series width\n     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info\n     * @param {number} labelLength labelLength\n     * @param {number} overflowLeft overflow left\n     * @private\n     */\n    _updateDegree: function(seriesWidth, rotationInfo, labelLength, overflowLeft) {\n        var limitWidth, newDegree;\n        if (overflowLeft > 0) {\n            limitWidth = seriesWidth / labelLength + chartConst.XAXIS_LABEL_GUTTER;\n            newDegree = this._findRotationDegree(limitWidth, rotationInfo.maxLabelWidth, rotationInfo.labelHeight);\n            rotationInfo.degree = newDegree;\n        }\n    },\n\n    /**\n     * Update width of dimensions.\n     * @param {{plot: {width: number}, series: {width: number}, xAxis: {width: number}}} dimensions dimensions\n     * @param {number} overflowLeft overflow left\n     * @private\n     */\n    _updateDimensionsWidth: function(dimensions, overflowLeft) {\n        if (overflowLeft > 0) {\n            this.chartLeftPadding += overflowLeft;\n            dimensions.plot.width -= overflowLeft;\n            dimensions.series.width -= overflowLeft;\n            dimensions.xAxis.width -= overflowLeft;\n        }\n    },\n\n    /**\n     * Update height of dimensions.\n     * @param {{plot: {height: number}, series: {height: number}, xAxis: {height: number}}} dimensions dimensions\n     * @param {number} diffHeight diff height\n     * @private\n     */\n    _updateDimensionsHeight: function(dimensions, diffHeight) {\n        dimensions.plot.height -= diffHeight;\n        dimensions.series.height -= diffHeight;\n        dimensions.xAxis.height += diffHeight;\n    },\n\n    /**\n     * Calculate height difference between origin category and multiline category.\n     * @param {array.&lt;string>} labels labels\n     * @param {{fontSize: number, fontFamily: string}} theme axis label theme\n     * @param {number} limitWidth limit width\n     * @returns {number} calculated height\n     * @private\n     */\n    _calculateDiffWithMultilineHeight: function(labels, theme, limitWidth) {\n        var multilineLabels = this.dataProcessor.getMultilineCategories(limitWidth, theme),\n            normalHeight = renderUtil.getRenderedLabelsMaxHeight(labels, theme),\n            multilineHeight = renderUtil.getRenderedLabelsMaxHeight(multilineLabels, tui.util.extend({\n                cssText: 'line-height:1.2;width:' + limitWidth + 'px'\n            }, theme));\n\n        return multilineHeight - normalHeight;\n    },\n\n    /**\n     * Update dimensions and degree.\n     * @param {{plot: {width: number, height: number}, series: {width: number, height: number}, xAxis: {width: number, height: number}}} dimensions dimensions\n     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info\n     * @param {array} labels labels\n     * @param {object} theme theme\n     * @param {number} limitWidth limit width\n     * @private\n     */\n    _updateDimensionsAndDegree: function(dimensions, rotationInfo, labels, theme, limitWidth) {\n        var overflowLeft, diffHeight;\n        if (rotationInfo) {\n            overflowLeft = this._calculateOverflowLeft(dimensions.yAxis.width, rotationInfo, labels[0], theme);\n            this._updateDimensionsWidth(dimensions, overflowLeft);\n            this._updateDegree(dimensions.series.width, rotationInfo, labels.length, overflowLeft);\n            diffHeight = this._calculateDiffWithRotatedHeight(rotationInfo);\n        } else {\n            diffHeight = this._calculateDiffWithMultilineHeight(labels, theme, limitWidth);\n        }\n        this._updateDimensionsHeight(dimensions, diffHeight);\n    },\n\n    /**\n     * Calculate limit width of x axis.\n     * @param {number} seriesWidth series width\n     * @param {number} labelCount label count\n     * @param {string} chartType chart type\n     * @returns {number} limit width\n     * @private\n     */\n    _calculateXAxisLabelLimitWidth: function(seriesWidth, labelCount, chartType) {\n        var isAlign = predicate.isLineTypeChart(chartType);\n        return seriesWidth / (isAlign ? labelCount - 1 : labelCount);\n    },\n\n    /**\n     * Make bounds about chart components.\n     * @memberOf module:boundsMaker\n     * @param {object} dataProcessor data processor\n     * @param {object} params parameters\n     *      @param {object} params.theme chart theme\n     *      @param {boolean} params.isVertical whether vertical or not\n     *      @param {object} params.options chart options\n     *      @param {boolean} params.hasAxes whether has axes area or not\n     *      @param {array} params.optionChartTypes y axis option chart types\n     * @returns {{\n     *   plot: {\n     *     dimension: {width: number, height: number},\n     *     position: {top: number, right: number}\n     *   },\n     *   yAxis: {\n     *     dimension: {width: (number), height: number},\n     *     position: {top: number}\n     *   },\n     *   xAxis: {\n     *     dimension: {width: number, height: (number)},\n     *     position: {right: number}\n     *   },\n     *   series: {\n     *     dimension: {width: number, height: number},\n     *     position: {top: number, right: number}\n     *   },\n     *   legend: {\n     *     position: {top: number}\n     *   },\n     *   tooltip: {\n     *     dimension: {width: number, height: number},\n     *     position: {top: number, left: number}\n     *   }\n     * }} bounds\n     */\n    make: function(dataProcessor, params) {\n        var legendOption = params.options.legend || {},\n            xAxisOptions = params.options.xAxis || {},\n            axesLabelInfo, dimensions, limitWidth, rotationInfo, top,\n            left, topLegendHeight, leftLegendWidth, seriesBound, axesBounds, bounds;\n\n        this.dataProcessor = dataProcessor;\n        this.chartLeftPadding = chartConst.CHART_PADDING;\n        this.legendCheckboxWidth = legendOption.hasCheckbox === false ? 0 : chartConst.LEGEND_CHECKBOX_WIDTH;\n\n        axesLabelInfo = this._makeAxesLabelInfo(params);\n        dimensions = this._makeComponentsDimensions(tui.util.extend({\n            axesLabelInfo: axesLabelInfo\n        }, params));\n\n\n        if (params.hasAxes) {\n            limitWidth = this._calculateXAxisLabelLimitWidth(dimensions.series.width, axesLabelInfo.xAxis.length, params.options.chartType);\n\n            if (xAxisOptions.rotation !== false) {\n                rotationInfo = this._makeHorizontalLabelRotationInfo(limitWidth, axesLabelInfo.xAxis, params.theme.xAxis.label);\n            }\n\n            this._updateDimensionsAndDegree(dimensions, rotationInfo, axesLabelInfo.xAxis, params.theme.xAxis.label, limitWidth);\n        }\n\n        topLegendHeight = predicate.isTopLegendAlign(legendOption.align) ? dimensions.legend.height : 0;\n        leftLegendWidth = predicate.isLeftLegendAlign(legendOption.align) ? dimensions.legend.width : 0;\n\n        top = dimensions.title.height + chartConst.CHART_PADDING + topLegendHeight;\n        left = dimensions.yAxis.width + this.chartLeftPadding + leftLegendWidth;\n\n        seriesBound = this._makeBasicBound(dimensions.series, top, left);\n\n        axesBounds = this._makeAxesBounds({\n            hasAxes: params.hasAxes,\n            rotationInfo: rotationInfo,\n            optionChartTypes: params.optionChartTypes,\n            dimensions: dimensions,\n            top: top,\n            left: left,\n            leftLegendWidth: leftLegendWidth\n        });\n\n        bounds = tui.util.extend({\n            chart: this._makeChartBound(dimensions.chart),\n            series: seriesBound,\n            legend: this._makeLegendBound(dimensions, legendOption),\n            tooltip: this._makeBasicBound(dimensions.series, top - chartConst.SERIES_EXPAND_SIZE, left - chartConst.SERIES_EXPAND_SIZE),\n            customEvent: seriesBound\n        }, axesBounds);\n\n        return bounds;\n    }\n};\n\nmodule.exports = boundsMaker;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"