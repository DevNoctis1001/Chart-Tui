tui.util.defineNamespace("fedoc.content", {});
fedoc.content["charts_comboChart.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Combo chart.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar calculator = require('../helpers/calculator'),\n    ChartBase = require('./chartBase'),\n    axisTypeMixer = require('./axisTypeMixer'),\n    axisDataMaker = require('../helpers/axisDataMaker'),\n    defaultTheme = require('../themes/defaultTheme'),\n    ColumnChartSeries = require('../series/columnChartSeries'),\n    LineChartSeries = require('../series/lineChartSeries');\n\nvar ComboChart = tui.util.defineClass(ChartBase, /** @lends ComboChart.prototype */ {\n    /**\n     * Combo chart.\n     * @constructs ComboChart\n     * @extends ChartBase\n     * @param {array.&lt;array>} rawData raw data\n     * @param {object} theme chart theme\n     * @param {object} options chart options\n     */\n    init: function(rawData, theme, options) {\n        var chartTypesMap;\n\n        this.className = 'tui-combo-chart';\n\n        chartTypesMap = this._makeChartTypesMap(rawData.series, options.yAxis);\n\n        tui.util.extend(this, chartTypesMap);\n\n        ChartBase.call(this, {\n            rawData: rawData,\n            theme: theme,\n            options: options,\n            hasAxes: true,\n            isVertical: true,\n            seriesChartTypes: chartTypesMap.seriesChartTypes\n        });\n\n        /**\n         * yAxis options map\n         * @type {object}\n         */\n        this.yAxisOptionsMap = this._makeYAxisOptionsMap(chartTypesMap.chartTypes, options.yAxis);\n        this._addComponents(chartTypesMap);\n    },\n\n    /**\n     * Make yAxis options map.\n     * @param {array.&lt;string>} chartTypes chart types\n     * @param {?object} yAxisOptions yAxis options\n     * @returns {{column: ?object, line: ?object}} options map\n     * @private\n     */\n    _makeYAxisOptionsMap: function(chartTypes, yAxisOptions) {\n        var optionMap = {};\n        yAxisOptions = yAxisOptions || {};\n        tui.util.forEachArray(chartTypes, function(chartType, index) {\n            optionMap[chartType] = yAxisOptions[index] || yAxisOptions;\n        });\n\n        return optionMap;\n    },\n\n    /**\n     * Make chart types map.\n     * @param {object} rawSeriesData raw series data\n     * @param {object} yAxisOption option for y axis\n     * @returns {object} chart types map\n     * @private\n     */\n    _makeChartTypesMap: function(rawSeriesData, yAxisOption) {\n        var seriesChartTypes = tui.util.keys(rawSeriesData).sort(),\n            optionChartTypes = this._getYAxisOptionChartTypes(seriesChartTypes, yAxisOption),\n            chartTypes = optionChartTypes.length ? optionChartTypes : seriesChartTypes,\n            validChartTypes = tui.util.filter(optionChartTypes, function(chartType) {\n                return rawSeriesData[chartType].length;\n            }),\n            chartTypesMap;\n\n        if (validChartTypes.length === 1) {\n            chartTypesMap = {\n                chartTypes: validChartTypes,\n                seriesChartTypes: validChartTypes,\n                optionChartTypes: !optionChartTypes.length ? optionChartTypes : validChartTypes\n            };\n        } else {\n            chartTypesMap = {\n                chartTypes: chartTypes,\n                seriesChartTypes: seriesChartTypes,\n                optionChartTypes: optionChartTypes\n            };\n        }\n\n        return chartTypesMap;\n    },\n\n    /**\n     * Make options map\n     * @param {object} chartTypes chart types\n     * @returns {object} options map\n     * @private\n     */\n    _makeOptionsMap: function(chartTypes) {\n        var optionsMap = {};\n        tui.util.forEachArray(chartTypes, function(chartType) {\n            optionsMap[chartType] = this.options.series &amp;&amp; this.options.series[chartType];\n        }, this);\n        return optionsMap;\n    },\n\n    /**\n     * Make theme map\n     * @param {object} chartTypes chart types\n     * @returns {object} theme map\n     * @private\n     */\n    _makeThemeMap: function(chartTypes) {\n        var theme = this.theme,\n            themeMap = {},\n            colorCount = 0;\n\n        tui.util.forEachArray(chartTypes, function(chartType) {\n            var chartTheme = JSON.parse(JSON.stringify(theme)),\n                removedColors;\n\n            if (chartTheme.series[chartType]) {\n                themeMap[chartType] = chartTheme.series[chartType];\n            } else if (!chartTheme.series.colors) {\n                themeMap[chartType] = JSON.parse(JSON.stringify(defaultTheme.series));\n                themeMap[chartType].label.fontFamily = chartTheme.chart.fontFamily;\n            } else {\n                removedColors = chartTheme.series.colors.splice(0, colorCount);\n                chartTheme.series.colors = chartTheme.series.colors.concat(removedColors);\n                themeMap[chartType] = chartTheme.series;\n                colorCount += this.dataProcessor.getLegendLabels(chartType).length;\n            }\n        }, this);\n\n        return themeMap;\n    },\n\n    /**\n     * Make serieses\n     * @param {array.&lt;string>} chartTypes chart types\n     * @returns {array.&lt;object>} serieses\n     * @private\n     */\n    _makeSerieses: function(chartTypes) {\n        var seriesClasses = {\n                column: ColumnChartSeries,\n                line: LineChartSeries\n            },\n            optionsMap = this._makeOptionsMap(chartTypes),\n            themeMap = this._makeThemeMap(chartTypes),\n            serieses;\n\n        serieses = tui.util.map(chartTypes, function(chartType) {\n            var data = {\n                allowNegativeTooltip: true,\n                componentType: 'series',\n                chartType: chartType,\n                options: optionsMap[chartType],\n                theme: themeMap[chartType]\n            };\n\n            return {\n                name: chartType + 'Series',\n                SeriesClass: seriesClasses[chartType],\n                data: data\n            };\n        });\n\n        return serieses;\n    },\n\n    /**\n     * Add components\n     * @param {object} chartTypesMap chart types map\n     * @private\n     */\n    _addComponents: function(chartTypesMap) {\n        var axes = ['yAxis', 'xAxis'],\n            serieses = this._makeSerieses(chartTypesMap.seriesChartTypes);\n\n        if (chartTypesMap.optionChartTypes.length) {\n            axes.push('rightYAxis');\n        }\n\n        this._addComponentsForAxisType({\n            axes: axes,\n            seriesChartTypes: chartTypesMap.seriesChartTypes,\n            chartType: this.options.chartType,\n            serieses: serieses\n        });\n    },\n\n    /**\n     * Get y axis option chart types.\n     * @param {array.&lt;string>} chartTypes chart types\n     * @param {object} yAxisOptions y axis options\n     * @returns {array.&lt;string>} chart types\n     * @private\n     */\n    _getYAxisOptionChartTypes: function(chartTypes, yAxisOptions) {\n        var resultChartTypes = chartTypes.slice(),\n            isReverse = false,\n            optionChartTypes;\n\n        yAxisOptions = yAxisOptions ? [].concat(yAxisOptions) : [];\n\n        if (yAxisOptions.length === 1 &amp;&amp; !yAxisOptions[0].chartType) {\n            resultChartTypes = [];\n        } else if (yAxisOptions.length) {\n            optionChartTypes = tui.util.map(yAxisOptions, function(option) {\n                return option.chartType;\n            });\n\n            tui.util.forEachArray(optionChartTypes, function(chartType, index) {\n                isReverse = isReverse || (chartType &amp;&amp; resultChartTypes[index] !== chartType || false);\n            });\n\n            if (isReverse) {\n                resultChartTypes.reverse();\n            }\n        }\n\n        return resultChartTypes;\n    },\n\n    /**\n     * Make y axis data.\n     * @param {object} params parameters\n     *      @param {number} params.index chart index\n     *      @param {{width: number, height: number}} params.seriesDimension series dimension\n     *      @param {array.&lt;string>} chartTypes chart type\n     *      @param {boolean} isOneYAxis whether one series or not\n     *      @param {object} options chart options\n     *      @param {object} addParams add params\n     * @returns {object} y axis data\n     * @private\n     */\n    _makeYAxisData: function(params) {\n        var index = params.index,\n            chartType = params.chartTypes[index],\n            options = params.options,\n            yAxisOptions = this.yAxisOptionsMap[chartType],\n            yAxisValues, seriesOption, yAxisData;\n\n        if (!chartType) {\n            return {};\n        }\n\n        if (params.isOneYAxis) {\n            yAxisValues = this.dataProcessor.getWholeGroupValues();\n        } else {\n            yAxisValues = this.dataProcessor.getGroupValues(chartType);\n        }\n\n        seriesOption = options.series &amp;&amp; options.series[chartType] || options.series;\n\n        yAxisData = axisDataMaker.makeValueAxisData(tui.util.extend({\n            values: yAxisValues,\n            stacked: seriesOption &amp;&amp; seriesOption.stacked || '',\n            options: yAxisOptions,\n            chartType: chartType,\n            seriesDimension: params.seriesDimension,\n            formatFunctions: this.dataProcessor.getFormatFunctions(),\n            isVertical: true\n        }, params.addParams));\n        yAxisData.options = yAxisOptions;\n\n        return yAxisData;\n    },\n\n    /**\n     * Make axes data\n     * @param {object} bounds chart bounds\n     * @returns {object} axes data\n     * @private\n     */\n    _makeAxesData: function(bounds) {\n        var options = this.options,\n            formatFunctions = this.dataProcessor.getFormatFunctions(),\n            yAxisParams = {\n                seriesDimension: bounds.series.dimension,\n                chartTypes: this.chartTypes,\n                isOneYAxis: !this.optionChartTypes.length,\n                options: options\n            },\n            xAxisData = axisDataMaker.makeLabelAxisData({\n                labels: this.dataProcessor.getCategories()\n            }),\n            yAxisData = this._makeYAxisData(tui.util.extend({\n                index: 0\n            }, yAxisParams)),\n            axesData, rightYAxisData;\n\n        axesData = {\n            yAxis: yAxisData,\n            xAxis: xAxisData\n        };\n\n        if (!yAxisParams.isOneYAxis) {\n            rightYAxisData = this._makeYAxisData(tui.util.extend({\n                index: 1,\n                addParams: {\n                    isPositionRight: true\n                }\n            }, yAxisParams));\n            if (yAxisData.tickCount &lt; rightYAxisData.tickCount) {\n                this._increaseYAxisTickCount(rightYAxisData.tickCount - yAxisData.tickCount, yAxisData, formatFunctions);\n            } else if (yAxisData.tickCount > rightYAxisData.tickCount) {\n                this._increaseYAxisTickCount(yAxisData.tickCount - rightYAxisData.tickCount, rightYAxisData, formatFunctions);\n            }\n\n            rightYAxisData.aligned = xAxisData.aligned;\n            axesData.rightYAxis = rightYAxisData;\n        }\n\n        return axesData;\n    },\n\n    /**\n     * Increase y axis tick count.\n     * @param {number} increaseTickCount increase tick count\n     * @param {object} toData to tick info\n     * @param {array.&lt;function>} formatFunctions format functions\n     * @private\n     */\n    _increaseYAxisTickCount: function(increaseTickCount, toData, formatFunctions) {\n        toData.limit.max += toData.step * increaseTickCount;\n        toData.labels = axisDataMaker.formatLabels(calculator.makeLabelsFromLimit(toData.limit, toData.step), formatFunctions);\n        toData.tickCount += increaseTickCount;\n        toData.validTickCount += increaseTickCount;\n    },\n\n    /**\n     * Render\n     * @returns {HTMLElement} chart element\n     */\n    render: function() {\n        return ChartBase.prototype.render.call(this, {\n            optionChartTypes: this.optionChartTypes\n        });\n    },\n\n    /**\n     * On change selected legend.\n     * @param {array.&lt;?boolean> | {line: ?array.&lt;boolean>, column: ?array.&lt;boolean>}} checkedLegends checked legends\n     */\n    onChangeCheckedLegends: function(checkedLegends) {\n        var rawData = this._filterRawData(this.rawData, checkedLegends),\n            chartTypesMap = this._makeChartTypesMap(rawData.series, this.options.yAxis);\n\n        tui.util.extend(this, chartTypesMap);\n\n        ChartBase.prototype.onChangeCheckedLegends.call(this, checkedLegends, rawData, chartTypesMap);\n    }\n});\n\naxisTypeMixer.mixin(ComboChart);\n\nmodule.exports = ComboChart;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"