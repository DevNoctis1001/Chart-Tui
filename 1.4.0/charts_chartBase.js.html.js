tui.util.defineNamespace("fedoc.content", {});
fedoc.content["charts_chartBase.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview ChartBase\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar dom = require('../helpers/domHandler'),\n    renderUtil = require('../helpers/renderUtil'),\n    DataProcessor = require('../helpers/dataProcessor'),\n    boundsMaker = require('../helpers/boundsMaker'),\n    UserEventListener = require('../helpers/userEventListener');\n\nvar ChartBase = tui.util.defineClass(/** @lends ChartBase.prototype */ {\n    /**\n     * Chart base.\n     * @constructs ChartBase\n     * @param {object} params parameters\n     *      @param {object} params.bounds chart bounds\n     *      @param {object} params.theme chart theme\n     *      @param {{yAxis: obejct, xAxis: object}} axesData axes data\n     *      @param {object} params.options chart options\n     *      @param {boolean} param.isVertical whether vertical or not\n     */\n    init: function(params) {\n        /**\n         * data processor\n         * @type {DataProcessor}\n         */\n        this.dataProcessor = this._createDataProcessor(params);\n\n        this.orgWholeLegendData = this.dataProcessor.getWholeLegendData();\n\n        /**\n         * component array\n         * @type {array}\n         */\n        this.components = [];\n\n        /**\n         * component instance map\n         * @type {object}\n         */\n        this.componentMap = {};\n\n        /**\n         * Raw data.\n         * @type {object} raw data\n         */\n        this.rawData = params.rawData;\n\n        /**\n         * theme\n         * @type {object}\n         */\n        this.theme = params.theme;\n\n        /**\n         * options\n         * @type {object}\n         */\n        this.options = params.options;\n\n        /**\n         * whether chart has axes or not\n         * @type {boolean}\n         */\n        this.hasAxes = params.hasAxes;\n\n        /**\n         * whether vertical or not\n         * @type {boolean}\n         */\n        this.isVertical = !!params.isVertical;\n\n        /**\n         * whether chart has group tooltip or not\n         * @type {*|boolean}\n         */\n        this.hasGroupTooltip = params.options.tooltip &amp;&amp; params.options.tooltip.grouped;\n\n        /**\n         * user event listener\n         * @type {object}\n         */\n        this.userEvent = new UserEventListener();\n\n        this.chartType = this.options.chartType;\n\n        this._addCustomEventComponent();\n    },\n\n    /**\n     * Create dataProcessor.\n     * @param {object} params parameters\n     *      @params {object} rawData raw data\n     *      @params {{chart: object, chartType: string}} options chart options\n     *      @params {array} seriesChartTypes series chart types\n     * @returns {object} data processor\n     * @private\n     */\n    _createDataProcessor: function(params) {\n        var dataProcessor = new DataProcessor(params.rawData),\n            options = params.options;\n\n        dataProcessor.process(params.rawData, options, params.seriesChartTypes);\n        return dataProcessor;\n    },\n\n    /**\n     * Make data for tooltip component.\n     * @returns {object} tooltip data\n     * @private\n     */\n    _makeTooltipData: function() {\n        return {\n            isVertical: this.isVertical,\n            userEvent: this.userEvent,\n            chartType: this.chartType\n        };\n    },\n\n    /**\n     * Add custom event component.\n     * @private\n     * @abstract\n     */\n    _addCustomEventComponent: function() {},\n\n    /**\n     * Add component.\n     * The component refers to a component of the chart.\n     * The component types are axis, legend, plot, series and customEvent.\n     * Chart Component Description : https://i-msdn.sec.s-msft.com/dynimg/IC267997.gif\n     * @param {string} name component name\n     * @param {function} Component component constructor\n     * @param {object} params parameters\n     * @private\n     */\n    _addComponent: function(name, Component, params) {\n        var commonParams = {},\n            options, index, theme,\n            component, componentType;\n\n        params = params || {};\n\n        componentType = params.componentType || name;\n        options = params.options || this.options[componentType];\n        theme = params.theme || this.theme[componentType];\n        index = params.index || 0;\n\n        commonParams.theme = tui.util.isArray(theme) ? theme[index] : theme;\n        commonParams.options = tui.util.isArray(options) ? options[index] : options || {};\n        commonParams.dataProcessor = this.dataProcessor;\n\n        params = tui.util.extend(params, commonParams);\n\n        component = new Component(params);\n\n        this.components.push({\n            name: name,\n            componentType: componentType,\n            instance: component\n        });\n        this.componentMap[name] = component;\n    },\n\n    /**\n     * Make bounds.\n     * @param {?object} boundParams addition params for calculating bounds\n     * @returns {object} chart bounds\n     * @private\n     */\n    _makeBounds: function(boundParams) {\n        return boundsMaker.make(this.dataProcessor, tui.util.extend({\n            theme: this.theme,\n            options: this.options,\n            hasAxes: this.hasAxes,\n            isVertical: this.isVertical,\n            chartType: this.chartType\n        }, boundParams));\n    },\n\n    /**\n     * Make rendering data for axis type chart.\n     * @param {object} bounds chart bounds\n     * @param {object} options options\n     * @private\n     * @abstract\n     */\n    _makeRenderingData: function() {},\n\n    /**\n     * Attach custom evnet.\n     * @private\n     */\n    _attachCustomEvent: function() {\n        var legend = this.componentMap.legend,\n            serieses = tui.util.filter(this.componentMap, function (component) {\n                return component.componentType === 'series';\n            });\n\n        if (legend) {\n            legend.on('changeCheckedLegends', this.onChangeCheckedLegends, this);\n            tui.util.forEach(serieses, function (series) {\n                legend.on(renderUtil.makeCustomEventName('select', series.chartType, 'legend'), series.onSelectLegend, series);\n            }, this);\n        }\n    },\n\n    /**\n     * Render chart.\n     * @param {object} boundParams parameters for making bounds\n     * @returns {HTMLElement} chart element\n     */\n    render: function(boundParams) {\n        var el = dom.create('DIV', this.className),\n            bounds, renderingData;\n\n        dom.addClass(el, 'tui-chart');\n        bounds = this._makeBounds(boundParams);\n        renderingData = this._makeRenderingData(bounds);\n\n        this._renderTitle(el);\n        renderUtil.renderDimension(el, bounds.chart.dimension);\n        renderUtil.renderBackground(el, this.theme.chart.background);\n        renderUtil.renderFontFamily(el, this.theme.chart.fontFamily);\n        this._renderComponents(bounds, renderingData, 'render', el);\n        this._sendSeriesData();\n        this._attachCustomEvent();\n        this.chartContainer = el;\n\n        return el;\n    },\n\n    /**\n     * Filter raw data.\n     * @param {object} rawData raw data\n     * @param {array.&lt;?boolean> | {line: ?array.&lt;boolean>, column: ?array.&lt;boolean>}} checkedLegends checked legends\n     * @returns {object} rawData\n     * @private\n     */\n    _filterRawData: function(rawData, checkedLegends) {\n        var cloneData = JSON.parse(JSON.stringify(rawData));\n\n        if (tui.util.isArray(cloneData.series)) {\n            cloneData.series = tui.util.filter(cloneData.series, function(series, index) {\n                return checkedLegends[index];\n            });\n        } else {\n            tui.util.forEach(cloneData.series, function(serieses, chartType) {\n                if (!checkedLegends[chartType]) {\n                    cloneData.series[chartType] = [];\n                } else if (checkedLegends[chartType].length) {\n                    cloneData.series[chartType] = tui.util.filter(serieses, function(series, index) {\n                        return checkedLegends[chartType][index];\n                    });\n                }\n            });\n        }\n\n        return cloneData;\n    },\n\n    /**\n     * Make rerendering data.\n     * @param {object} renderingData rendering data\n     * @param {array.&lt;?boolean> | {line: ?array.&lt;boolean>, column: ?array.&lt;boolean>}} checkedLegends checked legends\n     * @returns {object} rendering data\n     * @private\n     */\n    _makeRerenderingData: function(renderingData, checkedLegends) {\n        var tooltipData = this._makeTooltipData(),\n            serieses = tui.util.filter(this.componentMap, function(component) {\n                return component.componentType === 'series';\n            });\n\n        renderingData.tooltip = tui.util.extend({\n            checkedLegends: checkedLegends\n        }, tooltipData, renderingData.tooltip);\n\n        tui.util.forEach(serieses, function(series, seriesName) {\n            renderingData[seriesName] = tui.util.extend({\n                checkedLegends: checkedLegends[series.chartType] || checkedLegends\n            }, renderingData[seriesName]);\n        });\n\n        return renderingData;\n    },\n\n    /**\n     * Rerender.\n     * @param {array.&lt;?boolean> | {line: ?array.&lt;boolean>, column: ?array.&lt;boolean>}} checkedLegends checked legends\n     * @param {?object} rawData rawData\n     * @param {?object} boundsParams addition params for calculating bounds\n     * @private\n     */\n    _rerender: function(checkedLegends, rawData, boundsParams) {\n        var newWholeLegendData, bounds, renderingData;\n\n        rawData = rawData || this._filterRawData(this.dataProcessor.getRawData(), checkedLegends);\n\n        this.dataProcessor.process(rawData, this.options, this.seriesChartTypes);\n\n        newWholeLegendData = this.dataProcessor.getWholeLegendData();\n        // 범례 영역은 변경되지 않으므로, bounds 계산에는 변경되지 않은 레이블 데이터를 포함해야 함\n        this.dataProcessor.setWholeLegendData(this.orgWholeLegendData);\n        bounds = this._makeBounds(boundsParams);\n        this.dataProcessor.setWholeLegendData(newWholeLegendData);\n\n        renderingData = this._makeRenderingData(bounds);\n        renderingData = this._makeRerenderingData(renderingData, checkedLegends);\n\n        this._renderComponents(bounds, renderingData, 'rerender');\n\n        this._sendSeriesData(boundsParams);\n    },\n\n    /**\n     * On change checked legend.\n     * @param {array.&lt;?boolean> | {line: ?array.&lt;boolean>, column: ?array.&lt;boolean>}} checkedLegends checked legends\n     * @param {?object} rawData rawData\n     * @param {?object} boundsParams addition params for calculating bounds\n     */\n    onChangeCheckedLegends: function(checkedLegends, rawData, boundsParams) {\n        this._rerender(checkedLegends, rawData, boundsParams);\n    },\n\n    /**\n     * Render title.\n     * @param {HTMLElement} el target element\n     * @private\n     */\n    _renderTitle: function(el) {\n        var chartOptions = this.options.chart || {},\n            elTitle = renderUtil.renderTitle(chartOptions.title, this.theme.title, 'tui-chart-title');\n\n        dom.append(el, elTitle);\n    },\n\n    /**\n     * Render components.\n     * @param {array.&lt;object>} bounds bounds\n     * @param {object} renderingData data for rendering\n     * @param {string} funcName function name for execution\n     * @param {HTMLElement} container container element\n     * @private\n     */\n    _renderComponents: function(bounds, renderingData, funcName, container) {\n        var elements = tui.util.map(this.components, function(component) {\n            var bound = bounds[component.name] || bounds[component.componentType],\n                data = renderingData[component.name],\n                element = null;\n\n            if (bound &amp;&amp; component.instance[funcName]) {\n                element = component.instance[funcName](bound, data);\n            }\n\n            return element;\n        }, this);\n\n        if (container) {\n            dom.append(container, elements);\n        }\n    },\n\n    /**\n     * Send series data to custom event component.\n     * @private\n     */\n    _sendSeriesData: function() {\n        var seriesInfos, chartTypes;\n\n        if (!this.componentMap.customEvent) {\n            return;\n        }\n\n        chartTypes = this.chartTypes || [this.chartType];\n        seriesInfos = tui.util.map(chartTypes, function(chartType) {\n            var component = this.componentMap[chartType + 'Series'] || this.componentMap.series;\n\n            return {\n                chartType: chartType,\n                data: component.getSeriesData()\n            };\n        }, this);\n\n        this.componentMap.customEvent.initCustomEventData(seriesInfos);\n    },\n\n    /**\n     * Make event name for animation.\n     * @param {string} chartType chart type\n     * @param {string} prefix prefix\n     * @returns {string} event name\n     * @private\n     */\n    _makeAnimationEventName: function(chartType, prefix) {\n        return prefix + chartType.substring(0, 1).toUpperCase() + chartType.substring(1) + 'Animation';\n    },\n\n    /**\n     * Animate chart.\n     */\n    animateChart: function() {\n        tui.util.forEachArray(this.components, function(component) {\n            if (component.instance.animateComponent) {\n                component.instance.animateComponent();\n            }\n        });\n    },\n\n    /**\n     * Register of user event.\n     * @param {string} eventName event name\n     * @param {function} func event callback\n     */\n    on: function(eventName, func) {\n        this.userEvent.register(eventName, func);\n    },\n\n    /**\n     * Update dimension.\n     * @param {{width: number, height: number}} dimension dimension\n     * @returns {boolean} whether updated or not\n     * @private\n     */\n    _updateDimension: function(dimension) {\n        var updated = false;\n\n        if (dimension.width) {\n            this.options.chart.width = dimension.width;\n            updated = true;\n        }\n\n        if (dimension.height) {\n            this.options.chart.height = dimension.height;\n            updated = true;\n        }\n\n        return updated;\n    },\n\n    /**\n     * Public API for resizable.\n     * @param {object} dimension dimension\n     *      @param {number} dimension.width width\n     *      @param {number} dimension.height height\n     * @api\n     */\n    resize: function(dimension) {\n        var updated, bounds, renderingData;\n\n        if (!dimension) {\n            return;\n        }\n\n        updated = this._updateDimension(dimension);\n\n        if (!updated) {\n            return;\n        }\n\n        bounds = this._makeBounds();\n        renderingData = this._makeRenderingData(bounds);\n        renderUtil.renderDimension(this.chartContainer, bounds.chart.dimension);\n        this._renderComponents(bounds, renderingData, 'resize');\n        this._sendSeriesData();\n    },\n\n    /**\n     * Set tooltip align option.\n     * @param {string} align align (left|center|right, top|middle|bottom)\n     * @api\n     */\n    setTooltipAlign: function(align) {\n        this.componentMap.tooltip.setAlign(align);\n    },\n\n    /**\n     * Set position option.\n     * @param {object} position moving position\n     *      @param {number} position.left left\n     *      @param {number} position.top top\n     * @api\n     */\n    setTooltipPosition: function(position) {\n        this.componentMap.tooltip.setPosition(position);\n    },\n\n    /**\n     * Reset tooltip align option.\n     * @api\n     */\n    resetTooltipAlign: function() {\n        this.componentMap.tooltip.resetAlign();\n    },\n\n    /**\n     * Reset tooltip position.\n     * @api\n     */\n    resetTooltipPosition: function() {\n        this.componentMap.tooltip.resetPosition();\n    }\n});\n\nmodule.exports = ChartBase;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"