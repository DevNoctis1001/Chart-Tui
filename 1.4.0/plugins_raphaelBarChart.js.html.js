tui.util.defineNamespace("fedoc.content", {});
fedoc.content["plugins_raphaelBarChart.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Raphael bar chart renderer.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\nvar raphaelRenderUtil = require('./raphaelRenderUtil');\n\nvar Raphael = window.Raphael;\n\nvar ANIMATION_TIME = 700,\n    EMPHASIS_OPACITY = 1,\n    DE_EMPHASIS_OPACITY = 0.3;\n\n/**\n * @classdesc RaphaelBarChart is graph renderer for bar, column chart.\n * @class RaphaelBarChart\n */\nvar RaphaelBarChart = tui.util.defineClass(/** @lends RaphaelBarChart.prototype */ {\n    /**\n     * Render function of bar chart\n     * @param {HTMLElement} container container element\n     * @param {{size: object, model: object, options: object, tooltipPosition: string}} data chart data\n     * @return {object} paper raphael paper\n     */\n    render: function(container, data) {\n        var groupBounds = data.groupBounds,\n            dimension = data.dimension,\n            paper, baseParams;\n\n        if (!groupBounds) {\n            return null;\n        }\n\n        this.paper = paper = Raphael(container, dimension.width, dimension.height);\n\n        baseParams = {\n            paper: paper,\n            theme: data.theme,\n            groupBounds: groupBounds,\n            groupValues: data.groupValues,\n            chartType: data.chartType\n        };\n\n        this._renderBars(baseParams);\n\n        this._renderBarBorders(baseParams);\n\n        this.theme = data.theme;\n        this.groupBounds = groupBounds;\n        this.chartType = data.chartType;\n\n        return paper;\n    },\n\n    /**\n     * Render rect\n     * @param {object} params parameters\n     *      @param {object} params.paper raphael paper\n     *      @param {string} params.color series color\n     *      @param {string} params.borderColor series borderColor\n     *      @param {{left: number, top: number, width: number, height: number}} params.bound bound\n     * @returns {object} bar rect\n     * @private\n     */\n    _renderBar: function(params) {\n        var bound = params.bound,\n            rect;\n\n        if (bound.width &lt; 0 || bound.height &lt; 0) {\n            return null;\n        }\n\n        rect = params.paper.rect(bound.left, bound.top, bound.width, bound.height);\n        rect.attr({\n            fill: params.color,\n            stroke: 'none'\n        });\n\n        return rect;\n    },\n\n    /**\n     * Render bars.\n     * @param {object} params parameters\n     *      @param {object} params.paper raphael paper\n     *      @param {{colors: string[], singleColors: string[], borderColor: string}} params.theme bar chart theme\n     *      @param {array.&lt;array.&lt;{left: number, top:number, width: number, height: number}>>} params.groupBounds bounds\n     * @private\n     */\n    _renderBars: function(params) {\n        var singleColors = (params.groupBounds[0].length === 1) &amp;&amp; params.theme.singleColors || [],\n            colors = params.theme.colors;\n\n        this.groupBars = tui.util.map(params.groupBounds, function(bounds, groupIndex) {\n            var singleColor = singleColors[groupIndex];\n            return tui.util.map(bounds, function(bound, index) {\n                var color, rect, value;\n\n                if (!bound) {\n                    return null;\n                }\n\n                color = singleColor || colors[index];\n                value = params.groupValues[groupIndex][index];\n\n                rect = this._renderBar({\n                    paper: params.paper,\n                    chartType: params.chartType,\n                    color: color,\n                    borderColor: params.theme.borderColor,\n                    bound: bound.start,\n                    value: value\n                });\n\n                return {\n                    rect: rect,\n                    color: color,\n                    bound: bound.end,\n                    value: value,\n                    groupIndex: groupIndex,\n                    index: index\n                };\n            }, this);\n        }, this);\n    },\n\n    /**\n     * Make rect points.\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @returns {{\n     *      leftTop: {left: number, top: number},\n     *      rightTop: {left: number, top: number},\n     *      rightBottom: {left: number, top: number},\n     *      leftBottom: {left: number, top: number}\n     * }} rect points\n     * @private\n     */\n    _makeRectPoints: function(bound) {\n        return {\n            leftTop: {\n                left: Math.ceil(bound.left),\n                top: Math.ceil(bound.top)\n            },\n            rightTop: {\n                left: Math.ceil(bound.left + bound.width),\n                top: Math.ceil(bound.top)\n            },\n            rightBottom: {\n                left: Math.ceil(bound.left + bound.width),\n                top: Math.ceil(bound.top + bound.height)\n            },\n            leftBottom: {\n                left: Math.ceil(bound.left),\n                top: Math.ceil(bound.top + bound.height)\n            }\n        };\n    },\n\n    /**\n     * Make top line path.\n     * @param {{left: numbrer, top: number}} leftTop left top\n     * @param {{left: numbrer, top: number}} rightTop right top\n     * @param {string} chartType chart type\n     * @param {number} value value\n     * @returns {string} top line path\n     * @private\n     */\n    _makeTopLinePath: function(leftTop, rightTop, chartType, value) {\n        var cloneLeftTop = tui.util.extend({}, leftTop);\n        cloneLeftTop.left -= chartType === 'column' || value &lt; 0 ? 1 : 0;\n        return raphaelRenderUtil.makeLinePath(cloneLeftTop, rightTop).join(' ');\n    },\n\n    /**\n     * Make border lines paths.\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @param {string} chartType chart type\n     * @param {number} value value\n     * @returns {{top: string, right: string, bottom: string, left: string}} paths\n     * @private\n     */\n    _makeBorderLinesPaths: function(bound, chartType, value) {\n        var points = this._makeRectPoints(bound),\n            paths = {};\n\n        if (chartType === 'bar' || value >= 0) {\n            paths.top = this._makeTopLinePath(points.leftTop, points.rightTop, chartType, value);\n        }\n\n        if (chartType === 'column' || value >= 0) {\n            paths.right = raphaelRenderUtil.makeLinePath(points.rightTop, points.rightBottom).join(' ');\n        }\n\n        if (chartType === 'bar' || value &lt; 0) {\n            paths.bottom = raphaelRenderUtil.makeLinePath(points.leftBottom, points.rightBottom).join(' ');\n        }\n\n        if (chartType === 'column' || value &lt; 0) {\n            paths.left = raphaelRenderUtil.makeLinePath(points.leftTop, points.leftBottom).join(' ');\n        }\n\n        return paths;\n    },\n\n    /**\n     * Render border lines;\n     * @param {object} params parameters\n     *      @param {object} params.paper paper\n     *      @param {{left: number, top:number, width: number, height: number}} params.bound bar bound\n     *      @param {string} params.borderColor border color\n     *      @param {string} params.chartType chart type\n     *      @param {number} params.value value\n     * @returns {object} raphael object\n     * @private\n     */\n    _renderBorderLines: function(params) {\n        var borderLinePaths = this._makeBorderLinesPaths(params.bound, params.chartType, params.value),\n            lines = {};\n\n        tui.util.forEach(borderLinePaths, function(path, name) {\n            lines[name] = raphaelRenderUtil.renderLine(params.paper, path, params.borderColor, 1);\n        });\n\n        return lines;\n    },\n\n    /**\n     * Render bar borders.\n     * @param {object} params parameters\n     *      @param {object} params.paper raphael paper\n     *      @param {{colors: string[], singleColors: string[], borderColor: string}} params.theme bar chart theme\n     *      @param {array.&lt;array.&lt;{left: number, top:number, width: number, height: number}>>} params.groupBounds bounds\n     * @private\n     */\n    _renderBarBorders: function(params) {\n        var borderColor = params.theme.borderColor;\n\n        if (!borderColor) {\n            return;\n        }\n\n        this.groupBorders = tui.util.map(params.groupBounds, function(bounds, groupIndex) {\n            return tui.util.map(bounds, function(bound, index) {\n                var value;\n\n                if (!bound) {\n                    return null;\n                }\n\n                value = params.groupValues[groupIndex][index];\n\n                return this._renderBorderLines({\n                    paper: params.paper,\n                    bound: bound.start,\n                    borderColor: borderColor,\n                    chartType: params.chartType,\n                    value: value\n                });\n            }, this);\n        }, this);\n    },\n\n    /**\n     * Animate rect.\n     * @param {object} rect raphael object\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @private\n     */\n    _animateRect: function(rect, bound) {\n        rect.animate({\n            x: bound.left,\n            y: bound.top,\n            width: bound.width,\n            height: bound.height\n        }, ANIMATION_TIME);\n    },\n\n    /**\n     * Animate borders.\n     * @param {array.&lt;object>} lines raphael objects\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @param {string} chartType chart type\n     * @param {number} value value\n     * @private\n     */\n    _animateBorders: function(lines, bound, chartType, value) {\n        var paths = this._makeBorderLinesPaths(bound, chartType, value);\n\n        tui.util.forEach(lines, function(line, name) {\n            line.animate({path: paths[name]}, ANIMATION_TIME);\n        });\n    },\n\n    /**\n     * Animate.\n     * @param {function} callback callback\n     */\n    animate: function(callback) {\n        var that = this,\n            groupBorders = this.groupBorders || [];\n\n        if (this.callbackTimeout) {\n            clearTimeout(this.callbackTimeout);\n            delete this.callbackTimeout;\n        }\n        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {\n            var lines = groupBorders[groupIndex] &amp;&amp; groupBorders[groupIndex][index];\n            if (!bar) {\n                return;\n            }\n            that._animateRect(bar.rect, bar.bound);\n            if (lines) {\n                that._animateBorders(lines, bar.bound, that.chartType, bar.value);\n            }\n        });\n\n        if (callback) {\n            this.callbackTimeout = setTimeout(function() {\n                callback();\n                delete that.callbackTimeout;\n            }, ANIMATION_TIME);\n        }\n    },\n\n    /**\n     * Update rect bound\n     * @param {object} rect raphael object\n     * @param {{left: number, top: number, width: number, height: number}} bound bound\n     * @private\n     */\n    _updateRectBound: function(rect, bound) {\n        rect.attr({\n            x: bound.left,\n            y: bound.top,\n            width: bound.width,\n            height: bound.height\n        });\n    },\n\n    /**\n     * Update borders attribute\n     * @param {array.&lt;object>} lines raphael objects\n     * @param {{left: number, top: number, width: number, height: number}} bound bound\n     * @param {string} chartType chart type\n     * @param {number} value value\n     * @private\n     */\n    _updateBordersPath: function(lines, bound, chartType, value) {\n        var paths = this._makeBorderLinesPaths(bound, chartType, value);\n\n        tui.util.forEach(lines, function(line, name) {\n            line.attr({path: paths[name]});\n        });\n    },\n\n    /**\n     * Resize graph of bar type chart.\n     * @param {object} params parameters\n     *      @param {{width: number, height:number}} params.dimension dimension\n     *      @param {array.&lt;array.&lt;{left:number, top:number, width: number, height: number}>>} params.groupBounds group bounds\n     */\n    resize: function(params) {\n        var that = this,\n            groupBorders = this.groupBorders || [],\n            dimension = params.dimension,\n            groupBounds = params.groupBounds;\n\n        this.groupBounds = groupBounds;\n        this.paper.setSize(dimension.width, dimension.height);\n\n        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {\n            var lines, bound;\n\n            if (!bar) {\n                return;\n            }\n\n            lines = groupBorders[groupIndex] &amp;&amp; groupBorders[groupIndex][index];\n            bound = groupBounds[groupIndex][index].end;\n            bar.bound = bound;\n            that._updateRectBound(bar.rect, bound);\n\n            if (lines) {\n                that._updateBordersPath(lines, bound, that.chartType, bar.value);\n            }\n        });\n    },\n\n    /**\n     * Change borders color.\n     * @param {array.&lt;object>} lines raphael objects\n     * @param {borderColor} borderColor border color\n     * @private\n     */\n    _changeBordersColor: function(lines, borderColor) {\n        tui.util.forEach(lines, function(line) {\n            line.attr({stroke: borderColor});\n        });\n    },\n\n    /**\n     * Change bar color.\n     * @param {{groupIndex: number, index: number}} indexes indexes\n     * @param {string} color fill color\n     * @param {?string} borderColor stroke color\n     * @private\n     */\n    _changeBarColor: function(indexes, color, borderColor) {\n        var bar = this.groupBars[indexes.groupIndex][indexes.index],\n            lines;\n\n        bar.rect.attr({\n            fill: color\n        });\n\n        if (borderColor) {\n            lines = this.groupBorders[indexes.groupIndex][indexes.index];\n            this._changeBordersColor(lines, borderColor);\n        }\n    },\n\n    /**\n     * Select series.\n     * @param {{groupIndex: number, index: number}} indexes indexes\n     */\n    selectSeries: function(indexes) {\n        var bar = this.groupBars[indexes.groupIndex][indexes.index],\n            objColor = Raphael.color(bar.color),\n            color = this.theme.selectionColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, 0.2),\n            borderColor = this.theme.borderColor,\n            objBorderColor;\n\n        if (borderColor) {\n            objBorderColor = Raphael.color(borderColor);\n            borderColor = raphaelRenderUtil.makeChangedLuminanceColor(objBorderColor.hex, 0.2);\n        }\n\n        this._changeBarColor(indexes, color, borderColor);\n    },\n\n    /**\n     * Unselect series.\n     * @param {{groupIndex: number, index: number}} indexes indexes\n     */\n    unselectSeries: function(indexes) {\n        var bar = this.groupBars[indexes.groupIndex][indexes.index],\n            borderColor = this.theme.borderColor;\n        this._changeBarColor(indexes, bar.color, borderColor);\n    },\n\n    /**\n     * Select legend.\n     * @param {?number} legendIndex legend index\n     */\n    selectLegend: function(legendIndex) {\n        var groupBorders = this.groupBorders || [],\n            noneSelected = tui.util.isNull(legendIndex);\n\n        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {\n            var lines, opacity;\n\n            if (!bar) {\n                return;\n            }\n\n            lines = groupBorders[groupIndex] &amp;&amp; groupBorders[groupIndex][index];\n            opacity = (noneSelected || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;\n\n            bar.rect.attr({'fill-opacity': opacity});\n            if (lines) {\n                tui.util.forEach(lines, function(line) {\n                    line.attr({'stroke-opacity': opacity});\n                });\n            }\n        });\n    }\n});\n\nmodule.exports = RaphaelBarChart;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"