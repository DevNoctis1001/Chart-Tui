ne.util.defineNamespace("fedoc.content", {});
fedoc.content["helpers_calculator.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview calculator.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const');\n\n/**\n * Calculator.\n * @module calculator\n */\nvar calculator = {\n    /**\n     * To calculate scale from chart min, max data.\n     *  - http://peltiertech.com/how-excel-calculates-automatic-chart-axis-limits/\n     * @memberOf module:calculator\n     * @param {number} min min minimum value of user data\n     * @param {number} max max maximum value of user data\n     * @param {number} tickCount tick count\n     * @returns {{min: number, max: number}} scale axis scale\n     */\n    calculateScale: function(min, max) {\n        var saveMin = 0,\n            scale = {},\n            iodValue; // increase or decrease value;\n\n        if (min &lt; 0) {\n            saveMin = min;\n            max -= min;\n            min = 0;\n        }\n\n        iodValue = (max - min) / 20;\n        scale.max = max + iodValue + saveMin;\n\n        if (max / 6 > min) {\n            scale.min = 0 + saveMin;\n        } else {\n            scale.min = min - iodValue + saveMin;\n        }\n        return scale;\n    },\n\n    /**\n     * To normalize number.\n     * @memberOf module:calculator\n     * @param {number} value target value\n     * @returns {number} normalized number\n     */\n    normalizeAxisNumber: function(value) {\n        var standard = 0,\n            flag = 1,\n            normalized, mod;\n\n        if (value === 0) {\n            return value;\n        } else if (value &lt; 0) {\n            flag = -1;\n        }\n\n        value *= flag;\n\n        tui.util.forEachArray(chartConst.AXIS_STANDARD_MULTIPLE_NUMS, function(num) {\n            if (value &lt; num) {\n                if (num > 1) {\n                    standard = num;\n                }\n                return false;\n            } else if (num === 10) {\n                standard = 10;\n            }\n        });\n\n        if (standard &lt; 1) {\n            normalized = this.normalizeAxisNumber(value * 10) * 0.1;\n        } else {\n            mod = tui.util.mod(value, standard);\n            normalized = tui.util.addition(value, (mod > 0 ? standard - mod : 0));\n        }\n\n        return normalized *= flag;\n    },\n\n    /**\n     * To make tick positions of pixel type.\n     * @memberOf module:calculator\n     * @param {number} size area width or height\n     * @param {number} count tick count\n     * @returns {array.&lt;number>} positions\n     */\n    makeTickPixelPositions: function(size, count) {\n        var positions = [],\n            pxScale, pxStep;\n\n        if (count > 0) {\n            pxScale = {min: 0, max: size - 1};\n            pxStep = this.getScaleStep(pxScale, count);\n            positions = tui.util.map(tui.util.range(0, size, pxStep), function(position) {\n                return Math.round(position);\n            });\n            positions[positions.length - 1] = size - 1;\n        }\n        return positions;\n    },\n\n    /**\n     * To make labels from scale.\n     * @memberOf module:calculator\n     * @param {{min: number, max: number}} scale axis scale\n     * @param {number} step step between max and min\n     * @returns {string[]} labels\n     * @private\n     */\n    makeLabelsFromScale: function(scale, step) {\n        var multipleNum = tui.util.findMultipleNum(step),\n            min = scale.min * multipleNum,\n            max = scale.max * multipleNum,\n            labels = tui.util.range(min, max + 1, step * multipleNum);\n        labels = tui.util.map(labels, function(label) {\n            return label / multipleNum;\n        });\n        return labels;\n    },\n\n    /**\n     * Get scale step.\n     * @memberOf module:calculator\n     * @param {{min: number, max: number}} scale axis scale\n     * @param {number} count value count\n     * @returns {number} scale step\n     */\n    getScaleStep: function(scale, count) {\n        return (scale.max - scale.min) / (count - 1);\n    },\n\n    /**\n     * To calculate adjacent.\n     * @param {number} degree degree\n     * @param {number} hypotenuse hypotenuse\n     * @returns {number} adjacent\n     *\n     *   H : Hypotenuse\n     *   A : Adjacent\n     *   O : Opposite\n     *   D : Degree\n     *\n     *        /|\n     *       / |\n     *    H /  | O\n     *     /   |\n     *    /\\ D |\n     *    -----\n     *       A\n     */\n    calculateAdjacent: function(degree, hypotenuse) {\n        return Math.cos(degree * chartConst.RAD) * hypotenuse;\n    },\n\n    /**\n     * To calculate opposite.\n     * @param {number} degree degree\n     * @param {number} hypotenuse hypotenuse\n     * @returns {number} opposite\n     */\n    calculateOpposite: function(degree, hypotenuse) {\n        return Math.sin(degree * chartConst.RAD) * hypotenuse;\n    }\n};\n\nmodule.exports = calculator;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"