tui.util.defineNamespace("fedoc.content", {});
fedoc.content["models_data_seriesDataModelForTreemap.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview SeriesDataModelForTreemap is base model for drawing graph of treemap chart series area.\n * SeriesDataModel.groups has SeriesGroups.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar SeriesDataModel = require('./seriesDataModel');\nvar SeriesItem = require('./seriesItemForTreemap');\nvar chartConst = require('../../const');\n\nvar aps = Array.prototype.slice;\n\nvar SeriesDataModelForTreemap = tui.util.defineClass(SeriesDataModel, {\n    /**\n     * SeriesDataModelForTreemap is base model for drawing graph of treemap chart series area.\n     * @constructs SeriesDataModelForTreemap\n     */\n    init: function() {\n        SeriesDataModel.apply(this, arguments);\n\n        /**\n         * cached found seriesItems map\n         * @type {object.&lt;string, Array.&lt;SeriesItem>>}\n         */\n        this.foundSeriesItemsMap = {};\n\n        /**\n         * cached seriesItem map\n         * @type {object&lt;string, SeriesItem>}\n         */\n        this.seriesItemMap = {};\n    },\n\n    /**\n     * Flatten hierarchical data.\n     * @param {Array.&lt;object>} rawSeriesData - raw series data\n     * @param {string | number} parent - parent id\n     * @param {?Array.&lt;number>} ancestorIndexes - ancestor indexes\n     * @returns {Array.&lt;object>}\n     * @private\n     */\n    _flattenHierarchicalData: function(rawSeriesData, parent, ancestorIndexes) {\n        var self = this;\n        var flatData = [];\n        var idPrefix;\n\n        if (parent) {\n            idPrefix = parent + '_';\n        } else {\n            idPrefix = chartConst.TREEMAP_ID_PREFIX;\n            parent = chartConst.TREEMAP_ROOT_ID;\n        }\n\n        ancestorIndexes = ancestorIndexes || [];\n\n        tui.util.forEachArray(rawSeriesData, function(datum, index) {\n            var id = idPrefix + index;\n            var children = datum.children;\n            var indexes = ancestorIndexes.concat(index);\n\n            datum.indexes = indexes;\n\n            flatData.push(datum);\n\n            if (!datum.id) {\n                datum.id = id;\n            }\n\n            if (!datum.parent) {\n                datum.parent = parent;\n            }\n\n            if (children) {\n                flatData = flatData.concat(self._flattenHierarchicalData(children, id, indexes));\n                delete datum.children;\n            }\n        });\n\n        return flatData;\n    },\n\n    /**\n     * Partition raw series data by parent id\n     * @param {Array.&lt;object>} rawSeriesData - raw series data\n     * @param {string | number} parent - parent id\n     * @returns {Array.&lt;Array>}\n     * @private\n     */\n    _partitionRawSeriesDataByParent: function(rawSeriesData, parent) {\n        var filtered = [];\n        var rejected = [];\n\n        tui.util.forEachArray(rawSeriesData, function(datum) {\n            if (datum.parent === parent) {\n                filtered.push(datum);\n            } else {\n                rejected.push(datum);\n            }\n        });\n\n        return [filtered, rejected];\n    },\n\n    /**\n     * Set tree properties like depth, group in raw series data.\n     * @param {Array.&lt;object>} rawSeriesData - raw series data\n     * @param {number} depth - tree depth\n     * @param {number} parent - parent id\n     * @param {number} group - tree group\n     * @returns {Array.&lt;object>}\n     * @private\n     */\n    _setTreeProperties: function(rawSeriesData, depth, parent, group) {\n        var self = this;\n        var parted = this._partitionRawSeriesDataByParent(rawSeriesData, parent);\n        var filtered = parted[0];\n        var rejected = parted[1];\n        var childDepth = depth + 1;\n\n        tui.util.forEachArray(filtered, function(datum, index) {\n            var descendants, children;\n\n            datum.depth = depth;\n            datum.group = tui.util.isUndefined(group) ? index : group;\n\n            descendants = self._setTreeProperties(rejected, childDepth, datum.id, datum.group);\n            children = tui.util.filter(descendants, function(descendant) {\n                return descendant.depth === childDepth;\n            });\n\n            if (children.length) {\n                datum.value = tui.util.sum(tui.util.pluck(children, 'value'));\n                datum.hasChild = true;\n            } else {\n                datum.hasChild = false;\n            }\n\n            filtered = filtered.concat(descendants);\n        });\n\n        return filtered;\n    },\n\n    /**\n     * Create base groups.\n     * @returns {Array.&lt;Array.&lt;SeriesItem>>}\n     * @private\n     * @override\n     */\n    _createBaseGroups: function() {\n        var chartType = this.chartType;\n        var rawSeriesData = this.rawSeriesData;\n        var seriesItemMap = this.seriesItemMap;\n        var formatFunctions = this.formatFunctions;\n\n        rawSeriesData = this._flattenHierarchicalData(rawSeriesData);\n        rawSeriesData = this._setTreeProperties(rawSeriesData, 1, chartConst.TREEMAP_ROOT_ID);\n\n        return [tui.util.map(rawSeriesData, function(rawDatum) {\n            var seriesItem = new SeriesItem(rawDatum, formatFunctions, chartType);\n\n            seriesItemMap[seriesItem.id] = seriesItem;\n\n            return seriesItem;\n        })];\n    },\n\n    /**\n     * Find SeriesItems.\n     * @param {string} key - key\n     * @param {function} condition - condition function\n     * @returns {Array.&lt;SeriesItem>}\n     * @private\n     */\n    _findSeriesItems: function(key, condition) {\n        if (!this.foundSeriesItemsMap[key]) {\n            this.foundSeriesItemsMap[key] = this.getFirstSeriesGroup(true).filter(condition);\n        }\n\n        return this.foundSeriesItemsMap[key];\n    },\n\n    /**\n     * Make cache key for caching found SeriesItems.\n     * @param {string} prefix - prefix\n     * @returns {string}\n     * @private\n     */\n    _makeCacheKey: function(prefix) {\n        var key = prefix;\n\n        if (arguments.length > 1) {\n            key += aps.call(arguments, 1).join('_');\n        }\n\n        return key;\n    },\n\n    /**\n     * Whether valid group or not.\n     * If comparingGroup is undefined or group and comparingGroup are equal, this group is valid.\n     * @param {number} group - group\n     * @param {number} [comparingGroup] - comparing group\n     * @returns {boolean}\n     * @private\n     */\n    _isValidGroup: function(group, comparingGroup) {\n        return !tui.util.isExisty(comparingGroup) || (group === comparingGroup);\n    },\n\n    /**\n     * Find SeriesItems by depth.\n     * @param {number} depth - tree depth\n     * @param {number} [group] - tree group\n     * @returns {Array.&lt;SeriesItem>}\n     */\n    findSeriesItemsByDepth: function(depth, group) {\n        var self = this;\n        var key = this._makeCacheKey(chartConst.TREEMAP_DEPTH_KEY_PREFIX, depth, group);\n\n        return this._findSeriesItems(key, function(seriesItem) {\n            return (seriesItem.depth === depth) &amp;&amp; self._isValidGroup(seriesItem.group, group);\n        });\n    },\n\n    /**\n     * Find SeriesItems by parent id.\n     * @param {string | number} parent - parent id\n     * @returns {Array.&lt;SeriesItem>}\n     */\n    findSeriesItemsByParent: function(parent) {\n        var key = this._makeCacheKey(chartConst.TREEMAP_PARENT_KEY_PREFIX, parent);\n\n        return this._findSeriesItems(key, function(seriesItem) {\n            return seriesItem.parent === parent;\n        });\n    },\n\n    /**\n     * Find leaf SeriesItems.\n     * @param {number} [group] - tree group\n     * @returns {Array.&lt;SeriesItem>}\n     */\n    findLeafSeriesItems: function(group) {\n        var self = this;\n        var key = this._makeCacheKey(chartConst.TREEMAP_LEAF_KEY_PREFIX, group);\n\n        return this._findSeriesItems(key, function(seriesItem) {\n            return !seriesItem.hasChild &amp;&amp; self._isValidGroup(seriesItem.group, group);\n        });\n    },\n\n    /**\n     * Find parent by depth.\n     * @param {string} id - id\n     * @param {number} depth - depth\n     * @returns {SeriesItem|null}\n     */\n    findParentByDepth: function(id, depth) {\n        var seriesItem = this.seriesItemMap[id] || null;\n\n        if (seriesItem &amp;&amp; seriesItem.depth !== depth) {\n            seriesItem = this.findParentByDepth(seriesItem.parent, depth);\n        }\n\n        return seriesItem;\n    },\n\n    /**\n     * Initialize foundSeriesItemsMap.\n     */\n    initSeriesItemsMap: function() {\n        this.foundSeriesItemsMap = null;\n    }\n});\n\nmodule.exports = SeriesDataModelForTreemap;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"