tui.util.defineNamespace("fedoc.content", {});
fedoc.content["components_customEvents_customEventBase.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview CustomEventBase is base class for event handle layers.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar TickBaseCoordinateModel = require('./tickBaseCoordinateModel');\nvar BoundsBaseCoordinateModel = require('./boundsBaseCoordinateModel');\nvar chartConst = require('../../const/');\nvar eventListener = require('../../helpers/eventListener');\nvar predicate = require('../../helpers/predicate');\nvar dom = require('../../helpers/domHandler');\nvar renderUtil = require('../../helpers/renderUtil');\n\nvar CustomEventBase = tui.util.defineClass(/** @lends CustomEventBase.prototype */ {\n    /**\n     * CustomEventBase is base class for custom event components.\n     * @constructs CustomEventBase\n     * @param {object} params parameters\n     *      @param {string} params.chartType - chart type\n     *      @param {Array.&lt;string>} params.chartTypes - chart types\n     *      @param {boolean} params.isVertical - whether vertical or not\n     *      @param {DataProcessor} params.dataProcessor - DataProcessor instance\n     *      @param {boolean} params.allowSelect - whether has allowSelect option or not\n     */\n    init: function(params) {\n        var isLineTypeChart;\n\n        /**\n         * type of chart\n         * @type {string}\n         */\n        this.chartType = params.chartType;\n\n        /**\n         * chartTypes is available in combo chart\n         * @type {Array.&lt;string>}\n         */\n        this.chartTypes = params.chartTypes;\n\n        /**\n         * whether vertical or not\n         * @type {boolean}\n         */\n        this.isVertical = params.isVertical;\n\n        /**\n         * data processor\n         * @type {DataProcessor}\n         */\n        this.dataProcessor = params.dataProcessor;\n\n        /**\n         * whether allow select series or not\n         */\n        this.allowSelect = params.allowSelect;\n\n        /**\n         * event bus for transmitting message\n         * @type {object}\n         */\n        this.eventBus = params.eventBus;\n\n        /**\n         * layout bounds information for this components\n         * @type {null|{dimension:{width:number, height:number}, position:{left:number, top:number}}}\n         */\n        this.layout = null;\n\n        /**\n         * selected series item.\n         * @type {null | object}\n         */\n        this.selectedData = null;\n\n        /**\n         * previous client position of mouse event (clientX, clientY)\n         * @type {null | object}\n         */\n        this.prevClientPosition = null;\n\n        /**\n         * previous found data\n         * @type {null | object}\n         */\n        this.prevFoundData = null;\n\n\n        isLineTypeChart = predicate.isLineTypeChart(this.chartType, this.chartTypes);\n\n        /**\n         * expand size\n         * @type {number}\n         */\n        this.expandSize = isLineTypeChart ? chartConst.SERIES_EXPAND_SIZE : 0;\n\n        /**\n         * container bound\n         * @type {null | {left: number, top: number, right: number, bottom: number}}\n         */\n        this.containerBound = null;\n\n        /**\n         * series data set\n         * @type {Array}\n         */\n        this.seriesDataSet = [];\n\n        /**\n         * series count\n         * @type {number}\n         */\n        this.seriesCount = predicate.isComboChart(this.chartType) ? 2 : 1;\n\n        this._attachToEventBus();\n    },\n\n    /**\n     * Attach to event bus.\n     * @private\n     */\n    _attachToEventBus: function() {\n        this.eventBus.on('receiveSeriesData', this.onReceiveSeriesData, this);\n    },\n\n    /**\n     * Get bound for rendering.\n     * @returns {{\n     *      dimension: {width: number, height: number},\n     *      position: {left: number, top: number}\n     * }}\n     * @private\n     */\n    _getRenderingBound: function() {\n        var renderingBound = this.layout;\n\n        if (predicate.isLineTypeChart(this.chartType, this.chartTypes)) {\n            renderingBound = renderUtil.expandBound(renderingBound);\n        }\n\n        return renderingBound;\n    },\n\n    /**\n     * Render event handle layer area.\n     * @param {HTMLElement} customEventContainer - container element for custom event\n     * @param {number} tickCount - tick count\n     * @private\n     */\n    _renderCustomEventArea: function(customEventContainer, tickCount) {\n        var dimension = this.layout.dimension;\n        var renderingBound, tbcm;\n\n        this.dimension = dimension;\n        tbcm = new TickBaseCoordinateModel(dimension, tickCount, this.chartType, this.isVertical, this.chartTypes);\n        this.tickBaseCoordinateModel = tbcm;\n        renderingBound = this._getRenderingBound();\n        renderUtil.renderDimension(customEventContainer, renderingBound.dimension);\n        renderUtil.renderPosition(customEventContainer, renderingBound.position);\n    },\n\n    /**\n     * Set data for rendering.\n     * @param {{\n     *      layout: {\n     *          dimension: {width: number, height: number},\n     *          position: {left: number, top: number}\n     *      }\n     * }} data - bounds data\n     * @private\n     */\n    _setDataForRendering: function(data) {\n        this.layout = data.layout;\n    },\n\n    /**\n     * Pick tick count.\n     * @param {{xAxis: object, yAxis: object}} axisDataMap - axis data map\n     * @returns {number}\n     * @private\n     */\n    _pickTickCount: function(axisDataMap) {\n        var tickCount;\n\n        if (this.isVertical) {\n            tickCount = axisDataMap.xAxis.eventTickCount || axisDataMap.xAxis.tickCount;\n        } else {\n            tickCount = axisDataMap.yAxis.tickCount;\n        }\n\n        return tickCount;\n    },\n\n    /**\n     * Render for customEvent component.\n     * @param {object} data - bounds data and tick count\n     * @returns {HTMLElement} container for custom event\n     */\n    render: function(data) {\n        var container = dom.create('DIV', 'tui-chart-series-custom-event-area');\n        var tickCount;\n\n        if (data.axisDataMap.xAxis) {\n            tickCount = this._pickTickCount(data.axisDataMap);\n        }\n\n        this._setDataForRendering(data);\n        this._renderCustomEventArea(container, tickCount);\n        this.attachEvent(container);\n        this.customEventContainer = container;\n\n        return container;\n    },\n\n    /**\n     * Get container bound.\n     * @returns {ClientRect}\n     * @private\n     */\n    _getContainerBound: function() {\n        if (!this.containerBound) {\n            this.containerBound = this.customEventContainer.getBoundingClientRect();\n        }\n\n        return this.containerBound;\n    },\n\n    /**\n     * Calculate layer position by client position.\n     * @param {number} clientX - clientX\n     * @param {number} [clientY] - clientY\n     * @param {boolean} [checkLimit] - whether check limit or not\n     * @returns {{x: number, y: ?number}}\n     * @private\n     */\n    _calculateLayerPosition: function(clientX, clientY, checkLimit) {\n        var bound = this._getContainerBound();\n        var layerPosition = {};\n        var expandSize = this.expandSize;\n        var maxLeft, minLeft;\n\n        checkLimit = tui.util.isUndefined(checkLimit) ? true : checkLimit;\n\n        if (checkLimit) {\n            maxLeft = bound.right + expandSize;\n            minLeft = bound.left - expandSize;\n            clientX = Math.min(Math.max(clientX, minLeft), maxLeft);\n        }\n\n        layerPosition.x = clientX - bound.left;\n\n        if (!tui.util.isUndefined(clientY)) {\n            layerPosition.y = clientY - bound.top;\n        }\n\n        return layerPosition;\n    },\n\n    /**\n     * Create BoundsBaseCoordinateModel from seriesBounds for custom event.\n     * @param {Array.&lt;object>} seriesData - series data\n     */\n    onReceiveSeriesData: function(seriesData) {\n        var seriesDataSet = this.seriesDataSet;\n        var seriesCount = this.seriesCount;\n\n        if (seriesDataSet.length === seriesCount) {\n            seriesDataSet = [];\n        }\n\n        seriesDataSet.push(seriesData);\n\n        if (seriesDataSet.length === seriesCount) {\n            this.boundsBaseCoordinateModel = new BoundsBaseCoordinateModel(seriesDataSet);\n        }\n    },\n\n    /**\n     * Rerender for customEvent component.\n     * @param {object} data - bounds data and tick count\n     */\n    rerender: function(data) {\n        var tickCount;\n\n        if (data.axisDataMap.xAxis) {\n            tickCount = this._pickTickCount(data.axisDataMap);\n        }\n\n        this.selectedData = null;\n        this._setDataForRendering(data);\n        this._renderCustomEventArea(this.customEventContainer, tickCount);\n    },\n\n    /**\n     * Resize for customEvent component.\n     * @param {object} data - bounds data and tick count\n     */\n    resize: function(data) {\n        this.containerBound = null;\n        this.rerender(data);\n    },\n\n    /**\n     * Whether changed select data or not.\n     * @param {object} prev - previous data\n     * @param {object} cur - current data\n     * @returns {boolean}\n     * @private\n     */\n    _isChangedSelectData: function(prev, cur) {\n        return !prev || !cur || prev.chartType !== cur.chartType ||\n            prev.indexes.groupIndex !== cur.indexes.groupIndex || prev.indexes.index !== cur.indexes.index;\n    },\n\n    /**\n     * Find coordinate data from boundsCoordinateModel.\n     * @param {{x: number, y: number}} layerPosition - layer position\n     * @returns {object}\n     * @private\n     */\n    _findDataFromBoundsCoordinateModel: function(layerPosition) {\n        var layerX = layerPosition.x;\n        var layerY = layerPosition.y;\n        var groupIndex;\n\n        if (predicate.isTreemapChart(this.chartType)) {\n            groupIndex = 0;\n        } else {\n            layerY += chartConst.SERIES_EXPAND_SIZE;\n            groupIndex = this.tickBaseCoordinateModel.findIndex(this.isVertical ? layerX : layerY);\n            layerX += chartConst.SERIES_EXPAND_SIZE;\n        }\n\n        return this.boundsBaseCoordinateModel.findData(groupIndex, layerX, layerY);\n    },\n\n    /**\n     * Find data.\n     * @param {number} clientX - clientX\n     * @param {number} clientY - clientY\n     * @returns {object}\n     * @private\n     */\n    _findData: function(clientX, clientY) {\n        var layerPosition = this._calculateLayerPosition(clientX, clientY);\n\n        return this._findDataFromBoundsCoordinateModel(layerPosition);\n    },\n\n    /**\n     * Show tooltip\n     * @private\n     * @abstract\n     */\n    _showTooltip: function() {},\n\n    /**\n     * Animate for adding data.\n     */\n    animateForAddingData: function() {\n        var foundData, isMoving;\n\n        if (!this.prevClientPosition) {\n            return;\n        }\n\n        foundData = this._findData(this.prevClientPosition.x, this.prevClientPosition.y);\n\n        if (foundData) {\n            isMoving = this.prevFoundData &amp;&amp; (this.prevFoundData.indexes.groupIndex === foundData.indexes.groupIndex);\n            this._showTooltip(foundData, isMoving);\n        }\n\n        this.prevFoundData = foundData;\n    },\n\n    /**\n     * On mouse event.\n     * @param {string} eventType - custom event type\n     * @param {MouseEvent} e - mouse event\n     * @private\n     */\n    _onMouseEvent: function(eventType, e) {\n        dom.addClass(this.customEventContainer, 'hide');\n        this.eventBus.fire(eventType + 'Series', {\n            left: e.clientX,\n            top: e.clientY\n        });\n        dom.removeClass(this.customEventContainer, 'hide');\n    },\n\n    /**\n     * Unselect selected data.\n     * @private\n     */\n    _unselectSelectedData: function() {\n        this.eventBus.fire('unselectSeries', this.selectedData);\n        this.selectedData = null;\n    },\n\n    /**\n     * On click\n     * @param {MouseEvent} e - mouse event\n     * @private\n     */\n    _onClick: function(e) {\n        var foundData = this._findData(e.clientX, e.clientY);\n\n        if (!this._isChangedSelectData(this.selectedData, foundData)) {\n            this._unselectSelectedData();\n        } else if (foundData) {\n            if (this.selectedData) {\n                this._unselectSelectedData();\n            }\n\n            this.eventBus.fire('selectSeries', foundData);\n            if (this.allowSelect) {\n                this.selectedData = foundData;\n            }\n        }\n    },\n\n    /**\n     * On mouse down\n     * @private\n     * @abstract\n     */\n    _onMousedown: function() {},\n\n    /**\n     * On mouse up\n     * @private\n     * @abstract\n     */\n    _onMouseup: function() {},\n\n    /**\n     * On mouse move\n     * @param {MouseEvent} e - mouse event\n     * @private\n     */\n    _onMousemove: function(e) {\n        this.prevClientPosition = {\n            x: e.clientX,\n            y: e.clientY\n        };\n    },\n\n    /**\n     * On mouse out\n     * @private\n     */\n    _onMouseout: function() {\n        this.prevClientPosition = null;\n        this.prevFoundData = null;\n    },\n\n    /**\n     * Attach event\n     * @param {HTMLElement} target - target element\n     */\n    attachEvent: function(target) {\n        eventListener.on(target, {\n            click: this._onClick,\n            mousedown: this._onMousedown,\n            mouseup: this._onMouseup,\n            mousemove: this._onMousemove,\n            mouseout: this._onMouseout\n        }, this);\n    }\n});\n\ntui.util.CustomEvents.mixin(CustomEventBase);\n\nmodule.exports = CustomEventBase;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"