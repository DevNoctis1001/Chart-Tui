tui.util.defineNamespace("fedoc.content", {});
fedoc.content["models_scaleData_scaleDataMaker.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview scaleMaker calculates the limit and step into values of processed data and returns it.\n * @auth NHN Ent.\n *       FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../../const');\nvar predicate = require('../../helpers/predicate');\nvar calculator = require('../../helpers/calculator');\nvar renderUtil = require('../../helpers/renderUtil');\n\nvar abs = Math.abs;\n\n/**\n * scaleMaker calculates limit and step into values of processed data and returns it.\n * @module scaleDataMaker\n */\nvar scaleDataMaker = {\n    /**\n     * Get candidate counts of value.\n     * @memberOf module:axisDataMaker\n     * @param {number} baseSize - base size(width or not)\n     * @returns {Array.&lt;number>} value counts\n     * @private\n     */\n    _getCandidateCountsOfValue: function(baseSize) {\n        var minStart = 3;\n        var start = Math.max(minStart, parseInt(baseSize / chartConst.MAX_PIXEL_TYPE_STEP_SIZE, 10));\n        var end = Math.max(start, parseInt(baseSize / chartConst.MIN_PIXEL_TYPE_STEP_SIZE, 10)) + 1;\n\n        return tui.util.range(start, end);\n    },\n\n    /**\n     * Make limit for diverging option.\n     * @param {{min: number, max: number}} limit limit\n     * @returns {{min: number, max: number}} changed limit\n     * @private\n     */\n    _makeLimitForDivergingOption: function(limit) {\n        var newMax = Math.max(abs(limit.min), abs(limit.max));\n\n        return {\n            min: -newMax,\n            max: newMax\n        };\n    },\n\n    /**\n     * Make integer type scale.\n     * @memberOf module:axisDataMaker\n     * @param {{min: number, max: number}} limit - limit\n     * @param {?{min: ?number, max: ?number}} limitOption - limit option\n     * @returns {{\n     *      limit: {min: number, max: number},\n     *      options: {min: number, max: number},\n     *      divideNum: number\n     * }} integer type info\n     * @private\n     */\n    _makeIntegerTypeScale: function(limit, limitOption) {\n        var min = limit.min;\n        var max = limit.max;\n        var multipleNum, changedOptions;\n\n        limitOption = limitOption || {};\n\n        if (abs(min) >= 1 || abs(max) >= 1) {\n            return {\n                limit: limit,\n                limitOption: limitOption,\n                divisionNumber: 1\n            };\n        }\n\n        multipleNum = tui.util.findMultipleNum(min, max);\n        changedOptions = {};\n\n        if (!tui.util.isUndefined(limitOption.min)) {\n            changedOptions.min = limitOption.min * multipleNum;\n        }\n\n        if (!tui.util.isUndefined(limitOption.max)) {\n            changedOptions.max = limitOption.max * multipleNum;\n        }\n\n        return {\n            limit: {\n                min: min * multipleNum,\n                max: max * multipleNum\n            },\n            limitOption: changedOptions,\n            divisionNumber: multipleNum\n        };\n    },\n\n    /**\n     * Make limit if equal min and max.\n     * @param {{min: number, max: number}} limit limit\n     * @returns {{min: number, max: number}} changed limit\n     * @private\n     */\n    _makeLimitIfEqualMinMax: function(limit) {\n        var min = limit.min,\n            max = limit.max;\n\n        if (min > 0) {\n            min = 0;\n        } else if (min &lt; 0) {\n            max = 0;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    },\n\n    /**\n     * Make base limit\n     * @memberOf module:axisDataMaker\n     * @param {{min: number, max: number}} dataLimit user limit\n     * @param {{min: number, max: number}} limitOption axis options\n     * @returns {{min: number, max: number}} base limit\n     * @private\n     */\n    _makeBaseLimit: function(dataLimit, limitOption) {\n        var isMinusLimit = predicate.isMinusLimit(dataLimit);\n        var min = dataLimit.min;\n        var max = dataLimit.max;\n        var baseLimit, tmpMin;\n\n        if (min === max) {\n            baseLimit = this._makeLimitIfEqualMinMax(dataLimit);\n        } else {\n            if (isMinusLimit) {\n                tmpMin = min;\n                min = -max;\n                max = -tmpMin;\n            }\n\n            baseLimit = calculator.calculateLimit(min, max);\n\n            if (isMinusLimit) {\n                tmpMin = baseLimit.min;\n                baseLimit.min = -baseLimit.max;\n                baseLimit.max = -tmpMin;\n            }\n        }\n\n        baseLimit.min = tui.util.isUndefined(limitOption.min) ? baseLimit.min : limitOption.min;\n        baseLimit.max = tui.util.isUndefined(limitOption.max) ? baseLimit.max : limitOption.max;\n\n        return baseLimit;\n    },\n\n    /**\n     * Normalize min.\n     * @memberOf module:axisDataMaker\n     * @param {number} min original min\n     * @param {number} step scale step\n     * @returns {number} normalized min\n     * @private\n     */\n    _normalizeMin: function(min, step) {\n        var mod = tui.util.mod(min, step),\n            normalized;\n\n        if (mod === 0) {\n            normalized = min;\n        } else {\n            normalized = tui.util.subtract(min, (min >= 0 ? mod : step + mod));\n        }\n\n        return Math.round(normalized);\n    },\n\n    /**\n     * Make normalized max.\n     * @memberOf module:axisDataMaker\n     * @param {{min: number, max: number}} limit limit\n     * @param {number} step scale step\n     * @param {number} valueCount value count\n     * @returns {number} normalized max\n     * @private\n     */\n    _makeNormalizedMax: function(limit, step, valueCount) {\n        var minMaxDiff = tui.util.multiply(step, valueCount - 1);\n        var normalizedMax = tui.util.add(limit.min, minMaxDiff);\n        var maxDiff = limit.max - normalizedMax;\n        var modDiff, divideDiff;\n\n        // normalize된 max값이 원래의 max값 보다 작을 경우 step을 증가시켜 큰 값으로 만들기\n        if (maxDiff > 0) {\n            modDiff = maxDiff % step;\n            divideDiff = Math.floor(maxDiff / step);\n            normalizedMax += step * (modDiff > 0 ? divideDiff + 1 : divideDiff);\n        }\n\n        return normalizedMax;\n    },\n\n    /**\n     * Normalize limit.\n     * @param {{min: number, max: number}} limit base limit\n     * @param {number} step scale step\n     * @param {number} valueCount value count\n     * @returns {{min: number, max: number}} normalized limit\n     * @private\n     */\n    _normalizeLimit: function(limit, step, valueCount) {\n        limit.min = this._normalizeMin(limit.min, step);\n        limit.max = this._makeNormalizedMax(limit, step, valueCount);\n\n        return limit;\n    },\n\n    /**\n     * Decrease minimum value by step value,\n     *  when chart type is line or dataMin is minus, options is undefined, minimum values(min, dataMin) are same.\n     * @param {number} min - limit min\n     * @param {number} dataMin - minimum value\n     * @param {number} step - scale step\n     * @param {string} chartType - chart type\n     * @param {?number} optionMin - min option\n     * @param {boolean} isVertical - whether vertical or not\n     * @returns {number}\n     * @private\n     */\n    _decreaseMinByStep: function(min, dataMin, step, chartType, optionMin, isVertical) {\n        /*eslint max-params: [2, 6]*/\n        var isLineChart = predicate.isLineChart(chartType);\n        var isAreaChartXAxis = predicate.isAreaChart(chartType) &amp;&amp; !isVertical;\n        var isMinusDataMin = dataMin &lt; 0;\n        var isUndefinedMinOption = tui.util.isUndefined(optionMin);\n        var isSame = (min === dataMin);\n\n        if ((isLineChart || isAreaChartXAxis || isMinusDataMin) &amp;&amp; isUndefinedMinOption &amp;&amp; isSame) {\n            min -= step;\n        }\n\n        return min;\n    },\n\n    /**\n     * Increase maximum value by step value,\n     *  when chart type is line or dataMin is plus, options is undefined, maximum values(max, dataMax) are same.\n     * @param {number} max - limit max\n     * @param {number} dataMax - maximum value\n     * @param {number} step - scale step\n     * @param {string} chartType - chart type\n     * @param {?number} optionMax - max option\n     * @returns {number}\n     * @private\n     */\n    _increaseMaxByStep: function(max, dataMax, step, chartType, optionMax) {\n        var isLineChart = predicate.isLineChart(chartType);\n        var isPlusDataMax = dataMax > 0;\n        var isUndefinedMaxOption = tui.util.isUndefined(optionMax);\n        var isSame = (max === dataMax);\n\n        if ((isLineChart || isPlusDataMax) &amp;&amp; isUndefinedMaxOption &amp;&amp; isSame) {\n            max += step;\n        }\n\n        return max;\n    },\n\n    /**\n     * Divide scale step.\n     * @param {{min: number, max: number}} limit limit\n     * @param {number} step step\n     * @param {number} candidateValueCount candidate valueCount\n     * @returns {number} scale step\n     * @private\n     */\n    _divideScaleStep: function(limit, step, candidateValueCount) {\n        var isEvenStep = ((step % 2) === 0),\n            valueCount = calculator.makeLabelsFromLimit(limit, step).length,\n            twiceValueCount = (valueCount * 2) - 1,\n            diffOrg = abs(candidateValueCount - valueCount),\n            diffTwice = abs(candidateValueCount - twiceValueCount);\n\n        // step을 반으로 나누었을 때의 valueCount가 후보로 계산된 candidateValueCount와 인접하면 step을 반으로 나누어 반환합니다.\n        if (isEvenStep &amp;&amp; diffTwice &lt;= diffOrg) {\n            step = step / 2;\n        }\n\n        return step;\n    },\n\n    /**\n     * Minimize scale limit.\n     * @param {{min: number, max: number}} limit base limit\n     * @param {{min: number, max: number}} dataLimit limit of user data\n     * @param {number} step scale step\n     * @param {number} valueCount value count\n     * @param {{min: number, max:number}} options limit options of axis\n     * @returns {{min: number, max: number}} minimized limit\n     * @private\n     */\n    _minimizeScaleLimit: function(limit, dataLimit, step, valueCount, options) {\n        var min = limit.max,\n            max = limit.min,\n            comparisonMin = tui.util.isUndefined(options.min) ? dataLimit.min - 1 : options.min,\n            comparisonMax = tui.util.isUndefined(options.max) ? dataLimit.max + 1 : options.max;\n\n        tui.util.forEachArray(tui.util.range(1, valueCount), function(valueIndex) {\n            var changingStep = (step * valueIndex),\n                changedMin = max + changingStep,\n                changedMax = min - changingStep;\n\n            // limit이 dataLimit 범위를 넘어갈 것으로 예상되는 경우에 변경을 중단함\n            if (dataLimit.min &lt;= changedMin &amp;&amp; dataLimit.max >= changedMax) {\n                return false;\n            }\n\n            if (comparisonMin >= changedMin) {\n                limit.min = changedMin;\n            }\n\n            if (comparisonMax &lt;= changedMax) {\n                limit.max = changedMax;\n            }\n\n            return true;\n        });\n\n        return limit;\n    },\n\n    /**\n     * Adjust limit for bubble chart.\n     * @param {{min: number, max: number}} limit - limit\n     * @param {number} step - step;\n     * @param {object.&lt;string, object>} overflowItem - overflow Item map\n     * @private\n     */\n    _adjustLimitForBubbleChart: function(limit, step, overflowItem) {\n        if (overflowItem.minItem) {\n            limit.min -= step;\n        }\n\n        if (overflowItem.maxItem) {\n            limit.max += step;\n        }\n    },\n\n    /**\n     * Make candidate axis scale.\n     * @param {{\n     *      dataLimit: {min: number, max: number},\n     *      baseLimit: {min: number, max: number}\n     * }} limitMap - limit map\n     * @param {{\n     *      isVertical: boolean,\n     *      chartType: string,\n     *      overflowItem: ?object,\n     *      limitOption: ?{min: ?number, max: ?number}\n     * }} options - options\n     * @param {number} valueCount value count\n     * @returns {{\n     *      limit: {min: number, max: number},\n     *      step: number\n     * }} scale\n     * @private\n     */\n    _makeCandidateScale: function(limitMap, options, valueCount) {\n        var baseLimit = limitMap.baseLimit;\n        var dataLimit = limitMap.dataLimit;\n        var limitOption = options.limitOption;\n        var isVertical = options.isVertical;\n        var chartType = options.chartType;\n        var limit = tui.util.extend({}, baseLimit);\n        var step;\n\n        // 01. 기본 limit 정보로 step 얻기\n        step = calculator.calculateStepFromLimit(limit, valueCount);\n\n        // 02. step 정규화 시키기 (ex: 0.3 --> 0.5, 7 --> 10)\n        step = calculator.normalizeAxisNumber(step);\n\n        // 03. limit 정규화 시키기\n        limit = this._normalizeLimit(limit, step, valueCount);\n\n        // 04. line차트의 경우 사용자의 min값이 limit의 min값과 같을 경우, min값을 1 step 감소 시킴\n        limit.min = this._decreaseMinByStep(limit.min, dataLimit.min, step, chartType, limitOption.min, isVertical);\n\n        // 04. 사용자의 max값이 scale max와 같을 경우, max값을 1 step 증가 시킴\n        limit.max = this._increaseMaxByStep(limit.max, dataLimit.max, step, chartType, limitOption.max);\n\n        // 05. axis limit이 사용자 min, max와 거리가 멀 경우 조절\n        limit = this._minimizeScaleLimit(limit, dataLimit, step, valueCount, limitOption);\n\n        // 06. 조건에 따라 step값을 반으로 나눔\n        step = this._divideScaleStep(limit, step, valueCount);\n\n        if (options.overflowItem) {\n            this._adjustLimitForBubbleChart(limit, step, options.overflowItem);\n        }\n\n        return {\n            limit: limit,\n            step: step,\n            stepCount: abs(limit.max - limit.min) / step\n        };\n    },\n\n    /**\n     * Make candidates for axis scale.\n     * @param {{\n     *      limit: {min: number, max: number},\n     *      options: {min: number, max: number},\n     *      divisionNumber: number\n     * }} integerTypeScale - integer type axis scale\n     * @param {Array.&lt;number>} valueCounts - candidate counts of value\n     * @param {{\n     *      isVertical: boolean,\n     *      chartType: string,\n     *      overflowItem: ?object\n     * }} options - options\n     * @returns {Array.&lt;{limit:{min: number, max: number}, stpe: number}>}\n     * @private\n     */\n    _makeCandidateScales: function(integerTypeScale, valueCounts, options) {\n        var self = this;\n        var dataLimit = integerTypeScale.limit;\n        var limitOption = integerTypeScale.limitOption;\n        var limitMap = {\n            dataLimit: dataLimit,\n            baseLimit: this._makeBaseLimit(dataLimit, limitOption)\n        };\n\n        options.limitOption = limitOption;\n\n        return tui.util.map(valueCounts, function(valueCount) {\n            return self._makeCandidateScale(limitMap, options, valueCount);\n        });\n    },\n\n    /**\n     * Get comparing value for selecting axis scale.\n     * @param {{min: number, max: number}} baseLimit - limit\n     * @param {Array.&lt;number>} valueCounts - candidate counts of value\n     * @param {{limit: {min: number, max: number}, step: number}} candidateScale - scale\n     * @param {number} index - index\n     * @returns {number} comparing value\n     * @private\n     */\n    _getComparingValue: function(baseLimit, valueCounts, candidateScale, index) {\n        var diffMax = abs(candidateScale.limit.max - baseLimit.max);\n        var diffMin = abs(baseLimit.min - candidateScale.limit.min);\n        // 예상 label count와 차이가 많을 수록 후보 제외 가능성이 높음\n        var diffCount = Math.max(abs(valueCounts[index] - candidateScale.stepCount), 1);\n        // 소수점 이하 길이가 길 수록 후보에서 제외될 가능성이 높음\n        var weight = Math.pow(10, tui.util.getDecimalLength(candidateScale.step));\n\n        return (diffMax + diffMin) * diffCount * weight;\n    },\n\n    /**\n     * Select axis scale.\n     * @param {{min: number, max: number}} baseLimit limit\n     * @param {Array.&lt;{limit: {min: number, max: number}, step: number}>} candidates scale candidates\n     * @param {Array.&lt;number>} valueCounts - label counts\n     * @returns {{limit: {min: number, max: number}, step: number}} selected scale\n     * @private\n     */\n    _selectAxisScale: function(baseLimit, candidates, valueCounts) {\n        var getComparingValue = tui.util.bind(this._getComparingValue, this, baseLimit, valueCounts);\n        var axisScale = tui.util.min(candidates, getComparingValue);\n\n        return axisScale;\n    },\n\n    /**\n     * Restore number state of scale.\n     * @memberOf module:axisDataMaker\n     * @param {{limit: {min: number, max: number}, step: number}} scale scale\n     * @param {number} divisionNumber divide num\n     * @returns {{limit: {min: number, max: number}, step: number}} restored scale\n     * @private\n     */\n    _restoreNumberState: function(scale, divisionNumber) {\n        if (divisionNumber === 1) {\n            return scale;\n        }\n\n        scale.step = tui.util.divide(scale.step, divisionNumber);\n        scale.limit.min = tui.util.divide(scale.limit.min, divisionNumber);\n        scale.limit.max = tui.util.divide(scale.limit.max, divisionNumber);\n\n        return scale;\n    },\n\n    /**\n     * millisecond map\n     */\n    millisecondMap: {\n        year: 31536000000,\n        month: 2678400000,\n        date: 86400000,\n        hour: 3600000,\n        minute: 60000,\n        second: 1000\n    },\n\n    /**\n     * millisecond types\n     */\n    millisecondTypes: ['year', 'month', 'date', 'hour', 'minute', 'second'],\n\n    /**\n     * Find date type.\n     * @param {{min: number, max: number}} dataLimit - data limit\n     * @param {number} count - data count\n     * @returns {string}\n     * @private\n     */\n    _findDateType: function(dataLimit, count) {\n        var diff = dataLimit.max - dataLimit.min;\n        var millisecondTypes = this.millisecondTypes;\n        var millisecondMap = this.millisecondMap;\n        var lastTypeIndex = millisecondTypes.length - 1;\n        var foundType;\n\n        if (diff) {\n            tui.util.forEachArray(millisecondTypes, function(type, index) {\n                var millisecond = millisecondMap[type];\n                var dividedCount = Math.floor(diff / millisecond);\n                var foundIndex;\n\n                if (dividedCount) {\n                    foundIndex = index &lt; lastTypeIndex &amp;&amp; (dividedCount &lt; count) ? index + 1 : index;\n                    foundType = millisecondTypes[foundIndex];\n                }\n\n                return !tui.util.isExisty(foundIndex);\n            });\n        } else {\n            foundType = chartConst.DATE_TYPE_SECOND;\n        }\n\n        return foundType;\n    },\n\n    /**\n     * Make datetime information\n     * @param {{min: number, max: number}} dataLimit - data limit\n     * @param {number} count - data count\n     * @returns {{divisionNumber: number, minDate: number, dataLimit: {min: number, max: number}}}\n     * @private\n     */\n    _makeDatetimeInfo: function(dataLimit, count) {\n        var dateType = this._findDateType(dataLimit, count);\n        var divisionNumber = this.millisecondMap[dateType];\n        var minDate = tui.util.divide(dataLimit.min, divisionNumber);\n        var maxDate = tui.util.divide(dataLimit.max, divisionNumber);\n        var max = maxDate - minDate;\n\n        return {\n            divisionNumber: divisionNumber,\n            minDate: minDate,\n            dataLimit: {\n                min: 0,\n                max: max\n            }\n        };\n    },\n\n    /**\n     * Restore scale to datetime type.\n     * @param {{scale: number, limit:{min: number, max: number}}} scale - scale\n     * @param {number} minDate - minimum date\n     * @param {number} divisionNumber - division number\n     * @returns {{step: number, limit: {min: number, max: number}}}\n     * @private\n     */\n    _restoreScaleToDatetimeType: function(scale, minDate, divisionNumber) {\n        var limit = scale.limit;\n\n        scale.step = tui.util.multiply(scale.step, divisionNumber);\n        limit.min = tui.util.multiply(tui.util.add(limit.min, minDate), divisionNumber);\n        limit.max = tui.util.multiply(tui.util.add(limit.max, minDate), divisionNumber);\n\n        return scale;\n    },\n\n    /**\n     * Calculate scale.\n     * @param {Array.&lt;number>} baseValues - base values for calculating scale data\n     * @param {number} baseSize - base size(width or height) for calculating scale data\n     * @param {string} chartType - chart type\n     * @param {{\n     *      type: string,\n     *      tickCounts: ?Array.&lt;number>,\n     *      limitOption: ?{min: ?number, max: ?number},\n     *      diverging: boolean,\n     *      isVertical: boolean,\n     *      overflowItem: ?object\n     * }} options - options\n     * @returns {{limit: {min: number, max: number}, step: number}}\n     * @private\n     */\n    _calculateScale: function(baseValues, baseSize, chartType, options) {\n        var dataLimit = {\n            min: tui.util.min(baseValues),\n            max: tui.util.max(baseValues)\n        };\n        var datetimeInfo, integerTypeScale, tickCounts, candidates, scale;\n\n        if (predicate.isDatetimeType(options.type)) {\n            datetimeInfo = this._makeDatetimeInfo(dataLimit, baseValues.length);\n            dataLimit = datetimeInfo.dataLimit;\n        }\n\n        if (dataLimit.min === 0 &amp;&amp; dataLimit.max === 0) {\n            dataLimit.max = 5;\n        }\n\n        if (predicate.isDivergingChart(chartType, options.diverging)) {\n            dataLimit = this._makeLimitForDivergingOption(dataLimit);\n        }\n\n        // 01. limit, options 정보를 정수형으로 변경\n        integerTypeScale = this._makeIntegerTypeScale(dataLimit, options.limitOption);\n\n        // 02. value count 후보군 얻기\n        tickCounts = options.tickCounts || this._getCandidateCountsOfValue(baseSize);\n\n        // 03. axis scale 후보군 얻기\n        candidates = this._makeCandidateScales(integerTypeScale, tickCounts, {\n            chartType: chartType,\n            isVertical: options.isVertical,\n            overflowItem: options.overflowItem\n        });\n\n        // 04. axis scale 후보군 중 하나 선택\n        scale = this._selectAxisScale(integerTypeScale.limit, candidates, tickCounts);\n\n        // 05. 정수형으로 변경했던 scale을 원래 형태로 변경\n        scale = this._restoreNumberState(scale, integerTypeScale.divisionNumber);\n\n        if (predicate.isDatetimeType(options.type)) {\n            scale = this._restoreScaleToDatetimeType(scale, datetimeInfo.minDate, datetimeInfo.divisionNumber);\n        }\n\n        return scale;\n    },\n\n    /**\n     * Get percent stackType scale.\n     * @param {Array.&lt;number>} baseValues - base values\n     * @param {string} chartType - chart type\n     * @param {boolean} diverging - diverging option\n     * @returns {{limit: {min:number, max:number}, step: number}}\n     * @private\n     */\n    _getPercentStackedScale: function(baseValues, chartType, diverging) {\n        var scale;\n\n        if (calculator.sumMinusValues(baseValues) === 0) {\n            scale = chartConst.PERCENT_STACKED_AXIS_SCALE;\n        } else if (calculator.sumPlusValues(baseValues) === 0) {\n            scale = chartConst.MINUS_PERCENT_STACKED_AXIS_SCALE;\n        } else if (predicate.isDivergingChart(chartType, diverging)) {\n            scale = chartConst.DIVERGING_PERCENT_STACKED_AXIS_SCALE;\n        } else {\n            scale = chartConst.DUAL_PERCENT_STACKED_AXIS_SCALE;\n        }\n\n        return scale;\n    },\n\n    /**\n     * Make scale data.\n     * @param {Array.&lt;number>} baseValues - base values for calculating scale data\n     * @param {number} baseSize - base size(width or height) for calculating scale data\n     * @param {string} chartType - chart type\n     * @param {{\n     *      type: string,\n     *      stackType: string,\n     *      diverging: boolean,\n     *      isVertical: boolean,\n     *      limitOption: ?{min: ?number, max: ?number},\n     *      tickCounts: ?Array.&lt;number>\n     * }} options - options\n     * @returns {{limit: {min:number, max:number}, step: number}}\n     */\n    makeScaleData: function(baseValues, baseSize, chartType, options) {\n        var scaleData;\n\n        if (predicate.isPercentStackChart(chartType, options.stackType)) {\n            scaleData = this._getPercentStackedScale(baseValues, chartType, options.diverging);\n        } else {\n            scaleData = this._calculateScale(baseValues, baseSize, chartType, options);\n        }\n\n        return scaleData;\n    },\n\n    /**\n     * Get functions for formatting value.\n     * @param {string} chartType - chart type\n     * @param {string} stackType - stack type\n     * @param {?Array.&lt;function>} formatFunctions - format functions\n     * @returns {Array.&lt;function>}\n     * @private\n     */\n    _getFormatFunctions: function(chartType, stackType, formatFunctions) {\n        if (predicate.isPercentStackChart(chartType, stackType)) {\n            formatFunctions = [function(value) {\n                return value + '%';\n            }];\n        }\n\n        return formatFunctions;\n    },\n\n    /**\n     * Create scale values.\n     * @param {{limit: {min: number, max: number}, step: number}} scaleData - scale data\n     * @param {string} chartType - chart type\n     * @param {boolean} diverging - diverging option\n     * @returns {Array.&lt;number>}\n     * @private\n     */\n    _createScaleValues: function(scaleData, chartType, diverging) {\n        var values = calculator.makeLabelsFromLimit(scaleData.limit, scaleData.step);\n\n        return predicate.isDivergingChart(chartType, diverging) ? tui.util.map(values, abs) : values;\n    },\n\n    /**\n     * Create formatted scale values.\n     * @param {{limit: {min: number, max: number}, step: number}} scaleData - scale data\n     * @param {{\n     *      chartType: string,\n     *      areaType: string,\n     *      valueType: string\n     * }} typeMap - type map\n     * @param {{\n     *      type: string,\n     *      stackType: string,\n     *      diverging: boolean,\n     *      dateFormat: ?string\n     * }} options - options\n     * @param {?Array.&lt;function>} formatFunctions - format functions\n     * @returns {Array.&lt;string|number>|*}\n     */\n    createFormattedLabels: function(scaleData, typeMap, options, formatFunctions) {\n        var chartType = typeMap.chartType;\n        var areaType = typeMap.areaType;\n        var valueType = typeMap.valueType;\n        var values = this._createScaleValues(scaleData, chartType, options.diverging);\n        var formattedValues;\n\n        if (predicate.isDatetimeType(options.type)) {\n            formattedValues = renderUtil.formatDates(values, options.dateFormat);\n        } else {\n            formatFunctions = this._getFormatFunctions(chartType, options.stackType, formatFunctions);\n            formattedValues = renderUtil.formatValues(values, formatFunctions, chartType, areaType, valueType);\n        }\n\n        return formattedValues;\n    }\n};\n\nmodule.exports = scaleDataMaker;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"