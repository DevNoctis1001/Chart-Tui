tui.util.defineNamespace("fedoc.content", {});
fedoc.content["charts_mapChartMapModel.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview MapChartMapModel is map model of map chart.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const');\n\nvar MapChartMapModel = tui.util.defineClass(/** @lends MapChartMapModel.prototype */ {\n    /**\n     * MapChartMapModel is map model of map chart.\n     * @constructs MapChartMapModel\n     * @param {MapChartDataProcessor} dataProcessor Map chart data processor\n     * @param {Array.&lt;{name: string, path: string, labelCoordinate: ?{x: number, y:number}}>} rawMapData raw map data\n     */\n    init: function(dataProcessor, rawMapData) {\n        /**\n         * Command function map.\n         * @type {{\n         *      M: MapChartMapModel._makeCoordinate, m: MapChartMapModel._makeCoordinateFromRelativeCoordinate,\n         *      L: MapChartMapModel._makeCoordinate, l: MapChartMapModel._makeCoordinateFromRelativeCoordinate,\n         *      H: MapChartMapModel._makeXCoordinate, h: MapChartMapModel._makeXCoordinateFroRelativeCoordinate,\n         *      V: MapChartMapModel._makeYCoordinate, v: MapChartMapModel._makeYCoordinateFromRelativeCoordinate\n         * }}\n         */\n        this.commandFuncMap = {\n            M: tui.util.bind(this._makeCoordinate, this),\n            m: tui.util.bind(this._makeCoordinateFromRelativeCoordinate, this),\n            L: tui.util.bind(this._makeCoordinate, this),\n            l: tui.util.bind(this._makeCoordinateFromRelativeCoordinate, this),\n            H: tui.util.bind(this._makeXCoordinate, this),\n            h: tui.util.bind(this._makeXCoordinateFroRelativeCoordinate, this),\n            V: tui.util.bind(this._makeYCoordinate, this),\n            v: tui.util.bind(this._makeYCoordinateFromRelativeCoordinate, this)\n        };\n\n        /**\n         * Ignore command map.\n         * @type {{Z: boolean, z: boolean}}\n         */\n        this.ignoreCommandMap = {\n            Z: true,\n            z: true\n        };\n\n        /**\n         * Map data.\n         * @type {Array}\n         */\n        this.mapData = [];\n\n        /**\n         * Map dimension\n         * @type {{width: number, height: number}}\n         */\n        this.mapDimension = null;\n\n        /**\n         * Map chart data processor.\n         * @type {MapChartDataProcessor}\n         */\n        this.dataProcessor = dataProcessor;\n\n        this._createMapData(rawMapData);\n    },\n\n    /**\n     * Split coordinate string.\n     * @param {string} coordinateStr coordinate string\n     * @returns {{x: number, y: number}} coordinate map\n     * @private\n     */\n    _splitCoordinate: function(coordinateStr) {\n        var coordinates = coordinateStr.split(','),\n            result = {\n                x: parseFloat(coordinates[0])\n            };\n\n        if (coordinates[1]) {\n            result.y = parseFloat(coordinates[1]);\n        }\n\n        return result;\n    },\n\n    /**\n     * Make coordinate\n     * @param {string} coordinateStr coordinate\n     * @returns {{x: number, y: number}} coordinate\n     * @private\n     */\n    _makeCoordinate: function(coordinateStr) {\n        return this._splitCoordinate(coordinateStr);\n    },\n\n    /**\n     * Make coordinate from relative coordinate.\n     * @param {string} coordinateStr coordinate\n     * @param {{x: number, y: number}} prevCoordinate previous coordinate\n     * @returns {{x: number, y: number}} coordinate\n     * @private\n     */\n    _makeCoordinateFromRelativeCoordinate: function(coordinateStr, prevCoordinate) {\n        var coordinate = this._splitCoordinate(coordinateStr);\n\n        return {\n            x: coordinate.x + prevCoordinate.x,\n            y: coordinate.y + prevCoordinate.y\n        };\n    },\n\n    /**\n     * Make x coordinate.\n     * @param {string} coordinateStr coordinate\n     * @returns {{x: number}} x coordinate\n     * @private\n     */\n    _makeXCoordinate: function(coordinateStr) {\n        var coordinate = this._splitCoordinate(coordinateStr);\n\n        return {\n            x: coordinate.x\n        };\n    },\n\n    /**\n     * Make x coordinate from relative coordinate.\n     * @param {string} coordinateStr coordinate\n     * @param {{x: number, y: number}} prevCoordinate previous coordinate\n     * @returns {{x: number}} x coordinate\n     * @private\n     */\n    _makeXCoordinateFroRelativeCoordinate: function(coordinateStr, prevCoordinate) {\n        var coordinate = this._splitCoordinate(coordinateStr);\n\n        return {\n            x: coordinate.x + prevCoordinate.x\n        };\n    },\n\n    /**\n     * Make y coordinate.\n     * @param {string} coordinateStr coordinate\n     * @returns {{y: number}} y coordinate\n     * @private\n     */\n    _makeYCoordinate: function(coordinateStr) {\n        var coordinate = this._splitCoordinate(coordinateStr);\n\n        return {\n            y: coordinate.x\n        };\n    },\n\n    /**\n     * Make y coordinate from relative coordinate.\n     * @param {string} coordinateStr coordinate\n     * @param {{x: number, y: number}} prevCoordinate previous coordinate\n     * @returns {{y: number}} y coordinate\n     * @private\n     */\n    _makeYCoordinateFromRelativeCoordinate: function(coordinateStr, prevCoordinate) {\n        var coordinate = this._splitCoordinate(coordinateStr);\n\n        return {\n            y: coordinate.x + prevCoordinate.y\n        };\n    },\n\n    /**\n     * Split path.\n     * @param {string} path path\n     * @returns {Array.&lt;{type: string, coordinate: string}>} splitted path data\n     * @private\n     */\n    _splitPath: function(path) {\n        var i = 0,\n            len = path.length,\n            pathData = [],\n            coordinate = '',\n            chr, commandType;\n\n        for (; i &lt; len; i += 1) {\n            chr = path.charAt(i);\n            if (this.commandFuncMap[chr]) {\n                if (commandType &amp;&amp; coordinate) {\n                    pathData.push({\n                        type: commandType,\n                        coordinate: coordinate\n                    });\n                }\n                commandType = chr;\n                coordinate = '';\n            } else if (!this.ignoreCommandMap[chr]) {\n                coordinate += chr;\n            }\n        }\n\n        if (commandType &amp;&amp; coordinate) {\n            pathData.push({\n                type: commandType,\n                coordinate: coordinate\n            });\n        }\n\n        return pathData;\n    },\n\n    /**\n     * Make coordinates from path.\n     * @param {string} path path\n     * @returns {Array.&lt;{x: number, y: number}>} coordinates\n     * @private\n     */\n    _makeCoordinatesFromPath: function(path) {\n        var pathData = this._splitPath(path),\n            prevCoordinate = {\n                x: 0,\n                y: 0\n            };\n\n        return tui.util.map(pathData, function(datum) {\n            var commandFunc = this.commandFuncMap[datum.type],\n                coordinate = commandFunc(datum.coordinate, prevCoordinate);\n\n            tui.util.extend(prevCoordinate, coordinate);\n\n            return coordinate;\n        }, this);\n    },\n\n    /**\n     * Find bound from coordinates.\n     * @param {Array.&lt;{left: number, top: number}>} coordinates coordinates\n     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} bound\n     * @private\n     */\n    _findBoundFromCoordinates: function(coordinates) {\n        var xs = tui.util.filter(tui.util.pluck(coordinates, 'x'), function(x) {\n                return !tui.util.isUndefined(x);\n            }),\n            ys = tui.util.filter(tui.util.pluck(coordinates, 'y'), function(y) {\n                return !tui.util.isUndefined(y);\n            }),\n            maxLeft = Math.max.apply(null, xs),\n            minLeft = Math.min.apply(null, xs),\n            maxTop = Math.max.apply(null, ys),\n            minTop = Math.min.apply(null, ys);\n\n        return {\n            dimension: {\n                width: maxLeft - minLeft,\n                height: maxTop - minTop\n            },\n            position: {\n                left: minLeft,\n                top: minTop\n            }\n        };\n    },\n\n    /**\n     * Make label position.\n     * @param {{dimension: {width: number, height: number}, position: {top: number, left: number}}} bound bound\n     * @param {?{left: number, top: number}} positionRatio position ratio\n     * @returns {{left: number, top: number}} label position\n     * @private\n     */\n    _makeLabelPosition: function(bound, positionRatio) {\n        positionRatio = positionRatio || chartConst.MAP_CHART_LABEL_DEFAULT_POSITION_RATIO;\n\n        return {\n            left: bound.position.left + (bound.dimension.width * positionRatio.x),\n            top: bound.position.top + (bound.dimension.height * positionRatio.y)\n        };\n    },\n\n    /**\n     * Create map data.\n     * @param {Array.&lt;{name: string, path: string, labelCoordinate: ?{x: number, y:number}}>} rawMapData raw map data\n     * @private\n     */\n    _createMapData: function(rawMapData) {\n        this.mapData = tui.util.map(rawMapData, function(datum) {\n            var coordinate = this._makeCoordinatesFromPath(datum.path),\n                bound = this._findBoundFromCoordinates(coordinate),\n                userData = this.dataProcessor.getValueMapDatum(datum.code),\n                name, labelCoordinate, formattedValue, percentValue, resultData;\n\n            if (userData) {\n                formattedValue = userData.formattedValue;\n                percentValue = userData.percentValue;\n                name = userData.name || datum.name;\n                labelCoordinate = userData.labelCoordinate || datum.labelCoordinate;\n            }\n\n            resultData = {\n                code: datum.code,\n                name: name,\n                path: datum.path,\n                bound: bound,\n                labelPosition: this._makeLabelPosition(bound, labelCoordinate)\n            };\n\n            if (formattedValue) {\n                resultData.formattedValue = formattedValue;\n            }\n\n            if (percentValue) {\n                resultData.percentValue = percentValue;\n            }\n\n            return resultData;\n        }, this);\n    },\n\n    getMapData: function() {\n        return this.mapData;\n    },\n\n    getDatum: function(index) {\n        return this.mapData[index];\n    },\n\n    /**\n     * Get label data.\n     * @param {number} ratio ratio\n     * @returns {Array.&lt;{name: string, bound: {dimension: {width: number, height: number}, position: {top: number, left: number}}, labelPosition: {width: number, height: number}}>} map data\n     */\n    getLabelData: function(ratio) {\n        var labelData = tui.util.filter(this.mapData, function(datum) {\n                return this.dataProcessor.getValueMapDatum(datum.code);\n            }, this);\n\n        return tui.util.map(labelData, function(datum) {\n            return {\n                name: datum.name,\n                labelPosition: {\n                    left: datum.labelPosition.left * ratio,\n                    top: datum.labelPosition.top * ratio\n                }\n            };\n        });\n    },\n\n    /**\n     * Make map dimension\n     * @returns {{width: number, height: number}} map dimension\n     * @private\n     */\n    _makeMapDimension: function() {\n        var mapData = this.mapData,\n            lefts = tui.util.map(mapData, function(datum) {\n                return datum.bound.position.left;\n            }),\n            rights = tui.util.map(mapData, function(datum) {\n                return datum.bound.position.left + datum.bound.dimension.width;\n            }),\n            tops = tui.util.map(mapData, function(datum) {\n                return datum.bound.position.top;\n            }),\n            bottoms = tui.util.map(mapData, function(datum) {\n                return datum.bound.position.top + datum.bound.dimension.height;\n            });\n        return {\n            width: Math.max.apply(null, rights) - Math.min.apply(null, lefts),\n            height: Math.max.apply(null, bottoms) - Math.min.apply(null, tops)\n        };\n    },\n\n    /**\n     * Get map dimension.\n     * @returns {{width: number, height: number}} map dimension\n     */\n    getMapDimension: function() {\n        if (!this.mapDimension) {\n            this.mapDimension = this._makeMapDimension();\n        }\n\n        return this.mapDimension;\n    }\n});\n\nmodule.exports = MapChartMapModel;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"