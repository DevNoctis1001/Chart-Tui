ne.util.defineNamespace("fedoc.content", {});
fedoc.content["customEvents_pointTypeDataModel.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview PointTypeDataModel is data mode for point type custom event.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const'),\n    predicate = require('../helpers/predicate');\n\nvar PointTypeDataModel = tui.util.defineClass(/** @lends PointTypeDataModel.prototype */ {\n    /**\n     * PointTypeDataModel is data mode for point type custom event.\n     * @constructs PointTypeDataModel\n     * @param {array.&lt;object>} seriesInfos series infos\n     */\n    init: function(seriesInfos) {\n        this.data = this._makeData(seriesInfos);\n    },\n\n    /**\n     * To make coordinate data about bar type graph\n     * @param {array.&lt;array.&lt;object>>} groupBounds group bounds\n     * @param {string} chartType chart type\n     * @returns {array} coordinate data\n     * @private\n     */\n    _makeRectTypeCoordinateData: function(groupBounds, chartType) {\n        return tui.util.map(groupBounds, function(bounds, groupIndex) {\n            return tui.util.map(bounds, function(_bound, index) {\n                var bound;\n                if (!_bound) {\n                    return null;\n                }\n\n                bound = _bound.end;\n\n                return {\n                    sendData: {\n                        chartType: chartType,\n                        indexes: {\n                            groupIndex: groupIndex,\n                            index: index\n                        },\n                        allowNegativeTooltip: true,\n                        bound: bound\n                    },\n                    bound: {\n                        left: bound.left,\n                        top: bound.top,\n                        right: bound.left + bound.width,\n                        bottom: bound.top + bound.height\n                    }\n                };\n            });\n        });\n    },\n\n    /**\n     * To make coordinate data about dot type graph\n     * @param {array.&lt;array.&lt;object>>} groupPositions group positions\n     * @param {string} chartType chart type\n     * @returns {array} coordinate data\n     * @private\n     */\n    _makeDotTypeCoordinateData: function(groupPositions, chartType) {\n        return tui.util.map(tui.util.pivot(groupPositions), function(positions, groupIndex) {\n            return tui.util.map(positions, function(position, index) {\n                return {\n                    sendData: {\n                        chartType: chartType,\n                        indexes: {\n                            groupIndex: groupIndex,\n                            index: index\n                        },\n                        bound: position\n                    },\n                    bound: {\n                        left: position.left - chartConst.DOT_RADIUS,\n                        top: position.top - chartConst.DOT_RADIUS,\n                        right: position.left + chartConst.DOT_RADIUS,\n                        bottom: position.top + chartConst.DOT_RADIUS\n                    }\n                };\n            });\n        });\n    },\n\n    /**\n     * To join data.\n     * @param {array.&lt;array.&lt;array.&lt;object>>>} groupData group data\n     * @returns {array.&lt;array.&lt;object>>} joined data\n     * @private\n     */\n    _joinData: function(groupData) {\n        var results = [];\n        tui.util.forEachArray(groupData, function(coordData) {\n            tui.util.forEachArray(coordData, function(data, index) {\n                if (!results[index]) {\n                    results[index] = [];\n                }\n                results[index] = results[index].concat(data);\n            });\n        });\n\n        return results;\n    },\n\n    /**\n     * To make coordinate data.\n     * @param {array.&lt;object>} seriesInfos series infos\n     * @returns {array.&lt;array.&lt;object>>} coordinate data\n     * @private\n     */\n    _makeData: function(seriesInfos) {\n        var coordinateData;\n        seriesInfos.reverse();\n        coordinateData = tui.util.map(seriesInfos, function(info) {\n            var result;\n            if (predicate.isLineTypeChart(info.chartType)) {\n                result = this._makeDotTypeCoordinateData(info.data.groupPositions, info.chartType);\n            } else {\n                result = this._makeRectTypeCoordinateData(info.data.groupBounds, info.chartType);\n            }\n            return result;\n        }, this);\n        return this._joinData(coordinateData);\n    },\n\n    /**\n     * Find tooltip data.\n     * @param {number} groupIndex group index\n     * @param {number} layerX mouse position x\n     * @param {number} layerY mouse position y\n     * @returns {object} tooltip data\n     */\n    findData: function(groupIndex, layerX, layerY) {\n        var min = 10000,\n            result = null,\n            candidates;\n\n        if (groupIndex === -1) {\n            return result;\n        }\n\n        // layerX, layerY를 포함하는 data 추출\n        candidates = tui.util.filter(this.data[groupIndex], function(data) {\n            var bound = data &amp;&amp; data.bound;\n            return bound &amp;&amp; bound.left &lt;= layerX &amp;&amp; bound.right >= layerX &amp;&amp; bound.top &lt;= layerY &amp;&amp; bound.bottom >= layerY;\n        });\n\n        // 추출된 data 중 top이 layerY와 가장 가까운 data 찾아내기\n        tui.util.forEachArray(candidates, function(data) {\n            var diff = Math.abs(layerY - data.sendData.bound.top);\n            if (min > diff) {\n                min = diff;\n                result = data.sendData;\n            }\n        });\n\n        return result;\n    }\n});\n\nmodule.exports = PointTypeDataModel;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"