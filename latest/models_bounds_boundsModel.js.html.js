tui.util.defineNamespace("fedoc.content", {});
fedoc.content["models_bounds_boundsModel.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Bounds model.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../../const');\nvar predicate = require('../../helpers/predicate');\nvar renderUtil = require('../../helpers/renderUtil');\nvar circleLegendCalculator = require('./circleLegendCalculator');\nvar axisCalculator = require('./axisCalculator');\nvar legendCalculator = require('./legendCalculator');\nvar seriesCalculator = require('./seriesCalculator');\nvar spectrumLegendCalculator = require('./spectrumLegendCalculator');\n\n/**\n * Dimension.\n * @typedef {{width: number, height:number}} dimension\n */\n\n/**\n * Position.\n * @typedef {{left: number, top:number}} position\n */\n\n/**\n * Bound.\n * @typedef {{dimension: dimension, position:position}} bound\n */\n\nvar BoundsModel = tui.util.defineClass(/** @lends BoundsModel.prototype */{\n    /**\n     * Bounds maker.\n     * @constructs BoundsModel\n     * @param {object} params parameters\n     */\n    init: function(params) {\n        /**\n         * options\n         * @type {object}\n         */\n        this.options = params.options || {};\n        this.options.legend = this.options.legend || {};\n        this.options.yAxis = this.options.yAxis || {};\n\n        /**\n         * theme\n         * @type {object}\n         */\n        this.theme = params.theme || {};\n\n        /**\n         * whether chart has axes or not\n         * @type {boolean}\n         */\n        this.hasAxes = params.hasAxes;\n\n        /**\n         * chart type\n         * @type {string}\n         */\n        this.chartType = params.chartType;\n\n        /**\n         * series names\n         */\n        this.seriesNames = params.seriesNames || [];\n\n        /**\n         * data processor\n         * @type {DataProcessor}\n         */\n        this.dataProcessor = params.dataProcessor;\n\n        this.initBoundsData();\n    },\n\n    /**\n     * Initialize bounds data.\n     */\n    initBoundsData: function() {\n        this.dimensionMap = {\n            legend: {\n                width: 0\n            },\n            yAxis: {\n                width: 0\n            },\n            rightYAxis: {\n                width: 0\n            },\n            xAxis: {\n                height: 0\n            },\n            circleLegend: {\n                width: 0\n            }\n        };\n\n        this.positionMap = {};\n\n        /**\n         * chart left padding\n         * @type {number}\n         */\n        this.chartLeftPadding = chartConst.CHART_PADDING;\n\n        this.maxRadiusForBubbleChart = null;\n\n        this._registerChartDimension();\n        this._registerTitleDimension();\n    },\n\n    /**\n     * Register dimension.\n     * @param {string} name component name\n     * @param {dimension} dimension component dimension\n     * @private\n     */\n    _registerDimension: function(name, dimension) {\n        this.dimensionMap[name] = tui.util.extend(this.dimensionMap[name] || {}, dimension);\n    },\n\n    /**\n     * Get bound.\n     * @param {string} name component name\n     * @returns {bound} component bound\n     */\n    getBound: function(name) {\n        return {\n            dimension: this.dimensionMap[name] || {},\n            position: this.positionMap[name] || {}\n        };\n    },\n\n    /**\n     * Set bound.\n     * @param {string} name component name\n     * @param {bound} bound component bound\n     * @private\n     */\n    _setBound: function(name, bound) {\n        this.dimensionMap[name] = bound.dimension;\n        this.positionMap[name] = bound.position;\n    },\n\n    /**\n     * Get dimension.\n     * @param {string} name component name\n     * @returns {dimension} component dimension\n     */\n    getDimension: function(name) {\n        return this.dimensionMap[name];\n    },\n\n    /**\n     * Get dimension map.\n     * @param {string} types - dimension type names\n     * @returns {object}\n     */\n    getDimensionMap: function(types) {\n        var self = this;\n        var dimensionMap = {};\n\n        if (types &amp;&amp; types.length) {\n            tui.util.forEachArray(types, function(type) {\n                dimensionMap[type] = self.dimensionMap[type];\n            });\n        } else {\n            dimensionMap = this.dimensionMap;\n        }\n\n        return JSON.parse(JSON.stringify((dimensionMap)));\n    },\n\n    /**\n     * Get position.\n     * @param {string} name component name\n     * @returns {position} component position\n     */\n    getPosition: function(name) {\n        return this.positionMap[name];\n    },\n\n    /**\n     * Register chart dimension\n     * @private\n     */\n    _registerChartDimension: function() {\n        var chartOptions = this.options.chart || {},\n            dimension = {\n                width: chartOptions.width || chartConst.CHART_DEFAULT_WIDTH,\n                height: chartOptions.height || chartConst.CHART_DEFAULT_HEIGHT\n            };\n\n        this._registerDimension('chart', dimension);\n    },\n\n    /**\n     * Register title dimension\n     * @private\n     */\n    _registerTitleDimension: function() {\n        var chartOptions = this.options.chart || {},\n            titleHeight = renderUtil.getRenderedLabelHeight(chartOptions.title, this.theme.title),\n            dimension = {\n                height: titleHeight + chartConst.TITLE_PADDING\n            };\n\n        this._registerDimension('title', dimension);\n    },\n\n    /**\n     * Register height for x axis component.\n     */\n    registerXAxisHeight: function() {\n        this._registerDimension('xAxis', {\n            height: axisCalculator.calculateXAxisHeight(this.options.xAxis.title, this.theme.xAxis)\n        });\n    },\n\n    /**\n     * Register dimension for legend component.\n     */\n    registerLegendDimension: function() {\n        var legendLabels = tui.util.pluck(this.dataProcessor.getOriginalLegendData(), 'label');\n        var legendOptions = this.options.legend;\n        var labelTheme = this.theme.legend.label;\n        var chartWidth = this.getDimension('chart').width;\n        var legendDimension = legendCalculator.calculate(legendOptions, labelTheme, legendLabels, chartWidth);\n\n        this._registerDimension('legend', legendDimension);\n    },\n\n    /**\n     * Update dimension for SpectrumLegend.\n     */\n    updateDimensionForSpectrumLegend: function() {\n        var maxValue = this.dataProcessor.getFormattedMaxValue(this.chartType, 'legend');\n        var labelTheme = this.theme.label;\n        var dimension;\n\n        if (predicate.isHorizontalLegend(this.options.legend.align)) {\n            dimension = spectrumLegendCalculator._makeHorizontalDimension(maxValue, labelTheme);\n        } else {\n            dimension = spectrumLegendCalculator._makeVerticalDimension(maxValue, labelTheme);\n        }\n\n        this._registerDimension('legend', dimension);\n    },\n\n    /**\n     * Register dimension for y axis.\n     * @param {{min: number, max: number}} limit - min, max\n     * @param {string} componentName - component name like yAxis, rightYAxis\n     * @param {object} options - options for y axis\n     * @param {{title: object, label: object}} theme - them for y axis\n     * @param {boolean} isVertical - whether vertical or not\n     */\n    registerYAxisDimension: function(limit, componentName, options, theme, isVertical) {\n        var categories;\n\n        if (limit) {\n            categories = [limit.min, limit.max];\n        } else if (predicate.isHeatmapChart(this.chartType) || !isVertical) {\n            categories = this.dataProcessor.getCategories(true);\n        } else {\n            return;\n        }\n\n        this._registerDimension(componentName, {\n            width: axisCalculator.calculateYAxisWidth(categories, options, theme)\n        });\n    },\n\n    /**\n     * Create series width.\n     * @returns {number} series width\n     */\n    calculateSeriesWidth: function() {\n        var dimensionMap = this.getDimensionMap(['chart', 'yAxis', 'legend', 'rightYAxis']);\n\n        return seriesCalculator.calculateWidth(dimensionMap, this.options.legend);\n    },\n\n    /**\n     * Create series height\n     * @returns {number} series height\n     */\n    calculateSeriesHeight: function() {\n        var dimensionMap = this.getDimensionMap(['chart', 'title', 'legend', 'xAxis']);\n\n        return seriesCalculator.calculateHeight(dimensionMap, this.options.legend);\n    },\n\n    getBaseSizeForLimit: function(isVertical) {\n        var baseSize;\n\n        if (isVertical) {\n            baseSize = this.calculateSeriesHeight();\n        } else {\n            baseSize = this.calculateSeriesWidth();\n        }\n\n        return baseSize;\n    },\n\n    /**\n     * Make series dimension.\n     * @returns {{width: number, height: number}} series dimension\n     * @private\n     */\n    _makeSeriesDimension: function() {\n        return {\n            width: this.calculateSeriesWidth(),\n            height: this.calculateSeriesHeight()\n        };\n    },\n\n    /**\n     * Register series dimension.\n     */\n    registerSeriesDimension: function() {\n        var seriesDimension = this._makeSeriesDimension();\n\n        this._registerDimension('series', seriesDimension);\n    },\n\n    /**\n     * Update width of legend and series of BoundsModel.\n     * @param {number} circleLegendWidth - width for circle legend\n     * @param {number} diffWidth - difference width\n     * @private\n     */\n    _updateLegendAndSeriesWidth: function(circleLegendWidth, diffWidth) {\n        var legendOptions = this.options.legend;\n\n        if (predicate.isVerticalLegend(legendOptions.align) &amp;&amp; legendOptions.visible) {\n            this._registerDimension('legend', {\n                width: circleLegendWidth\n            });\n        }\n\n        this._registerDimension('series', {\n            width: this.getDimension('series').width - diffWidth\n        });\n    },\n\n    /**\n     * Register dimension of circle legend.\n     * @param {object} axisDataMap - axisData map\n     * @private\n     */\n    registerCircleLegendDimension: function(axisDataMap) {\n        var seriesDimension = this.getDimension('series');\n        var legendOptions = this.options.legend;\n        var maxLabel = this.dataProcessor.getFormattedMaxValue(this.chartType, 'circleLegend', 'r');\n        var fontFamily = this.theme.chart.fontFamily;\n        var circleLegendWidth = circleLegendCalculator.calculateCircleLegendWidth(seriesDimension, axisDataMap,\n            maxLabel, fontFamily);\n        var legendWidth, diffWidth;\n\n        if (predicate.isVerticalLegend(legendOptions.align) &amp;&amp; legendOptions.visible) {\n            legendWidth = this.getDimension('legend').width;\n        } else {\n            legendWidth = 0;\n        }\n\n        circleLegendWidth = Math.min(circleLegendWidth, Math.max(legendWidth, chartConst.MIN_LEGEND_WIDTH));\n        diffWidth = circleLegendWidth - legendWidth;\n\n        this._registerDimension('circleLegend', {\n            width: circleLegendWidth,\n            height: circleLegendWidth\n        });\n\n        if (diffWidth) {\n            this._updateLegendAndSeriesWidth(circleLegendWidth, diffWidth);\n        }\n    },\n\n    /**\n     * Make plot dimention\n     * @returns {{width: number, height: number}} plot dimension\n     * @private\n     */\n    _makePlotDimension: function() {\n        var seriesDimension = this.getDimension('series');\n\n        return {\n            width: seriesDimension.width,\n            height: seriesDimension.height + chartConst.OVERLAPPING_WIDTH\n        };\n    },\n\n    /**\n     * Register center componets dimension.\n     * @private\n     */\n    _registerCenterComponentsDimension: function() {\n        var seriesDimension = this.getDimension('series');\n\n        this._registerDimension('tooltip', seriesDimension);\n        this._registerDimension('customEvent', seriesDimension);\n    },\n\n    /**\n     * Register axis components dimension.\n     * @private\n     */\n    _registerAxisComponentsDimension: function() {\n        var plotDimension = this._makePlotDimension();\n\n        this._registerDimension('plot', plotDimension);\n\n        this._registerDimension('xAxis', {\n            width: plotDimension.width\n        });\n\n        this._registerDimension('yAxis', {\n            height: plotDimension.height\n        });\n\n        this._registerDimension('rightYAxis', {\n            height: plotDimension.height\n        });\n    },\n\n    /**\n     * Update width of dimensions.\n     * @param {number} overflowLeft overflow left\n     * @private\n     */\n    _updateDimensionsWidth: function(overflowLeft) {\n        this.chartLeftPadding += overflowLeft;\n        this.dimensionMap.plot.width -= overflowLeft;\n        this.dimensionMap.series.width -= overflowLeft;\n        this.dimensionMap.customEvent.width -= overflowLeft;\n        this.dimensionMap.xAxis.width -= overflowLeft;\n    },\n\n    /**\n     * Update height of dimensions.\n     * @param {number} diffHeight diff height\n     * @private\n     */\n    _updateDimensionsHeight: function(diffHeight) {\n        this.dimensionMap.plot.height -= diffHeight;\n        this.dimensionMap.series.height -= diffHeight;\n        this.dimensionMap.customEvent.height -= diffHeight;\n        this.dimensionMap.tooltip.height -= diffHeight;\n        this.dimensionMap.yAxis.height -= diffHeight;\n        this.dimensionMap.rightYAxis.height -= diffHeight;\n        this.dimensionMap.xAxis.height += diffHeight;\n    },\n\n    /**\n     * Update dimensions for label of x axis.\n     * @param {?object} xAxisData - axis data for x axis.\n     * @private\n     */\n    _updateDimensionsForXAxisLabel: function(xAxisData) {\n        if (xAxisData.overflowLeft > 0) {\n            this._updateDimensionsWidth(xAxisData.overflowLeft);\n        }\n\n        if (xAxisData.overflowHeight) {\n            this._updateDimensionsHeight(xAxisData.overflowHeight);\n        }\n    },\n\n    /**\n     * Register axes type component positions.\n     * @param {number} leftLegendWidth legend width\n     * @private\n     */\n    _registerAxisComponentsPosition: function(leftLegendWidth) {\n        var seriesPosition = this.getPosition('series'),\n            seriesDimension = this.getDimension('series'),\n            yAxisWidth = this.getDimension('yAxis').width,\n            leftAreaWidth = yAxisWidth + seriesDimension.width + leftLegendWidth;\n\n        this.positionMap.plot = {\n            top: seriesPosition.top,\n            left: seriesPosition.left\n        };\n\n        this.positionMap.yAxis = {\n            top: seriesPosition.top,\n            left: this.chartLeftPadding + leftLegendWidth\n        };\n\n        this.positionMap.xAxis = {\n            top: seriesPosition.top + seriesDimension.height,\n            left: seriesPosition.left\n        };\n\n        this.positionMap.rightYAxis = {\n            top: seriesPosition.top,\n            left: this.chartLeftPadding + leftAreaWidth - chartConst.OVERLAPPING_WIDTH\n        };\n    },\n\n    /**\n     * Make legend bound.\n     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} legend bound\n     * @private\n     */\n    _makeLegendPosition: function() {\n        var dimensionMap = this.dimensionMap;\n        var seriesDimension = this.getDimension('series');\n        var legendOption = this.options.legend;\n        var top = dimensionMap.title.height;\n        var yAxisAreaWidth, left;\n\n        if (predicate.isLegendAlignBottom(legendOption.align)) {\n            top += seriesDimension.height + this.getDimension('xAxis').height + chartConst.LEGEND_AREA_PADDING;\n        }\n\n        if (predicate.isHorizontalLegend(legendOption.align)) {\n            left = ((this.getDimension('chart').width - this.getDimension('legend').width) / 2)\n                - chartConst.LEGEND_AREA_PADDING;\n        } else if (predicate.isLegendAlignLeft(legendOption.align)) {\n            left = 0;\n        } else {\n            yAxisAreaWidth = this.getDimension('yAxis').width + this.getDimension('rightYAxis').width;\n            left = seriesDimension.width + yAxisAreaWidth + this.chartLeftPadding;\n        }\n\n        return {\n            top: top,\n            left: left\n        };\n    },\n\n    /**\n     * Make CircleLegend position.\n     * @returns {{top: number, left: number}}\n     * @private\n     */\n    _makeCircleLegendPosition: function() {\n        var seriesPosition = this.getPosition('series');\n        var seriesDimension = this.getDimension('series');\n        var circleDimension = this.getDimension('circleLegend');\n        var legendOptions = this.options.legend;\n        var left, legendWidth;\n\n        if (predicate.isLegendAlignLeft(legendOptions.align)) {\n            left = 0;\n        } else {\n            left = seriesPosition.left + seriesDimension.width;\n        }\n\n        if (predicate.isVerticalLegend(legendOptions.align) &amp;&amp; legendOptions.visible) {\n            legendWidth = this.getDimension('legend').width + chartConst.CHART_PADDING;\n            left += (legendWidth - circleDimension.width) / 2;\n        }\n\n        return {\n            top: seriesPosition.top + seriesDimension.height - circleDimension.height,\n            left: left\n        };\n    },\n\n    /**\n     * Whether need expansion series or not.\n     * @returns {boolean}\n     * @private\n     */\n    _isNeedExpansionSeries: function() {\n        var chartType = this.chartType;\n\n        return !predicate.isMousePositionChart(chartType) &amp;&amp; !predicate.isTreemapChart(chartType)\n            &amp;&amp; !predicate.isPieDonutComboChart(chartType, this.seriesNames);\n    },\n\n    /**\n     * Register essential components positions.\n     * Essential components is all components except components for axis.\n     * @private\n     */\n    _registerEssentialComponentsPositions: function() {\n        var seriesPosition = this.getPosition('series');\n        var tooltipPosition;\n\n        this.positionMap.customEvent = tui.util.extend({}, seriesPosition);\n        this.positionMap.legend = this._makeLegendPosition();\n\n        if (this.getDimension('circleLegend').width) {\n            this.positionMap.circleLegend = this._makeCircleLegendPosition();\n        }\n\n        if (this._isNeedExpansionSeries()) {\n            tooltipPosition = {\n                top: seriesPosition.top - chartConst.SERIES_EXPAND_SIZE,\n                left: seriesPosition.left - chartConst.SERIES_EXPAND_SIZE\n            };\n        } else {\n            tooltipPosition = seriesPosition;\n        }\n\n        this.positionMap.tooltip = tooltipPosition;\n    },\n\n    /**\n     * Register positions.\n     * @private\n     */\n    _registerPositions: function() {\n        var alignOption = this.options.legend.align;\n        var isVisibleLegend = this.options.legend.visible;\n        var legendDimension = this.getDimension('legend');\n        var topLegendHeight = (predicate.isLegendAlignTop(alignOption) &amp;&amp; isVisibleLegend) ? legendDimension.height : 0;\n        var leftLegendWidth = (predicate.isLegendAlignLeft(alignOption) &amp;&amp; isVisibleLegend) ? legendDimension.width : 0;\n        var seriesPosition = {\n            top: this.getDimension('title').height + chartConst.CHART_PADDING + topLegendHeight,\n            left: this.chartLeftPadding + leftLegendWidth + this.getDimension('yAxis').width\n        };\n\n        this.positionMap.series = seriesPosition;\n\n        if (this.hasAxes) {\n            this._registerAxisComponentsPosition(leftLegendWidth);\n        }\n\n        this._registerEssentialComponentsPositions();\n    },\n\n    /**\n     * Register bound of extended series for rendering.\n     * @private\n     */\n    _registerExtendedSeriesBound: function() {\n        var seriesBound = this.getBound('series');\n        if (this._isNeedExpansionSeries()) {\n            seriesBound = renderUtil.expandBound(seriesBound);\n        }\n\n        this._setBound('extendedSeries', seriesBound);\n    },\n\n    /**\n     * Update bounds(positions, dimensions) of components for center option of yAxis.\n     * @private\n     */\n    _updateBoundsForYAxisCenterOption: function() {\n        var yAxisWidth = this.getDimension('yAxis').width;\n        var yAxisExtensibleLeft = Math.floor((this.getDimension('series').width / 2)) + chartConst.OVERLAPPING_WIDTH;\n        var xAxisDecreasingLeft = yAxisWidth - chartConst.OVERLAPPING_WIDTH;\n        var additionalLeft = renderUtil.isOldBrowser() ? 1 : 0;\n\n        this.dimensionMap.extendedSeries.width += yAxisWidth;\n        this.dimensionMap.xAxis.width += chartConst.OVERLAPPING_WIDTH;\n        this.dimensionMap.plot.width += yAxisWidth + chartConst.OVERLAPPING_WIDTH;\n        this.dimensionMap.customEvent.width += yAxisWidth;\n        this.dimensionMap.tooltip.width += yAxisWidth;\n\n        this.positionMap.series.left -= (yAxisWidth - additionalLeft);\n        this.positionMap.extendedSeries.left -= (xAxisDecreasingLeft - additionalLeft);\n        this.positionMap.plot.left -= xAxisDecreasingLeft;\n        this.positionMap.yAxis.left += yAxisExtensibleLeft;\n        this.positionMap.xAxis.left -= xAxisDecreasingLeft;\n        this.positionMap.customEvent.left -= xAxisDecreasingLeft;\n        this.positionMap.tooltip.left -= xAxisDecreasingLeft;\n    },\n\n    /**\n     * Register bounds data.\n     * @param {?object} xAxisData - axis data for x axis.\n     */\n    registerBoundsData: function(xAxisData) {\n        this._registerCenterComponentsDimension();\n\n        if (this.hasAxes) {\n            this._registerAxisComponentsDimension();\n            this._updateDimensionsForXAxisLabel(xAxisData);\n        }\n\n        this._registerPositions();\n        this._registerExtendedSeriesBound();\n\n        if (this.options.yAxis.isCenter) {\n            this._updateBoundsForYAxisCenterOption();\n        }\n    },\n\n    /**\n     * Calculate max radius.\n     * @param {object} axisDataMap - axisData map\n     * @returns {number}\n     */\n    calculateMaxRadius: function(axisDataMap) {\n        var dimensionMap = this.getDimensionMap(['series', 'circleLegend']);\n\n        return circleLegendCalculator.calculateMaxRadius(dimensionMap, axisDataMap);\n    }\n});\n\nmodule.exports = BoundsModel;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"