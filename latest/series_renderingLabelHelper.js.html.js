tui.util.defineNamespace("fedoc.content", {});
fedoc.content["series_renderingLabelHelper.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview  renderingLabelHelper is helper for rendering of series label.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const');\nvar renderUtil = require('../helpers/renderUtil');\nvar seriesTemplate = require('./seriesTemplate');\n\n/**\n * renderingLabelHelper is helper for rendering of series label.\n */\nvar renderingLabelHelper = {\n    /**\n     * Calculate left position for center align of series label.\n     * @param {{left: number, top: number, width:number, height: number}} bound - bound\n     * @param {number} labelWidth - label width\n     * @returns {number}\n     * @private\n     */\n    _calculateLeftPositionForCenterAlign: function(bound, labelWidth) {\n        return bound.left + ((bound.width - labelWidth) / 2);\n    },\n\n    /**\n     * Calculate top position for middle align of series label.\n     * @param {{left: number, top: number, width:number, height: number}} bound - bound\n     * @param {number} labelHeight - label height\n     * @returns {number}\n     * @private\n     */\n    _calculateTopPositionForMiddleAlign: function(bound, labelHeight) {\n        return bound.top + ((bound.height - labelHeight + chartConst.TEXT_PADDING) / 2);\n    },\n\n    /**\n     * Make position for type of bound for rendering label.\n     * @param {{left: number, top: number, width:number, height: number}} bound - bound\n     * @param {number} labelHeight - label height\n     * @param {string} label - label\n     * @param {object} theme - theme for series label\n     * @returns {{left: number, top: number}}\n     * @private\n     */\n    _makePositionForBoundType: function(bound, labelHeight, label, theme) {\n        var labelWidth = renderUtil.getRenderedLabelWidth(label, theme);\n\n        return {\n            left: this._calculateLeftPositionForCenterAlign(bound, labelWidth),\n            top: this._calculateTopPositionForMiddleAlign(bound, labelHeight)\n        };\n    },\n\n    /**\n     * Make position map for rendering label.\n     * @param {SeriesItem} seriesItem - series item\n     * @param {{left: number, top: number, width: number, height: number}} bound - bound\n     * @param {number} labelHeight - label height\n     * @param {object} theme - theme for series label\n     * @param {function} makePosition - function for making position of label\n     * @returns {{end: *}}\n     * @private\n     */\n    _makePositionMap: function(seriesItem, bound, labelHeight, theme, makePosition) {\n        var value = seriesItem.value;\n        var isOppositeSide = value >= 0;\n        var positionMap = {\n            end: makePosition(bound, labelHeight, seriesItem.endLabel, theme, isOppositeSide)\n        };\n\n        if (seriesItem.isRange) {\n            isOppositeSide = value &lt; 0;\n            positionMap.start = makePosition(bound, labelHeight, seriesItem.startLabel, theme, isOppositeSide);\n        }\n\n        return positionMap;\n    },\n\n    /**\n     * Bounds to label positions.\n     * @param {SeriesDataModel} seriesDataModel - series data model\n     * @param {Array.&lt;Array.&lt;{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set\n     * @param {object} theme - theme for series label\n     * @param {function} [makePosition] - function for making position of label\n     * @returns {Array.&lt;Object>}\n     */\n    boundsToLabelPositions: function(seriesDataModel, boundsSet, theme, makePosition) {\n        var self = this;\n        var labelHeight = renderUtil.getRenderedLabelHeight(chartConst.MAX_HEIGHT_WORLD, theme);\n\n        makePosition = makePosition || tui.util.bind(this._makePositionForBoundType, this);\n\n        return seriesDataModel.map(function(seriesGroup, groupIndex) {\n            var bounds = boundsSet[groupIndex];\n\n            return seriesGroup.map(function(seriesItem, index) {\n                var bound = bounds[index].end;\n\n                return self._makePositionMap(seriesItem, bound, labelHeight, theme, makePosition);\n            });\n        });\n    },\n\n    /**\n     * Make label position for bar chart.\n     * @param {{left: number, top: number, width:number, height: number}} bound - bound\n     * @param {number} labelHeight - label height\n     * @param {string} label - label\n     * @param {object} theme - theme for series label\n     * @param {boolean} isOppositeSide - whether opossite side or not\n     * @returns {{left: number, top: number}}\n     * @private\n     */\n    _makePositionForBarChart: function(bound, labelHeight, label, theme, isOppositeSide) {\n        var labelWidth = renderUtil.getRenderedLabelWidth(label, theme);\n        var left = bound.left;\n\n        if (isOppositeSide) {\n            left += bound.width + chartConst.SERIES_LABEL_PADDING;\n        } else {\n            left -= labelWidth + chartConst.SERIES_LABEL_PADDING;\n        }\n\n        return {\n            left: left,\n            top: this._calculateTopPositionForMiddleAlign(bound, labelHeight)\n        };\n    },\n\n    /**\n     * Bounds to label positions for bar chart.\n     * @param {SeriesDataModel} seriesDataModel - series data model\n     * @param {Array.&lt;Array.&lt;{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set\n     * @param {object} theme - theme for series label\n     * @returns {*|Array.&lt;Object>|Array}\n     */\n    boundsToLabelPositionsForBarChart: function(seriesDataModel, boundsSet, theme) {\n        var makePositionFunction = tui.util.bind(this._makePositionForBarChart, this);\n\n        return this.boundsToLabelPositions(seriesDataModel, boundsSet, theme, makePositionFunction);\n    },\n\n    /**\n     * Make label position for column chart.\n     * @param {{left: number, top: number, width:number, height: number}} bound - bound\n     * @param {number} labelHeight - label height\n     * @param {string} label - label\n     * @param {object} theme - theme for series label\n     * @param {boolean} isOppositeSide - whether opossite side or not\n     * @returns {{left: number, top: number}}\n     * @private\n     */\n    _makePositionForColumnChart: function(bound, labelHeight, label, theme, isOppositeSide) {\n        var labelWidth = renderUtil.getRenderedLabelWidth(label, theme);\n        var top = bound.top;\n\n        if (isOppositeSide) {\n            top -= labelHeight + chartConst.SERIES_LABEL_PADDING;\n        } else {\n            top += bound.height + chartConst.SERIES_LABEL_PADDING;\n        }\n\n        return {\n            left: this._calculateLeftPositionForCenterAlign(bound, labelWidth),\n            top: top\n        };\n    },\n\n    /**\n     * Bounds to label positions for column chart.\n     * @param {SeriesDataModel} seriesDataModel - series data model\n     * @param {Array.&lt;Array.&lt;{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set\n     * @param {object} theme - theme for series label\n     * @returns {*|Array.&lt;Object>|Array}\n     */\n    boundsToLabelPositionsForColumnChart: function(seriesDataModel, boundsSet, theme) {\n        var makePositionFunction = tui.util.bind(this._makePositionForColumnChart, this);\n\n        return this.boundsToLabelPositions(seriesDataModel, boundsSet, theme, makePositionFunction);\n    },\n\n    /**\n     * Make css text for series label.\n     * @param {{left: number, top: number}} position - position for rendering label\n     * @param {object} theme - theme for series label\n     * @param {number} index - index of legends\n     * @param {number} selectedIndex - selected index of legends\n     * @param {object} [tplCssText] - cssText template object\n     * @returns {*}\n     * @private\n     */\n    _makeLabelCssText: function(position, theme, index, selectedIndex, tplCssText) {\n        var cssObj = tui.util.extend(position, theme);\n\n        tplCssText = tplCssText || seriesTemplate.tplCssText;\n\n        if (!tui.util.isNull(selectedIndex) &amp;&amp; (selectedIndex !== index)) {\n            cssObj.opacity = renderUtil.makeOpacityCssText(chartConst.SERIES_LABEL_OPACITY);\n        } else {\n            cssObj.opacity = '';\n        }\n\n        return tplCssText(cssObj);\n    },\n\n    /**\n     * Make html about series label.\n     * @param {{left: number, top: number}} position - position for rendering label\n     * @param {string} label - label of SeriesItem\n     * @param {object} theme - theme for series label\n     * @param {number} index - index of legends\n     * @param {number} selectedIndex - selected index of legends\n     * @param {object} [tplCssText] - cssText template object\n     * @param {boolean} [isStart] - whether start label or not\n     * @returns {string}\n     */\n    makeSeriesLabelHtml: function(position, label, theme, index, selectedIndex, tplCssText, isStart) {\n        /*eslint max-params: [2, 7]*/\n        var cssText = this._makeLabelCssText(position, theme, index, selectedIndex, tplCssText);\n        var rangeLabelAttribute = '';\n\n        if (isStart) {\n            rangeLabelAttribute = ' data-range=\"true\"';\n        }\n        return seriesTemplate.tplSeriesLabel({\n            label: label,\n            cssText: cssText,\n            rangeLabelAttribute: rangeLabelAttribute\n        });\n    },\n\n    /**\n     * Make\n     * @param {HTMLElement} container - container of label area\n     * @param {SeriesDataModel} seriesDataModel - series data model\n     * @param {Array.&lt;Array.&lt;{left: number, top: number}>>} positionsSet - positions set\n     * @param {object} theme - theme for series label\n     * @param {number} selectedIndex - selected index of legends\n     * @returns {*}\n     */\n    makeLabelsHtmlForBoundType: function(container, seriesDataModel, positionsSet, theme, selectedIndex) {\n        var makeSeriesLabelHtml = tui.util.bind(this.makeSeriesLabelHtml, this);\n        var labelsHtml = seriesDataModel.map(function(seriesGroup, groupIndex) {\n            return seriesGroup.map(function(seriesItem, index) {\n                var positionMap = positionsSet[groupIndex][index];\n                var html = makeSeriesLabelHtml(positionMap.end, seriesItem.endLabel, theme, index, selectedIndex);\n\n                if (positionMap.start) {\n                    html += makeSeriesLabelHtml(positionMap.start, seriesItem.startLabel, theme, index, selectedIndex);\n                }\n\n                return html;\n            }).join('');\n        }).join('');\n\n        return labelsHtml;\n    }\n};\n\nmodule.exports = renderingLabelHelper;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"