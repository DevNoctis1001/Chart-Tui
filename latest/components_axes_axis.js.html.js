tui.util.defineNamespace("fedoc.content", {});
fedoc.content["components_axes_axis.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview  Axis component.\n * @author NHN Ent.\n *         FE Development Lab &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar dom = require('../../helpers/domHandler');\nvar chartConst = require('../../const/');\nvar predicate = require('../../helpers/predicate');\nvar calculator = require('../../helpers/calculator');\nvar renderUtil = require('../../helpers/renderUtil');\nvar axisTemplate = require('./axisTemplate');\n\nvar Axis = tui.util.defineClass(/** @lends Axis.prototype */ {\n    /**\n     * Axis component.\n     * @constructs Axis\n     * @param {object} params parameters\n     *      @param {object} params.bound axis bound\n     *      @param {object} params.theme axis theme\n     *      @param {object} params.options axis options\n     */\n    init: function(params) {\n        /**\n         * Axis view className\n         * @type {string}\n         */\n        this.className = 'tui-chart-axis-area';\n\n        /**\n         * Data processor\n         * @type {DataProcessor}\n         */\n        this.dataProcessor = params.dataProcessor;\n\n        /**\n         * Options\n         * @type {object}\n         */\n        this.options = params.options || {};\n\n        /**\n         * Theme\n         * @type {object}\n         */\n        this.theme = params.theme[params.seriesName] || params.theme;\n\n        /**\n         * Whether label type or not.\n         * @type {boolean}\n         */\n        this.isLabel = null;\n\n        /**\n         * Whether vertical type or not.\n         */\n        this.isVertical = params.isVertical;\n\n        /**\n         * cached axis data\n         * @type {object}\n         */\n        this.data = {};\n\n        /**\n         * layout bounds information for this components\n         * @type {null|{dimension:{width:number, height:number}, position:{left:number, top:number}}}\n         */\n        this.layout = null;\n\n        /**\n         * dimension map for layout of chart\n         * @type {null|object}\n         */\n        this.dimensionMap = null;\n\n        /**\n         * axis data map\n         * @type {null|object}\n         */\n        this.axisDataMap = null;\n    },\n\n    /**\n     * Whether valid axis or not.\n     * @returns {boolean} whether valid axis or not.\n     * @private\n     */\n    _isValidAxis: function() {\n        var isValid = true;\n\n        if (this.componentName === 'rightYAxis') {\n            isValid = this.dataProcessor.isValidAllSeriesDataModel();\n        }\n\n        return isValid;\n    },\n\n    /**\n     * Render opposite side tick area.\n     * @param {string} tickHtml tick html\n     * @returns {?HTMLElement} right tick area element\n     * @private\n     */\n    _renderOppositeSideTickArea: function(tickHtml) {\n        var tickContainer;\n\n        if (this.options.isCenter) {\n            tickContainer = dom.create('DIV', 'tui-chart-tick-area opposite-side');\n            tickContainer.innerHTML = tickHtml;\n        }\n\n        return tickContainer;\n    },\n\n    /**\n     * Add css classes.\n     * @param {HTMLElement} axisContainer axis container\n     * @private\n     */\n    _addCssClasses: function(axisContainer) {\n        dom.addClass(axisContainer, this.isVertical ? 'vertical' : 'horizontal');\n        dom.addClass(axisContainer, this.options.isCenter ? 'center' : '');\n        dom.addClass(axisContainer, this.options.divided ? 'division' : '');\n        dom.addClass(axisContainer, this.data.isPositionRight ? 'right' : '');\n    },\n\n\n    /**\n     * Render child containers like title area, label area and tick area.\n     * @param {number} size xAxis width or yAxis height\n     * @param {number} width axis width\n     * @param {number} tickCount tick count\n     * @param {Array.&lt;number|string>} categories categories\n     * @param {number} additionalWidth additional width\n     * @returns {Array.&lt;HTMLElement>} child containers\n     * @private\n     */\n    _renderChildContainers: function(size, width, tickCount, categories, additionalWidth) {\n        var titleContainer = this._renderTitleArea(size),\n            labelContainer = this._renderLabelArea(size, width, tickCount, categories, additionalWidth),\n            childContainers = [titleContainer, labelContainer],\n            isVerticalLineType = this.isVertical &amp;&amp; this.data.aligned,\n            tickContainer, oppositeSideTickContainer;\n\n        if (!isVerticalLineType) {\n            tickContainer = this._renderTickArea(size, tickCount, additionalWidth);\n            oppositeSideTickContainer = this._renderOppositeSideTickArea(tickContainer.innerHTML);\n            childContainers = childContainers.concat([tickContainer, oppositeSideTickContainer]);\n        }\n\n        return childContainers;\n    },\n\n    /**\n     * Render divided xAxis if yAxis rendered in the center.\n     * @param {HTMLElement} axisContainer axis container element\n     * @param {number} width axis area width\n     * @private\n     */\n    _renderDividedAxis: function(axisContainer, width) {\n        var lWidth = Math.round(width / 2);\n        var rWidth = width - lWidth;\n        var axisData = this.data;\n        var tickCount = axisData.tickCount;\n        var halfTickCount = parseInt(tickCount / 2, 10) + 1;\n        var categories = axisData.labels;\n        var lCategories = categories.slice(0, halfTickCount);\n        var rCategories = categories.slice(halfTickCount - 1, tickCount);\n        var additionalWidth = lWidth + this.dimensionMap.yAxis.width;\n        var lContainers = this._renderChildContainers(lWidth, lWidth, halfTickCount, lCategories, 0);\n        var rContainers = this._renderChildContainers(rWidth, rWidth, halfTickCount, rCategories, additionalWidth);\n        var rTitleContainer = rContainers[0];\n\n        dom.addClass(rTitleContainer, 'right');\n        dom.append(axisContainer, lContainers.concat(rContainers));\n    },\n\n    /**\n     * Render single axis if not divided.\n     * @param {HTMLElement} axisContainer axis container element\n     * @param {{width: number, height: number}} dimension axis area dimension\n     * @private\n     */\n    _renderNotDividedAxis: function(axisContainer, dimension) {\n        var axisData = this.data;\n        var isVertical = this.isVertical;\n        var width = dimension.width;\n        var size = isVertical ? dimension.height : width;\n        var additionalSize = 0;\n        var childContainers;\n\n        if (axisData.positionRatio) {\n            additionalSize = size * axisData.positionRatio;\n        }\n\n        childContainers = this._renderChildContainers(size, width, axisData.tickCount, axisData.labels, additionalSize);\n\n        dom.append(axisContainer, childContainers);\n    },\n\n    /**\n     * Render axis area.\n     * @param {HTMLElement} axisContainer axis area element\n     * @param {{isVertical: boolean, isPositionRight: boolean, aligned: aligned}} data rendering data\n     * @private\n     */\n    _renderAxisArea: function(axisContainer) {\n        var dimension = this.layout.dimension;\n        var axisData = this.data;\n\n        this.isLabel = axisData.isLabelAxis;\n\n        this._addCssClasses(axisContainer);\n\n        if (this.options.divided) {\n            this.containerWidth = dimension.width + this.dimensionMap.yAxis.width;\n            this._renderDividedAxis(axisContainer, dimension.width);\n            dimension.width = this.containerWidth;\n        } else {\n            this._renderNotDividedAxis(axisContainer, dimension);\n            dimension.width += this.options.isCenter ? 2 : 0;\n        }\n\n        renderUtil.renderDimension(axisContainer, dimension);\n        renderUtil.renderPosition(axisContainer, this.layout.position);\n    },\n\n    /**\n     * Set data for rendering.\n     * @param {{\n     *      options: ?object,\n     *      layout: {\n     *          dimension: {width: number, height: number},\n     *          position: {left: number, top: number}\n     *      },\n     *      dimensionMap: object,\n     *      axisDataMap: object\n     * }} data - bounds and scale data\n     * @private\n     */\n    _setDataForRendering: function(data) {\n        this.layout = data.layout;\n        this.dimensionMap = data.dimensionMap;\n        this.data = data.axisDataMap[this.componentName];\n        this.options = this.data.options;\n    },\n\n    /**\n     * @param {object} data - bounds and scale data\n     * @returns {HTMLElement} axis area base element\n     */\n    render: function(data) {\n        var container = dom.create('DIV', this.className);\n\n        this._setDataForRendering(data);\n        this._renderAxisArea(container);\n        this.axisContainer = container;\n\n        return container;\n    },\n\n    /**\n     * Rerender axis component.\n     * @param {object} data - bounds and scale data\n     */\n    rerender: function(data) {\n        this.axisContainer.innerHTML = '';\n\n        if (this._isValidAxis()) {\n            this._setDataForRendering(data);\n            this._renderAxisArea(this.axisContainer);\n        }\n    },\n\n    /**\n     * Resize axis component.\n     * @param {object} data - bounds and scale data\n     */\n    resize: function(data) {\n        this.rerender(data);\n    },\n\n    /**\n     * Zoom.\n     * @param {object} data - bounds and scale data\n     */\n    zoom: function(data) {\n        this.rerender(data);\n    },\n\n    /**\n     * Move axis to left.\n     * @param {number} tickSize - tick size for moving\n     * @private\n     */\n    _moveToLeft: function(tickSize) {\n        var ticksElement = this.ticksElement;\n        var firstTickElement = ticksElement.firstChild;\n        var labelContainer = this.labelContainer;\n        var firstLabelElement = labelContainer.firstChild;\n        var ticksBeforeLeft = parseInt(ticksElement.style.left, 10) || 0;\n        var labelBeforeLeft = parseInt(labelContainer.style.left, 10) || 0;\n        var startIndex = this.data.startIndex || 0;\n\n        renderUtil.startAnimation(300, function(ratio) {\n            var left = tickSize * ratio;\n            var opacity = 1 - ratio;\n\n            ticksElement.style.left = (ticksBeforeLeft - left) + 'px';\n            labelContainer.style.left = (labelBeforeLeft - left) + 'px';\n\n            if (startIndex === 0) {\n                renderUtil.setOpacity([firstTickElement, firstLabelElement], opacity);\n            }\n        });\n    },\n\n    /**\n     * Resize by tick size.\n     * @param {number} tickSize - tick size for resizing\n     * @private\n     */\n    _resizeByTickSize: function(tickSize) {\n        var ticksElement = this.ticksElement;\n        var labelContainer = this.labelContainer;\n        var beforeWidth = parseInt(ticksElement.style.width, 10) || ticksElement.offsetWidth;\n\n        renderUtil.startAnimation(chartConst.ADDING_DATA_ANIMATION_DURATION, function(ratio) {\n            var width = beforeWidth - (tickSize * ratio);\n\n            ticksElement.style.width = width + 'px';\n            labelContainer.style.width = width + 'px';\n        });\n    },\n\n    /**\n     * Animate for adding data.\n     * @param {{tickSize: number}} data - data for animate\n     */\n    animateForAddingData: function(data) {\n        if (this.isVertical || this.dataProcessor.isCoordinateType()) {\n            return;\n        }\n\n        if (data.shifting) {\n            this._moveToLeft(data.tickSize);\n        } else {\n            this._resizeByTickSize(data.tickSize);\n        }\n    },\n\n    /**\n     * Make cssText from position map for css.\n     * @param {object.&lt;string, number>} positionMap - position map for css\n     * @returns {string}\n     * @private\n     */\n    _makeCssTextFromPositionMap: function(positionMap) {\n        tui.util.forEach(positionMap, function(value, name) {\n            positionMap[name] = value + 'px';\n        });\n\n        return renderUtil.makeCssTextFromMap(positionMap);\n    },\n\n    /**\n     * Make position map for center align option of y axis.\n     * @returns {{left: number, bottom: number}}\n     * @private\n     */\n    _makePositionMapForCenterAlign: function() {\n        var titleOptions = this.options.title;\n        var offset = titleOptions.offset || {};\n        var titleWidth = renderUtil.getRenderedLabelWidth(titleOptions.text, this.theme.title);\n        var yAxisWidth = this.dimensionMap.yAxis.width;\n        var left = (yAxisWidth - titleWidth) / 2;\n        var bottom = -this.dimensionMap.xAxis.height;\n\n        bottom -= offset.y || 0;\n        left += offset.x || 0;\n\n        return {\n            left: left,\n            bottom: bottom\n        };\n    },\n\n    /**\n     * Make right position for right y axis.\n     * @param {number} size - width or height\n     * @returns {number}\n     * @private\n     */\n    _makeRightPosition: function(size) {\n        var offset = this.options.title.offset || {};\n        var rightPosition;\n\n        if (renderUtil.isIE7() || this.options.rotateTitle === false) {\n            rightPosition = 0;\n        } else {\n            rightPosition = -size;\n        }\n\n        rightPosition -= offset.x || 0;\n\n        return rightPosition;\n    },\n\n    /**\n     * Make top position.\n     * @param {number} size - width or height\n     * @returns {?number}\n     * @private\n     */\n    _makeTopPosition: function(size) {\n        var offset = this.options.title.offset;\n        var topPosition = null;\n        var titleHeight;\n\n        if (this.options.rotateTitle === false) {\n            titleHeight = renderUtil.getRenderedLabelHeight(this.options.title, this.theme.title);\n            topPosition = (size - titleHeight) / 2;\n        } else if (this.data.isPositionRight) {\n            topPosition = 0;\n        } else if (!renderUtil.isOldBrowser()) {\n            topPosition = size;\n        }\n\n        if (offset) {\n            topPosition = topPosition || 0;\n            topPosition += offset.y || 0;\n        }\n\n        return topPosition;\n    },\n\n    /**\n     * Make positionMap for not center align.\n     * @param {number} size - width or height\n     * @returns {object.&lt;string, number>}\n     * @private\n     */\n    _makePositionMapForNotCenterAlign: function(size) {\n        var positionMap = {};\n        var offset = this.options.title.offset || {};\n        var topPosition;\n\n        if (this.data.isPositionRight) {\n            positionMap.right = this._makeRightPosition(size);\n        } else {\n            positionMap.left = offset.x || 0;\n        }\n\n        topPosition = this._makeTopPosition(size);\n\n        if (!tui.util.isNull(topPosition)) {\n            positionMap.top = topPosition;\n        }\n\n        return positionMap;\n    },\n\n    /**\n     * Render css style of title area for vertical type.\n     * @param {HTMLElement} titleContainer title element\n     * @param {number} size width or height\n     * @private\n     */\n    _renderTitleAreaStyleForVertical: function(titleContainer, size) {\n        var cssPositionMap;\n        var cssText;\n\n        if (this.options.isCenter) {\n            cssPositionMap = this._makePositionMapForCenterAlign();\n        } else {\n            cssPositionMap = this._makePositionMapForNotCenterAlign(size);\n        }\n\n        if (this.options.rotateTitle !== false) {\n            cssPositionMap.width = size;\n        }\n\n        cssText = this._makeCssTextFromPositionMap(cssPositionMap);\n        titleContainer.style.cssText += ';' + cssText;\n    },\n\n    /**\n     * Render title position for horizontal type.\n     * @param {HTMLElement} titleContainer title element\n     * @param {{left: number, top: number, right: number, bottom: number}} offset - title position option\n     * @private\n     */\n    _renderTitlePositionForHorizontal: function(titleContainer, offset) {\n        renderUtil.renderPosition(titleContainer, {\n            left: offset.x,\n            bottom: -offset.y\n        });\n    },\n\n    /**\n     * Render css style of title area\n     * @param {HTMLElement} titleContainer title element\n     * @param {number} size width or height\n     * @private\n     */\n    _renderTitleAreaStyle: function(titleContainer, size) {\n        var offset = this.options.title.offset;\n\n        if (this.isVertical) {\n            this._renderTitleAreaStyleForVertical(titleContainer, size);\n        } else if (offset) {\n            this._renderTitlePositionForHorizontal(titleContainer, offset);\n        }\n    },\n\n    /**\n     * Title area renderer\n     * @param {?number} size (width or height)\n     * @returns {HTMLElement} title element\n     * @private\n     */\n    _renderTitleArea: function(size) {\n        var title = this.options.title || {};\n        var titleContainer = renderUtil.renderTitle(title.text, this.theme.title, 'tui-chart-title-area');\n\n        if (titleContainer) {\n            this._renderTitleAreaStyle(titleContainer, size);\n        }\n\n        if (this.options.rotateTitle !== false) {\n            dom.addClass(titleContainer, 'rotation');\n        }\n\n        return titleContainer;\n    },\n\n    /**\n     * Make percentage position.\n     * @param {Array.&lt;number>} positions - positions\n     * @param {number} areaSize - area size\n     * @returns {Array.&lt;number>}\n     * @private\n     */\n    _makePercentagePositions: function(positions, areaSize) {\n        areaSize = this.containerWidth || areaSize;\n\n        return tui.util.map(positions, function(position) {\n            return calculator.makePercentageValue(position, areaSize);\n        });\n    },\n\n    /**\n     * Make tick html.\n     * @param {number} size - area size\n     * @param {number} tickCount - tick count\n     * @param {boolean} isNotDividedXAxis - whether not divided xAxis or not\n     * @param {number} additionalSize - additional size\n     * @returns {string}\n     * @private\n     */\n    _makeTickHtml: function(size, tickCount, isNotDividedXAxis, additionalSize) {\n        var tickColor = this.theme.tickColor;\n        var axisData = this.data;\n        var sizeRatio = axisData.sizeRatio || 1;\n        var posType = this.isVertical ? 'bottom' : 'left';\n        var positions = calculator.makeTickPixelPositions((size * sizeRatio), tickCount);\n        var containerWidth = this.containerWidth || size;\n        var template, html;\n\n        positions.length = axisData.tickCount;\n        additionalSize = calculator.makePercentageValue(additionalSize, containerWidth);\n        positions = this._makePercentagePositions(positions, size);\n\n        template = axisTemplate.tplAxisTick;\n        html = tui.util.map(positions, function(position, index) {\n            var tickHtml, cssTexts;\n\n            position -= (index === 0 &amp;&amp; isNotDividedXAxis) ? calculator.makePercentageValue(1, containerWidth) : 0;\n            position += additionalSize;\n\n            cssTexts = [\n                renderUtil.concatStr('background-color:', tickColor),\n                renderUtil.concatStr(posType, ': ', position, '%')\n            ].join(';');\n            tickHtml = template({cssText: cssTexts});\n\n            return tickHtml;\n        }).join('');\n\n        return html;\n    },\n\n    /**\n     * Render tick line.\n     * @param {number} areaSize - width or height\n     * @param {boolean} isNotDividedXAxis - whether is not divided x axis or not.\n     * @param {number} additionalSize - additional size\n     * @returns {HTMLElement}\n     * @private\n     */\n    _renderTickLine: function(areaSize, isNotDividedXAxis, additionalSize) {\n        var tickLineElement = dom.create('DIV', 'tui-chart-tick-line');\n        var tickLineExtend = isNotDividedXAxis ? chartConst.OVERLAPPING_WIDTH : 0;\n        var axisData = this.data;\n        var positionValue = -tickLineExtend;\n        var cssMap = {};\n        var sizeType, posType, lineSize;\n\n        if (this.isVertical) {\n            sizeType = 'height';\n            posType = 'bottom';\n        } else {\n            sizeType = 'width';\n            posType = 'left';\n        }\n\n        lineSize = areaSize + tickLineExtend;\n\n        if (!axisData.sizeRatio) {\n            positionValue += additionalSize;\n        }\n\n        cssMap[posType] = positionValue;\n        cssMap[sizeType] = lineSize;\n\n        tickLineElement.style.cssText = this._makeCssTextFromPositionMap(cssMap);\n\n        return tickLineElement;\n    },\n\n    /**\n     * Render ticks.\n     * @param {number} areaSize - width or height\n     * @param {number} tickCount - tick count\n     * @param {boolean} isNotDividedXAxis - whether is not divided x axis or not.\n     * @param {number} additionalSize - additional size\n     * @returns {HTMLElement}\n     * @private\n     */\n    _renderTicks: function(areaSize, tickCount, isNotDividedXAxis, additionalSize) {\n        var ticksElement = dom.create('DIV', 'tui-chart-ticks');\n        var ticksHtml = this._makeTickHtml(areaSize, tickCount, isNotDividedXAxis, additionalSize);\n\n        ticksElement.innerHTML = ticksHtml;\n\n        return ticksElement;\n    },\n\n    /**\n     * Render tick area.\n     * @param {number} size - width or height\n     * @param {number} tickCount - tick count\n     * @param {?number} additionalSize - additional size (width or height)\n     * @returns {HTMLElement}\n     * @private\n     */\n    _renderTickArea: function(size, tickCount, additionalSize) {\n        var tickContainer = dom.create('DIV', 'tui-chart-tick-area');\n        var isNotDividedXAxis = !this.isVertical &amp;&amp; !this.options.divided;\n        var tickLineElement, ticksElement;\n\n        additionalSize = additionalSize || 0;\n        tickLineElement = this._renderTickLine(size, isNotDividedXAxis, additionalSize);\n        ticksElement = this._renderTicks(size, tickCount, isNotDividedXAxis, additionalSize);\n        dom.append(tickContainer, tickLineElement);\n        dom.append(tickContainer, ticksElement);\n\n        this.ticksElement = ticksElement;\n\n        return tickContainer;\n    },\n\n    /**\n     * Make cssText of vertical label.\n     * @param {number} axisWidth axis width\n     * @param {number} titleAreaWidth title area width\n     * @returns {string} cssText\n     * @private\n     */\n    _makeVerticalLabelCssText: function(axisWidth, titleAreaWidth) {\n        return ';width:' + (axisWidth - titleAreaWidth + chartConst.V_LABEL_RIGHT_PADDING) + 'px';\n    },\n\n    /**\n     * Apply css style of label area.\n     * @param {HTMLElement} labelContainer label container\n     * @param {number} axisWidth axis width\n     * @private\n     */\n    _applyLabelAreaStyle: function(labelContainer, axisWidth) {\n        var cssText = renderUtil.makeFontCssText(this.theme.label),\n            titleAreaWidth;\n\n        if (this.isVertical) {\n            titleAreaWidth = this._getRenderedTitleHeight() + chartConst.TITLE_AREA_WIDTH_PADDING;\n            cssText += this._makeVerticalLabelCssText(axisWidth, titleAreaWidth);\n        }\n\n        labelContainer.style.cssText = cssText;\n    },\n\n    /**\n     * Render label area.\n     * @param {number} size label area size\n     * @param {number} axisWidth axis area width\n     * @param {number} tickCount tick count\n     * @param {Array.&lt;string>} categories categories\n     * @param {?number} additionalSize additional size (width or height)\n     * @returns {HTMLElement} label area element\n     * @private\n     */\n    _renderLabelArea: function(size, axisWidth, tickCount, categories, additionalSize) {\n        var labelContainer = dom.create('DIV', 'tui-chart-label-area');\n        var sizeRatio = this.data.sizeRatio || 1;\n        var tickPixelPositions = calculator.makeTickPixelPositions((size * sizeRatio), tickCount);\n        var labelSize = tickPixelPositions[1] - tickPixelPositions[0];\n        var options = this.options;\n        var containerWidth = this.containerWidth || size;\n        var labelsHtml;\n\n        if (predicate.isValidLabelInterval(options.labelInterval, options.tickInterval)) {\n            additionalSize -= ((labelSize * options.labelInterval / 2) - (labelSize / 2))\n            labelSize *= options.labelInterval;\n        }\n\n        additionalSize = additionalSize ? calculator.makePercentageValue(additionalSize, containerWidth) : 0;\n        labelsHtml = this._makeLabelsHtml(size, tickPixelPositions, categories, labelSize, additionalSize);\n        labelContainer.innerHTML = labelsHtml;\n\n        this._applyLabelAreaStyle(labelContainer, axisWidth);\n        this._changeLabelAreaPosition(labelContainer, labelSize);\n\n        this.labelContainer = labelContainer;\n\n        return labelContainer;\n    },\n\n    /**\n     * Get height of title area ;\n     * @returns {number} height\n     * @private\n     */\n    _getRenderedTitleHeight: function() {\n        var title = this.options.title,\n            theme = this.theme.title,\n            result = title ? renderUtil.getRenderedLabelHeight(title, theme) : 0;\n\n        return result;\n    },\n\n    /**\n     * Make cssText of label.\n     * @param {number} labelSize label size (width or height)\n     * @returns {string[]} cssTexts\n     * @private\n     */\n    _makeLabelCssText: function(labelSize) {\n        var isVertical = this.isVertical;\n        var cssTexts = [];\n\n        if (isVertical &amp;&amp; this.isLabel) {\n            cssTexts.push(renderUtil.concatStr('height:', labelSize, 'px'));\n            cssTexts.push(renderUtil.concatStr('line-height:', labelSize, 'px'));\n        } else if (!isVertical) {\n            cssTexts.push(renderUtil.concatStr('width:', labelSize, 'px'));\n        }\n\n        return cssTexts.length ? cssTexts.join(';') + ';' : '';\n    },\n\n    /**\n     * Calculate rotation moving position.\n     * @param {object} params parameters\n     *      @param {number} params.labelHeight label height\n     *      @param {number} params.left normal left\n     *      @param {number} params.moveLeft move left\n     *      @param {number} params.top top\n     * @returns {{top:number, left: number}} position\n     * @private\n     */\n    _calculateRotationMovingPosition: function(params) {\n        var moveLeft = params.moveLeft;\n        var degree = this.data.degree;\n        var containerWidth = this.containerWidth || params.size;\n\n        if (this.data.degree === chartConst.ANGLE_85) {\n            moveLeft += calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, params.labelHeight / 2);\n        }\n\n        return {\n            top: params.top,\n            left: params.left - calculator.makePercentageValue(moveLeft, containerWidth)\n        };\n    },\n\n    /**\n     * Calculate rotation moving position for old browser(IE7, IE8).\n     * @param {object} params parameters\n     *      @param {number} params.labelWidth label width\n     *      @param {number} params.labelHeight label height\n     *      @param {number} params.left normal left\n     *      @param {(string | number)} params.label label\n     *      @param {object} theme label theme\n     * @returns {{top:number, left: number}} position\n     * @private\n     */\n    _calculateRotationMovingPositionForOldBrowser: function(params) {\n        var labelWidth = renderUtil.getRenderedLabelWidth(params.label, params.theme);\n        var degree = this.data.degree;\n        var smallAreaWidth = calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, params.labelHeight / 2);\n        var newLabelWidth = (calculator.calculateAdjacent(degree, labelWidth / 2) + smallAreaWidth) * 2;\n        var changedWidth = renderUtil.isIE7() ? 0 : (labelWidth - newLabelWidth);\n        var moveLeft = (params.labelWidth / 2) - (smallAreaWidth * 2);\n        var containerWidth = this.containerWidth || params.size;\n\n        if (degree === chartConst.ANGLE_85) {\n            moveLeft += smallAreaWidth;\n        }\n\n        return {\n            top: chartConst.XAXIS_LABEL_TOP_MARGIN,\n            left: params.left + calculator.makePercentageValue(changedWidth - moveLeft, containerWidth)\n        };\n    },\n\n    /**\n     * Make cssText for rotation moving.\n     * @param {object} params parameters\n     *      @param {number} params.labelWidth label width\n     *      @param {number} params.labelHeight label height\n     *      @param {number} params.left normal left\n     *      @param {number} params.moveLeft move left\n     *      @param {number} params.top top\n     *      @param {(string | number)} params.label label\n     *      @param {object} theme label theme\n     * @returns {string} cssText\n     * @private\n     */\n    _makeCssTextForRotationMoving: function(params) {\n        var position;\n\n        if (renderUtil.isOldBrowser()) {\n            position = this._calculateRotationMovingPositionForOldBrowser(params);\n        } else {\n            position = this._calculateRotationMovingPosition(params);\n        }\n\n        return renderUtil.concatStr('left:', position.left, '%', ';top:', position.top, 'px');\n    },\n\n    /**\n     * Make html of rotation labels.\n     * @param {number} areaSize - area size.\n     * @param {Array.&lt;object>} positions label position array\n     * @param {string[]} categories categories\n     * @param {number} labelSize label size\n     * @param {number} additionalSize additional size\n     * @returns {string} labels html\n     * @private\n     */\n    _makeRotationLabelsHtml: function(areaSize, positions, categories, labelSize, additionalSize) {\n        var self = this;\n        var degree = this.data.degree;\n        var template = axisTemplate.tplAxisLabel;\n        var labelHeight = renderUtil.getRenderedLabelHeight(categories[0], this.theme.label);\n        var labelCssText = this._makeLabelCssText(labelSize);\n        var additionalClass = ' tui-chart-xaxis-rotation tui-chart-xaxis-rotation' + degree;\n        var halfWidth = labelSize / 2;\n        var moveLeft = calculator.calculateAdjacent(degree, halfWidth);\n        var top = calculator.calculateOpposite(degree, halfWidth) + chartConst.XAXIS_LABEL_TOP_MARGIN;\n        var spanCssText = (renderUtil.isIE7() &amp;&amp; degree) ? chartConst.IE7_ROTATION_FILTER_STYLE_MAP[degree] : '';\n        var labelsHtml;\n\n        additionalSize = additionalSize || 0;\n        labelsHtml = tui.util.map(positions, function(position, index) {\n            var label = categories[index],\n                rotationCssText = self._makeCssTextForRotationMoving({\n                    size: areaSize,\n                    labelHeight: labelHeight,\n                    labelWidth: labelSize,\n                    top: top,\n                    left: position + additionalSize,\n                    moveLeft: moveLeft,\n                    label: label,\n                    theme: self.theme.label\n                });\n\n            return template({\n                additionalClass: additionalClass,\n                cssText: labelCssText + rotationCssText,\n                spanCssText: spanCssText,\n                label: label\n            });\n        }).join('');\n\n        return labelsHtml;\n    },\n\n    /**\n     * Make html of normal labels.\n     * @param {Array.&lt;object>} positions label position array\n     * @param {string[]} categories categories\n     * @param {number} labelSize label size\n     * @param {number} additionalSize additional size\n     * @returns {string} labels html\n     * @private\n     */\n    _makeNormalLabelsHtml: function(positions, categories, labelSize, additionalSize) {\n        var template = axisTemplate.tplAxisLabel,\n            labelCssText = this._makeLabelCssText(labelSize),\n            posType, labelsHtml;\n\n        if (this.isVertical) {\n            posType = this.isLabel ? 'top' : 'bottom';\n        } else {\n            posType = 'left';\n        }\n\n        labelsHtml = tui.util.map(positions, function(position, index) {\n            var addCssText = renderUtil.concatStr(posType, ':', (position + additionalSize), '%');\n\n            return template({\n                additionalClass: '',\n                cssText: labelCssText + addCssText,\n                label: categories[index],\n                spanCssText: ''\n            });\n        }).join('');\n\n        return labelsHtml;\n    },\n\n    /**\n     * Make labels html.\n     * @param {number} areaSize - area size\n     * @param {Array.&lt;object>} positions - positions for labels\n     * @param {Array.&lt;string>} categories - categories\n     * @param {number} labelSize label size\n     * @param {number} additionalSize additional size\n     * @returns {string} labels html\n     * @private\n     */\n    _makeLabelsHtml: function(areaSize, positions, categories, labelSize, additionalSize) {\n        var isRotationlessXAxis = !this.isVertical &amp;&amp; this.isLabel &amp;&amp; this.options.rotateLabel === false;\n        var hasRotatedXAxisLabel = this.componentName === 'xAxis' &amp;&amp; this.data.degree;\n        var labelsHtml;\n\n        if (isRotationlessXAxis) {\n            categories = this.data.multilineLabels;\n        }\n\n        if (categories.length) {\n            positions.length = categories.length;\n        }\n\n        positions = this._makePercentagePositions(positions, areaSize);\n\n        if (hasRotatedXAxisLabel) {\n            labelsHtml = this._makeRotationLabelsHtml(areaSize, positions, categories, labelSize, additionalSize);\n        } else {\n            labelsHtml = this._makeNormalLabelsHtml(positions, categories, labelSize, additionalSize);\n        }\n\n        return labelsHtml;\n    },\n\n    /**\n     * Change position of label area.\n     * @param {HTMLElement} labelContainer label area element\n     * @param {number} labelSize label size (width or height)\n     * @private\n     */\n    _changeLabelAreaPosition: function(labelContainer, labelSize) {\n        var labelHeight;\n\n        if (this.isLabel &amp;&amp; !this.data.aligned) {\n            return;\n        }\n\n        if (this.isVertical) {\n            labelHeight = renderUtil.getRenderedLabelHeight('ABC', this.theme.label);\n            labelContainer.style.top = renderUtil.concatStr(parseInt(labelHeight / 2, 10), 'px');\n        } else {\n            labelContainer.style.left = renderUtil.concatStr('-', parseInt(labelSize / 2, 10), 'px');\n        }\n    }\n});\n\nmodule.exports = Axis;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"