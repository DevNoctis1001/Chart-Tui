ne.util.defineNamespace("fedoc.content", {});
fedoc.content["series_pieChartSeries.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Pie chart series component.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar Series = require('./series'),\n    chartConst = require('../const'),\n    dom = require('../helpers/domHandler'),\n    renderUtil = require('../helpers/renderUtil');\n\nvar PieChartSeries = tui.util.defineClass(Series, /** @lends PieChartSeries.prototype */ {\n    /**\n     * Line chart series component.\n     * @constructs PieChartSeries\n     * @extends Series\n     * @param {object} params parameters\n     *      @param {object} params.model series model\n     *      @param {object} params.options series options\n     *      @param {object} params.theme series theme\n     */\n    init: function() {\n        Series.apply(this, arguments);\n    },\n\n    /**\n     * To make percent value.\n     * @param {{values: array, scale: {min: number, max: number}}} data series data\n     * @returns {array.&lt;array.&lt;number>>} percent values\n     * @private\n     */\n    _makePercentValues: function(data) {\n        var result = tui.util.map(data.values, function(values) {\n            var sum = tui.util.sum(values);\n            return tui.util.map(values, function(value) {\n                return value / sum;\n            });\n        });\n        return result;\n    },\n\n    /**\n     * To make sectors information.\n     * @param {array.&lt;number>} percentValues percent values\n     * @param {{cx: number, cy: number, r: number}} circleBound circle bound\n     * @returns {array.&lt;object>} sectors information\n     * @private\n     */\n    _makeSectorsInfo: function(percentValues, circleBound) {\n        var cx = circleBound.cx,\n            cy = circleBound.cy,\n            r = circleBound.r,\n            angle = 0,\n            delta = 10,\n            paths;\n\n        paths = tui.util.map(percentValues, function(percentValue) {\n            var addAngle = chartConst.ANGLE_360 * percentValue,\n                endAngle = angle + addAngle,\n                popupAngle = angle + (addAngle / 2),\n                angles = {\n                    start: {\n                        startAngle: angle,\n                        endAngle: angle\n                    },\n                    end: {\n                        startAngle: angle,\n                        endAngle: endAngle\n                    }\n                },\n                positionData = {\n                    cx: cx,\n                    cy: cy,\n                    angle: popupAngle\n                };\n            angle = endAngle;\n            return {\n                percentValue: percentValue,\n                angles: angles,\n                popupPosition: this._getArcPosition(tui.util.extend({\n                    r: r + delta\n                }, positionData)),\n                centerPosition: this._getArcPosition(tui.util.extend({\n                    r: (r / 2) + delta\n                }, positionData)),\n                outerPosition: {\n                    start: this._getArcPosition(tui.util.extend({\n                        r: r\n                    }, positionData)),\n                    middle: this._getArcPosition(tui.util.extend({\n                        r: r + delta\n                    }, positionData))\n                }\n            };\n        }, this);\n\n        return paths;\n    },\n\n    /**\n     * To make series data.\n     * @returns {{\n     *      formattedValues: array,\n     *      chartBackground: string,\n     *      circleBound: ({cx: number, cy: number, r: number}),\n     *      sectorsInfo: array.&lt;object>\n     * }} add data for graph rendering\n     */\n    makeSeriesData: function() {\n        var circleBound = this._makeCircleBound(this.bound.dimension, {\n                showLabel: this.options.showLabel,\n                legendType: this.options.legendType\n            }),\n            sectorsInfo = this._makeSectorsInfo(this.percentValues[0], circleBound);\n\n        this.popupPositions = tui.util.pluck(sectorsInfo, 'popupPosition');\n        return {\n            chartBackground: this.chartBackground,\n            circleBound: circleBound,\n            sectorsInfo: sectorsInfo\n        };\n    },\n\n    /**\n     * To make circle bound\n     * @param {{width: number, height:number}} dimension chart dimension\n     * @param {{showLabel: boolean, legendType: string}} options options\n     * @returns {{cx: number, cy: number, r: number}} circle bounds\n     * @private\n     */\n    _makeCircleBound: function(dimension, options) {\n        var width = dimension.width,\n            height = dimension.height,\n            isSmallPie = options.legendType === chartConst.SERIES_LEGEND_TYPE_OUTER &amp;&amp; options.showLabel,\n            radiusRate = isSmallPie ? chartConst.PIE_GRAPH_SMALL_RATE : chartConst.PIE_GRAPH_DEFAULT_RATE,\n            diameter = tui.util.multiplication(tui.util.min([width, height]), radiusRate);\n        return {\n            cx: tui.util.division(width, 2),\n            cy: tui.util.division(height, 2),\n            r: tui.util.division(diameter, 2)\n        };\n    },\n\n    /**\n     * Get arc position.\n     * @param {object} params parameters\n     *      @param {number} params.cx center x\n     *      @param {number} params.cy center y\n     *      @param {number} params.r radius\n     *      @param {number} params.angle angle(degree)\n     * @returns {{left: number, top: number}} arc position\n     * @private\n     */\n    _getArcPosition: function(params) {\n        return {\n            left: params.cx + (params.r * Math.sin(params.angle * chartConst.RAD)),\n            top: params.cy - (params.r * Math.cos(params.angle * chartConst.RAD))\n        };\n    },\n\n\n    /**\n     * To make add data for series label.\n     * @param {HTMLElement} container container\n     * @returns {{\n     *      container: HTMLElement,\n     *      legendLabels: array.&lt;string>,\n     *      options: {legendType: string, showLabel: boolean},\n     *      chartWidth: number,\n     *      formattedValues: array\n     * }} add data for make series label\n     * @private\n     */\n    _makeSeriesDataForSeriesLabel: function(container) {\n        return {\n            container: container,\n            legendLabels: this.data.legendLabels,\n            options: {\n                legendType: this.options.legendType,\n                showLabel: this.options.showLabel\n            },\n            chartWidth: this.data.chartWidth,\n            formattedValues: this.data.formattedValues[0]\n        };\n    },\n\n    /**\n     * Get series label.\n     * @param {object} params parameters\n     *      @param {string} params.legend legend\n     *      @param {string} params.label label\n     *      @param {string} params.separator separator\n     *      @param {{legendType: boolean, showLabel: boolean}} params.options options\n     * @returns {string} series label\n     * @private\n     */\n    _getSeriesLabel: function(params) {\n        var seriesLabel = '';\n        if (params.options.legendType) {\n            seriesLabel = params.legend;\n        }\n\n        if (params.options.showLabel) {\n            seriesLabel += (seriesLabel ? params.separator : '') + params.label;\n        }\n\n        return seriesLabel;\n    },\n\n    /**\n     * Render center legend.\n     * @param {object} params parameters\n     *      @param {HTMLElement} container container\n     *      @param {array.&lt;string>} legends legends\n     *      @param {array.&lt;object>} centerPositions center positions\n     * @return {HTMLElement} series area element\n     * @private\n     */\n    _renderLegendLabel: function(params) {\n        var positions = params.positions,\n            formattedValues = params.formattedValues,\n            elSeriesLabelArea = dom.create('div', 'tui-chart-series-label-area'),\n            html;\n\n        html = tui.util.map(params.legendLabels, function(legend, index) {\n            var label = this._getSeriesLabel({\n                    legend: legend,\n                    label: formattedValues[index],\n                    separator: params.separator,\n                    options: params.options\n                }),\n                position = params.moveToPosition(positions[index], label);\n            return this.makeSeriesLabelHtml(position, label, 0, index);\n        }, this).join('');\n\n        elSeriesLabelArea.innerHTML = html;\n        params.container.appendChild(elSeriesLabelArea);\n\n        return elSeriesLabelArea;\n    },\n\n    /**\n     * Move to center position.\n     * @param {{left: number, top: number}} position position\n     * @param {string} label label\n     * @returns {{left: number, top: number}} center position\n     * @private\n     */\n    _moveToCenterPosition: function(position, label) {\n        var left = position.left - (renderUtil.getRenderedLabelWidth(label, this.theme.label) / 2),\n            top = position.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);\n        return {\n            left: left,\n            top: top\n        };\n    },\n\n    /**\n     * Render center legend.\n     * @param {object} params parameters\n     *      @param {HTMLElement} container container\n     *      @param {array.&lt;string>} legends legends\n     *      @param {array.&lt;object>} centerPositions center positions\n     * @return {HTMLElement} area element\n     * @private\n     */\n    _renderCenterLegend: function(params) {\n        var elArea = this._renderLegendLabel(tui.util.extend({\n            positions: tui.util.pluck(params.sectorsInfo, 'centerPosition'),\n            moveToPosition: tui.util.bind(this._moveToCenterPosition, this),\n            separator: '&lt;br>'\n        }, params));\n\n        return elArea;\n    },\n\n    /**\n     * Add end position.\n     * @param {number} centerLeft center left\n     * @param {array.&lt;object>} positions positions\n     * @private\n     */\n    _addEndPosition: function(centerLeft, positions) {\n        tui.util.forEach(positions, function(position) {\n            var end = tui.util.extend({}, position.middle);\n            if (end.left &lt; centerLeft) {\n                end.left -= chartConst.SERIES_OUTER_LABEL_PADDING;\n            } else {\n                end.left += chartConst.SERIES_OUTER_LABEL_PADDING;\n            }\n            position.end = end;\n        });\n    },\n\n    /**\n     * Move to outer position.\n     * @param {number} centerLeft center left\n     * @param {object} position position\n     * @param {string} label label\n     * @returns {{left: number, top: number}} outer position\n     * @private\n     */\n    _moveToOuterPosition: function(centerLeft, position, label) {\n        var positionEnd = position.end,\n            left = positionEnd.left,\n            top = positionEnd.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);\n\n        if (left &lt; centerLeft) {\n            left -= renderUtil.getRenderedLabelWidth(label, this.theme.label) + chartConst.SERIES_LABEL_PADDING;\n        } else {\n            left += chartConst.SERIES_LABEL_PADDING;\n        }\n\n        return {\n            left: left,\n            top: top\n        };\n    },\n\n    /**\n     * Render outer legend.\n     * @param {object} params parameters\n     *      @param {HTMLElement} container container\n     *      @param {array.&lt;string>} legends legends\n     *      @param {array.&lt;object>} centerPositions center positions\n     * @return {HTMLElement} area element\n     * @private\n     */\n    _renderOuterLegend: function(params) {\n        var outerPositions = tui.util.pluck(params.sectorsInfo, 'outerPosition'),\n            centerLeft = params.chartWidth / 2,\n            elArea;\n\n        this._addEndPosition(centerLeft, outerPositions);\n        elArea = this._renderLegendLabel(tui.util.extend({\n            positions: outerPositions,\n            moveToPosition: tui.util.bind(this._moveToOuterPosition, this, centerLeft),\n            separator: ':&amp;nbsp;'\n        }, params));\n\n        if (this.paper) {\n            this.graphRenderer.renderLegendLines(this.paper, outerPositions);\n        }\n\n        return elArea;\n    },\n\n    /**\n     * Render series label.\n     * @param {object} params parameters\n     * @returns {HTMLElement} area element\n     * @private\n     */\n    _renderSeriesLabel: function(params) {\n        var elArea;\n        if (params.options.legendType === chartConst.SERIES_LEGEND_TYPE_OUTER) {\n            elArea = this._renderOuterLegend(params);\n        } else {\n            elArea = this._renderCenterLegend(params);\n        }\n        return elArea;\n    },\n\n    /**\n     * Get bound.\n     * @param {number} groupIndex group index\n     * @param {number} index index\n     * @returns {{left: number, top: number}} bound\n     * @private\n     */\n    _getBound: function(groupIndex, index) {\n        if (groupIndex === -1 || index === -1) {\n            return null;\n        }\n        return this.popupPositions[index];\n    },\n\n    /**\n     * Show series label area.\n     */\n    showSeriesLabelArea: function() {\n        this.graphRenderer.animateLegendLines();\n        Series.prototype.showSeriesLabelArea.call(this);\n    }\n});\n\nmodule.exports = PieChartSeries;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"