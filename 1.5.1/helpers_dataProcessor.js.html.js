tui.util.defineNamespace("fedoc.content", {});
fedoc.content["helpers_dataProcessor.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Data processor.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar predicate = require('./predicate'),\n    renderUtil = require('./renderUtil'),\n    calculator = require('./calculator');\n\nvar concat = Array.prototype.concat;\n\n/**\n * Raw data.\n * @typedef {Array.&lt;{name: string, data: Array.&lt;number>}>} rawSeriesData\n */\n\nvar DataProcessor = tui.util.defineClass(/** @lends DataProcessor.prototype */{\n    /**\n     * Data processor.\n     * @constructs DataProcessor\n     * @param {{\n     *      categories: Array.&lt;string>,\n     *      series: (rawSeriesData | {line: ?rawSeriesData, column: ?rawSeriesData})\n     * }} rawData raw data\n     */\n    init: function(rawData) {\n        this.orgRawData = rawData;\n        this.data = null;\n    },\n\n    /**\n     * Get raw data.\n     * @returns {{categories: Array.&lt;string>, series: (rawSeriesData|{line: ?rawSeriesData, column: ?rawSeriesData})}} raw data\n     */\n    getRawData: function() {\n        return this.orgRawData;\n    },\n\n    /**\n     * Process raw data.\n     * @param {Array.&lt;Array>} rawData raw data\n     * @param {object} options options\n     * @param {Array.&lt;string>} seriesChartTypes chart types\n     */\n    process: function(rawData, options, seriesChartTypes) {\n        var chartType = options.chartType,\n            categories = this._processCategories(rawData.categories),\n            seriesData = rawData.series,\n            values = this._pickValues(seriesData),\n            wholeValues = this._makeWholeValues(values, seriesChartTypes),\n            legendLabels = this._pickLegendLabels(seriesData),\n            wholeLegendData = this._makeWholeLegendData(legendLabels, chartType, seriesChartTypes),\n            format = options.chart &amp;&amp; options.chart.format || '',\n            formatFunctions = this._findFormatFunctions(format),\n            seriesOption = options.series || {},\n            formattedValues, wholeFormattedValues;\n\n        this.divergingOption = predicate.isBarTypeChart(options.chartType) &amp;&amp; seriesOption.diverging;\n        formattedValues = this._formatValues(values, formatFunctions);\n        wholeFormattedValues = this._makeWholeValues(formattedValues, seriesChartTypes);\n\n        this.data = {\n            categories: categories,\n            values: values,\n            wholeValues: wholeValues,\n            legendLabels: legendLabels,\n            wholeLegendData: wholeLegendData,\n            formatFunctions: formatFunctions,\n            formattedValues: formattedValues,\n            wholeFormattedValues: wholeFormattedValues,\n            percentValues: {}\n        };\n    },\n\n    /**\n     * Get Categories\n     * @returns {Array.&lt;string>}}\n     */\n    getCategories: function() {\n        return this.data.categories;\n    },\n\n    /**\n     * Get category.\n     * @param {number} index index\n     * @returns {string} category\n     */\n    getCategory: function(index) {\n        return this.data.categories[index];\n    },\n\n    /**\n     * Get group values.\n     * @param {string} chartType chart type\n     * @returns {Array.Array.&lt;number>} group values\n     */\n    getGroupValues: function(chartType) {\n        return this.data.values[chartType] || this.data.values;\n    },\n\n    /**\n     * Get value.\n     * @param {number} groupIndex group index\n     * @param {number} index index\n     * @param {?string} chartType chart type\n     * @returns {number} value\n     */\n    getValue: function(groupIndex, index, chartType) {\n        var groupValues = this.getGroupValues(chartType);\n        return groupValues[groupIndex][index];\n    },\n\n    /**\n     * Get whole group values.\n     * @returns {Array.&lt;Array.&lt;number>>} gruop values\n     */\n    getWholeGroupValues: function() {\n        return this.data.wholeValues;\n    },\n\n    /**\n     * Get legend labels.\n     * @param {?string} chartType chart type\n     * @returns {Array.&lt;string> | {column: ?Array.&lt;string>, line: ?Array.&lt;string>}} legend labels\n     */\n    getLegendLabels: function(chartType) {\n        return this.data.legendLabels[chartType] || this.data.legendLabels;\n    },\n\n    /**\n     * Get whole legend data.\n     * @returns {Array.&lt;string>} legend data\n     */\n    getWholeLegendData: function() {\n        return this.data.wholeLegendData;\n    },\n\n    /**\n     * Set whole legend data.\n     * @param {Array.&lt;{chartType: string, label: string}>} wholeLegendData legend data\n     */\n    setWholeLegendData: function(wholeLegendData) {\n        this.data.wholeLegendData = wholeLegendData;\n    },\n\n    /**\n     * Get legend data.\n     * @param {number} index index\n     * @returns {{chartType: string, label: string}} legend data\n     */\n    getLegendData: function(index) {\n        return this.data.wholeLegendData[index];\n    },\n\n    /**\n     * Get format functions.\n     * @returns {Array.&lt;function>} functions\n     */\n    getFormatFunctions: function() {\n        return this.data.formatFunctions;\n    },\n\n    /**\n     * Get formatted group values\n     * @param {string} chartType chart type\n     * @returns {Array.&lt;string>} group values\n     */\n    getFormattedGroupValues: function(chartType) {\n        return this.data.formattedValues[chartType] || this.data.formattedValues;\n    },\n\n    /**\n     * Get formatted value.\n     * @param {number} groupIndex group index\n     * @param {number} index index\n     * @param {?string} chartType chartType\n     * @returns {string} formatted value\n     */\n    getFormattedValue: function(groupIndex, index, chartType) {\n        var formattedGroupValues = this.getFormattedGroupValues(chartType);\n        return formattedGroupValues[groupIndex][index];\n    },\n\n    /**\n     * Get first formatted vlaue.\n     * @param {?string} chartType chartType\n     * @returns {string} formatted value\n     */\n    getFirstFormattedValue: function(chartType) {\n        return this.getFormattedValue(0, 0, chartType);\n    },\n\n    /**\n     * Get whole formatted values.\n     * @returns {Array.Array.&lt;string>} formatted values\n     */\n    getWholeFormattedValues: function() {\n        return this.data.wholeFormattedValues;\n    },\n\n    /**\n     * Process categories\n     * @param {Array.&lt;string>} categories categories\n     * @returns {Array.&lt;string>} processed categories\n     * @private\n     */\n    _processCategories: function(categories) {\n        return tui.util.map(categories, tui.util.encodeHTMLEntity);\n    },\n\n    /**\n     * Pick value.\n     * @param {{name: string, data: (Array.&lt;number> | number)}} items items\n     * @returns {Array} picked value\n     * @private\n     */\n    _pickValue: function(items) {\n        return tui.util.map([].concat(items.data), parseFloat);\n    },\n\n    /**\n     * Pick values from axis data.\n     * @param {Array.&lt;Array>} seriesData series data\n     * @returns {string[]} values\n     */\n    _pickValues: function(seriesData) {\n        var values, result;\n        if (tui.util.isArray(seriesData)) {\n            values = tui.util.map(seriesData, this._pickValue, this);\n            result = tui.util.pivot(values);\n        } else {\n            result = {};\n            tui.util.forEach(seriesData, function(groupValues, type) {\n                values = tui.util.map(groupValues, this._pickValue, this);\n                result[type] = tui.util.pivot(values);\n            }, this);\n        }\n        return result;\n    },\n\n    /**\n     * Make whole values.\n     * @param {Array.&lt;Array>} groupValues values\n     * @param {Array.&lt;string>} seriesChartTypes chart types\n     * @returns {Array.&lt;number>} join values\n     * @private\n     */\n    _makeWholeValues: function(groupValues, seriesChartTypes) {\n        var wholeValues = [];\n\n        if (!seriesChartTypes) {\n            wholeValues = groupValues;\n        } else {\n            tui.util.forEachArray(seriesChartTypes, function(_chartType) {\n                tui.util.forEach(groupValues[_chartType], function(values, index) {\n                    if (!wholeValues[index]) {\n                        wholeValues[index] = [];\n                    }\n                    wholeValues[index] = wholeValues[index].concat(values);\n                });\n            });\n        }\n\n        return wholeValues;\n    },\n\n    /**\n     * Pick legend label.\n     * @param {object} item item\n     * @returns {string} label\n     * @private\n     */\n    _pickLegendLabel: function(item) {\n        return tui.util.encodeHTMLEntity(item.name);\n    },\n\n    /**\n     * Pick legend labels from axis data.\n     * @param {Array.&lt;Array>} seriesData series data\n     * @returns {string[]} labels\n     */\n    _pickLegendLabels: function(seriesData) {\n        var result;\n        if (tui.util.isArray(seriesData)) {\n            result = tui.util.map(seriesData, this._pickLegendLabel, this);\n        } else {\n            result = {};\n            tui.util.forEach(seriesData, function(groupValues, type) {\n                result[type] = tui.util.map(groupValues, this._pickLegendLabel, this);\n            }, this);\n        }\n        return result;\n    },\n\n    /**\n     * Make whole legend data.\n     * @param {Array} legendLabels legend labels\n     * @param {string} chartType chart type\n     * @param {Array.&lt;string>} seriesChartTypes chart types\n     * @returns {Array} labels\n     * @private\n     */\n    _makeWholeLegendData: function(legendLabels, chartType, seriesChartTypes) {\n        var wholeLabels;\n        if (!seriesChartTypes || !seriesChartTypes.length) {\n            wholeLabels = tui.util.map(legendLabels, function(label) {\n                return {\n                    chartType: chartType,\n                    label: label\n                };\n            });\n        } else {\n            wholeLabels = [];\n            tui.util.forEachArray(seriesChartTypes, function(_chartType) {\n                var labels = tui.util.map(legendLabels[_chartType], function(label) {\n                    return {\n                        chartType: _chartType,\n                        label: label\n                    };\n                });\n                wholeLabels = wholeLabels.concat(labels);\n            });\n        }\n        return wholeLabels;\n    },\n\n    /**\n     * Format group values.\n     * @param {Array.&lt;Array>} groupValues group values\n     * @param {function[]} formatFunctions format functions\n     * @returns {string[]} formatted values\n     * @private\n     */\n    _formatGroupValues: function(groupValues, formatFunctions) {\n        return tui.util.map(groupValues, function(values) {\n            if (this.divergingOption) {\n                values = tui.util.map(values, Math.abs);\n            }\n            return tui.util.map(values, function(value) {\n                var fns = [value].concat(formatFunctions);\n                return tui.util.reduce(fns, function(stored, fn) {\n                    return fn(stored);\n                });\n            });\n        }, this);\n    },\n\n    /**\n     * Format converted values.\n     * @param {Array.&lt;Array>} chartValues chart values\n     * @param {function[]} formatFunctions format functions\n     * @returns {string[]} formatted values\n     * @private\n     */\n    _formatValues: function(chartValues, formatFunctions) {\n        var result;\n        formatFunctions = formatFunctions || [];\n        if (tui.util.isArray(chartValues)) {\n            result = this._formatGroupValues(chartValues, formatFunctions);\n        } else {\n            result = {};\n            tui.util.forEach(chartValues, function(groupValues, chartType) {\n                result[chartType] = this._formatGroupValues(groupValues, formatFunctions);\n            }, this);\n        }\n        return result;\n    },\n\n    /**\n     * Pick max length under point.\n     * @param {string[]} values chart values\n     * @returns {number} max length under point\n     * @private\n     */\n    _pickMaxLenUnderPoint: function(values) {\n        var max = 0;\n\n        tui.util.forEachArray(values, function(value) {\n            var len = tui.util.lengthAfterPoint(value);\n            if (len > max) {\n                max = len;\n            }\n        }, this);\n\n        return max;\n    },\n\n    /**\n     * Whether zero fill format or not.\n     * @param {string} format format\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isZeroFill: function(format) {\n        return format.length > 2 &amp;&amp; format.charAt(0) === '0';\n    },\n\n    /**\n     * Whether decimal format or not.\n     * @param {string} format format\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isDecimal: function(format) {\n        var indexOf = format.indexOf('.');\n        return indexOf > -1 &amp;&amp; indexOf &lt; format.length - 1;\n    },\n\n    /**\n     * Whether comma format or not.\n     * @param {string} format format\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isComma: function(format) {\n        return format.indexOf(',') === format.split('.')[0].length - 4;\n    },\n\n    /**\n     * Format zero fill.\n     * @param {number} len length of result\n     * @param {string} value target value\n     * @returns {string} formatted value\n     * @private\n     */\n    _formatZeroFill: function(len, value) {\n        var zero = '0',\n            isMinus = value &lt; 0;\n\n        value = Math.abs(value) + '';\n\n        if (value.length >= len) {\n            return value;\n        }\n\n        while (value.length &lt; len) {\n            value = zero + value;\n        }\n\n        return (isMinus ? '-' : '') + value;\n    },\n\n    /**\n     * Format Decimal.\n     * @param {number} len length of under decimal point\n     * @param {string} value target value\n     * @returns {string} formatted value\n     * @private\n     */\n    _formatDecimal: function(len, value) {\n        var pow;\n\n        if (len === 0) {\n            return Math.round(value, 10);\n        }\n\n        pow = Math.pow(10, len);\n        value = Math.round(value * pow) / pow;\n        value = parseFloat(value).toFixed(len);\n        return value;\n    },\n\n    /**\n     * Format Comma.\n     * @param {string} value target value\n     * @returns {string} formatted value\n     * @private\n     */\n    _formatComma: function(value) {\n        var comma = ',',\n            underPointValue = '',\n            values, lastIndex;\n\n        value += '';\n\n        if (value.indexOf('.') > -1) {\n            values = value.split('.');\n            value = values[0];\n            underPointValue = '.' + values[1];\n        }\n\n        if (value.length &lt; 4) {\n            return value + underPointValue;\n        }\n\n        values = (value).split('').reverse();\n        lastIndex = values.length - 1;\n        values = tui.util.map(values, function(char, index) {\n            var result = [char];\n            if (index &lt; lastIndex &amp;&amp; (index + 1) % 3 === 0) {\n                result.push(comma);\n            }\n            return result;\n        });\n\n        return concat.apply([], values).reverse().join('') + underPointValue;\n    },\n\n    /**\n     * Find format functions.\n     * @param {string} format format\n     * @param {string[]} values chart values\n     * @returns {function[]} functions\n     */\n    _findFormatFunctions: function(format) {\n        var funcs = [],\n            len;\n\n        if (!format) {\n            return [];\n        }\n\n        if (this._isDecimal(format)) {\n            len = this._pickMaxLenUnderPoint([format]);\n            funcs = [tui.util.bind(this._formatDecimal, this, len)];\n        } else if (this._isZeroFill(format)) {\n            len = format.length;\n            funcs = [tui.util.bind(this._formatZeroFill, this, len)];\n            return funcs;\n        }\n\n        if (this._isComma(format)) {\n            funcs.push(this._formatComma);\n        }\n\n        return funcs;\n    },\n\n    /**\n     * Make multiline category.\n     * @param {string} category category\n     * @param {number} limitWidth limit width\n     * @param {object} theme label theme\n     * @returns {string} multiline category\n     * @private\n     */\n    _makeMultilineCategory: function(category, limitWidth, theme) {\n        var words = category.split(/\\s+/),\n            lineWords = words[0],\n            lines = [];\n\n        tui.util.forEachArray(words.slice(1), function(word) {\n            var width = renderUtil.getRenderedLabelWidth(lineWords + ' ' + word, theme);\n\n            if (width > limitWidth) {\n                lines.push(lineWords);\n                lineWords = word;\n            } else {\n                lineWords += ' ' + word;\n            }\n        });\n\n        if (lineWords) {\n            lines.push(lineWords);\n        }\n\n        return lines.join('&lt;br>');\n    },\n\n    /**\n     * Get multiline categories.\n     * @param {number} limitWidth limit width\n     * @param {object} theme label theme\n     * @returns {Array} multiline categories\n     */\n    getMultilineCategories: function(limitWidth, theme) {\n        if (!this.data.multilineCategories) {\n            this.data.multilineCategories = tui.util.map(this.getCategories(), function(category) {\n                return this._makeMultilineCategory(category, limitWidth, theme);\n            }, this);\n        }\n\n        return this.data.multilineCategories;\n    },\n\n    /**\n     * Make percent value.\n     * @param {Array.&lt;Array.&lt;number>>} groupValues gruop values\n     * @returns {Array.&lt;Array.&lt;number>>} percent values\n     * @private\n     */\n    _makePieChartPercentValues: function(groupValues) {\n        var result = tui.util.map(groupValues, function(values) {\n            var sum = tui.util.sum(values);\n\n            return tui.util.map(values, function(value) {\n                return value / sum;\n            });\n        });\n        return result;\n    },\n\n    /**\n     * Make percent values for normal stacked option.\n     * @param {Array.&lt;Array.&lt;number>>} groupValues gruop values\n     * @param {{min: number, max: number}} limit axis limit\n     * @returns {Array} percent values about normal stacked option.\n     * @private\n     */\n    _makeNormalStackedPercentValues: function(groupValues, limit) {\n        var distance = Math.abs(limit.max - limit.min);\n\n        return tui.util.map(groupValues, function(values) {\n            return tui.util.map(values, function(value) {\n                return value / distance;\n            });\n        });\n    },\n\n    /**\n     * Make percent values for percent stacked option.\n     * @param {Array.&lt;Array.&lt;number>>} groupValues gruop values\n     * @returns {Array} percent values about percent stacked option\n     * @private\n     */\n    _makePercentStackedPercentValues: function(groupValues) {\n        var flattenValues = concat.apply([], groupValues),\n            plusSum = calculator.sumPlusValues(flattenValues),\n            minusSum = Math.abs(calculator.sumMinusValues(flattenValues)),\n            ratio = (plusSum > 0 &amp;&amp; minusSum > 0) ? 0.5 : 1;\n\n        return tui.util.map(groupValues, function(values) {\n            var sum = tui.util.sum(tui.util.map(values, function(value) {\n                return Math.abs(value);\n            }));\n\n            return tui.util.map(values, function(value) {\n                return sum === 0 ? 0 : ratio * (value / sum);\n            });\n        });\n    },\n\n    /**\n     * Make percent values for percent diverging stacked option.\n     * @param {Array.&lt;Array.&lt;number>>} groupValues group values\n     * @returns {Array.&lt;Array.&lt;number>>} percent values\n     * @private\n     */\n    _makePercentDivergentStackedPercentValues: function(groupValues) {\n        return tui.util.map(groupValues, function(values) {\n            var plusSum = calculator.sumPlusValues(values),\n                minusSum = Math.abs(calculator.sumMinusValues(values));\n\n            return tui.util.map(values, function(value) {\n                var sum = value >= 0 ? plusSum : minusSum;\n                return sum === 0 ? 0 : 0.5 * (value / sum);\n            });\n        });\n    },\n\n    /**\n     * Make percent value.\n     * @param {Array.&lt;Array.&lt;number>>} groupValues group values\n     * @param {{min: number, max: number}} limit axis limit\n     * @param {boolean} isLineTypeChart whether line type chart or not.\n     * @returns {Array.&lt;Array.&lt;number>>} percent values\n     * @private\n     */\n    _makePercentValues: function(groupValues, limit, isLineTypeChart) {\n        var min = limit.min,\n            max = limit.max,\n            distance = max - min,\n            flag = 1,\n            subValue = 0,\n            percentValues;\n\n        if (!isLineTypeChart &amp;&amp; min &lt; 0 &amp;&amp; max &lt;= 0) {\n            flag = -1;\n            subValue = max;\n            distance = min - max;\n        } else if (isLineTypeChart || min >= 0) {\n            subValue = min;\n        }\n\n        percentValues = tui.util.map(groupValues, function(values) {\n            return tui.util.map(values, function(value) {\n                return (value - subValue) * flag / distance;\n            });\n        });\n\n        return percentValues;\n    },\n\n    /**\n     * Register percent values.\n     * @param {string} chartType chart type\n     */\n    registerPieChartPercentValues: function(chartType) {\n        var groupValues = this.getGroupValues(chartType);\n        this.data.percentValues[chartType] = this._makePieChartPercentValues(groupValues);\n    },\n\n    /**\n     * Register percent values.\n     * @param {{min: number, max: number}} limit axis limit\n     * @param {string} stacked stacked option\n     * @param {string} chartType chart type\n     * @private\n     */\n    registerPercentValues: function(limit, stacked, chartType) {\n        var result,\n            groupValues = this.getGroupValues(chartType),\n            isAllowedStackedOption = predicate.isAllowedStackedOption(chartType),\n            isLineTypeChart = predicate.isLineTypeChart(chartType);\n\n        if (isAllowedStackedOption &amp;&amp; predicate.isNormalStacked(stacked)) {\n            result = this._makeNormalStackedPercentValues(groupValues, limit);\n        } else if (isAllowedStackedOption &amp;&amp; predicate.isPercentStacked(stacked)) {\n            if (this.divergingOption) {\n                result = this._makePercentDivergentStackedPercentValues(groupValues);\n            } else {\n                result = this._makePercentStackedPercentValues(groupValues);\n            }\n        } else {\n            result = this._makePercentValues(groupValues, limit, isLineTypeChart);\n        }\n\n        this.data.percentValues[chartType] = isLineTypeChart ? tui.util.pivot(result) : result;\n    },\n\n    /**\n     * Get percent values.\n     * @param {string} chartType chart type\n     * @returns {Array.&lt;Array.&lt;number>>} percent values\n     */\n    getPercentValues: function(chartType) {\n        return this.data.percentValues[chartType];\n    }\n});\n\nmodule.exports = DataProcessor;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"