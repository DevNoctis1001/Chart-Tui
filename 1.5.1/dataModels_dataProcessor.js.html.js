tui.util.defineNamespace("fedoc.content", {});
fedoc.content["dataModels_dataProcessor.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Data processor.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar ItemGroup = require('../dataModels/itemGroup'),\n    predicate = require('../helpers/predicate'),\n    rawDataHandler = require('../helpers/rawDataHandler'),\n    renderUtil = require('../helpers/renderUtil');\n\nvar concat = Array.prototype.concat;\n\n/**\n * Raw series datum.\n * @typedef {{name: ?string, data: Array.&lt;number>, stack: ?string}} rawSeriesDatum\n */\n\n/**\n * Raw series data.\n * @typedef {Array.&lt;rawSeriesDatum>} rawSeriesData\n */\n\n/**\n * Raw data.\n * @typedef {{\n *      categories: ?Array.&lt;string>,\n *      series: (rawSeriesData|{line: ?rawSeriesData, column: ?rawSeriesData})\n * }} rawData\n */\n\nvar DataProcessor = tui.util.defineClass(/** @lends DataProcessor.prototype */{\n    /**\n     * Data processor.\n     * @constructs DataProcessor\n     * @param {rawData} rawData raw data\n     * @param {object} options options\n     * @param {Array.&lt;string>} seriesChartTypes chart types\n     */\n    init: function(rawData, options, seriesChartTypes) {\n        var seriesOption = options.series || {};\n\n        /**\n         * original raw data.\n         * @type {{categories: ?Array.&lt;string>, series: Array.&lt;object>}}\n         */\n        this.orgRawData = rawData;\n\n        /**\n         * chart options\n         * @type {Object}\n         */\n        this.options = options;\n\n        /**\n         * series chart types\n         * @type {Array.&lt;string>}\n         */\n        this.seriesChartTypes = seriesChartTypes;\n\n        /**\n         * diverging option\n         * @type {boolean}\n         */\n        this.divergingOption = predicate.isBarTypeChart(options.chartType) &amp;&amp; seriesOption.diverging;\n\n        this.updateRawData(rawData);\n    },\n\n    /**\n     * Get raw data.\n     * @returns {rawData} raw data\n     */\n    getRawData: function() {\n        return this.orgRawData;\n    },\n\n    /**\n     * Update raw data.\n     * @param {rawData} rawData raw data\n     */\n    updateRawData: function(rawData) {\n        /**\n         * raw data\n         * @type {rawData}\n         */\n        this.rawData = rawData;\n\n        /**\n         * categories\n         * @type {Array.&lt;string>}\n         */\n        this.categories = null;\n\n        /**\n         * stacks\n         * @type {Array.&lt;number>}\n         */\n        this.stacks = null;\n\n        /**\n         * Item group\n         * @type {ItemGroup}\n         */\n        this.itemGroup = null;\n\n        /**\n         * legend labels\n         * @type {{column: Array.&lt;string>, line: Array.&lt;string> | Array.&lt;string>}}\n         */\n        this.legendLabels = null;\n\n        /**\n         * whole legend data\n         * @type {Array.&lt;object>}\n         */\n        this.wholeLegendData = null;\n\n        /**\n         * functions for formatting\n         * @type {Array.&lt;function>}\n         */\n        this.formatFunctions = null;\n\n        /**\n         * multiline categories\n         * @type {Array.&lt;string>}\n         */\n        this.multilineCategories = null;\n    },\n\n    /**\n     * Process categories\n     * @param {Array.&lt;string>} categories categories\n     * @returns {Array.&lt;string>} processed categories\n     * @private\n     */\n    _processCategories: function(categories) {\n        return tui.util.map(categories, tui.util.encodeHTMLEntity);\n    },\n\n    /**\n     * Get Categories\n     * @returns {Array.&lt;string>}}\n     */\n    getCategories: function() {\n        if (!this.categories) {\n            this.categories = this._processCategories(this.rawData.categories);\n        }\n\n        return this.categories;\n    },\n\n    /**\n     * Get category.\n     * @param {number} index index\n     * @returns {string} category\n     */\n    getCategory: function(index) {\n        return this.getCategories()[index];\n    },\n\n    /**\n     * Get stacks.\n     * @returns {Array.&lt;string>}\n     */\n    getStacks: function() {\n        if (!this.stacks) {\n            this.stacks = rawDataHandler.pickStacks(this.rawData.series);\n        }\n\n        return this.stacks;\n    },\n\n    /**\n     * Get stack count.\n     * @returns {Number}\n     */\n    getStackCount: function() {\n        return this.getStacks().length;\n    },\n\n    /**\n     * Find stack index.\n     * @param {string} stack stack\n     * @returns {number}\n     */\n    findStackIndex: function(stack) {\n        return tui.util.inArray(stack, this.getStacks());\n    },\n\n\n    /**\n     * Get ItemGroup.\n     * @returns {ItemGroup}\n     */\n    getItemGroup: function() {\n        if (!this.itemGroup) {\n            this.itemGroup = new ItemGroup(this.rawData.series, this.options,\n                this.seriesChartTypes, this.getFormatFunctions());\n        }\n\n        return this.itemGroup;\n    },\n\n    /**\n     * Get group count.\n     * @param {string} chartType chart type\n     * @returns {number}\n     */\n    getGroupCount: function(chartType) {\n        return this.getItemGroup().getGroupCount(chartType);\n    },\n\n    /**\n     * Whether valid all group or not.\n     * @returns {boolean}\n     */\n    isValidAllGroup: function() {\n        return this.getItemGroup().isValidAllGroup();\n    },\n\n    /**\n     * Get whole group items.\n     * @returns {Array.&lt;Items>}\n     */\n    getWholeGroups: function() {\n        return this.getItemGroup().getWholeGroups();\n    },\n\n    /**\n     * Get value.\n     * @param {number} groupIndex group index\n     * @param {number} index index\n     * @param {?string} chartType chart type\n     * @returns {number} value\n     */\n    getValue: function(groupIndex, index, chartType) {\n        return this.getItemGroup().getValue(groupIndex, index, chartType);\n    },\n\n    /**\n     * Get whole values.\n     * @returns {Array.&lt;number>} values\n     */\n    getWholeValues: function() {\n        return this.getItemGroup().getWholeValues();\n    },\n\n    /**\n     * Get values.\n     * @param {string} chartType chart type\n     * @returns {Array.&lt;number>}\n     */\n    getValues: function(chartType) {\n        return this.getItemGroup().getValues(chartType);\n    },\n\n    /**\n     * Get legend labels.\n     * @param {?string} chartType chart type\n     * @returns {Array.&lt;string> | {column: ?Array.&lt;string>, line: ?Array.&lt;string>}} legend labels\n     */\n    getLegendLabels: function(chartType) {\n        if (!this.legendLabels) {\n            this.legendLabels = this._pickLegendLabels();\n        }\n        return this.legendLabels[chartType] || this.legendLabels;\n    },\n\n    /**\n     * Get whole legend data.\n     * @returns {Array.&lt;string>} legend data\n     */\n    getWholeLegendData: function() {\n        if (!this.wholeLegendData) {\n            this.wholeLegendData = this._makeWholeLegendData();\n        }\n        return this.wholeLegendData;\n    },\n\n    /**\n     * Set whole legend data.\n     * @param {Array.&lt;{chartType: string, label: string}>} wholeLegendData legend data\n     */\n    setWholeLegendData: function(wholeLegendData) {\n        this.wholeLegendData = wholeLegendData;\n    },\n\n    /**\n     * Get legend data.\n     * @param {number} index index\n     * @returns {{chartType: string, label: string}} legend data\n     */\n    getLegendData: function(index) {\n        return this.getWholeLegendData()[index];\n    },\n\n    /**\n     * Get format functions.\n     * @returns {Array.&lt;function>} functions\n     */\n    getFormatFunctions: function() {\n        if (!this.formatFunctions) {\n            this.formatFunctions = this._findFormatFunctions();\n        }\n\n        return this.formatFunctions;\n    },\n\n    /**\n     * Get first formatted vlaue.\n     * @param {?string} chartType chartType\n     * @returns {string} formatted value\n     */\n    getFirstFormattedValue: function(chartType) {\n        return this.getItemGroup().getFirstItem(chartType).formattedValue;\n    },\n\n    /**\n     * Pick legend label.\n     * @param {object} item item\n     * @returns {string} label\n     * @private\n     */\n    _pickLegendLabel: function(item) {\n        return tui.util.encodeHTMLEntity(item.name);\n    },\n\n    /**\n     * Pick legend labels from raw data.\n     * @returns {string[]} labels\n     */\n    _pickLegendLabels: function() {\n        var self = this,\n            seriesData = this.rawData.series,\n            result;\n        if (tui.util.isArray(seriesData)) {\n            result = tui.util.map(seriesData, this._pickLegendLabel);\n        } else {\n            result = {};\n            tui.util.forEach(seriesData, function(seriesDatum, type) {\n                result[type] = tui.util.map(seriesDatum, self._pickLegendLabel);\n            });\n        }\n\n        return result;\n    },\n\n    /**\n     * Make whole legend data.\n     * @returns {Array} labels\n     * @private\n     */\n    _makeWholeLegendData: function() {\n        var self = this,\n            legendLabels = this.getLegendLabels(),\n            seriesChartTypes = this.seriesChartTypes,\n            wholeLabels;\n\n        if (!seriesChartTypes || !seriesChartTypes.length) {\n            wholeLabels = tui.util.map(legendLabels, function(label) {\n                return {\n                    chartType: self.options.chartType,\n                    label: label\n                };\n            });\n        } else {\n            wholeLabels = [];\n            tui.util.forEachArray(seriesChartTypes, function(chartType) {\n                var labels = tui.util.map(legendLabels[chartType], function(label) {\n                    return {\n                        chartType: chartType,\n                        label: label\n                    };\n                });\n                wholeLabels = wholeLabels.concat(labels);\n            });\n        }\n\n        return wholeLabels;\n    },\n\n    /**\n     * Pick max length under point.\n     * @param {string[]} values chart values\n     * @returns {number} max length under point\n     * @private\n     */\n    _pickMaxLenUnderPoint: function(values) {\n        var max = 0;\n\n        tui.util.forEachArray(values, function(value) {\n            var len = tui.util.lengthAfterPoint(value);\n            if (len > max) {\n                max = len;\n            }\n        });\n\n        return max;\n    },\n\n    /**\n     * Whether zero fill format or not.\n     * @param {string} format format\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isZeroFill: function(format) {\n        return format.length > 2 &amp;&amp; format.charAt(0) === '0';\n    },\n\n    /**\n     * Whether decimal format or not.\n     * @param {string} format format\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isDecimal: function(format) {\n        var indexOf = format.indexOf('.');\n\n        return indexOf > -1 &amp;&amp; indexOf &lt; format.length - 1;\n    },\n\n    /**\n     * Whether comma format or not.\n     * @param {string} format format\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isComma: function(format) {\n        return format.indexOf(',') > -1;\n    },\n\n    /**\n     * Format zero fill.\n     * @param {number} len length of result\n     * @param {string} value target value\n     * @returns {string} formatted value\n     * @private\n     */\n    _formatZeroFill: function(len, value) {\n        var zero = '0',\n            isMinus = value &lt; 0;\n\n        value = String(Math.abs(value));\n\n        if (value.length >= len) {\n            return value;\n        }\n\n        while (value.length &lt; len) {\n            value = zero + value;\n        }\n\n        return (isMinus ? '-' : '') + value;\n    },\n\n    /**\n     * Format Decimal.\n     * @param {number} len length of under decimal point\n     * @param {string} value target value\n     * @returns {string} formatted value\n     * @private\n     */\n    _formatDecimal: function(len, value) {\n        var pow;\n\n        if (len === 0) {\n            return Math.round(value);\n        }\n\n        pow = Math.pow(10, len);\n        value = Math.round(value * pow) / pow;\n        value = parseFloat(value).toFixed(len);\n\n        return value;\n    },\n\n    /**\n     * Format Comma.\n     * @param {string} value target value\n     * @returns {string} formatted value\n     * @private\n     */\n    _formatComma: function(value) {\n        var comma = ',',\n            underPointValue = '',\n            betweenLen = 3,\n            orgValue = value,\n            sign, values, lastIndex, formattedValue;\n\n        value = String(value);\n        sign = value.indexOf('-') > -1 ? '-' : '';\n\n        if (value.indexOf('.') > -1) {\n            values = value.split('.');\n            value = String(Math.abs(values[0]));\n            underPointValue = '.' + values[1];\n        } else {\n            value = String(Math.abs(value));\n        }\n\n        if (value.length &lt;= betweenLen) {\n            formattedValue = orgValue;\n        } else {\n            values = (value).split('').reverse();\n            lastIndex = values.length - 1;\n            values = tui.util.map(values, function(char, index) {\n                var result = [char];\n                if (index &lt; lastIndex &amp;&amp; (index + 1) % betweenLen === 0) {\n                    result.push(comma);\n                }\n                return result;\n            });\n            formattedValue = sign + concat.apply([], values).reverse().join('') + underPointValue;\n        }\n\n        return formattedValue;\n    },\n\n    /**\n     * Find format functions.\n     * @returns {function[]} functions\n     */\n    _findFormatFunctions: function() {\n        var format = tui.util.pick(this.options, 'chart', 'format') || '',\n            funcs = [],\n            len;\n\n        if (!format) {\n            return [];\n        }\n\n        if (this._isDecimal(format)) {\n            len = this._pickMaxLenUnderPoint([format]);\n            funcs = [tui.util.bind(this._formatDecimal, this, len)];\n        } else if (this._isZeroFill(format)) {\n            len = format.length;\n            funcs = [tui.util.bind(this._formatZeroFill, this, len)];\n            return funcs;\n        }\n\n        if (this._isComma(format)) {\n            funcs.push(this._formatComma);\n        }\n\n        return funcs;\n    },\n\n    /**\n     * Make multiline category.\n     * @param {string} category category\n     * @param {number} limitWidth limit width\n     * @param {object} theme label theme\n     * @returns {string} multiline category\n     * @private\n     */\n    _makeMultilineCategory: function(category, limitWidth, theme) {\n        var words = category.split(/\\s+/),\n            lineWords = words[0],\n            lines = [];\n\n        tui.util.forEachArray(words.slice(1), function(word) {\n            var width = renderUtil.getRenderedLabelWidth(lineWords + ' ' + word, theme);\n\n            if (width > limitWidth) {\n                lines.push(lineWords);\n                lineWords = word;\n            } else {\n                lineWords += ' ' + word;\n            }\n        });\n\n        if (lineWords) {\n            lines.push(lineWords);\n        }\n\n        return lines.join('&lt;br>');\n    },\n\n    /**\n     * Get multiline categories.\n     * @param {number} limitWidth limit width\n     * @param {object} theme label theme\n     * @returns {Array} multiline categories\n     */\n    getMultilineCategories: function(limitWidth, theme) {\n        var self = this;\n\n        if (!this.multilineCategories) {\n            this.multilineCategories = tui.util.map(this.getCategories(), function(category) {\n                return self._makeMultilineCategory(category, limitWidth, theme);\n            });\n        }\n\n        return this.multilineCategories;\n    },\n\n    /**\n     * Make sum map per stack.\n     * @param {items} items items\n     * @returns {object} sum map\n     * @private\n     */\n    _makeSumMapPerStack: function(items) {\n        var sumMap = {};\n        tui.util.forEachArray(items, function(item) {\n            if (!sumMap[item.stack]) {\n                sumMap[item.stack] = 0;\n            }\n\n            sumMap[item.stack] += Math.abs(item.value);\n        });\n\n        return sumMap;\n    },\n\n    /**\n     * Add data ratios of pie chart.\n     */\n    addDataRatiosOfPieChart: function() {\n        this.getItemGroup().addDataRatiosOfPieChart();\n    },\n\n    /**\n     * Update start value of item.\n     * @param {{min: number, max: number}} limit - limit\n     * @param {string} chartType - chart type\n     * @private\n     */\n    _updateItemStart: function(limit, chartType) {\n        var isOneSign = limit.min >= 0 || predicate.isMinusLimit(limit),\n            start = 0;\n\n        if (isOneSign) {\n            start = limit.min;\n        }\n\n        this.getItemGroup().updateItemStart(start, chartType);\n    },\n\n    /**\n     * Register percent values.\n     * @param {{min: number, max: number}} limit axis limit\n     * @param {string} stacked stacked option\n     * @param {string} chartType chart type\n     * @private\n     */\n    addDataRatios: function(limit, stacked, chartType) {\n        var itemGroup = this.getItemGroup();\n\n        this._updateItemStart(limit, chartType);\n        itemGroup.addDataRatios(limit, stacked, chartType);\n    }\n});\n\nmodule.exports = DataProcessor;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"