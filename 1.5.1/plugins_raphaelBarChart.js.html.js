tui.util.defineNamespace("fedoc.content", {});
fedoc.content["plugins_raphaelBarChart.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Raphael bar chart renderer.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\nvar raphaelRenderUtil = require('./raphaelRenderUtil');\n\nvar raphael = window.Raphael;\n\nvar ANIMATION_TIME = 700,\n    EMPHASIS_OPACITY = 1,\n    DE_EMPHASIS_OPACITY = 0.3,\n    DEFAULT_LUMINANC = 0.2;\n\n/**\n * @classdesc RaphaelBarChart is graph renderer for bar, column chart.\n * @class RaphaelBarChart\n */\nvar RaphaelBarChart = tui.util.defineClass(/** @lends RaphaelBarChart.prototype */ {\n    /**\n     * Render function of bar chart\n     * @param {HTMLElement} container container element\n     * @param {{size: object, model: object, options: object, tooltipPosition: string}} data chart data\n     * @returns {object} paper raphael paper\n     */\n    render: function(container, data) {\n        var groupBounds = data.groupBounds,\n            dimension = data.dimension,\n            paper;\n\n        if (!groupBounds) {\n            return null;\n        }\n\n        this.paper = paper = raphael(container, dimension.width, dimension.height);\n\n        this.theme = data.theme;\n        this.itemGroup = data.itemGroup;\n        this.chartType = data.chartType;\n\n        this.groupBars = this._renderBars(groupBounds);\n        this.groupBorders = this._renderBarBorders(groupBounds);\n\n        this.overlay = this._renderOverlay();\n        this.theme = data.theme;\n        this.groupBounds = groupBounds;\n        this.chartType = data.chartType;\n\n        return paper;\n    },\n\n    /**\n     * Render overlay.\n     * @returns {object} raphael object\n     * @private\n     */\n    _renderOverlay: function() {\n        var rect = this._renderBar({\n            bound: {\n                width: 1,\n                height: 1,\n                left: 0,\n                top: 0\n            },\n            color: '#fff'\n        }).attr({\n            'fill-opacity': 0\n        });\n\n        return rect;\n    },\n\n    /**\n     * Render rect\n     * @param {{left: number, top: number, width: number, height: number}} bound bound\n     * @param {string} color series color\n     * @returns {object} bar rect\n     * @private\n     */\n    _renderBar: function(bound, color) {\n        var rect;\n\n        if (bound.width &lt; 0 || bound.height &lt; 0) {\n            return null;\n        }\n\n        rect = this.paper.rect(bound.left, bound.top, bound.width, bound.height);\n        rect.attr({\n            fill: color,\n            stroke: 'none'\n        });\n\n        return rect;\n    },\n\n    /**\n     * Render bars.\n     * @param {Array.&lt;Array.&lt;{left: number, top:number, width: number, height: number}>>} groupBounds bounds\n     * @returns {Array.&lt;Array.&lt;object>>} bars\n     * @private\n     */\n    _renderBars: function(groupBounds) {\n        var self = this,\n            singleColors = [],\n            colors = this.theme.colors,\n            groupBars;\n\n        if ((groupBounds[0].length === 1) &amp;&amp; this.theme.singleColors) {\n            singleColors = this.theme.singleColors;\n        }\n\n        groupBars = tui.util.map(groupBounds, function(bounds, groupIndex) {\n            var singleColor = singleColors[groupIndex];\n\n            return tui.util.map(bounds, function(bound, index) {\n                var color, rect, item;\n\n                if (!bound) {\n                    return null;\n                }\n\n                item = self.itemGroup.getItem(groupIndex, index, self.chartType);\n\n                color = singleColor || colors[index];\n                rect = self._renderBar(bound.start, color);\n\n                return {\n                    rect: rect,\n                    color: color,\n                    bound: bound.end,\n                    item: item,\n                    groupIndex: groupIndex,\n                    index: index,\n                    isRange: item.isRange\n                };\n            });\n        });\n\n        return groupBars;\n    },\n\n    /**\n     * Make rect points.\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @returns {{\n     *      leftTop: {left: number, top: number},\n     *      rightTop: {left: number, top: number},\n     *      rightBottom: {left: number, top: number},\n     *      leftBottom: {left: number, top: number}\n     * }} rect points\n     * @private\n     */\n    _makeRectPoints: function(bound) {\n        return {\n            leftTop: {\n                left: Math.ceil(bound.left),\n                top: Math.ceil(bound.top)\n            },\n            rightTop: {\n                left: Math.ceil(bound.left + bound.width),\n                top: Math.ceil(bound.top)\n            },\n            rightBottom: {\n                left: Math.ceil(bound.left + bound.width),\n                top: Math.ceil(bound.top + bound.height)\n            },\n            leftBottom: {\n                left: Math.ceil(bound.left),\n                top: Math.ceil(bound.top + bound.height)\n            }\n        };\n    },\n\n    /**\n     * Make top line path.\n     * @param {object} points points\n     *      @param {{left: number, top: number}} points.leftTop left top\n     *      @param {{left: number, top: number}} points.rightTop right top\n     * @param {string} chartType chart type\n     * @param {Item} item item\n     * @returns {string} top line path\n     * @private\n     */\n    _makeTopLinePath: function(points, chartType, item) {\n        var linePath = null,\n            value = item.value,\n            cloneLeftTop;\n\n        if (chartType === 'bar' || value >= 0 || item.isRange) {\n            cloneLeftTop = tui.util.extend({}, points.leftTop);\n            cloneLeftTop.left -= chartType === 'column' || value &lt; 0 ? 1 : 0;\n            linePath = raphaelRenderUtil.makeLinePath(cloneLeftTop, points.rightTop).join(' ');\n        }\n\n        return linePath;\n    },\n\n    /**\n     * Make right line path.\n     * @param {object} points points\n     *      @param {{left: number, top: number}} points.rightTop right top\n     *      @param {{left: number, top: number}} points.rightBottom right bottom\n     * @param {string} chartType chart type\n     * @param {Item} item item\n     * @returns {string} top line path\n     * @private\n     */\n    _makeRightLinePath: function(points, chartType, item) {\n        var linePath = null;\n\n        if (chartType === 'column' || item.value >= 0 || item.isRange) {\n            linePath = raphaelRenderUtil.makeLinePath(points.rightTop, points.rightBottom).join(' ');\n        }\n\n        return linePath;\n    },\n\n    /**\n     * Make bottom line path.\n     * @param {object} points points\n     *      @param {{left: number, top: number}} points.lefBottom left bottom\n     *      @param {{left: number, top: number}} points.rightBottom right bottom\n     * @param {string} chartType chart type\n     * @param {Item} item item\n     * @returns {string} top line path\n     * @private\n     */\n    _makeBottomLinePath: function(points, chartType, item) {\n        var linePath = null;\n\n        if (chartType === 'bar' || item.value &lt; 0 || item.isRange) {\n            linePath = raphaelRenderUtil.makeLinePath(points.leftBottom, points.rightBottom).join(' ');\n        }\n\n        return linePath;\n    },\n\n    /**\n     * Make left line path.\n     * @param {object} points points\n     *      @param {{left: number, top: number}} points.lefTop left top\n     *      @param {{left: number, top: number}} points.leftBottom left bottom\n     * @param {string} chartType chart type\n     * @param {Item} item item\n     * @returns {string} top line path\n     * @private\n     */\n    _makeLeftLinePath: function(points, chartType, item) {\n        var linePath = null;\n\n        if (chartType === 'column' || item.value &lt; 0 || item.isRange) {\n            linePath = raphaelRenderUtil.makeLinePath(points.leftTop, points.leftBottom).join(' ');\n        }\n\n        return linePath;\n    },\n\n    /**\n     * Make border lines paths.\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @param {string} chartType chart type\n     * @param {Item} item item\n     * @returns {{top: string, right: string, bottom: string, left: string}} paths\n     * @private\n     */\n    _makeBorderLinesPaths: function(bound, chartType, item) {\n        var points = this._makeRectPoints(bound),\n            paths = {\n                top: this._makeTopLinePath(points, chartType, item),\n                right: this._makeRightLinePath(points, chartType, item),\n                bottom: this._makeBottomLinePath(points, chartType, item),\n                left: this._makeLeftLinePath(points, chartType, item)\n            };\n\n        return tui.util.filter(paths, function(path) {\n            return path;\n        });\n    },\n\n    /**\n     * Render border lines;\n     * @param {{left: number, top:number, width: number, height: number}} bound bar bound\n     * @param {string} borderColor border color\n     * @param {string} chartType chart type\n     * @param {Item} item item\n     * @returns {object} raphael object\n     * @private\n     */\n    _renderBorderLines: function(bound, borderColor, chartType, item) {\n        var self = this,\n            borderLinePaths = this._makeBorderLinesPaths(bound, chartType, item),\n            lines = {};\n\n        tui.util.forEach(borderLinePaths, function(path, name) {\n            lines[name] = raphaelRenderUtil.renderLine(self.paper, path, borderColor, 1);\n        });\n\n        return lines;\n    },\n\n    /**\n     * Render bar borders.\n     * @param {Array.&lt;Array.&lt;{left: number, top:number, width: number, height: number}>>} groupBounds bounds\n     * @returns {Array.&lt;Array.&lt;object>>} borders\n     * @private\n     */\n    _renderBarBorders: function(groupBounds) {\n        var self = this,\n            borderColor = this.theme.borderColor,\n            groupBorders;\n\n        if (!borderColor) {\n            return null;\n        }\n\n        groupBorders = tui.util.map(groupBounds, function(bounds, groupIndex) {\n            return tui.util.map(bounds, function(bound, index) {\n                var item;\n\n                if (!bound) {\n                    return null;\n                }\n\n                item = self.itemGroup.getItem(groupIndex, index, self.chartType);\n\n                return self._renderBorderLines(bound.start, borderColor, self.chartType, item);\n            });\n        });\n\n        return groupBorders;\n    },\n\n    /**\n     * Animate rect.\n     * @param {object} rect raphael object\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @private\n     */\n    _animateRect: function(rect, bound) {\n        rect.animate({\n            x: bound.left,\n            y: bound.top,\n            width: bound.width,\n            height: bound.height\n        }, ANIMATION_TIME);\n    },\n\n    /**\n     * Animate borders.\n     * @param {Array.&lt;object>} lines raphael objects\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @param {string} chartType chart type\n     * @param {Item} item item\n     * @private\n     */\n    _animateBorders: function(lines, bound, chartType, item) {\n        var paths = this._makeBorderLinesPaths(bound, chartType, item);\n\n        tui.util.forEach(lines, function(line, name) {\n            line.animate({path: paths[name]}, ANIMATION_TIME);\n        });\n    },\n\n    /**\n     * Animate.\n     * @param {function} onFinish finish callback function\n     */\n    animate: function(onFinish) {\n        var self = this,\n            groupBorders = this.groupBorders || [];\n\n        if (this.callbackTimeout) {\n            clearTimeout(this.callbackTimeout);\n            delete this.callbackTimeout;\n        }\n        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {\n            var lines = groupBorders[groupIndex] &amp;&amp; groupBorders[groupIndex][index];\n            if (!bar) {\n                return;\n            }\n            self._animateRect(bar.rect, bar.bound);\n            if (lines) {\n                self._animateBorders(lines, bar.bound, self.chartType, bar.item);\n            }\n        });\n\n        if (onFinish) {\n            this.callbackTimeout = setTimeout(function() {\n                onFinish();\n                delete self.callbackTimeout;\n            }, ANIMATION_TIME);\n        }\n    },\n\n    /**\n     * Show animation.\n     * @param {{groupIndex: number, index:number}} data show info\n     */\n    showAnimation: function(data) {\n        var bar = this.groupBars[data.groupIndex][data.index],\n            bound = bar.bound;\n        this.overlay.attr({\n            width: bound.width,\n            height: bound.height,\n            x: bound.left,\n            y: bound.top,\n            'fill-opacity': 0.3\n        });\n    },\n\n    /**\n     * Hide animation.\n     */\n    hideAnimation: function() {\n        this.overlay.attr({\n            width: 1,\n            height: 1,\n            x: 0,\n            y: 0,\n            'fill-opacity': 0\n        });\n    },\n\n    /**\n     * Update rect bound\n     * @param {object} rect raphael object\n     * @param {{left: number, top: number, width: number, height: number}} bound bound\n     * @private\n     */\n    _updateRectBound: function(rect, bound) {\n        rect.attr({\n            x: bound.left,\n            y: bound.top,\n            width: bound.width,\n            height: bound.height\n        });\n    },\n\n    /**\n     * Update borders attribute\n     * @param {Array.&lt;object>} lines raphael objects\n     * @param {{left: number, top: number, width: number, height: number}} bound bound\n     * @param {string} chartType chart type\n     * @param {Item} item item\n     * @private\n     */\n    _updateBordersPath: function(lines, bound, chartType, item) {\n        var paths = this._makeBorderLinesPaths(bound, chartType, item);\n\n        tui.util.forEach(lines, function(line, name) {\n            line.attr({path: paths[name]});\n        });\n    },\n\n    /**\n     * Resize graph of bar type chart.\n     * @param {object} params parameters\n     *      @param {{width: number, height:number}} params.dimension dimension\n     *      @param {Array.&lt;Array.&lt;{\n     *                  left:number, top:number, width: number, height: number\n     *              }>>} params.groupBounds group bounds\n     */\n    resize: function(params) {\n        var self = this,\n            groupBorders = this.groupBorders || [],\n            dimension = params.dimension,\n            groupBounds = params.groupBounds;\n\n        this.groupBounds = groupBounds;\n        this.paper.setSize(dimension.width, dimension.height);\n\n        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {\n            var lines, bound;\n\n            if (!bar) {\n                return;\n            }\n\n            lines = groupBorders[groupIndex] &amp;&amp; groupBorders[groupIndex][index];\n            bound = groupBounds[groupIndex][index].end;\n            bar.bound = bound;\n            self._updateRectBound(bar.rect, bound);\n\n            if (lines) {\n                self._updateBordersPath(lines, bound, self.chartType, bar.item);\n            }\n        });\n    },\n\n    /**\n     * Change borders color.\n     * @param {Array.&lt;object>} lines raphael objects\n     * @param {borderColor} borderColor border color\n     * @private\n     */\n    _changeBordersColor: function(lines, borderColor) {\n        tui.util.forEach(lines, function(line) {\n            line.attr({stroke: borderColor});\n        });\n    },\n\n    /**\n     * Change bar color.\n     * @param {{groupIndex: number, index: number}} indexes indexes\n     * @param {string} color fill color\n     * @param {?string} borderColor stroke color\n     * @private\n     */\n    _changeBarColor: function(indexes, color, borderColor) {\n        var bar = this.groupBars[indexes.groupIndex][indexes.index],\n            lines;\n\n        bar.rect.attr({\n            fill: color\n        });\n\n        if (borderColor) {\n            lines = this.groupBorders[indexes.groupIndex][indexes.index];\n            this._changeBordersColor(lines, borderColor);\n        }\n    },\n\n    /**\n     * Select series.\n     * @param {{groupIndex: number, index: number}} indexes indexes\n     */\n    selectSeries: function(indexes) {\n        var bar = this.groupBars[indexes.groupIndex][indexes.index],\n            objColor = raphael.color(bar.color),\n            selectionColorTheme = this.theme.selectionColor,\n            color = selectionColorTheme || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC),\n            borderColor = this.theme.borderColor,\n            objBorderColor;\n\n        if (borderColor) {\n            objBorderColor = raphael.color(borderColor);\n            borderColor = raphaelRenderUtil.makeChangedLuminanceColor(objBorderColor.hex, DEFAULT_LUMINANC);\n        }\n\n        this._changeBarColor(indexes, color, borderColor);\n    },\n\n    /**\n     * Unselect series.\n     * @param {{groupIndex: number, index: number}} indexes indexes\n     */\n    unselectSeries: function(indexes) {\n        var bar = this.groupBars[indexes.groupIndex][indexes.index],\n            borderColor = this.theme.borderColor;\n        this._changeBarColor(indexes, bar.color, borderColor);\n    },\n\n    /**\n     * Select legend.\n     * @param {?number} legendIndex legend index\n     */\n    selectLegend: function(legendIndex) {\n        var groupBorders = this.groupBorders || [],\n            noneSelected = tui.util.isNull(legendIndex);\n\n        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {\n            var lines, opacity;\n\n            if (!bar) {\n                return;\n            }\n\n            lines = groupBorders[groupIndex] &amp;&amp; groupBorders[groupIndex][index];\n            opacity = (noneSelected || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;\n\n            bar.rect.attr({'fill-opacity': opacity});\n            if (lines) {\n                tui.util.forEach(lines, function(line) {\n                    line.attr({'stroke-opacity': opacity});\n                });\n            }\n        });\n    }\n});\n\nmodule.exports = RaphaelBarChart;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"