tui.util.defineNamespace("fedoc.content", {});
fedoc.content["plugins_raphaelPieChart.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview RaphaelPieCharts is graph renderer for pie chart.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar raphaelRenderUtil = require('./raphaelRenderUtil');\n\nvar raphael = window.Raphael,\n    DEGREE_180 = 180,\n    DEGREE_360 = 360,\n    MIN_DEGREE = 0.01,\n    RAD = Math.PI / DEGREE_180,\n    ANIMATION_TIME = 500,\n    LOADING_ANIMATION_TIME = 700,\n    EMPHASIS_OPACITY = 1,\n    DE_EMPHASIS_OPACITY = 0.3,\n    DEFAULT_LUMINANC = 0.2;\n\n/**\n * @classdesc RaphaelPieCharts is graph renderer for pie chart.\n * @class RaphaelPieChart\n */\nvar RaphaelPieChart = tui.util.defineClass(/** @lends RaphaelPieChart.prototype */ {\n    /**\n     * Render function of pie chart.\n     * @param {HTMLElement} container container\n     * @param {{\n     *      sectorData: Array.&lt;object>,\n     *      circleBound: {cx: number, cy: number, r: number},\n     *      dimension: object, theme: object, options: object\n     * }} data render data\n     * @param {object} callbacks callbacks\n     *      @param {function} callbacks.funcShowTooltip show tooltip function\n     *      @param {function} callbacks.funcHideTooltip hide tooltip function\n     *      @param {function} callbacks.funcSelectSeries select series function\n     * @returns {object} paper raphael paper\n     */\n    render: function(container, data, callbacks) {\n        var dimension = data.dimension,\n            paper;\n\n        //Raphael._oid = 0;\n        this.paper = paper = raphael(container, dimension.width, dimension.height);\n\n        if (!paper.customAttributes.sector) {\n            paper.customAttributes.sector = tui.util.bind(this._makeSectorPath, this);\n        }\n\n        this.container = container;\n        this.callbacks = callbacks;\n        this.selectionColor = data.theme.selectionColor;\n        this.circleBound = data.circleBound;\n\n        this._renderPie(paper, data);\n        return paper;\n    },\n\n    /**\n     * Clear paper.\n     */\n    clear: function() {\n        this.paper.clear();\n    },\n    /**\n     * Make sector path.\n     * @param {number} cx center x\n     * @param {number} cy center y\n     * @param {number} r radius\n     * @param {number} startAngle start angle\n     * @param {number} endAngle end angel\n     * @returns {{path: Array}} sector path\n     * @private\n     */\n    _makeSectorPath: function(cx, cy, r, startAngle, endAngle) {\n        var x1 = cx + r * Math.sin(startAngle * RAD), // 원 호의 시작 x 좌표\n            y1 = cy - r * Math.cos(startAngle * RAD), // 원 호의 시작 y 좌표\n            x2 = cx + r * Math.sin(endAngle * RAD), // 원 호의 종료 x 좌표\n            y2 = cy - r * Math.cos(endAngle * RAD), // 원 호의 종료 y 좌표\n            largeArcFlag = endAngle - startAngle > DEGREE_180 ? 1 : 0,\n            path = ['M', cx, cy,\n                'L', x1, y1,\n                'A', r, r, 0, largeArcFlag, 1, x2, y2,\n                'Z'\n            ];\n        // path에 대한 자세한 설명은 아래 링크를 참고\n        // http://www.w3schools.com/svg/svg_path.asp\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n        return {path: path};\n    },\n\n    /**\n     * Render sector\n     * @param {object} params parameters\n     *      @param {object} params.paper raphael paper\n     *      @param {{cx: number, cy: number, r:number}} params.circleBound circle bounds\n     *      @param {number} params.startAngle start angle\n     *      @param {number} params.endAngle end angle\n     *      @param {{fill: string, stroke: string, strike-width: string}} params.attrs attrs\n     * @returns {object} raphael object\n     * @private\n     */\n    _renderSector: function(params) {\n        var circleBound = params.circleBound,\n            angles = params.angles;\n\n        return params.paper.path().attr({\n            sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]\n        }).attr(params.attrs);\n    },\n\n    /**\n     * Render pie graph.\n     * @param {object} paper raphael paper\n     * @param {{\n     *      sectorData: Array.&lt;object>,\n     *      circleBound: {cx: number, cy: number, r: number},\n     *      dimension: object, theme: object, options: object\n     * }} data render data\n     * @private\n     */\n    _renderPie: function(paper, data) {\n        var self = this,\n            circleBound = data.circleBound,\n            colors = data.theme.colors,\n            chartBackground = data.chartBackground,\n            sectors = [];\n\n        tui.util.forEachArray(data.sectorData, function(sectorDatum, index) {\n            var percentValue = sectorDatum.percentValue,\n                color = colors[index],\n                sector = self._renderSector({\n                    paper: paper,\n                    circleBound: circleBound,\n                    angles: sectorDatum.angles.start,\n                    attrs: {\n                        fill: color,\n                        stroke: chartBackground,\n                        'stroke-width': 1\n                    }\n                });\n            sector.data('index', index);\n            sectors.push({\n                sector: sector,\n                color: color,\n                angles: sectorDatum.angles.end,\n                percentValue: percentValue\n            });\n        });\n\n        this.sectors = sectors;\n    },\n\n    /**\n     * Render legend lines.\n     * @param {Array.&lt;object>} outerPositions outer position\n     */\n    renderLegendLines: function(outerPositions) {\n        var paper = this.paper,\n            paths;\n\n        if (!this.legendLines) {\n            paths = this._makeLinePaths(outerPositions);\n            this.legendLines = tui.util.map(paths, function(path) {\n                return raphaelRenderUtil.renderLine(paper, path, 'transparent', 1);\n            });\n        }\n    },\n\n    /**\n     * Make line paths.\n     * @param {Array.&lt;object>} outerPositions outer positions\n     * @returns {Array} line paths.\n     * @private\n     */\n    _makeLinePaths: function(outerPositions) {\n        var paths = tui.util.map(outerPositions, function(positions) {\n            return [\n                raphaelRenderUtil.makeLinePath(positions.start, positions.middle),\n                raphaelRenderUtil.makeLinePath(positions.middle, positions.end),\n                'Z'\n            ].join('');\n        });\n\n        return paths;\n    },\n\n    /**\n     * Expand selector radius.\n     * @param {object} sector pie sector\n     */\n    _expandSector: function(sector) {\n        var cx = this.circleBound.cx,\n            cy = this.circleBound.cy;\n\n        sector.animate({\n            transform: 's1.1 1.1 ' + cx + ' ' + cy\n        }, ANIMATION_TIME, 'elastic');\n    },\n\n    /**\n     * Restore selector radius.\n     * @param {object} sector pie sector\n     */\n    _restoreSector: function(sector) {\n        sector.animate({transform: ''}, ANIMATION_TIME, 'elastic');\n    },\n\n    /**\n     * animate expanding.\n     * @param {number} index sector index\n     */\n    _animateExpanding: function(index) {\n        var sector = this.sectors[index].sector;\n\n        if (this.prevMovedSector) {\n            this._animateRestoring(this.prevMovedSector.data('index'));\n        }\n\n        this._expandSector(sector);\n    },\n\n    /**\n     * Animate restoring.\n     * @param {number} index sector index\n     */\n    _animateRestoring: function(index) {\n        var sector = this.sectors[index].sector;\n        this._restoreSector(sector);\n    },\n\n    /**\n     * Animate.\n     * @param {function} callback callback\n     */\n    animate: function(callback) {\n        var delayTime = 0,\n            circleBound = this.circleBound;\n\n        tui.util.forEachArray(this.sectors, function(item) {\n            var angles = item.angles,\n                animationTime, anim;\n\n            if (angles.startAngle === 0 &amp;&amp; angles.endAngle === DEGREE_360) {\n                angles.endAngle = DEGREE_360 - MIN_DEGREE;\n            }\n\n            animationTime = LOADING_ANIMATION_TIME * item.percentValue;\n            anim = raphael.animation({\n                sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]\n            }, animationTime);\n\n            item.sector.animate(anim.delay(delayTime));\n            delayTime += animationTime;\n        });\n\n        if (callback) {\n            setTimeout(callback, delayTime);\n        }\n    },\n\n    /**\n     * Animate legend lines.\n     */\n    animateLegendLines: function() {\n        if (!this.legendLines) {\n            return;\n        }\n\n        tui.util.forEachArray(this.legendLines, function(line) {\n            line.animate({\n                'stroke': 'black',\n                'stroke-opacity': 1\n            });\n        });\n    },\n\n\n    /**\n     * Resize graph of pie chart.\n     * @param {object} params parameters\n     *      @param {{width: number, height:number}} params.dimension dimension\n     *      @param {{cx:number, cy:number, r: number}} params.circleBound circle bound\n     */\n    resize: function(params) {\n        var dimension = params.dimension,\n            circleBound = params.circleBound;\n\n        this.circleBound = circleBound;\n        this.paper.setSize(dimension.width, dimension.height);\n        delete this.containerBound;\n\n        tui.util.forEachArray(this.sectors, function(item) {\n            var angles = item.angles;\n            item.sector.attr({\n                sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]\n            });\n        });\n    },\n\n    /**\n     * Move legend lines.\n     * @param {Array.&lt;object>} outerPositions outer positions\n     */\n    moveLegendLines: function(outerPositions) {\n        var paths;\n\n        if (!this.legendLines) {\n            return;\n        }\n\n        paths = this._makeLinePaths(outerPositions);\n        tui.util.forEachArray(this.legendLines, function(line, index) {\n            line.attr({path: paths[index]});\n            return line;\n        });\n    },\n\n    /**\n     * Click series.\n     * @param {{left: number, top: number}} position mouse position\n     */\n    clickSeries: function(position) {\n        var sector = this.paper.getElementByPoint(position.left, position.top);\n\n        if (sector &amp;&amp; this.prevSelectedSector) {\n            this._unselectSeries(this.prevSelectedSector.data('index'));\n        }\n\n        if (this.prevSelectedSector === sector) {\n            sector = null;\n            delete this.prevSelectedSector;\n        } else if (sector) {\n            this._selectSeries(sector.data('index'));\n            this.prevSelectedSector = sector;\n        }\n    },\n\n\n    /**\n     * Get series container bound.\n     * @returns {{left: number, top: number}} container bound\n     * @private\n     */\n    _getContainerBound: function() {\n        if (!this.containerBound) {\n            this.containerBound = this.container.getBoundingClientRect();\n        }\n        return this.containerBound;\n    },\n\n    /**\n     * Whether changed or not.\n     * @param {{left: number, top: number}} prevPosition previous position\n     * @param {{left: number, top: number}} position position\n     * @returns {boolean} result boolean\n     * @private\n     */\n    _isChangedPosition: function(prevPosition, position) {\n        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;\n    },\n\n    /**\n     * Move mouse on series.\n     * @param {{left: number, top: number}} position mouse position\n     */\n    moveMouseOnSeries: function(position) {\n        var sector = this.paper.getElementByPoint(position.left, position.top),\n            containerBound, args, changedSector;\n\n        if (sector &amp;&amp; this.sectors[sector.data('index')]) {\n            containerBound = this._getContainerBound();\n            changedSector = this.prevMovedSector !== sector;\n            args = [{}, 0, sector.data('index'), {\n                left: position.left - containerBound.left,\n                top: position.top - containerBound.top\n            }];\n\n            if (changedSector) {\n                this._animateExpanding(sector.data('index'));\n            }\n\n            if (this._isChangedPosition(this.prevPosition, position)) {\n                this.callbacks.funcShowTooltip.apply(null, args);\n                this.prevMovedSector = sector;\n            }\n        } else if (this.prevMovedSector) {\n            this._animateRestoring(this.prevMovedSector.data('index'));\n            this.callbacks.funcHideTooltip();\n            this.prevMovedSector = null;\n        }\n        this.prevPosition = position;\n    },\n\n    /**\n     * Select series.\n     * @param {number} index index\n     * @private\n     */\n    _selectSeries: function(index) {\n        var item = this.sectors[index],\n            objColor = raphael.color(item.color),\n            color = this.selectionColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC);\n\n        item.sector.attr({\n            fill: color\n        });\n    },\n\n    /**\n     * Unelect series.\n     * @param {number} index index\n     * @private\n     */\n    _unselectSeries: function(index) {\n        var sector = this.sectors[index];\n\n        sector.sector.attr({\n            fill: sector.color\n        });\n    },\n\n    /**\n     * Select legend.\n     * @param {?number} legendIndex legend index\n     */\n    selectLegend: function(legendIndex) {\n        var isNull = tui.util.isNull(legendIndex);\n\n        tui.util.forEachArray(this.sectors, function(item, index) {\n            var opacity;\n\n            opacity = (isNull || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;\n\n            item.sector.attr({\n                'fill-opacity': opacity\n            });\n        });\n    }\n});\n\nmodule.exports = RaphaelPieChart;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"