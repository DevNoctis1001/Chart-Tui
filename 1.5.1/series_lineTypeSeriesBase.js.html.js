tui.util.defineNamespace("fedoc.content", {});
fedoc.content["series_lineTypeSeriesBase.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview LineTypeSeriesBase is base class for line type series.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const'),\n    renderUtil = require('../helpers/renderUtil');\n/**\n * @classdesc LineTypeSeriesBase is base class for line type series.\n * @class LineTypeSeriesBase\n * @mixin\n */\nvar LineTypeSeriesBase = tui.util.defineClass(/** @lends LineTypeSeriesBase.prototype */ {\n    /**\n     * Make positions of line chart.\n     * @returns {Array.&lt;Array.&lt;object>>} positions\n     * @private\n     */\n    _makeBasicPositions: function() {\n        var dimension = this.boundsMaker.getDimension('series'),\n            itemGroup = this.dataProcessor.getItemGroup(),\n            width = dimension.width,\n            height = dimension.height,\n            len = itemGroup.getGroupCount(this.chartType),\n            start = chartConst.SERIES_EXPAND_SIZE,\n            step;\n\n        if (this.data.aligned) {\n            step = width / (len - 1);\n        } else {\n            step = width / len;\n            start += (step / 2);\n        }\n\n        return itemGroup.map(function(items) {\n            return items.map(function(item, index) {\n                return {\n                    left: start + (step * index),\n                    top: height - (item.ratio * height) + chartConst.SERIES_EXPAND_SIZE\n                };\n            });\n        }, this.chartType, true);\n    },\n\n    /**\n     * Make label position top.\n     * @param {{top: number, startTop: number}} position position\n     * @param {number} value value\n     * @param {number} labelHeight label height\n     * @returns {number} position top\n     * @private\n     */\n    _makeLabelPositionTop: function(position, value, labelHeight) {\n        var positionTop;\n\n        if (this.options.stacked &amp;&amp; position.startTop) {\n            positionTop = (position.startTop + position.top - labelHeight) / 2 + 1;\n        } else if (value &lt; 0 &amp;&amp; !tui.util.isUndefined(position.startTop)) {\n            positionTop = position.top + chartConst.SERIES_LABEL_PADDING;\n        } else {\n            positionTop = position.top - labelHeight - chartConst.SERIES_LABEL_PADDING;\n        }\n\n        return positionTop;\n    },\n\n    /**\n     * Render series label.\n     * @param {HTMLElement} elSeriesLabelArea series label area element\n     * @private\n     */\n    _renderSeriesLabel: function(elSeriesLabelArea) {\n        var self = this,\n            groupPositions = this.seriesData.groupPositions,\n            itemGroup = this.dataProcessor.getItemGroup(),\n            firstFormattedValue = this.dataProcessor.getFirstFormattedValue(this.chartType),\n            labelHeight = renderUtil.getRenderedLabelHeight(firstFormattedValue, this.theme.label),\n            htmls;\n\n        htmls = itemGroup.map(function(items, groupIndex) {\n            return items.map(function(item, index) {\n                var position = groupPositions[groupIndex][index],\n                    labelHtml = '',\n                    labelWidth;\n\n                if (position.top !== position.startTop) {\n                    labelWidth = renderUtil.getRenderedLabelWidth(item.formattedValue, self.theme.label);\n                    labelHtml = self._makeSeriesLabelHtml({\n                        left: position.left - (labelWidth / 2),\n                        top: self._makeLabelPositionTop(position, item.formattedValue, labelHeight)\n                    }, item.formattedValue, groupIndex);\n                }\n                return labelHtml;\n            }).join('');\n        }, this.chartType, true);\n\n        elSeriesLabelArea.innerHTML = htmls.join('');\n    },\n\n    /**\n     * Whether changed or not.\n     * @param {number} groupIndex group index\n     * @param {number} index index\n     * @returns {boolean} whether changed or not\n     * @private\n     */\n    _isChanged: function(groupIndex, index) {\n        var prevIndexes = this.prevIndexes;\n\n        this.prevIndexes = {\n            groupIndex: groupIndex,\n            index: index\n        };\n\n        return !prevIndexes || (prevIndexes.groupIndex !== groupIndex) || (prevIndexes.index !== index);\n    },\n\n    /**\n     * To call showGroupTooltipLine function of graphRenderer.\n     * @param {{\n     *      dimension: {width: number, height: number},\n     *      position: {left: number, top: number}\n     * }} bound bound\n     */\n    onShowGroupTooltipLine: function(bound) {\n        if (!this.graphRenderer.showGroupTooltipLine) {\n            return;\n        }\n        this.graphRenderer.showGroupTooltipLine(bound);\n    },\n\n    /**\n     * To call hideGroupTooltipLine function of graphRenderer.\n     */\n    onHideGroupTooltipLine: function() {\n        if (!this.graphRenderer.hideGroupTooltipLine) {\n            return;\n        }\n        this.graphRenderer.hideGroupTooltipLine();\n    }\n});\n\nLineTypeSeriesBase.mixin = function(func) {\n    tui.util.extend(func.prototype, LineTypeSeriesBase.prototype);\n};\n\nmodule.exports = LineTypeSeriesBase;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"