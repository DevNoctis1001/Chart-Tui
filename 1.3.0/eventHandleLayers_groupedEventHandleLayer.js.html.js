ne.util.defineNamespace("fedoc.content", {});
fedoc.content["eventHandleLayers_groupedEventHandleLayer.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview GroupedEventHandleLayer is event handle layer for grouped toolip option.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar EventHandleLayerBase = require('./eventHandleLayerBase'),\n    chartConst = require('../const'),\n    state = require('../helpers/state');\n\nvar GroupedEventHandleLayer = tui.util.defineClass(EventHandleLayerBase, /** @lends GroupedEventHandleLayer.prototype */ {\n    /**\n     * GroupedEventHandleLayer is event handle layer for grouped toolip option.\n     * @constructs EventHandleLayerBase\n     * @extends EventHandleLayerBase\n     */\n    init: function() {\n        EventHandleLayerBase.apply(this, arguments);\n    },\n\n    /**\n     * To make coordinate data about non line type chart.\n     * @param {number} size width or height\n     * @param {number} tickCount tick count\n     * @returns {array} coordinate data\n     * @private\n     */\n    _makeNormalCoordinateData: function(size, tickCount) {\n        var len = tickCount - 1,\n            tickInterval = size / len,\n            prev = 0;\n        return tui.util.map(tui.util.range(0, len), function(index) {\n            var max = tui.util.min([size, (index + 1) * tickInterval]),\n                scale = {\n                    min: prev,\n                    max: max\n                };\n            prev = max;\n            return scale;\n        });\n    },\n\n    /**\n     * To make coordinate data.\n     * @param {{width: number, height: number}} dimension dimension\n     * @param {number} tickCount tick count\n     * @param {string} chartType chart type\n     * @returns {array.&lt;{min: number, max: number}>} tick groups\n     * @private\n     */\n    makeCoordinateData: function(dimension, tickCount, chartType) {\n        var sizeType = this.isVertical ? 'width' : 'height',\n            coordinateData;\n        if (state.isLineTypeChart(chartType)) {\n            coordinateData = this.makeLineTypeCoordinateData(dimension[sizeType], tickCount);\n        } else {\n            coordinateData = this._makeNormalCoordinateData(dimension[sizeType], tickCount);\n        }\n\n        return coordinateData;\n    },\n\n    /**\n     * To make range of tooltip position.\n     * @param {{min: number, max: number}} scale scale\n     * @param {string} chartType chart type\n     * @returns {{start: number, end: number}} range type value\n     * @private\n     */\n    _makeRange: function(scale, chartType) {\n        var range, center;\n        if (state.isLineTypeChart(chartType)) {\n            center = scale.max - (scale.max - scale.min) / 2;\n            range = {\n                start: center,\n                end: center\n            };\n        } else {\n            range = {\n                start: scale.min,\n                end: scale.max\n            };\n        }\n\n        return range;\n    },\n\n    /**\n     * Get layer position.\n     * @param {MouseEvent} e mouse event object\n     * @param {{top: number, right: number, bottom: number, left: number}} bound bound\n     * @param {boolean} isVertical whether vertical or not\n     * @returns {number} layer position (left or top)\n     * @private\n     */\n    _getLayerPositionValue: function(e, bound, isVertical) {\n        var layerPosition;\n        if (isVertical) {\n            layerPosition = e.clientX - bound.left;\n        } else {\n            layerPosition = e.clientY - bound.top;\n        }\n        return layerPosition;\n    },\n\n    /**\n     * Get tooltip direction.\n     * @param {number} index index\n     * @returns {string} direction\n     * @private\n     */\n    _getTooltipDirection: function(index) {\n        var standardNumber = Math.ceil(this.coordinateData.length / 2),\n            number = index + 1;\n        // 중앙을 기준으로 중앙을 포함하여 앞부분에 위치하는 data는 forword를 반환하고, 뒷부분에 위치하는 data는 backword를 반환한다.\n        return standardNumber >= number ? chartConst.TOOLTIP_DIRECTION_FORWARD : chartConst.TOOLTIP_DIRECTION_BACKWARD;\n    },\n\n    /**\n     * On mousemove.\n     * @param {MouseEvent} e mouse event object\n     * @override\n     */\n    onMousemove: function(e) {\n        var elTarget = e.target || e.srcElement,\n            bound = elTarget.getBoundingClientRect(),\n            layerPositionValue = this._getLayerPositionValue(e, bound, this.isVertical),\n            index = this.findIndex(layerPositionValue),\n            prevIndex = this.prevIndex,\n            sizeType = this.isVertical ? 'height' : 'width',\n            direction;\n\n        if (index === -1 || prevIndex === index) {\n            return;\n        }\n\n        this.prevIndex = index;\n\n        direction = this._getTooltipDirection(index);\n\n        this.fire('showGroupTooltip', {\n            index: index,\n            range: this._makeRange(this.coordinateData[index], this.chartType),\n            size: this.bound.dimension[sizeType],\n            direction: direction,\n            isVertical: this.isVertical\n        });\n    },\n\n    /**\n     * On mouseout.\n     * @param {MouseEvent} e mouse event object\n     * @override\n     */\n    onMouseout: function() {\n        this.fire('hideGroupTooltip', this.prevIndex);\n        delete this.prevIndex;\n    }\n});\n\ntui.util.CustomEvents.mixin(GroupedEventHandleLayer);\n\nmodule.exports = GroupedEventHandleLayer;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"
