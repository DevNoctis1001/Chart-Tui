ne.util.defineNamespace("fedoc.content", {});
fedoc.content["plugins_raphaelPieChart.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview RaphaelPieCharts is graph renderer for pie chart.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar raphaelRenderUtil = require('./raphaelRenderUtil');\n\nvar Raphael = window.Raphael,\n    ANGLE_180 = 180,\n    RAD = Math.PI / ANGLE_180,\n    ANIMATION_TIME = 500,\n    LOADING_ANIMATION_TIME = 700;\n\n/**\n * @classdesc RaphaelPieCharts is graph renderer for pie chart.\n * @class RaphaelPieChart\n */\nvar RaphaelPieChart = tui.util.defineClass(/** @lends RaphaelPieChart.prototype */ {\n    /**\n     * Render function of pie chart.\n     * @param {HTMLElement} container container\n     * @param {{sectorsInfo: array.&lt;object>, circleBound: {cx: number, cy: number, r: number}, dimension: object, theme: object, options: object}} data render data\n     * @param {object} callbacks callbacks\n     *      @param {function} callbacks.funcShowTooltip show tooltip function\n     *      @param {function} callbacks.funcHideTooltip hide tooltip function\n     *      @param {function} callbacks.funcSelectSeries select series function\n     * @return {object} paper raphael paper\n     */\n    render: function(container, data, callbacks) {\n        var dimension = data.dimension,\n            paper;\n\n        this.paper = paper = Raphael(container, dimension.width, dimension.height);\n\n        if (!paper.customAttributes.sector) {\n            paper.customAttributes.sector = tui.util.bind(this._makeSectorPath, this);\n        }\n\n        this.selectionColor = data.theme.selectionColor;\n        this.circleBound = data.circleBound;\n        this._renderPie(paper, data, callbacks);\n\n        return paper;\n    },\n\n    /**\n     * To make sector path.\n     * @param {number} cx center x\n     * @param {number} cy center y\n     * @param {number} r radius\n     * @param {number} startAngle start angle\n     * @param {number} endAngle end angel\n     * @returns {{path: array}} sector path\n     * @private\n     */\n    _makeSectorPath: function(cx, cy, r, startAngle, endAngle) {\n        var x1 = cx + r * Math.sin(startAngle * RAD), // 원 호의 시작 x 좌표\n            y1 = cy - r * Math.cos(startAngle * RAD), // 원 호의 시작 y 좌표\n            x2 = cx + r * Math.sin(endAngle * RAD),// 원 호의 종료 x 좌표\n            y2 = cy - r * Math.cos(endAngle * RAD), // 원 호의 종료 y 좌표\n            largeArcFlag = endAngle - startAngle > ANGLE_180 ? 1 : 0,\n            path = [\"M\", cx, cy,\n                \"L\", x1, y1,\n                \"A\", r, r, 0, largeArcFlag, 1, x2, y2,\n                \"Z\"\n            ];\n        // path에 대한 자세한 설명은 아래 링크를 참고\n        // http://www.w3schools.com/svg/svg_path.asp\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n        return {path: path};\n    },\n\n    /**\n     * Render sector\n     * @param {object} params parameters\n     *      @param {object} params.paper raphael paper\n     *      @param {{cx: number, cy: number, r:number}} params.circleBound circle bounds\n     *      @param {number} params.startAngle start angle\n     *      @param {number} params.endAngle end angle\n     *      @param {{fill: string, stroke: string, strike-width: string}} params.attrs attrs\n     * @returns {object} raphael object\n     * @private\n     */\n    _renderSector: function (params) {\n        var circleBound = params.circleBound,\n            angles = params.angles;\n        return params.paper.path().attr({\n            sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]\n        }).attr(params.attrs);\n    },\n\n    /**\n     * Render pie graph.\n     * @param {object} paper raphael paper\n     * @param {{sectorsInfo: array.&lt;object>, circleBound: {cx: number, cy: number, r: number}, dimension: object, theme: object, options: object}} data render data\n     * @param {object} callbacks callbacks\n     *      @param {function} callbacks.funcShowTooltip show tooltip function\n     *      @param {function} callbacks.funcHideTooltip hide tooltip function\n     *      @param {function} callbacks.funcSelectSeries select series function\n     * @private\n     */\n    _renderPie: function(paper, data, callbacks) {\n        var circleBound = data.circleBound,\n            colors = data.theme.colors,\n            chartBackground = data.chartBackground,\n            sectors = [];\n\n        tui.util.forEachArray(data.sectorsInfo, function(sectorInfo, index) {\n            var percentValue = sectorInfo.percentValue,\n                color = colors[index],\n                sector = this._renderSector({\n                    paper: paper,\n                    circleBound: circleBound,\n                    angles: sectorInfo.angles.start,\n                    attrs: {\n                        fill: color,\n                        stroke: chartBackground,\n                        'stroke-width': 1\n                    }\n                });\n\n            this._bindHoverEvent(sector, index, callbacks);\n\n            sectors.push({\n                sector: sector,\n                color: color,\n                angles: sectorInfo.angles.end,\n                percentValue: percentValue\n            });\n        }, this);\n\n        this.sectors = sectors;\n    },\n\n    /**\n     * Render legend lines.\n     * @param {array.&lt;object>} outerPositions outer position\n     */\n    renderLegendLines: function(outerPositions) {\n        var that = this,\n            paths;\n\n        if (this.legendLines) {\n            return;\n        }\n\n        paths = this._makeLinePaths(outerPositions);\n        this.legendLines = tui.util.map(paths, function(path) {\n            return raphaelRenderUtil.renderLine(that.paper, path, 'transparent', 1);\n        });\n    },\n\n    /**\n     * To make line paths.\n     * @param {array.&lt;object>} outerPositions outer positions\n     * @returns {Array} line paths.\n     * @private\n     */\n    _makeLinePaths: function(outerPositions) {\n        var paths = tui.util.map(outerPositions, function(positions) {\n            return [\n                raphaelRenderUtil.makeLinePath(positions.start, positions.middle),\n                raphaelRenderUtil.makeLinePath(positions.middle, positions.end),\n                'Z'\n            ].join('');\n        }, this);\n        return paths;\n    },\n\n    /**\n     * Bind hover event.\n     * @param {object} target raphael item\n     * @param {number} index index\n     * @param {object} callbacks callbacks\n     *      @param {function} callbacks.funcShowTooltip show tooltip function\n     *      @param {function} callbacks.funcHideTooltip hide tooltip function\n     *      @param {function} callbacks.funcSelectSeries select series function\n     * @private\n     */\n    _bindHoverEvent: function(target, index, callbacks) {\n        var args = [{}, 0, index],\n            isOn = false,\n            throttled = tui.util.throttle(function() {\n                if (!isOn) {\n                    return;\n                }\n                callbacks.funcShowTooltip.apply(null, arguments);\n            }, 100);\n\n        target.mouseover(function (e) {\n            var _args = args.concat({\n                clientX: e.clientX,\n                clientY: e.clientY\n            });\n            isOn = true;\n            callbacks.funcShowTooltip.apply(null, _args);\n        }).mousemove(function(e) {\n            var _args = args.concat({\n                clientX: e.clientX,\n                clientY: e.clientY - 10\n            });\n            throttled.apply(null, _args);\n        }).mouseout(function () {\n            isOn = false;\n            callbacks.funcHideTooltip();\n        }).click(function() {\n            callbacks.funcSelectSeries(index);\n        });\n    },\n\n    /**\n     * To expand selector radius.\n     * @param {object} sector pie sector\n     */\n    _expandSector: function(sector) {\n        var cx = this.circleBound.cx,\n            cy = this.circleBound.cy;\n        sector.animate({\n            transform: \"s1.1 1.1 \" + cx + \" \" + cy\n        }, ANIMATION_TIME, \"elastic\");\n    },\n\n    /**\n     * To restore selector radius.\n     * @param {object} sector pie sector\n     */\n    _restoreSector: function(sector) {\n        sector.animate({transform: \"\"}, ANIMATION_TIME, \"elastic\");\n    },\n\n    /**\n     * Show animation.\n     * @param {{index: number}} data data\n     */\n    showAnimation: function(data) {\n        var sector = this.sectors[data.index].sector;\n        this._expandSector(sector);\n    },\n\n    /**\n     * Hide animation.\n     * @param {{index: number}} data data\n     */\n    hideAnimation: function(data) {\n        var sector = this.sectors[data.index].sector;\n        this._restoreSector(sector);\n    },\n\n    /**\n     * Animate.\n     * @param {function} callback callback\n     */\n    animate: function(callback) {\n        var delayTime = 0,\n            circleBound = this.circleBound;\n        tui.util.forEachArray(this.sectors, function(item) {\n            var angles = item.angles,\n                animationTime = LOADING_ANIMATION_TIME * item.percentValue,\n                anim = Raphael.animation({\n                    sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]\n                }, animationTime);\n            item.sector.animate(anim.delay(delayTime));\n            delayTime += animationTime;\n        }, this);\n\n        if (callback) {\n            setTimeout(callback, delayTime);\n        }\n    },\n\n    /**\n     * Animate legend lines.\n     */\n    animateLegendLines: function() {\n        if (!this.legendLines) {\n            return;\n        }\n        tui.util.forEachArray(this.legendLines, function(line) {\n            line.animate({\n                'stroke': 'black',\n                'stroke-opacity': 1\n            });\n        });\n    },\n\n\n    /**\n     * To resize graph of pie chart.\n     * @param {object} params parameters\n     *      @param {{width: number, height:number}} params.dimension dimension\n     *      @param {{cx:number, cy:number, r: number}} params.circleBound circle bound\n     */\n    resize: function(params) {\n        var dimension = params.dimension,\n            circleBound = params.circleBound;\n\n        this.circleBound = circleBound;\n        this.paper.setSize(dimension.width, dimension.height);\n\n        tui.util.forEachArray(this.sectors, function(item) {\n            var angles = item.angles;\n            item.sector.attr({\n                sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]\n            });\n        }, this);\n    },\n\n    /**\n     * To move legend lines.\n     * @param {array.&lt;object>} outerPositions outer positions\n     */\n    moveLegendLines: function(outerPositions) {\n        var paths;\n        if (!this.legendLines) {\n            return;\n        }\n\n        paths = this._makeLinePaths(outerPositions)\n        tui.util.forEachArray(this.legendLines, function(line, index) {\n            line.attr({path: paths[index]});\n            return line;\n        });\n    },\n\n    /**\n     * Select series.\n     * @param {{groupIndex: number, index: number}} indexes indexes\n     */\n    selectSeries: function(indexes) {\n        var item = this.sectors[indexes.index],\n            objColor = Raphael.color(item.color),\n            color = this.selectionColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, 0.2);\n        item.sector.attr({\n            fill: color\n        });\n    },\n\n    /**\n     * Unelect series.\n     * @param {{groupIndex: number, index: number}} indexes indexes\n     */\n    unselectSeries: function(indexes) {\n        var sector = this.sectors[indexes.index];\n        sector.sector.attr({\n            fill: sector.color\n        });\n    }\n});\n\nmodule.exports = RaphaelPieChart;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"