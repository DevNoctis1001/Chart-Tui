ne.util.defineNamespace("fedoc.content", {});
fedoc.content["plugins_raphaelBarChart.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Raphael bar chart renderer.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\nvar raphaelRenderUtil = require('./raphaelRenderUtil');\n\nvar Raphael = window.Raphael;\n\nvar ANIMATION_TIME = 700;\n\n/**\n * @classdesc RaphaelBarChart is graph renderer for bar, column chart.\n * @class RaphaelBarChart\n */\nvar RaphaelBarChart = tui.util.defineClass(/** @lends RaphaelBarChart.prototype */ {\n    /**\n     * Render function of bar chart\n     * @param {object} paper raphael paper\n     * @param {HTMLElement} container container element\n     * @param {{size: object, model: object, options: object, tooltipPosition: string}} data chart data\n     * @param {function} inCallback mouseover callback\n     * @param {function} outCallback mouseout callback\n     * @return {object} paper raphael paper\n     */\n    render: function(paper, container, data, inCallback, outCallback) {\n        var groupBounds = data.groupBounds,\n            dimension = data.dimension,\n            baseParams;\n\n        if (!groupBounds) {\n            return null;\n        }\n\n        if (!paper) {\n            paper = Raphael(container, dimension.width, dimension.height);\n        }\n\n        baseParams = {\n            paper: paper,\n            theme: data.theme,\n            groupBounds: groupBounds,\n            groupValues: data.groupValues,\n            chartType: data.chartType\n        };\n\n        this._renderBars(tui.util.extend({\n            inCallback: inCallback,\n            outCallback: outCallback\n        }, baseParams));\n\n        this._renderBarBorders(baseParams);\n\n        this.chartType = data.chartType;\n\n        return paper;\n    },\n\n    /**\n     * Render rect\n     * @param {object} params parameters\n     *      @param {object} params.paper raphael paper\n     *      @param {string} params.color series color\n     *      @param {string} params.borderColor series borderColor\n     *      @param {{left: number, top: number, width: number, height: number}} params.bound bound\n     * @returns {object} bar rect\n     * @private\n     */\n    _renderBar: function(params) {\n        var bound = params.bound,\n            rect;\n        if (bound.width &lt; 0 || bound.height &lt; 0) {\n            return null;\n        }\n\n        rect = params.paper.rect(bound.left, bound.top, bound.width, bound.height);\n        rect.attr({\n            fill: params.color,\n            stroke: 'none'\n        });\n\n        return rect;\n    },\n\n    /**\n     * Bind hover event.\n     * @param {object} rect raphael rect\n     * @param {{left: number, top: number, width: number, height: number}} bound bound\n     * @param {string} id tooltip id\n     * @param {function} inCallback in callback\n     * @param {function} outCallback out callback\n     * @private\n     */\n    _bindHoverEvent: function(rect, bound, groupIndex, index, inCallback, outCallback) {\n        rect.hover(function() {\n            inCallback(bound, groupIndex, index);\n        }, function() {\n            outCallback();\n        });\n    },\n\n    /**\n     * Render bars.\n     * @param {object} params parameters\n     *      @param {object} params.paper raphael paper\n     *      @param {{colors: string[], singleColors: string[], borderColor: string}} params.theme bar chart theme\n     *      @param {array.&lt;array.&lt;{left: number, top:number, width: number, height: number}>>} params.groupBounds bounds\n     *      @param {function} params.inCallback in callback\n     *      @param {function} params.outCallback out callback\n     * @private\n     */\n    _renderBars: function(params) {\n        var singleColors = (params.groupBounds[0].length === 1) &amp;&amp; params.theme.singleColors || [],\n            colors = params.theme.colors,\n            bars = [];\n        tui.util.forEachArray(params.groupBounds, function(bounds, groupIndex) {\n            var singleColor = singleColors[groupIndex];\n            tui.util.forEachArray(bounds, function(bound, index) {\n                var color, id, rect, value;\n\n                if (!bound) {\n                    return;\n                }\n\n                color = singleColor || colors[index];\n                id = groupIndex + '-' + index;\n                value = params.groupValues[groupIndex][index];\n                rect = this._renderBar({\n                    paper: params.paper,\n                    chartType: params.chartType,\n                    color: color,\n                    borderColor: params.theme.borderColor,\n                    bound: bound.start,\n                    value: value\n                });\n\n                if (rect) {\n                    this._bindHoverEvent(rect, bound.end, groupIndex, index, params.inCallback, params.outCallback);\n                }\n\n                bars.push({\n                    rect: rect,\n                    bound: bound.end,\n                    value: value\n                });\n            }, this);\n        }, this);\n\n        this.bars = bars;\n    },\n\n    /**\n     * To make rect points.\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @returns {{\n     *      leftTop: {left: number, top: number},\n     *      rightTop: {left: number, top: number},\n     *      rightBottom: {left: number, top: number},\n     *      leftBottom: {left: number, top: number}\n     * }} rect points\n     * @private\n     */\n    _makeRectPoints: function(bound) {\n        return {\n            leftTop: {\n                left: Math.ceil(bound.left),\n                top: Math.ceil(bound.top)\n            },\n            rightTop: {\n                left: Math.ceil(bound.left + bound.width),\n                top: Math.ceil(bound.top)\n            },\n            rightBottom: {\n                left: Math.ceil(bound.left + bound.width),\n                top: Math.ceil(bound.top + bound.height)\n            },\n            leftBottom: {\n                left: Math.ceil(bound.left),\n                top: Math.ceil(bound.top + bound.height)\n            }\n        };\n    },\n\n    /**\n     * To make top line path.\n     * @param {{left: numbrer, top: number}} leftTop left top\n     * @param {{left: numbrer, top: number}} rightTop right top\n     * @param {string} chartType chart type\n     * @param {number} value value\n     * @returns {string} top line path\n     * @private\n     */\n    _makeTopLinePath: function(leftTop, rightTop, chartType, value) {\n        var cloneLeftTop = tui.util.extend({}, leftTop);\n        cloneLeftTop.left -= chartType === 'column' || value &lt; 0 ? 1 : 0;\n        return raphaelRenderUtil.makeLinePath(cloneLeftTop, rightTop);\n    },\n\n    /**\n     * To make border lines paths.\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @param {string} chartType chart type\n     * @param {number} value value\n     * @returns {{top: string, right: string, bottom: string, left: string}} paths\n     * @private\n     */\n    _makeBorderLinesPaths: function(bound, chartType, value) {\n        var points = this._makeRectPoints(bound),\n            paths = {};\n\n        if (chartType === 'bar' || value >= 0) {\n            paths.top = this._makeTopLinePath(points.leftTop, points.rightTop, chartType, value);\n        }\n\n        if (chartType === 'column' || value >= 0) {\n            paths.right = raphaelRenderUtil.makeLinePath(points.rightTop, points.rightBottom);\n        }\n\n        if (chartType === 'bar' || value &lt; 0) {\n            paths.bottom = raphaelRenderUtil.makeLinePath(points.leftBottom, points.rightBottom);\n        }\n\n        if (chartType === 'column' || value &lt; 0) {\n            paths.left = raphaelRenderUtil.makeLinePath(points.leftTop, points.leftBottom);\n        }\n\n        return paths;\n    },\n\n    /**\n     * Render border lines;\n     * @param {object} params parameters\n     *      @param {object} params.paper paper\n     *      @param {{left: number, top:number, width: number, height: number}} params.bound bar bound\n     *      @param {string} params.borderColor border color\n     *      @param {string} params.chartType chart type\n     *      @param {number} params.value value\n     * @returns {object} raphael object\n     * @private\n     */\n    _renderBorderLines: function(params) {\n        var borderLinePaths = this._makeBorderLinesPaths(params.bound, params.chartType, params.value),\n            lines = {};\n        tui.util.forEach(borderLinePaths, function(path, name) {\n            lines[name] = raphaelRenderUtil.renderLine(params.paper, path, params.borderColor, 1);\n        });\n        return lines;\n    },\n\n    /**\n     * Render bar borders.\n     * @param {object} params parameters\n     *      @param {object} params.paper raphael paper\n     *      @param {{colors: string[], singleColors: string[], borderColor: string}} params.theme bar chart theme\n     *      @param {array.&lt;array.&lt;{left: number, top:number, width: number, height: number}>>} params.groupBounds bounds\n     * @private\n     */\n    _renderBarBorders: function(params) {\n        var borderColor = params.theme.borderColor,\n            borders = [];\n\n        this.borders = borders;\n\n        if (!borderColor) {\n            return;\n        }\n\n        tui.util.forEachArray(params.groupBounds, function(bounds, groupIndex) {\n            tui.util.forEachArray(bounds, function(bound, index) {\n                var value, borderLines;\n\n                if (!bound) {\n                    return;\n                }\n\n                value = params.groupValues[groupIndex][index];\n                borderLines = this._renderBorderLines({\n                    paper: params.paper,\n                    bound: bound.start,\n                    borderColor: borderColor,\n                    chartType: params.chartType,\n                    value: value\n                });\n                borders.push(borderLines);\n            }, this);\n        }, this);\n    },\n\n    /**\n     * Animate rect.\n     * @param {object} rect raphael object\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @private\n     */\n    _animateRect: function(rect, bound) {\n        rect.animate({\n            x: bound.left,\n            y: bound.top,\n            width: bound.width,\n            height: bound.height\n        }, ANIMATION_TIME);\n    },\n\n    /**\n     * Animate borders.\n     * @param {array.&lt;object>} lines raphael objects\n     * @param {{left: number, top:number, width: number, height: number}} bound rect bound\n     * @param {string} chartType chart type\n     * @param {number} value value\n     * @private\n     */\n    _animateBorders: function(lines, bound, chartType, value) {\n        var paths = this._makeBorderLinesPaths(bound, chartType, value);\n        tui.util.forEach(lines, function(line, name) {\n            line.animate({path: paths[name]}, ANIMATION_TIME);\n        });\n    },\n\n    /**\n     * Animate.\n     * @param {function} callback callback\n     */\n    animate: function(callback) {\n        tui.util.forEach(this.bars, function(bar, index) {\n            var lines = this.borders[index];\n            this._animateRect(bar.rect, bar.bound);\n            if (lines) {\n                this._animateBorders(lines, bar.bound, this.chartType, bar.value);\n            }\n        }, this);\n\n        if (callback) {\n            setTimeout(callback, ANIMATION_TIME);\n        }\n    }\n});\n\nmodule.exports = RaphaelBarChart;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"