ne.util.defineNamespace("fedoc.content", {});
fedoc.content["series_lineTypeSeriesBase.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview LineTypeSeriesBase is base class for line type series.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar chartConst = require('../const'),\n    dom = require('../helpers/domHandler'),\n    renderUtil = require('../helpers/renderUtil');\n/**\n * @classdesc LineTypeSeriesBase is base class for line type series.\n * @class LineTypeSeriesBase\n * @mixin\n */\nvar LineTypeSeriesBase = tui.util.defineClass(/** @lends LineTypeSeriesBase.prototype */ {\n    /**\n     * To make positions of line chart.\n     * @param {{width: number, height:nunber}} dimension line chart dimension\n     * @returns {array.&lt;array.&lt;object>>} positions\n     */\n    makePositions: function(dimension) {\n        var groupValues = this.percentValues,\n            width = dimension.width,\n            height = dimension.height,\n            len = groupValues[0].length,\n            step, start, result;\n        if (this.aligned) {\n            step = width / (len - 1);\n            start = 0;\n        } else {\n            step = width / len;\n            start = step / 2;\n        }\n\n        result = tui.util.map(groupValues, function(values) {\n            return tui.util.map(values, function(value, index) {\n                return {\n                    left: start + (step * index) + chartConst.SERIES_EXPAND_SIZE,\n                    top: height - (value * height)\n                };\n            });\n        });\n        this.groupPositions = result;\n        return result;\n    },\n\n    /**\n     * Render series label.\n     * @param {object} params parameters\n     *      @param {HTMLElement} params.container container\n     *      @param {array.&lt;array>} params.groupPositions group positions\n     *      @param {array.&lt;array>} params.formattedValues formatted values\n     * @return {HTMLElement} series area element\n     * @private\n     */\n    _renderSeriesLabel: function(params) {\n        var groupPositions, labelHeight, elSeriesLabelArea, html;\n\n        if (!this.options.showLabel) {\n            return null;\n        }\n        groupPositions = params.groupPositions;\n        labelHeight = renderUtil.getRenderedLabelHeight(params.formattedValues[0][0], this.theme.label);\n        elSeriesLabelArea = dom.create('div', 'tui-chart-series-label-area');\n\n        html = tui.util.map(params.formattedValues, function(values, groupIndex) {\n            return tui.util.map(values, function(value, index) {\n                var position = groupPositions[groupIndex][index],\n                    labelWidth = renderUtil.getRenderedLabelWidth(value, this.theme.label),\n                    labelHtml = this.makeSeriesLabelHtml({\n                        left: position.left - (labelWidth / 2),\n                        top: position.top - labelHeight - chartConst.SERIES_LABEL_PADDING\n                    }, value, index, groupIndex);\n                return labelHtml;\n            }, this).join('');\n        }, this).join('');\n\n        elSeriesLabelArea.innerHTML = html;\n        params.container.appendChild(elSeriesLabelArea);\n\n        return elSeriesLabelArea;\n    },\n\n    /**\n     * Get bound.\n     * @param {number} groupIndex group index\n     * @param {number} index index\n     * @returns {{left: number, top: number}} bound\n     * @private\n     */\n    _getBound: function(groupIndex, index) {\n        return this.groupPositions[index][groupIndex];\n    },\n\n    /**\n     * Find index.\n     * @param {number} groupIndex group index\n     * @param {number} layerY mouse position\n     * @returns {number} index\n     * @private\n     */\n    _findIndex: function(groupIndex, layerY) {\n        var foundIndex = -1,\n            diff = 1000;\n\n        if (!this.tickItems) {\n            this.tickItems = tui.util.pivot(this.groupPositions);\n        }\n\n        tui.util.forEach(this.tickItems[groupIndex], function(position, index) {\n            var compare = Math.abs(layerY - position.top);\n            if (diff > compare) {\n                diff = compare;\n                foundIndex = index;\n            }\n        });\n        return foundIndex;\n    },\n\n    /**\n     * Whether changed or not.\n     * @param {number} groupIndex group index\n     * @param {number} index index\n     * @returns {boolean} whether changed or not\n     * @private\n     */\n    _isChanged: function(groupIndex, index) {\n        var prevIndexes = this.prevIndexes;\n\n        this.prevIndexes = {\n            groupIndex: groupIndex,\n            index: index\n        };\n\n        return !prevIndexes || (prevIndexes.groupIndex !== groupIndex) || (prevIndexes.index !== index);\n    },\n\n    /**\n     * On over tick sector.\n     * @param {number} groupIndex groupIndex\n     * @param {number} layerY layerY\n     */\n    onLineTypeOverTickSector: function(groupIndex, layerY) {\n        var index, prevIndexes;\n\n        index = this._findIndex(groupIndex, layerY);\n        prevIndexes = this.prevIndexes;\n\n        if (!this._isChanged(groupIndex, index)) {\n            return;\n        }\n\n        if (prevIndexes) {\n            this.outCallback();\n        }\n\n        this.inCallback(this._getBound(groupIndex, index), groupIndex, index);\n    },\n\n    /**\n     * On out tick sector.\n     */\n    onLineTypeOutTickSector: function() {\n        delete this.prevIndexes;\n        this.outCallback();\n    }\n});\n\nLineTypeSeriesBase.mixin = function(func) {\n    tui.util.extend(func.prototype, LineTypeSeriesBase.prototype);\n};\n\nmodule.exports = LineTypeSeriesBase;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"