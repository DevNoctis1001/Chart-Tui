ne.util.defineNamespace("fedoc.content", {});
fedoc.content["series_series.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Series base component.\n * @author NHN Ent.\n *         FE Development Team &lt;dl_javascript@nhnent.com>\n */\n\n'use strict';\n\nvar seriesTemplate = require('./seriesTemplate'),\n    chartConst = require('../const'),\n    state = require('../helpers/state'),\n    dom = require('../helpers/domHandler'),\n    renderUtil = require('../helpers/renderUtil'),\n    event = require('../helpers/eventListener'),\n    pluginFactory = require('../factories/pluginFactory');\n\nvar SERIES_LABEL_CLASS_NAME = 'tui-chart-series-label';\n\nvar Series = tui.util.defineClass(/** @lends Series.prototype */ {\n    /**\n     * Series base component.\n     * @constructs Series\n     * @param {object} params parameters\n     *      @param {object} params.model series model\n     *      @param {object} params.options series options\n     *      @param {object} params.theme series theme\n     */\n    init: function(params) {\n        var libType;\n\n        tui.util.extend(this, params);\n        libType = params.libType || chartConst.DEFAULT_PLUGIN;\n        this.percentValues = this._makePercentValues(params.data, params.options.stacked);\n        /**\n         * Graph renderer\n         * @type {object}\n         */\n        this.graphRenderer = pluginFactory.get(libType, params.chartType);\n\n        /**\n         * Series view className\n         * @type {string}\n         */\n        this.className = 'tui-chart-series-area';\n\n        this.seriesData = this.makeSeriesData();\n    },\n\n    /**\n     * To make series data.\n     * @returns {object} add data\n     */\n    makeSeriesData: function() {\n        return {};\n    },\n\n    /**\n     * Show tooltip (mouseover callback).\n     * @param {object} params parameters\n     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not\n     * @param {{top:number, left: number, width: number, height: number}} bound graph bound information\n     * @param {number} groupIndex group index\n     * @param {number} index index\n     */\n    showTooltip: function(params, bound, groupIndex, index, eventPosition) {\n        this.fire('showTooltip', tui.util.extend({\n            indexes: {\n                groupIndex: groupIndex,\n                index: index\n            },\n            bound: bound,\n            eventPosition: eventPosition\n        }, params));\n    },\n\n    /**\n     * Hide tooltip (mouseout callback).\n     * @param {string} id tooltip id\n     */\n    hideTooltip: function() {\n        this.fire('hideTooltip');\n    },\n\n    /**\n     * To expand series dimension\n     * @param {{width: number, height: number}} dimension series dimension\n     * @returns {{width: number, height: number}} expended dimension\n     * @private\n     */\n    _expandDimension: function(dimension) {\n        return {\n            width: dimension.width + chartConst.SERIES_EXPAND_SIZE * 2,\n            height: dimension.height + chartConst.SERIES_EXPAND_SIZE\n        };\n    },\n\n    /**\n     * Render series.\n     * @param {object} paper object for graph drawing\n     * @returns {HTMLElement} series element\n     */\n    render: function(paper) {\n        var el = dom.create('DIV', this.className),\n            bound = this.bound,\n            dimension = this._expandDimension(bound.dimension),\n            inCallback = tui.util.bind(this.showTooltip, this, {\n                allowNegativeTooltip: !!this.allowNegativeTooltip,\n                chartType: this.chartType\n            }),\n            outCallback = tui.util.bind(this.hideTooltip, this),\n            data = {\n                dimension: dimension,\n                chartType: this.chartType,\n                theme: this.theme,\n                options: this.options\n            },\n            seriesData = this.seriesData,\n            addDataForSeriesLabel;\n\n        if (!paper) {\n            renderUtil.renderDimension(el, dimension);\n        }\n\n        this._renderPosition(el, bound.position, this.chartType);\n\n        data = tui.util.extend(data, seriesData);\n\n        this.paper = this.graphRenderer.render(paper, el, data, inCallback, outCallback);\n\n        if (this._renderSeriesLabel) {\n            addDataForSeriesLabel = this._makeSeriesDataForSeriesLabel(el, dimension);\n            this.elSeriesLabelArea = this._renderSeriesLabel(tui.util.extend(addDataForSeriesLabel, seriesData));\n        }\n\n        if (!this.isGroupedTooltip) {\n            this.attachEvent(el);\n        }\n\n        // series label mouse event 동작 시 사용\n        this.inCallback = inCallback;\n        this.outCallback = outCallback;\n\n        return el;\n    },\n\n    /**\n     * To make add data for series label.\n     * @param {HTMLElement} container container\n     * @param {{width: number, height: number}} dimension dimension\n     * @returns {{\n     *      container: HTMLElement,\n     *      values: array.&lt;array>,\n     *      formattedValues: array.&lt;array>,\n     *      formatFunctions: array.&lt;function>,\n     *      dimension: {width: number, height: number}\n     * }} add data for series label\n     * @private\n     */\n    _makeSeriesDataForSeriesLabel: function(container, dimension) {\n        return {\n            container: container,\n            values: this.data.values,\n            formattedValues: this.data.formattedValues,\n            formatFunctions: this.data.formatFunctions,\n            dimension: dimension\n        };\n    },\n\n    /**\n     * Render bounds\n     * @param {HTMLElement} el series element\n     * @param {{top: number, left: number}} position series position\n     * @private\n     */\n    _renderPosition: function(el, position) {\n        var hiddenWidth = renderUtil.isIE8() ? chartConst.HIDDEN_WIDTH : 0;\n        position.top = position.top - (hiddenWidth * 2);\n        position.left = position.left - chartConst.SERIES_EXPAND_SIZE - hiddenWidth;\n        renderUtil.renderPosition(el, position);\n    },\n\n    /**\n     * Get paper.\n     * @returns {object} object for graph drawing\n     */\n    getPaper: function() {\n        return this.paper;\n    },\n\n    /**\n     * To make percent value.\n     * @param {{values: array, scale: {min: number, max: number}}} data series data\n     * @param {string} stacked stacked option\n     * @returns {array.&lt;array.&lt;number>>} percent values\n     * @private\n     */\n    _makePercentValues: function(data, stacked) {\n        var result;\n        if (stacked === chartConst.STACKED_NORMAL_TYPE) {\n            result = this._makeNormalStackedPercentValues(data);\n        } else if (stacked === chartConst.STACKED_PERCENT_TYPE) {\n            result = this._makePercentStackedPercentValues(data);\n        } else {\n            result = this._makeNormalPercentValues(data);\n        }\n\n        return result;\n    },\n\n    /**\n     * To make percent values about normal stacked option.\n     * @param {{values: array, scale: {min: number, max: number}}} data series data\n     * @returns {array} percent values about normal stacked option.\n     * @private\n     */\n    _makeNormalStackedPercentValues: function(data) {\n        var min = data.scale.min,\n            max = data.scale.max,\n            distance = max - min,\n            percentValues = tui.util.map(data.values, function(values) {\n                var plusValues = tui.util.filter(values, function(value) {\n                        return value > 0;\n                    }),\n                    sum = tui.util.sum(plusValues),\n                    groupPercent = (sum - min) / distance;\n                return tui.util.map(values, function(value) {\n                    return value === 0 ? 0 : groupPercent * (value / sum);\n                });\n            });\n        return percentValues;\n    },\n\n    /**\n     * To make percent values about percent stacked option.\n     * @param {{values: array, scale: {min: number, max: number}}} data series data\n     * @returns {array} percent values about percent stacked option\n     * @private\n     */\n    _makePercentStackedPercentValues: function(data) {\n        var percentValues = tui.util.map(data.values, function(values) {\n            var plusValues = tui.util.filter(values, function(value) {\n                    return value > 0;\n                }),\n                sum = tui.util.sum(plusValues);\n            return tui.util.map(values, function(value) {\n                return value === 0 ? 0 : value / sum;\n            });\n        });\n        return percentValues;\n    },\n\n    /**\n     * To make normal percent value.\n     * @param {{values: array, scale: {min: number, max: number}}} data series data\n     * @returns {array.&lt;array.&lt;number>>} percent values\n     * @private\n     */\n    _makeNormalPercentValues: function(data) {\n        var min = data.scale.min,\n            max = data.scale.max,\n            distance = max - min,\n            isLineTypeChart = state.isLineTypeChart(this.chartType),\n            flag = 1,\n            subValue = 0,\n            percentValues;\n\n        if (!isLineTypeChart &amp;&amp; min &lt; 0 &amp;&amp; max &lt;= 0) {\n            flag = -1;\n            subValue = max;\n            distance = min - max;\n        } else if (isLineTypeChart || min >= 0) {\n            subValue = min;\n        }\n\n        percentValues = tui.util.map(data.values, function(values) {\n            return tui.util.map(values, function(value) {\n                return (value - subValue) * flag / distance;\n            });\n        });\n        return percentValues;\n    },\n\n    /**\n     * Get scale distance from zero point.\n     * @param {number} size chart size (width or height)\n     * @param {{min: number, max: number}} scale scale\n     * @returns {{toMax: number, toMin: number}} pixel distance\n     */\n    getScaleDistanceFromZeroPoint: function(size, scale) {\n        var min = scale.min,\n            max = scale.max,\n            distance = max - min,\n            toMax = 0,\n            toMin = 0;\n\n        if (min &lt; 0 &amp;&amp; max > 0) {\n            toMax = (distance + min) / distance * size;\n            toMin = (distance - max) / distance * size;\n        }\n\n        return {\n            toMax: toMax,\n            toMin: toMin\n        };\n    },\n\n    renderCoordinateArea: function() {},\n\n    /**\n     * On mouseover event handler for series area\n     * @param {MouseEvent} e mouse event\n     */\n    onMouseover: function(e) {\n        var elTarget = e.target || e.srcElement,\n            groupIndex, index;\n\n        if (elTarget.className !== SERIES_LABEL_CLASS_NAME) {\n            return;\n        }\n\n        groupIndex = parseInt(elTarget.getAttribute('data-group-index'), 10);\n        index = parseInt(elTarget.getAttribute('data-index'), 10);\n\n        if (groupIndex === -1 || index === -1) {\n            return;\n        }\n\n        this.inCallback(this._getBound(groupIndex, index), groupIndex, index);\n    },\n\n    onMousemove: function() {},\n    /**\n     * On mouseout event handler for series area\n     * @param {MouseEvent} e mouse event\n     */\n    onMouseout: function(e) {\n        var elTarget = e.target || e.srcElement,\n            groupIndex, index;\n\n        if (elTarget.className !== SERIES_LABEL_CLASS_NAME) {\n            return;\n        }\n\n        groupIndex = parseInt(elTarget.getAttribute('data-group-index'), 10);\n        index = parseInt(elTarget.getAttribute('data-index'), 10);\n\n        if (groupIndex === -1 || index === -1) {\n            return;\n        }\n\n        this.outCallback(groupIndex, index);\n    },\n\n    /**\n     * Attach event\n     * @param {HTMLElement} el target element\n     */\n    attachEvent: function(el) {\n        event.bindEvent('mouseover', el, tui.util.bind(this.onMouseover, this));\n        event.bindEvent('mousemove', el, tui.util.bind(this.onMousemove, this));\n        event.bindEvent('mouseout', el, tui.util.bind(this.onMouseout, this));\n    },\n\n    /**\n     * To call showAnimation function of graphRenderer.\n     * @param {{groupIndex: number, index: number}} data data\n     */\n    onShowAnimation: function(data) {\n        if (!this.graphRenderer.showAnimation) {\n            return;\n        }\n        this.graphRenderer.showAnimation.call(this.graphRenderer, data);\n    },\n\n    /**\n     * To call hideAnimation function of graphRenderer.\n     * @param {{groupIndex: number, index: number}} data data\n     */\n    onHideAnimation: function(data) {\n        if (!this.graphRenderer.hideAnimation) {\n            return;\n        }\n        this.graphRenderer.hideAnimation.call(this.graphRenderer, data);\n    },\n\n    /**\n     * To call showGroupAnimation function of graphRenderer.\n     * @param {number} index index\n     * @param {{\n     *      dimension: {width: number, height: number},\n     *      position: {left: number, top: number}\n     * }} bound bound\n     */\n    onShowGroupAnimation: function(index, bound) {\n        if (!this.graphRenderer.showGroupAnimation) {\n            return;\n        }\n        this.graphRenderer.showGroupAnimation.call(this.graphRenderer, index, bound);\n    },\n\n    /**\n     * To call hideGroupAnimation function of graphRenderer.\n     * @param {number} index index\n     */\n    onHideGroupAnimation: function(index) {\n        if (!this.graphRenderer.hideGroupAnimation) {\n            return;\n        }\n        this.graphRenderer.hideGroupAnimation.call(this.graphRenderer, index);\n    },\n\n    /**\n     * Animate component.\n     */\n    animateComponent: function() {\n        if (this.graphRenderer.animate) {\n            this.graphRenderer.animate(tui.util.bind(this.showSeriesLabelArea, this));\n        }\n    },\n\n    /**\n     * To make html about series label\n     * @param {{left: number, top: number}} position position\n     * @param {string} value value\n     * @param {number} groupIndex group index\n     * @param {number} index index\n     * @returns {string} html string\n     */\n    makeSeriesLabelHtml: function(position, value, groupIndex, index) {\n        var cssObj = tui.util.extend(position, this.theme.label);\n        return seriesTemplate.tplSeriesLabel({\n            cssText: seriesTemplate.tplCssText(cssObj),\n            value: value,\n            groupIndex: groupIndex,\n            index: index\n        });\n    },\n\n    /**\n     * Show series label area.\n     */\n    showSeriesLabelArea: function() {\n        if ((!this.options.showLabel &amp;&amp; !this.options.legendType) || !this.elSeriesLabelArea) {\n            return;\n        }\n\n        dom.addClass(this.elSeriesLabelArea, 'show');\n\n        (new tui.component.Effects.Fade({\n            element: this.elSeriesLabelArea,\n            duration: 300\n        })).action({\n            start: 0,\n            end: 1,\n            complete: function() {}\n        });\n    }\n});\n\ntui.util.CustomEvents.mixin(Series);\n\nmodule.exports = Series;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"