(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @fileoverview  Axis component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('../helpers/domHandler'),
    chartConst = require('../const'),
    calculator = require('../helpers/calculator'),
    renderUtil = require('../helpers/renderUtil'),
    axisTemplate = require('./axisTemplate');

var Axis = tui.util.defineClass(/** @lends Axis.prototype */ {
    /**
     * Axis component.
     * @constructs Axis
     * @param {object} params parameters
     *      @param {{
     *          labels: Array.<string>,
     *          tickCount: number,
     *          isLabelAxis: boolean,
     *          isVertical: boolean
     *      }} params.data axis data
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     *      @param {object} params.options axis options
     */
    init: function(params) {
        /**
         * Axis view className
         * @type {string}
         */
        this.className = 'tui-chart-axis-area';

        /**
         * Chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * Data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * Theme
         * @type {object}
         */
        this.theme = params.theme || {};

        /**
         * Whether label type or not.
         * @type {boolean}
         */
        this.isLabel = params.isLabel;

        /**
         * Data for rendering
         * @type {object}
         */
        this.data = {};
    },

    /**
     * Make height of x axis area.
     * @returns {number} height
     * @private
     */
    _makeXAxisHeight: function() {
        var title = this.options.title;
        var titleHeight = renderUtil.getRenderedLabelHeight(title, this.theme.title);
        var titleAreaHeight = titleHeight ? (titleHeight + chartConst.TITLE_PADDING) : 0;
        var labelHeight = renderUtil.getRenderedLabelHeight(chartConst.MAX_HEIGHT_WORLD, this.theme.label);

        return titleAreaHeight + labelHeight + chartConst.CHART_PADDING;
    },

    /**
     * Make width of y axis area.
     * @param {Array.<string | number>} labels labels
     * @returns {number} width
     * @private
     */
    _makeYAxisWidth: function(labels) {
        var title = this.options.title || '',
            titleAreaWidth = 0,
            width = 0;

        if (this.options.isCenter) {
            width += chartConst.AXIS_LABEL_PADDING;
        } else {
            titleAreaWidth = renderUtil.getRenderedLabelHeight(title, this.theme.title) + chartConst.TITLE_PADDING;
        }

        width += renderUtil.getRenderedLabelsMaxWidth(labels, this.theme.label) + titleAreaWidth +
            chartConst.AXIS_LABEL_PADDING;

        return width;
    },

    /**
     * Whether valid axis or not.
     * @returns {boolean} whether valid axis or not.
     * @private
     */
    _isValidAxis: function() {
        var isValid = true;

        if (this.componentName === 'rightYAxis') {
            isValid = this.dataProcessor.isValidAllSeriesDataModel();
        }

        return isValid;
    },

    /**
     * Register legend dimension to boundsMaker.
     */
    registerDimension: function() {
        var dimension = {};

        if (!this._isValidAxis()) {
            return;
        }

        if (this.componentType === 'xAxis') {
            dimension.height = this._makeXAxisHeight();
            this.boundsMaker.registerBaseDimension(this.componentName, dimension);
        } else if (this.isLabel) {
            dimension.width = this._makeYAxisWidth(this.dataProcessor.getCategories());
            this.boundsMaker.registerBaseDimension(this.componentName, dimension);
        }
    },

    /**
     * Register legend additional dimension to boundsMaker.
     */
    registerAdditionalDimension: function() {
        var dimension,
            axesData = this.boundsMaker.axesData;

        if (!this._isValidAxis()) {
            return;
        }

        if ((this.componentType === 'yAxis') && !this.isLabel) {
            dimension = {
                width: this._makeYAxisWidth(axesData.yAxis.labels)
            };
            this.boundsMaker.registerBaseDimension(this.componentName, dimension);
        }
    },

    /**
     * Render opposite side tick area.
     * @param {string} tickHtml tick html
     * @returns {?HTMLElement} right tick area element
     * @private
     */
    _renderOppositeSideTickArea: function(tickHtml) {
        var tickContainer;

        if (this.options.isCenter) {
            tickContainer = dom.create('DIV', 'tui-chart-tick-area opposite-side');
            tickContainer.innerHTML = tickHtml;
        }

        return tickContainer;
    },

    /**
     * Add css classes.
     * @param {HTMLElement} axisContainer axis container
     * @private
     */
    _addCssClasses: function(axisContainer) {
        dom.addClass(axisContainer, this.data.isVertical ? 'vertical' : 'horizontal');
        dom.addClass(axisContainer, this.options.isCenter ? 'center' : '');
        dom.addClass(axisContainer, this.options.divided ? 'division' : '');
        dom.addClass(axisContainer, this.data.isPositionRight ? 'right' : '');
    },


    /**
     * Render child containers like title area, lable area and tick area.
     * @param {number} size xAxis width or yAxis height
     * @param {number} width axis width
     * @param {number} tickCount tick count
     * @param {Array.<number|string>} categories categories
     * @param {number} additionalWidth aditional width
     * @returns {Array.<HTMLElement>} child containers
     * @private
     */
    _renderChildContainers: function(size, width, tickCount, categories, additionalWidth) {
        var titleContainer = this._renderTitleArea(size),
            labelContainer = this._renderLabelArea(size, width, tickCount, categories, additionalWidth),
            childContainers = [titleContainer, labelContainer],
            isLineType = this.data.isVertical && this.data.aligned,
            tickContainer, oppositeSideTickContainer;

        if (!isLineType) {
            tickContainer = this._renderTickArea(size, tickCount, categories, additionalWidth);
            oppositeSideTickContainer = this._renderOppositeSideTickArea(tickContainer.innerHTML);
            childContainers = childContainers.concat([tickContainer, oppositeSideTickContainer]);
        }

        return childContainers;
    },

    /**
     Render division xAxis area if yAxis rendered in the center.
     * @param {HTMLElement} axisContainer axis container element
     * @param {number} width axis area width
     * @private
     */
    _renderDivisionAxisArea: function(axisContainer, width) {
        var leftWidth = Math.round(width / 2),
            rightWidth = width - leftWidth,
            tickCount = this.data.tickCount,
            halfTickCount = parseInt(tickCount / 2, 10) + 1,
            categories = this.data.labels,
            leftCates = categories.slice(0, halfTickCount),
            rightCates = categories.slice(halfTickCount - 1, tickCount),
            additionWidth = leftWidth + this.boundsMaker.getDimension('yAxis').width,
            leftContainers, rightContainers, rightTitleContainer;

        leftContainers = this._renderChildContainers(leftWidth, leftWidth, halfTickCount, leftCates);
        rightContainers = this._renderChildContainers(rightWidth, rightWidth, halfTickCount, rightCates, additionWidth);

        rightTitleContainer = rightContainers[0];
        dom.addClass(rightTitleContainer, 'right');
        dom.append(axisContainer, leftContainers.concat(rightContainers));
    },

    /**
     * Render single axis area if yAxis did not rendered in the center.
     * @param {HTMLElement} axisContainer axis container element
     * @param {{width: number, height: number}} dimension axis area dimension
     * @private
     */
    _renderSingleAxisArea: function(axisContainer, dimension) {
        var isVertical = !!this.data.isVertical,
            size = isVertical ? dimension.height : dimension.width,
            childContainers = this._renderChildContainers(size, dimension.width, this.data.tickCount, this.data.labels);

        dom.append(axisContainer, childContainers);
    },

    /**
     * Render axis area.
     * @param {HTMLElement} axisContainer axis area element
     * @param {{isVertical: boolean, isPositionRight: boolean, aligned: aligned}} data rendering data
     * @private
     */
    _renderAxisArea: function(axisContainer) {
        var dimension = tui.util.extend({}, this.boundsMaker.getDimension(this.componentName));

        this._addCssClasses(axisContainer);

        if (this.options.divided) {
            this._renderDivisionAxisArea(axisContainer, dimension.width);
            dimension.width += this.boundsMaker.getDimension('yAxis').width;
        } else {
            this._renderSingleAxisArea(axisContainer, dimension);
            dimension.width += this.options.isCenter ? 2 : 0;
        }

        renderUtil.renderDimension(axisContainer, dimension);
        renderUtil.renderPosition(axisContainer, this.boundsMaker.getPosition(this.componentName));
    },

    /**
     * Render axis component.
     * @param {{isVertical: boolean, isPositionRight: boolean, aligned: aligned}} data rendering data
     * @returns {HTMLElement} axis area base element
     */
    render: function(data) {
        var el = dom.create('DIV', this.className);

        this.data = data;
        this._renderAxisArea(el);
        this.axisContainer = el;
        return el;
    },

    /**
     * Rerender axis component.
     * @param {object} data rendering data
     */
    rerender: function(data) {
        this.axisContainer.innerHTML = '';

        if (this._isValidAxis()) {
            if (data.options) {
                this.options = data.options;
            }
            this.data = data;
            this._renderAxisArea(this.axisContainer);
        }
    },

    /**
     * Resize axis component.
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound axis bound
     * @param {object} data rendering data
     */
    resize: function(bound, data) {
        this.rerender(bound, data);
    },

    /**
     * Render css style of title area
     * @param {HTMLElement} titleContainer title element
     * @param {number} size width or height
     * @private
     */
    _renderTitleAreaStyle: function(titleContainer, size) {
        var isPositionRight = this.data.isPositionRight,
            cssTexts = [
                renderUtil.concatStr('width:', size, 'px')
            ],
            titleWidth, yAxisWidth, xAxisHeight;

        if (isPositionRight) {
            if (renderUtil.isIE7()) {
                cssTexts.push(renderUtil.concatStr('right:', '0px'));
            } else {
                cssTexts.push(renderUtil.concatStr('right:', -size, 'px'));
            }
            cssTexts.push('top:0px');
        } else if (this.options.isCenter) {
            titleWidth = renderUtil.getRenderedLabelWidth(this.options.title, this.theme.title);
            yAxisWidth = this.boundsMaker.getDimension('yAxis').width;
            xAxisHeight = this.boundsMaker.getDimension('xAxis').height;

            cssTexts = [
                'left:' + ((yAxisWidth - titleWidth) / 2) + 'px',
                'bottom: -' + xAxisHeight + 'px'
            ];
        } else {
            cssTexts.push('left:0px');
            if (!renderUtil.isOldBrowser()) {
                cssTexts.push(renderUtil.concatStr('top:', size, 'px'));
            }
        }

        titleContainer.style.cssText += ';' + cssTexts.join(';');
    },

    /**
     * Title area renderer
     * @param {?number} size (width or height)
     * @returns {HTMLElement} title element
     * @private
     */
    _renderTitleArea: function(size) {
        var titleContainer = renderUtil.renderTitle(this.options.title, this.theme.title, 'tui-chart-title-area');

        if (titleContainer && this.data.isVertical) {
            this._renderTitleAreaStyle(titleContainer, size);
        }

        return titleContainer;
    },

    /**
     * Render tick area.
     * @param {number} size size or height
     * @param {number} tickCount tick count
     * @param {Array.<string>} categories categories
     * @param {?number} additionalSize additional size (width or height)
     * @returns {HTMLElement} tick area element
     * @private
     */
    _renderTickArea: function(size, tickCount, categories, additionalSize) {
        var data = this.data,
            isSingleXAxis = !data.isVertical && !this.options.divided,
            tickColor = this.theme.tickColor,
            positions = calculator.makeTickPixelPositions(size, tickCount),
            elTickArea = dom.create('DIV', 'tui-chart-tick-area'),
            template = axisTemplate.tplAxisTick,
            tickLineExtend = isSingleXAxis ? 1 : 0,
            posType, lineSizeType, lineHtml, ticksHtml;

        additionalSize = additionalSize || 0;

        if (data.isVertical) {
            posType = 'bottom';
            lineSizeType = 'height';
        } else {
            posType = 'left';
            lineSizeType = 'width';
        }

        lineHtml = axisTemplate.tplTickLine({
            positionType: posType,
            positionValue: additionalSize - tickLineExtend,
            sizeType: lineSizeType,
            size: size + tickLineExtend
        });

        ticksHtml = tui.util.map(positions, function(position, index) {
            var tickHtml, cssTexts;

            if (data.aligned && (categories[index] === chartConst.EMPTY_AXIS_LABEL)) {
                tickHtml = '';
            } else {
                position -= (index === 0 && isSingleXAxis) ? 1 : 0;
                cssTexts = [
                    renderUtil.concatStr('background-color:', tickColor),
                    renderUtil.concatStr(posType, ': ', additionalSize + position, 'px')
                ].join(';');
                tickHtml = template({cssText: cssTexts});
            }

            return tickHtml;
        }).join('');

        elTickArea.innerHTML = lineHtml + ticksHtml;

        return elTickArea;
    },

    /**
     * Make cssText of vertical label.
     * @param {number} axisWidth axis width
     * @param {number} titleAreaWidth title area width
     * @returns {string} cssText
     * @private
     */
    _makeVerticalLabelCssText: function(axisWidth, titleAreaWidth) {
        return ';width:' + (axisWidth - titleAreaWidth + chartConst.V_LABEL_RIGHT_PADDING) + 'px';
    },

    /**
     * Apply css style of label area.
     * @param {HTMLElement} labelContainer label container
     * @param {number} axisWidth axis width
     * @private
     */
    _applyLabelAreaStyle: function(labelContainer, axisWidth) {
        var cssText = renderUtil.makeFontCssText(this.theme.label),
            titleAreaWidth;

        if (this.data.isVertical) {
            titleAreaWidth = this._getRenderedTitleHeight() + chartConst.TITLE_AREA_WIDTH_PADDING;
            cssText += this._makeVerticalLabelCssText(axisWidth, titleAreaWidth);
        }

        labelContainer.style.cssText = cssText;
    },

    /**
     * Render label area.
     * @param {number} size label area size
     * @param {number} axisWidth axis area width
     * @param {number} tickCount tick count
     * @param {Array.<string>} categories categories
     * @param {?number} additionalSize additional size (width or height)
     * @returns {HTMLElement} label area element
     * @private
     */
    _renderLabelArea: function(size, axisWidth, tickCount, categories, additionalSize) {
        var labelContainer = dom.create('DIV', 'tui-chart-label-area'),
            tickPixelPositions = calculator.makeTickPixelPositions(size, tickCount),
            labelSize = tickPixelPositions[1] - tickPixelPositions[0],
            labelsHtml;

        additionalSize = additionalSize || 0;
        labelsHtml = this._makeLabelsHtml(tickPixelPositions, categories, labelSize, additionalSize);
        labelContainer.innerHTML = labelsHtml;

        this._applyLabelAreaStyle(labelContainer, axisWidth);
        this._changeLabelAreaPosition(labelContainer, labelSize);

        return labelContainer;
    },

    /**
     * Get height of title area ;
     * @returns {number} height
     * @private
     */
    _getRenderedTitleHeight: function() {
        var title = this.options.title,
            theme = this.theme.title,
            result = title ? renderUtil.getRenderedLabelHeight(title, theme) : 0;

        return result;
    },

    /**
     * Make cssText of label.
     * @param {number} labelSize label size (width or height)
     * @returns {string[]} cssTexts
     * @private
     */
    _makeLabelCssText: function(labelSize) {
        var isVertical = this.data.isVertical,
            cssTexts = [];

        if (isVertical && this.data.isLabelAxis) {
            cssTexts.push(renderUtil.concatStr('height:', labelSize, 'px'));
            cssTexts.push(renderUtil.concatStr('line-height:', labelSize, 'px'));
        } else if (!isVertical) {
            cssTexts.push(renderUtil.concatStr('width:', labelSize, 'px'));
        }

        return cssTexts.length ? cssTexts.join(';') + ';' : '';
    },

    /**
     * Calculate rotation moving position.
     * @param {object} params parameters
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {number} params.moveLeft move left
     *      @param {number} params.top top
     * @returns {{top:number, left: number}} position
     * @private
     */
    _calculateRotationMovingPosition: function(params) {
        var moveLeft = params.moveLeft,
            degree = this.boundsMaker.xAxisDegree;

        if (degree === chartConst.ANGLE_85) {
            moveLeft += calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, params.labelHeight / 2);
        }

        return {
            top: params.top,
            left: params.left - moveLeft
        };
    },

    /**
     * Calculate rotation moving position for old browser(IE7, IE8).
     * @param {object} params parameters
     *      @param {number} params.labelWidth label width
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {(string | number)} params.label label
     *      @param {object} theme label theme
     * @returns {{top:number, left: number}} position
     * @private
     */
    _calculateRotationMovingPositionForOldBrowser: function(params) {
        var labelWidth = renderUtil.getRenderedLabelWidth(params.label, params.theme),
            degree = this.boundsMaker.xAxisDegree,
            smallAreaWidth = calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, params.labelHeight / 2),
            newLabelWidth = (calculator.calculateAdjacent(degree, labelWidth / 2) + smallAreaWidth) * 2,
            changedWidth = renderUtil.isIE7() ? 0 : (labelWidth - newLabelWidth),
            moveLeft = (params.labelWidth / 2) - (smallAreaWidth * 2);

        if (degree === chartConst.ANGLE_85) {
            moveLeft += smallAreaWidth;
        }

        return {
            top: chartConst.XAXIS_LABEL_TOP_MARGIN,
            left: params.left + changedWidth - moveLeft
        };
    },

    /**
     * Make cssText for rotation moving.
     * @param {object} params parameters
     *      @param {number} params.labelWidth label width
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {number} params.moveLeft move left
     *      @param {number} params.top top
     *      @param {(string | number)} params.label label
     *      @param {object} theme label theme
     * @returns {string} cssText
     * @private
     */
    _makeCssTextForRotationMoving: function(params) {
        var position;

        if (renderUtil.isOldBrowser()) {
            position = this._calculateRotationMovingPositionForOldBrowser(params);
        } else {
            position = this._calculateRotationMovingPosition(params);
        }

        return renderUtil.concatStr('left:', position.left, 'px', ';top:', position.top, 'px');
    },

    /**
     * Make html of rotation labels.
     * @param {Array.<object>} positions label position array
     * @param {string[]} categories categories
     * @param {number} labelSize label size
     * @param {number} additionalSize additional size
     * @returns {string} labels html
     * @private
     */
    _makeRotationLabelsHtml: function(positions, categories, labelSize, additionalSize) {
        var self = this,
            degree = this.boundsMaker.xAxisDegree,
            template = axisTemplate.tplAxisLabel,
            labelHeight = renderUtil.getRenderedLabelHeight(categories[0], this.theme.label),
            labelCssText = this._makeLabelCssText(labelSize),
            additionalClass = ' tui-chart-xaxis-rotation tui-chart-xaxis-rotation' + degree,
            halfWidth = labelSize / 2,
            moveLeft = calculator.calculateAdjacent(degree, halfWidth),
            top = calculator.calculateOpposite(degree, halfWidth) +
                chartConst.XAXIS_LABEL_TOP_MARGIN,
            spanCssText = (renderUtil.isIE7() && degree) ? chartConst.IE7_ROTATION_FILTER_STYLE_MAP[degree] : '',
            labelsHtml;

        additionalSize = additionalSize || 0;
        labelsHtml = tui.util.map(positions, function(position, index) {
            var label = categories[index],
                rotationCssText = self._makeCssTextForRotationMoving({
                    labelHeight: labelHeight,
                    labelWidth: labelSize,
                    top: top,
                    left: position + additionalSize,
                    moveLeft: moveLeft,
                    label: label,
                    theme: self.theme.label
                });

            return template({
                additionalClass: additionalClass,
                cssText: labelCssText + rotationCssText,
                spanCssText: spanCssText,
                label: label
            });
        }).join('');

        return labelsHtml;
    },

    /**
     * Make html of normal labels.
     * @param {Array.<object>} positions label position array
     * @param {string[]} categories categories
     * @param {number} labelSize label size
     * @param {number} additionalSize additional size
     * @returns {string} labels html
     * @private
     */
    _makeNormalLabelsHtml: function(positions, categories, labelSize, additionalSize) {
        var template = axisTemplate.tplAxisLabel,
            labelCssText = this._makeLabelCssText(labelSize),
            posType, labelsHtml;

        additionalSize = additionalSize || 0;

        if (this.data.isVertical) {
            posType = this.data.isLabelAxis ? 'top' : 'bottom';
        } else {
            posType = 'left';
        }

        labelsHtml = tui.util.map(positions, function(position, index) {
            var addCssText = renderUtil.concatStr(posType, ':', (position + additionalSize), 'px');
            return template({
                additionalClass: '',
                cssText: labelCssText + addCssText,
                label: categories[index],
                spanCssText: ''
            });
        }).join('');

        return labelsHtml;
    },

    /**
     * Make labels html.
     * @param {Array.<object>} positions label position array
     * @param {string[]} categories categories
     * @param {number} labelSize label size
     * @param {number} additionalSize additional size
     * @returns {string} labels html
     * @private
     */
    _makeLabelsHtml: function(positions, categories, labelSize, additionalSize) {
        var isRotationlessXAxis = !this.data.isVertical && this.data.isLabelAxis && this.options.rotation === false,
            hasRotatedXAxisLabel = this.componentName === 'xAxis' && this.boundsMaker.xAxisDegree,
            labelsHtml;

        if (isRotationlessXAxis) {
            categories = this.dataProcessor.getMultilineCategories();
        }

        positions.length = categories.length;

        if (hasRotatedXAxisLabel) {
            labelsHtml = this._makeRotationLabelsHtml(positions, categories, labelSize, additionalSize);
        } else {
            labelsHtml = this._makeNormalLabelsHtml(positions, categories, labelSize, additionalSize);
        }

        return labelsHtml;
    },

    /**
     * Change position of label area.
     * @param {HTMLElement} labelContainer label area element
     * @param {number} labelSize label size (width or height)
     * @private
     */
    _changeLabelAreaPosition: function(labelContainer, labelSize) {
        var labelHeight;

        if (this.data.isLabelAxis && !this.data.aligned) {
            return;
        }

        if (this.data.isVertical) {
            labelHeight = renderUtil.getRenderedLabelHeight('ABC', this.theme.label);
            labelContainer.style.top = renderUtil.concatStr(parseInt(labelHeight / 2, 10), 'px');
        } else {
            labelContainer.style.left = renderUtil.concatStr('-', parseInt(labelSize / 2, 10), 'px');
        }
    }
});

module.exports = Axis;

},{"../const":20,"../helpers/calculator":43,"../helpers/domHandler":45,"../helpers/renderUtil":49,"./axisTemplate":2}],2:[function(require,module,exports){
/**
 * @fileoverview This is templates or axis view.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var htmls = {
    HTML_AXIS_TICK_LINE: '<div class="tui-chart-tick-line"' +
        ' style="{{ positionType }}:{{ positionValue }}px;{{ sizeType }}:{{ size }}px"></div>',
    HTML_AXIS_TICK: '<div class="tui-chart-tick" style="{{ cssText }}"></div>',
    HTML_AXIS_LABEL: '<div class="tui-chart-label{{ additionalClass }}" style="{{ cssText }}">' +
        '<span{{ spanCssText }}>{{ label }}</span></div>'
};

module.exports = {
    tplTickLine: templateMaker.template(htmls.HTML_AXIS_TICK_LINE),
    tplAxisTick: templateMaker.template(htmls.HTML_AXIS_TICK),
    tplAxisLabel: templateMaker.template(htmls.HTML_AXIS_LABEL)
};

},{"../helpers/templateMaker":50}],3:[function(require,module,exports){
/**
 * @fileoverview chart.js is entry point of Toast UI Chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var chartConst = require('./const'),
    chartFactory = require('./factories/chartFactory'),
    pluginFactory = require('./factories/pluginFactory'),
    themeFactory = require('./factories/themeFactory'),
    mapFactory = require('./factories/mapFactory');

var _createChart;

require('./polyfill');
require('./code-snippet-util');
require('./registerCharts');
require('./registerThemes');

/**
 * Raw series datum.
 * @typedef {{name: ?string, data: Array.<number>, stack: ?string}} rawSeriesDatum
 */

/**
 * Raw series data.
 * @typedef {Array.<rawSeriesDatum>} rawSeriesData
 */

/**
 * Raw data.
 * @typedef {{
 *      categories: ?Array.<string>,
 *      series: (rawSeriesData|{line: ?rawSeriesData, column: ?rawSeriesData})
 * }} rawData
 */

/**
 * NHN Entertainment Toast UI Chart.
 * @namespace tui.chart
 */
tui.util.defineNamespace('tui.chart');

/**
 * Create chart.
 * @param {HTMLElement} container container
 * @param {rawData} rawData raw data
 * @param {{
 *   chart: {
 *     width: number,
 *     height: number,
 *     title: string,
 *     format: string
 *   },
 *   yAxis: {
 *     title: string,
 *     min: number
 *   },
 *   xAxis: {
 *     title: string,
 *     min: number
 *   },
 *   tooltip: {
 *     suffix: string,
 *     template: function
 *   },
 *   theme: string
 * }} options chart options
 * @returns {object} chart instance.
 * @private
 * @ignore
 */
_createChart = function(container, rawData, options) {
    var themeName, theme, chart;

    rawData = JSON.parse(JSON.stringify(rawData));
    options = options ? tui.util.deepCopy(options) : {};
    themeName = options.theme || chartConst.DEFAULT_THEME_NAME;
    theme = themeFactory.get(themeName);

    chart = chartFactory.get(options.chartType, rawData, theme, options);
    container.appendChild(chart.render());
    chart.animateChart();

    return chart;
};

/**
 * Bar chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {rawData} rawData raw data
 *      @param {Array.<string>} rawData.categories categories
 *      @param {Array.<Array>} rawData.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {string} options.yAxis.align align option for diverging option
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.min minimal value of horizontal axis
 *          @param {number} options.xAxis.max maximum value of horizontal axis
 *      @param {object} options.series options of series
 *          @param {string} options.series.stacked stacked type
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {number} options.series.barWidth bar width
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *          @param {boolean} options.series.diverging whether diverging or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Bar Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.barChart(container, rawData, options);
 */
tui.chart.barChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_BAR;
    return _createChart(container, rawData, options);
};

/**
 * Column chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {rawData} rawData raw data
 *      @param {Array.<string>} rawData.categories categories
 *      @param {Array.<Array>} rawData.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *          @param {boolean} options.xAxis.rotation whether label rotation or not (default: true)
 *      @param {object} options.series options of series
 *          @param {string} options.series.stacked stacked type
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {number} options.series.barWidth bar width
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *          @param {boolean} options.series.diverging whether diverging or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} column chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Column Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.columnChart(container, rawData, options);
 */
tui.chart.columnChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_COLUMN;
    return _createChart(container, rawData, options);
};

/**
 * Line chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {rawData} rawData raw data
 *      @param {Array.<string>} rawData.categories categories
 *      @param {Array.<Array>} rawData.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *          @param {boolean} options.xAxis.rotation whether label rotation or not (default: true)
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.hasDot whether has dot or not
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *          @param {boolean} options.series.spline whether spline or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Line Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       },
 *       series: {
 *         hasDot: true
 *       }
 *     };
 * tui.chart.lineChart(container, rawData, options);
 */
tui.chart.lineChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_LINE;
    return _createChart(container, rawData, options);
};

/**
 * Area chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {rawData} rawData raw data
 *      @param {Array.<string>} rawData.categories categories
 *      @param {Array.<Array>} rawData.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *          @param {boolean} options.xAxis.rotation whether label rotation or not (default: true)
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.hasDot whether has dot or not
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *          @param {boolean} options.series.spline whether spline or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Area Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.areaChart(container, rawData, options);
 */
tui.chart.areaChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_AREA;
    return _createChart(container, rawData, options);
};

/**
 * Bubble chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {rawData} rawData raw data
 *      @param {Array.<string>} rawData.categories categories
 *      @param {Array.<Array>} rawData.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *          @param {boolean} options.xAxis.rotation whether label rotation or not (default: true)
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bubble chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [{
 *              x: 10,
 *              y: 20,
 *              r: 15,
 *              label: 'Lable1'
 *           }, {
 *              x: 20,
 *              y: 40,
 *              r: 10,
 *              label: 'Lable2'
 *           }]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [{
 *              x: 40,
 *              y: 10,
 *              r: 5,
 *              label: 'Lable3'
 *           }, {
 *              x: 30,
 *              y: 40,
 *              r: 8,
 *              label: 'Lable4'
 *           }]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Bubble Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.bubbleChart(container, rawData, options);
 */
tui.chart.bubbleChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_BUBBLE;
    return _createChart(container, rawData, options);
};

/**
 * Combo chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {rawData} rawData raw data
 *      @param {Array.<string>} rawData.categories categories
 *      @param {Array.<Array>} rawData.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object|Array} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *          @param {boolean} options.xAxis.rotation whether label rotation or not (default: true)
 *      @param {object} options.series options of series
 *          @param {object} options.series.column options of column series
 *              @param {string} options.series.column.stacked stacked type
 *              @param {boolean} options.series.column.showLabel whether show label or not
 *              @param {number} options.series.column.barWidth bar width
 *              @param {boolean} options.series.column.hasSelection whether has selection or not
 *          @param {object} options.series.line options of line series
 *              @param {boolean} options.series.line.hasDot whether has dot or not
 *              @param {boolean} options.series.line.showLabel whether show label or not
 *              @param {boolean} options.series.line.hasSelection whether has selection or not
 *              @param {boolean} options.series.line.spline whether spline or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {object} options.tooltip.column options of column tooltip
 *              @param {string} options.tooltip.column.suffix suffix of tooltip
 *              @param {function} [options.tooltip.column.template] template of tooltip
 *              @param {string} options.tooltip.column.align tooltip align option
 *              @param {object} options.tooltip.column.position relative position
 *                  @param {number} options.tooltip.column.position.left position left
 *                  @param {number} options.tooltip.column.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: {
 *         column: [
 *           {
 *             name: 'Legend1',
 *             data: [20, 30, 50]]
 *           },
 *           {
 *             name: 'Legend2',
 *             data: [40, 40, 60]
 *           },
 *           {
 *             name: 'Legend3',
 *             data: [60, 50, 10]
 *           },
 *           {
 *             name: 'Legend4',
 *             data: [80, 10, 70]
 *           }
 *         },
 *         line: [
 *           {
 *             name: 'Legend5',
 *             data: [1, 2, 3]
 *           }
 *         ]
 *       }
 *     },
 *     options = {
 *       chart: {
 *         title: 'Combo Chart'
 *       },
 *       yAxis:[
 *         {
 *           title: 'Y Axis',
 *           chartType: 'line'
 *         },
 *         {
 *           title: 'Y Right Axis'
 *         }
 *       ],
 *       xAxis: {
 *         title: 'X Axis'
 *       },
 *       series: {
 *         hasDot: true
 *       }
 *     };
 * tui.chart.comboChart(container, rawData, options);
 */
tui.chart.comboChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_COMBO;
    return _createChart(container, rawData, options);
};

/**
 * Pie chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {rawData} rawData raw data
 *      @param {Array.<Array>} rawData.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left|center|outer)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: 20
 *         },
 *         {
 *           name: 'Legend2',
 *           data: 40
 *         },
 *         {
 *           name: 'Legend3',
 *           data: 60
 *         },
 *         {
 *           name: 'Legend4',
 *           data: 80
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Pie Chart'
 *       }
 *     };
 * tui.chart.pieChart(container, rawData, options);
 */
tui.chart.pieChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_PIE;
    return _createChart(container, rawData, options);
};

/**
 * Map chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {rawData} rawData chart data
 *      @param {Array.<Array>} rawData.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.showLabel whether show label or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left|center|outer)
 *      @param {string} options.theme theme name
 *      @param {string} options.map map type
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       series: [
 *         {
 *           code: 'KR',
 *           data: 100,
 *           labelCoordinate: {
 *             x: 0.6,
 *             y: 0.7
 *           }
 *         },
 *         {
 *           code: 'JP',
 *           data: 50
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Map Chart'
 *       },
 *       map: 'world'
 *     };
 * tui.chart.mapChart(container, rawData, options);
 */
tui.chart.mapChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_MAP;
    options.map = mapFactory.get(options.map);

    return _createChart(container, rawData, options);
};

/**
 * Register theme.
 * @memberOf tui.chart
 * @param {string} themeName theme name
 * @param {object} theme application chart theme
 *      @param {object} theme.chart chart theme
 *          @param {string} theme.chart.fontFamily font family of chart
 *          @param {string} theme.chart.background background of chart
 *      @param {object} theme.title chart theme
 *          @param {number} theme.title.fontSize font size of chart title
 *          @param {string} theme.title.fontFamily font family of chart title
 *          @param {string} theme.title.color font color of chart title
 *          @param {string} theme.title.background background of chart title
 *      @param {object} theme.yAxis theme of vertical axis
 *          @param {object} theme.yAxis.title theme of vertical axis title
 *              @param {number} theme.yAxis.title.fontSize font size of vertical axis title
 *              @param {string} theme.yAxis.title.fontFamily font family of vertical axis title
 *              @param {string} theme.yAxis.title.color font color of vertical axis title
 *          @param {object} theme.yAxis.label theme of vertical axis label
 *              @param {number} theme.yAxis.label.fontSize font size of vertical axis label
 *              @param {string} theme.yAxis.label.fontFamily font family of vertical axis label
 *              @param {string} theme.yAxis.label.color font color of vertical axis label
 *          @param {string} theme.yAxis.tickColor color of vertical axis tick
 *      @param {object} theme.xAxis theme of horizontal axis
 *          @param {object} theme.xAxis.title theme of horizontal axis title
 *              @param {number} theme.xAxis.title.fontSize font size of horizontal axis title
 *              @param {string} theme.xAxis.title.fontFamily font family of horizontal axis title
 *              @param {string} theme.xAxis.title.color font color of horizontal axis title
 *          @param {object} theme.xAxis.label theme of horizontal axis label
 *              @param {number} theme.xAxis.label.fontSize font size of horizontal axis label
 *              @param {string} theme.xAxis.label.fontFamily font family of horizontal axis label
 *              @param {string} theme.xAxis.label.color font color of horizontal axis label
 *          @param {string} theme.xAxis.tickColor color of horizontal axis tick
 *      @param {object} theme.plot plot theme
 *          @param {string} theme.plot.lineColor plot line color
 *          @param {string} theme.plot.background plot background
 *      @param {object} theme.series series theme
 *          @param {Array.<string>} theme.series.colors series colors
 *          @param {string} theme.series.borderColor series border color
 *          @param {string} theme.series.selectionColor series selection color
 *          @param {string} theme.series.startColor start color for map chart
 *          @param {string} theme.series.endColor end color for map chart
 *          @param {string} theme.series.overColor end color for map chart
 *      @param {object} theme.legend legend theme
 *          @param {object} theme.legend.label theme of legend label
 *              @param {number} theme.legend.label.fontSize font size of legend label
 *              @param {string} theme.legend.label.fontFamily font family of legend label
 *              @param {string} theme.legend.label.color font color of legend label
 * @api
 * @example
 * var theme = {
 *   yAxis: {
 *     tickColor: '#ccbd9a',
 *       title: {
 *         color: '#333333'
 *       },
 *       label: {
 *         color: '#6f491d'
 *       }
 *     },
 *     xAxis: {
 *       tickColor: '#ccbd9a',
 *       title: {
 *         color: '#333333'
 *       },
 *       label: {
 *         color: '#6f491d'
 *       }
 *     },
 *     plot: {
 *       lineColor: '#e5dbc4',
 *       background: '#f6f1e5'
 *     },
 *     series: {
 *       colors: ['#40abb4', '#e78a31', '#c1c452', '#795224', '#f5f5f5'],
 *       borderColor: '#8e6535',
 *       selectionColor: '#cccccc',
 *       startColor: '#efefef',
 *       endColor: 'blue',
 *       overColor: 'yellow'
 *     },
 *     legend: {
 *       label: {
 *         color: '#6f491d'
 *       }
 *     }
 *   };
 * tui.chart.registerTheme('newTheme', theme);
 */
tui.chart.registerTheme = function(themeName, theme) {
    themeFactory.register(themeName, theme);
};

/**
 * Register map.
 * @param {string} mapName map name
 * @param {Array.<{code: string, name: string, path: string}>} data map data
 * @api
 * @example
 * var data = [
 *   {
 *     code: 'KR',
 *     name: 'South Korea',
 *     path: 'M835.13,346.53L837.55,350.71...',
 *     labelCoordinate: {
 *       x: 0.6,
 *       y: 0.7
 *     }
 *   },
 *   //...
 * ];
 * tui.chart.registerMap('newMap', data);
 */
tui.chart.registerMap = function(mapName, data) {
    mapFactory.register(mapName, data);
};

/**
 * Register graph plugin.
 * @memberOf tui.chart
 * @param {string} libType type of graph library
 * @param {object} plugin plugin to control library
 * @example
 * var pluginRaphael = {
 *   bar: function() {} // Render class
 * };
 * tui.chart.registerPlugin('raphael', pluginRaphael);
 */
tui.chart.registerPlugin = function(libType, plugin) {
    pluginFactory.register(libType, plugin);
};

},{"./code-snippet-util":19,"./const":20,"./factories/chartFactory":36,"./factories/mapFactory":37,"./factories/pluginFactory":38,"./factories/themeFactory":39,"./polyfill":71,"./registerCharts":72,"./registerThemes":73}],4:[function(require,module,exports){
/**
 * @fileoverview Area chart
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    lineTypeMixer = require('./lineTypeMixer'),
    axisTypeMixer = require('./axisTypeMixer'),
    rawDataHandler = require('../helpers/rawDataHandler'),
    Series = require('../series/areaChartSeries');

var AreaChart = tui.util.defineClass(ChartBase, /** @lends LineChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-area-chart',

    /**
     * Series class
     * @type {function}
     */
    Series: Series,

    /**
     * Area chart.
     * @constructs AreaChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     * @mixes axisTypeMixer
     * @mixes lineTypeMixer
     */
    init: function(rawData, theme, options) {
        rawDataHandler.removeSeriesStack(rawData.series);
        this._lineTypeInit(rawData, theme, options);
    }
});

axisTypeMixer.mixin(AreaChart);
lineTypeMixer.mixin(AreaChart);

module.exports = AreaChart;

},{"../helpers/rawDataHandler":48,"../series/areaChartSeries":74,"./axisTypeMixer":5,"./chartBase":9,"./lineTypeMixer":14}],5:[function(require,module,exports){
/**
 * @fileoverview axisTypeMixer is mixer of axis type chart(bar, column, line, area).
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var renderUtil = require('../helpers/renderUtil'),
    ChartBase = require('./chartBase'),
    Axis = require('../axes/axis'),
    Plot = require('../plots/plot'),
    Legend = require('../legends/legend'),
    GroupTypeCustomEvent = require('../customEvents/groupTypeCustomEvent'),
    BoundsTypeCustomEvent = require('../customEvents/boundsTypeCustomEvent'),
    Tooltip = require('../tooltips/tooltip'),
    GroupTooltip = require('../tooltips/groupTooltip');


/**
 * Axis limit value.
 * @typedef {{min: number, max: number}} axisLimit
 */

/**
 * axisTypeMixer is base class of axis type chart(bar, column, line, area).
 * @mixin
 */
var axisTypeMixer = {
    /**
     * Add axis components.
     * @param {Array.<object>} axes axes option
     * @param {boolean} aligned whether aligned or not
     * @private
     */
    _addAxisComponents: function(axes, aligned) {
        var self = this;
        tui.util.forEach(axes, function(axis) {
            var axisParams = {
                aligned: aligned,
                isLabel: !!axis.isLabel,
                chartType: axis.chartType
            };

            if (axis.name === 'rightYAxis') {
                axisParams.componentType = 'yAxis';
                axisParams.index = 1;
            }

            self.componentManager.register(axis.name, Axis, axisParams);
        });
    },

    /**
     * Add series components
     * @param {Array<object>} serieses serieses
     * @param {object} options options
     * @param {boolean} aligned whether aligned or not
     * @private
     */
    _addSeriesComponents: function(serieses, options) {
        var self = this,
            seriesBaseParams = {
                libType: options.libType,
                chartType: options.chartType,
                userEvent: this.userEvent,
                componentType: 'series'
            };

        tui.util.forEach(serieses, function(series) {
            var seriesParams = tui.util.extend(seriesBaseParams, series.data);
            self.componentManager.register(series.name, series.SeriesClass, seriesParams);
        });
    },

    /**
     * Add tooltip component
     * @private
     */
    _addTooltipComponent: function() {
        var TooltipClass = this.hasGroupTooltip ? GroupTooltip : Tooltip;
        this.componentManager.register('tooltip', TooltipClass, this._makeTooltipData());
    },

    /**
     * Add legend component.
     * @param {Array.<string>} chartTypes series chart types
     * @param {string} chartType chartType
     * @param {object} legendOptions legend options
     * @private
     */
    _addLegendComponent: function(chartTypes, chartType, legendOptions) {
        if (!legendOptions || !legendOptions.hidden) {
            this.componentManager.register('legend', Legend, {
                chartTypes: chartTypes,
                chartType: chartType,
                userEvent: this.userEvent
            });
        }
    },

    /**
     * Add components for axis type chart.
     * @param {object} params parameters
     *      @param {object} params.axes axes data
     *      @param {object} params.plotData plot data
     *      @param {function} params.serieses serieses
     * @private
     */
    _addComponentsForAxisType: function(params) {
        var options = this.options,
            aligned = !!params.aligned;

        this.componentManager.register('plot', Plot);
        this._addAxisComponents(params.axes, aligned);
        this._addLegendComponent(params.seriesChartTypes, params.chartType, this.options.legend);
        this._addSeriesComponents(params.serieses, options);
        this._addTooltipComponent(options.chartType);
    },

    /**
     * Get limit map.
     * @param {{yAxis: object, xAxis: object}} axesData axes data
     * @param {Array.<string>} chartTypes chart types
     * @returns {{column: ?axisLimit, line: ?axisLimit}} limit map
     * @private
     */
    _getLimitMap: function(axesData, chartTypes) {
        var limitMap = {},
            yAxisLimit = axesData.yAxis ? axesData.yAxis.limit : axesData.rightYAxis.limit;

        limitMap[chartTypes[0]] = this.isVertical ? yAxisLimit : axesData.xAxis.limit;

        if (chartTypes.length > 1) {
            limitMap[chartTypes[1]] = axesData.rightYAxis ? axesData.rightYAxis.limit : yAxisLimit;
        }

        return limitMap;
    },

    /**
     * Make series data for rendering.
     * @param {{yAxis: object, xAxis: object}} axesData axes data
     * @param {Array.<string>} chartTypes chart types
     * @param {boolean} isVertical whether vertical or not
     * @returns {object} series data
     * @private
     */
    _makeSeriesDataForRendering: function(axesData, chartTypes) {
        var limitMap = this._getLimitMap(axesData, chartTypes),
            aligned = axesData.xAxis.aligned,
            seriesData = {};

        tui.util.forEachArray(chartTypes, function(chartType) {
            seriesData[chartType + 'Series'] = {
                limit: limitMap[chartType],
                aligned: aligned,
                hasAxes: true
            };
        });

        return seriesData;
    },

    /**
     * Add data ratios.
     * @private
     * @override
     */
    _addDataRatios: function() {
        var self = this;
        var axesData = this.boundsMaker.getAxesData();
        var chartTypes = this.chartTypes || [this.chartType];
        var limitMap = this._getLimitMap(axesData, chartTypes);
        var stackedOption = this.options.series && this.options.series.stacked;

        tui.util.forEachArray(chartTypes, function(chartType) {
            self.dataProcessor.addDataRatios(limitMap[chartType], stackedOption, chartType);
        });
    },

    /**
     * Make rendering data for axis type chart.
     * @returns {object} data for rendering
     * @private
     * @override
     */
    _makeRenderingData: function() {
        var axesData = this.boundsMaker.getAxesData();
        var optionChartTypes = this.chartTypes || [this.chartType];
        var seriesData = this._makeSeriesDataForRendering(axesData, optionChartTypes, this.isVertical);
        var yAxis = axesData.yAxis ? axesData.yAxis : axesData.rightYAxis;

        return tui.util.extend({
            plot: {
                vTickCount: yAxis.validTickCount,
                hTickCount: axesData.xAxis.validTickCount
            },
            customEvent: {
                tickCount: this.isVertical ? axesData.xAxis.tickCount : yAxis.tickCount
            }
        }, seriesData, axesData);
    },

    /**
     * Add grouped event handler layer.
     * @private
     * @override
     */
    _addCustomEventComponentForGroupTooltip: function() {
        this.componentManager.register('customEvent', GroupTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical
        });
    },

    /**
     * Add custom event component for normal tooltip.
     * @private
     */
    _addCustomEventComponentForNormalTooltip: function() {
        this.componentManager.register('customEvent', BoundsTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical
        });
    },

    /**
     * Add custom event component.
     * @private
     */
    _addCustomEventComponent: function() {
        if (this.hasGroupTooltip) {
            this._addCustomEventComponentForGroupTooltip();
        } else {
            this._addCustomEventComponentForNormalTooltip();
        }
    },

    /**
     * Attach coordinate event.
     * @param {CustomEvent} customEvent custom event component
     * @param {Tooltip} tooltip tooltip component
     * @param {Array.<Series>} serieses series components
     * @private
     */
    _attachCustomEventForGroupTooltip: function(customEvent, tooltip, serieses) {
        customEvent.on('showGroupTooltip', tooltip.onShow, tooltip);
        customEvent.on('hideGroupTooltip', tooltip.onHide, tooltip);

        tui.util.forEach(serieses, function(series) {
            if (series.onShowGroupTooltipLine) {
                tooltip.on('showGroupTooltipLine', series.onShowGroupTooltipLine, series);
                tooltip.on('hideGroupTooltipLine', series.onHideGroupTooltipLine, series);
            }
            tooltip.on('showGroupAnimation', series.onShowGroupAnimation, series);
            tooltip.on('hideGroupAnimation', series.onHideGroupAnimation, series);
        });
    },

    /**
     * Attach custom event for normal tooltip.
     * @param {CustomEvent} customEvent custom event component
     * @param {Tooltip} tooltip tooltip component
     * @param {Array.<Series>} serieses series components
     * @private
     */
    _attachCustomEventForNormalTooltip: function(customEvent, tooltip, serieses) {
        customEvent.on('showTooltip', tooltip.onShow, tooltip);
        customEvent.on('hideTooltip', tooltip.onHide, tooltip);

        tui.util.forEach(serieses, function(series) {
            var showAnimationEventName, hideAnimationEventName;

            if (series.onShowAnimation) {
                showAnimationEventName = renderUtil.makeCustomEventName('show', series.chartType, 'animation');
                hideAnimationEventName = renderUtil.makeCustomEventName('hide', series.chartType, 'animation');
                tooltip.on(showAnimationEventName, series.onShowAnimation, series);
                tooltip.on(hideAnimationEventName, series.onHideAnimation, series);
            }
        });
    },

    /**
     * Attach custom event for series selection.
     * @param {CustomEvent} customEvent custom event component
     * @param {Array.<Series>} serieses series components
     * @private
     */
    _attachCustomEventForSeriesSelection: function(customEvent, serieses) {
        tui.util.forEach(serieses, function(series) {
            var selectSeriesEventName = renderUtil.makeCustomEventName('select', series.chartType, 'series'),
                unselectSeriesEventName = renderUtil.makeCustomEventName('unselect', series.chartType, 'series');

            customEvent.on(selectSeriesEventName, series.onSelectSeries, series);
            customEvent.on(unselectSeriesEventName, series.onUnselectSeries, series);
        });
    },

    /**
     * Attach custom event.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var serieses = this.componentManager.where({componentType: 'series'}),
            customEvent = this.componentManager.get('customEvent'),
            tooltip = this.componentManager.get('tooltip');

        ChartBase.prototype._attachCustomEvent.call(this, serieses);

        if (this.hasGroupTooltip) {
            this._attachCustomEventForGroupTooltip(customEvent, tooltip, serieses);
        } else {
            this._attachCustomEventForNormalTooltip(customEvent, tooltip, serieses);
        }

        this._attachCustomEventForSeriesSelection(customEvent, serieses);
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = axisTypeMixer;

},{"../axes/axis":1,"../customEvents/boundsTypeCustomEvent":24,"../customEvents/groupTypeCustomEvent":26,"../helpers/renderUtil":49,"../legends/legend":53,"../plots/plot":58,"../tooltips/groupTooltip":87,"../tooltips/tooltip":91,"./chartBase":9}],6:[function(require,module,exports){
/**
 * @fileoverview Bar chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    chartConst = require('../const'),
    axisTypeMixer = require('./axisTypeMixer'),
    barTypeMixer = require('./barTypeMixer'),
    predicate = require('../helpers/predicate'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    Series = require('../series/barChartSeries');

var BarChart = tui.util.defineClass(ChartBase, /** @lends BarChart.prototype */ {
    /**
     * Bar chart.
     * @constructs BarChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        /**
         * className
         * @type {string}
         */
        this.className = 'tui-bar-chart';

        /**
         * Whether has right y axis or not.
         * @type {boolean}
         */
        this.hasRightYAxis = false;

        options.yAxis = options.yAxis || {};
        options.xAxis = options.xAxis || {};
        options.plot = options.plot || {};
        options.series = options.series || {};

        if (predicate.isValidStackedOption(options.series.stacked)) {
            rawData.series = this._sortRawSeriesData(rawData.series);
        }

        if (options.series.diverging) {
            rawData.series = this._makeRawSeriesDataForDiverging(rawData.series, options.series.stacked);
            this._updateDivergingOption(options);
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Update options for diverging option.
     * @param {object} options options
     * @private
     */
    _updateDivergingOption: function(options) {
        var isCenter;

        options.series.stacked = options.series.stacked || chartConst.STACKED_NORMAL_TYPE;
        this.hasRightYAxis = tui.util.isArray(options.yAxis) && options.yAxis.length > 1;

        isCenter = predicate.isYAxisAlignCenter(this.hasRightYAxis, options.yAxis.align);

        options.yAxis.isCenter = isCenter;
        options.xAxis.divided = isCenter;
        options.series.divided = isCenter;
        options.plot.divided = isCenter;
    },

    /**
     * Make axes data
     * @param {object} bounds chart bounds
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        var axisScaleMaker = this._createAxisScaleMaker({
                min: this.options.xAxis.min,
                max: this.options.xAxis.max
            }, {
                areaType: 'xAxis'
            }),
            xAxisData = axisDataMaker.makeValueAxisData({
                axisScaleMaker: axisScaleMaker
            }),
            yAxisData = axisDataMaker.makeLabelAxisData({
                labels: this.dataProcessor.getCategories(),
                isVertical: true
            }),
            axesData = {
                xAxis: xAxisData,
                yAxis: yAxisData
            };

        if (this.hasRightYAxis) {
            axesData.rightYAxis = tui.util.extend({
                isPositionRight: true
            }, JSON.parse(JSON.stringify(yAxisData)));
        }

        return axesData;
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        var axes = [
            {
                name: 'yAxis',
                isLabel: true
            },
            {
                name: 'xAxis'
            }
        ];

        if (this.hasRightYAxis) {
            axes.push({
                name: 'rightYAxis',
                isLabe: true
            });
        }
        this._addComponentsForAxisType({
            axes: axes,
            chartType: chartType,
            serieses: [
                {
                    name: 'barSeries',
                    SeriesClass: Series
                }
            ]
        });
    },

    /**
     * On change selected legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     */
    onChangeCheckedLegends: function(checkedLegends) {
        var boundParams;

        if (this.hasRightYAxis) {
            boundParams = {
                optionChartTypes: ['bar', 'bar']
            };
        }

        ChartBase.prototype.onChangeCheckedLegends.call(this, checkedLegends, null, boundParams);
    }
});

axisTypeMixer.mixin(BarChart);
barTypeMixer.mixin(BarChart);

module.exports = BarChart;

},{"../const":20,"../helpers/axisDataMaker":40,"../helpers/predicate":47,"../series/barChartSeries":75,"./axisTypeMixer":5,"./barTypeMixer":7,"./chartBase":9}],7:[function(require,module,exports){
/**
 * @fileoverview barTypeMixer is mixer of bar type chart(bar, column).
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    rawDataHandler = require('../helpers/rawDataHandler'),
    predicate = require('../helpers/predicate');

/**
 * barTypeMixer is mixer of bar type chart(bar, column).
 * @mixin
 */
var barTypeMixer = {
    /**
     * Make minus values.
     * @param {Array.<number>} data number data
     * @returns {Array} minus values
     * @private
     */
    _makeMinusValues: function(data) {
        return tui.util.map(data, function(value) {
            return value < 0 ? 0 : -value;
        });
    },

    /**
     * Make plus values.
     * @param {Array.<number>} data number data
     * @returns {Array} plus values
     * @private
     */
    _makePlusValues: function(data) {
        return tui.util.map(data, function(value) {
            return value < 0 ? 0 : value;
        });
    },

    /**
     * Make normal diverging raw series data.
     * @param {{data: Array.<number>}} rawSeriesData raw series data
     * @returns {{data: Array.<number>}} changed raw series data
     * @private
     */
    _makeNormalDivergingRawSeriesData: function(rawSeriesData) {
        rawSeriesData.length = Math.min(rawSeriesData.length, 2);

        rawSeriesData[0].data = this._makeMinusValues(rawSeriesData[0].data);

        if (rawSeriesData[1]) {
            rawSeriesData[1].data = this._makePlusValues(rawSeriesData[1].data);
        }

        return rawSeriesData;
    },

    /**
     * Make stacked diverging raw series data.
     * @param {{data: Array.<number>, stack: string}} rawSeriesData raw series data
     * @returns {{data: Array.<number>}} changed raw series data
     * @private
     */
    _makeStackedDivergingRawSeriesData: function(rawSeriesData) {
        var self = this,
            stacks = rawDataHandler.pickStacks(rawSeriesData),
            result = [],
            leftStack = stacks[0],
            rightStack = stacks[1];

        rawSeriesData = rawDataHandler.sortSeriesData(rawSeriesData, stacks);

        tui.util.forEachArray(rawSeriesData, function(seriesDatum) {
            var stack = seriesDatum.stack || chartConst.DEFAULT_STACK;
            if (stack === leftStack) {
                seriesDatum.data = self._makeMinusValues(seriesDatum.data);
                result.push(seriesDatum);
            } else if (stack === rightStack) {
                seriesDatum.data = self._makePlusValues(seriesDatum.data);
                result.push(seriesDatum);
            }
        });
        return result;
    },

    /**
     * Make raw series data for diverging.
     * @param {{data: Array.<number>, stack: string}} rawSeriesData raw series data
     * @param {?string} stackedOption stacked option
     * @returns {{data: Array.<number>}} changed raw series data
     * @private
     */
    _makeRawSeriesDataForDiverging: function(rawSeriesData, stackedOption) {
        if (predicate.isValidStackedOption(stackedOption)) {
            rawSeriesData = this._makeStackedDivergingRawSeriesData(rawSeriesData);
        } else {
            rawSeriesData = this._makeNormalDivergingRawSeriesData(rawSeriesData);
        }

        return rawSeriesData;
    },

    /**
     * Sort raw series data from stacks.
     * @param {Array.<{data: Array.<number>, stack: string}>} rawSeriesData raw series data
     * @returns {Array.<{data: Array.<number>, stack: string}>}
     * @private
     */
    _sortRawSeriesData: function(rawSeriesData) {
        var stacks = rawDataHandler.pickStacks(rawSeriesData);

        return rawDataHandler.sortSeriesData(rawSeriesData, stacks);
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = barTypeMixer;

},{"../const":20,"../helpers/predicate":47,"../helpers/rawDataHandler":48}],8:[function(require,module,exports){
/**
 * @fileoverview Bubble chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var chartConst = require('../const');
var Series = require('../series/bubbleChartSeries');
var CircleLegend = require('../legends/circleLegend');
var axisTypeMixer = require('./axisTypeMixer');
var axisDataMaker = require('../helpers/axisDataMaker');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');
var SimpleCustomEvent = require('../customEvents/simpleCustomEvent');

var BubbleChart = tui.util.defineClass(ChartBase, /** @lends BubbleChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-bubble-chart',
    /**
     * Bubble chart.
     * @constructs BubbleChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        options.tooltip = options.tooltip || {};

        this.axisScaleMakerMap = null;

        if (!options.tooltip.align) {
            options.tooltip.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Pick limit from options
     * @param {{min: number, max: number, title: string}} options - axis options
     * @returns {{min: number, max: number}}
     * @private
     */
    _pickLimitFromOptions: function(options) {
        options = options || {};

        return {
            min: options.min,
            max: options.max
        };
    },

    /**
     * Create AxisScaleMaker for bubble chart.
     * @param {{min: number, max: number, title: string}} options - axis options
     * @param {string} areaType - type of area like xAxis, yAxis
     * @param {string} valueType - type of value like x, y, r
     * @returns {AxisScaleMaker}
     * @override
     * @private
     */
    _createAxisScaleMaker: function(options, areaType, valueType) {
        var limit = this._pickLimitFromOptions(options);
        var additionalParams = {
            areaType: areaType,
            valueType: valueType
        };

        return ChartBase.prototype._createAxisScaleMaker.call(this, limit, additionalParams, this.chartType);
    },

    /**
     * Make map for AxisScaleMaker of axes(xAxis, yAxis).
     * @returns {Object.<string, AxisScaleMaker>}
     * @private
     */
    _makeAxisScaleMakerMap: function() {
        var hasCategories = this.dataProcessor.hasCategories();
        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType);
        var isXCountGreaterThanYCount = seriesDataModel.isXCountGreaterThanYCount();
        var options = this.options;
        var scaleMakerMap = {};

        if (hasCategories) {
            if (isXCountGreaterThanYCount) {
                scaleMakerMap.xAxis = this._createAxisScaleMaker(options.xAxis, 'xAxis', 'x');
            } else {
                scaleMakerMap.yAxis = this._createAxisScaleMaker(options.yAxis, 'yAxis', 'y');
            }
        } else {
            scaleMakerMap.xAxis = this._createAxisScaleMaker(options.xAxis, 'xAxis', 'x');
            scaleMakerMap.yAxis = this._createAxisScaleMaker(options.yAxis, 'yAxis', 'y');
        }

        return scaleMakerMap;
    },

    /**
     * Get map for AxisScaleMaker of axes(xAxis, yAxis).
     * @returns {Object.<string, AxisScaleMaker>}
     * @private
     */
    _getAxisScaleMakerMap: function() {
        if (!this.axisScaleMakerMap) {
            this.axisScaleMakerMap = this._makeAxisScaleMakerMap();
        }

        return this.axisScaleMakerMap;
    },

    /**
     * Make axis data.
     * @param {AxisScaleMaker} axisScaleMaker - AxisScaleMaker
     * @param {boolean} [isVertical] - whether vertical or not
     * @returns {object}
     * @private
     */
    _makeAxisData: function(axisScaleMaker, isVertical) {
        var axisData;

        if (axisScaleMaker) {
            axisData = axisDataMaker.makeValueAxisData({
                axisScaleMaker: axisScaleMaker,
                isVertical: !!isVertical
            });
        } else {
            axisData = axisDataMaker.makeLabelAxisData({
                labels: this.dataProcessor.getCategories(),
                isVertical: !!isVertical
            });
        }

        return axisData;
    },

    /**
     * Make axes data
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        var axisScaleMakerMap = this._getAxisScaleMakerMap();

        return {
            xAxis: this._makeAxisData(axisScaleMakerMap.xAxis),
            yAxis: this._makeAxisData(axisScaleMakerMap.yAxis, true)
        };
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        this._addComponentsForAxisType({
            axes: [
                {
                    name: 'yAxis'
                },
                {
                    name: 'xAxis'
                }
            ],
            chartType: chartType,
            serieses: [
                {
                    name: 'bubbleSeries',
                    SeriesClass: Series
                }
            ]
        });

        if (!tui.util.pick(this.options, 'circleLegend', 'hidden')) {
            this.componentManager.register('circleLegend', CircleLegend, {
                chartType: chartType,
                baseFontFamily: this.theme.chart.fontFamily
            });
        }
    },

    /**
     * Get width of max label of CircleLegend.
     * @returns {number}
     * @private
     */
    _getMaxCircleLegendLabelWidth: function() {
        var maxLabel = this.dataProcessor.getFormattedMaxValue(this.chartType, 'circleLegend', 'r');
        var maxLabelWidth = renderUtil.getRenderedLabelWidth(maxLabel, {
            fontSize: chartConst.CIRCLE_LEGEND_LABEL_FONT_SIZE,
            fontFamily: this.theme.chart.fontFamily
        });

        return maxLabelWidth;
    },

    /**
     * Get width of circle legend area.
     * @returns {number}
     * @private
     */
    _getCircleLegendWidth: function() {
        var maxRadius = this.boundsMaker.getMinimumPixelStepForAxis();
        var circleWidth = (maxRadius * 2) + chartConst.CIRCLE_LEGEND_PADDING;
        var maxLabelWidth = this._getMaxCircleLegendLabelWidth();

        return Math.max(circleWidth, maxLabelWidth);
    },

    /**
     * Update width of legend and series of boundsMaker.
     * @param {number} seriesWidth - width of series area
     * @param {number} legendWidth - width of legend area
     * @private
     */
    _updateLegendAndSeriesWidth: function(seriesWidth, legendWidth) {
        var circleLegendWidth = this._getCircleLegendWidth();
        var legendAlignOption = tui.util.pick(this.options, 'legend', 'align');

        if (!predicate.isHorizontalLegend(legendAlignOption)) {
            this.boundsMaker.registerBaseDimension('legend', {
                width: circleLegendWidth
            });
        }

        this.boundsMaker.registerBaseDimension('series', {
            width: seriesWidth - (circleLegendWidth - legendWidth)
        });
    },

    /**
     * Update axesData of boundsMaker.
     * @private
     */
    _updateAxesDataOfBoundsMaker: function() {
        var newAxesData;

        this.axisScaleMakerMap = null;
        newAxesData = this._makeAxesData();
        this.boundsMaker.registerAxesData(newAxesData);
    },

    /**
     * Whether changed max radius or not.
     * @param {boolean} beforeMaxRadius - before max radius
     * @returns {boolean}
     */
    isChangedMaxRadius: function(beforeMaxRadius) {
        var afterMaxRadius = this.boundsMaker.getMinimumPixelStepForAxis();

        return (beforeMaxRadius !== afterMaxRadius);
    },

    /**
     * Update width of legend area by width of circle legend area.
     * @private
     */
    _updateLegendWidthByCircleLegendWidth: function() {
        var boundsMaker = this.boundsMaker;
        var axesData = boundsMaker.getAxesData();
        var circleLegendWidth = this._getCircleLegendWidth();
        var legendWidth = boundsMaker.getDimension('calculationLegend').width;
        var isXAxisLabel, beforeMaxRadius, seriesWidth;

        if (legendWidth >= circleLegendWidth) {
            return;
        }

        isXAxisLabel = axesData.xAxis.isLabel;
        seriesWidth = boundsMaker.getDimension('series').width;
        beforeMaxRadius = boundsMaker.getMinimumPixelStepForAxis();

        this._updateLegendAndSeriesWidth(seriesWidth, legendWidth);

        if (!isXAxisLabel) {
            this._updateAxesDataOfBoundsMaker(isXAxisLabel);
        }

        if (this.isChangedMaxRadius(beforeMaxRadius)) {
            this._updateLegendAndSeriesWidth(seriesWidth, legendWidth);

            if (!isXAxisLabel) {
                this._updateAxesDataOfBoundsMaker(isXAxisLabel);
            }
        }
    },

    /**
     * Register dimension of circle legend.
     * @private
     */
    _registerCircleLegendDimension: function() {
        var circleLegendWidth = this._getCircleLegendWidth();

        this.boundsMaker.registerBaseDimension('circleLegend', {
            width: circleLegendWidth,
            height: circleLegendWidth
        });
    },

    /**
     * Update dimensions.
     * @param {{xAxis: object, yAxis: object}} axesData - data for rendering of axis area(x axis and y axis).
     * @private
     * @override
     */
    _updateDimensions: function() {
        if (predicate.isHidden(this.options.circleLegend)) {
            return;
        }

        this._updateLegendWidthByCircleLegendWidth();
        this._registerCircleLegendDimension();
    },

    /**
     * Rerender.
     * @private
     */
    _rerender: function() {
        this.axisScaleMakerMap = null;
        ChartBase.prototype._rerender.apply(this, arguments);
    }
});

axisTypeMixer.mixin(BubbleChart);

/**
 * Add data ratios.
 * @private
 * @override
 */
BubbleChart.prototype._addDataRatios = function() {
    var scaleMakerMap = this._getAxisScaleMakerMap(),
        limitMap = {};

    if (scaleMakerMap.xAxis) {
        limitMap.x = scaleMakerMap.xAxis.getLimit();
    }

    if (scaleMakerMap.yAxis) {
        limitMap.y = scaleMakerMap.yAxis.getLimit();
    }

    this.dataProcessor.addDataRatiosForCoordinateType(limitMap);
};

/**
 * Add custom event component for normal tooltip.
 * @private
 */
BubbleChart.prototype._attachCustomEvent = function() {
    var componentManager = this.componentManager;
    var customEvent = componentManager.get('customEvent');
    var bubbleSeries = componentManager.get('bubbleSeries');
    var tooltip = componentManager.get('tooltip');

    axisTypeMixer._attachCustomEvent.call(this);

    customEvent.on({
        clickBubbleSeries: bubbleSeries.onClickSeries,
        moveBubbleSeries: bubbleSeries.onMoveSeries
    }, bubbleSeries);

    bubbleSeries.on({
        showTooltip: tooltip.onShow,
        hideTooltip: tooltip.onHide,
        showTooltipContainer: tooltip.onShowTooltipContainer,
        hideTooltipContainer: tooltip.onHideTooltipContainer
    }, tooltip);
};

/**
 * Add custom event component.
 * @private
 */
BubbleChart.prototype._addCustomEventComponent = function() {
    this.componentManager.register('customEvent', SimpleCustomEvent, {
        chartType: this.chartType
    });
};

module.exports = BubbleChart;

},{"../const":20,"../customEvents/simpleCustomEvent":28,"../helpers/axisDataMaker":40,"../helpers/predicate":47,"../helpers/renderUtil":49,"../legends/circleLegend":52,"../series/bubbleChartSeries":77,"./axisTypeMixer":5,"./chartBase":9}],9:[function(require,module,exports){
/**
 * @fileoverview ChartBase
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ComponentManager = require('./componentManager'),
    DefaultDataProcessor = require('../dataModels/dataProcessor'),
    BoundsMaker = require('../helpers/boundsMaker'),
    AxisScaleMaker = require('../helpers/axisScaleMaker'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    UserEventListener = require('../helpers/userEventListener');

var ChartBase = tui.util.defineClass(/** @lends ChartBase.prototype */ {
    /**
     * Chart base.
     * @constructs ChartBase
     * @param {object} params parameters
     *      @param {object} params.rawData raw data
     *      @param {object} params.theme chart theme
     *      @param {object} params.options chart options
     *      @param {boolean} params.hasAxes whether has axes or not
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {DataProcessor} params.DataProcessor DataProcessor
     */
    init: function(params) {
        /**
         * raw data.
         * @type {object}
         */
        this.rawData = params.rawData;

        /**
         * theme
         * @type {object}
         */
        this.theme = params.theme;

        /**
         * options
         * @type {object}
         */
        this.options = params.options;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = this.options.chartType;

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = params.hasAxes;

        /**
         * whether vertical or not
         * @type {boolean}
         */
        this.isVertical = !!params.isVertical;

        /**
         * whether chart has group tooltip or not
         * @type {boolean}
         */
        this.hasGroupTooltip = !!tui.util.pick(this.options, 'tooltip', 'grouped');

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = this._createDataProcessor(params.DataProcessor || DefaultDataProcessor, params);

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = new BoundsMaker({
            options: this.options,
            theme: this.theme,
            dataProcessor: this.dataProcessor,
            hasAxes: this.hasAxes,
            isVertical: this.isVertical,
            chartType: this.chartType
        });

        /**
         * component manager
         * @type {ComponentManager}
         */
        this.componentManager = new ComponentManager({
            dataProcessor: this.dataProcessor,
            options: this.options,
            theme: this.theme,
            boundsMaker: this.boundsMaker,
            hasAxes: this.hasAxes
        });

        /**
         * user event listener
         * @type {object}
         */
        this.userEvent = new UserEventListener();

        this._addCustomEventComponent();
    },

    /**
     * Create dataProcessor.
     * @param {DataProcessor} DataProcessor DataProcessor class
     * @param {object} params parameters
     *      @params {object} rawData raw data
     *      @params {{chart: object, chartType: string}} options chart options
     *      @params {Array} seriesChartTypes series chart types
     * @returns {object} data processor
     * @private
     */
    _createDataProcessor: function(DataProcessor, params) {
        var dataProcessor = new DataProcessor(params.rawData, this.chartType, params.options, params.seriesChartTypes);

        return dataProcessor;
    },

    /**
     * Create axis scale maker.
     * @param {{min: number, max: number}} limitOption limit
     * @param {?object} additionalParams additional parameters
     * @param {string} chartType chart type
     * @returns {AxisScaleMaker}
     * @private
     */
    _createAxisScaleMaker: function(limitOption, additionalParams, chartType) {
        var seriesOptions = this.options.series || {};

        chartType = chartType || this.chartType;
        seriesOptions = seriesOptions[chartType] || seriesOptions;

        return new AxisScaleMaker(tui.util.extend({
            dataProcessor: this.dataProcessor,
            boundsMaker: this.boundsMaker,
            options: {
                stacked: seriesOptions.stacked,
                diverging: seriesOptions.diverging,
                limit: limitOption
            },
            isVertical: this.isVertical,
            chartType: chartType
        }, additionalParams));
    },

    /**
     * Make data for tooltip component.
     * @returns {object} tooltip data
     * @private
     */
    _makeTooltipData: function() {
        return {
            isVertical: this.isVertical,
            userEvent: this.userEvent,
            chartType: this.chartType
        };
    },

    /**
     * Add custom event component.
     * @private
     * @abstract
     */
    _addCustomEventComponent: function() {},

    /**
     * Make rendering data for axis type chart.
     * @returns {object} rendering data.
     * @private
     */
    _makeRenderingData: function() {
        return {};
    },

    /**
     * Attach custom evnet.
     * @param {Array.<object>} serieses serieses
     * @private
     */
    _attachCustomEvent: function(serieses) {
        var legend = this.componentManager.get('legend');

        serieses = serieses || this.componentManager.where({componentType: 'series'});

        if (legend) {
            legend.on('changeCheckedLegends', this.onChangeCheckedLegends, this);
            tui.util.forEach(serieses, function(series) {
                var selectLegendEventName = renderUtil.makeCustomEventName('select', series.chartType, 'legend');
                legend.on(selectLegendEventName, series.onSelectLegend, series);
            });
        }
    },

    /**
     * Make axes data.
     * @abstract
     * @private
     */
    _makeAxesData: function() {},

    /**
     * Update dimensions.
     * @abstract
     * @private
     */
    _updateDimensions: function() {},

    /**
     * Add data ratios.
     * @private
     * @abstract
     */
    _addDataRatios: function() {},

    /**
     * Execute component function.
     * @param {string} funcName function name
     * @private
     */
    _executeComponentFunc: function(funcName) {
        this.componentManager.each(function(component) {
            if (component[funcName]) {
                component[funcName]();
            }
        });
    },

    /**
     * Render.
     * @param {function} onRender render callback function
     * @private
     */
    _render: function(onRender) {
        var axesData, renderingData;

        this._executeComponentFunc('registerDimension');
        axesData = this._makeAxesData();

        this.boundsMaker.registerAxesData(axesData);
        this._executeComponentFunc('registerAdditionalDimension');
        this.boundsMaker.registerSeriesDimension();

        this._updateDimensions();

        this.boundsMaker.registerBoundsData();
        this._addDataRatios();

        renderingData = this._makeRenderingData();

        onRender(renderingData);

        this._sendSeriesData();
    },

    /**
     * Render chart.
     * @returns {HTMLElement} chart element
     */
    render: function() {
        var el = dom.create('DIV', this.className),
            self = this;

        dom.addClass(el, 'tui-chart');
        this._renderTitle(el);
        renderUtil.renderDimension(el, this.boundsMaker.getDimension('chart'));
        renderUtil.renderBackground(el, this.theme.chart.background);
        renderUtil.renderFontFamily(el, this.theme.chart.fontFamily);

        this._render(function(renderingData) {
            self._renderComponents(renderingData, 'render', el);
        });

        this._attachCustomEvent();
        this.chartContainer = el;

        return el;
    },

    /**
     * Filter raw data.
     * @param {object} rawData raw data
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @returns {object} rawData
     * @private
     */
    _filterRawData: function(rawData, checkedLegends) {
        var cloneData = JSON.parse(JSON.stringify(rawData));

        if (tui.util.isArray(cloneData.series)) {
            cloneData.series = tui.util.filter(cloneData.series, function(series, index) {
                return checkedLegends[index];
            });
        } else {
            tui.util.forEach(cloneData.series, function(serieses, chartType) {
                if (!checkedLegends[chartType]) {
                    cloneData.series[chartType] = [];
                } else if (checkedLegends[chartType].length) {
                    cloneData.series[chartType] = tui.util.filter(serieses, function(series, index) {
                        return checkedLegends[chartType][index];
                    });
                }
            });
        }

        return cloneData;
    },

    /**
     * Make rerendering data.
     * @param {object} renderingData rendering data
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @returns {object} rendering data
     * @private
     */
    _makeRerenderingData: function(renderingData, checkedLegends) {
        var tooltipData = this._makeTooltipData(),
            serieses = this.componentManager.where({componentType: 'series'});

        renderingData.tooltip = tui.util.extend({
            checkedLegends: checkedLegends
        }, tooltipData, renderingData.tooltip);

        tui.util.forEach(serieses, function(series) {
            renderingData[series.componentName] = tui.util.extend({
                checkedLegends: checkedLegends[series.chartType] || checkedLegends
            }, renderingData[series.componentName]);
        });

        return renderingData;
    },

    /**
     * Rerender.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @param {?object} rawData rawData
     * @private
     */
    _rerender: function(checkedLegends, rawData) {
        var self = this;

        rawData = rawData || this._filterRawData(this.dataProcessor.getOriginalRawData(), checkedLegends);
        this.dataProcessor.initData(rawData);
        this.boundsMaker.initBoundsData();
        this._render(function(renderingData) {
            renderingData = self._makeRerenderingData(renderingData, checkedLegends);
            self._renderComponents(renderingData, 'rerender');
        });
    },

    /**
     * On change checked legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @param {?object} rawData rawData
     * @param {?object} boundsParams addition params for calculating bounds
     */
    onChangeCheckedLegends: function(checkedLegends, rawData, boundsParams) {
        this._rerender(checkedLegends, rawData, boundsParams);
    },

    /**
     * Render title.
     * @param {HTMLElement} el target element
     * @private
     */
    _renderTitle: function(el) {
        var chartOptions = this.options.chart || {},
            elTitle = renderUtil.renderTitle(chartOptions.title, this.theme.title, 'tui-chart-title');

        dom.append(el, elTitle);
    },

    /**
     * Render components.
     * @param {object} renderingData data for rendering
     * @param {string} funcName function name for execution
     * @param {HTMLElement} container container element
     * @private
     */
    _renderComponents: function(renderingData, funcName, container) {
        var elements = this.componentManager.map(function(component) {
            var data = renderingData[component.componentName],
                element = null;

            if (component[funcName]) {
                element = component[funcName](data);
            }

            return element;
        });

        if (container) {
            dom.append(container, elements);
        }
    },

    /**
     * Send series data to custom event component.
     * @private
     */
    _sendSeriesData: function() {
        var self = this,
            customEvent = this.componentManager.get('customEvent'),
            seriesInfos, chartTypes;

        if (!customEvent) {
            return;
        }

        chartTypes = this.chartTypes || [this.chartType];
        seriesInfos = tui.util.map(chartTypes, function(chartType) {
            var component = self.componentManager.get(chartType + 'Series') || self.componentManager.get('series');

            return {
                chartType: chartType,
                data: component.getSeriesData()
            };
        });

        customEvent.initCustomEventData(seriesInfos);
    },

    /**
     * Make event name for animation.
     * @param {string} chartType chart type
     * @param {string} prefix prefix
     * @returns {string} event name
     * @private
     */
    _makeAnimationEventName: function(chartType, prefix) {
        return prefix + chartType.substring(0, 1).toUpperCase() + chartType.substring(1) + 'Animation';
    },

    /**
     * Animate chart.
     */
    animateChart: function() {
        this.componentManager.each(function(component) {
            if (component.animateComponent) {
                component.animateComponent();
            }
        });
    },

    /**
     * Register of user event.
     * @param {string} eventName event name
     * @param {function} func event callback
     */
    on: function(eventName, func) {
        this.userEvent.register(eventName, func);
    },

    /**
     * Update dimension of chart.
     * @param {{width: number, height: number}} dimension dimension
     * @returns {boolean} whether updated or not
     * @private
     */
    _updateChartDimension: function(dimension) {
        var updated = false;

        if (dimension.width) {
            this.options.chart.width = dimension.width;
            updated = true;
        }

        if (dimension.height) {
            this.options.chart.height = dimension.height;
            updated = true;
        }

        return updated;
    },

    /**
     * Public API for resizable.
     * @param {object} dimension dimension
     *      @param {number} dimension.width width
     *      @param {number} dimension.height height
     * @api
     */
    resize: function(dimension) {
        var self = this,
            updated;

        if (!dimension) {
            return;
        }

        updated = this._updateChartDimension(dimension);

        if (!updated) {
            return;
        }

        this.boundsMaker.initBoundsData(this.options.chart);
        renderUtil.renderDimension(this.chartContainer, dimension);

        this._render(function(renderingData) {
            self._renderComponents(renderingData, 'resize');
        });
    },

    /**
     * Set tooltip align option.
     * @param {string} align align (left|center|right, top|middle|bottom)
     * @api
     */
    setTooltipAlign: function(align) {
        this.componentManager.get('tooltip').setAlign(align);
    },

    /**
     * Set position option.
     * @param {object} position moving position
     *      @param {number} position.left left
     *      @param {number} position.top top
     * @api
     */
    setTooltipPosition: function(position) {
        this.componentManager.get('tooltip').setPosition(position);
    },

    /**
     * Reset tooltip align option.
     * @api
     */
    resetTooltipAlign: function() {
        this.componentManager.get('tooltip').resetAlign();
    },

    /**
     * Reset tooltip position.
     * @api
     */
    resetTooltipPosition: function() {
        this.componentManager.get('tooltip').resetPosition();
    },

    /**
     * Show series label.
     * @api
     */
    showSeriesLabel: function() {
        var serieses = this.componentManager.where({componentType: 'series'});

        tui.util.forEachArray(serieses, function(series) {
            series.showLabel();
        });
    },

    /**
     * Hide series label.
     * @api
     */
    hideSeriesLabel: function() {
        var serieses = this.componentManager.where({componentType: 'series'});

        tui.util.forEachArray(serieses, function(series) {
            series.hideLabel();
        });
    }
});

module.exports = ChartBase;

},{"../dataModels/dataProcessor":30,"../helpers/axisScaleMaker":41,"../helpers/boundsMaker":42,"../helpers/domHandler":45,"../helpers/renderUtil":49,"../helpers/userEventListener":51,"./componentManager":12}],10:[function(require,module,exports){
/**
 * @fileoverview Column chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    chartConst = require('../const'),
    axisTypeMixer = require('./axisTypeMixer'),
    barTypeMixer = require('./barTypeMixer'),
    predicate = require('../helpers/predicate'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    Series = require('../series/columnChartSeries');

var ColumnChart = tui.util.defineClass(ChartBase, /** @lends ColumnChart.prototype */ {
    /**
     * Column chart.
     * @constructs ColumnChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @mixes verticalTypeMixer
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     * @param {object} initedData initialized data from combo chart
     */
    init: function(rawData, theme, options) {
        /**
         * className
         * @type {string}
         */
        this.className = 'tui-column-chart';

        options.series = options.series || {};
        options.yAxis = options.yAxis || {};

        if (predicate.isValidStackedOption(options.series.stacked)) {
            rawData.series = this._sortRawSeriesData(rawData.series);
        }

        if (options.series.diverging) {
            rawData.series = this._makeRawSeriesDataForDiverging(rawData.series, options.series.stacked);
            options.series.stacked = options.series.stacked || chartConst.STACKED_NORMAL_TYPE;
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Make axes data
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        var options = this.options,
            axisScaleMaker = this._createAxisScaleMaker({
                min: options.yAxis.min,
                max: options.yAxis.max
            }, {
                areaType: 'yAxis'
            }),
            xAxisData = axisDataMaker.makeLabelAxisData({
                labels: this.dataProcessor.getCategories(),
                options: options.xAxis
            }),
            yAxisData = axisDataMaker.makeValueAxisData({
                axisScaleMaker: axisScaleMaker,
                isVertical: this.isVertical
            });

        return {
            xAxis: xAxisData,
            yAxis: yAxisData
        };
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        this._addComponentsForAxisType({
            axes: [
                {
                    name: 'yAxis'
                },
                {
                    name: 'xAxis',
                    isLabel: true
                }
            ],
            chartType: chartType,
            serieses: [
                {
                    name: 'columnSeries',
                    SeriesClass: Series,
                    data: {
                        allowNegativeTooltip: true
                    }
                }
            ]
        });
    }
});

axisTypeMixer.mixin(ColumnChart);
barTypeMixer.mixin(ColumnChart);

module.exports = ColumnChart;

},{"../const":20,"../helpers/axisDataMaker":40,"../helpers/predicate":47,"../series/columnChartSeries":78,"./axisTypeMixer":5,"./barTypeMixer":7,"./chartBase":9}],11:[function(require,module,exports){
/**
 * @fileoverview Combo chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var calculator = require('../helpers/calculator'),
    renderUtil = require('../helpers/renderUtil'),
    ChartBase = require('./chartBase'),
    axisTypeMixer = require('./axisTypeMixer'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    defaultTheme = require('../themes/defaultTheme'),
    ColumnChartSeries = require('../series/columnChartSeries'),
    LineChartSeries = require('../series/lineChartSeries');

var ComboChart = tui.util.defineClass(ChartBase, /** @lends ComboChart.prototype */ {
    /**
     * Combo chart.
     * @constructs ComboChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        var chartTypesMap;

        this.className = 'tui-combo-chart';

        chartTypesMap = this._makeChartTypesMap(rawData.series, options.yAxis);

        tui.util.extend(this, chartTypesMap);

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true,
            seriesChartTypes: chartTypesMap.seriesChartTypes
        });

        /**
         * yAxis options map
         * @type {object}
         */
        this.yAxisOptionsMap = this._makeYAxisOptionsMap(chartTypesMap.chartTypes, options.yAxis);
        this._addComponents(chartTypesMap);
    },

    /**
     * Make yAxis options map.
     * @param {Array.<string>} chartTypes chart types
     * @param {?object} yAxisOptions yAxis options
     * @returns {{column: ?object, line: ?object}} options map
     * @private
     */
    _makeYAxisOptionsMap: function(chartTypes, yAxisOptions) {
        var optionMap = {};
        yAxisOptions = yAxisOptions || {};
        tui.util.forEachArray(chartTypes, function(chartType, index) {
            optionMap[chartType] = yAxisOptions[index] || yAxisOptions;
        });

        return optionMap;
    },

    /**
     * Make chart types map.
     * @param {object} rawSeriesData raw series data
     * @param {object} yAxisOption option for y axis
     * @returns {object} chart types map
     * @private
     */
    _makeChartTypesMap: function(rawSeriesData, yAxisOption) {
        var seriesChartTypes = tui.util.keys(rawSeriesData).sort(),
            optionChartTypes = this._getYAxisOptionChartTypes(seriesChartTypes, yAxisOption),
            chartTypes = optionChartTypes.length ? optionChartTypes : seriesChartTypes,
            validChartTypes = tui.util.filter(optionChartTypes, function(chartType) {
                return rawSeriesData[chartType].length;
            }),
            chartTypesMap;

        if (validChartTypes.length === 1) {
            chartTypesMap = {
                chartTypes: validChartTypes,
                seriesChartTypes: validChartTypes,
                optionChartTypes: !optionChartTypes.length ? optionChartTypes : validChartTypes
            };
        } else {
            chartTypesMap = {
                chartTypes: chartTypes,
                seriesChartTypes: seriesChartTypes,
                optionChartTypes: optionChartTypes
            };
        }

        return chartTypesMap;
    },

    /**
     * Make options map
     * @param {object} chartTypes chart types
     * @returns {object} options map
     * @private
     */
    _makeOptionsMap: function(chartTypes) {
        var self = this,
            optionsMap = {};

        tui.util.forEachArray(chartTypes, function(chartType) {
            optionsMap[chartType] = self.options.series[chartType] || self.options.series;
        });

        return optionsMap;
    },

    /**
     * Make theme map
     * @param {object} chartTypes chart types
     * @returns {object} theme map
     * @private
     */
    _makeThemeMap: function(chartTypes) {
        var self = this,
            theme = this.theme,
            themeMap = {},
            colorCount = 0;

        tui.util.forEachArray(chartTypes, function(chartType) {
            var chartTheme = JSON.parse(JSON.stringify(theme)),
                removedColors;

            if (chartTheme.series[chartType]) {
                themeMap[chartType] = chartTheme.series[chartType];
            } else if (!chartTheme.series.colors) {
                themeMap[chartType] = JSON.parse(JSON.stringify(defaultTheme.series));
                themeMap[chartType].label.fontFamily = chartTheme.chart.fontFamily;
            } else {
                removedColors = chartTheme.series.colors.splice(0, colorCount);
                chartTheme.series.colors = chartTheme.series.colors.concat(removedColors);
                themeMap[chartType] = chartTheme.series;
                colorCount += self.dataProcessor.getLegendLabels(chartType).length;
            }
        });

        return themeMap;
    },

    /**
     * Make serieses
     * @param {Array.<string>} chartTypes chart types
     * @returns {Array.<object>} serieses
     * @private
     */
    _makeSerieses: function(chartTypes) {
        var seriesClasses = {
                column: ColumnChartSeries,
                line: LineChartSeries
            },
            optionsMap = this._makeOptionsMap(chartTypes),
            themeMap = this._makeThemeMap(chartTypes),
            serieses;

        serieses = tui.util.map(chartTypes, function(chartType) {
            var data = {
                allowNegativeTooltip: true,
                componentType: 'series',
                chartType: chartType,
                options: optionsMap[chartType],
                theme: themeMap[chartType]
            };

            return {
                name: chartType + 'Series',
                SeriesClass: seriesClasses[chartType],
                data: data
            };
        });

        return serieses;
    },

    /**
     * Add components
     * @param {object} chartTypesMap chart types map
     * @private
     */
    _addComponents: function(chartTypesMap) {
        var axes = [{
                name: 'yAxis',
                isLabel: true,
                chartType: chartTypesMap.chartTypes[0]
            },
            {
                name: 'xAxis'
            }],
            serieses = this._makeSerieses(chartTypesMap.seriesChartTypes);

        if (chartTypesMap.optionChartTypes.length) {
            axes.push({
                name: 'rightYAxis',
                isLabel: true,
                chartType: chartTypesMap.chartTypes[1]
            });
        }

        this._addComponentsForAxisType({
            axes: axes,
            seriesChartTypes: chartTypesMap.seriesChartTypes,
            chartType: this.options.chartType,
            serieses: serieses
        });
    },

    /**
     * Get y axis option chart types.
     * @param {Array.<string>} chartTypes chart types
     * @param {object} yAxisOptions y axis options
     * @returns {Array.<string>} chart types
     * @private
     */
    _getYAxisOptionChartTypes: function(chartTypes, yAxisOptions) {
        var resultChartTypes = chartTypes.slice(),
            isReverse = false,
            optionChartTypes;

        yAxisOptions = yAxisOptions ? [].concat(yAxisOptions) : [];

        if (yAxisOptions.length === 1 && !yAxisOptions[0].chartType) {
            resultChartTypes = [];
        } else if (yAxisOptions.length) {
            optionChartTypes = tui.util.map(yAxisOptions, function(option) {
                return option.chartType;
            });

            tui.util.forEachArray(optionChartTypes, function(chartType, index) {
                isReverse = isReverse || (chartType && resultChartTypes[index] !== chartType || false);
            });

            if (isReverse) {
                resultChartTypes.reverse();
            }
        }

        return resultChartTypes;
    },

    /**
     * Make y axis data.
     * @param {object} params parameters
     *      @param {number} params.index chart index
     *      @param {{width: number, height: number}} params.seriesDimension series dimension
     *      @param {Array.<string>} chartTypes chart type
     *      @param {boolean} isSingleYAxis whether single yAxis or not
     *      @param {object} options chart options
     *      @param {object} addParams add params
     * @returns {object} y axis data
     * @private
     */
    _makeYAxisData: function(params) {
        var index = params.index,
            chartType = params.chartTypes[index],
            yAxisOptions = this.yAxisOptionsMap[chartType],
            axisScaleMaker, yAxisData;

        if (!chartType) {
            return {};
        }

        axisScaleMaker = this._createAxisScaleMaker({
            min: yAxisOptions.min,
            max: yAxisOptions.max
        }, {
            isSingleYAxis: params.isSingleYAxis,
            areaType: 'yAxis'
        }, chartType);

        yAxisData = axisDataMaker.makeValueAxisData({
            axisScaleMaker: axisScaleMaker,
            isVertical: true,
            isSingleYAxis: params.isSingleYAxis
        });

        yAxisData.options = yAxisOptions;

        return yAxisData;
    },

    /**
     * Update tick count to make the same tick count of yAxes.
     * @param {object} yAxisData yAxis data
     * @param {object} rightYAxisData right yAxis data
     * @private
     */
    _updateYAxisTickCount: function(yAxisData, rightYAxisData) {
        var tickCountDiff = rightYAxisData.tickCount - yAxisData.tickCount;

        if (tickCountDiff > 0) {
            this._increaseYAxisTickCount(tickCountDiff, yAxisData);
        } else if (tickCountDiff < 0) {
            this._increaseYAxisTickCount(-tickCountDiff, rightYAxisData);
        }
    },

    /**
     * Make axes data
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        var yAxisParams = {
                chartTypes: this.chartTypes,
                isSingleYAxis: !this.optionChartTypes.length
            },
            xAxisData = axisDataMaker.makeLabelAxisData({
                labels: this.dataProcessor.getCategories()
            }),
            yAxisData = this._makeYAxisData(tui.util.extend({
                index: 0
            }, yAxisParams)),
            axesData = {
                yAxis: yAxisData,
                xAxis: xAxisData
            },
            rightYAxisData;

        if (!yAxisParams.isSingleYAxis) {
            rightYAxisData = this._makeYAxisData(tui.util.extend({
                index: 1
            }, yAxisParams));
            rightYAxisData.aligned = xAxisData.aligned;
            rightYAxisData.isPositionRight = true;

            this._updateYAxisTickCount(yAxisData, rightYAxisData);

            axesData.rightYAxis = rightYAxisData;
        }

        return axesData;
    },

    /**
     * Increase yAxis tick count.
     * @param {number} increaseTickCount increase tick count
     * @param {object} yAxisData yAxis data
     * @private
     */
    _increaseYAxisTickCount: function(increaseTickCount, yAxisData) {
        var formatFunctions = this.dataProcessor.getFormatFunctions(),
            labels;

        yAxisData.limit.max += yAxisData.step * increaseTickCount;
        labels = calculator.makeLabelsFromLimit(yAxisData.limit, yAxisData.step);
        yAxisData.labels = renderUtil.formatValues(labels, formatFunctions, 'yAxis');
        yAxisData.tickCount += increaseTickCount;
        yAxisData.validTickCount += increaseTickCount;
    },

    /**
     * On change selected legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     */
    onChangeCheckedLegends: function(checkedLegends) {
        var rawData = this._filterRawData(this.rawData, checkedLegends),
            chartTypesMap = this._makeChartTypesMap(rawData.series, this.options.yAxis);

        tui.util.extend(this, chartTypesMap);

        ChartBase.prototype.onChangeCheckedLegends.call(this, checkedLegends, rawData, chartTypesMap);
    }
});

axisTypeMixer.mixin(ComboChart);

module.exports = ComboChart;

},{"../helpers/axisDataMaker":40,"../helpers/calculator":43,"../helpers/renderUtil":49,"../series/columnChartSeries":78,"../series/lineChartSeries":79,"../themes/defaultTheme":86,"./axisTypeMixer":5,"./chartBase":9}],12:[function(require,module,exports){
/**
 * @fileoverview ComponentManager manages components of chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ComponentManager = tui.util.defineClass(/** @lends ComponentManager.prototype */ {
    /**
     * ComponentManager manages components of chart.
     * @param {object} params parameters
     *      @param {object} params.theme theme
     *      @param {object} params.options options
     *      @param {DataProcessor} params.dataProcessor data processor
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     * @constructs ComponentManager
     */
    init: function(params) {
        /**
         * Components
         * @type {Array.<object>}
         */
        this.components = [];

        /**
         * Component map.
         * @type {object}
         */
        this.componentMap = {};

        /**
         * theme
         * @type {object}
         */
        this.theme = params.theme || {};

        /**
         * options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = params.hasAxes;
    },

    /**
     * Make component options.
     * @param {object} options options
     * @param {string} componentType component type
     * @param {number} index component index
     * @returns {object} options
     * @private
     */
    _makeComponentOptions: function(options, componentType, index) {
        options = options || this.options[componentType];
        options = tui.util.isArray(options) ? options[index] : options || {};

        return options;
    },

    /**
     * Register component.
     * The component refers to a component of the chart.
     * The component types are axis, legend, plot, series and customEvent.
     * Chart Component Description : https://i-msdn.sec.s-msft.com/dynimg/IC267997.gif
     * @param {string} name component name
     * @param {function} Component component constructor
     * @param {object} params component parameters
     */
    register: function(name, Component, params) {
        var index,
            component, componentType;

        params = params || {};

        componentType = params.componentType || name;
        index = params.index || 0;

        params.theme = params.theme || this.theme[componentType];
        params.options = this._makeComponentOptions(params.options, componentType, index);

        params.dataProcessor = this.dataProcessor;
        params.boundsMaker = this.boundsMaker;
        params.hasAxes = this.hasAxes;

        component = new Component(params);
        component.componentName = name;
        component.componentType = componentType;

        this.components.push(component);
        this.componentMap[name] = component;
    },

    /**
     * Iterate each components.
     * @param {function} iteratee iteratee
     */
    each: function(iteratee) {
        tui.util.forEachArray(this.components, iteratee);
    },

    /**
     * Return the results of applying the iteratee to each components.
     *  @param {function} iteratee iteratee
     * @returns {Array.<object>} components
     */
    map: function(iteratee) {
        return tui.util.map(this.components, iteratee);
    },

    /**
     * Find components to conditionMap.
     * @param {object} conditionMap condition map
     * @returns {Array.<object>} filtered components
     */
    where: function(conditionMap) {
        return tui.util.filter(this.components, function(component) {
            var contained = true;

            tui.util.forEach(conditionMap, function(value, key) {
                if (component[key] !== value) {
                    contained = false;
                }

                return contained;
            });

            return contained;
        });
    },

    /**
     * Get component.
     * @param {string} name component name
     * @returns {object} component instance
     */
    get: function(name) {
        return this.componentMap[name];
    }
});

module.exports = ComponentManager;

},{}],13:[function(require,module,exports){
/**
 * @fileoverview Line chart
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    lineTypeMixer = require('./lineTypeMixer'),
    axisTypeMixer = require('./axisTypeMixer'),
    Series = require('../series/lineChartSeries');

var LineChart = tui.util.defineClass(ChartBase, /** @lends LineChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-line-chart',

    /**
     * Series class
     * @type {function}
     */
    Series: Series,

    /**
     * Line chart.
     * @constructs LineChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @mixes lineTypeMixer
     */
    init: function() {
        this._lineTypeInit.apply(this, arguments);
    }
});

axisTypeMixer.mixin(LineChart);
lineTypeMixer.mixin(LineChart);

module.exports = LineChart;

},{"../series/lineChartSeries":79,"./axisTypeMixer":5,"./chartBase":9,"./lineTypeMixer":14}],14:[function(require,module,exports){
/**
 * @fileoverview lineTypeMixer is mixer of line type chart(line, area).
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    predicate = require('../helpers/predicate'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    AreaTypeCustomEvent = require('../customEvents/areaTypeCustomEvent');

/**
 * lineTypeMixer is mixer of line type chart(line, area).
 * @mixin
 */
var lineTypeMixer = {
    /**
     * Initialize line type chart.
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     * @private
     */
    _lineTypeInit: function(rawData, theme, options) {
        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Make axes data
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        var options = this.options,
            axisScaleMaker = this._createAxisScaleMaker({
                min: options.yAxis.min,
                max: options.yAxis.max
            }, {
                areaType: 'yAxis'
            }),
            aligned = predicate.isLineTypeChart(options.chartType),
            xAxisData = axisDataMaker.makeLabelAxisData({
                labels: this.dataProcessor.getCategories(),
                aligned: aligned,
                options: options.xAxis
            }),
            yAxisData = axisDataMaker.makeValueAxisData({
                axisScaleMaker: axisScaleMaker,
                isVertical: this.isVertical,
                aligned: aligned
            });

        return {
            xAxis: xAxisData,
            yAxis: yAxisData
        };
    },

    /**
     * Add custom event component for normal tooltip.
     * @private
     */
    _addCustomEventComponentForNormalTooltip: function() {
        this.componentManager.register('customEvent', AreaTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical
        });
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        this._addComponentsForAxisType({
            axes: [
                {
                    name: 'yAxis'
                },
                {
                    name: 'xAxis',
                    isLabel: true
                }
            ],
            chartType: chartType,
            serieses: [
                {
                    name: this.options.chartType + 'Series',
                    SeriesClass: this.Series
                }
            ]
        });
    },

    /**
     * Render
     * @returns {HTMLElement} chart element
     */
    render: function() {
        return ChartBase.prototype.render.apply(this, arguments);
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = lineTypeMixer;

},{"../customEvents/areaTypeCustomEvent":21,"../helpers/axisDataMaker":40,"../helpers/predicate":47,"./chartBase":9}],15:[function(require,module,exports){
/**
 * @fileoverview Map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    chartConst = require('../const'),
    MapChartMapModel = require('./mapChartMapModel'),
    MapChartColorModel = require('./mapChartColorModel'),
    MapChartDataProcessor = require('../dataModels/mapChartDataProcessor'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    Series = require('../series/mapChartSeries'),
    Zoom = require('../series/zoom'),
    Legend = require('../legends/mapChartLegend'),
    MapChartTooltip = require('../tooltips/mapChartTooltip'),
    mapChartCustomEvent = require('../customEvents/mapChartCustomEvent');

var MapChart = tui.util.defineClass(ChartBase, /** @lends MapChart.prototype */ {
    /**
     * Map chart.
     * @constructs MapChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        /**
         * class name
         * @type {string}
         */
        this.className = 'tui-map-chart';

        options.tooltip = options.tooltip || {};
        options.legend = options.legend || {};

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            DataProcessor: MapChartDataProcessor
        });

        this._addComponents(options);
    },

    /**
     * Add components
     * @param {object} options chart options
     * @private
     */
    _addComponents: function(options) {
        options.legend = options.legend || {};

        this.componentManager.register('legend', Legend);

        this.componentManager.register('tooltip', MapChartTooltip, this._makeTooltipData());

        this.componentManager.register('mapSeries', Series, {
            libType: options.libType,
            chartType: options.chartType,
            componentType: 'series',
            userEvent: this.userEvent
        });
        this.componentManager.register('zoom', Zoom);
    },

    /**
     * Add custom event component.
     * @private
     */
    _addCustomEventComponent: function() {
        this.componentManager.register('customEvent', mapChartCustomEvent, {
            chartType: this.chartType
        });
    },

    /**
     * Make axes data
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        var axisScaleMaker = this._createAxisScaleMaker({}, {
            valueCount: chartConst.MAP_CHART_LEGEND_TICK_COUNT
        });

        return axisDataMaker.makeValueAxisData({
            axisScaleMaker: axisScaleMaker,
            isVertical: true
        });
    },

    /**
     * Add data ratios.
     * @private
     * @override
     */
    _addDataRatios: function() {
        var axesData = this.boundsMaker.getAxesData();

        this.dataProcessor.addDataRatios(axesData.limit);
    },

    /**
     * Make rendering data for map chart.
     * @returns {object} data for rendering
     * @private
     * @override
     */
    _makeRenderingData: function() {
        var axesData = this.boundsMaker.getAxesData();
        var seriesTheme = this.theme.series;
        var colorModel = new MapChartColorModel(seriesTheme.startColor, seriesTheme.endColor);
        var mapModel = new MapChartMapModel(this.dataProcessor, this.options.map);

        return {
            legend: {
                colorModel: colorModel,
                axesData: axesData
            },
            mapSeries: {
                mapModel: mapModel,
                colorModel: colorModel
            },
            tooltip: {
                mapModel: mapModel
            }
        };
    },

    /**
     * Attach custom evnet.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var customEvent = this.componentManager.get('customEvent'),
            mapSeries = this.componentManager.get('mapSeries'),
            legend = this.componentManager.get('legend'),
            tooltip = this.componentManager.get('tooltip'),
            zoom = this.componentManager.get('zoom');

        customEvent.on({
            clickMapSeries: mapSeries.onClickSeries,
            moveMapSeries: mapSeries.onMoveSeries,
            dragStartMapSeries: mapSeries.onDragStartSeries,
            dragMapSeries: mapSeries.onDragSeries,
            dragEndMapSeries: mapSeries.onDragEndSeries,
            wheel: tui.util.bind(zoom.onWheel, zoom)
        }, mapSeries);

        mapSeries.on({
            showWedge: legend.onShowWedge,
            hideWedge: legend.onHideWedge
        }, legend);

        mapSeries.on({
            showTooltip: tooltip.onShow,
            hideTooltip: tooltip.onHide,
            showTooltipContainer: tooltip.onShowTooltipContainer,
            hideTooltipContainer: tooltip.onHideTooltipContainer
        }, tooltip);

        zoom.on('zoom', mapSeries.onZoom, mapSeries, mapSeries);
    }
});

module.exports = MapChart;

},{"../const":20,"../customEvents/mapChartCustomEvent":27,"../dataModels/mapChartDataProcessor":31,"../helpers/axisDataMaker":40,"../legends/mapChartLegend":57,"../series/mapChartSeries":81,"../series/zoom":85,"../tooltips/mapChartTooltip":89,"./chartBase":9,"./mapChartColorModel":16,"./mapChartMapModel":17}],16:[function(require,module,exports){
/**
 * @fileoverview MapChartColorModel is color model for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var colorutil = require('../helpers/colorutil');

var MapChartColorModel = tui.util.defineClass(/** @lends MapChartColorModel.prototype */ {
    /**
     * MapChartColorModel is legend model.
     * @constructs MapChartColorModel
     * @param {string} startColor hex color
     * @param {string} endColor hex color
     */
    init: function(startColor, endColor) {
        var endRGB;

        this.start = colorutil.colorNameToHex(startColor);
        this.startRGB = colorutil.hexToRGB(this.start);
        this.end = colorutil.colorNameToHex(endColor);

        endRGB = colorutil.hexToRGB(this.end);
        this.distances = this._makeDistances(this.startRGB, endRGB);
        this.colorMap = {};
    },

    /**
     * Make distances start RGB to end RGB.
     * @param {Array.<number>} startRGB start RGB
     * @param {Array.<number>} endRGB end RGB
     * @returns {Array.<number>} distances
     * @private
     */
    _makeDistances: function(startRGB, endRGB) {
        return tui.util.map(startRGB, function(value, index) {
            return endRGB[index] - value;
        });
    },

    /**
     * Get hex color.
     * @param {number} ratio ratio
     * @returns {string} hex color
     */
    getColor: function(ratio) {
        var hexColor = this.colorMap[ratio],
            distances, rgbColor;

        if (!hexColor) {
            distances = this.distances;
            rgbColor = tui.util.map(this.startRGB, function(start, index) {
                return start + parseInt(distances[index] * ratio, 10);
            });
            hexColor = colorutil.rgbToHEX.apply(null, rgbColor);
        }

        return hexColor;
    }
});

module.exports = MapChartColorModel;

},{"../helpers/colorutil":44}],17:[function(require,module,exports){
/**
 * @fileoverview MapChartMapModel is map model of map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

var MapChartMapModel = tui.util.defineClass(/** @lends MapChartMapModel.prototype */ {
    /**
     * MapChartMapModel is map model of map chart.
     * @constructs MapChartMapModel
     * @param {MapChartDataProcessor} dataProcessor Map chart data processor
     * @param {Array.<{name: string, path: string, labelCoordinate: ?{x: number, y:number}}>} rawMapData raw map data
     */
    init: function(dataProcessor, rawMapData) {
        /**
         * Command function map.
         * @type {{
         *      M: MapChartMapModel._makeCoordinate, m: MapChartMapModel._makeCoordinateFromRelativeCoordinate,
         *      L: MapChartMapModel._makeCoordinate, l: MapChartMapModel._makeCoordinateFromRelativeCoordinate,
         *      H: MapChartMapModel._makeXCoordinate, h: MapChartMapModel._makeXCoordinateFroRelativeCoordinate,
         *      V: MapChartMapModel._makeYCoordinate, v: MapChartMapModel._makeYCoordinateFromRelativeCoordinate
         * }}
         */
        this.commandFuncMap = {
            M: tui.util.bind(this._makeCoordinate, this),
            m: tui.util.bind(this._makeCoordinateFromRelativeCoordinate, this),
            L: tui.util.bind(this._makeCoordinate, this),
            l: tui.util.bind(this._makeCoordinateFromRelativeCoordinate, this),
            H: tui.util.bind(this._makeXCoordinate, this),
            h: tui.util.bind(this._makeXCoordinateFroRelativeCoordinate, this),
            V: tui.util.bind(this._makeYCoordinate, this),
            v: tui.util.bind(this._makeYCoordinateFromRelativeCoordinate, this)
        };

        /**
         * Ignore command map.
         * @type {{Z: boolean, z: boolean}}
         */
        this.ignoreCommandMap = {
            Z: true,
            z: true
        };

        /**
         * Map data.
         * @type {Array}
         */
        this.mapData = [];

        /**
         * Map dimension
         * @type {{width: number, height: number}}
         */
        this.mapDimension = null;

        /**
         * Map chart data processor.
         * @type {MapChartDataProcessor}
         */
        this.dataProcessor = dataProcessor;

        this._createMapData(rawMapData);
    },

    /**
     * Split coordinate string.
     * @param {string} coordinateStr coordinate string
     * @returns {{x: number, y: number}} coordinate map
     * @private
     */
    _splitCoordinate: function(coordinateStr) {
        var coordinates = coordinateStr.split(','),
            result = {
                x: parseFloat(coordinates[0])
            };

        if (coordinates[1]) {
            result.y = parseFloat(coordinates[1]);
        }

        return result;
    },

    /**
     * Make coordinate
     * @param {string} coordinateStr coordinate
     * @returns {{x: number, y: number}} coordinate
     * @private
     */
    _makeCoordinate: function(coordinateStr) {
        return this._splitCoordinate(coordinateStr);
    },

    /**
     * Make coordinate from relative coordinate.
     * @param {string} coordinateStr coordinate
     * @param {{x: number, y: number}} prevCoordinate previous coordinate
     * @returns {{x: number, y: number}} coordinate
     * @private
     */
    _makeCoordinateFromRelativeCoordinate: function(coordinateStr, prevCoordinate) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            x: coordinate.x + prevCoordinate.x,
            y: coordinate.y + prevCoordinate.y
        };
    },

    /**
     * Make x coordinate.
     * @param {string} coordinateStr coordinate
     * @returns {{x: number}} x coordinate
     * @private
     */
    _makeXCoordinate: function(coordinateStr) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            x: coordinate.x
        };
    },

    /**
     * Make x coordinate from relative coordinate.
     * @param {string} coordinateStr coordinate
     * @param {{x: number, y: number}} prevCoordinate previous coordinate
     * @returns {{x: number}} x coordinate
     * @private
     */
    _makeXCoordinateFroRelativeCoordinate: function(coordinateStr, prevCoordinate) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            x: coordinate.x + prevCoordinate.x
        };
    },

    /**
     * Make y coordinate.
     * @param {string} coordinateStr coordinate
     * @returns {{y: number}} y coordinate
     * @private
     */
    _makeYCoordinate: function(coordinateStr) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            y: coordinate.x
        };
    },

    /**
     * Make y coordinate from relative coordinate.
     * @param {string} coordinateStr coordinate
     * @param {{x: number, y: number}} prevCoordinate previous coordinate
     * @returns {{y: number}} y coordinate
     * @private
     */
    _makeYCoordinateFromRelativeCoordinate: function(coordinateStr, prevCoordinate) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            y: coordinate.x + prevCoordinate.y
        };
    },

    /**
     * Split path.
     * @param {string} path path
     * @returns {Array.<{type: string, coordinate: string}>} splitted path data
     * @private
     */
    _splitPath: function(path) {
        var i = 0,
            len = path.length,
            pathData = [],
            coordinate = '',
            chr, commandType;

        for (; i < len; i += 1) {
            chr = path.charAt(i);
            if (this.commandFuncMap[chr]) {
                if (commandType && coordinate) {
                    pathData.push({
                        type: commandType,
                        coordinate: coordinate
                    });
                }
                commandType = chr;
                coordinate = '';
            } else if (!this.ignoreCommandMap[chr]) {
                coordinate += chr;
            }
        }

        if (commandType && coordinate) {
            pathData.push({
                type: commandType,
                coordinate: coordinate
            });
        }

        return pathData;
    },

    /**
     * Make coordinates from path.
     * @param {string} path path
     * @returns {Array.<{x: number, y: number}>} coordinates
     * @private
     */
    _makeCoordinatesFromPath: function(path) {
        var self = this,
            pathData = this._splitPath(path),
            prevCoordinate = {
                x: 0,
                y: 0
            };

        return tui.util.map(pathData, function(datum) {
            var commandFunc = self.commandFuncMap[datum.type],
                coordinate = commandFunc(datum.coordinate, prevCoordinate);

            tui.util.extend(prevCoordinate, coordinate);

            return coordinate;
        });
    },

    /**
     * Find bound from coordinates.
     * @param {Array.<{left: number, top: number}>} coordinates coordinates
     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} bound
     * @private
     */
    _findBoundFromCoordinates: function(coordinates) {
        var xs = tui.util.filter(tui.util.pluck(coordinates, 'x'), function(x) {
                return !tui.util.isUndefined(x);
            }),
            ys = tui.util.filter(tui.util.pluck(coordinates, 'y'), function(y) {
                return !tui.util.isUndefined(y);
            }),
            maxLeft = tui.util.max(xs),
            minLeft = tui.util.min(xs),
            maxTop = tui.util.max(ys),
            minTop = tui.util.min(ys);

        return {
            dimension: {
                width: maxLeft - minLeft,
                height: maxTop - minTop
            },
            position: {
                left: minLeft,
                top: minTop
            }
        };
    },

    /**
     * Make label position.
     * @param {{dimension: {width: number, height: number}, position: {top: number, left: number}}} bound bound
     * @param {?{left: number, top: number}} positionRatio position ratio
     * @returns {{left: number, top: number}} label position
     * @private
     */
    _makeLabelPosition: function(bound, positionRatio) {
        positionRatio = positionRatio || chartConst.MAP_CHART_LABEL_DEFAULT_POSITION_RATIO;

        return {
            left: bound.position.left + (bound.dimension.width * positionRatio.x),
            top: bound.position.top + (bound.dimension.height * positionRatio.y)
        };
    },

    /**
     * Create map data.
     * @param {Array.<{name: string, path: string, labelCoordinate: ?{x: number, y:number}}>} rawMapData raw map data
     * @private
     */
    _createMapData: function(rawMapData) {
        var self = this;

        this.mapData = tui.util.map(rawMapData, function(datum) {
            var coordinate = self._makeCoordinatesFromPath(datum.path),
                bound = self._findBoundFromCoordinates(coordinate),
                userData = self.dataProcessor.getValueMapDatum(datum.code),
                name, labelCoordinate, label, ratio, resultData;

            if (userData) {
                label = userData.label;
                ratio = userData.ratio;
                name = userData.name || datum.name;
                labelCoordinate = userData.labelCoordinate || datum.labelCoordinate;
            }

            resultData = {
                code: datum.code,
                name: name,
                path: datum.path,
                bound: bound,
                labelPosition: self._makeLabelPosition(bound, labelCoordinate)
            };

            if (label) {
                resultData.label = label;
            }

            if (ratio) {
                resultData.ratio = ratio;
            }

            return resultData;
        });
    },

    getMapData: function() {
        return this.mapData;
    },

    getDatum: function(index) {
        return this.mapData[index];
    },

    /**
     * Get label data.
     * @param {number} ratio ratio
     * @returns {Array.<{name: string, bound: {dimension: {width: number, height: number},
     *          position: {top: number, left: number}}, labelPosition: {width: number, height: number}}>} map data
     */
    getLabelData: function(ratio) {
        var self = this,
            labelData = tui.util.filter(this.mapData, function(datum) {
                return self.dataProcessor.getValueMapDatum(datum.code);
            });

        return tui.util.map(labelData, function(datum) {
            return {
                name: datum.name,
                labelPosition: {
                    left: datum.labelPosition.left * ratio,
                    top: datum.labelPosition.top * ratio
                }
            };
        });
    },

    /**
     * Make map dimension
     * @returns {{width: number, height: number}} map dimension
     * @private
     */
    _makeMapDimension: function() {
        var mapData = this.mapData,
            lefts = tui.util.map(mapData, function(datum) {
                return datum.bound.position.left;
            }),
            rights = tui.util.map(mapData, function(datum) {
                return datum.bound.position.left + datum.bound.dimension.width;
            }),
            tops = tui.util.map(mapData, function(datum) {
                return datum.bound.position.top;
            }),
            bottoms = tui.util.map(mapData, function(datum) {
                return datum.bound.position.top + datum.bound.dimension.height;
            });
        return {
            width: tui.util.max(rights) - tui.util.min(lefts),
            height: tui.util.max(bottoms) - tui.util.min(tops)
        };
    },

    /**
     * Get map dimension.
     * @returns {{width: number, height: number}} map dimension
     */
    getMapDimension: function() {
        if (!this.mapDimension) {
            this.mapDimension = this._makeMapDimension();
        }

        return this.mapDimension;
    }
});

module.exports = MapChartMapModel;

},{"../const":20}],18:[function(require,module,exports){
/**
 * @fileoverview Pie chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    Legend = require('../legends/legend'),
    Tooltip = require('../tooltips/tooltip'),
    Series = require('../series/pieChartSeries'),
    SimpleCustomEvent = require('../customEvents/simpleCustomEvent');

var PieChart = tui.util.defineClass(ChartBase, /** @lends PieChart.prototype */ {
    /**
     * Pie chart.
     * @constructs PieChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        this.className = 'tui-pie-chart';

        options.tooltip = options.tooltip || {};

        if (!options.tooltip.align) {
            options.tooltip.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options
        });

        this._addComponents(theme.chart.background, options);
    },

    /**
     * Add components
     * @param {object} chartBackground chart background
     * @param {object} options chart options
     * @private
     */
    _addComponents: function(chartBackground, options) {
        var legendAlign, isPieLegendType;

        options.legend = options.legend || {};
        legendAlign = options.legend && options.legend.align;
        isPieLegendType = predicate.isPieLegendAlign(legendAlign);

        if (!isPieLegendType && !options.legend.hidden) {
            this.componentManager.register('legend', Legend, {
                chartType: options.chartType,
                userEvent: this.userEvent
            });
        }

        this.componentManager.register('tooltip', Tooltip, this._makeTooltipData());

        this.componentManager.register('pieSeries', Series, {
            libType: options.libType,
            chartType: options.chartType,
            componentType: 'series',
            chartBackground: chartBackground,
            userEvent: this.userEvent,
            legendAlign: isPieLegendType && !options.legend.hidden ? legendAlign : null
        });
    },

    /**
     * Add custom event component.
     * @private
     */
    _addCustomEventComponent: function() {
        this.componentManager.register('customEvent', SimpleCustomEvent, {
            chartType: this.chartType
        });
    },

    /**
     * Add data ratios.
     * @private
     * @override
     */
    _addDataRatios: function() {
        this.dataProcessor.addDataRatiosOfPieChart();
    },

    /**
     * Attach custom evnet.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var customEvent, tooltip, pieSeries;

        ChartBase.prototype._attachCustomEvent.call(this);

        customEvent = this.componentManager.get('customEvent');
        tooltip = this.componentManager.get('tooltip');
        pieSeries = this.componentManager.get('pieSeries');

        customEvent.on({
            clickPieSeries: pieSeries.onClickSeries,
            movePieSeries: pieSeries.onMoveSeries
        }, pieSeries);

        pieSeries.on({
            showTooltip: tooltip.onShow,
            hideTooltip: tooltip.onHide,
            showTooltipContainer: tooltip.onShowTooltipContainer,
            hideTooltipContainer: tooltip.onHideTooltipContainer
        }, tooltip);
    }
});

module.exports = PieChart;

},{"../const":20,"../customEvents/simpleCustomEvent":28,"../helpers/predicate":47,"../legends/legend":53,"../series/pieChartSeries":82,"../tooltips/tooltip":91,"./chartBase":9}],19:[function(require,module,exports){
'use strict';

/**
 * Pick minimum value from value array.
 * @param {Array} arr value array
 * @param {?function} condition condition function
 * @param {?object} context target context
 * @returns {*} minimum value
 */
var min = function(arr, condition, context) {
    var result, minValue, rest;

    if (!condition) {
        result =  Math.min.apply(null, arr);
    } else {
        result = arr[0];
        minValue = condition.call(context, result, 0);
        rest = arr.slice(1);
        tui.util.forEachArray(rest, function(item, index) {
            var compareValue = condition.call(context, item, index + 1);
            if (compareValue < minValue) {
                minValue = compareValue;
                result = item;
            }
        });
    }

    return result;
};

/**
 * Pick maximum value from value array.
 * @param {Array} arr value array
 * @param {?function} condition condition function
 * @param {?object} context target context
 * @returns {*} maximum value
 */
var max = function(arr, condition, context) {
    var result, maxValue, rest;

    if (!condition) {
        result = Math.max.apply(null, arr);
    } else {
        result = arr[0];
        maxValue = condition.call(context, result, 0);
        rest = arr.slice(1);
        tui.util.forEachArray(rest, function(item, index) {
            var compareValue = condition.call(context, item, index + 1);
            if (compareValue > maxValue) {
                maxValue = compareValue;
                result = item;
            }
        });
    }

    return result;
};

/**
 * Whether one of them is true or not.
 * @param {Array} arr target array
 * @param {function} condition condition function
 * @param {?object} context target context
 * @returns {boolean} result boolean
 */
var any = function(arr, condition, context) {
    var result = false;
    tui.util.forEachArray(arr, function(item, index) {
        if (condition.call(context, item, index, arr)) {
            result = true;
            return false;
        }
    });
    return result;
};

/**
 * All of them is true or not.
 * @param {Array} arr target array
 * @param {function} condition condition function
 * @param {[object]} context target context
 * @returns {boolean} result boolean
 */
var all = function(arr, condition, context) {
    var result = true;
    tui.util.forEachArray(arr, function(item, index) {
        if (!condition.call(context, item, index, arr)) {
            result = false;
            return false;
        }
    });
    return result;
};

/**
 * Make unique values.
 * @param {Array} arr target array
 * @param {?boolean} sorted whether sorted or not.
 * @param {?function} iteratee iteratee function
 * @param {?object} context target context
 * @returns {Array} unique values
 */
var unique = function(arr, sorted, iteratee, context) {
    var result = [],
        prevValue;

    if (!tui.util.isBoolean(sorted)) {
        context = iteratee;
        iteratee = sorted;
        sorted = false;
    }

    iteratee = iteratee || function(value) {
        return value;
    };

    if (sorted) {
        tui.util.forEachArray(arr, function (value, index) {
            value = iteratee.call(context, value, index, arr);
            if (!index || prevValue !== value) {
                result.push(value);
            }
            prevValue = value;
        });
    } else {
        tui.util.forEachArray(arr, function(value, index) {
            value = iteratee.call(context, value, index, arr);
            if (tui.util.inArray(value, result) === -1) {
                result.push(value);
            }
        });
    }

    return result;
};

/**
 * Array pivot.
 * @memberOf module:calculator
 * @param {Array.<Array>} arr2d target 2d array
 * @returns {Array.<Array>} pivoted 2d array
 */
var pivot = function(arr2d) {
    var result = [];
    var len = tui.util.max(tui.util.map(arr2d, function(arr) {
        return arr.length;
    }));
    var index;

    tui.util.forEachArray(arr2d, function(arr) {
        for(index = 0; index < len; index += 1) {
            if (!result[index]) {
                result[index] = [];
            }
            result[index].push(arr[index]);
        }
    });
    return result;
};

/**
 * Get length after decimal point.
 * @param {string | number} value target value
 * @returns {number} result length
 */
var getDecimalLength = function(value) {
    var valueArr = String(value).split('.');
    return valueArr.length === 2 ? valueArr[1].length : 0;
};

/**
 * Find multiple num.
 * @param {...Array} target values
 * @returns {number} multiple num
 */
var findMultipleNum = function() {
    var args = [].slice.call(arguments),
        underPointLens = tui.util.map(args, function(value) {
            return tui.util.getDecimalLength(value);
        }),
        underPointLen = tui.util.max(underPointLens),
        multipleNum = Math.pow(10, underPointLen);
    return multipleNum;
};

/**
 * Modulo operation for floating point operation.
 * @param {number} target target values
 * @param {number} modNum mod num
 * @returns {number} result mod
 */
var mod = function(target, modNum) {
    var multipleNum = tui.util.findMultipleNum(modNum);
    return ((target * multipleNum) % (modNum * multipleNum)) / multipleNum;
};

/**
 * Addition for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} addition result
 */
var addition = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) + (b * multipleNum)) / multipleNum;
};

/**
 * Subtraction for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} subtraction result
 */
var subtraction = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) - (b * multipleNum)) / multipleNum;
};

/**
 * Multiplication for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} multiplication result
 */
var multiplication = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) * (b * multipleNum)) / (multipleNum * multipleNum);
};

/**
 * Division for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} division result
 */
var division = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return (a * multipleNum) / (b * multipleNum);
};

/**
 * Sum.
 * @param {Array.<number>} values target values
 * @returns {number} result value
 */
var sum = function(values) {
    var copyArr = values.slice();
    copyArr.unshift(0);
    return tui.util.reduce(copyArr, function(base, add) {
        return parseFloat(base) + parseFloat(add);
    });
};

/**
 * Proper case.
 * @param {string} value - string value
 * @returns {string}
 */
var properCase = function(value) {
    return value.substring(0, 1).toUpperCase() + value.substring(1);
};

/**
 * Deep copy.
 * @param {object|Array|*} origin - original data
 * @returns {*}
 */
var deepCopy = function(origin) {
    var clone;

    if (tui.util.isArray(origin)) {
        clone = [];
        tui.util.forEachArray(origin, function (value, index) {
            clone[index] = deepCopy(value);
        });
    } else if (tui.util.isFunction(origin)) {
        clone = origin;
    } else if (tui.util.isObject(origin)) {
        clone = {};
        tui.util.forEach(origin, function(value, key) {
            clone[key] = deepCopy(value);
        });
    } else {
        clone = origin;
    }

    return clone;
};

tui.util.min = min;
tui.util.max = max;
tui.util.any = any;
tui.util.all = all;
tui.util.unique = unique;
tui.util.pivot = pivot;
tui.util.getDecimalLength = getDecimalLength;
tui.util.mod = mod;
tui.util.findMultipleNum = findMultipleNum;
tui.util.addition = addition;
tui.util.subtraction = subtraction;
tui.util.multiplication = multiplication;
tui.util.division = division;
tui.util.sum = sum;
tui.util.properCase = properCase;
tui.util.deepCopy = deepCopy;

var aps = Array.prototype.slice;

/**
 * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed
 * since the last time the debouced function was invoked.
 * @param {function} fn The function to debounce.
 * @param {number} [delay=0] The number of milliseconds to delay
 * @memberof tui.util
 * @returns {function} debounced function.
 * @example
 *
 * function someMethodToInvokeDebounced() {}
 *
 * var debounced = tui.util.debounce(someMethodToInvokeDebounced, 300);
 *
 * // invoke repeatedly
 * debounced();
 * debounced();
 * debounced();
 * debounced();
 * debounced();
 * debounced();    // last invoke of debounced()
 *
 * // invoke someMethodToInvokeDebounced() after 300 milliseconds.
 */
function debounce(fn, delay) {
    var timer,
        args;

    /* istanbul ignore next */
    delay = delay || 0;

    function debounced() {
        args = aps.call(arguments);

        window.clearTimeout(timer);
        timer = window.setTimeout(function() {
            fn.apply(null, args);
        }, delay);
    }

    return debounced;
}

/**
 * Creates a throttled function that only invokes fn at most once per every interval milliseconds.
 *
 * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)
 *
 * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.
 * @param {function} fn function to throttle
 * @param {number} [interval=0] the number of milliseconds to throttle invocations to.
 * @memberof tui.util
 * @returns {function} throttled function
 * @example
 *
 * function someMethodToInvokeThrottled() {}
 *
 * var throttled = tui.util.throttle(someMethodToInvokeThrottled, 300);
 *
 * // invoke repeatedly
 * throttled();    // invoke (leading)
 * throttled();
 * throttled();    // invoke (near 300 milliseconds)
 * throttled();
 * throttled();
 * throttled();    // invoke (near 600 milliseconds)
 * // ...
 * // invoke (trailing)
 *
 * // if you need reuse throttled method. then invoke reset()
 * throttled.reset();
 */
function throttle(fn, interval) {
    var base,
        _timestamp = tui.util.timestamp,
        debounced,
        isLeading = true,
        stamp,
        args,
        tick = function(_args) {
            fn.apply(null, _args);
            base = null;
        };

    /* istanbul ignore next */
    interval = interval || 0;

    debounced = tui.util.debounce(tick, interval);

    function throttled() {
        args = aps.call(arguments);

        if (isLeading) {
            tick(args);
            isLeading = false;
            return;
        }

        stamp = _timestamp();

        base = base || stamp;

        debounced(args);

        if ((stamp - base) >= interval) {
            tick(args);
        }
    }

    function reset() {
        isLeading = true;
        base = null;
    }

    throttled.reset = reset;
    return throttled;
}

tui.util.debounce = debounce;
tui.util.throttle = throttle;

},{}],20:[function(require,module,exports){
/**
 * @fileoverview Chart const
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/*eslint no-magic-numbers: 0*/

/**
 * Chart const
 * @readonly
 * @enum {number}
 */
var chartConst = {
    /** tui class names
     * @type {string}
     */
    CLASS_NAME_LEGEND_LABEL: 'tui-chart-legend-label',
    /** @type {string} */
    CLASS_NAME_LEGEND_CHECKBOX: 'tui-chart-legend-checkbox',
    /** @type {string} */
    CLASS_NAME_SERIES_LABEL: 'tui-chart-series-label',
    /** @type {string} */
    CLASS_NAME_SERIES_LEGEND: 'tui-chart-series-legend',
    /** chart types
     * @type {string}
     */
    CHART_TYPE_BAR: 'bar',
    /** @type {string} */
    CHART_TYPE_COLUMN: 'column',
    /** @type {string} */
    CHART_TYPE_LINE: 'line',
    /** @type {string} */
    CHART_TYPE_AREA: 'area',
    /** @type {string} */
    CHART_TYPE_COMBO: 'combo',
    /** @type {string} */
    CHART_TYPE_PIE: 'pie',
    /** @type {string} */
    CHART_TYPE_BUBBLE: 'bubble',
    /** @type {string} */
    CHART_TYPE_MAP: 'map',
    /** chart padding */
    CHART_PADDING: 10,
    /** chart default width */
    CHART_DEFAULT_WIDTH: 500,
    /** chart default height */
    CHART_DEFAULT_HEIGHT: 400,
    /** overlapping width of xAxis and yAxis */
    OVERLAPPING_WIDTH: 1,
    /** rendered text padding */
    TEXT_PADDING: 2,
    /** series expand size */
    SERIES_EXPAND_SIZE: 10,
    /** series label padding */
    SERIES_LABEL_PADDING: 5,
    /** default font size of title */
    DEFAULT_TITLE_FONT_SIZE: 14,
    /** default font size of axis title */
    DEFAULT_AXIS_TITLE_FONT_SIZE: 10,
    /** default font size of label */
    DEFAULT_LABEL_FONT_SIZE: 12,
    /** default font size of series label */
    DEFAULT_SERIES_LABEL_FONT_SIZE: 11,
    /** default graph plugin
     * @type {string}
     */
    DEFAULT_PLUGIN: 'raphael',
    /** default tick color
     * @type {string}
     */
    DEFAULT_TICK_COLOR: 'black',
    /** default theme name
     * @type {string}
     */
    DEFAULT_THEME_NAME: 'default',
    MAX_HEIGHT_WORLD: 'A',
    /** stacked option types
     * @type {string}
     */
    STACKED_NORMAL_TYPE: 'normal',
    /** @type {string} */
    STACKED_PERCENT_TYPE: 'percent',
    DEFAULT_STACK: '___DEFAULT___STACK___',
    DUMMY_KEY: '___DUMMY___KEY___',
    /** empty axis label */
    EMPTY_AXIS_LABEL: '',
    /** angel */
    ANGLE_85: 85,
    ANGLE_90: 90,
    ANGLE_360: 360,
    /** radian */
    RAD: Math.PI / 180,
    /** series legend aligns
     * @type {string}
     */
    LEGEND_ALIGN_OUTER: 'outer',
    /** @type {string} */
    LEGEND_ALIGN_CENTER: 'center',
    /** @type {string} */
    LEGEND_ALIGN_TOP: 'top',
    /** @type {string} */
    LEGEND_ALIGN_BOTTOM: 'bottom',
    /** @type {string} */
    LEGEND_ALIGN_LEFT: 'left',
    /** series outer label padding */
    SERIES_OUTER_LABEL_PADDING: 20,
    /** default rate of pie graph */
    PIE_GRAPH_DEFAULT_RATE: 0.8,
    /** small rate of pie graph */
    PIE_GRAPH_SMALL_RATE: 0.65,
    /** tick count for map chart legend */
    MAP_CHART_LEGEND_TICK_COUNT: 4,
    /** default position ratio of map chart label
     * @type {object}
     */
    MAP_CHART_LABEL_DEFAULT_POSITION_RATIO: {
        x: 0.5,
        y: 0.5
    },
    /** dot radius */
    DOT_RADIUS: 4,
    /** yAxis properties
     * @type {Array.<string>}
     */
    YAXIS_PROPS: ['tickColor', 'title', 'label'], // yaxis theme의 속성 - chart type filtering할 때 사용됨
    /** series properties
     * @type {Array.<string>}
     */
    SERIES_PROPS: ['label', 'colors', 'borderColor', 'singleColors',
        'selectionColor', 'startColor', 'endColor', 'overColor'], // series theme의 속성 - chart type filtering할 때 사용됨
    /** title area width padding */
    TITLE_AREA_WIDTH_PADDING: 20,
    /** top margin of x axis label */
    XAXIS_LABEL_TOP_MARGIN: 10,
    /** right padding of vertical label */
    V_LABEL_RIGHT_PADDING: 10,
    /** tooltip prefix
     * @type {string}
     */
    TOOLTIP_PREFIX: 'tui-chart-tooltip',
    /** tooltip z-index **/
    TOOLTIP_ZINDEX: 500,
    /** tooltip animation time */
    TOOLTIP_ANIMATION_TIME: 100,
    /** tooltip animation time for pie chart */
    TOOLTIP_PIE_ANIMATION_TIME: 50,
    /** minimum pixel type step size */
    MIN_PIXEL_TYPE_STEP_SIZE: 40,
    /** maximum pixel type step size */
    MAX_PIXEL_TYPE_STEP_SIZE: 60,
    /** axis scale of percent stacked option
     * @type {object}
     */
    PERCENT_STACKED_AXIS_SCALE: {
        limit: {
            min: 0,
            max: 100
        },
        step: 25,
        labels: [0, 25, 50, 75, 100]
    },
    /** axis scale of minus percent stacked option
     * @type {object}
     */
    MINUS_PERCENT_STACKED_AXIS_SCALE: {
        limit: {
            min: -100,
            max: 0
        },
        step: 25,
        labels: [0, -25, -50, -75, -100]
    },
    /** axis scale of dual percent stacked option
     * @type {object}
     */
    DUAL_PERCENT_STACKED_AXIS_SCALE: {
        limit: {
            min: -100,
            max: 100
        },
        step: 25,
        labels: [-100, -75, -50, -25, 0, 25, 50, 75, 100]
    },
    /** axis scale of diverging percent stacked option
     * @type {object}
     */
    DIVERGING_PERCENT_STACKED_AXIS_SCALE: {
        limit: {
            min: -100,
            max: 100
        },
        step: 25,
        labels: [100, 75, 50, 25, 0, 25, 50, 75, 100]
    },
    /** title add padding */
    TITLE_PADDING: 10,
    /** legend area padding */
    LEGEND_AREA_PADDING: 10,
    /** legend checkbox width */
    LEGEND_CHECKBOX_WIDTH: 20,
    /** legend rect width */
    LEGEND_RECT_WIDTH: 12,
    /** lgend label left padding */
    LEGEND_LABEL_LEFT_PADDING: 5,
    /** map legend height */
    MAP_LEGEND_SIZE: 200,
    /** map legend graph size */
    MAP_LEGEND_GRAPH_SIZE: 25,
    /** map legend label padding */
    MAP_LEGEND_LABEL_PADDING: 5,
    CIRCLE_LEGEND_LABEL_FONT_SIZE: 9,
    CIRCLE_LEGEND_PADDING: 20,
    HALF_RATIO: 0.5,
    /** AXIS LABEL PADDING */
    AXIS_LABEL_PADDING: 7,
    /** rotations degree candidates */
    DEGREE_CANDIDATES: [25, 45, 65, 85],
    /** yAxis align option
     * @type {string}
     */
    YAXIS_ALIGN_CENTER: 'center',
    /** xAxis label compare margin */
    XAXIS_LABEL_COMPARE_MARGIN: 20,
    /** xAxis label gutter */
    XAXIS_LABEL_GUTTER: 2,
    /**
     * Standard multiple nums of axis
     * @type {Array}
     */
    AXIS_STANDARD_MULTIPLE_NUMS: [1, 2, 5, 10, 20, 50, 100],
    /**
     * Last standard multiple num of axis
     */
    AXIS_LAST_STANDARD_MULTIPLE_NUM: 100,
    /** label padding top */
    LABEL_PADDING_TOP: 2,
    /** line margin top */
    LINE_MARGIN_TOP: 5,
    /** tooltip gap */
    TOOLTIP_GAP: 5,
    /** tooltip direction
     * @type {string}
     */
    TOOLTIP_DIRECTION_FORWARD: 'forword',
    /** @type {string} */
    TOOLTIP_DIRECTION_CENTER: 'center',
    /** @type {string} */
    TOOLTIP_DIRECTION_BACKWARD: 'backword',
    /** tooltip align options
     * @type {string}
     */
    TOOLTIP_DEFAULT_ALIGN_OPTION: 'center top',
    /** @type {string} */
    TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION: 'right middle',
    /** @type {string} */
    TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION: 'right middle',
    /** @type {string} */
    TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION: 'center bottom',
    /** hide delay */
    HIDE_DELAY: 200,
    OLD_BROWSER_OPACITY_100: 100,
    SERIES_LABEL_OPACITY: 0.3,
    WHEEL_TICK: 120,
    MAX_ZOOM_MAGN: 32,
    FF_WHEELDELTA_ADJUSTING_VALUE: -40,
    IE7_ROTATION_FILTER_STYLE_MAP: {
        25: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' +
                ' M11=0.9063077870366499, M12=0.42261826174069944, M21=-0.42261826174069944, M22=0.9063077870366499)"',
        45: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' +
                ' M11=0.7071067811865476, M12=0.7071067811865475, M21=-0.7071067811865475, M22=0.7071067811865476)"',
        65: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' +
                ' M11=0.42261826174069944, M12=0.9063077870366499, M21=-0.9063077870366499, M22=0.42261826174069944)"',
        85: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' +
                ' M11=0.08715574274765814, M12=0.9961946980917455, M21=-0.9961946980917455, M22=0.08715574274765814)"'
    }
};
module.exports = chartConst;

},{}],21:[function(require,module,exports){
/**
 * @fileoverview AreaTypeCustomEvent is event handle layer for line type chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase'),
    AreaTypeDataModel = require('./areaTypeDataModel'),
    chartConst = require('../const');

var AreaTypeCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends AreaTypeCustomEvent.prototype */ {
    /**
     * AreaTypeCustomEvent is custom event for line type chart.
     * @param {object} params parameters
     * @constructs AreaTypeCustomEvent
     * @extends CustomEventBase
     */
    init: function(params) {
        CustomEventBase.call(this, params);

        /**
         * previous found data
         * @type {null | object}
         */
        this.prevFoundData = null;
    },

    /**
     * Initialize data of custom event
     * @param {Array.<object>} seriesInfos series infos
     * @override
     */
    initCustomEventData: function(seriesInfos) {
        var seriesInfo = seriesInfos[0];
        this.dataModel = new AreaTypeDataModel(seriesInfo);
        CustomEventBase.prototype.initCustomEventData.call(this, seriesInfos);
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onMousemove: function(e) {
        var target = e.target || e.srcElement,
            bound = target.getBoundingClientRect(),
            layerX = e.clientX - chartConst.SERIES_EXPAND_SIZE - bound.left,
            layerY = e.clientY - bound.top,
            groupIndex = this.tickBaseCoordinateModel.findIndex(layerX),
            foundData = this.dataModel.findData(groupIndex, layerY);

        if (!this._isChangedSelectData(this.prevFoundData, foundData)) {
            return;
        }

        if (foundData) {
            this.fire('showTooltip', foundData);
        } else if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
        }
        this.prevFoundData = foundData;
    },

    /**
     * On mouseout.
     * @private
     * @override
     */
    _onMouseout: function() {
        if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
            this.prevFoundData = null;
        }
    }
});

module.exports = AreaTypeCustomEvent;

},{"../const":20,"./areaTypeDataModel":22,"./customEventBase":25}],22:[function(require,module,exports){
/**
 * @fileoverview AreaTypeDataModel is data model for custom event of area type.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var AreaTypeDataModel = tui.util.defineClass(/** @lends AreaTypeDataModel.prototype */ {
    /**
     * AreaTypeDataModel is data mode for custom event of area type.
     * @constructs AreaTypeDataModel
     * @param {object} seriesInfo series info
     */
    init: function(seriesInfo) {
        this.data = this._makeData(seriesInfo.data.groupPositions, seriesInfo.chartType);
    },

    /**
     * Make area type data for custom event.
     * @param {Array.<Array.<object>>} groupPositions - group positions
     * @param {string} chartType - chart type
     * @returns {Array}
     * @private
     */
    _makeData: function(groupPositions, chartType) {
        groupPositions = tui.util.pivot(groupPositions);
        return tui.util.map(groupPositions, function(positions, groupIndex) {
            return tui.util.map(positions, function(position, index) {
                return {
                    chartType: chartType,
                    indexes: {
                        groupIndex: groupIndex,
                        index: index
                    },
                    bound: position
                };
            });
        });
    },

    /**
     * Find Data.
     * @param {number} groupIndex - group index
     * @param {number} layerY - mouse position
     * @returns {object}
     */
    findData: function(groupIndex, layerY) {
        var result = null,
            min = 10000;
        tui.util.forEach(this.data[groupIndex], function(data) {
            var diff = Math.abs(layerY - data.bound.top);
            if (min > diff) {
                min = diff;
                result = data;
            }
        });
        return result;
    }
});

module.exports = AreaTypeDataModel;

},{}],23:[function(require,module,exports){
/**
 * @fileoverview BoundsBaseCoordinateModel is data mode for custom event of point type.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * position
 * @typedef {{left: number, top: number}} position
 */

/**
 * bound
 * @typedef {{
 *      dimension: {width: number, height: number},
 *      position: position
 *}} bound
 */

/**
 * group bound
 *  @typedef {Array.<Array.<bound>>} groupBound
 */

/**
 * group position
 *  @typedef {Array.<Array.<position>>} groupPosition
 */

/**
 * series info
 * @typedef {{
 *      chartType: {string},
 *      data: {
 *          groupBounds: ?groupBound,
 *          groupValues: ?Array.<Array.<number>>,
 *          groupPositions: ?groupPosition
 *      }
 *}} seriesInfo
 */

var chartConst = require('../const'),
    predicate = require('../helpers/predicate');

var BoundsBaseCoordinateModel = tui.util.defineClass(/** @lends BoundsBaseCoordinateModel.prototype */ {
    /**
     * BoundsBaseCoordinateModel is data mode for custom event of point type.
     * @constructs BoundsBaseCoordinateModel
     * @param {Array.<seriesInfo>} seriesInfos series infos
     */
    init: function(seriesInfos) {
        this.data = this._makeData(seriesInfos);
    },

    /**
     * Make coordinate data about bar type graph
     * @param {groupBound} groupBounds group bounds
     * @param {string} chartType chart type
     * @returns {Array} coordinate data
     * @private
     */
    _makeRectTypeCoordinateData: function(groupBounds, chartType) {
        return tui.util.map(groupBounds, function(bounds, groupIndex) {
            return tui.util.map(bounds, function(_bound, index) {
                var bound;
                if (!_bound) {
                    return null;
                }

                bound = _bound.end;

                return {
                    sendData: {
                        chartType: chartType,
                        indexes: {
                            groupIndex: groupIndex,
                            index: index
                        },
                        allowNegativeTooltip: true,
                        bound: bound
                    },
                    bound: {
                        left: bound.left,
                        top: bound.top,
                        right: bound.left + bound.width,
                        bottom: bound.top + bound.height
                    }
                };
            });
        });
    },

    /**
     * Make coordinate data about dot type graph
     * @param {groupPositions} groupPositions group positions
     * @param {string} chartType chart type
     * @returns {Array.<Array.<object>>} coordinate data
     * @private
     */
    _makeDotTypeCoordinateData: function(groupPositions, chartType) {
        if (!groupPositions) {
            return [];
        }

        return tui.util.map(tui.util.pivot(groupPositions), function(positions, groupIndex) {
            return tui.util.map(positions, function(position, index) {
                return {
                    sendData: {
                        chartType: chartType,
                        indexes: {
                            groupIndex: groupIndex,
                            index: index
                        },
                        bound: position
                    },
                    bound: {
                        left: position.left - chartConst.DOT_RADIUS,
                        top: position.top - chartConst.DOT_RADIUS,
                        right: position.left + chartConst.DOT_RADIUS,
                        bottom: position.top + chartConst.DOT_RADIUS
                    }
                };
            });
        });
    },

    /**
     * Join data.
     * @param {Array.<Array.<Array.<object>>>} groupData group data
     * @returns {Array.<Array.<object>>} joined data
     * @private
     */
    _joinData: function(groupData) {
        var results = [];
        tui.util.forEachArray(groupData, function(coordData) {
            tui.util.forEachArray(coordData, function(data, index) {
                if (!results[index]) {
                    results[index] = [];
                }
                results[index] = results[index].concat(data);
            });
        });

        return results;
    },

    /**
     * Make coordinate data.
     * @param {Array.<seriesInfo>} seriesInfos series infos
     * @returns {Array.<Array.<object>>} coordinate data
     * @private
     */
    _makeData: function(seriesInfos) {
        var self = this,
            coordinateData;

        seriesInfos.reverse();
        coordinateData = tui.util.map(seriesInfos, function(info) {
            var result;
            if (predicate.isLineTypeChart(info.chartType)) {
                result = self._makeDotTypeCoordinateData(info.data.groupPositions, info.chartType);
            } else {
                result = self._makeRectTypeCoordinateData(info.data.groupBounds, info.chartType);
            }
            return result;
        });
        return this._joinData(coordinateData);
    },

    /**
     * Find candidates.
     * @param {{bound: {left: number, top: number, right: number, bottom: number}}} data data
     * @param {number} layerX layerX
     * @param {number} layerY layerY
     * @returns {Array.<{sendData: object}>} candidates
     * @private
     */
    _findCandidates: function(data, layerX, layerY) {
        return tui.util.filter(data, function(datum) {
            var bound = datum && datum.bound,
                included = false,
                includedX, includedY;

            if (bound) {
                includedX = bound.left <= layerX && bound.right >= layerX;
                includedY = bound.top <= layerY && bound.bottom >= layerY;
                included = includedX && includedY;
            }

            return included;
        });
    },

    /**
     * Find tooltip data.
     * @param {number} groupIndex group index
     * @param {number} layerX mouse position x
     * @param {number} layerY mouse position y
     * @returns {object} tooltip data
     */
    findData: function(groupIndex, layerX, layerY) {
        var min = 10000,
            result = null,
            candidates;

        if (groupIndex > -1) {
            // layerX, layerY를 포함하는 data 추출
            candidates = this._findCandidates(this.data[groupIndex], layerX, layerY);

            // 추출된 data 중 top이 layerY와 가장 가까운 data 찾아내기
            tui.util.forEachArray(candidates, function(data) {
                var diff = Math.abs(layerY - data.sendData.bound.top);
                if (min > diff) {
                    min = diff;
                    result = data.sendData;
                }
            });
        }

        return result;
    }
});

module.exports = BoundsBaseCoordinateModel;

},{"../const":20,"../helpers/predicate":47}],24:[function(require,module,exports){
/**
 * @fileoverview BoundsTypeCustomEvent is event handle layer for bounds.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    CustomEventBase = require('./customEventBase');

var BoundsTypeCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends BoundsTypeCustomEvent.prototype */ {
    /**
     * BoundsTypeCustomEvent is event handle layer for line type chart.
     * @constructs BoundsTypeCustomEvent
     * @extends CustomEventBase
     */
    init: function() {
        CustomEventBase.apply(this, arguments);

        /**
         * previous found data
         * @type {null | object}
         */
        this.prevFoundData = null;
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onMousemove: function(e) {
        var target = e.target || e.srcElement,
            clientX = e.clientX - chartConst.SERIES_EXPAND_SIZE,
            foundData = this._findDataFromBoundsCoordinateModel(target, clientX, e.clientY);

        if (!this._isChangedSelectData(this.prevFoundData, foundData)) {
            return;
        }

        if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
        }

        if (foundData) {
            this.fire('showTooltip', foundData);
        }

        this.prevFoundData = foundData;
    },

    /**
     * On mouseout.
     * @override
     */
    _onMouseout: function() {
        if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
            this.prevFoundData = null;
        }
    }
});

module.exports = BoundsTypeCustomEvent;

},{"../const":20,"./customEventBase":25}],25:[function(require,module,exports){
/**
 * @fileoverview CustomEventBase is base class for event handle layers.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var eventListener = require('../helpers/eventListener'),
    TickBaseCoordinateModel = require('./tickBaseCoordinateModel'),
    BoundsBaseCoordinateModel = require('./boundsBaseCoordinateModel'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

var CustomEventBase = tui.util.defineClass(/** @lends CustomEventBase.prototype */ {
    /**
     * CustomEventBase is base class for custom event components.
     * @constructs CustomEventBase
     * @param {object} params parameters
     *      @param {{
     *          dimension: {width: number, height: number},
     *          position: {left: number, top: number}
     *      }} params.bound bound
     *      @param {string} params.chartType chart type
     *      @param {boolean} params.isVertical whether vertical or not
     */
    init: function(params) {
        this.chartType = params.chartType;
        this.isVertical = params.isVertical;
        this.dataProcessor = params.dataProcessor;
        this.boundsMaker = params.boundsMaker;
        this.selectedData = null;
    },

    /**
     * Render event handle layer area.
     * @param {HTMLElement} customEventContainer - container element for custom event
     * @param {object} data - data for rendering
     * @private
     */
    _renderCustomEventArea: function(customEventContainer, data) {
        var expandedBound, tbcm;

        this.dimension = this.boundsMaker.getDimension('customEvent');
        tbcm = new TickBaseCoordinateModel(this.dimension, data.tickCount, this.chartType, this.isVertical);
        this.tickBaseCoordinateModel = tbcm;
        expandedBound = renderUtil.expandBound(this.boundsMaker.getBound('customEvent'));
        renderUtil.renderDimension(customEventContainer, expandedBound.dimension);
        renderUtil.renderPosition(customEventContainer, expandedBound.position);
    },

    /**
     * Render for customEvent component.
     * @param {object} data - data for rendering
     * @returns {HTMLElement} container for custom event
     */
    render: function(data) {
        var container = dom.create('DIV', 'tui-chart-series-custom-event-area');

        this._renderCustomEventArea(container, data);
        this.attachEvent(container);
        this.customEventContainer = container;
        return container;
    },

    /**
     * Create BoundsBaseCoordinateModel from seriesBounds for custom event.
     * @param {Array.<object>} seriesBounds - series bounds
     */
    initCustomEventData: function(seriesBounds) {
        this.boundsBaseCoordinateModel = new BoundsBaseCoordinateModel(seriesBounds);
    },

    /**
     * Rerender for customEvent component.
     * @param {{tickCount: number}} data - data for rerendering
     */
    rerender: function(data) {
        this._renderCustomEventArea(this.customEventContainer, data);
    },

    /**
     * Resize for customEvent component.
     * @param {{tickCount: number}} data - data for resizing
     */
    resize: function(data) {
        this.rerender(data);
    },

    /**
     * Whether changed select data or not.
     * @param {object} prev - previous data
     * @param {object} cur - current data
     * @returns {boolean}
     * @private
     */
    _isChangedSelectData: function(prev, cur) {
        return !prev || !cur || prev.chartType !== cur.chartType ||
            prev.indexes.groupIndex !== cur.indexes.groupIndex || prev.indexes.index !== cur.indexes.index;
    },

    /**
     * Find coordinate data from boundsCoordinateModel.
     * @param {HTMLElement} target - target element
     * @param {number} clientX mouse - position x
     * @param {number} clientY mouse - position y
     * @returns {object}
     * @private
     */
    _findDataFromBoundsCoordinateModel: function(target, clientX, clientY) {
        var bound = target.getBoundingClientRect(),
            layerX = clientX - bound.left,
            layerY = clientY - bound.top,
            groupIndex = this.tickBaseCoordinateModel.findIndex(this.isVertical ? layerX : layerY);
        return this.boundsBaseCoordinateModel.findData(groupIndex, layerX + chartConst.SERIES_EXPAND_SIZE, layerY);
    },

    /**
     * Unselect selected data.
     * @private
     */
    _unselectSelectedData: function() {
        var eventName = renderUtil.makeCustomEventName('unselect', this.selectedData.chartType, 'series');
        this.fire(eventName, this.selectedData);
        this.selectedData = null;
    },

    /**
     * On mouse event.
     * @param {string} eventType - custom event type
     * @param {MouseEvent} e - mouse event
     * @private
     */
    _onMouseEvent: function(eventType, e) {
        var eventName = renderUtil.makeCustomEventName(eventType, this.chartType, 'series');

        dom.addClass(this.customEventContainer, 'hide');
        this.fire(eventName, {
            left: e.clientX,
            top: e.clientY
        });
        dom.removeClass(this.customEventContainer, 'hide');
    },

    /**
     * On click
     * @param {MouseEvent} e - mouse event
     * @private
     */
    _onClick: function(e) {
        var target = e.target || e.srcElement,
            clientX = e.clientX - chartConst.SERIES_EXPAND_SIZE,
            foundData = this._findDataFromBoundsCoordinateModel(target, clientX, e.clientY);
        if (!this._isChangedSelectData(this.selectedData, foundData)) {
            this._unselectSelectedData();
        } else if (foundData) {
            if (this.selectedData) {
                this._unselectSelectedData();
            }
            this.fire(renderUtil.makeCustomEventName('select', foundData.chartType, 'series'), foundData);
            this.selectedData = foundData;
        }
    },

    /**
     * On mouse down
     * @private
     * @abstract
     */
    _onMousedown: function() {},

    /**
     * On mouse up
     * @private
     * @abstract
     */
    _onMouseup: function() {},

    /**
     * On mouse move
     * @private
     * @abstract
     */
    _onMousemove: function() {},

    /**
     * On mouse out
     * @private
     * @abstract
     */
    _onMouseout: function() {},

    /**
     * Attach event
     * @param {HTMLElement} target - target element
     */
    attachEvent: function(target) {
        eventListener.bindEvent('click', target, this._onClick, this);
        eventListener.bindEvent('mousedown', target, this._onMousedown, this);
        eventListener.bindEvent('mouseup', target, this._onMouseup, this);
        eventListener.bindEvent('mousemove', target, this._onMousemove, this);
        eventListener.bindEvent('mouseout', target, this._onMouseout, this);
    }
});

tui.util.CustomEvents.mixin(CustomEventBase);

module.exports = CustomEventBase;

},{"../const":20,"../helpers/domHandler":45,"../helpers/eventListener":46,"../helpers/renderUtil":49,"./boundsBaseCoordinateModel":23,"./tickBaseCoordinateModel":29}],26:[function(require,module,exports){
/**
 * @fileoverview GroupTypeCustomEvent is event handle layer for grouped tooltip option.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase'),
    chartConst = require('../const');

var GroupTypeCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends GroupTypeCustomEvent.prototype */ {
    /**
     * GroupTypeCustomEvent is event handle layer for grouped tooltip option.
     * @constructs GroupTypeCustomEvent
     * @extends CustomEventBase
     */
    init: function() {
        CustomEventBase.apply(this, arguments);
    },

    /**
     * Whether out position or not.
     * @param {number} layerX layerX
     * @param {number} layerY layerY
     * @returns {boolean} result boolean
     * @private
     */
    _isOutPosition: function(layerX, layerY) {
        var dimension = this.dimension;
        return layerX < 0 || layerX > dimension.width || layerY < 0 || layerY > dimension.height;
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e mouse event object
     * @private
     * @override
     */
    _onMousemove: function(e) {
        var elTarget = e.target || e.srcElement,
            bound = elTarget.getBoundingClientRect(),
            layerX = e.clientX - chartConst.SERIES_EXPAND_SIZE - bound.left,
            layerY = e.clientY - chartConst.SERIES_EXPAND_SIZE - bound.top,
            index = -1,
            pointValue, sizeType;

        if (this.isVertical) {
            pointValue = layerX;
            sizeType = 'height';
        } else {
            pointValue = layerY;
            sizeType = 'width';
        }

        if (!this._isOutPosition(layerX, layerY)) {
            index = this.tickBaseCoordinateModel.findIndex(pointValue);
        }

        if (index === -1) {
            this._onMouseout();
        } else if (this.prevIndex !== index) {
            this.prevIndex = index;
            this.fire('showGroupTooltip', {
                index: index,
                range: this.tickBaseCoordinateModel.makeRange(index, this.chartType),
                size: this.dimension[sizeType],
                isVertical: this.isVertical
            });
        }
    },

    /**
     * On mouseout.
     * @override
     */
    _onMouseout: function() {
        if (!tui.util.isUndefined(this.prevIndex)) {
            this.fire('hideGroupTooltip', this.prevIndex);
            delete this.prevIndex;
        }
    }
});

module.exports = GroupTypeCustomEvent;

},{"../const":20,"./customEventBase":25}],27:[function(require,module,exports){
/**
 * @fileoverview MapChartCustomEvent is event handle layer for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase'),
    chartConst = require('../const'),
    eventListener = require('../helpers/eventListener'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

var MapChartCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends MapChartCustomEvent.prototype */ {
    /**
     * MapChartCustomEvent is event handle layer for map chart.
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker boundsMaker instance
     * @constructs MapChartCustomEvent
     * @extends CustomEventBase
     */
    init: function(params) {
        this.boundsMaker = params.boundsMaker;
        this.chartType = params.chartType;
        this.isDown = false;
    },
    /**
     * Render event handle layer area
     * @param {HTMLElement} customEventContainer custom event container element
     * @private
     */
    _renderCustomEventArea: function(customEventContainer) {
        var bound = this.boundsMaker.getBound('customEvent');
        renderUtil.renderDimension(customEventContainer, bound.dimension);
        renderUtil.renderPosition(customEventContainer, bound.position);
    },

    /**
     * Initialize data of custom event
     * @override
     */
    initCustomEventData: function() {},

    /**
     * On click.
     * @private
     * @override
     */
    _onClick: function() {},

    /**
     * On mouse down
     * @param {mouseevent} e mouse event
     * @private
     * @override
     */
    _onMousedown: function(e) {
        this.isDown = true;
        this.fire('dragStartMapSeries', {
            left: e.clientX,
            top: e.clientY
        });
    },

    /**
     * Drag end.
     * @private
     */
    _dragEnd: function() {
        this.isDrag = false;
        dom.removeClass(this.customEventContainer, 'drag');
        this.fire('dragEndMapSeries');
    },

    /**
     * On mouse up
     * @param {mouseevent} e mouse event
     * @private
     * @override
     */
    _onMouseup: function(e) {
        this.isDown = false;
        if (this.isDrag) {
            this._dragEnd();
        } else if (!this.isMove) {
            this._onMouseEvent('click', e);
        }
        this.isMove = false;
    },

    /**
     * On mouse move.
     * @param {mouseevent} e mouse event
     * @private
     * @override
     */
    _onMousemove: function(e) {
        if (this.isDown) {
            if (!this.isDrag) {
                dom.addClass(this.customEventContainer, 'drag');
            }
            this.isDrag = true;
            this.fire('dragMapSeries', {
                left: e.clientX,
                top: e.clientY
            });
        } else {
            this.isMove = true;
            this._onMouseEvent('move', e);
        }
    },

    /**
     * On mouse out
     * @private
     * @override
     */
    _onMouseout: function(e) {
        if (this.isDrag) {
            this._dragEnd();
        } else {
            this._onMouseEvent('move', e);
        }
        this.isDown = false;
    },

    /**
     * On mouse wheel.
     * @param {mouseevent} e mouse event
     * @returns {?boolean}
     * @private
     */
    _onMousewheel: function(e) {
        var wheelDelta = e.wheelDelta || e.detail * chartConst.FF_WHEELDELTA_ADJUSTING_VALUE;

        this.fire('wheel', wheelDelta, {
            left: e.clientX,
            top: e.clientY
        });

        if (e.preventDefault) {
            e.preventDefault();
        }

        return false;
    },

    /**
     * Attach event
     * @param {HTMLElement} target target element
     * @override
     */
    attachEvent: function(target) {
        CustomEventBase.prototype.attachEvent.call(this, target);

        if (tui.util.browser.firefox) {
            eventListener.bindEvent('DOMMouseScroll', target, this._onMousewheel, this);
        } else {
            eventListener.bindEvent('mousewheel', target, this._onMousewheel, this);
        }
    }
});

tui.util.CustomEvents.mixin(MapChartCustomEvent);

module.exports = MapChartCustomEvent;

},{"../const":20,"../helpers/domHandler":45,"../helpers/eventListener":46,"../helpers/renderUtil":49,"./customEventBase":25}],28:[function(require,module,exports){
/**
 * @fileoverview SimpleCustomEvent is event handle layer for simply sending clientX, clientY.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase'),
    renderUtil = require('../helpers/renderUtil');

var SimpleCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends SimpleCustomEvent.prototype */ {
    /**
     * SimpleCustomEvent is event handle layer for simply sending clientX, clientY.
     * @constructs SimpleCustomEvent
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker - bounds maker instance
     *      @param {string} params.chartType - chart type
     * @extends CustomEventBase
     */
    init: function(params) {
        this.boundsMaker = params.boundsMaker;
        this.chartType = params.chartType;
    },

    /**
     * Render event handle layer area
     * @param {HTMLElement} customEventContainer - container element for custom event
     * @private
     */
    _renderCustomEventArea: function(customEventContainer) {
        var bound = this.boundsMaker.getBound('customEvent');
        renderUtil.renderDimension(customEventContainer, bound.dimension);
        renderUtil.renderPosition(customEventContainer, bound.position);
    },

    /**
     * Initialize data of custom event
     * @override
     */
    initCustomEventData: function() {},

    /**
     * On click.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onClick: function(e) {
        this._onMouseEvent('click', e);
    },

    /**
     * On mouse move.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onMousemove: function(e) {
        this._onMouseEvent('move', e);
    },

    /**
     * On mouse out.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onMouseout: function(e) {
        this._onMouseEvent('move', e);
    }
});

tui.util.CustomEvents.mixin(SimpleCustomEvent);

module.exports = SimpleCustomEvent;

},{"../helpers/renderUtil":49,"./customEventBase":25}],29:[function(require,module,exports){
/**
 * @fileoverview TickBaseDataModel is tick base data model.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var predicate = require('../helpers/predicate');

var TickBaseDataModel = tui.util.defineClass(/** @lends TickBaseDataModel.prototype */ {
    /**
     * TickBaseDataModel is tick base data model.
     * @param {{width: number, height: number}} dimension dimension
     * @param {number} tickCount tick count
     * @param {string} chartType chart type
     * @param {boolan} isVertical whether vertical or not
     * @constructs TickBaseDataModel
     */
    init: function(dimension, tickCount, chartType, isVertical) {
        this.data = this._makeData(dimension, tickCount, chartType, isVertical);
    },

    /**
     * Make tick base data about line type chart.
     * @param {number} width width
     * @param {number} tickCount tick count
     * @returns {Array} tick base data
     * @private
     */
    _makeLineTypeData: function(width, tickCount) {
        var tickInterval = (width + 1) / (tickCount - 1),
            halfInterval = tickInterval / 2,
            ranges = tui.util.map(tui.util.range(0, tickCount), function(index) {
                return {
                    min: index * tickInterval - halfInterval,
                    max: index * tickInterval + halfInterval
                };
            });
        ranges[tickCount - 1].max -= 1;
        return ranges;
    },

    /**
     * Make tick base data about non line type chart.
     * @param {number} size width or height
     * @param {number} tickCount tick count
     * @returns {Array} tick base data
     * @private
     */
    _makeNormalData: function(size, tickCount) {
        var len = tickCount - 1,
            tickInterval = size / len,
            prev = 0;
        return tui.util.map(tui.util.range(0, len), function(index) {
            var max = tui.util.min([size, (index + 1) * tickInterval]),
                limit = {
                    min: prev,
                    max: max
                };
            prev = max;
            return limit;
        });
    },

    /**
     * Make tick base data for custom event.
     * @param {{width: number, height: number}} dimension dimension
     * @param {number} tickCount tick count
     * @param {string} chartType chart type
     * @param {boolan} isVertical whether vertical or not
     * @returns {Array.<object>} tick base data
     * @private
     */
    _makeData: function(dimension, tickCount, chartType, isVertical) {
        var sizeType = isVertical ? 'width' : 'height',
            data;
        if (predicate.isLineTypeChart(chartType)) {
            data = this._makeLineTypeData(dimension[sizeType], tickCount);
        } else {
            data = this._makeNormalData(dimension[sizeType], tickCount);
        }

        return data;
    },

    /**
     * Find index.
     * @param {number} pointValue mouse position point value
     * @returns {number} group index
     */
    findIndex: function(pointValue) {
        var foundIndex = -1;
        tui.util.forEachArray(this.data, function(limit, index) {
            if (limit.min < pointValue && limit.max >= pointValue) {
                foundIndex = index;
                return false;
            }

            return true;
        });

        return foundIndex;
    },

    /**
     * Get tick base data length.
     * @returns {number} length
     */
    getLength: function() {
        return this.data.length;
    },

    /**
     * Make range of tooltip position.
     * @param {number} index index
     * @param {string} chartType chart type
     * @returns {{start: number, end: number}} range type value
     * @private
     */
    makeRange: function(index, chartType) {
        var limit = this.data[index],
            range, center;
        if (predicate.isLineTypeChart(chartType)) {
            center = parseInt(limit.max - (limit.max - limit.min) / 2, 10);
            range = {
                start: center,
                end: center
            };
        } else {
            range = {
                start: limit.min,
                end: limit.max
            };
        }

        return range;
    }
});

module.exports = TickBaseDataModel;

},{"../helpers/predicate":47}],30:[function(require,module,exports){
/**
 * @fileoverview DataProcessor process rawData.
 * rawData.categories --> categories
 * rawData.series --> SeriesDataModel, legendLabels, legendData
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    SeriesDataModel = require('../dataModels/seriesDataModel'),
    SeriesGroup = require('./seriesGroup'),
    predicate = require('../helpers/predicate'),
    rawDataHandler = require('../helpers/rawDataHandler'),
    renderUtil = require('../helpers/renderUtil');

var concat = Array.prototype.concat;

/**
 * Raw series datum.
 * @typedef {{name: ?string, data: Array.<number>, stack: ?string}} rawSeriesDatum
 */

/**
 * Raw series data.
 * @typedef {Array.<rawSeriesDatum>} rawSeriesData
 */

/**
 * Raw data by user.
 * @typedef {{
 *      categories: ?Array.<string>,
 *      series: (rawSeriesData|{line: ?rawSeriesData, column: ?rawSeriesData})
 * }} rawData
 */

/**
 * SeriesDataModel is base model for drawing graph of chart series area,
 *      and create from rawSeriesData by user,
 * SeriesDataModel.groups has SeriesGroups.
 */

/**
 * SeriesGroup is a element of SeriesDataModel.groups.
 * SeriesGroup.items has SeriesItem.
 */

var DataProcessor = tui.util.defineClass(/** @lends DataProcessor.prototype */{
    /**
     * Data processor.
     * @constructs DataProcessor
     * @param {rawData} rawData raw data
     * @param {string} chartType chart type
     * @param {object} options options
     * @param {Array.<string>} seriesChartTypes chart types
     */
    init: function(rawData, chartType, options, seriesChartTypes) {
        var seriesOption = options.series || {};

        /**
         * original raw data.
         * @type {{categories: ?Array.<string>, series: Array.<object>}}
         */
        this.originalRawData = rawData;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = chartType;

        /**
         * chart options
         * @type {Object}
         */
        this.options = options;

        /**
         * seriesChartTypes is sorted chart types for rendering series area of combo chart.
         * @type {Array.<string>}
         */
        this.seriesChartTypes = seriesChartTypes;

        /**
         * diverging option
         * @type {boolean}
         */
        this.divergingOption = predicate.isBarTypeChart(options.chartType) && seriesOption.diverging;

        /**
         * legend data for rendering legend of group tooltip
         * @type {Array.<{chartType: string, label: string}>}
         */
        this.originalLegendData = null;

        this.initData(rawData);
    },

    /**
     * Get original raw data.
     * @returns {rawData} raw data
     */
    getOriginalRawData: function() {
        return this.originalRawData;
    },

    /**
     * Initialize data.
     * @param {rawData} rawData raw data
     */
    initData: function(rawData) {
        /**
         * raw data
         * @type {rawData}
         */
        this.rawData = rawData;

        /**
         * categories
         * @type {Array.<string>}
         */
        this.categories = null;

        /**
         * stacks
         * @type {Array.<number>}
         */
        this.stacks = null;

        /**
         * seriesDataModel map
         * @type {object.<string, SeriesDataModel>}
         */
        this.seriesDataModelMap = {};

        /**
         * SeriesGroups
         * @type {Array.<SeriesGroup>}
         */
        this.seriesGroups = null;

        /**
         * map of values of SeriesItems
         * @type {Object.<string, Array.<number>>}
         */
        this.valuesMap = {};

        /**
         * legend labels for rendering legend area
         * @type {{column: Array.<string>, line: Array.<string> | Array.<string>}}
         */
        this.legendLabels = null;

        /**
         * legend data for rendering legend
         * @type {Array.<{chartType: string, label: string}>}
         */
        this.legendData = null;

        /**
         * functions for formatting
         * @type {Array.<function>}
         */
        this.formatFunctions = null;

        /**
         * multiline categories
         * @type {Array.<string>}
         */
        this.multilineCategories = null;
    },

    /**
     * Process categories
     * @returns {Array.<string>} processed categories
     * @private
     */
    _processCategories: function() {
        return tui.util.map(this.rawData.categories, tui.util.encodeHTMLEntity);
    },

    /**
     * Get Categories
     * @returns {Array.<string>}}
     */
    getCategories: function() {
        if (!this.categories) {
            this.categories = this._processCategories();
        }

        return this.categories;
    },

    /**
     * Whether has categories or not.
     * @returns {boolean}
     */
    hasCategories: function() {
        return !!this.getCategories().length;
    },

    /**
     * Get category.
     * @param {number} index index
     * @returns {string} category
     */
    getCategory: function(index) {
        return this.getCategories()[index];
    },

    /**
     * Get stacks.
     * @returns {Array.<string>}
     */
    getStacks: function() {
        if (!this.stacks) {
            this.stacks = rawDataHandler.pickStacks(this.rawData.series);
        }

        return this.stacks;
    },

    /**
     * Get stack count.
     * @returns {Number}
     */
    getStackCount: function() {
        return this.getStacks().length;
    },

    /**
     * Find stack index.
     * @param {string} stack stack
     * @returns {number}
     */
    findStackIndex: function(stack) {
        return tui.util.inArray(stack, this.getStacks());
    },

    /**
     * Get SeriesDataModel.
     * @param {string} chartType - chart type
     * @returns {SeriesDataModel}
     */
    getSeriesDataModel: function(chartType) {
        var rawSeriesData;

        if (!this.seriesDataModelMap[chartType]) {
            rawSeriesData = this.rawData.series[chartType] || this.rawData.series;
            this.seriesDataModelMap[chartType] = new SeriesDataModel(rawSeriesData, chartType,
                this.options, this.getFormatFunctions());
        }

        return this.seriesDataModelMap[chartType];
    },

    /**
     * Get group count.
     * @param {string} chartType chart type
     * @returns {number}
     */
    getGroupCount: function(chartType) {
        return this.getSeriesDataModel(chartType).getGroupCount();
    },

    /**
     * Traverse all SeriesDataModel by seriesChartTypes, and executes iteratee function.
     * @param {function} iteratee iteratee function
     * @private
     */
    _eachByAllSeriesDataModel: function(iteratee) {
        var self = this,
            seriesChartTypes = this.seriesChartTypes || [this.chartType];

        tui.util.forEachArray(seriesChartTypes, function(chartType) {
            return iteratee(self.getSeriesDataModel(chartType), chartType);
        });
    },

    /**
     * Whether valid all SeriesDataModel or not.
     * @returns {boolean}
     */
    isValidAllSeriesDataModel: function() {
        var isValid = true;

        this._eachByAllSeriesDataModel(function(seriesDataModel) {
            isValid = !!seriesDataModel.getGroupCount();

            return isValid;
        });

        return isValid;
    },

    /**
     * Make SeriesGroups.
     * @returns {Array.<SeriesGroup>}
     * @private
     */
    _makeSeriesGroups: function() {
        var joinedGroups = [],
            seriesGroups;

        this._eachByAllSeriesDataModel(function(seriesDataModel) {
            seriesDataModel.each(function(seriesGroup, index) {
                if (!joinedGroups[index]) {
                    joinedGroups[index] = [];
                }
                joinedGroups[index] = joinedGroups[index].concat(seriesGroup.items);
            });
        });

        seriesGroups = tui.util.map(joinedGroups, function(items) {
            return new SeriesGroup(items);
        });

        return seriesGroups;
    },

    /**
     * Get SeriesGroups.
     * @returns {Array.<SeriesGroup>}
     */
    getSeriesGroups: function() {
        if (!this.seriesGroups) {
            this.seriesGroups = this._makeSeriesGroups();
        }
        return this.seriesGroups;
    },

    /**
     * Get value.
     * @param {number} groupIndex group index
     * @param {number} index index
     * @param {?string} chartType chart type
     * @returns {number} value
     */
    getValue: function(groupIndex, index, chartType) {
        return this.getSeriesDataModel(chartType).getValue(groupIndex, index);
    },

    /**
     * Create values that picked value from SeriesItems of specific SeriesDataModel.
     * @param {?string} chartType - type of chart
     * @param {?string} valueType - type of value like value, x, y, r.
     * @returns {Array.<number>}
     * @private
     */
    _createValues: function(chartType, valueType) {
        var values;

        if (chartType === chartConst.DUMMY_KEY) {
            values = [];
            this._eachByAllSeriesDataModel(function(seriesDataModel) {
                values = values.concat(seriesDataModel.getValues(valueType));
            });
        } else {
            values = this.getSeriesDataModel(chartType).getValues(valueType);
        }
        return values;
    },

    /**
     * Get values from valuesMap.
     * @param {?string} chartType - type of chart
     * @param {?string} valueType - type of value like value, x, y, r.
     * @returns {Array.<number>}
     */
    getValues: function(chartType, valueType) {
        var mapKey;

        chartType = chartType || chartConst.DUMMY_KEY;

        mapKey = chartType + valueType;

        if (!this.valuesMap[mapKey]) {
            this.valuesMap[mapKey] = this._createValues(chartType, valueType);
        }

        return this.valuesMap[mapKey];
    },

    /**
     * Get max value.
     * @param {?string} chartType - type of chart
     * @param {?string} valueType - type of value like value, x, y, r
     * @returns {number}
     */
    getMaxValue: function(chartType, valueType) {
        return tui.util.max(this.getValues(chartType, valueType));
    },

    /**
     * Get formatted max value.
     * @param {?string} chartType - type of chart
     * @param {?string} areaType - type of area like circleLegend
     * @param {?string} valueType - type of value like value, x, y, r
     * @returns {string | number}
     */
    getFormattedMaxValue: function(chartType, areaType, valueType) {
        var maxValue = this.getMaxValue(chartType, valueType);
        var formatFunctions = this.getFormatFunctions();

        return renderUtil.formatValue(maxValue, formatFunctions, areaType, valueType);
    },

    /**
     * Traverse SeriesGroup of all SeriesDataModel, and executes iteratee function.
     * @param {function} iteratee iteratee function
     */
    eachBySeriesGroup: function(iteratee) {
        this._eachByAllSeriesDataModel(function(seriesDataModel, chartType) {
            seriesDataModel.each(function(seriesGroup, groupIndex) {
                iteratee(seriesGroup, groupIndex, chartType);
            });
        });
    },

    /**
     * Pick legend label.
     * @param {object} item item
     * @returns {string} label
     * @private
     */
    _pickLegendLabel: function(item) {
        return tui.util.encodeHTMLEntity(item.name);
    },

    /**
     * Pick legend labels from raw data.
     * @returns {string[]} labels
     */
    _pickLegendLabels: function() {
        var self = this,
            seriesData = this.rawData.series,
            result;
        if (tui.util.isArray(seriesData)) {
            result = tui.util.map(seriesData, this._pickLegendLabel);
        } else {
            result = {};
            tui.util.forEach(seriesData, function(seriesDatum, type) {
                result[type] = tui.util.map(seriesDatum, self._pickLegendLabel);
            });
        }

        return result;
    },

    /**
     * Get legend labels.
     * @param {?string} chartType chart type
     * @returns {Array.<string> | {column: ?Array.<string>, line: ?Array.<string>}} legend labels
     */
    getLegendLabels: function(chartType) {
        if (!this.legendLabels) {
            this.legendLabels = this._pickLegendLabels();
        }
        return this.legendLabels[chartType] || this.legendLabels;
    },

    /**
     * Make legend data.
     * @returns {Array} labels
     * @private
     */
    _makeLegendData: function() {
        var legendLabels = this.getLegendLabels(),
            seriesChartTypes = this.seriesChartTypes || [this.chartType],
            legendLabelsMap, legendData;

        if (tui.util.isArray(legendLabels)) {
            legendLabelsMap = [this.chartType];
            legendLabelsMap[this.chartType] = legendLabels;
        } else {
            seriesChartTypes = this.seriesChartTypes;
            legendLabelsMap = legendLabels;
        }

        legendData = tui.util.map(seriesChartTypes, function(chartType) {
            return tui.util.map(legendLabelsMap[chartType], function(label) {
                return {
                    chartType: chartType,
                    label: label
                };
            });
        });

        return concat.apply([], legendData);
    },

    /**
     * Get legend data.
     * @returns {Array.<{chartType: string, label: string}>} legend data
     */
    getLegendData: function() {
        if (!this.legendData) {
            this.legendData = this._makeLegendData();
        }

        if (!this.originalLegendData) {
            this.originalLegendData = this.legendData;
        }

        return this.legendData;
    },

    /**
     * get original legend data.
     * @returns {Array.<{chartType: string, label: string}>}
     */
    getOriginalLegendData: function() {
        return this.originalLegendData;
    },

    /**
     * Get legend item.
     * @param {number} index index
     * @returns {{chartType: string, label: string}} legend data
     */
    getLegendItem: function(index) {
        return this.getLegendData()[index];
    },

    /**
     * Get format functions.
     * @returns {Array.<function>} functions
     */
    getFormatFunctions: function() {
        if (!this.formatFunctions) {
            this.formatFunctions = this._findFormatFunctions();
        }

        return this.formatFunctions;
    },

    /**
     * Get first label of SeriesItem.
     * @param {?string} chartType chartType
     * @returns {string} formatted value
     */
    getFirstItemLabel: function(chartType) {
        return this.getSeriesDataModel(chartType).getFirstItemLabel();
    },

    /**
     * Pick max length under point.
     * @param {string[]} values chart values
     * @returns {number} max length under point
     * @private
     */
    _pickMaxLenUnderPoint: function(values) {
        var max = 0;

        tui.util.forEachArray(values, function(value) {
            var len = tui.util.getDecimalLength(value);
            if (len > max) {
                max = len;
            }
        });

        return max;
    },

    /**
     * Whether zero fill format or not.
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isZeroFill: function(format) {
        return format.length > 2 && format.charAt(0) === '0';
    },

    /**
     * Whether decimal format or not.
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isDecimal: function(format) {
        var indexOf = format.indexOf('.');

        return indexOf > -1 && indexOf < format.length - 1;
    },

    /**
     * Whether comma format or not.
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isComma: function(format) {
        return format.indexOf(',') > -1;
    },

    /**
     * Format to zero fill.
     * @param {number} len length of result
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    _formatToZeroFill: function(len, value) {
        var isMinus = value < 0;

        value = renderUtil.formatToZeroFill(Math.abs(value), len);

        return (isMinus ? '-' : '') + value;
    },

    /**
     * Format to Decimal.
     * @param {number} len length of under decimal point
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    _formatToDecimal: function(len, value) {
        return renderUtil.formatToDecimal(value, len);
    },

    /**
     * Find simple type format functions.
     * @param {string} format - simple format
     * @returns {Array.<function>}
     */
    _findSimpleTypeFormatFunctions: function(format) {
        var funcs = [];
        var len;

        if (this._isDecimal(format)) {
            len = this._pickMaxLenUnderPoint([format]);
            funcs = [tui.util.bind(this._formatToDecimal, this, len)];
        } else if (this._isZeroFill(format)) {
            len = format.length;
            funcs = [tui.util.bind(this._formatToZeroFill, this, len)];
            return funcs;
        }

        if (this._isComma(format)) {
            funcs.push(renderUtil.formatToComma);
        }

        return funcs;
    },

    /**
     * Find format functions.
     * @returns {function[]} functions
     */
    _findFormatFunctions: function() {
        var format = tui.util.pick(this.options, 'chart', 'format');
        var funcs = [];

        if (tui.util.isFunction(format)) {
            funcs = [format];
        } else if (tui.util.isString(format)) {
            funcs = this._findSimpleTypeFormatFunctions(format);
        }

        return funcs;
    },

    /**
     * Make multiline category.
     * @param {string} category category
     * @param {number} limitWidth limit width
     * @param {object} theme label theme
     * @returns {string} multiline category
     * @private
     */
    _makeMultilineCategory: function(category, limitWidth, theme) {
        var words = String(category).split(/\s+/),
            lineWords = words[0],
            lines = [];

        tui.util.forEachArray(words.slice(1), function(word) {
            var width = renderUtil.getRenderedLabelWidth(lineWords + ' ' + word, theme);

            if (width > limitWidth) {
                lines.push(lineWords);
                lineWords = word;
            } else {
                lineWords += ' ' + word;
            }
        });

        if (lineWords) {
            lines.push(lineWords);
        }

        return lines.join('<br>');
    },

    /**
     * Get multiline categories.
     * @param {number} limitWidth limit width
     * @param {object} theme label theme
     * @param {Array.<(number | string)>} xAxisLabels labels of xAxis
     * @returns {Array} multiline categories
     */
    getMultilineCategories: function(limitWidth, theme, xAxisLabels) {
        var self = this;

        if (!this.multilineCategories) {
            this.multilineCategories = tui.util.map(xAxisLabels, function(category) {
                return self._makeMultilineCategory(category, limitWidth, theme);
            });
        }

        return this.multilineCategories;
    },

    /**
     * Add data ratios of pie chart.
     */
    addDataRatiosOfPieChart: function() {
        this.getSeriesDataModel(chartConst.CHART_TYPE_PIE).addDataRatiosOfPieChart();
    },

    /**
     * Add data ratios for chart of coordinate type.
     * @param {{x: {min: number, max: number}, y: {min: number, max: number}}} limitMap - limit map
     */
    addDataRatiosForCoordinateType: function(limitMap) {
        this.getSeriesDataModel(chartConst.CHART_TYPE_BUBBLE).addDataRatiosForCoordinateType(limitMap);
    },

    /**
     * Add start value to all series item.
     * @param {{min: number, max: number}} limit - limit
     * @param {string} chartType - chart type
     * @private
     */
    _addStartValueToAllSeriesItem: function(limit, chartType) {
        var start = 0;

        if (limit.min >= 0) {
            start = limit.min;
        } else if (limit.max <= 0) {
            start = limit.max;
        }

        this.getSeriesDataModel(chartType).addStartValueToAllSeriesItem(start);
    },

    /**
     * Register percent values.
     * @param {{min: number, max: number}} limit axis limit
     * @param {string} stacked stacked option
     * @param {string} chartType chart type
     * @private
     */
    addDataRatios: function(limit, stacked, chartType) {
        var seriesDataModel = this.getSeriesDataModel(chartType);

        this._addStartValueToAllSeriesItem(limit, chartType);
        seriesDataModel.addDataRatios(limit, stacked);
    }
});

module.exports = DataProcessor;

},{"../const":20,"../dataModels/seriesDataModel":32,"../helpers/predicate":47,"../helpers/rawDataHandler":48,"../helpers/renderUtil":49,"./seriesGroup":33}],31:[function(require,module,exports){
/**
 * @fileoverview Data processor for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var DataProcessor = require('./dataProcessor'),
    renderUtil = require('../helpers/renderUtil');

/**
 * Raw series data.
 * @typedef {Array.<{code: string, name: ?string, data: number}>} rawSeriesData
 */

/**
 * Value map.
 * @typedef {{value: number, label: string, name: ?string}} valueMap
 */

var MapChartDataProcessor = tui.util.defineClass(DataProcessor, /** @lends MapChartDataProcessor.prototype */{
    /**
     * Data processor for map chart.
     * @constructs MapChartDataProcessor
     * @extends DataProcessor
     */
    init: function() {
        DataProcessor.apply(this, arguments);
    },

    /**
     * Update raw data.
     * @param {{series: rawSeriesData}} rawData raw data
     */
    initData: function(rawData) {
        this.rawData = rawData;

        /**
         * value map
         * @type {valueMap}
         */
        this.valueMap = null;
    },

    /**
     * Make value map.
     * @returns {valueMap} value map
     * @private
     */
    _makeValueMap: function() {
        var rawSeriesData = this.rawData.series,
            valueMap = {},
            formatFunctions = this._findFormatFunctions();

        tui.util.forEachArray(rawSeriesData, function(datum) {
            var result = {
                value: datum.data,
                label: renderUtil.formatValue(datum.data, formatFunctions, 'series')
            };

            if (datum.name) {
                result.name = datum.name;
            }

            if (datum.labelCoordinate) {
                result.labelCoordinate = datum.labelCoordinate;
            }

            valueMap[datum.code] = result;
        });

        return valueMap;
    },

    /**
     * Get value map.
     * @returns {number} value
     */
    getValueMap: function() {
        if (!this.valueMap) {
            this.valueMap = this._makeValueMap();
        }
        return this.valueMap;
    },

    /**
     * Get values.
     * @returns {Array.<number>} picked values.
     */
    getValues: function() {
        return tui.util.pluck(this.getValueMap(), 'value');
    },

    /**
     * Get valueMap datum.
     * @param {string} code map code
     * @returns {{code: string, name: string, label: number,
     *              labelCoordinate: {x: number, y: number}}} valueMap datum
     */
    getValueMapDatum: function(code) {
        return this.getValueMap()[code];
    },

    /**
     * Add data ratios of map chart.
     * @param {{min: number, max: number}} limit axis limit
     */
    addDataRatios: function(limit) {
        var min = limit.min,
            max = limit.max - min;
        tui.util.forEach(this.getValueMap(), function(map) {
            map.ratio = (map.value - min) / max;
        });
    }
});

module.exports = MapChartDataProcessor;

},{"../helpers/renderUtil":49,"./dataProcessor":30}],32:[function(require,module,exports){
/**
 * @fileoverview SeriesDataModel is base model for drawing graph of chart series area,
 *                  and create from rawSeriesData by user,
 * SeriesDataModel.groups has SeriesGroups.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * Raw series datum.
 * @typedef {{name: ?string, data: Array.<number>, stack: ?string}} rawSeriesDatum
 */

/**
 * Raw series data.
 * @typedef {Array.<rawSeriesDatum>} rawSeriesData
 */

/**
 * Groups.
 * @typedef {Array.<SeriesGroup>} groups
 */

/**
 * SeriesGroup is a element of SeriesDataModel.groups.
 * SeriesGroup.items has SeriesItem.
 */

/**
 * SeriesItem is a element of SeriesGroup.items.
 * SeriesItem has processed terminal data like value, ratio, etc.
 */

var SeriesGroup = require('./seriesGroup'),
    SeriesItem = require('./seriesItem'),
    SeriesItemForCoordinateType = require('./seriesItemForCoordinateType'),
    predicate = require('../helpers/predicate'),
    calculator = require('../helpers/calculator');

var concat = Array.prototype.concat;

var SeriesDataModel = tui.util.defineClass(/** @lends SeriesDataModel.prototype */{
    /**
     * SeriesDataModel is base model for drawing graph of chart series area,
     *      and create from rawSeriesData by user.
     * SeriesDataModel.groups has SeriesGroups.
     * @constructs SeriesDataModel
     * @param {rawSeriesData} rawSeriesData raw series data
     * @param {string} chartType chart type
     * @param {object} options options
     * @param {Array.<function>} formatFunctions format functions
     */
    init: function(rawSeriesData, chartType, options, formatFunctions) {
        /**
         * chart type
         * @type {string}
         */
        this.chartType = chartType;

        /**
         * chart options
         * @type {Object}
         */
        this.options = options || {};

        /**
         * functions for formatting
         * @type {Array.<function>}
         */
        this.formatFunctions = formatFunctions;

        /**
         * rawData.series
         * @type {rawSeriesData}
         */
        this.rawSeriesData = rawSeriesData || [];

        /**
         * baseGroups is base data for making SeriesGroups.
         * SeriesGroups is made by pivoted baseGroups, lf line type chart.
         * @type {Array.Array<SeriesItem>}
         */
        this.baseGroups = null;

        /**
         * groups has SeriesGroups.
         * @type {Array.<SeriesGroup>}
         */
        this.groups = null;

        /**
         * map of values by value type like value, x, y, r.
         * @type {object.<string, Array.<number>>}
         */
        this.valuesMap = {};

        this._removeRangeValue();
    },

    /**
     * Remove range value of item, if has stacked option.
     * @private
     */
    _removeRangeValue: function() {
        var seriesOption = tui.util.pick(this.options, 'series') || {};

        if (predicate.isAllowRangeData(this.chartType) &&
            !predicate.isValidStackedOption(seriesOption.stacked) && !seriesOption.spline) {
            return;
        }

        tui.util.forEachArray(this.rawSeriesData, function(rawItem) {
            if (!tui.util.isArray(rawItem.data)) {
                return;
            }
            tui.util.forEachArray(rawItem.data, function(value, index) {
                rawItem.data[index] = concat.apply(value)[0];
            });
        });
    },

    /**
     * Create base groups.
     * Base groups is two-dimensional array by seriesItems.
     * @returns {Array.<Array.<(SeriesItem | SeriesItemForCoordinateType)>>}
     * @private
     */
    _createBaseGroups: function() {
        var self = this;
        var SeriesItemClass;

        if (predicate.isBubbleChart(this.chartType)) {
            SeriesItemClass = SeriesItemForCoordinateType;
        } else {
            SeriesItemClass = SeriesItem;
        }

        return tui.util.map(this.rawSeriesData, function(rawDatum) {
            return tui.util.map(concat.apply(rawDatum.data), function(value) {
                return new SeriesItemClass(value, rawDatum.stack, self.formatFunctions);
            });
        });
    },

    /**
     * Get base groups.
     * @returns {Array.Array.<SeriesItem>}
     */
    getBaseGroups: function() {
        if (!this.baseGroups) {
            this.baseGroups = this._createBaseGroups();
        }

        return this.baseGroups;
    },

    /**
     * Create SeriesGroups from rawData.series.
     * @param {boolean} isPivot - whether pivot or not.
     * @returns {Array.<SeriesGroup>}
     * @private
     */
    _createSeriesGroupsFromRawData: function(isPivot) {
        var baseGroups = this.getBaseGroups();

        if (isPivot) {
            baseGroups = tui.util.pivot(baseGroups);
        }

        return tui.util.map(baseGroups, function(items) {
            return new SeriesGroup(items);
        });
    },

    /**
     * Get SeriesGroups.
     * @returns {(Array.<SeriesGroup>|object)}
     * @private
     */
    _getSeriesGroups: function() {
        if (!this.groups) {
            this.groups = this._createSeriesGroupsFromRawData(true);
        }

        return this.groups;
    },

    /**
     * Get group count.
     * @returns {Number}
     */
    getGroupCount: function() {
        return this._getSeriesGroups().length;
    },

    /**
     * Get pivot groups.
     * @returns {(Array.<SeriesGroup>|object)}
     */
    _getPivotGroups: function() {
        if (!this.pivotGroups) {
            this.pivotGroups = this._createSeriesGroupsFromRawData();
        }

        return this.pivotGroups;
    },

    /**
     * Get SeriesGroup.
     * @param {number} index - index
     * @returns {SeriesGroup}
     */
    getSeriesGroup: function(index) {
        return this._getSeriesGroups()[index];
    },

    /**
     * Get first SeriesGroup.
     * @returns {SeriesGroup}
     */
    getFirstSeriesGroup: function() {
        return this.getSeriesGroup(0);
    },

    /**
     * Get first label of SeriesItem.
     * @returns {string} formatted value
     */
    getFirstItemLabel: function() {
        return this.getFirstSeriesGroup().getFirstSeriesItem().label;
    },

    /**
     * Get series item.
     * @param {number} groupIndex - index of series groups
     * @param {number} index - index of series items
     * @returns {SeriesItem}
     */
    getSeriesItem: function(groupIndex, index) {
        return this.getSeriesGroup(groupIndex).getSeriesItem(index);
    },

    /**
     * Get first series item.
     * @returns {SeriesItem}
     */
    getFirstSeriesItem: function() {
        return this.getSeriesItem(0, 0);
    },

    /**
     * Get value.
     * @param {number} groupIndex - index of series groups
     * @param {number} index - index of series items
     * @returns {number} value
     */
    getValue: function(groupIndex, index) {
        return this.getSeriesItem(groupIndex, index).value;
    },

    /**
     * Get minimum value.
     * @param {string} valueType - value type like value, x, y, r.
     * @returns {number}
     */
    getMinValue: function(valueType) {
        return tui.util.min(this.getValues(valueType));
    },

    /**
     * Get maximum value.
     * @param {string} valueType - value type like value, x, y, r.
     * @returns {number}
     */
    getMaxValue: function(valueType) {
        return tui.util.max(this.getValues(valueType));
    },

    /**
     * Traverse seriesGroups, and returns to found SeriesItem by result of execution seriesGroup.find with condition.
     * @param {function} condition - condition function
     * @returns {SeriesItem}
     * @private
     */
    _findSeriesItem: function(condition) {
        var foundItem;

        this.each(function(seriesGroup) {
            foundItem = seriesGroup.find(condition);

            return !foundItem;
        });

        return foundItem;
    },

    /**
     * Find SeriesItem by value.
     * @param {string} valueType - value type like value, x, y, r.
     * @param {number} value - comparing value
     * @param {function} condition - condition function
     * @returns {SeriesItem}
     * @private
     */
    _findSeriesItemByValue: function(valueType, value, condition) {
        condition = condition || function() {
            return;
        };

        return this._findSeriesItem(function(seriesItem) {
            return seriesItem && (seriesItem[valueType] === value) && condition(seriesItem);
        });
    },

    /**
     * Find minimum SeriesItem.
     * @param {string} valueType - value type like value, x, y, r.
     * @param {function} condition - condition function
     * @returns {SeriesItem}
     */
    findMinSeriesItem: function(valueType, condition) {
        var minValue = this.getMinValue(valueType);

        return this._findSeriesItemByValue(valueType, minValue, condition);
    },

    /**
     * Find maximum SeriesItem.
     * @param {string} valueType - value type like value, x, y, r.
     * @param {function} condition - condition function
     * @returns {*|SeriesItem}
     */
    findMaxSeriesItem: function(valueType, condition) {
        var maxValue = this.getMaxValue(valueType);

        return this._findSeriesItemByValue(valueType, maxValue, condition);
    },

    /**
     * Create values that picked value from SeriesItems of SeriesGroups.
     * @param {?string} valueType - type of value
     * @returns {Array.<number>}
     * @private
     */
    _createValues: function(valueType) {
        var values = this.map(function(seriesGroup) {
            return seriesGroup.getValues(valueType);
        });

        return concat.apply([], values);
    },

    /**
     * Get values form valuesMap.
     * @param {?string} valueType - type of value
     * @returns {Array.<number>}
     */
    getValues: function(valueType) {
        valueType = valueType || 'value';

        if (!this.valuesMap[valueType]) {
            this.valuesMap[valueType] = this._createValues(valueType);
        }

        return this.valuesMap[valueType];
    },

    /**
     * Whether count of x values greater than count of y values.
     * @returns {boolean}
     */
    isXCountGreaterThanYCount: function() {
        return this.getValues('x').length > this.getValues('y').length;
    },

    /**
     * Add ratios, when has normal stacked option.
     * @param {{min: number, max: number}} limit - axis limit
     * @private
     */
    _addRatiosWhenNormalStacked: function(limit) {
        var distance = Math.abs(limit.max - limit.min);

        this.each(function(seriesGroup) {
            seriesGroup.addRatios(distance);
        });
    },

    /**
     * Calculate base ratio for calculating ratio of item.
     * @returns {number}
     * @private
     */
    _calculateBaseRatio: function() {
        var values = this.getValues(),
            plusSum = calculator.sumPlusValues(values),
            minusSum = Math.abs(calculator.sumMinusValues(values)),
            ratio = (plusSum > 0 && minusSum > 0) ? 0.5 : 1;

        return ratio;
    },

    /**
     * Add ratios, when has percent stacked option.
     * @private
     */
    _addRatiosWhenPercentStacked: function() {
        var baseRatio = this._calculateBaseRatio();

        this.each(function(seriesGroup) {
            seriesGroup.addRatiosWhenPercentStacked(baseRatio);
        });
    },

    /**
     * Add ratios, when has diverging stacked option.
     * @private
     */
    _addRatiosWhenDivergingStacked: function() {
        this.each(function(seriesGroup) {
            var values = seriesGroup.pluck('value'),
                plusSum = calculator.sumPlusValues(values),
                minusSum = Math.abs(calculator.sumMinusValues(values));

            seriesGroup.addRatiosWhenDivergingStacked(plusSum, minusSum);
        });
    },

    /**
     * Make subtraction value for making ratio of no option chart.
     * @param {{min: number, max: number}} limit - limit
     * @returns {number}
     * @private
     */
    _makeSubtractionValue: function(limit) {
        var allowMinusPointRender = predicate.allowMinusPointRender(this.chartType),
            subValue = 0;

        if (!allowMinusPointRender && predicate.isMinusLimit(limit)) {
            subValue = limit.max;
        } else if (allowMinusPointRender || limit.min >= 0) {
            subValue = limit.min;
        }

        return subValue;
    },

    /**
     * Add ratios, when has not option.
     * @param {{min: number, max: number}} limit - axis limit
     * @private
     */
    _addRatios: function(limit) {
        var distance = Math.abs(limit.max - limit.min),
            subValue = this._makeSubtractionValue(limit);

        this.each(function(seriesGroup) {
            seriesGroup.addRatios(distance, subValue);
        });
    },

    /**
     * Add data ratios.
     * @param {{min: number, max: number}} limit - axis limit
     * @param {string} stacked - stacked option
     * @private
     */
    addDataRatios: function(limit, stacked) {
        var isAllowedStackedOption = predicate.isAllowedStackedOption(this.chartType);

        if (isAllowedStackedOption && predicate.isNormalStacked(stacked)) {
            this._addRatiosWhenNormalStacked(limit);
        } else if (isAllowedStackedOption && predicate.isPercentStacked(stacked)) {
            if (this.divergingOption) {
                this._addRatiosWhenDivergingStacked();
            } else {
                this._addRatiosWhenPercentStacked();
            }
        } else {
            this._addRatios(limit);
        }
    },

    /**
     * Add data ratios of pie chart.
     */
    addDataRatiosOfPieChart: function() {
        this.each(function(seriesGroup) {
            var sum = tui.util.sum(seriesGroup.pluck('value'));

            seriesGroup.addRatios(sum);
        });
    },

    /**
     * Add ratios of data for chart of coordinate type.
     * @param {{x: {min: number, max: number}, y: {min: number, max: number}}} limitMap - limit map
     */
    addDataRatiosForCoordinateType: function(limitMap) {
        var xLimit = limitMap.x;
        var yLimit = limitMap.y;
        var maxRadius = tui.util.max(this.getValues('r'));
        var xDistance, xSubValue, yDistance, ySubValue;

        if (xLimit) {
            xDistance = Math.abs(xLimit.max - xLimit.min);
            xSubValue = this._makeSubtractionValue(xLimit);
        }

        if (yLimit) {
            yDistance = Math.abs(yLimit.max - yLimit.min);
            ySubValue = this._makeSubtractionValue(yLimit);
        }

        this.each(function(seriesGroup) {
            seriesGroup.each(function(item) {
                if (!item) {
                    return;
                }
                item.addRatio('x', xDistance, xSubValue);
                item.addRatio('y', yDistance, ySubValue);
                item.addRatio('r', maxRadius, 0);
            });
        });
    },

    /**
     * Add start to all series item.
     * @param {number} start - start value
     */
    addStartValueToAllSeriesItem: function(start) {
        this.each(function(seriesGroup) {
            seriesGroup.addStartValueToAllSeriesItem(start);
        });
    },

    /**
     * Whether has range data or not.
     * @returns {boolean}
     */
    hasRangeData: function() {
        var hasRangeData = false;

        this.each(function(seriesGroup) {
            hasRangeData = seriesGroup.hasRangeData();
            return !hasRangeData;
        });

        return hasRangeData;
    },

    /**
     * Traverse groups, and executes iteratee function.
     * @param {function} iteratee - iteratee function
     * @param {boolean} isPivot - whether pivot or not
     */
    each: function(iteratee, isPivot) {
        var groups = isPivot ? this._getPivotGroups() : this._getSeriesGroups();

        tui.util.forEachArray(groups, function(seriesGroup, index) {
            return iteratee(seriesGroup, index);
        });
    },

    /**
     * Traverse groups, and returns to result of execution about iteratee function.
     * @param {function} iteratee - iteratee function
     * @param {boolean} isPivot - whether pivot or not
     * @returns {Array}
     */
    map: function(iteratee, isPivot) {
        var results = [];

        this.each(function(seriesGroup, index) {
            results.push(iteratee(seriesGroup, index));
        }, isPivot);

        return results;
    }
});

module.exports = SeriesDataModel;

},{"../helpers/calculator":43,"../helpers/predicate":47,"./seriesGroup":33,"./seriesItem":34,"./seriesItemForCoordinateType":35}],33:[function(require,module,exports){
/**
 * @fileoverview SeriesGroup is a element of SeriesDataModel.groups.
 * SeriesGroup.items has SeriesItem.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * SeriesItem is a element of SeriesGroup.items.
 * SeriesItem has processed terminal data like value, ratio, etc.
 */

var SeriesGroup = tui.util.defineClass(/** @lends SeriesGroup.prototype */{
    /**
     * SeriesGroup is a element of SeriesDataModel.groups.
     * SeriesGroup.items has SeriesItem.
     * @constructs SeriesGroup
     * @param {Array.<SeriesItem>} seriesItems - series items
     */
    init: function(seriesItems) {
        /**
         * items has SeriesItem
         * @type {Array.<SeriesItem>}
         */
        this.items = seriesItems;

        /**
         * map of values by value type like value, x, y, r.
         * @type {Array.<number>}
         */
        this.valuesMap = {};

        this.valuesMapPerStack = null;
    },

    /**
     * Get series item count.
     * @returns {number}
     */
    getSeriesItemCount: function() {
        return this.items.length;
    },

    /**
     * Get series item.
     * @param {number} index - index of items
     * @returns {SeriesItem}
     */
    getSeriesItem: function(index) {
        return this.items[index];
    },

    /**
     * Get first SeriesItem.
     * @returns {SeriesItem}
     */
    getFirstSeriesItem: function() {
        return this.getSeriesItem(0);
    },

    /**
     * Create values that picked value from SeriesItems.
     * @param {?string} valueType - type of value
     * @returns {Array.<number>}
     * @private
     */
    _createValues: function(valueType) {
        var values = [];

        this.each(function(item) {
            if (!item) {
                return;
            }

            if (tui.util.isExisty(item[valueType])) {
                values.push(item[valueType]);
            }
            if (tui.util.isExisty(item.start)) {
                values.push(item.start);
            }
        });

        return values;
    },

    /**
     * Get values from valuesMap.
     * @param {?string} valueType - type of value
     * @returns {Array}
     */
    getValues: function(valueType) {
        valueType = valueType || 'value';

        if (!this.valuesMap[valueType]) {
            this.valuesMap[valueType] = this._createValues(valueType);
        }

        return this.valuesMap[valueType];
    },

    /**
     * Make values map per stack.
     * @returns {object}
     * @private
     */
    _makeValuesMapPerStack: function() {
        var valuesMap = {};

        this.each(function(item) {
            if (!valuesMap[item.stack]) {
                valuesMap[item.stack] = [];
            }
            valuesMap[item.stack].push(item.value);
        });

        return valuesMap;
    },

    /**
     * Get values map per stack.
     * @returns {*|Object}
     */
    getValuesMapPerStack: function() {
        if (!this.valuesMapPerStack) {
            this.valuesMapPerStack = this._makeValuesMapPerStack();
        }

        return this.valuesMapPerStack;
    },

    /**
     * Make sum map per stack.
     * @returns {object} sum map
     * @private
     */
    _makeSumMapPerStack: function() {
        var valuesMap = this.getValuesMapPerStack(),
            sumMap = {};

        tui.util.forEach(valuesMap, function(values, key) {
            sumMap[key] = tui.util.sum(tui.util.map(values, function(value) {
                return Math.abs(value);
            }));
        });

        return sumMap;
    },

    /**
     * Add start value to all series item.
     * @param {number} start start value
     */
    addStartValueToAllSeriesItem: function(start) {
        this.each(function(item) {
            item.addStart(start);
        });
    },

    /**
     * Add ratios when percent stacked.
     * @param {number} baseRatio - base ratio
     */
    addRatiosWhenPercentStacked: function(baseRatio) {
        var sumMap = this._makeSumMapPerStack();

        this.each(function(item) {
            var dividingNumber = sumMap[item.stack];

            item.addRatio(dividingNumber, 0, baseRatio);
        });
    },

    /**
     * Add ratios when diverging stacked.
     * @param {number} plusSum - sum of plus number
     * @param {number} minusSum - sum of minus number
     */
    addRatiosWhenDivergingStacked: function(plusSum, minusSum) {
        this.each(function(item) {
            var dividingNumber = (item.value >= 0) ? plusSum : minusSum;

            item.addRatio(dividingNumber, 0, 0.5);
        });
    },

    /**
     * Add ratios.
     * @param {number} divNumber dividing number
     * @param {number} subValue subtraction value
     */
    addRatios: function(divNumber, subValue) {
        this.each(function(item) {
            item.addRatio(divNumber, subValue);
        });
    },

    /**
     * Whether has range data or not.
     * @returns {boolean}
     */
    hasRangeData: function() {
        var hasRangeData = false;

        this.each(function(seriesItem) {
            hasRangeData = seriesItem.isRange;
            return !hasRangeData;
        });

        return hasRangeData;
    },

    /**
     * Traverse items, and executes iteratee function.
     * @param {function} iteratee - iteratee function
     */
    each: function(iteratee) {
        tui.util.forEachArray(this.items, iteratee);
    },

    /**
     * Traverse items, and returns to results of execution about iteratee function.
     * @param {function} iteratee - iteratee function
     * @returns {Array}
     */
    map: function(iteratee) {
        return tui.util.map(this.items, iteratee);
    },

    /**
     * Traverse items and returns to picked result at item.
     * @param {string} key key for pick
     * @returns {Array}
     */
    pluck: function(key) {
        return tui.util.pluck(this.items, key);
    },

    /**
     * Traverse items, and returns to found SeriesItem by condition function.
     * @param {function} condition - condition function
     * @returns {SeriesItem|null}
     */
    find: function(condition) {
        var foundItem;

        this.each(function(seriesItem) {
            if (condition(seriesItem)) {
                foundItem = seriesItem;
            }
            return !foundItem;
        });

        return foundItem || null;
    }
});

module.exports = SeriesGroup;

},{}],34:[function(require,module,exports){
/**
 * @fileoverview SeriesItem is a element of SeriesGroup.items.
 * SeriesItem has processed terminal data like value, ratio, etc.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    renderUtil = require('../helpers/renderUtil');

var SeriesItem = tui.util.defineClass(/** @lends SeriesItem.prototype */{
    /**
     * SeriesItem is a element of SeriesGroup.items.
     * SeriesItem has processed terminal data like value, ratio, etc.
     * @constructs SeriesItem
     * @param {number} value - value
     * @param {?string} stack - stack
     * @param {?Array.<function>} formatFunctions - format functions
     */
    init: function(value, stack, formatFunctions) {
        /**
         * for group stack option.
         * @type {string}
         */
        this.stack = stack || chartConst.DEFAULT_STACK;

        /**
         * format functions
         * @type {Array.<function>}
         */
        this.formatFunctions = formatFunctions;

        /**
         * whether range item or not
         * @type {boolean}
         */
        this.isRange = false;

        /**
         * value of item
         * @type {number}
         */
        this.value = null;

        /**
         * label
         * @type {string}
         */
        this.label = null;

        /**
         * ratio of value about distance of limit
         * @type {number}
         */
        this.ratio = null;

        /**
         * end value of item.
         * @type {number}
         */
        this.end = null;

        /**
         * end label
         * @type {number}
         */
        this.endLabel = null;

        /**
         * ratio of end value
         * @type {number}
         */
        this.endRatio = null;

        /**
         * start value of item.
         * @type {number}
         */
        this.start = null;

        /**
         * start label
         * @type {number}
         */
        this.startLabel = null;

        /**
         * ratio of start value
         * @type {number}
         */
        this.startRatio = null;

        /**
         * distance of start ratio and end ratio
         * @type {null}
         */
        this.ratioDistance = null;

        this._initValues(value);
    },

    /**
     * Initialize values of item.
     * @param {number} value - value
     * @private
     */
    _initValues: function(value) {
        var values = this._createValues(value),
            hasStart = values.length > 1;

        this.value = this.end = values[0];
        this.label = this.endLabel = renderUtil.formatValue(this.value, this.formatFunctions, 'series');

        if (hasStart) {
            this.addStart(values[1], true);
            this._updateFormattedValueforRange();
            this.isRange = true;
        }
    },

    /**
     * Crete sorted values.
     * @param {Array.<number>|number} value value
     * @returns {Array.<number>}
     * @private
     */
    _createValues: function(value) {
        var values = tui.util.map([].concat(value), parseFloat);

        values = values.sort(function(a, b) {
            if (a < 0 && b < 0) {
                return a - b;
            }

            return b - a;
        });

        return values;
    },

    /**
     * Add start.
     * @param {number} value - value
     * @private
     */
    addStart: function(value) {
        if (!tui.util.isNull(this.start)) {
            return;
        }

        this.start = value;
        this.startLabel = renderUtil.formatValue(value, this.formatFunctions, 'series');
    },

    /**
     * Update formatted value for range.
     * @private
     */
    _updateFormattedValueforRange: function() {
        this.label = this.startLabel + ' ~ ' + this.endLabel;
    },

    /**
     * Calculate ratio for making bound.
     * @param {number} value - value
     * @param {number} divNumber - number for division
     * @param {number} subNumber - number for subtraction
     * @param {number} baseRatio - base ratio
     * @returns {number}
     * @private
     */
    _calculateRatio: function(value, divNumber, subNumber, baseRatio) {
        return ((value - subNumber) / divNumber) * baseRatio;
    },

    /**
     * Add ratio.
     * @param {number} divNumber - number for division
     * @param {?number} subNumber - number for subtraction
     * @param {?number} baseRatio - base ratio
     */
    addRatio: function(divNumber, subNumber, baseRatio) {
        divNumber = divNumber || 1;
        baseRatio = baseRatio || 1;
        subNumber = subNumber || 0;

        this.ratio = this.endRatio = this._calculateRatio(this.value, divNumber, subNumber, baseRatio);

        if (!tui.util.isNull(this.start)) {
            this.startRatio = this._calculateRatio(this.start, divNumber, subNumber, baseRatio);
            this.ratioDistance = Math.abs(this.endRatio - this.startRatio);
        }
    },

    /**
     * Pick value map.
     * @returns {{value: number, start: ?number, end: ?number}}
     */
    pickValueMap: function() {
        return {
            value: this.value,
            start: this.start,
            end: this.end
        };
    }
});

module.exports = SeriesItem;

},{"../const":20,"../helpers/renderUtil":49}],35:[function(require,module,exports){
/**
 * @fileoverview SeriesItemForCoordinateType is a element of SeriesGroup.items.
 * SeriesItemForCoordinateType has processed terminal data like x, y, r, xRatio, yRatio, rRatio.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var SeriesItemForCoordinateType = tui.util.defineClass(/** @lends SeriesItemForCoordinateType.prototype */{
    /**
     * SeriesItemForCoordinateType is a element of SeriesGroup.items.
     * SeriesItemForCoordinateType has processed terminal data like x, y, r, xRatio, yRatio, rRatio.
     * @constructs SeriesItemForCoordinateType
     * @param {object} rawSeriesDatum - value
     */
    init: function(rawSeriesDatum) {
        this._initData(rawSeriesDatum);
    },

    /**
     * Initialize data of item.
     * @param {{x: ?number, y: ?number, r: ?number, label: ?string}} rawSeriesDatum - rawSeriesDatum for bubble chart
     * @private
     */
    _initData: function(rawSeriesDatum) {
        this.x = rawSeriesDatum.x;
        this.y = rawSeriesDatum.y;
        this.r = rawSeriesDatum.r;
        this.label = rawSeriesDatum.label || '';

        this.ratioMap = {};
    },

    /**
     * Add ratio.
     * @param {string} valueType - type of value like x, y, r
     * @param {?number} divNumber - number for division
     * @param {?number} subNumber - number for subtraction
     */
    addRatio: function(valueType, divNumber, subNumber) {
        if (!tui.util.isExisty(this.ratioMap[valueType]) && divNumber) {
            this.ratioMap[valueType] = (this[valueType] - subNumber) / divNumber;
        }
    },

    /**
     * Pick value map.
     * @returns {{x: (number | null), y: (number | null), r: (number | null)}}
     */
    pickValueMap: function() {
        return {
            x: this.ratioMap.x ? this.x : null,
            y: this.ratioMap.y ? this.y : null,
            r: this.ratioMap.r ? this.r : null
        };
    }
});

module.exports = SeriesItemForCoordinateType;

},{}],36:[function(require,module,exports){
/**
 * @fileoverview  Chart factory play role register chart.
 *                Also, you can get chart from this factory.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var charts = {},
    factory = {
        /**
         * Get chart instance.
         * @param {string} chartType chart type
         * @param {object} data chart data
         * @param {object} theme chart options
         * @param {object} options chart options
         * @returns {object} chart instance;
         */
        get: function(chartType, data, theme, options) {
            var Chart = charts[chartType],
                chart;

            if (!Chart) {
                throw new Error('Not exist ' + chartType + ' chart.');
            }

            chart = new Chart(data, theme, options);

            return chart;
        },

        /**
         * Register chart.
         * @param {string} chartType char type
         * @param {class} ChartClass chart class
         */
        register: function(chartType, ChartClass) {
            charts[chartType] = ChartClass;
        }
    };

module.exports = factory;

},{}],37:[function(require,module,exports){
/**
 * @fileoverview  Map factory.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var maps = {};

module.exports = {
    /**
     * Get map data.
     * @param {string} mapName map name
     * @returns {Array} map data
     */
    get: function(mapName) {
        var data = maps[mapName];

        if (!data) {
            throw new Error('Not exist ' + mapName + ' map.');
        }

        return data;
    },

    /**
     * Register Map.
     * @param {string} mapName map name
     * @param {Array} data map data
     */
    register: function(mapName, data) {
        maps[mapName] = data;
    }
};

},{}],38:[function(require,module,exports){
/**
 * @fileoverview  Plugin factory play role register rendering plugin.
 *                Also, you can get plugin from this factory.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var plugins = {},
    factory = {
        /**
         * Get graph renderer.
         * @param {string} libType type of graph library
         * @param {string} chartType chart type
         * @returns {object} renderer instance
         */
        get: function(libType, chartType) {
            var plugin = plugins[libType],
                Renderer, renderer;

            if (!plugin) {
                throw new Error('Not exist ' + libType + ' plugin.');
            }

            Renderer = plugin[chartType];
            if (!Renderer) {
                throw new Error('Not exist ' + chartType + ' chart renderer.');
            }

            renderer = new Renderer();

            return renderer;
        },
        /**
         * Plugin register.
         * @param {string} libType type of graph library
         * @param {object} plugin plugin to control library
         */
        register: function(libType, plugin) {
            plugins[libType] = plugin;
        }
    };

module.exports = factory;

},{}],39:[function(require,module,exports){
/**
 * @fileoverview  Theme factory play role register theme.
 *                Also, you can get theme from this factory.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    defaultTheme = require('../themes/defaultTheme');

var themes = {};

module.exports = {
    /**
     * Get theme.
     * @param {string} themeName theme name
     * @returns {object} theme object
     */
    get: function(themeName) {
        var theme = themes[themeName];

        if (!theme) {
            throw new Error('Not exist ' + themeName + ' theme.');
        }

        return theme;
    },

    /**
     * Theme register.
     * @param {string} themeName theme name
     * @param {object} theme theme
     */
    register: function(themeName, theme) {
        var targetItems;
        theme = JSON.parse(JSON.stringify(theme));

        if (themeName !== chartConst.DEFAULT_THEME_NAME) {
            theme = this._initTheme(theme);
        }

        targetItems = this._getInheritTargetThemeItems(theme);

        this._inheritThemeFont(theme, targetItems);
        this._copyColorInfo(theme);
        themes[themeName] = theme;
    },

    /**
     * Init theme.
     * @param {object} theme theme
     * @returns {object} theme
     * @private
     * @ignore
     */
    _initTheme: function(theme) {
        var cloneTheme = JSON.parse(JSON.stringify(defaultTheme)),
            newTheme;

        this._concatDefaultColors(theme, cloneTheme.series.colors);
        newTheme = this._overwriteTheme(theme, cloneTheme);

        newTheme = this._copyProperty({
            propName: 'yAxis',
            fromTheme: theme,
            toTheme: newTheme,
            rejectionProps: chartConst.YAXIS_PROPS
        });

        newTheme = this._copyProperty({
            propName: 'series',
            fromTheme: theme,
            toTheme: newTheme,
            rejectionProps: chartConst.SERIES_PROPS
        });

        return newTheme;
    },

    /**
     * Filter chart types.
     * @param {object} target target charts
     * @param {Array.<string>} rejectionProps reject property
     * @returns {Object} filtered charts.
     * @private
     */
    _filterChartTypes: function(target, rejectionProps) {
        var result;
        if (!target) {
            return [];
        }

        result = tui.util.filter(target, function(item, name) {
            return tui.util.inArray(name, rejectionProps) === -1;
        });
        return result;
    },

    /**
     * Concat colors.
     * @param {object} theme theme
     * @param {Array.<string>} seriesColors series colors
     * @private
     */
    _concatColors: function(theme, seriesColors) {
        if (theme.colors) {
            theme.colors = theme.colors.concat(seriesColors);
        }

        if (theme.singleColors) {
            theme.singleColors = theme.singleColors.concat(seriesColors);
        }
    },

    /**
     * Concat default colors.
     * @param {object} theme theme
     * @param {Array.<string>} seriesColors series colors
     * @private
     */
    _concatDefaultColors: function(theme, seriesColors) {
        var self = this,
            chartTypes;

        if (!theme.series) {
            return;
        }

        chartTypes = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);

        if (!tui.util.keys(chartTypes).length) {
            this._concatColors(theme.series, seriesColors);
        } else {
            tui.util.forEach(chartTypes, function(item) {
                self._concatColors(item, seriesColors);
            });
        }
    },

    /**
     * Overwrite theme
     * @param {object} from from theme property
     * @param {object} to to theme property
     * @returns {object} result property
     * @private
     */
    _overwriteTheme: function(from, to) {
        var self = this;

        tui.util.forEach(to, function(item, key) {
            var fromItem = from[key];
            if (!fromItem) {
                return;
            }

            if (tui.util.isArray(fromItem)) {
                to[key] = fromItem.slice();
            } else if (tui.util.isObject(fromItem)) {
                self._overwriteTheme(fromItem, item);
            } else {
                to[key] = fromItem;
            }
        });

        return to;
    },

    /**
     * Copy property.
     * @param {object} params parameters
     *      @param {string} params.propName property name
     *      @param {object} params.fromTheme from property
     *      @param {object} params.toTheme tp property
     *      @param {Array.<string>} params.rejectionProps reject property name
     * @returns {object} copied property
     * @private
     */
    _copyProperty: function(params) {
        var self = this,
            chartTypes;

        if (!params.toTheme[params.propName]) {
            return params.toTheme;
        }

        chartTypes = this._filterChartTypes(params.fromTheme[params.propName], params.rejectionProps);
        if (tui.util.keys(chartTypes).length) {
            tui.util.forEach(chartTypes, function(item, key) {
                var cloneTheme = JSON.parse(JSON.stringify(defaultTheme[params.propName]));
                params.fromTheme[params.propName][key] = self._overwriteTheme(item, cloneTheme);
            });

            params.toTheme[params.propName] = params.fromTheme[params.propName];
        }

        return params.toTheme;
    },

    /**
     * Copy color info to legend
     * @param {object} seriesTheme series theme
     * @param {object} legendTheme legend theme
     * @param {Array.<string>} colors colors
     * @private
     */
    _copyColorInfoToOther: function(seriesTheme, legendTheme, colors) {
        legendTheme.colors = colors || seriesTheme.colors;
        if (seriesTheme.singleColors) {
            legendTheme.singleColors = seriesTheme.singleColors;
        }
        if (seriesTheme.borderColor) {
            legendTheme.borderColor = seriesTheme.borderColor;
        }
        if (seriesTheme.selectionColor) {
            legendTheme.selectionColor = seriesTheme.selectionColor;
        }
    },

    /**
     * Get target items about font inherit.
     * @param {object} theme theme
     * @returns {Array.<object>} target items
     * @private
     */
    _getInheritTargetThemeItems: function(theme) {
        var items = [
                theme.title,
                theme.xAxis.title,
                theme.xAxis.label,
                theme.legend.label
            ],
            yAxisChartTypeThems = this._filterChartTypes(theme.yAxis, chartConst.YAXIS_PROPS),
            seriesChartTypeThemes = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);

        if (!tui.util.keys(yAxisChartTypeThems).length) {
            items.push(theme.yAxis.title);
            items.push(theme.yAxis.label);
        } else {
            tui.util.forEach(yAxisChartTypeThems, function(chatTypeTheme) {
                items.push(chatTypeTheme.title);
                items.push(chatTypeTheme.label);
            });
        }

        if (!tui.util.keys(seriesChartTypeThemes).length) {
            items.push(theme.series.label);
        } else {
            tui.util.forEach(seriesChartTypeThemes, function(chatTypeTheme) {
                items.push(chatTypeTheme.label);
            });
        }
        return items;
    },

    /**
     * Inherit theme font.
     * @param {object} theme theme
     * @param {Array.<object>} targetItems target theme items
     * @private
     */
    _inheritThemeFont: function(theme, targetItems) {
        var baseFont = theme.chart.fontFamily;

        tui.util.forEachArray(targetItems, function(item) {
            if (!item.fontFamily) {
                item.fontFamily = baseFont;
            }
        });
    },

    /**
     * Copy color info.
     * @param {object} theme theme
     * @private
     * @ignore
     */
    _copyColorInfo: function(theme) {
        var self = this,
            seriesChartTypes = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);

        if (!tui.util.keys(seriesChartTypes).length) {
            this._copyColorInfoToOther(theme.series, theme.legend);
            this._copyColorInfoToOther(theme.series, theme.tooltip);
        } else {
            tui.util.forEach(seriesChartTypes, function(item, chartType) {
                theme.legend[chartType] = {};
                theme.tooltip[chartType] = {};
                self._copyColorInfoToOther(item, theme.legend[chartType], item.colors || theme.legend.colors);
                self._copyColorInfoToOther(item, theme.tooltip[chartType], item.colors || theme.tooltip.colors);
                delete theme.legend.colors;
                delete theme.tooltip.colors;
            });
        }
    }
};

},{"../const":20,"../themes/defaultTheme":86}],40:[function(require,module,exports){
/**
 * @fileoverview Axis Data Maker
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

/**
 * Axis data maker.
 * @module axisDataMaker
 */
var axisDataMaker = {
    /**
     * Make labels.
     * @param {Array.<string>} labels labels
     * @param {number} labelInterval label interval
     * @returns {Array.<string>} labels
     * @private
     */
    _makeLabels: function(labels, labelInterval) {
        var lastIndex;
        if (!labelInterval) {
            return labels;
        }

        lastIndex = labels.length - 1;
        return tui.util.map(labels, function(label, index) {
            if (index > 0 && index < lastIndex && (index % labelInterval) > 0) {
                label = chartConst.EMPTY_AXIS_LABEL;
            }
            return label;
        });
    },

    /**
     * Make data about label axis.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {Array.<string>} params.labels chart labels
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {boolean} params.aligned whether align or not
     * @returns {{
     *      labels: Array.<string>,
     *      tickCount: number,
     *      validTickCount: number,
     *      isLabelAxis: boolean,
     *      isVertical: boolean
     * }} axis data
     */
    makeLabelAxisData: function(params) {
        var tickCount = params.labels.length,
            options = params.options || {},
            labels = this._makeLabels(params.labels, options.labelInterval);

        if (!params.aligned) {
            tickCount += 1;
        }

        return {
            labels: labels,
            tickCount: tickCount,
            validTickCount: 0,
            isLabelAxis: true,
            isVertical: !!params.isVertical,
            aligned: !!params.aligned
        };
    },

    /**
     * Make data about value axis.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {AxisScaleMaker} params.axisScaleMaker chart values
     *      @param {boolean} params.isVertical whether vertical or not
     * @returns {{
     *      labels: Array.<string>,
     *      tickCount: number,
     *      validTickCount: number,
     *      isLabelAxis: boolean,
     *      limit: {min: number, max: number},
     *      isVertical: boolean
     * }} axis data
     */
    makeValueAxisData: function(params) {
        var axisScaleMaker = params.axisScaleMaker,
            rangeValues = axisScaleMaker.getFormattedScaleValues(),
            tickCount = rangeValues.length;

        return {
            labels: rangeValues,
            tickCount: tickCount,
            validTickCount: tickCount,
            limit: axisScaleMaker.getLimit(),
            step: axisScaleMaker.getStep(),
            isVertical: !!params.isVertical,
            isPositionRight: !!params.isPositionRight,
            aligned: !!params.aligned
        };
    }
};

module.exports = axisDataMaker;

},{"../const":20}],41:[function(require,module,exports){
/**
 * @fileoverview Axis scale maker.
 * @auth NHN Ent.
 *       FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('./predicate'),
    calculator = require('./calculator'),
    renderUtil = require('./renderUtil');

var abs = Math.abs;

var AxisScaleMaker = tui.util.defineClass(/** @lends AxisScaleMaker.prototype */{
    /**
     * Axis scale.
     * @param {object} params parameters
     * @constructs AxisScaleMaker
     */
    init: function(params) {
        /**
         * Data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * Chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * type of value like value, x, y, r
         * @type {string}
         */
        this.valueType = params.valueType;

        /**
         * type of area like yAxis, xAxis
         * @type {string}
         */
        this.areaType = params.areaType;

        /**
         * Whether vertical type or not.
         * @type {boolean}
         */
        this.isVertical = !!params.isVertical;

        /**
         * Whether single yAxis or not.
         * @type {boolean}
         */
        this.isSingleYAxis = !!params.isSingleYAxis;
        /**
         * Count of scale values.
         * @type {number}
         */
        this.valueCounts = params.valueCount ? [params.valueCount] : null;

        /**
         * Axis scale
         * @type {{limit: {min: number, max: number}, step: number}}
         */
        this.scale = null;

        /**
         * Formatted scale values.
         * @type {Array.<string | number>}
         */
        this.formattedValues = null;
    },

    /**
     * Get scale.
     * @returns {{limit: {min: number, max: number}, step: number}}
     * @private
     */
    _getScale: function() {
        if (!this.scale) {
            this.scale = this._makeScale();
        }

        return this.scale;
    },

    /**
     * Get limit.
     * @returns {{min: number, max: number}}
     */
    getLimit: function() {
        return this._getScale().limit;
    },

    /**
     * Get step.
     * @returns {number}
     */
    getStep: function() {
        return this._getScale().step;
    },

    /**
     * Whether percent stacked chart or not.
     * @returns {boolean}
     * @private
     */
    _isPercentStackedChart: function() {
        var isAllowedStackedOption = predicate.isAllowedStackedOption(this.chartType),
            isPercentStacked = predicate.isPercentStacked(this.options.stacked);

        return isAllowedStackedOption && isPercentStacked;
    },

    /**
     * Whether normal stacked chart or not.
     * @returns {boolean}
     * @private
     */
    _isNormalStackedChart: function() {
        var isAllowedStackedOption = predicate.isAllowedStackedOption(this.chartType),
            isNormalStacked = predicate.isNormalStacked(this.options.stacked);

        return isAllowedStackedOption && isNormalStacked;
    },

    /**
     * Whether diverging chart or not.
     * @returns {boolean|*}
     * @private
     */
    _isDivergingChart: function() {
        return this.options.diverging && predicate.isBarTypeChart(this.chartType);
    },

    /**
     * Get functions for formatting value.
     * @returns {Array.<function>}
     * @private
     */
    _getFormatFunctions: function() {
        var formatFunctions;

        if (this._isPercentStackedChart()) {
            formatFunctions = [function(value) {
                return value + '%';
            }];
        } else {
            formatFunctions = this.dataProcessor.getFormatFunctions();
        }

        return formatFunctions;
    },

    /**
     * Get scale values.
     * @returns {Array.<number>}
     * @private
     */
    _getScaleValues: function() {
        var scale = this._getScale(),
            values = calculator.makeLabelsFromLimit(scale.limit, scale.step);

        return this._isDivergingChart() ? tui.util.map(values, abs) : values;
    },

    /**
     * Get formatted scale values.
     * @returns {Array.<string|number>|*}
     */
    getFormattedScaleValues: function() {
        var values, formatFunctions;

        if (!this.formattedValues) {
            values = this._getScaleValues();
            formatFunctions = this._getFormatFunctions();
            this.formattedValues = renderUtil.formatValues(values, formatFunctions, this.areaType, this.valueType);
        }

        return this.formattedValues;
    },

    /**
     * Make base values of normal stacked chart.
     * @returns {Array.<number>}
     * @private
     */
    _makeBaseValuesForNormalStackedChart: function() {
        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType),
            baseValues = [];

        seriesDataModel.each(function(seriesGroup) {
            var valuesMap = seriesGroup._makeValuesMapPerStack();

            tui.util.forEach(valuesMap, function(values) {
                var plusSum = calculator.sumPlusValues(values),
                    minusSum = calculator.sumMinusValues(values);
                baseValues = baseValues.concat([plusSum, minusSum]);
            });
        });

        return baseValues;
    },

    /**
     * Make base values.
     * @returns {Array.<number>} base values
     * @private
     */
    _makeBaseValues: function() {
        var baseValues;

        if (predicate.isMapChart(this.chartType)) {
            baseValues = this.dataProcessor.getValues();
        } else if (this.isSingleYAxis) {
            baseValues = this.dataProcessor.getValues();
        } else if (this._isNormalStackedChart()) {
            baseValues = this._makeBaseValuesForNormalStackedChart();
        } else {
            baseValues = this.dataProcessor.getValues(this.chartType, this.valueType);
        }

        return baseValues;
    },

    /**
     * Get base size for calculation candidate value counts.
     * @returns {number} base size
     * @private
     */
    _getBaseSize: function() {
        var baseSize;

        if (this.isVertical) {
            baseSize = this.boundsMaker.makeSeriesHeight();
        } else {
            baseSize = this.boundsMaker.makeSeriesWidth();
        }

        return baseSize;
    },

    /**
     * Get candidate counts of value.
     * @memberOf module:axisDataMaker
     * @returns {Array.<number>} value counts
     * @private
     */
    _getCandidateCountsOfValue: function() {
        var minStart = 3,
            valueCounts, baseSize, start, end;

        baseSize = this._getBaseSize();
        start = Math.max(minStart, parseInt(baseSize / chartConst.MAX_PIXEL_TYPE_STEP_SIZE, 10));
        end = Math.max(start, parseInt(baseSize / chartConst.MIN_PIXEL_TYPE_STEP_SIZE, 10)) + 1;
        valueCounts = tui.util.range(start, end);

        return valueCounts;
    },

    /**
     * Make limit for diverging option.
     * @param {{min: number, max: number}} limit limit
     * @returns {{min: number, max: number}} changed limit
     * @private
     */
    _makeLimitForDivergingOption: function(limit) {
        var newMax = Math.max(abs(limit.min), abs(limit.max));

        return {
            min: -newMax,
            max: newMax
        };
    },

    /**
     * Make integer type scale.
     * @memberOf module:axisDataMaker
     * @param {{min: number, max: number}} limit limit
     * @returns {{
     *      limit: {min: number, max: number},
     *      options: {min: number, max: number},
     *      divideNum: number
     * }} integer type info
     * @private
     */
    _makeIntegerTypeScale: function(limit) {
        var options = this.options.limit || {},
            min = limit.min,
            max = limit.max,
            multipleNum, changedOptions;

        if (abs(min) >= 1 || abs(max) >= 1) {
            return {
                limit: limit,
                options: options,
                divideNum: 1
            };
        }

        multipleNum = tui.util.findMultipleNum(min, max);
        changedOptions = {};

        if (!tui.util.isUndefined(options.min)) {
            changedOptions.min = options.min * multipleNum;
        }

        if (!tui.util.isUndefined(options.max)) {
            changedOptions.max = options.max * multipleNum;
        }

        return {
            limit: {
                min: min * multipleNum,
                max: max * multipleNum
            },
            options: changedOptions,
            divideNum: multipleNum
        };
    },

    /**
     * Make limit if equal min and max.
     * @param {{min: number, max: number}} limit limit
     * @returns {{min: number, max: number}} changed limit
     * @private
     */
    _makeLimitIfEqualMinMax: function(limit) {
        var min = limit.min,
            max = limit.max;

        if (min > 0) {
            min = 0;
        } else if (min < 0) {
            max = 0;
        }

        return {
            min: min,
            max: max
        };
    },

    /**
     * Make base limit
     * @memberOf module:axisDataMaker
     * @param {{min: number, max: number}} dataLimit user limit
     * @param {{min: number, max: number}} options axis options
     * @returns {{min: number, max: number}} base limit
     * @private
     */
    _makeBaseLimit: function(dataLimit, options) {
        var isMinusLimit = predicate.isMinusLimit(dataLimit),
            min = dataLimit.min,
            max = dataLimit.max,
            baseLimit, tmpMin;

        if (min === max) {
            baseLimit = this._makeLimitIfEqualMinMax(dataLimit);
        } else {
            if (isMinusLimit) {
                tmpMin = min;
                min = -max;
                max = -tmpMin;
            }

            baseLimit = calculator.calculateLimit(min, max);

            if (isMinusLimit) {
                tmpMin = baseLimit.min;
                baseLimit.min = -baseLimit.max;
                baseLimit.max = -tmpMin;
            }

            baseLimit.min = tui.util.isUndefined(options.min) ? baseLimit.min : options.min;
            baseLimit.max = tui.util.isUndefined(options.max) ? baseLimit.max : options.max;
        }

        return baseLimit;
    },

    /**
     * Normalize min.
     * @memberOf module:axisDataMaker
     * @param {number} min original min
     * @param {number} step scale step
     * @returns {number} normalized min
     * @private
     */
    _normalizeMin: function(min, step) {
        var mod = tui.util.mod(min, step),
            normalized;

        if (mod === 0) {
            normalized = min;
        } else {
            normalized = tui.util.subtraction(min, (min >= 0 ? mod : step + mod));
        }
        return normalized;
    },

    /**
     * Make normalized max.
     * @memberOf module:axisDataMaker
     * @param {{min: number, max: number}} limit limit
     * @param {number} step scale step
     * @param {number} valueCount value count
     * @returns {number} normalized max
     * @private
     */
    _makeNormalizedMax: function(limit, step, valueCount) {
        var minMaxDiff = tui.util.multiplication(step, valueCount - 1),
            normalizedMax = tui.util.addition(limit.min, minMaxDiff),
            maxDiff = limit.max - normalizedMax,
            modDiff, divideDiff;
        // normalize된 max값이 원래의 max값 보다 작을 경우 step을 증가시켜 큰 값으로 만들기
        if (maxDiff > 0) {
            modDiff = maxDiff % step;
            divideDiff = Math.floor(maxDiff / step);
            normalizedMax += step * (modDiff > 0 ? divideDiff + 1 : divideDiff);
        }
        return normalizedMax;
    },

    /**
     * Normalize limit.
     * @param {{min: number, max: number}} limit base limit
     * @param {number} step scale step
     * @param {number} valueCount value count
     * @returns {{min: number, max: number}} normalized limit
     * @private
     */
    _normalizeLimit: function(limit, step, valueCount) {
        limit.min = this._normalizeMin(limit.min, step);
        limit.max = this._makeNormalizedMax(limit, step, valueCount);
        return limit;
    },

    /**
     * Decrease minimum value by step value,
     *  when chart type is line or dataMin is minus, options is undefined, minimum values(min, dataMin) are same.
     * @param {number} min base min
     * @param {number} dataMin minimum value of user data
     * @param {number} step scale step
     * @param {?number} optionMin min option
     * @returns {number} changed min
     * @private
     */
    _decreaseMinByStep: function(min, dataMin, step, optionMin) {
        var isLineChart = predicate.isLineChart(this.chartType),
            isMinusDataMin = dataMin < 0,
            isUndefinedMinOption = tui.util.isUndefined(optionMin),
            isSame = (min === dataMin);

        if ((isLineChart || isMinusDataMin) && isUndefinedMinOption && isSame) {
            min -= step;
        }

        return min;
    },

    /**
     * Increase maximum value by step value,
     *  when chart type is line or dataMin is plus, options is undefined, maximum values(max, dataMax) are same.
     * @param {number} max base max
     * @param {number} dataMax maximum value of user data
     * @param {number} step scale step
     * @param {?number} optionMax max option
     * @returns {number} changed max
     * @private
     */
    _increaseMaxByStep: function(max, dataMax, step, optionMax) {
        var isLineChart = predicate.isLineChart(this.chartType),
            isPlusDataMax = dataMax > 0,
            isUndefinedMaxOption = tui.util.isUndefined(optionMax),
            isSame = (max === dataMax);

        if ((isLineChart || isPlusDataMax) && isUndefinedMaxOption && isSame) {
            max += step;
        }

        return max;
    },

    /**
     * Divide scale step.
     * @param {{min: number, max: number}} limit limit
     * @param {number} step step
     * @param {number} candidateValueCount candidate valueCount
     * @returns {number} scale step
     * @private
     */
    _divideScaleStep: function(limit, step, candidateValueCount) {
        var isEvenStep = ((step % 2) === 0),
            valueCount = calculator.makeLabelsFromLimit(limit, step).length,
            twiceValueCount = (valueCount * 2) - 1,
            diffOrg = abs(candidateValueCount - valueCount),
            diffTwice = abs(candidateValueCount - twiceValueCount);

        // step을 반으로 나누었을 때의 valueCount가 후보로 계산된 candidateValueCount와 인접하면 step을 반으로 나누어 반환합니다.
        if (isEvenStep && diffTwice <= diffOrg) {
            step = step / 2;
        }
        return step;
    },

    /**
     * Minimize scale limit.
     * @param {{min: number, max: number}} limit base limit
     * @param {{min: number, max: number}} dataLimit limit of user data
     * @param {number} step scale step
     * @param {number} valueCount value count
     * @param {{min: number, max:number}} options limit options of axis
     * @returns {{min: number, max: number}} minimized limit
     * @private
     */
    _minimizeScaleLimit: function(limit, dataLimit, step, valueCount, options) {
        var min = limit.max,
            max = limit.min,
            comparisonMin = tui.util.isUndefined(options.min) ? dataLimit.min - 1 : options.min,
            comparisonMax = tui.util.isUndefined(options.max) ? dataLimit.max + 1 : options.max;

        tui.util.forEachArray(tui.util.range(1, valueCount), function(valueIndex) {
            var changingStep = (step * valueIndex),
                changedMin = max + changingStep,
                changedMax = min - changingStep;

            // limit이 dataLimit 범위를 넘어갈 것으로 예상되는 경우에 변경을 중단함
            if (dataLimit.min <= changedMin && dataLimit.max >= changedMax) {
                return false;
            }

            if (comparisonMin >= changedMin) {
                limit.min = changedMin;
            }

            if (comparisonMax <= changedMax) {
                limit.max = changedMax;
            }

            return true;
        });

        return limit;
    },

    /**
     * Adjust limit for bubble chart.
     * @param {{min: number, max: number}} limit - limit
     * @param {number} step - step;
     * @private
     */
    _adjustLimitForBubbleChart: function(limit, step) {
        var valueType = this.valueType;
        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType);
        var maxRadiusValue = seriesDataModel.getMaxValue('r');
        var isBiggerRatioThanHalfRatio = function(seriesItem) {
            return (seriesItem.r / maxRadiusValue) > chartConst.HALF_RATIO;
        };
        var foundMinItem = seriesDataModel.findMinSeriesItem(valueType, isBiggerRatioThanHalfRatio);
        var foundMaxItem = seriesDataModel.findMaxSeriesItem(valueType, isBiggerRatioThanHalfRatio);

        if (foundMinItem) {
            limit.min -= step;
        }

        if (foundMaxItem) {
            limit.max += step;
        }
    },

    /**
     * Make candidate axis scale.
     * @param {{min: number, max: number}} baseLimit base limit
     * @param {{min: number, max: number}} dataLimit limit of user data
     * @param {number} valueCount value count
     * @param {{min: number, max:number}} options limit options of axis
     * @returns {{
     *      limit: {min: number, max: number},
     *      step: number
     * }} scale
     * @private
     */
    _makeCandidateScale: function(baseLimit, dataLimit, valueCount, options) {
        var limit = tui.util.extend({}, baseLimit),
            step;

        // 01. 기본 limit 정보로 step 얻기
        step = calculator.calculateStepFromLimit(limit, valueCount);

        // 02. step 정규화 시키기 (ex: 0.3 --> 0.5, 7 --> 10)
        step = calculator.normalizeAxisNumber(step);

        // 03. limit 정규화 시키기
        limit = this._normalizeLimit(limit, step, valueCount);

        // 04. line차트의 경우 사용자의 min값이 limit의 min값과 같을 경우, min값을 1 step 감소 시킴
        limit.min = this._decreaseMinByStep(limit.min, dataLimit.min, step, options.min);

        // 04. 사용자의 max값이 scale max와 같을 경우, max값을 1 step 증가 시킴
        limit.max = this._increaseMaxByStep(limit.max, dataLimit.max, step, options.max);

        // 05. axis limit이 사용자 min, max와 거리가 멀 경우 조절
        limit = this._minimizeScaleLimit(limit, dataLimit, step, valueCount, options);

        // 06. 조건에 따라 step값을 반으로 나눔
        step = this._divideScaleStep(limit, step, valueCount);

        if (predicate.isBubbleChart(this.chartType)) {
            this._adjustLimitForBubbleChart(limit, step);
        }

        return {
            limit: limit,
            step: step,
            valueCount: abs(limit.max - limit.min) / step
        };
    },

    /**
     * Make candidates about axis scale.
     * @param {{
     *      limit: {min: number, max: number},
     *      options: {min: number, max: number},
     *      divideNum: number
     * }} integerTypeScale - integer type axis scale
     * @param {Array.<number>} valueCounts - candidate counts of value
     * @returns {Array.<{limit:{min: number, max: number}, stpe: number}>} - candidates scale
     * @private
     */
    _makeCandidateScales: function(integerTypeScale, valueCounts) {
        var self = this,
            dataLimit = integerTypeScale.limit,
            options = integerTypeScale.options,
            baseLimit = this._makeBaseLimit(dataLimit, options);

        return tui.util.map(valueCounts, function(valueCount) {
            return self._makeCandidateScale(baseLimit, dataLimit, valueCount, options);
        });
    },

    /**
     * Get comparing value for selecting axis scale.
     * @param {{min: number, max: number}} baseLimit - limit
     * @param {Array.<number>} valueCounts - candidate counts of value
     * @param {{limit: {min: number, max: number}, step: number}} candidateScale - scale
     * @param {number} index - index
     * @returns {number} comparing value
     * @private
     */
    _getComparingValue: function(baseLimit, valueCounts, candidateScale, index) {
        var diffMax = abs(candidateScale.limit.max - baseLimit.max);
        var diffMin = abs(baseLimit.min - candidateScale.limit.min);
        // 예상 label count와 차이가 많을 수록 후보 제외 가능성이 높음
        var diffCount = Math.max(abs(valueCounts[index] - candidateScale.valueCount), 1);
        // 소수점 이하 길이가 길 수록 후보에서 제외될 가능성이 높음
        var weight = Math.pow(10, tui.util.getDecimalLength(candidateScale.step));

        return (diffMax + diffMin) * diffCount * weight;
    },

    /**
     * Select axis scale.
     * @param {{min: number, max: number}} baseLimit limit
     * @param {Array.<{limit: {min: number, max: number}, step: number}>} candidates scale candidates
     * @param {Array.<number>} valueCounts - label counts
     * @returns {{limit: {min: number, max: number}, step: number}} selected scale
     * @private
     */
    _selectAxisScale: function(baseLimit, candidates, valueCounts) {
        var getComparingValue = tui.util.bind(this._getComparingValue, this, baseLimit, valueCounts);
        var axisScale = tui.util.min(candidates, getComparingValue);

        return axisScale;
    },

    /**
     * Restore number state of scale.
     * @memberOf module:axisDataMaker
     * @param {{limit: {min: number, max: number}, step: number}} scale scale
     * @param {number} divideNum divide num
     * @returns {{limit: {min: number, max: number}, step: number}} restored scale
     * @private
     */
    _restoreNumberState: function(scale, divideNum) {
        if (divideNum === 1) {
            return scale;
        }

        scale.step = tui.util.division(scale.step, divideNum);
        scale.limit.min = tui.util.division(scale.limit.min, divideNum);
        scale.limit.max = tui.util.division(scale.limit.max, divideNum);

        return scale;
    },

    /**
     * Calculate scale.
     * @returns {{limit: {min: number, max: number}, step: number}}
     * @private
     */
    _calculateScale: function() {
        var baseValues = this._makeBaseValues();
        var dataLimit = {
            min: tui.util.min(baseValues),
            max: tui.util.max(baseValues)
        };
        var integerTypeScale, valueCounts, candidates, scale;

        if (dataLimit.min === 0 && dataLimit.max === 0) {
            dataLimit.max = 5;
        }

        if (this._isDivergingChart()) {
            dataLimit = this._makeLimitForDivergingOption(dataLimit);
        }

        // 01. limit, options 정보를 정수형으로 변경
        integerTypeScale = this._makeIntegerTypeScale(dataLimit);

        // 02. value count 후보군 얻기
        valueCounts = this.valueCounts || this._getCandidateCountsOfValue();

        // 03. axis scale 후보군 얻기
        candidates = this._makeCandidateScales(integerTypeScale, valueCounts);

        // 04. axis scale 후보군 중 하나 선택
        scale = this._selectAxisScale(integerTypeScale.limit, candidates, valueCounts);

        // 05. 정수형으로 변경했던 scale를 원래 형태로 변경
        scale = this._restoreNumberState(scale, integerTypeScale.divideNum);

        return scale;
    },

    /**
     * Get values for sum.
     * @returns {Array.<number>}
     * @private
     */
    _getValuesForSum: function() {
        var values;

        if (this.isSingleYAxis) {
            values = this.dataProcessor.getValues();
        } else {
            values = this.dataProcessor.getValues(this.chartType);
        }

        return values;
    },

    /**
     * Calculate minus sum about group values.
     * @returns {number}
     * @private
     */
    _calculateMinusSum: function() {
        var values = this._getValuesForSum();

        return calculator.sumMinusValues(values);
    },

    /**
     * Calculate plus sum about group values.
     * @returns {number}
     * @private
     */
    _calculatePlusSum: function() {
        var values = this._getValuesForSum();

        return calculator.sumPlusValues(values);
    },

    /**
     * Get percent stacked scale.
     * @returns {{limit: {min:number, max:number}, step: number}}
     * @private
     */
    _getPercentStackedScale: function() {
        var scale;

        if (this._calculateMinusSum() === 0) {
            scale = chartConst.PERCENT_STACKED_AXIS_SCALE;
        } else if (this._calculatePlusSum() === 0) {
            scale = chartConst.MINUS_PERCENT_STACKED_AXIS_SCALE;
        } else if (this._isDivergingChart()) {
            scale = chartConst.DIVERGING_PERCENT_STACKED_AXIS_SCALE;
        } else {
            scale = chartConst.DUAL_PERCENT_STACKED_AXIS_SCALE;
        }

        return scale;
    },

    /**
     * Make scale.
     * @returns {{limit: {min:number, max:number}, step: number}}
     * @private
     */
    _makeScale: function() {
        var scale;

        if (this._isPercentStackedChart()) {
            scale = this._getPercentStackedScale();
        } else {
            scale = this._calculateScale();
        }

        return scale;
    }
});

module.exports = AxisScaleMaker;

},{"../const":20,"./calculator":43,"./predicate":47,"./renderUtil":49}],42:[function(require,module,exports){
/**
 * @fileoverview Bounds maker.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    calculator = require('./calculator'),
    predicate = require('./predicate'),
    renderUtil = require('./renderUtil');

/**
 * Dimension.
 * @typedef {{width: number, height:number}} dimension
 */

/**
 * Position.
 * @typedef {{left: number, top:number}} position
 */

/**
 * Bound.
 * @typedef {{dimension: dimension, position:position}} bound
 */

var BoundsMaker = tui.util.defineClass(/** @lends BoundsMaker.prototype */{
    /**
     * Bounds maker.
     * @constructs BoundsMaker
     * @param {object} params parameters
     */
    init: function(params) {
        /**
         * options
         * @type {object}
         */
        this.options = params.options || {};
        this.options.legend = this.options.legend || {};
        this.options.yAxis = this.options.yAxis || {};

        /**
         * theme
         * @type {object}
         */
        this.theme = params.theme || {};

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = params.hasAxes;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        this.initBoundsData();
    },

    /**
     * Initialize bounds data.
     * @param {object} chartOption chart option
     */
    initBoundsData: function(chartOption) {
        this.dimensions = {
            legend: {
                width: 0
            },
            yAxis: {
                width: 0
            },
            rightYAxis: {
                width: 0
            },
            xAxis: {
                height: 0
            },
            circleLegend: {
                width: 0
            },
            calculationLegend: {
                width: 0
            }
        };

        this.positions = {};

        this.axesData = {};

        this.xAxisDegree = 0;

        /**
         * chart left padding
         * @type {number}
         */
        this.chartLeftPadding = chartConst.CHART_PADDING;

        if (chartOption) {
            this.options.chart = chartOption;
        }

        this._registerChartDimension();
        this._registerTitleDimension();
    },

    /**
     * Register dimension.
     * @param {string} name component name
     * @param {dimension} dimension component dimension
     * @private
     */
    _registerDimension: function(name, dimension) {
        this.dimensions[name] = tui.util.extend(this.dimensions[name] || {}, dimension);
    },

    /**
     * Register base dimension.
     * @param {string} name component name
     * @param {dimension} dimension component dimension
     */
    registerBaseDimension: function(name, dimension) {
        this._registerDimension(name, dimension);
    },

    /**
     * Register axes data.
     * @param {object} axesData axes data
     */
    registerAxesData: function(axesData) {
        this.axesData = axesData;
    },

    /**
     * Axes data.
     * @returns {{xAxis: object, yAxis: object, rightYAxis: object}}
     */
    getAxesData: function() {
        return this.axesData;
    },

    /**
     * Calculate step of pixel unit.
     * @param {{tickCount: number, isLabel: boolean}} axisData - data for rendering axis
     * @param {number} size - width or height of serise area
     * @returns {number}
     * @private
     */
    _calculatePixelStep: function(axisData, size) {
        var tickCount = axisData.tickCount;
        var pixelStep;

        if (axisData.isLabel) {
            pixelStep = size / tickCount / 2;
        } else {
            pixelStep = size / (tickCount - 1);
        }

        return parseInt(pixelStep, 10);
    },

    /**
     * Get minimum step of pixel unit for axis.
     * @returns {number}
     */
    getMinimumPixelStepForAxis: function() {
        var dimension = this.getDimension('series');
        var yPixelStep = this._calculatePixelStep(this.axesData.yAxis, dimension.height);
        var xPixelStep = this._calculatePixelStep(this.axesData.xAxis, dimension.width);

        return Math.min(yPixelStep, xPixelStep);
    },

    /**
     * Get bound.
     * @param {string} name component name
     * @returns {bound} component bound
     */
    getBound: function(name) {
        return {
            dimension: this.dimensions[name] || {},
            position: this.positions[name] || {}
        };
    },

    /**
     * Set bound.
     * @param {string} name component name
     * @param {bound} bound component bound
     * @private
     */
    _setBound: function(name, bound) {
        this.dimensions[name] = bound.dimension;
        this.positions[name] = bound.position;
    },

    /**
     * Get dimension.
     * @param {string} name component name
     * @returns {dimension} component dimension
     */
    getDimension: function(name) {
        return this.dimensions[name];
    },

    /**
     * Get position.
     * @param {string} name component name
     * @returns {position} component position
     */
    getPosition: function(name) {
        return this.positions[name];
    },

    /**
     * Register chart dimension
     * @private
     */
    _registerChartDimension: function() {
        var chartOptions = this.options.chart || {},
            dimension = {
                width: chartOptions.width || chartConst.CHART_DEFAULT_WIDTH,
                height: chartOptions.height || chartConst.CHART_DEFAULT_HEIGHT
            };

        this._registerDimension('chart', dimension);
    },

    /**
     * Register title dimension
     * @private
     */
    _registerTitleDimension: function() {
        var chartOptions = this.options.chart || {},
            titleHeight = renderUtil.getRenderedLabelHeight(chartOptions.title, this.theme.title),
            dimension = {
                height: titleHeight + chartConst.TITLE_PADDING
            };

        this._registerDimension('title', dimension);
    },

    /**
     * Calculate limit width of x axis.
     * @returns {number} limit width
     * @private
     */
    _calculateXAxisLabelLimitWidth: function() {
        var seriesWidth = this.getDimension('series').width,
            labelCount = this.axesData.xAxis.labels.length,
            isAlign = predicate.isLineTypeChart(this.chartType);
        return seriesWidth / (isAlign ? labelCount - 1 : labelCount);
    },

    /**
     * Find rotation degree.
     * @param {number} limitWidth limit width
     * @param {number} labelWidth label width
     * @param {number} labelHeight label height
     * @param {number} index candidates index
     * @returns {number} rotation degree
     * @private
     */
    _findRotationDegree: function(limitWidth, labelWidth, labelHeight) {
        var foundDegree,
            halfWidth = labelWidth / 2,
            halfHeight = labelHeight / 2;

        tui.util.forEachArray(chartConst.DEGREE_CANDIDATES, function(degree) {
            var compareWidth = (calculator.calculateAdjacent(degree, halfWidth) +
                calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, halfHeight)) * 2;

            foundDegree = degree;
            if (compareWidth <= limitWidth + chartConst.XAXIS_LABEL_COMPARE_MARGIN) {
                return false;
            }

            return true;
        });

        return foundDegree;
    },

    /**
     * Make rotation info about horizontal label.
     * @param {number} limitWidth limit width
     * @param {Array.<string>} labels axis labels
     * @param {object} theme axis label theme
     * @returns {?object} rotation info
     * @private
     */
    _makeHorizontalLabelRotationInfo: function(limitWidth) {
        var labels = this.axesData.xAxis.labels,
            theme = this.theme.xAxis.label,
            maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(labels, theme),
            degree, labelHeight;

        if (maxLabelWidth <= limitWidth) {
            return null;
        }

        labelHeight = renderUtil.getRenderedLabelsMaxHeight(labels, theme);
        degree = this._findRotationDegree(limitWidth, maxLabelWidth, labelHeight);

        return {
            maxLabelWidth: maxLabelWidth,
            labelHeight: labelHeight,
            degree: degree
        };
    },


    /**
     * Calculate overflow position left.
     * @param {{degree: number, labelHeight: number}} rotationInfo rotation info
     * @param {string} firstLabel firstLabel
     * @returns {number} overflow position left
     * @private
     */
    _calculateOverflowLeft: function(rotationInfo, firstLabel) {
        var degree = rotationInfo.degree,
            labelHeight = rotationInfo.labelHeight,
            firstLabelWidth = renderUtil.getRenderedLabelWidth(firstLabel, this.theme.xAxis.label),
            newLabelWidth = (calculator.calculateAdjacent(degree, firstLabelWidth / 2)
                + calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, labelHeight / 2)) * 2,
            yAxisWidth = this.options.yAxis.isCenter ? 0 : this.getDimension('yAxis').width,
            diffLeft = newLabelWidth - yAxisWidth;
        return diffLeft;
    },

    /**
     * Update width of dimensions.
     * @param {number} overflowLeft overflow left
     * @private
     */
    _updateDimensionsWidth: function(overflowLeft) {
        if (overflowLeft > 0) {
            this.chartLeftPadding += overflowLeft;
            this.dimensions.plot.width -= overflowLeft;
            this.dimensions.series.width -= overflowLeft;
            this.dimensions.customEvent.width -= overflowLeft;
            this.dimensions.xAxis.width -= overflowLeft;
            this.positions.series.left += overflowLeft;
        }
    },

    /**
     * Update degree of rotationInfo.
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @param {number} labelLength labelLength
     * @param {number} overflowLeft overflow left
     * @private
     */
    _updateDegree: function(rotationInfo, labelLength, overflowLeft) {
        var limitWidth, newDegree;
        if (overflowLeft > 0) {
            limitWidth = this.getDimension('series').width / labelLength + chartConst.XAXIS_LABEL_GUTTER;
            newDegree = this._findRotationDegree(limitWidth, rotationInfo.maxLabelWidth, rotationInfo.labelHeight);
            rotationInfo.degree = newDegree;
        }
    },

    /**
     * Calculate rotated height of xAxis.
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @returns {number} xAxis height
     * @private
     */
    _calculateXAxisRotatedHeight: function(rotationInfo) {
        var degree = rotationInfo.degree,
            maxLabelWidth = rotationInfo.maxLabelWidth,
            labelHeight = rotationInfo.labelHeight,
            axisHeight = (calculator.calculateOpposite(degree, maxLabelWidth / 2) +
                calculator.calculateOpposite(chartConst.ANGLE_90 - degree, labelHeight / 2)) * 2;

        return axisHeight;
    },

    /**
     * Calculate height difference between origin category and rotation category.
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @returns {number} height difference
     * @private
     */
    _calculateDiffWithRotatedHeight: function(rotationInfo) {
        var rotatedHeight = this._calculateXAxisRotatedHeight(rotationInfo);
        return rotatedHeight - rotationInfo.labelHeight;
    },

    /**
     * Calculate height difference between origin category and multiline category.
     * @param {Array.<string>} labels labels
     * @param {number} limitWidth limit width
     * @returns {number} calculated height
     * @private
     */
    _calculateDiffWithMultilineHeight: function(labels, limitWidth) {
        var theme = this.theme.xAxis.label,
            multilineLabels = this.dataProcessor.getMultilineCategories(limitWidth, theme, this.axesData.xAxis.labels),
            normalHeight = renderUtil.getRenderedLabelsMaxHeight(labels, theme),
            multilineHeight = renderUtil.getRenderedLabelsMaxHeight(multilineLabels, tui.util.extend({
                cssText: 'line-height:1.2;width:' + limitWidth + 'px'
            }, theme));

        return multilineHeight - normalHeight;
    },

    /**
     * Update height of dimensions.
     * @param {number} diffHeight diff height
     * @private
     */
    _updateDimensionsHeight: function(diffHeight) {
        this.dimensions.plot.height -= diffHeight;
        this.dimensions.series.height -= diffHeight;
        this.dimensions.customEvent.height -= diffHeight;
        this.dimensions.tooltip.height -= diffHeight;
        this.dimensions.yAxis.height -= diffHeight;
        this.dimensions.rightYAxis.height -= diffHeight;
        this.dimensions.xAxis.height += diffHeight;
    },

    /**
     * Update dimensions and degree.
     * @private
     */
    _updateDimensionsAndDegree: function() {
        var xAxisOptions = this.options.xAxis || {},
            limitWidth = this._calculateXAxisLabelLimitWidth(),
            labels = this.axesData.xAxis.labels,
            rotationInfo, overflowLeft, diffHeight;

        if (xAxisOptions.rotation !== false) {
            rotationInfo = this._makeHorizontalLabelRotationInfo(limitWidth);
        }

        if (rotationInfo) {
            overflowLeft = this._calculateOverflowLeft(rotationInfo, labels[0]);
            this.xAxisDegree = rotationInfo.degree;
            this._updateDimensionsWidth(overflowLeft);
            this._updateDegree(rotationInfo, labels.length, overflowLeft);
            diffHeight = this._calculateDiffWithRotatedHeight(rotationInfo);
        } else {
            diffHeight = this._calculateDiffWithMultilineHeight(labels, limitWidth);
        }

        this._updateDimensionsHeight(diffHeight);
    },

    /**
     * Make plot dimention
     * @returns {{width: number, height: number}} plot dimension
     * @private
     */
    _makePlotDimension: function() {
        var seriesDimension = this.getDimension('series');
        return {
            width: seriesDimension.width,
            height: seriesDimension.height + chartConst.OVERLAPPING_WIDTH
        };
    },

    /**
     * Register axis components dimension.
     * @private
     */
    _registerAxisComponentsDimension: function() {
        var plotDimension = this._makePlotDimension();

        this._registerDimension('plot', plotDimension);

        this._registerDimension('xAxis', {
            width: plotDimension.width
        });

        this._registerDimension('yAxis', {
            height: plotDimension.height
        });

        this._registerDimension('rightYAxis', {
            height: plotDimension.height
        });
    },

    /**
     * Make series width.
     * @returns {number} series width
     */
    makeSeriesWidth: function() {
        var chartWidth = this.getDimension('chart').width;
        var yAxisWidth = this.getDimension('yAxis').width;
        var legendDimension = this.getDimension('calculationLegend');
        var legendWidth, rightAreaWidth;

        if (predicate.isHorizontalLegend(this.options.legend.align)) {
            legendWidth = 0;
        } else {
            legendWidth = legendDimension ? legendDimension.width : 0;
        }

        rightAreaWidth = legendWidth + this.getDimension('rightYAxis').width;

        return chartWidth - (chartConst.CHART_PADDING * 2) - yAxisWidth - rightAreaWidth;
    },

    /**
     * Make series height
     * @returns {number} series height
     */
    makeSeriesHeight: function() {
        var chartHeight = this.getDimension('chart').height,
            titleHeight = this.getDimension('title').height,
            legendHeight, bottomAreaWidth;

        if (predicate.isHorizontalLegend(this.options.legend.align)) {
            legendHeight = this.getDimension('legend').height;
        } else {
            legendHeight = 0;
        }

        bottomAreaWidth = legendHeight + this.dimensions.xAxis.height;

        return chartHeight - (chartConst.CHART_PADDING * 2) - titleHeight - bottomAreaWidth;
    },

    /**
     * Make series dimension.
     * @returns {{width: number, height: number}} series dimension
     * @private
     */
    _makeSeriesDimension: function() {
        return {
            width: this.makeSeriesWidth(),
            height: this.makeSeriesHeight()
        };
    },

    /**
     * Register center componets dimension.
     * @private
     */
    _registerCenterComponentsDimension: function() {
        var seriesDimension = this.getDimension('series');

        this._registerDimension('tooltip', seriesDimension);
        this._registerDimension('customEvent', seriesDimension);
    },

    /**
     * Register axes type component positions.
     * @param {number} leftLegendWidth legend width
     * @private
     */
    _registerAxisComponentsPosition: function(leftLegendWidth) {
        var seriesPosition = this.getPosition('series'),
            seriesDimension = this.getDimension('series'),
            yAxisWidth = this.getDimension('yAxis').width,
            leftAreaWidth = yAxisWidth + seriesDimension.width + leftLegendWidth;

        this.positions.plot = {
            top: seriesPosition.top,
            left: seriesPosition.left
        };

        this.positions.yAxis = {
            top: seriesPosition.top,
            left: this.chartLeftPadding + leftLegendWidth
        };

        this.positions.xAxis = {
            top: seriesPosition.top + seriesDimension.height,
            left: seriesPosition.left
        };

        this.positions.rightYAxis = {
            top: seriesPosition.top,
            left: this.chartLeftPadding + leftAreaWidth - chartConst.OVERLAPPING_WIDTH
        };
    },

    /**
     * Make legend bound.
     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} legend bound
     * @private
     */
    _makeLegendPosition: function() {
        var dimensions = this.dimensions,
            seriesDimension = this.getDimension('series'),
            legendOption = this.options.legend,
            top = dimensions.title.height,
            yAxisAreaWidth, left;

        if (predicate.isLegendAlignBottom(legendOption.align)) {
            top += seriesDimension.height + this.getDimension('xAxis').height + chartConst.LEGEND_AREA_PADDING;
        }

        if (predicate.isHorizontalLegend(legendOption.align)) {
            left = ((this.getDimension('chart').width - this.getDimension('legend').width) / 2)
                - chartConst.LEGEND_AREA_PADDING;
        } else if (predicate.isLegendAlignLeft(legendOption.align)) {
            left = 0;
        } else {
            yAxisAreaWidth = this.getDimension('yAxis').width + this.getDimension('rightYAxis').width;
            left = seriesDimension.width + yAxisAreaWidth + this.chartLeftPadding;
        }

        return {
            top: top,
            left: left
        };
    },

    /**
     * Make CircleLegend position.
     * @returns {{top: number, left: number}}
     * @private
     */
    _makeCircleLegendPosition: function() {
        var seriesPosition = this.getPosition('series');
        var seriesDimension = this.getDimension('series');
        var circleDimension = this.getDimension('circleLegend');
        var left;

        if (predicate.isLegendAlignLeft(this.options.legend.align)) {
            left = 0;
        } else {
            left = seriesPosition.left + seriesDimension.width;
        }

        return {
            top: seriesPosition.top + seriesDimension.height - circleDimension.height,
            left: left
        };
    },

    /**
     * Register essential components positions.
     * @private
     */
    _registerEssentialComponentsPositions: function() {
        var seriesPosition = this.getPosition('series'),
            tooltipPosition;

        this.positions.customEvent = tui.util.extend({}, seriesPosition);
        this.positions.legend = this._makeLegendPosition();

        if (this.getDimension('circleLegend').width) {
            this.positions.circleLegend = this._makeCircleLegendPosition();
        }

        if (!predicate.isMousePositionChart(this.chartType)) {
            tooltipPosition = {
                top: seriesPosition.top - chartConst.SERIES_EXPAND_SIZE,
                left: seriesPosition.left - chartConst.SERIES_EXPAND_SIZE
            };
        } else {
            tooltipPosition = seriesPosition;
        }

        this.positions.tooltip = tooltipPosition;
    },

    /**
     * Register positions.
     * @private
     */
    _registerPositions: function() {
        var alignOption = this.options.legend.align,
            legendDimension = this.getDimension('legend'),
            topLegendHeight = predicate.isLegendAlignTop(alignOption) ? legendDimension.height : 0,
            leftLegendWidth = predicate.isLegendAlignLeft(alignOption) ? legendDimension.width : 0,
            seriesPosition = {
                top: this.getDimension('title').height + chartConst.CHART_PADDING + topLegendHeight,
                left: this.chartLeftPadding + leftLegendWidth + this.getDimension('yAxis').width
            };

        this.positions.series = seriesPosition;

        if (this.hasAxes) {
            this._updateDimensionsAndDegree();
            this._registerAxisComponentsPosition(leftLegendWidth);
        }

        this._registerEssentialComponentsPositions();
    },

    /**
     * Register bound of extended series for rendering.
     * @private
     */
    _registerExtendedSeriesBound: function() {
        var seriesBound = this.getBound('series');
        if (!predicate.isMousePositionChart(this.chartType)) {
            seriesBound = renderUtil.expandBound(seriesBound);
        }

        this._setBound('extendedSeries', seriesBound);
    },

    /**
     * Update bounds(positions, dimensions) of components for center option of yAxis.
     * @private
     */
    _updateBoundsForYAxisCenterOption: function() {
        var yAxisWidth = this.getDimension('yAxis').width,
            yAxisExtensibleLeft = Math.floor((this.getDimension('series').width / 2)) + chartConst.OVERLAPPING_WIDTH,
            xAxisDecreasingLeft = yAxisWidth - chartConst.OVERLAPPING_WIDTH,
            additionalLeft = renderUtil.isOldBrowser() ? 1 : 0;

        this.dimensions.extendedSeries.width += yAxisWidth;
        this.dimensions.xAxis.width += chartConst.OVERLAPPING_WIDTH;
        this.dimensions.plot.width += yAxisWidth + chartConst.OVERLAPPING_WIDTH;
        this.dimensions.customEvent.width += yAxisWidth;
        this.dimensions.tooltip.width += yAxisWidth;

        this.positions.series.left -= (yAxisWidth - additionalLeft);
        this.positions.extendedSeries.left -= (xAxisDecreasingLeft - additionalLeft);
        this.positions.plot.left -= xAxisDecreasingLeft;
        this.positions.yAxis.left += yAxisExtensibleLeft;
        this.positions.xAxis.left -= xAxisDecreasingLeft;
        this.positions.customEvent.left -= xAxisDecreasingLeft;
        this.positions.tooltip.left -= xAxisDecreasingLeft;
    },

    /**
     * Register series dimension.
     */
    registerSeriesDimension: function() {
        var seriesDimension = this._makeSeriesDimension();

        this._registerDimension('series', seriesDimension);
    },

    /**
     * Register bounds data.
     */
    registerBoundsData: function() {
        this._registerCenterComponentsDimension();

        if (this.hasAxes) {
            this._registerAxisComponentsDimension();
        }

        this._registerPositions();
        this._registerExtendedSeriesBound();

        if (this.options.yAxis.isCenter) {
            this._updateBoundsForYAxisCenterOption();
        }
    }
});

module.exports = BoundsMaker;

},{"../const":20,"./calculator":43,"./predicate":47,"./renderUtil":49}],43:[function(require,module,exports){
/**
 * @fileoverview calculator.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/*eslint no-magic-numbers: [1, {ignore: [-1, 0, 1, 2, 10, 20, 6, 0.1]}]*/

var chartConst = require('../const');

/**
 * Calculator.
 * @module calculator
 */
var calculator = {
    /**
     * Calculate limit from chart min, max data.
     *  - http://peltiertech.com/how-excel-calculates-automatic-chart-axis-limits/
     * @memberOf module:calculator
     * @param {number} min min minimum value of user data
     * @param {number} max max maximum value of user data
     * @param {number} tickCount tick count
     * @returns {{min: number, max: number}} limit axis limit
     */
    calculateLimit: function(min, max) {
        var saveMin = 0,
            limit = {},
            iodValue; // increase or decrease value;

        if (min < 0) {
            saveMin = min;
            max -= min;
            min = 0;
        }

        iodValue = (max - min) / 20;
        limit.max = max + iodValue + saveMin;

        if (max / 6 > min) {
            limit.min = 0 + saveMin;
        } else {
            limit.min = min - iodValue + saveMin;
        }
        return limit;
    },

    /**
     * Normalize number.
     * @memberOf module:calculator
     * @param {number} value target value
     * @returns {number} normalized number
     */
    normalizeAxisNumber: function(value) {
        var standard = 0,
            flag = 1,
            normalized, mod;

        if (value === 0) {
            return value;
        } else if (value < 0) {
            flag = -1;
        }

        value *= flag;

        tui.util.forEachArray(chartConst.AXIS_STANDARD_MULTIPLE_NUMS, function(num) {
            if (value < num) {
                if (num > 1) {
                    standard = num;
                }
                return false;
            } else if (num === chartConst.AXIS_LAST_STANDARD_MULTIPLE_NUM) {
                standard = num;
            }

            return true;
        });

        if (standard < 1) {
            normalized = this.normalizeAxisNumber(value * 10) * 0.1;
        } else {
            mod = tui.util.mod(value, standard);
            normalized = tui.util.addition(value, (mod > 0 ? standard - mod : 0));
        }

        normalized *= flag;

        return normalized;
    },

    /**
     * Make tick positions of pixel type.
     * @memberOf module:calculator
     * @param {number} size area width or height
     * @param {number} count tick count
     * @param {?number} additionalPosition additional position
     * @returns {Array.<number>} positions
     */
    makeTickPixelPositions: function(size, count, additionalPosition) {
        var positions = [],
            pxLimit, pxStep;

        additionalPosition = additionalPosition || 0;

        if (count > 0) {
            pxLimit = {min: 0, max: size - 1};
            pxStep = this.calculateStepFromLimit(pxLimit, count);
            positions = tui.util.map(tui.util.range(0, size, pxStep), function(position) {
                return Math.round(position + additionalPosition);
            });
            positions[positions.length - 1] = Math.round(size - 1 + additionalPosition);
        }

        return positions;
    },

    /**
     * Make labels from limit.
     * @memberOf module:calculator
     * @param {{min: number, max: number}} limit axis limit
     * @param {number} step step between max and min
     * @returns {string[]} labels
     * @private
     */
    makeLabelsFromLimit: function(limit, step) {
        var multipleNum = tui.util.findMultipleNum(step),
            min = limit.min * multipleNum,
            max = limit.max * multipleNum,
            labels = tui.util.range(min, max + 1, step * multipleNum);
        labels = tui.util.map(labels, function(label) {
            return label / multipleNum;
        });
        return labels;
    },

    /**
     * Calculate step from limit.
     * @memberOf module:calculator
     * @param {{min: number, max: number}} limit axis limit
     * @param {number} count value count
     * @returns {number} step
     */
    calculateStepFromLimit: function(limit, count) {
        return (limit.max - limit.min) / (count - 1);
    },

    /**
     * Calculate adjacent.
     * @param {number} degree degree
     * @param {number} hypotenuse hypotenuse
     * @returns {number} adjacent
     *
     *   H : Hypotenuse
     *   A : Adjacent
     *   O : Opposite
     *   D : Degree
     *
     *        /|
     *       / |
     *    H /  | O
     *     /   |
     *    /\ D |
     *    -----
     *       A
     */
    calculateAdjacent: function(degree, hypotenuse) {
        return Math.cos(degree * chartConst.RAD) * hypotenuse;
    },

    /**
     * Calculate opposite.
     * @param {number} degree degree
     * @param {number} hypotenuse hypotenuse
     * @returns {number} opposite
     */
    calculateOpposite: function(degree, hypotenuse) {
        return Math.sin(degree * chartConst.RAD) * hypotenuse;
    },

    /**
     * Sum plus values.
     * @param {Array.<number>} values values
     * @returns {number} sum
     */
    sumPlusValues: function(values) {
        var plusValues = tui.util.filter(values, function(value) {
            return value > 0;
        });
        return tui.util.sum(plusValues);
    },

    /**
     * Sum minus values.
     * @param {Array.<number>} values values
     * @returns {number} sum
     */
    sumMinusValues: function(values) {
        var minusValues = tui.util.filter(values, function(value) {
            return value < 0;
        });
        return tui.util.sum(minusValues);
    }
};

module.exports = calculator;

},{"../const":20}],44:[function(require,module,exports){
/**
 * @fileoverview Utility methods to manipulate colors
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

/*eslint no-magic-numbers: [1, {ignore: [-1, 0, 1, 2, 4, 16]}]*/

var hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;

/**
 * Color map.
 * http://stackoverflow.com/questions/1573053/javascript-function-to-convert-color-names-to-hex-codes
 * http://www.w3schools.com/HTML/html_colornames.asp
 * @type {object}
 */
var colorMap = {
    'aliceblue': '#f0f8ff',
    'antiquewhite': '#faebd7',
    'aqua': '#00ffff',
    'aquamarine': '#7fffd4',
    'azure': '#f0ffff',
    'beige': '#f5f5dc',
    'bisque': '#ffe4c4',
    'black': '#000000',
    'blanchedalmond': '#ffebcd',
    'blue': '#0000ff',
    'blueviolet': '#8a2be2',
    'brown': '#a52a2a',
    'burlywood': '#deb887',
    'cadetblue': '#5f9ea0',
    'chartreuse': '#7fff00',
    'chocolate': '#d2691e',
    'coral': '#ff7f50',
    'cornflowerblue': '#6495ed',
    'cornsilk': '#fff8dc',
    'crimson': '#dc143c',
    'cyan': '#00ffff',
    'darkblue': '#00008b',
    'darkcyan': '#008b8b',
    'darkgoldenrod': '#b8860b',
    'darkgray': '#a9a9a9',
    'darkgreen': '#006400',
    'darkkhaki': '#bdb76b',
    'darkmagenta': '#8b008b',
    'darkolivegreen': '#556b2f',
    'darkorange': '#ff8c00',
    'darkorchid': '#9932cc',
    'darkred': '#8b0000',
    'darksalmon': '#e9967a',
    'darkseagreen': '#8fbc8f',
    'darkslateblue': '#483d8b',
    'darkslategray': '#2f4f4f',
    'darkturquoise': '#00ced1',
    'darkviolet': '#9400d3',
    'deeppink': '#ff1493',
    'deepskyblue': '#00bfff',
    'dimgray': '#696969',
    'dodgerblue': '#1e90ff',
    'firebrick': '#b22222',
    'floralwhite': '#fffaf0',
    'forestgreen': '#228b22',
    'fuchsia': '#ff00ff',
    'gainsboro': '#dcdcdc',
    'ghostwhite': '#f8f8ff',
    'gold': '#ffd700',
    'goldenrod': '#daa520',
    'gray': '#808080',
    'green': '#008000',
    'greenyellow': '#adff2f',
    'honeydew': '#f0fff0',
    'hotpink': '#ff69b4',
    'indianred ': '#cd5c5c',
    'indigo': '#4b0082',
    'ivory': '#fffff0',
    'khaki': '#f0e68c',
    'lavender': '#e6e6fa',
    'lavenderblush': '#fff0f5',
    'lawngreen': '#7cfc00',
    'lemonchiffon': '#fffacd',
    'lightblue': '#add8e6',
    'lightcoral': '#f08080',
    'lightcyan': '#e0ffff',
    'lightgoldenrodyellow': '#fafad2',
    'lightgrey': '#d3d3d3',
    'lightgreen': '#90ee90',
    'lightpink': '#ffb6c1',
    'lightsalmon': '#ffa07a',
    'lightseagreen': '#20b2aa',
    'lightskyblue': '#87cefa',
    'lightslategray': '#778899',
    'lightsteelblue': '#b0c4de',
    'lightyellow': '#ffffe0',
    'lime': '#00ff00',
    'limegreen': '#32cd32',
    'linen': '#faf0e6',
    'magenta': '#ff00ff',
    'maroon': '#800000',
    'mediumaquamarine': '#66cdaa',
    'mediumblue': '#0000cd',
    'mediumorchid': '#ba55d3',
    'mediumpurple': '#9370d8',
    'mediumseagreen': '#3cb371',
    'mediumslateblue': '#7b68ee',
    'mediumspringgreen': '#00fa9a',
    'mediumturquoise': '#48d1cc',
    'mediumvioletred': '#c71585',
    'midnightblue': '#191970',
    'mintcream': '#f5fffa',
    'mistyrose': '#ffe4e1',
    'moccasin': '#ffe4b5',
    'navajowhite': '#ffdead',
    'navy': '#000080',
    'oldlace': '#fdf5e6',
    'olive': '#808000',
    'olivedrab': '#6b8e23',
    'orange': '#ffa500',
    'orangered': '#ff4500',
    'orchid': '#da70d6',
    'palegoldenrod': '#eee8aa',
    'palegreen': '#98fb98',
    'paleturquoise': '#afeeee',
    'palevioletred': '#d87093',
    'papayawhip': '#ffefd5',
    'peachpuff': '#ffdab9',
    'peru': '#cd853f',
    'pink': '#ffc0cb',
    'plum': '#dda0dd',
    'powderblue': '#b0e0e6',
    'purple': '#800080',
    'red': '#ff0000',
    'rosybrown': '#bc8f8f',
    'royalblue': '#4169e1',
    'saddlebrown': '#8b4513',
    'salmon': '#fa8072',
    'sandybrown': '#f4a460',
    'seagreen': '#2e8b57',
    'seashell': '#fff5ee',
    'sienna': '#a0522d',
    'silver': '#c0c0c0',
    'skyblue': '#87ceeb',
    'slateblue': '#6a5acd',
    'slategray': '#708090',
    'snow': '#fffafa',
    'springgreen': '#00ff7f',
    'steelblue': '#4682b4',
    'tan': '#d2b48c',
    'teal': '#008080',
    'thistle': '#d8bfd8',
    'tomato': '#ff6347',
    'turquoise': '#40e0d0',
    'violet': '#ee82ee',
    'wheat': '#f5deb3',
    'white': '#ffffff',
    'whitesmoke': '#f5f5f5',
    'yellow': '#ffff00',
    'yellowgreen': '#9acd32'
};

var colorutil = {
    /**
     * pad left zero characters.
     * @param {number} number number value to pad zero.
     * @param {number} length pad length to want.
     * @returns {string} padded string.
     */
    leadingZero: function(number, length) {
        var zero = '',
            i = 0;

        if (String(number).length > length) {
            return String(number);
        }

        for (; i < (length - 1); i += 1) {
            zero += '0';
        }

        return (zero + number).slice(length * -1);
    },

    /**
     * Check validate of hex string value is RGB
     * @param {string} str - rgb hex string
     * @returns {boolean} return true when supplied str is valid RGB hex string
     */
    isValidRGB: function(str) {
        return hexRX.test(str);
    },

    /**
     * Convert color hex string to rgb number array
     * @param {string} hexStr - hex string
     * @returns {number[]} rgb numbers
     */
    hexToRGB: function(hexStr) {
        var r, g, b;

        if (!colorutil.isValidRGB(hexStr)) {
            return false;
        }

        hexStr = hexStr.substring(1);

        r = parseInt(hexStr.substr(0, 2), 16);
        g = parseInt(hexStr.substr(2, 2), 16);
        b = parseInt(hexStr.substr(4, 2), 16);

        return [r, g, b];
    },

    /**
     * Convert rgb number to hex string
     * @param {number} r - red
     * @param {number} g - green
     * @param {number} b - blue
     * @returns {string|boolean} return false when supplied rgb number is not valid. otherwise, converted hex string
     */
    rgbToHEX: function(r, g, b) {
        var hexStr = '#' +
            colorutil.leadingZero(r.toString(16), 2) +
            colorutil.leadingZero(g.toString(16), 2) +
            colorutil.leadingZero(b.toString(16), 2);

        if (colorutil.isValidRGB(hexStr)) {
            return hexStr;
        }

        return false;
    },

    /**
     * Color name to hex.
     * @param {string} colorName color name
     * @returns {string} hex
     */
    colorNameToHex: function(colorName) {
        return colorMap[colorName.toLowerCase()] || colorName;
    }
};

tui.util.defineNamespace('tui.chart');
tui.chart.colorutil = colorutil;

module.exports = colorutil;

},{}],45:[function(require,module,exports){
/**
 * @fileoverview DOM Handler.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var aps = Array.prototype.slice;

/**
 * DOM Handler.
 * @module domHandler
 */
var domHandler = {
    /**
     * Create element.
     * @memberOf module:domHandler
     * @param {string} tag html tag
     * @param {string} newClass class name
     * @returns {HTMLElement} created element
     */
    create: function(tag, newClass) {
        var el = document.createElement(tag);

        if (newClass) {
            this.addClass(el, newClass);
        }

        return el;
    },

    /**
     * Get class names.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @returns {Array} names
     * @private
     */
    _getClassNames: function(el) {
        var className, classNames;

        if (el.classList) {
            classNames = aps.call(el.classList);
        } else {
            className = el.className || '';
            classNames = className && tui.util.isString(className) ? className.split(' ') : [];
        }

        return classNames;
    },

    /**
     * Add css class to target element.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} newClass add class name
     */
    addClass: function(el, newClass) {
        var classNames, index;

        if (!el || !newClass) {
            return;
        }

        classNames = this._getClassNames(el);
        index = tui.util.inArray(newClass, classNames);

        if (index > -1) {
            return;
        }

        classNames.push(newClass);
        el.className = classNames.join(' ');
    },

    /**
     * Remove css class from target element.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} rmClass remove class name
     */
    removeClass: function(el, rmClass) {
        var classNames = this._getClassNames(el),
            index = tui.util.inArray(rmClass, classNames);

        if (index === -1) {
            return;
        }

        classNames.splice(index, 1);
        el.className = classNames.join(' ');
    },

    /**
     * Whether class exist or not.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} findClass target css class
     * @returns {boolean} has class
     */
    hasClass: function(el, findClass) {
        var classNames = this._getClassNames(el),
            index = tui.util.inArray(findClass, classNames);
        return index > -1;
    },

    /**
     * Find parent by class name.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} className target css class
     * @param {string} lastClass last css class
     * @returns {HTMLElement} result element
     */
    findParentByClass: function(el, className, lastClass) {
        var parent = el.parentNode,
            result;

        if (!parent) {
            result = null;
        } else if (this.hasClass(parent, className)) {
            result = parent;
        } else if (parent.nodeName === 'BODY' || this.hasClass(parent, lastClass)) {
            result = null;
        } else {
            result = this.findParentByClass(parent, className, lastClass);
        }

        return result;
    },

    /**
     * Append child element.
     * @memberOf module:domHandler
     * @param {HTMLElement} container container element
     * @param {HTMLElement} children child element
     */
    append: function(container, children) {
        if (!container || !children) {
            return;
        }
        children = tui.util.isArray(children) ? children : [children];

        tui.util.forEachArray(children, function(child) {
            if (!child) {
                return;
            }
            container.appendChild(child);
        });
    }
};

module.exports = domHandler;

},{}],46:[function(require,module,exports){
/**
 * @fileoverview Event listener.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * Event listener.
 * @module eventListener
 */
var eventListener = {
    /**
     * Event listener for IE.
     * @memberOf module:eventListener
     * @param {string} eventName event name
     * @param {HTMLElement} el target element
     * @param {function} callback callback function
     * @param {?object} context context for callback
     * @private
     */
    _attachEvent: function(eventName, el, callback, context) {
        if (context) {
            callback = tui.util.bind(callback, context);
        }
        el.attachEvent('on' + eventName, callback);
    },

    /**
     * Event listener for other browsers.
     * @memberOf module:eventListener
     * @param {string} eventName event name
     * @param {HTMLElement} el target element
     * @param {function} callback callback function
     * @param {?object} context context for callback
     * @private
     */
    _addEventListener: function(eventName, el, callback, context) {
        if (context) {
            callback = tui.util.bind(callback, context);
        }

        el.addEventListener(eventName, callback);
    },
    /**
     * Bind event function.
     * @memberOf module:eventListener
     * @param {string} eventName event name
     * @param {HTMLElement} target target element
     * @param {function} callback callback function
     * @param {?object} context context for callback
     */
    bindEvent: function(eventName, target, callback, context) {
        var bindEvent;
        if ('addEventListener' in target) {
            bindEvent = this._addEventListener;
        } else if ('attachEvent' in target) {
            bindEvent = this._attachEvent;
        }
        this.bindEvent = bindEvent;

        bindEvent(eventName, target, callback, context);
    }
};

module.exports = eventListener;

},{}],47:[function(require,module,exports){
/**
 * @fileoverview Predicate.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

/**
 * predicate.
 * @module predicate
 */
var predicate = {
    /**
     * Whether bar chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isBarChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_BAR;
    },

    /**
     * Whether column chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isColumnChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_COLUMN;
    },

    /**
     * Whether bar type chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isBarTypeChart: function(chartType) {
        return this.isBarChart(chartType) || this.isColumnChart(chartType);
    },

    /**
     * Whether combo chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isComboChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_COMBO;
    },

    /**
     * Whether line chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isLineChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_LINE;
    },

    /**
     * Whether area chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isAreaChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_AREA;
    },

    /**
     * Whether line type chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isLineTypeChart: function(chartType) {
        return this.isLineChart(chartType) || this.isAreaChart(chartType);
    },

    /**
     * Whether bubble chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isBubbleChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_BUBBLE;
    },

    /**
     * Whether pie chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isPieChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_PIE;
    },

    /**
     * Whether map chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isMapChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_MAP;
    },

    /**
     * Whether allow rendering for minus point in area of series.
     * @memberOf module:predicate
     * @param {string} chartType - chart type
     * @returns {boolean}
     */
    allowMinusPointRender: function(chartType) {
        return this.isLineTypeChart(chartType) || this.isBubbleChart(chartType);
    },

    /**
     * Whether mouse position chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isMousePositionChart: function(chartType) {
        return this.isPieChart(chartType) || this.isMapChart(chartType) || this.isBubbleChart(chartType);
    },

    /**
     * Whether align of legend is outer or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isLegendAlignOuter: function(align) {
        return align === chartConst.LEGEND_ALIGN_OUTER;
    },

    /**
     * Whether align of legend is center or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isLegendAlignCenter: function(align) {
        return align === chartConst.LEGEND_ALIGN_CENTER;
    },

    /**
     * Whether align of legend is left or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isLegendAlignLeft: function(align) {
        return align === chartConst.LEGEND_ALIGN_LEFT;
    },

    /**
     * Whether align of legend is top or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isLegendAlignTop: function(align) {
        return align === chartConst.LEGEND_ALIGN_TOP;
    },

    /**
     * Whether align of legend is bottom or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isLegendAlignBottom: function(align) {
        return align === chartConst.LEGEND_ALIGN_BOTTOM;
    },

    /**
     * Whether horizontal legend align or not.
     * @memberOf module:predicate
     * @param {string} align align
     * @returns {boolean} result boolean
     */
    isHorizontalLegend: function(align) {
        return this.isLegendAlignTop(align) || this.isLegendAlignBottom(align);
    },

    /**
     * Whether legend align of pie chart or not.
     * @memberOf module:predicate
     * @param {?string} align chart type
     * @returns {boolean} result boolean
     */
    isPieLegendAlign: function(align) {
        var result = false;
        if (align) {
            result = this.isLegendAlignOuter(align) || this.isLegendAlignCenter(align);
        }
        return result;
    },

    /**
     * Whether allowed stacked option or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isAllowedStackedOption: function(chartType) {
        return this.isBarChart(chartType) || this.isColumnChart(chartType) || this.isAreaChart(chartType);
    },

    /**
     * Whether normal stacked or not.
     * @memberOf module:predicate
     * @param {boolean} stacked stacked option
     * @returns {boolean} result boolean
     */
    isNormalStacked: function(stacked) {
        return stacked === chartConst.STACKED_NORMAL_TYPE;
    },

    /**
     * Whether percent stacked or not.
     * @memberOf module:predicate
     * @param {boolean} stacked stacked option
     * @returns {boolean} result boolean
     */
    isPercentStacked: function(stacked) {
        return stacked === chartConst.STACKED_PERCENT_TYPE;
    },

    /**
     * Whether valid stacked option or not.
     * @memberOf module:predicate
     * @param {boolean} stacked stacked option
     * @returns {boolean} result boolean
     */
    isValidStackedOption: function(stacked) {
        return stacked && (this.isNormalStacked(stacked) || this.isPercentStacked(stacked));
    },

    /**
     * Whether allow range data or not.
     * @param {string} chartType - chart type
     * @returns {boolean}
     */
    isAllowRangeData: function(chartType) {
        return this.isBarTypeChart(chartType) || this.isAreaChart(chartType);
    },

    /**
     * Whether align of yAxis is center or not.
     * @memberOf module:predicate
     * @param {boolean} hasRightYAxis whether has right yAxis.
     * @param {string} alignOption align option of yAxis.
     * @returns {boolean} whether align center or not.
     */
    isYAxisAlignCenter: function(hasRightYAxis, alignOption) {
        return !hasRightYAxis && (alignOption === chartConst.YAXIS_ALIGN_CENTER);
    },

    /**
     * Whether minus limit or not.
     * @param {{min: number, max: number}} limit limit
     * @returns {boolean}
     */
    isMinusLimit: function(limit) {
        return limit.min <= 0 && limit.max <= 0;
    },

    /**
     * Whether options.hidden is true or not.
     * @param {object} [options] - options
     * @returns {boolean}
     */
    isHidden: function(options) {
        return !!tui.util.pick(options, 'hidden');
    }
};

module.exports = predicate;

},{"../const":20}],48:[function(require,module,exports){
/**
 * @fileoverview Raw data handler.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

/**
 * Raw data Handler.
 * @module rawDataHandler
 */
var rawDataHandler = {
    /**
     * Pick stacks.
     * @param {Array.<{stack: string}>} seriesData raw series data
     * @returns {Array.<string>} stacks
     */
    pickStacks: function(seriesData) {
        var stacks, uniqStacks, filteredStack;

        stacks = tui.util.map(seriesData, function(seriesDatum) {
            return seriesDatum.stack;
        });

        uniqStacks = tui.util.unique(stacks).slice(0, 2);

        filteredStack = tui.util.filter(uniqStacks, function(stack) {
            return !!stack;
        });

        if (filteredStack.length < uniqStacks.length) {
            filteredStack.push(chartConst.DEFAULT_STACK);
        }

        return filteredStack;
    },

    /**
     * Sort series data from stacks.
     * @param {Array.<{stack: ?string}>} seriesData series data
     * @param {Array.<string>} stacks stacks
     * @returns {Array}
     */
    sortSeriesData: function(seriesData, stacks) {
        var newSeriesData = [];

        tui.util.forEachArray(stacks, function(stack) {
            var filtered = tui.util.filter(seriesData, function(datum) {
                return (datum.stack || chartConst.DEFAULT_STACK) === stack;
            });
            newSeriesData = newSeriesData.concat(filtered);
        });

        return newSeriesData;
    },

    /**
     * Remove stack of series data.
     * @param {Array.<{stack: ?string}>} seriesData series data
     */
    removeSeriesStack: function(seriesData) {
        tui.util.forEachArray(seriesData, function(datum) {
            delete datum.stack;
        });
    }
};

module.exports = rawDataHandler;

},{"../const":20}],49:[function(require,module,exports){
/**
 * @fileoverview Util for rendering.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/*eslint no-magic-numbers: [1, {ignore: [-1, 0, 1, 2, 7, 8]}]*/

var dom = require('./domHandler'),
    chartConst = require('./../const');

var concat = Array.prototype.concat;

var browser = tui.util.browser,
    isIE7 = browser.msie && browser.version === 7,
    isOldBrowser = browser.msie && browser.version <= 8;

/**
 * Util for rendering.
 * @module renderUtil
 */
var renderUtil = {
    /**
     * Concat string.
     * @memberOf module:renderUtil
     * @params {...string} target strings
     * @returns {string} concat string
     */
    concatStr: function() {
        return String.prototype.concat.apply('', arguments);
    },

    /**
     * Make cssText for font.
     * @memberOf module:renderUtil
     * @param {{fontSize: number, fontFamily: string, color: string}} theme font theme
     * @returns {string} cssText
     */
    makeFontCssText: function(theme) {
        var cssTexts = [];

        if (!theme) {
            return '';
        }

        if (theme.fontSize) {
            cssTexts.push(this.concatStr('font-size:', theme.fontSize, 'px'));
        }

        if (theme.fontFamily) {
            cssTexts.push(this.concatStr('font-family:', theme.fontFamily));
        }

        if (theme.color) {
            cssTexts.push(this.concatStr('color:', theme.color));
        }

        return cssTexts.join(';');
    },

    checkEl: null,
    /**
     * Create element for size check.
     * @memberOf module:renderUtil
     * @returns {HTMLElement} element
     * @private
     */
    _createSizeCheckEl: function() {
        var div, span;
        if (!this.checkEl) {
            div = dom.create('DIV', 'tui-chart-size-check-element');
            span = dom.create('SPAN');
            div.appendChild(span);
            this.checkEl = div;
        } else {
            this.checkEl.style.cssText = '';
        }

        return this.checkEl;
    },

    /**
     * Make caching key.
     * @param {string} label labek
     * @param {{fontSize: number, fontFamily: string}} theme theme
     * @param {string} offsetType offset type (offsetWidth or offsetHeight)
     * @returns {string} key
     * @private
     */
    _makeCachingKey: function(label, theme, offsetType) {
        var keys = [label, offsetType];

        tui.util.forEach(theme, function(key, value) {
            keys.push(key + value);
        });

        return keys.join('-');
    },

    /**
     * Size cache.
     * @type {object}
     */
    sizeCache: {},

    /**
     * Add css style.
     * @param {HTMLElement} div div element
     * @param {{fontSize: number, fontFamily: string, cssText: string}} theme theme
     * @private
     */
    _addCssStyle: function(div, theme) {
        div.style.fontSize = (theme.fontSize || chartConst.DEFAULT_LABEL_FONT_SIZE) + 'px';

        if (theme.fontFamily) {
            div.style.fontFamily = theme.fontFamily;
        }

        if (theme.cssText) {
            div.style.cssText += theme.cssText;
        }
    },

    /**
     * Get rendered label size (width or height).
     * @memberOf module:renderUtil
     * @param {string | number} label label
     * @param {object} theme theme
     * @param {string} offsetType offset type (offsetWidth or offsetHeight)
     * @returns {number} size
     * @private
     */
    _getRenderedLabelSize: function(label, theme, offsetType) {
        var key, div, span, labelSize;

        theme = theme || {};

        label = tui.util.isExisty(label) ? String(label) : '';

        if (!label) {
            return 0;
        }

        key = this._makeCachingKey(label, theme, offsetType);
        labelSize = this.sizeCache[key];

        if (!labelSize) {
            div = this._createSizeCheckEl();
            span = div.firstChild;

            span.innerHTML = label;

            this._addCssStyle(div, theme);

            document.body.appendChild(div);
            labelSize = span[offsetType];
            document.body.removeChild(div);

            this.sizeCache[key] = labelSize;
        }

        return labelSize;
    },

    /**
     * Get rendered label width.
     * @memberOf module:renderUtil
     * @param {string} label label
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} width
     */
    getRenderedLabelWidth: function(label, theme) {
        var labelWidth = this._getRenderedLabelSize(label, theme, 'offsetWidth');
        return labelWidth;
    },

    /**
     * Get rendered label height.
     * @memberOf module:renderUtil
     * @param {string} label label
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} height
     */
    getRenderedLabelHeight: function(label, theme) {
        var labelHeight = this._getRenderedLabelSize(label, theme, 'offsetHeight');
        return labelHeight;
    },

    /**
     * Get Rendered Labels Max Size(width or height).
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @param {function} iteratee iteratee
     * @returns {number} max size (width or height)
     * @private
     */
    _getRenderedLabelsMaxSize: function(labels, theme, iteratee) {
        var maxSize = 0,
            sizes;

        if (labels && labels.length) {
            sizes = tui.util.map(labels, function(label) {
                return iteratee(label, theme);
            });
            maxSize = tui.util.max(sizes);
        }

        return maxSize;
    },

    /**
     * Get rendered labels max width.
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} max width
     * @private
     */
    getRenderedLabelsMaxWidth: function(labels, theme) {
        var iteratee = tui.util.bind(this.getRenderedLabelWidth, this),
            maxWidth = this._getRenderedLabelsMaxSize(labels, theme, iteratee);
        return maxWidth;
    },

    /**
     * Get rendered labels max height.
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} max height
     */
    getRenderedLabelsMaxHeight: function(labels, theme) {
        var iteratee = tui.util.bind(this.getRenderedLabelHeight, this),
            maxHeight = this._getRenderedLabelsMaxSize(labels, theme, iteratee);
        return maxHeight;
    },

    /**
     * Render dimension.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {{width: number, height: number}} dimension dimension
     */
    renderDimension: function(el, dimension) {
        el.style.cssText = [
            this.concatStr('width:', dimension.width, 'px'),
            this.concatStr('height:', dimension.height, 'px')
        ].join(';');
    },

    /**
     * Render position(top, right).
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {{top: number, left: number, right: number}} position position
     */
    renderPosition: function(el, position) {
        if (tui.util.isUndefined(position)) {
            return;
        }

        if (!tui.util.isUndefined(position.top)) {
            el.style.top = position.top + 'px';
        }

        if (!tui.util.isUndefined(position.left)) {
            el.style.left = position.left + 'px';
        }

        if (!tui.util.isUndefined(position.right)) {
            el.style.right = position.right + 'px';
        }
    },

    /**
     * Render background.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {string} background background option
     */
    renderBackground: function(el, background) {
        if (!background) {
            return;
        }

        el.style.background = background;
    },

    /**
     * Render font family.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {string} fontFamily font family option
     */
    renderFontFamily: function(el, fontFamily) {
        if (!fontFamily) {
            return;
        }

        el.style.fontFamily = fontFamily;
    },

    /**
     * Render title.
     * @memberOf module:renderUtil
     * @param {string} title title
     * @param {{fontSize: number, color: string, background: string}} theme title theme
     * @param {string} className css class name
     * @returns {HTMLElement} title element
     */
    renderTitle: function(title, theme, className) {
        var elTitle, cssText;

        if (!title) {
            return null;
        }

        elTitle = dom.create('DIV', className);
        elTitle.innerHTML = title;

        cssText = renderUtil.makeFontCssText(theme);

        if (theme.background) {
            cssText += ';' + this.concatStr('background:', theme.background);
        }

        elTitle.style.cssText = cssText;

        return elTitle;
    },

    /**
     * Expand dimension.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound series bound
     * @returns {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} expended bound
     */
    expandBound: function(bound) {
        var dimension = bound.dimension,
            position = bound.position;
        return {
            dimension: {
                width: dimension.width + chartConst.SERIES_EXPAND_SIZE * 2,
                height: dimension.height + chartConst.SERIES_EXPAND_SIZE * 2
            },
            position: {
                left: position.left - chartConst.SERIES_EXPAND_SIZE,
                top: position.top - chartConst.SERIES_EXPAND_SIZE
            }
        };
    },

    /**
     * Make custom event name.
     * @param {string} prefix prefix
     * @param {string} value value
     * @param {string} suffix suffix
     * @returns {string} custom event name
     */
    makeCustomEventName: function(prefix, value, suffix) {
        return prefix + tui.util.properCase(value) + tui.util.properCase(suffix);
    },

    /**
     * Format value.
     * @param {number} value value
     * @param {Array.<function>} formatFunctions - functions for format
     * @param {string} areaType - type of area like yAxis, xAxis, series, circleLegend
     * @param {string} [valueType] - value type
     * @returns {string} formatted value
     */
    formatValue: function(value, formatFunctions, areaType, valueType) {
        var fns = [value].concat(formatFunctions || []);

        valueType = valueType || 'value';

        return tui.util.reduce(fns, function(stored, fn) {
            return fn(stored, areaType, valueType);
        });
    },

    /**
     * Format values.
     * @param {Array.<number>} values values
     * @param {Array.<function>} formatFunctions functions for format
     * @param {string} areaType - type of area like yAxis, xAxis, series, circleLegend
     * @param {string} valueType - value type
     * @returns {Array.<string>}
     */
    formatValues: function(values, formatFunctions, areaType, valueType) {
        var formatedValues;
        if (!formatFunctions || !formatFunctions.length) {
            return values;
        }
        formatedValues = tui.util.map(values, function(label) {
            return renderUtil.formatValue(label, formatFunctions, areaType, valueType);
        });
        return formatedValues;
    },

    /**
     * Cancel animation
     * @param {{id: number}} animation animaion object
     */
    cancelAnimation: function(animation) {
        if (animation && animation.id) {
            cancelAnimationFrame(animation.id);
            delete animation.id;
        }
    },

    /**
     * Start animation.
     * @param {number} animationTime animation time
     * @param {function} onAnimation animation callback function
     * @returns {{id: number}} requestAnimationFrame id
     */
    startAnimation: function(animationTime, onAnimation) {
        var animation = {},
            startTime;

        /**
         * Animate.
         */
        function animate() {
            var diffTime = (new Date()).getTime() - startTime,
                ratio = Math.min((diffTime / animationTime), 1);

            onAnimation(ratio);

            if (ratio === 1) {
                delete animation.id;
            } else {
                animation.id = requestAnimationFrame(animate);
            }
        }

        startTime = (new Date()).getTime();
        animation.id = requestAnimationFrame(animate);

        return animation;
    },

    /**
     * Whether IE7 or not.
     * @returns {boolean} result boolean
     */
    isIE7: function() {
        return isIE7;
    },

    /**
     * Whether oldBrowser or not.
     * @memberOf module:renderUtil
     * @returns {boolean} result boolean
     */
    isOldBrowser: function() {
        return isOldBrowser;
    },

    /**
     * Format to zero fill.
     * @param {string} value target value
     * @param {number} len length of result
     * @returns {string} formatted value
     * @private
     */
    formatToZeroFill: function(value, len) {
        var zero = '0';

        value = String(value);

        if (value.length >= len) {
            return value;
        }

        while (value.length < len) {
            value = zero + value;
        }

        return value;
    },

    /**
     * Format to Decimal.
     * @param {string} value target value
     * @param {number} len length of under decimal point
     * @returns {string} formatted value
     */
    formatToDecimal: function(value, len) {
        var pow;

        if (len === 0) {
            return Math.round(value);
        }

        pow = Math.pow(10, len);
        value = Math.round(value * pow) / pow;
        value = parseFloat(value).toFixed(len);

        return value;
    },

    /**
     * Format to Comma.
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    formatToComma: function(value) {
        var comma = ',',
            underPointValue = '',
            betweenLen = 3,
            orgValue = value,
            sign, values, lastIndex, formattedValue;

        value = String(value);
        sign = value.indexOf('-') > -1 ? '-' : '';

        if (value.indexOf('.') > -1) {
            values = value.split('.');
            value = String(Math.abs(values[0]));
            underPointValue = '.' + values[1];
        } else {
            value = String(Math.abs(value));
        }

        if (value.length <= betweenLen) {
            formattedValue = orgValue;
        } else {
            values = (value).split('').reverse();
            lastIndex = values.length - 1;
            values = tui.util.map(values, function(char, index) {
                var result = [char];
                if (index < lastIndex && (index + 1) % betweenLen === 0) {
                    result.push(comma);
                }
                return result;
            });
            formattedValue = sign + concat.apply([], values).reverse().join('') + underPointValue;
        }

        return formattedValue;
    }
};

tui.util.defineNamespace('tui.chart');
tui.chart.renderUtil = renderUtil;

module.exports = renderUtil;

},{"./../const":20,"./domHandler":45}],50:[function(require,module,exports){
/**
 * @fileoverview This is template maker.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

module.exports = {
    /**
     * This is template maker.
     * @param {string} html html
     * @returns {function} template function
     * @eaxmple
     *
     *   var template = templateMaker.template('<span>{{ name }}</span>'),
     *       result = template({name: 'John');
     *   console.log(result); // <span>John</span>
     *
     */
    template: function(html) {
        return function(data) {
            var result = html;
            tui.util.forEach(data, function(value, key) {
                var regExp = new RegExp('{{\\s*' + key + '\\s*}}', 'g');
                result = result.replace(regExp, value);
            });
            return result;
        };
    }
};

},{}],51:[function(require,module,exports){
/**
 * @fileoverview UserEventListener is listener of user event.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var UserEventListener = tui.util.defineClass(/** @lends UserEventListener.prototype */ {
    /**
     * Register user event.
     * @param {string} eventName event name
     * @param {function} func event callback
     */
    register: function(eventName, func) {
        this.on(eventName, func);
    }
});

tui.util.CustomEvents.mixin(UserEventListener);

module.exports = UserEventListener;

},{}],52:[function(require,module,exports){
/**
 * @fileoverview  Circle legend component render a legend in the form of overlapping circles
 *                  by representative radius values.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');
var dom = require('../helpers/domHandler');
var renderUtil = require('../helpers/renderUtil');
var pluginFactory = require('../factories/pluginFactory');
var legendTemplate = require('./../legends/legendTemplate');

var CircleLegend = tui.util.defineClass(/** @lends CircleLegend.prototype */ {
    /**
     * css className of circle legend
     * @type {string}
     */
    className: 'tui-chart-circle-legend-area',
    /**
     * ratios for rendering circle
     * @type {Array.<number>}
     */
    circleRatios: [1, 0.5, 0.25],
    /**
     * Circle legend component render a legend in the form of overlapping circles by representative radius values.
     * @constructs CircleLegend
     * @param {object} params parameters
     *      @param {?string} params.libType - library type for graph rendering
     *      @param {string} params.chartType - chart type
     *      @param {DataProcessor} params.dataProcessor - DataProcessor
     *      @param {BoundsMaker} params.boundsMaker - BoundsMaker
     *      @param {string} params.baseFontFamily - base fontFamily of chart
     */
    init: function(params) {
        var libType = params.libType || chartConst.DEFAULT_PLUGIN;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * theme for label of circle legend area
         * @type {{fontSize: number, fontFamily: *}}
         */
        this.labelTheme = {
            fontSize: chartConst.CIRCLE_LEGEND_LABEL_FONT_SIZE,
            fontFamily: params.baseFontFamily
        };

        /**
         * Graph renderer
         * @type {object}
         */
        this.graphRenderer = pluginFactory.get(libType, 'circleLegend');
    },

    /**
     * Format label
     * @param {number} label - label
     * @param {number} decimalLength - decimal length
     * @returns {string}
     * @private
     */
    _formatLabel: function(label, decimalLength) {
        var formatFunctions = this.dataProcessor.getFormatFunctions();

        if (decimalLength === 0) {
            label = String(parseInt(label, 10));
        } else {
            label = String(label);
            label = renderUtil.formatToDecimal(label, decimalLength);
        }

        return renderUtil.formatValue(label, formatFunctions, 'circleLegend', 'r');
    },

    /**
     * Make label html.
     * @returns {string}
     * @private
     */
    _makeLabelHtml: function() {
        var self = this;
        var boundsMaker = this.boundsMaker;
        var dimension = boundsMaker.getDimension('circleLegend');
        var halfWidth = dimension.width / 2;
        var maxPixelRadius = boundsMaker.getMinimumPixelStepForAxis();
        var maxValueRadius = this.dataProcessor.getMaxValue(this.chartType, 'r');
        var decimalLength = tui.util.getDecimalLength(maxValueRadius);
        var labelHeight = renderUtil.getRenderedLabelHeight(maxValueRadius, this.labelTheme);

        return tui.util.map(this.circleRatios, function(ratio) {
            var diameter = maxPixelRadius * ratio * 2;
            var label = self._formatLabel(maxValueRadius * ratio, decimalLength);
            var labelWidth = renderUtil.getRenderedLabelWidth(label, self.labelTheme);
            return legendTemplate.tplCircleLegendLabel({
                left: halfWidth - (labelWidth / 2),
                top: dimension.height - diameter - labelHeight,
                label: label
            });
        }).join('');
    },

    /**
     * Render label area.
     * @private
     */
    _renderLabelArea: function() {
        var labelContainer = dom.create('DIV', 'tui-chart-circle-legend-label-area');

        labelContainer.innerHTML = this._makeLabelHtml();
        this.container.appendChild(labelContainer);
    },

    /**
     * Render for circle legend area.
     * @private
     */
    _render: function() {
        var circleContainer = dom.create('DIV', 'tui-chart-circle-area');
        var maxRadius = this.boundsMaker.getMinimumPixelStepForAxis();
        var dimension = this.boundsMaker.getDimension('circleLegend');
        var position = this.boundsMaker.getPosition('circleLegend');

        this.container.appendChild(circleContainer);

        this.graphRenderer.render(circleContainer, dimension, maxRadius, this.circleRatios);

        this._renderLabelArea();
        renderUtil.renderPosition(this.container, position);
    },

    /**
     * Render.
     * @returns {HTMLElement}
     */
    render: function() {
        var container = dom.create('DIV', this.className);

        this.container = container;
        this._render();
        return container;
    },

    /**
     * Rerender.
     */
    rerender: function() {
        this.container.innerHTML = null;
        this._render();
    },

    /**
     * Resize.
     */
    resize: function() {
        this.rerender();
    }
});

module.exports = CircleLegend;

},{"../const":20,"../factories/pluginFactory":38,"../helpers/domHandler":45,"../helpers/renderUtil":49,"./../legends/legendTemplate":56}],53:[function(require,module,exports){
/**
 * @fileoverview  Legend component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var LegendModel = require('./legendModel'),
    LegendDimensionModel = require('./legendDimensionModel'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    predicate = require('../helpers/predicate'),
    eventListener = require('../helpers/eventListener'),
    renderUtil = require('../helpers/renderUtil'),
    legendTemplate = require('./../legends/legendTemplate');

var Legend = tui.util.defineClass(/** @lends Legend.prototype */ {
    /**
     * Legend component.
     * @constructs Legend
     * @param {object} params parameters
     *      @param {object} params.theme axis theme
     *      @param {?Array.<string>} params.chartTypes chart types
     *      @param {string} params.chart type
     */
    init: function(params) {
        var legendData;

        /**
         * legend theme
         * @type {Object}
         */
        this.theme = params.theme;

        /**
         * options
         * @type {Object}
         */
        this.options = params.options || {};

        /**
         * chart types
         * @type {?Array.<string>}
         */
        this.chartTypes = params.chartTypes;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * user event object
         */
        this.userEvent = params.userEvent;

        /**
         * Legend view className
         */
        this.className = 'tui-chart-legend-area';

        /**
         * checked indexes
         * @type {Array}
         */
        this.checkedIndexes = [];

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        legendData = params.dataProcessor.getLegendData();
        /**
         * legend model
         */
        this.legendModel = new LegendModel({
            theme: this.theme,
            labels: params.dataProcessor.getLegendLabels(),
            legendData: legendData,
            chartTypes: this.chartTypes,
            chartType: this.chartType
        });

        this.dimensionModel = new LegendDimensionModel({
            legendLabels: tui.util.pluck(legendData, 'label'),
            chartType: this.chartType,
            options: this.options,
            theme: this.theme
        });
    },

    /**
     * Register legend dimension.
     */
    registerDimension: function() {
        var chartWidth = this.boundsMaker.getDimension('chart').width;
        var legendDimension = this.dimensionModel.makeDimension(chartWidth);

        this.boundsMaker.registerBaseDimension('legend', legendDimension);

        if (!predicate.isHorizontalLegend(this.options.align) && this.options.hidden !== true) {
            this.boundsMaker.registerBaseDimension('calculationLegend', {
                width: legendDimension.width
            });
        }
    },

    /**
     * Render legend area.
     * @param {HTMLElement} legendContainer legend container
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound lengend bound
     * @param {Array.<boolean>} checkedIndexes checked indexes
     * @private
     */
    _renderLegendArea: function(legendContainer) {
        legendContainer.innerHTML = this._makeLegendHtml(this.legendModel.getData());
        renderUtil.renderPosition(legendContainer, this.boundsMaker.getPosition('legend'));
        legendContainer.style.cssText += ';' + renderUtil.makeFontCssText(this.theme.label);
    },

    /**
     * Render legend component.
     * @returns {HTMLElement} legend element
     */
    render: function() {
        var el = dom.create('DIV', this.className);

        this.legendContainer = el;

        if (predicate.isHorizontalLegend(this.options.align)) {
            dom.addClass(el, 'horizontal');
        }

        this._renderLegendArea(el);
        this._attachEvent(el);
        return el;
    },

    /**
     * Rerender.
     */
    rerender: function() {
        this._renderLegendArea(this.legendContainer);
    },

    /**
     * Resize legend component.
     */
    resize: function() {
        this._renderLegendArea(this.legendContainer);
    },

    /**
     * Make cssText of legend rect.
     * @param {{
     *      chartType: string,
     *      theme: {color: string, borderColor: ?string, singleColor: ?string}
     * }} legendDatum legend datum
     * @param {number} baseMarginTop base margin-top
     * @returns {string} cssText of legend rect
     * @private
     */
    _makeLegendRectCssText: function(legendDatum, baseMarginTop) {
        var theme = legendDatum.theme,
            borderCssText = theme.borderColor ? renderUtil.concatStr(';border:1px solid ', theme.borderColor) : '',
            rectMargin, marginTop;
        if (legendDatum.chartType === 'line') {
            marginTop = baseMarginTop + chartConst.LINE_MARGIN_TOP;
        } else {
            marginTop = baseMarginTop;
        }

        rectMargin = renderUtil.concatStr(';margin-top:', marginTop, 'px');

        return renderUtil.concatStr('background-color:', theme.singleColor || theme.color, borderCssText, rectMargin);
    },


    /**
     * Make labels width.
     * @param {Array.<{chartType: ?string, label: string}>} legendData legend data
     * @returns {Array.<number>} labels width
     * @private
     */
    _makeLabelsWidth: function(legendData) {
        var self = this;

        return tui.util.map(legendData, function(item) {
            var labelWidth = renderUtil.getRenderedLabelWidth(item.label, self.theme.label);
            return labelWidth + chartConst.LEGEND_AREA_PADDING;
        });
    },

    /**
     * Make legend html.
     * @param {Array.<{chartType: ?string, label: string}>} legendData legend data
     * @returns {string} legend html
     * @private
     */
    _makeLegendHtml: function(legendData) {
        var self = this,
            template = legendTemplate.tplLegend,
            checkBoxTemplate = legendTemplate.tplCheckbox,
            labelsWidth = this._makeLabelsWidth(legendData),
            labelHeight = renderUtil.getRenderedLabelHeight(legendData[0].label, legendData[0].theme),
            isHorizontalLegend = predicate.isHorizontalLegend(this.options.align),
            height = labelHeight + (chartConst.LABEL_PADDING_TOP * 2),
            baseMarginTop = parseInt((height - chartConst.LEGEND_RECT_WIDTH) / 2, 10) - 1,
            html = tui.util.map(legendData, function(legendDatum, index) {
                var rectCssText = self._makeLegendRectCssText(legendDatum, baseMarginTop),
                    checkbox = self.options.hasCheckbox === false ? '' : checkBoxTemplate({
                        index: index,
                        checked: self.legendModel.isCheckedIndex(index) ? ' checked' : ''
                    }),
                    data;

                data = {
                    rectCssText: rectCssText,
                    height: height,
                    labelHeight: labelHeight,
                    unselected: self.legendModel.isUnselectedIndex(index) ? ' unselected' : '',
                    labelWidth: isHorizontalLegend ? ';width:' + labelsWidth[index] + 'px' : '',
                    iconType: legendDatum.chartType || 'rect',
                    label: legendDatum.label,
                    checkbox: checkbox,
                    index: index
                };
                return template(data);
            }).join('');
        return html;
    },

    /**
     * Find legend element.
     * @param {HTMLElement} elTarget target element
     * @returns {HTMLElement} legend element
     * @private
     */
    _findLegendLabelElement: function(elTarget) {
        var legendContainer;

        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_LEGEND_LABEL)) {
            legendContainer = elTarget;
        } else {
            legendContainer = dom.findParentByClass(elTarget, chartConst.CLASS_NAME_LEGEND_LABEL);
        }

        return legendContainer;
    },

    /**
     * Fire legend checkbox event.
     * @private
     */
    _fireLegendCheckboxEvent: function() {
        this.fire('changeCheckedLegends', this.legendModel.getCheckedIndexes());
    },

    /**
     * Fire legend event.
     * @param {{chartType: string, index: number}} data data
     * @private
     */
    _fireLegendSelectionEvent: function(data) {
        var self = this,
            chartTypes = this.chartTypes || [data.chartType],
            index = this.legendModel.getSelectedIndex(),
            legendIndex = !tui.util.isNull(index) ? data.seriesIndex : index;

        tui.util.forEachArray(chartTypes, function(chartType) {
            self.fire(renderUtil.makeCustomEventName('select', chartType, 'legend'), data.chartType, legendIndex);
        });
    },

    /**
     * Fire user event.
     * @param {{label: string, chartType: string, index: number}} data data
     * @private
     */
    _fireUserEvent: function(data) {
        this.userEvent.fire('selectLegend', {
            legend: data.label,
            chartType: data.chartType,
            index: data.index
        });
    },

    /**
     * Select legend.
     * @param {number} index index
     * @private
     */
    _selectLegend: function(index) {
        var data = this.legendModel.getDatum(index);

        this.legendModel.toggleSelectedIndex(index);

        if (!tui.util.isNull(this.legendModel.getSelectedIndex()) && !this.legendModel.isCheckedSelectedIndex()) {
            this.legendModel.checkSelectedIndex();
            this._fireLegendCheckboxEvent();
        }

        this._renderLegendArea(this.legendContainer);

        this._fireLegendSelectionEvent(data);
        this._fireUserEvent(data);
    },

    /**
     * Get checked indexes.
     * @returns {Array} checked indexes
     * @private
     */
    _getCheckedIndexes: function() {
        var checkedIndexes = [];
        tui.util.forEachArray(this.legendContainer.getElementsByTagName('input'), function(checkbox, index) {
            if (checkbox.checked) {
                checkedIndexes.push(index);
            }
        });
        return checkedIndexes;
    },

    /**
     * Check legend.
     * @private
     */
    _checkLegend: function() {
        var checkedIndexes = this._getCheckedIndexes(),
            checkedCount = checkedIndexes.length,
            data;

        if ((predicate.isPieChart(this.chartType) && checkedCount === 1) || checkedCount === 0) {
            this._renderLegendArea(this.legendContainer);
        } else {
            this.legendModel.updateCheckedData(checkedIndexes);

            data = this.legendModel.getSelectedDatum();

            if (!this.legendModel.isCheckedSelectedIndex()) {
                this.legendModel.updateSelectedIndex(null);
            }

            this._renderLegendArea(this.legendContainer);

            this._fireLegendCheckboxEvent();

            if (data) {
                this._fireLegendSelectionEvent(data, true);
            }
        }
    },

    /**
     * On click event handler.
     * @param {MouseEvent} e mouse event
     * @private
     */
    _onClick: function(e) {
        var elTarget = e.target || e.srcElement,
            legendContainer, index;

        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_LEGEND_CHECKBOX)) {
            this._checkLegend();
            return;
        }

        legendContainer = this._findLegendLabelElement(elTarget);

        if (!legendContainer) {
            return;
        }

        index = parseInt(legendContainer.getAttribute('data-index'), 10);
        this._selectLegend(index);
    },

    /**
     * Attach browser event.
     * @param {HTMLElement} target target element
     * @private
     */
    _attachEvent: function(target) {
        eventListener.bindEvent('click', target, this._onClick, this);
    }
});

tui.util.CustomEvents.mixin(Legend);

module.exports = Legend;

},{"../const":20,"../helpers/domHandler":45,"../helpers/eventListener":46,"../helpers/predicate":47,"../helpers/renderUtil":49,"./../legends/legendTemplate":56,"./legendDimensionModel":54,"./legendModel":55}],54:[function(require,module,exports){
/**
 * @fileoverview LegendDimensionModel is legend dimension model.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil');

var LegendDimensionModel = tui.util.defineClass(/** @lends LegendDimensionModel.prototype */ {
    /**
     * LegendDimensionModel is legend dimension model.
     * @constructs LegendDimensionModel
     * @param {object} params parameters
     *      @param {string} params.chartType chart type
     *      @param {object} params.options legend options
     *      @param {object} params.theme legend theme
     *      @param {Array.<string | number>} params.legendLabels legend labels
     */
    init: function(params) {
        this.chartType = params.chartType;

        this.options = params.options;

        this.theme = params.theme;

        this.legendLabels = params.legendLabels;

        this.legendCheckboxWidth = this.options.hasCheckbox === false ? 0 : chartConst.LEGEND_CHECKBOX_WIDTH;
    },

    /**
     * Make legend width.
     * @param {number} labelWidth label width
     * @returns {number} legend width
     * @private
     */
    _makeLegendWidth: function(labelWidth) {
        return labelWidth + this.legendCheckboxWidth + chartConst.LEGEND_RECT_WIDTH +
            chartConst.LEGEND_LABEL_LEFT_PADDING + chartConst.LEGEND_AREA_PADDING;
    },

    /**
     * Calculate sum of legends width.
     * @param {Array.<string>} labels legend labels
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {number} sum of width
     * @private
     */
    _calculateLegendsWidthSum: function(labels, labelTheme) {
        var self = this;

        return tui.util.sum(tui.util.map(labels, function(label) {
            return self._makeLegendWidth(renderUtil.getRenderedLabelWidth(label, labelTheme));
        }));
    },

    /**
     * Divide legend labels.
     * @param {Array.<string>} labels legend labels
     * @param {number} count division count
     * @returns {Array.<Array.<string>>} divided labels
     * @private
     */
    _divideLegendLabels: function(labels, count) {
        var limitCount = Math.round(labels.length / count),
            results = [],
            temp = [];

        tui.util.forEachArray(labels, function(label) {
            if (temp.length < limitCount) {
                temp.push(label);
            } else {
                results.push(temp);
                temp = [label];
            }
        });

        if (temp.length) {
            results.push(temp);
        }

        return results;
    },

    /**
     * Get max line width.
     * @param {Array.<string>} dividedLabels divided labels
     * @param {{fontFamily: ?string, fontSize: ?string}} labelTheme label theme
     * @returns {number} max line width
     * @private
     */
    _getMaxLineWidth: function(dividedLabels, labelTheme) {
        var self = this,
            lineWidths = tui.util.map(dividedLabels, function(_labels) {
                return self._calculateLegendsWidthSum(_labels, labelTheme);
            });

        return tui.util.max(lineWidths);
    },

    /**
     * Make division labels and max line width.
     * @param {Array.<string>} labels legend labels
     * @param {number} chartWidth chart width
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {{dividedLabels: Array.<Array.<string>>, maxLineWidth: number}} result
     * @private
     */
    _makeDividedLabelsAndMaxLineWidth: function(labels, chartWidth, labelTheme) {
        var divideCount = 1,
            maxLineWidth = 0,
            prevMaxWidth = 0,
            dividedLabels, prevLabels;

        do {
            dividedLabels = this._divideLegendLabels(labels, divideCount);
            maxLineWidth = this._getMaxLineWidth(dividedLabels, labelTheme);

            if (prevMaxWidth === maxLineWidth) {
                dividedLabels = prevLabels;
                break;
            }

            prevMaxWidth = maxLineWidth;
            prevLabels = dividedLabels;
            divideCount += 1;
        } while (maxLineWidth >= chartWidth);

        return {
            dividedLabels: dividedLabels,
            maxLineWidth: maxLineWidth
        };
    },

    /**
     * Calculate height of horizontal legend.
     * @param {Array.<Array.<string>>} dividedLabels divided labels
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {number} legend height
     * @private
     */
    _calculateHorizontalLegendHeight: function(dividedLabels, labelTheme) {
        return tui.util.sum(tui.util.map(dividedLabels, function(labels) {
            return renderUtil.getRenderedLabelsMaxHeight(labels, labelTheme);
        }));
    },

    /**
     * Make dimension of horizontal legend.
     * @param {number} chartWidth chart width
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {{width: number, height: (number)}} dimension of horizontal legend
     * @private
     */
    _makeHorizontalDimension: function(chartWidth) {
        var labelTheme = this.theme.label,
            labelsAndMaxWidth = this._makeDividedLabelsAndMaxLineWidth(this.legendLabels, chartWidth, labelTheme),
            horizontalLegendHeight = this._calculateHorizontalLegendHeight(labelsAndMaxWidth.dividedLabels, labelTheme),
            legendHeight = horizontalLegendHeight + (chartConst.LEGEND_AREA_PADDING * 2);

        return {
            width: labelsAndMaxWidth.maxLineWidth,
            height: legendHeight
        };
    },

    /**
     * Make dimension of vertical legend.
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {{width: (number)}} dimension of vertical legend
     * @private
     */
    _makeVerticalDimension: function() {
        var maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(this.legendLabels, this.theme.label),
            legendWidth = this._makeLegendWidth(maxLabelWidth);
        return {
            width: legendWidth,
            height: 0
        };
    },

    /**
     * Whether skipped legend sizing or not.
     * @returns {boolean} result boolean
     * @private
     */
    _isSkipLegend: function() {
        var isPieChart = predicate.isPieChart(this.chartType),
            isPieLegendAlign = predicate.isPieChart(this.chartType) && predicate.isPieLegendAlign(this.options.align);

        return (isPieChart && isPieLegendAlign) || this.options.hidden;
    },

    /**
     * Make legend dimension.
     * @param {number} chartWidth chart width
     * @returns {{width: number, height: number}} legend dimention
     */
    makeDimension: function(chartWidth) {
        var dimension = {};

        if (this._isSkipLegend()) {
            dimension.width = 0;
        } else if (predicate.isHorizontalLegend(this.options.align)) {
            dimension = this._makeHorizontalDimension(chartWidth);
        } else {
            dimension = this._makeVerticalDimension();
        }

        return dimension;
    }
});

module.exports = LegendDimensionModel;

},{"../const":20,"../helpers/predicate":47,"../helpers/renderUtil":49}],55:[function(require,module,exports){
/**
 * @fileoverview LegendModel is legend model.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var defaultTheme = require('../themes/defaultTheme');

var concat = Array.prototype.concat;

var LegendModel = tui.util.defineClass(/** @lends LegendModel.prototype */ {
    /**
     * LegendModel is legend model.
     * @constructs LegendModel
     * @param {object} params parameters
     *      @param {number} params.labels legend labels
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        /**
         * legend theme
         * @type {Object}
         */
        this.theme = params.theme;

        /**
         * legend labels
         * @type {Array.<string> | {column: ?Array.<string>, line: ?Array.<string>}}
         */
        this.labels = params.labels;

        /**
         * label infos
         * @type {Array.<{chartType: string, label: string, index: number}>}
         */
        this.legendData = params.legendData;

        /**
         * chart types
         * @type {?Array.<string>}
         */
        this.chartTypes = params.chartTypes;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * Legend data
         * @type {?Array}
         */
        this.data = null;

        /**
         * Selected legend index.
         * @type {?number}
         */
        this.selectedIndex = null;

        /**
         * sending data to series
         * @type {object}
         */
        this.checkedIndexesMap = {};

        /**
         * checked indexes
         * @type {Array}
         */
        this.checkedWholeIndexes = [];

        this._initCheckedIndexes();
        this._setData();
    },

    /**
     * Initialize checked data.
     * @private
     */
    _initCheckedIndexes: function() {
        var checkedWholeIndexes = [];
        tui.util.forEachArray(this.legendData, function(legendDatum, index) {
            checkedWholeIndexes[index] = true;
        });
        this.checkedWholeIndexes = checkedWholeIndexes;
    },

    /**
     * Make label info that applied theme.
     * @param {Array.<object>} legendData legend data
     * @param {{colors: Array.<number>, singleColor: ?string, bordercolor: ?string}} theme legend theme
     * @param {Array.<boolean>} checkedIndexes checked indexes
     * @returns {Array.<object>} labels
     * @private
     */
    _makeLabelInfoAppliedTheme: function(legendData, theme, checkedIndexes) {
        var seriesIndex = 0;

        return tui.util.map(legendData, function(datum, index) {
            var itemTheme = {
                color: theme.colors[index]
            };

            if (theme.singleColors && theme.singleColors.length) {
                itemTheme.singleColor = theme.singleColors[index];
            }

            if (theme.borderColor) {
                itemTheme.borderColor = theme.borderColor;
            }

            datum.theme = itemTheme;
            datum.index = index;

            if (!checkedIndexes || !tui.util.isUndefined(checkedIndexes[index])) {
                datum.seriesIndex = seriesIndex;
                seriesIndex += 1;
            } else {
                datum.seriesIndex = -1;
            }

            return datum;
        });
    },

    /**
     * Set legend data.
     * @private
     */
    _setData: function() {
        var self = this,
            legendData = this.legendData,
            data, defaultLegendTheme, startIndex, startThemeIndex;

        if (!this.chartTypes) {
            data = this._makeLabelInfoAppliedTheme(legendData, this.theme, this.checkedIndexesMap[this.chartType]);
        } else {
            startIndex = 0;
            startThemeIndex = 0;
            defaultLegendTheme = {
                colors: defaultTheme.series.colors
            };
            data = concat.apply([], tui.util.map(this.chartTypes, function(chartType) {
                var chartTheme = self.theme[chartType],
                    labelLen = self.labels[chartType].length,
                    endIndex = startIndex + labelLen,
                    slicedLegendData, checkedIndexes, themeEndIndex, datum;

                if (!chartTheme) {
                    themeEndIndex = startThemeIndex + labelLen;
                    chartTheme = JSON.parse(JSON.stringify(defaultLegendTheme));
                    chartTheme.colors = chartTheme.colors.slice(startThemeIndex, themeEndIndex);
                    startThemeIndex = themeEndIndex;
                }

                slicedLegendData = legendData.slice(startIndex, endIndex);
                checkedIndexes = self.checkedIndexesMap[chartType];
                datum = self._makeLabelInfoAppliedTheme(slicedLegendData, chartTheme, checkedIndexes);
                startIndex = endIndex;
                return datum;
            }));
        }

        this.data = data;
    },

    /**
     * Get legend data.
     * @returns {Array.<{chartType: string, label: string, theme: object}>} legend data
     */
    getData: function() {
        return this.data;
    },

    /**
     * Get legend datum by index.
     * @param {number} index legend index
     * @returns {{chartType: string, label: string, theme: object}} legend datum
     */
    getDatum: function(index) {
        return this.data[index];
    },

    /**
     * Get selected datum.
     * @returns {{chartType: string, label: string, theme: Object}} legend datum
     */
    getSelectedDatum: function() {
        return this.getDatum(this.selectedIndex);
    },

    /**
     * Update selected index.
     * @param {?number} value value
     */
    updateSelectedIndex: function(value) {
        this.selectedIndex = value;
    },

    /**
     * Toggle selected index.
     * @param {number} index legend index
     */
    toggleSelectedIndex: function(index) {
        var selectedIndex;

        if (this.selectedIndex === index) {
            selectedIndex = null;
        } else {
            selectedIndex = index;
        }

        this.updateSelectedIndex(selectedIndex);
    },

    /**
     * Get selected index.
     * @returns {number} selected index
     */
    getSelectedIndex: function() {
        return this.selectedIndex;
    },

    /**
     * Whether unselected index or not.
     * @param {number} index legend index
     * @returns {boolean} true if selected
     */
    isUnselectedIndex: function(index) {
        return !tui.util.isNull(this.selectedIndex) && (this.selectedIndex !== index);
    },

    /**
     * Whether checked selected index or not.
     * @returns {boolean} true if checked
     */
    isCheckedSelectedIndex: function() {
        return this.isCheckedIndex(this.selectedIndex);
    },

    /**
     * Update checked index.
     * @param {number} index legend index
     * @private
     */
    _updateCheckedIndex: function(index) {
        this.checkedWholeIndexes[index] = true;
    },

    /**
     * Whether checked index.
     * @param {number} index legend index
     * @returns {boolean} true if checked
     */
    isCheckedIndex: function(index) {
        return !!this.checkedWholeIndexes[index];
    },


    /**
     * Add sending datum.
     * @param {number} index legend index
     */
    _addSendingDatum: function(index) {
        var legendDatum = this.getDatum(index);
        if (!this.checkedIndexesMap[legendDatum.chartType]) {
            this.checkedIndexesMap[legendDatum.chartType] = [];
        }
        this.checkedIndexesMap[legendDatum.chartType][legendDatum.index] = true;
    },

    /**
     * Check selected index;
     */
    checkSelectedIndex: function() {
        this._updateCheckedIndex(this.selectedIndex);
        this._addSendingDatum(this.selectedIndex);
        this._setData();
    },

    /**
     * Get checked indexes.
     * @returns {{column: ?Array.<boolean>, line: ?Array.<boolean>} | Array.<boolean>} sending data
     */
    getCheckedIndexes: function() {
        return this.checkedIndexesMap[this.chartType] || this.checkedIndexesMap;
    },

    /**
     * Reset checked data.
     * @private
     */
    _resetCheckedData: function() {
        this.checkedWholeIndexes = [];
        this.checkedIndexesMap = {};
    },

    /**
     * Update checked data.
     * @param {Array.<number>} indexes indxes
     */
    updateCheckedData: function(indexes) {
        var self = this;

        this._resetCheckedData();
        tui.util.forEachArray(indexes, function(index) {
            self._updateCheckedIndex(index);
            self._addSendingDatum(index);
        });
        this._setData();
    }
});

module.exports = LegendModel;

},{"../themes/defaultTheme":86}],56:[function(require,module,exports){
/**
 * @fileoverview This is templates of legend view.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var htmls = {
    HTML_CHECKBOX: '<div class="tui-chart-legend-checkbox-area"><input class="tui-chart-legend-checkbox"' +
        ' type="checkbox" value="{{ index }}"{{ checked }} /></div>',
    HTML_LEGEND: '<div class="tui-chart-legend{{ unselected }}" style="height:{{ height }}px">' +
        '{{ checkbox }}<div class="tui-chart-legend-rect {{ iconType }}" style="{{ rectCssText }}"></div>' +
        '<div class="tui-chart-legend-label" style="height:{{ labelHeight }}px{{ labelWidth }}"' +
            ' data-index="{{ index }}">{{ label }}</div></div>',
    HTML_TICK: '<div class="tui-chart-map-legend-tick" style="{{ position }}"></div>' +
        '<div class="tui-chart-map-legend-tick-label" style="{{ labelPosition }}">{{ label }}</div>',
    HTML_CIRCLE_LEGEND_LABEL: '<div class="tui-chart-circle-legend-label"' +
            ' style="left: {{ left }}px;top: {{ top }}px">{{ label }}</div>'
};

module.exports = {
    tplCheckbox: templateMaker.template(htmls.HTML_CHECKBOX),
    tplLegend: templateMaker.template(htmls.HTML_LEGEND),
    tplTick: templateMaker.template(htmls.HTML_TICK),
    tplCircleLegendLabel: templateMaker.template(htmls.HTML_CIRCLE_LEGEND_LABEL)
};

},{"../helpers/templateMaker":50}],57:[function(require,module,exports){
/**
 * @fileoverview  Legend component for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    pluginFactory = require('../factories/pluginFactory'),
    legendTemplate = require('./../legends/legendTemplate');

var MapChartLegend = tui.util.defineClass(/** @lends MapChartLegend.prototype */ {
    /**
     * Legend component for map chart.
     * @constructs MapChartLegend
     * @param {object} params parameters
     *      @param {object} params.theme axis theme
     *      @param {?Array.<string>} params.options legend options
     *      @param {MapChartDataProcessor} params.dataProcessor data processor
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     */
    init: function(params) {
        var libType = params.libType || chartConst.DEFAULT_PLUGIN;

        /**
         * class name.
         * @type {string}
         */
        this.className = 'tui-chart-legend-area';

        /**
         * legend theme
         * @type {Object}
         */
        this.theme = params.theme;

        /**
         * options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Graph renderer
         * @type {object}
         */
        this.graphRenderer = pluginFactory.get(libType, 'mapLegend');

        /**
         * Whether horizontal legend or not.
         * @type {boolean}
         */
        this.isHorizontal = predicate.isHorizontalLegend(this.options.align);
    },

    /**
     * Make vertical legend dimension.
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeVerticalDimension: function() {
        var maxValue = tui.util.max(this.dataProcessor.getValues()),
            formatFunctions = this.dataProcessor.getFormatFunctions(),
            valueStr = renderUtil.formatValue(maxValue, formatFunctions, 'legend'),
            labelWidth = renderUtil.getRenderedLabelWidth(valueStr, this.theme.label),
            padding = chartConst.LEGEND_AREA_PADDING + chartConst.MAP_LEGEND_LABEL_PADDING;

        return {
            width: chartConst.MAP_LEGEND_GRAPH_SIZE + labelWidth + padding,
            height: chartConst.MAP_LEGEND_SIZE
        };
    },

    /**
     * Make horizontal legend dimension
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeHorizontalDimension: function() {
        var maxValue = tui.util.max(this.dataProcessor.getValues()),
            labelHeight = renderUtil.getRenderedLabelHeight(maxValue, this.theme.label),
            padding = chartConst.LEGEND_AREA_PADDING + chartConst.MAP_LEGEND_LABEL_PADDING;

        return {
            width: chartConst.MAP_LEGEND_SIZE,
            height: chartConst.MAP_LEGEND_GRAPH_SIZE + labelHeight + padding
        };
    },

    /**
     * Register dimension.
     */
    registerDimension: function() {
        var dimension;

        if (this.isHorizontal) {
            dimension = this._makeHorizontalDimension();
        } else {
            dimension = this._makeVerticalDimension();
        }

        this.boundsMaker.registerBaseDimension('legend', dimension);
        this.boundsMaker.registerBaseDimension('calculationLegend', dimension);
    },

    /**
     * Make base data to make tick html.
     * @returns {{startPositionValue: number, step: number, positionType: string, labelSize: ?number}} base data
     * @private
     */
    _makeBaseDataToMakeTickHtml: function() {
        var dimension = this.boundsMaker.getDimension('legend'),
            stepCount = this.axesData.tickCount - 1,
            baseData = {},
            firstLabel;

        if (this.isHorizontal) {
            baseData.startPositionValue = 5;
            baseData.step = dimension.width / stepCount;
            baseData.positionType = 'left:';
        } else {
            baseData.startPositionValue = 0;
            baseData.step = dimension.height / stepCount;
            baseData.positionType = 'top:';
            firstLabel = this.axesData.labels[0];
            baseData.labelSize = parseInt(renderUtil.getRenderedLabelHeight(firstLabel, this.theme.label) / 2, 10) - 1;
        }

        return baseData;
    },
    /**
     * Make tick html.
     * @returns {string} tick html.
     * @private
     */
    _makeTickHtml: function() {
        var self = this,
            baseData = this._makeBaseDataToMakeTickHtml(),
            positionValue = baseData.startPositionValue,
            htmls;

        htmls = tui.util.map(this.axesData.labels, function(label) {
            var labelSize, html;

            if (self.isHorizontal) {
                labelSize = parseInt(renderUtil.getRenderedLabelWidth(label, self.theme.label) / 2, 10);
            } else {
                labelSize = baseData.labelSize;
            }

            html = legendTemplate.tplTick({
                position: baseData.positionType + positionValue + 'px',
                labelPosition: baseData.positionType + (positionValue - labelSize) + 'px',
                label: label
            });

            positionValue += baseData.step;
            return html;
        });

        return htmls.join('');
    },

    /**
     * Render tick area.
     * @returns {HTMLElement} tick countainer
     * @private
     */
    _renderTickArea: function() {
        var tickContainer = dom.create('div', 'tui-chart-legend-tick-area');

        tickContainer.innerHTML = this._makeTickHtml();

        if (this.isHorizontal) {
            dom.addClass(tickContainer, 'horizontal');
        }
        return tickContainer;
    },

    /**
     * Make graph dimension of vertical legend
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeVerticalGraphDimension: function() {
        return {
            width: chartConst.MAP_LEGEND_GRAPH_SIZE,
            height: this.boundsMaker.getDimension('legend').height
        };
    },

    /**
     * Make graph dimension of horizontal legend
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeHorizontalGraphDimension: function() {
        return {
            width: this.boundsMaker.getDimension('legend').width + 10,
            height: chartConst.MAP_LEGEND_GRAPH_SIZE
        };
    },

    /**
     * Render graph.
     * @param {HTMLElement} container container element
     * @private
     */
    _renderGraph: function(container) {
        var dimension;

        if (this.isHorizontal) {
            dimension = this._makeHorizontalGraphDimension();
        } else {
            dimension = this._makeVerticalGraphDimension();
        }

        this.graphRenderer.render(container, dimension, this.colorModel, this.isHorizontal);
    },

    /**
     * Render legend area.
     * @param {HTMLElement} container legend container
     * @private
     */
    _renderLegendArea: function(container) {
        var tickContainer;

        container.innerHTML = '';
        renderUtil.renderPosition(container, this.boundsMaker.getPosition('legend'));
        this._renderGraph(container);
        tickContainer = this._renderTickArea();
        container.appendChild(tickContainer);
        container.style.cssText += ';' + renderUtil.makeFontCssText(this.theme.label);
    },

    /**
     * Render legend component.
     * @param {{colorModel: MapChartColorModel, axesData: object}} data rendering data
     * @returns {HTMLElement} legend element
     */
    render: function(data) {
        var container = dom.create('DIV', this.className);

        this.legendContainer = container;
        this.colorModel = data.colorModel;
        this.axesData = data.axesData;
        this._renderLegendArea(container);

        return container;
    },

    /**
     * Resize legend component.
     */
    resize: function() {
        this._renderLegendArea(this.legendContainer);
    },

    /**
     * On show wedge.
     * @param {number} ratio ratio
     */
    onShowWedge: function(ratio) {
        this.graphRenderer.showWedge(chartConst.MAP_LEGEND_SIZE * ratio);
    },

    /**
     * On hide wedge.
     */
    onHideWedge: function() {
        this.graphRenderer.hideWedge();
    }
});

tui.util.CustomEvents.mixin(MapChartLegend);

module.exports = MapChartLegend;

},{"../const":20,"../factories/pluginFactory":38,"../helpers/domHandler":45,"../helpers/predicate":47,"../helpers/renderUtil":49,"./../legends/legendTemplate":56}],58:[function(require,module,exports){
/**
 * @fileoverview Plot component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('../helpers/domHandler'),
    calculator = require('../helpers/calculator'),
    renderUtil = require('../helpers/renderUtil'),
    plotTemplate = require('./plotTemplate');

var Plot = tui.util.defineClass(/** @lends Plot.prototype */ {
    /**
     * Plot component.
     * @constructs Plot
     * @param {object} params parameters
     *      @param {number} params.vTickCount vertical tick count
     *      @param {number} params.hTickCount horizontal tick count
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        /**
         * Plot view className
         * @type {string}
         */
        this.className = 'tui-chart-plot-area';

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * Theme
         * @type {object}
         */
        this.theme = params.theme || {};

        /**
         * Plot data.
         * @type {object}
         */
        this.data = {};
    },

    /**
     * Render plot area.
     * @param {HTMLElement} plotContainer plot area element
     * @param {object} data rendering data
     * @private
     */
    _renderPlotArea: function(plotContainer, data) {
        var dimension = this.boundsMaker.getDimension('plot');
        this.data = data;

        renderUtil.renderDimension(plotContainer, dimension);
        renderUtil.renderPosition(plotContainer, this.boundsMaker.getPosition('plot'));

        if (!this.options.hideLine) {
            this._renderLines(plotContainer, dimension);
        }
    },

    /**
     * Render plot component.
     * @param {object} data rendering data
     * @returns {HTMLElement} plot element
     */
    render: function(data) {
        var el = dom.create('DIV', this.className);
        this._renderPlotArea(el, data);
        this.plotContainer = el;
        return el;
    },

    /**
     * Rerender.
     * @param {object} data rendering
     */
    rerender: function(data) {
        this.plotContainer.innerHTML = '';
        this._renderPlotArea(this.plotContainer, data);
    },

    /**
     * Resize plot component.
     * @param {object} data rendering data
     */
    resize: function(data) {
        this.rerender(data);
    },

    /**
     * Render plot lines.
     * @param {HTMLElement} el element
     * @param {{width: number, height: number}} dimension plot area dimension
     * @private
     */
    _renderLines: function(el, dimension) {
        var hPositions = this._makeHorizontalPixelPositions(dimension.width),
            vPositions = this._makeVerticalPixelPositions(dimension.height),
            theme = this.theme,
            lineHtml = '';

        lineHtml += this._makeLineHtml({
            positions: hPositions,
            size: dimension.height,
            className: 'vertical',
            positionType: 'left',
            sizeType: 'height',
            lineColor: theme.lineColor
        });
        lineHtml += this._makeLineHtml({
            positions: vPositions,
            size: dimension.width,
            className: 'horizontal',
            positionType: 'bottom',
            sizeType: 'width',
            lineColor: theme.lineColor
        });

        el.innerHTML = lineHtml;

        renderUtil.renderBackground(el, theme.background);
    },

    /**
     * Make html of plot line.
     * @param {object} params parameters
     *      @param {Array.<object>} params.positions positions
     *      @param {number} params.size width or height
     *      @param {string} params.className line className
     *      @param {string} params.positionType position type (left or bottom)
     *      @param {string} params.sizeType size type (size or height)
     *      @param {string} params.lineColor line color
     * @returns {string} html
     * @private
     */
    _makeLineHtml: function(params) {
        var template = plotTemplate.tplPlotLine,
            lineHtml = tui.util.map(params.positions, function(position) {
                var cssTexts = [
                        renderUtil.concatStr(params.positionType, ':', position, 'px'),
                        renderUtil.concatStr(params.sizeType, ':', params.size, 'px')
                    ], data;

                if (params.lineColor) {
                    cssTexts.push(renderUtil.concatStr('background-color:', params.lineColor));
                }

                data = {className: params.className, cssText: cssTexts.join(';')};
                return template(data);
            }).join('');
        return lineHtml;
    },

    /**
     * Make pixel value of vertical positions
     * @param {number} height plot height
     * @returns {Array.<number>} positions
     * @private
     */
    _makeVerticalPixelPositions: function(height) {
        var positions = calculator.makeTickPixelPositions(height, this.data.vTickCount);
        positions.shift();
        return positions;
    },

    /**
     * Make divided positions of plot.
     * @param {number} width plot width
     * @returns {Array.<number>}
     * @private
     */
    _makeDividedPlotPositions: function(width) {
        var tickCount = parseInt(this.data.hTickCount / 2, 10) + 1,
            yAxisWidth = this.boundsMaker.getDimension('yAxis').width,
            leftWidth, rightWidth, leftPositions, rightPositions;

        width -= yAxisWidth;
        leftWidth = Math.round((width) / 2);
        rightWidth = width - leftWidth;

        leftPositions = calculator.makeTickPixelPositions(leftWidth, tickCount);
        rightPositions = calculator.makeTickPixelPositions(rightWidth, tickCount, leftWidth + yAxisWidth);

        leftPositions.pop();
        rightPositions.shift();

        return leftPositions.concat(rightPositions);
    },

    /**
     * Make pixel value of horizontal positions.
     * @param {number} width plot width
     * @returns {Array.<number>} positions
     * @private
     */
    _makeHorizontalPixelPositions: function(width) {
        var positions;

        if (this.options.divided) {
            positions = this._makeDividedPlotPositions(width);
        } else {
            positions = calculator.makeTickPixelPositions(width, this.data.hTickCount);
            positions.shift();
        }
        return positions;
    }
});

module.exports = Plot;

},{"../helpers/calculator":43,"../helpers/domHandler":45,"../helpers/renderUtil":49,"./plotTemplate":59}],59:[function(require,module,exports){
/**
 * @fileoverview This is templates of plot view .
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var tags = {
    HTML_PLOT_LINE: '<div class="tui-chart-plot-line {{ className }}" style="{{ cssText }}"></div>'
};

module.exports = {
    tplPlotLine: templateMaker.template(tags.HTML_PLOT_LINE)
};

},{"../helpers/templateMaker":50}],60:[function(require,module,exports){
/**
 * @fileoverview Raphael render plugin.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var BarChart = require('./raphaelBarChart');
var LineChart = require('./raphaelLineChart');
var AreaChart = require('./raphaelAreaChart');
var PieChart = require('./raphaelPieChart');
var BubbleChart = require('./raphaelBubbleChart');
var MapChart = require('./raphaelMapChart');
var MapLegend = require('./raphaelMapLegend');
var CircleLegend = require('./raphaelCircleLegend');

var pluginName = 'raphael',
    pluginRaphael;

pluginRaphael = {
    bar: BarChart,
    column: BarChart,
    line: LineChart,
    area: AreaChart,
    pie: PieChart,
    bubble: BubbleChart,
    map: MapChart,
    mapLegend: MapLegend,
    circleLegend: CircleLegend
};

tui.chart.registerPlugin(pluginName, pluginRaphael);

},{"./raphaelAreaChart":61,"./raphaelBarChart":62,"./raphaelBubbleChart":63,"./raphaelCircleLegend":64,"./raphaelLineChart":65,"./raphaelMapChart":67,"./raphaelMapLegend":68,"./raphaelPieChart":69}],61:[function(require,module,exports){
/**
 * @fileoverview Raphael area chart renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var RaphaelLineBase = require('./raphaelLineTypeBase'),
    raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael,
    EMPHASIS_OPACITY = 1,
    DE_EMPHASIS_OPACITY = 0.3;

var concat = Array.prototype.concat;

var RaphaelAreaChart = tui.util.defineClass(RaphaelLineBase, /** @lends RaphaelAreaChart.prototype */ {
    /**
     * RaphaelAreaChart is graph renderer for area chart.
     * @constructs RaphaelAreaChart
     * @extends RaphaelLineTypeBase
     */
    init: function() {
        /**
         * selected legend index
         * @type {?number}
         */
        this.selectedLegendIndex = null;

        /**
         * type of chart
         * @type {string}
         */
        this.chartType = 'area';
    },

    /**
     * Render function of area chart.
     * @param {HTMLElement} container container
     * @param {{groupPositions: Array.<Array>, dimension: object, theme: object, options: object}} data render data
     * @returns {object} paper raphael paper
     */
    render: function(container, data) {
        var dimension = data.dimension,
            groupPositions = data.groupPositions,
            theme = data.theme,
            colors = theme.colors,
            opacity = data.options.hasDot ? 1 : 0,
            borderStyle = this.makeBorderStyle(theme.borderColor, opacity),
            outDotStyle = this.makeOutDotStyle(opacity, borderStyle),
            paper;

        this.paper = paper = raphael(container, 1, dimension.height);
        this.stackedOption = data.options.stacked;
        this.isSpline = data.options.spline;
        this.dimension = dimension;
        this.zeroTop = data.zeroTop;
        this.hasRangeData = data.hasRangeData;

        this.groupPaths = this.isSpline ? this._getSplineAreasPath(groupPositions) : this._getAreasPath(groupPositions);
        this.groupAreas = this._renderAreas(paper, this.groupPaths, colors);
        this.tooltipLine = this._renderTooltipLine(paper, dimension.height);
        this.groupDots = this._renderDots(paper, groupPositions, colors, opacity);

        if (data.options.hasSelection) {
            this.selectionDot = this._makeSelectionDot(paper);
            this.selectionColor = theme.selectionColor;

            if (this.hasRangeData) {
                this.selectionStartDot = this._makeSelectionDot(paper);
            }
        }

        this.outDotStyle = outDotStyle;
        this.groupPositions = groupPositions;
        this.dotOpacity = opacity;
        delete this.pivotGroupDots;

        return paper;
    },

    /**
     * Render area graphs.
     * @param {object} paper paper
     * @param {Array.<object>} groupPaths group paths
     * @param {Array.<string>} colors colors
     * @returns {Array} raphael objects
     * @private
     */
    _renderAreas: function(paper, groupPaths, colors) {
        var groupAreas;

        colors = colors.slice(0, groupPaths.length);
        colors.reverse();
        groupPaths.reverse();

        groupAreas = tui.util.map(groupPaths, function(path, groupIndex) {
            var areaColor = colors[groupIndex] || 'transparent',
                lineColor = areaColor,
                polygons = {
                    area: raphaelRenderUtil.renderArea(paper, path.area.join(' '), {
                        fill: areaColor,
                        opacity: 0.5,
                        stroke: areaColor
                    }),
                    line: raphaelRenderUtil.renderLine(paper, path.line.join(' '), lineColor, 1)
                };

            if (path.startLine) {
                polygons.startLine = raphaelRenderUtil.renderLine(paper, path.startLine.join(' '), lineColor, 1);
            }

            return polygons;
        });

        return groupAreas.reverse();
    },

    /**
     * Make height.
     * @param {number} top top
     * @param {number} startTop start top
     * @returns {number} height
     * @private
     */
    _makeHeight: function(top, startTop) {
        return Math.abs(top - startTop);
    },

    /**
     * Make areas path.
     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
     * @returns {Array.<string | number>} path
     * @private
     */
    _makeAreasPath: function(positions) {
        var len = positions.length * 2,
            path = [];

        tui.util.forEachArray(positions, function(position, index) {
            path[index] = ['L', position.left, position.top];
            path[len - index - 1] = ['L', position.left, position.startTop];
        });

        path = concat.apply([], path);
        path[0] = 'M';

        return path;
    },

    /**
     * Get area path.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @returns {Array.<{area: Array.<string | number>, line: Array.<string | number>}>} path
     * @private
     */
    _getAreasPath: function(groupPositions) {
        var self = this;

        return tui.util.map(groupPositions, function(positions) {
            var paths;

            positions[0].left -= 1;

            paths = {
                area: self._makeAreasPath(positions),
                line: self._makeLinesPath(positions)
            };

            if (self.hasRangeData) {
                paths.startLine = self._makeLinesPath(positions, 'startTop');
            }

            return paths;
        });
    },

    /**
     * Make spline area bottom path.
     * @param {Array.<{left: number, top: number}>} positions positions
     * @param {Array.<{left: number, top: number}>} prevPositions previous positions
     * @returns {Array.<string | number>} spline area path
     * @private
     */
    _makeSplineAreaBottomPath: function(positions) {
        var self = this;

        return tui.util.map(positions, function(position) {
            return ['L', position.left, self.zeroTop];
        }).reverse();
    },

    /**
     * Get spline areas path.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @returns {Array.<{area: Array.<string | number>, line: Array.<string | number>}>} path
     * @private
     */
    _getSplineAreasPath: function(groupPositions) {
        var self = this;

        return tui.util.map(groupPositions, function(positions) {
            var linesPath, areasBottomPath;

            positions[0].left -= 1;
            linesPath = self._makeSplineLinesPath(positions);
            areasBottomPath = self._makeSplineAreaBottomPath(positions);

            return {
                area: linesPath.concat(areasBottomPath),
                line: linesPath
            };
        });
    },

    /**
     * Resize graph of area chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {Array.<Array.<{left:number, top:number}>>} params.groupPositions group positions
     */
    resize: function(params) {
        var self = this,
            dimension = params.dimension,
            groupPositions = params.groupPositions;

        this.groupPositions = groupPositions;
        this.groupPaths = this.isSpline ? this._getSplineAreasPath(groupPositions) : this._getAreasPath(groupPositions);
        this.paper.setSize(dimension.width, dimension.height);
        this.tooltipLine.attr({top: dimension.height});

        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {
            var area = self.groupAreas[groupIndex];
            area.area.attr({path: path.area.join(' ')});
            area.line.attr({path: path.line.join(' ')});

            if (area.startLine) {
                area.startLine.attr({path: path.startLine.join(' ')});
            }

            tui.util.forEachArray(self.groupDots[groupIndex], function(item, index) {
                var position = groupPositions[groupIndex][index];
                var startPositon;

                self._moveDot(item.dot.dot, position);
                if (item.startDot) {
                    startPositon = tui.util.extend({}, position);
                    startPositon.top = startPositon.startTop;
                    self._moveDot(item.startDot.dot, startPositon);
                }
            });
        });
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var self = this,
            noneSelected = tui.util.isNull(legendIndex);

        this.selectedLegendIndex = legendIndex;

        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {
            var area = self.groupAreas[groupIndex],
                opacity = (noneSelected || legendIndex === groupIndex) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            area.area.attr({'fill-opacity': opacity});
            area.line.attr({'stroke-opacity': opacity});

            if (area.startLine) {
                area.startLine.attr({'stroke-opacity': opacity});
            }

            tui.util.forEachArray(self.groupDots[groupIndex], function(item) {
                if (self.dotOpacity) {
                    item.dot.dot.attr({'fill-opacity': opacity});
                    if (item.startDot) {
                        item.startDot.dot.attr({'fill-opacity': opacity});
                    }
                }
            });
        });
    }
});

module.exports = RaphaelAreaChart;

},{"./raphaelLineTypeBase":66,"./raphaelRenderUtil":70}],62:[function(require,module,exports){
/**
 * @fileoverview Raphael bar chart renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';
var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

var ANIMATION_TIME = 700,
    EMPHASIS_OPACITY = 1,
    DE_EMPHASIS_OPACITY = 0.3,
    DEFAULT_LUMINANC = 0.2;

/**
 * @classdesc RaphaelBarChart is graph renderer for bar, column chart.
 * @class RaphaelBarChart
 */
var RaphaelBarChart = tui.util.defineClass(/** @lends RaphaelBarChart.prototype */ {
    /**
     * Render function of bar chart
     * @param {HTMLElement} container container element
     * @param {{size: object, model: object, options: object, tooltipPosition: string}} data chart data
     * @returns {object} paper raphael paper
     */
    render: function(container, data) {
        var groupBounds = data.groupBounds,
            dimension = data.dimension,
            paper;

        if (!groupBounds) {
            return null;
        }

        this.paper = paper = raphael(container, dimension.width, dimension.height);

        this.theme = data.theme;
        this.seriesDataModel = data.seriesDataModel;
        this.chartType = data.chartType;

        this.groupBars = this._renderBars(groupBounds);
        this.groupBorders = this._renderBarBorders(groupBounds);

        this.overlay = this._renderOverlay();
        this.theme = data.theme;
        this.groupBounds = groupBounds;
        this.chartType = data.chartType;

        return paper;
    },

    /**
     * Render overlay.
     * @returns {object} raphael object
     * @private
     */
    _renderOverlay: function() {
        var rect = this._renderBar({
            bound: {
                width: 1,
                height: 1,
                left: 0,
                top: 0
            },
            color: '#fff'
        }).attr({
            'fill-opacity': 0
        });

        return rect;
    },

    /**
     * Render rect
     * @param {{left: number, top: number, width: number, height: number}} bound bound
     * @param {string} color series color
     * @returns {object} bar rect
     * @private
     */
    _renderBar: function(bound, color) {
        var rect;

        if (bound.width < 0 || bound.height < 0) {
            return null;
        }

        rect = this.paper.rect(bound.left, bound.top, bound.width, bound.height);
        rect.attr({
            fill: color,
            stroke: 'none'
        });

        return rect;
    },

    /**
     * Render bars.
     * @param {Array.<Array.<{left: number, top:number, width: number, height: number}>>} groupBounds bounds
     * @returns {Array.<Array.<object>>} bars
     * @private
     */
    _renderBars: function(groupBounds) {
        var self = this,
            singleColors = [],
            colors = this.theme.colors,
            groupBars;

        if ((groupBounds[0].length === 1) && this.theme.singleColors) {
            singleColors = this.theme.singleColors;
        }

        groupBars = tui.util.map(groupBounds, function(bounds, groupIndex) {
            var singleColor = singleColors[groupIndex];

            return tui.util.map(bounds, function(bound, index) {
                var color, rect, item;

                if (!bound) {
                    return null;
                }

                item = self.seriesDataModel.getSeriesItem(groupIndex, index, self.chartType);

                color = singleColor || colors[index];
                rect = self._renderBar(bound.start, color);

                return {
                    rect: rect,
                    color: color,
                    bound: bound.end,
                    item: item,
                    groupIndex: groupIndex,
                    index: index,
                    isRange: item.isRange
                };
            });
        });

        return groupBars;
    },

    /**
     * Make rect points.
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @returns {{
     *      leftTop: {left: number, top: number},
     *      rightTop: {left: number, top: number},
     *      rightBottom: {left: number, top: number},
     *      leftBottom: {left: number, top: number}
     * }} rect points
     * @private
     */
    _makeRectPoints: function(bound) {
        return {
            leftTop: {
                left: Math.ceil(bound.left),
                top: Math.ceil(bound.top)
            },
            rightTop: {
                left: Math.ceil(bound.left + bound.width),
                top: Math.ceil(bound.top)
            },
            rightBottom: {
                left: Math.ceil(bound.left + bound.width),
                top: Math.ceil(bound.top + bound.height)
            },
            leftBottom: {
                left: Math.ceil(bound.left),
                top: Math.ceil(bound.top + bound.height)
            }
        };
    },

    /**
     * Make top line path.
     * @param {object} points points
     *      @param {{left: number, top: number}} points.leftTop left top
     *      @param {{left: number, top: number}} points.rightTop right top
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {string} top line path
     * @private
     */
    _makeTopLinePath: function(points, chartType, item) {
        var linePath = null,
            value = item.value,
            cloneLeftTop;

        if (chartType === 'bar' || value >= 0 || item.isRange) {
            cloneLeftTop = tui.util.extend({}, points.leftTop);
            cloneLeftTop.left -= chartType === 'column' || value < 0 ? 1 : 0;
            linePath = raphaelRenderUtil.makeLinePath(cloneLeftTop, points.rightTop).join(' ');
        }

        return linePath;
    },

    /**
     * Make right line path.
     * @param {object} points points
     *      @param {{left: number, top: number}} points.rightTop right top
     *      @param {{left: number, top: number}} points.rightBottom right bottom
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {string} top line path
     * @private
     */
    _makeRightLinePath: function(points, chartType, item) {
        var linePath = null;

        if (chartType === 'column' || item.value >= 0 || item.isRange) {
            linePath = raphaelRenderUtil.makeLinePath(points.rightTop, points.rightBottom).join(' ');
        }

        return linePath;
    },

    /**
     * Make bottom line path.
     * @param {object} points points
     *      @param {{left: number, top: number}} points.lefBottom left bottom
     *      @param {{left: number, top: number}} points.rightBottom right bottom
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {string} top line path
     * @private
     */
    _makeBottomLinePath: function(points, chartType, item) {
        var linePath = null;

        if (chartType === 'bar' || item.value < 0 || item.isRange) {
            linePath = raphaelRenderUtil.makeLinePath(points.leftBottom, points.rightBottom).join(' ');
        }

        return linePath;
    },

    /**
     * Make left line path.
     * @param {object} points points
     *      @param {{left: number, top: number}} points.lefTop left top
     *      @param {{left: number, top: number}} points.leftBottom left bottom
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {string} top line path
     * @private
     */
    _makeLeftLinePath: function(points, chartType, item) {
        var linePath = null;

        if (chartType === 'column' || item.value < 0 || item.isRange) {
            linePath = raphaelRenderUtil.makeLinePath(points.leftTop, points.leftBottom).join(' ');
        }

        return linePath;
    },

    /**
     * Make border lines paths.
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {{top: string, right: string, bottom: string, left: string}} paths
     * @private
     */
    _makeBorderLinesPaths: function(bound, chartType, item) {
        var points = this._makeRectPoints(bound),
            paths = {
                top: this._makeTopLinePath(points, chartType, item),
                right: this._makeRightLinePath(points, chartType, item),
                bottom: this._makeBottomLinePath(points, chartType, item),
                left: this._makeLeftLinePath(points, chartType, item)
            };

        return tui.util.filter(paths, function(path) {
            return path;
        });
    },

    /**
     * Render border lines;
     * @param {{left: number, top:number, width: number, height: number}} bound bar bound
     * @param {string} borderColor border color
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {object} raphael object
     * @private
     */
    _renderBorderLines: function(bound, borderColor, chartType, item) {
        var self = this,
            borderLinePaths = this._makeBorderLinesPaths(bound, chartType, item),
            lines = {};

        tui.util.forEach(borderLinePaths, function(path, name) {
            lines[name] = raphaelRenderUtil.renderLine(self.paper, path, borderColor, 1);
        });

        return lines;
    },

    /**
     * Render bar borders.
     * @param {Array.<Array.<{left: number, top:number, width: number, height: number}>>} groupBounds bounds
     * @returns {Array.<Array.<object>>} borders
     * @private
     */
    _renderBarBorders: function(groupBounds) {
        var self = this,
            borderColor = this.theme.borderColor,
            groupBorders;

        if (!borderColor) {
            return null;
        }

        groupBorders = tui.util.map(groupBounds, function(bounds, groupIndex) {
            return tui.util.map(bounds, function(bound, index) {
                var seriesItem;

                if (!bound) {
                    return null;
                }

                seriesItem = self.seriesDataModel.getSeriesItem(groupIndex, index, self.chartType);

                return self._renderBorderLines(bound.start, borderColor, self.chartType, seriesItem);
            });
        });

        return groupBorders;
    },

    /**
     * Animate rect.
     * @param {object} rect raphael object
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @private
     */
    _animateRect: function(rect, bound) {
        rect.animate({
            x: bound.left,
            y: bound.top,
            width: bound.width,
            height: bound.height
        }, ANIMATION_TIME);
    },

    /**
     * Animate borders.
     * @param {Array.<object>} lines raphael objects
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @param {string} chartType chart type
     * @param {Item} item item
     * @private
     */
    _animateBorders: function(lines, bound, chartType, item) {
        var paths = this._makeBorderLinesPaths(bound, chartType, item);

        tui.util.forEach(lines, function(line, name) {
            line.animate({path: paths[name]}, ANIMATION_TIME);
        });
    },

    /**
     * Animate.
     * @param {function} onFinish finish callback function
     */
    animate: function(onFinish) {
        var self = this,
            groupBorders = this.groupBorders || [];

        if (this.callbackTimeout) {
            clearTimeout(this.callbackTimeout);
            delete this.callbackTimeout;
        }
        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
            var lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
            if (!bar) {
                return;
            }
            self._animateRect(bar.rect, bar.bound);
            if (lines) {
                self._animateBorders(lines, bar.bound, self.chartType, bar.item);
            }
        });

        if (onFinish) {
            this.callbackTimeout = setTimeout(function() {
                onFinish();
                delete self.callbackTimeout;
            }, ANIMATION_TIME);
        }
    },

    /**
     * Show animation.
     * @param {{groupIndex: number, index:number}} data show info
     */
    showAnimation: function(data) {
        var bar = this.groupBars[data.groupIndex][data.index],
            bound = bar.bound;
        this.overlay.attr({
            width: bound.width,
            height: bound.height,
            x: bound.left,
            y: bound.top,
            'fill-opacity': 0.3
        });
    },

    /**
     * Hide animation.
     */
    hideAnimation: function() {
        this.overlay.attr({
            width: 1,
            height: 1,
            x: 0,
            y: 0,
            'fill-opacity': 0
        });
    },

    /**
     * Update rect bound
     * @param {object} rect raphael object
     * @param {{left: number, top: number, width: number, height: number}} bound bound
     * @private
     */
    _updateRectBound: function(rect, bound) {
        rect.attr({
            x: bound.left,
            y: bound.top,
            width: bound.width,
            height: bound.height
        });
    },

    /**
     * Update borders attribute
     * @param {Array.<object>} lines raphael objects
     * @param {{left: number, top: number, width: number, height: number}} bound bound
     * @param {string} chartType chart type
     * @param {Item} item item
     * @private
     */
    _updateBordersPath: function(lines, bound, chartType, item) {
        var paths = this._makeBorderLinesPaths(bound, chartType, item);

        tui.util.forEach(lines, function(line, name) {
            line.attr({path: paths[name]});
        });
    },

    /**
     * Resize graph of bar type chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {Array.<Array.<{
     *                  left:number, top:number, width: number, height: number
     *              }>>} params.groupBounds group bounds
     */
    resize: function(params) {
        var self = this,
            groupBorders = this.groupBorders || [],
            dimension = params.dimension,
            groupBounds = params.groupBounds;

        this.groupBounds = groupBounds;
        this.paper.setSize(dimension.width, dimension.height);

        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
            var lines, bound;

            if (!bar) {
                return;
            }

            lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
            bound = groupBounds[groupIndex][index].end;
            bar.bound = bound;
            self._updateRectBound(bar.rect, bound);

            if (lines) {
                self._updateBordersPath(lines, bound, self.chartType, bar.item);
            }
        });
    },

    /**
     * Change borders color.
     * @param {Array.<object>} lines raphael objects
     * @param {borderColor} borderColor border color
     * @private
     */
    _changeBordersColor: function(lines, borderColor) {
        tui.util.forEach(lines, function(line) {
            line.attr({stroke: borderColor});
        });
    },

    /**
     * Change bar color.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} color fill color
     * @param {?string} borderColor stroke color
     * @private
     */
    _changeBarColor: function(indexes, color, borderColor) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            lines;

        bar.rect.attr({
            fill: color
        });

        if (borderColor) {
            lines = this.groupBorders[indexes.groupIndex][indexes.index];
            this._changeBordersColor(lines, borderColor);
        }
    },

    /**
     * Select series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    selectSeries: function(indexes) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            objColor = raphael.color(bar.color),
            selectionColorTheme = this.theme.selectionColor,
            color = selectionColorTheme || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC),
            borderColor = this.theme.borderColor,
            objBorderColor;

        if (borderColor) {
            objBorderColor = raphael.color(borderColor);
            borderColor = raphaelRenderUtil.makeChangedLuminanceColor(objBorderColor.hex, DEFAULT_LUMINANC);
        }

        this._changeBarColor(indexes, color, borderColor);
    },

    /**
     * Unselect series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    unselectSeries: function(indexes) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            borderColor = this.theme.borderColor;
        this._changeBarColor(indexes, bar.color, borderColor);
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var groupBorders = this.groupBorders || [],
            noneSelected = tui.util.isNull(legendIndex);

        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
            var lines, opacity;

            if (!bar) {
                return;
            }

            lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
            opacity = (noneSelected || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            bar.rect.attr({'fill-opacity': opacity});
            if (lines) {
                tui.util.forEach(lines, function(line) {
                    line.attr({'stroke-opacity': opacity});
                });
            }
        });
    }
});

module.exports = RaphaelBarChart;

},{"./raphaelRenderUtil":70}],63:[function(require,module,exports){
/**
 * @fileoverview Raphael bubble chart renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';
var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

var ANIMATION_TIME = 700;
var CIRCLE_OPACITY = 0.5;
var STROKE_OPACITY = 0.3;
var EMPHASIS_OPACITY = 0.5;
var DE_EMPHASIS_OPACITY = 0.3;
var DEFAULT_LUMINANC = 0.2;
var OVERLAY_BORDER_WIDTH = 2;

/**
 * bound for circle
 * @typedef {{left: number, top: number, radius: number}} bound
 */

/**
 * Information for rendered circle
 * @typedef {{circle: object, color: string, bound: bound}} circleInfo
 */

/**
 * @classdesc RaphaelBubbleChart is graph renderer for bubble chart.
 * @class RaphaelBubbleChart
 */
var RaphaelBubbleChart = tui.util.defineClass(/** @lends RaphaelBubbleChart.prototype */ {
    /**
     * Render function of bubble chart
     * @param {HTMLElement} container - container element
     * @param {{
     *      dimension: {width: number, height: number},
     *      seriesDataModel: SeriesDataModel,
     *      groupBounds: Array.<Array.<bound>>,
     *      theme: object
     * }} data - data for rendering
     * @param {{showTooltip: function, hideTooltip: function}} callbacks - callbacks for toggle of tooltip.
     * @returns {object}
     */
    render: function(container, data, callbacks) {
        var dimension = data.dimension,
            paper;

        this.paper = paper = raphael(container, dimension.width, dimension.height);

        /**
         * container element
         * @type {HTMLElement}
         */
        this.container = container;

        /**
         * theme
         * @type {object}
         */
        this.theme = data.theme;

        /**
         * seriesDataModel
         * @type {SeriesDataModel}
         */
        this.seriesDataModel = data.seriesDataModel;

        /**
         * group bounds
         * @type {Array.<Array.<bound>>}
         */
        this.groupBounds = data.groupBounds;

        /**
         * callbacks for toggle of tooltip.
         * @type {{showTooltip: Function, hideTooltip: Function}}
         */
        this.callbacks = callbacks;

        /**
         * overlay is circle object of raphael, that using for mouseover.
         * @type {object}
         */
        this.overlay = this._renderOverlay();

        /**
         * two-dimensional array by circleInfo
         * @type {Array.<Array.<circleInfo>>}
         */
        this.groupCircleInfos = this._renderCircles();

        /**
         * previous selected circle
         * @type {?object}
         */
        this.prevCircle = null;

        /**
         * previous over circle
         * @type {?object}
         */
        this.prevOverCircle = null;

        /**
         * animation timeout id
         * @type {?number}
         */
        this.animationTimeoutId = null;

        return paper;
    },

    /**
     * Render overlay.
     * @returns {object}
     * @private
     */
    _renderOverlay: function() {
        var position = {
            left: 0,
            top: 0
        };
        var attribute = {
            fill: 'none',
            stroke: '#fff',
            'stroke-opacity': STROKE_OPACITY,
            'stroke-width': 2
        };
        var circle = raphaelRenderUtil.renderCircle(this.paper, position, 0, attribute);

        return circle;
    },

    /**
     * Render circles.
     * @returns {Array.<Array.<circleInfo>>}
     * @private
     */
    _renderCircles: function() {
        var self = this;
        var colors = this.theme.colors;
        var singleColors = [];

        if ((this.groupBounds[0].length === 1) && this.theme.singleColors) {
            singleColors = this.theme.singleColors;
        }

        return tui.util.map(this.groupBounds, function(bounds, groupIndex) {
            var singleColor = singleColors[groupIndex];

            return tui.util.map(bounds, function(bound, index) {
                var circleInfo = null;
                var color, circle;

                if (bound) {
                    color = singleColor || colors[index];
                    circle = raphaelRenderUtil.renderCircle(self.paper, bound, 0, {
                        fill: color,
                        opacity: 0,
                        stroke: 'none'
                    });

                    circle.data('groupIndex', groupIndex);
                    circle.data('index', index);

                    circleInfo = {
                        circle: circle,
                        color: color,
                        bound: bound
                    };
                }

                return circleInfo;
            });
        });
    },

    /**
     * Animate circle
     * @param {object} circle - raphael object
     * @param {number} radius - radius of circle
     * @private
     */
    _animateCircle: function(circle, radius) {
        circle.animate({
            r: radius,
            opacity: CIRCLE_OPACITY
        }, ANIMATION_TIME);
    },

    /**
     * Animate.
     * @param {function} onFinish - finish callback function
     */
    animate: function(onFinish) {
        var self = this;

        if (this.animationTimeoutId) {
            clearTimeout(this.animationTimeoutId);
            this.animationTimeoutId = null;
        }

        raphaelRenderUtil.forEach2dArray(this.groupCircleInfos, function(circleInfo) {
            if (!circleInfo) {
                return;
            }
            self._animateCircle(circleInfo.circle, circleInfo.bound.radius);
        });

        if (onFinish) {
            this.animationTimeoutId = setTimeout(function() {
                onFinish();
                this.animationTimeoutId = null;
            }, ANIMATION_TIME);
        }
    },

    /**
     * Update circle bound
     * @param {object} circle - raphael object
     * @param {{left: number, top: number}} bound - bound
     * @private
     */
    _updatePosition: function(circle, bound) {
        circle.attr({
            cx: bound.left,
            cy: bound.top,
            r: bound.radius
        });
    },

    /**
     * Resize graph of bubble type chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension - dimension
     *      @param {Array.<Array.<bound>>} params.groupBounds - group bounds
     */
    resize: function(params) {
        var self = this;
        var dimension = params.dimension;
        var groupBounds = params.groupBounds;

        this.groupBounds = groupBounds;
        this.paper.setSize(dimension.width, dimension.height);

        raphaelRenderUtil.forEach2dArray(this.groupCircleInfos, function(circleInfo, groupIndex, index) {
            var bound = groupBounds[groupIndex][index];

            circleInfo.bound = bound;
            self._updatePosition(circleInfo.circle, bound);
        });
    },

    /**
     * Click series.
     * @param {{left: number, top: number}} position mouse position
     */
    clickSeries: function(position) {
        var circle = this.paper.getElementByPoint(position.left, position.top);
        var prevCircle = this.prevCircle;

        if (circle && prevCircle) {
            this._unselectSeries(prevCircle.data('groupIndex'), prevCircle.data('index'));
        }

        if (prevCircle === circle) {
            this.prevCircle = null;
        } else if (circle) {
            this._selectSeries(circle.data('groupIndex'), circle.data('index'));
            this.prevCircle = circle;
        }
    },

    /**
     * Get series container bound.
     * @returns {{left: number, top: number, width: number, height: number}}
     * @private
     */
    _getContainerBound: function() {
        if (!this.containerBound) {
            this.containerBound = this.container.getBoundingClientRect();
        }
        return this.containerBound;
    },

    /**
     * Whether changed or not.
     * @param {{left: number, top: number}} prevPosition - previous position
     * @param {{left: number, top: number}} position - position
     * @returns {boolean} result boolean
     * @private
     */
    _isChangedPosition: function(prevPosition, position) {
        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
    },

    /**
     * Show overlay when mouse over a circle.
     * @param {number} groupIndex - index of circles group
     * @param {number} index - index of circles
     * @private
     */
    _showOverlay: function(groupIndex, index) {
        var circleInfo = this.groupCircleInfos[groupIndex][index];
        var bound = circleInfo.bound;

        this.overlay.attr({
            cx: bound.left,
            cy: bound.top,
            r: bound.radius + OVERLAY_BORDER_WIDTH,
            stroke: circleInfo.color,
            opacity: 1
        });
    },

    /**
     * Hide overlay.
     * @private
     */
    _hideOverlay: function() {
        this.overlay.attr({
            cx: 0,
            cy: 0,
            r: 0,
            opacity: 0
        });
    },

    /**
     * Find circle.
     * @param {{left: number, top: number}} position - position
     * @returns {?object}
     * @private
     */
    _findCircle: function(position) {
        var circles = [];
        var paper = this.paper;
        var foundCircle, circle;

        while (tui.util.isUndefined(foundCircle)) {
            circle = paper.getElementByPoint(position.left, position.top);

            if (circle) {
                if (circle.attrs.opacity > DE_EMPHASIS_OPACITY) {
                    foundCircle = circle;
                } else {
                    circles.push(circle);
                    circle.hide();
                }
            } else {
                foundCircle = null;
            }
        }

        if (!foundCircle) {
            foundCircle = circles[0];
        }

        tui.util.forEachArray(circles, function(_circle) {
            _circle.show();
        });

        return foundCircle;
    },

    /**
     * Move mouse on series.
     * @param {{left: number, top: number}} position - mouse position
     */
    moveMouseOnSeries: function(position) {
        var circle = this._findCircle(position);
        var containerBound, isChanged, groupIndex, index, args;

        if (circle && tui.util.isExisty(circle.data('groupIndex'))) {
            containerBound = this._getContainerBound();
            isChanged = (this.prevOverCircle !== circle);
            groupIndex = circle.data('groupIndex');
            index = circle.data('index');
            args = [{}, groupIndex, index, {
                left: position.left - containerBound.left,
                top: position.top - containerBound.top
            }];

            if (isChanged) {
                this._showOverlay(groupIndex, index);
            }

            if (this._isChangedPosition(this.prevPosition, position)) {
                this.callbacks.showTooltip.apply(null, args);
                this.prevOverCircle = circle;
            }
        } else if (this.prevOverCircle) {
            this._hideOverlay();
            this.callbacks.hideTooltip();
            this.prevOverCircle = null;
        }
        this.prevPosition = position;
    },

    /**
     * Select series.
     * @param {number} groupIndex - index of group
     * @param {number} index - index
     */
    _selectSeries: function(groupIndex, index) {
        var circleInfo = this.groupCircleInfos[groupIndex][index];
        var objColor = raphael.color(circleInfo.color);
        var themeColor = this.theme.selectionColor;
        var color = themeColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC);

        circleInfo.circle.attr({
            fill: color
        });
    },

    /**
     * Unselect series.
     * @param {number} groupIndex - index of group
     * @param {number} index - index
     */
    _unselectSeries: function(groupIndex, index) {
        var circleInfo = this.groupCircleInfos[groupIndex][index];

        circleInfo.circle.attr({
            fill: circleInfo.color
        });
    },

    /**
     * Select legend.
     * @param {?number} legendIndex - index of legend
     */
    selectLegend: function(legendIndex) {
        var noneSelected = tui.util.isNull(legendIndex);

        raphaelRenderUtil.forEach2dArray(this.groupCircleInfos, function(circleInfo, groupIndex, index) {
            var opacity;

            if (!circleInfo) {
                return;
            }

            opacity = (noneSelected || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            circleInfo.circle.attr({opacity: opacity});
        });
    }
});

module.exports = RaphaelBubbleChart;

},{"./raphaelRenderUtil":70}],64:[function(require,module,exports){
/**
 * @fileoverview RaphaelCircleLegend is graph renderer for circleLegend.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

/**
 * @classdesc RaphaelCircleLegend is graph renderer for circleLegend.
 * @class RaphaelCircleLegend
 */
var RaphaelCircleLegend = tui.util.defineClass(/** @lends RaphaelCircleLegend.prototype */ {
    /**
     * Render function of map chart legend.
     * @param {HTMLElement} container container
     * @param {{width: number, height: number}} dimension - dimension of circle legend area
     * @param {number} maxRadius - pixel type maximum radius
     * @param {Array.<number>} radiusRatios - radius ratios
     * @returns {object} paper raphael paper
     */
    render: function(container, dimension, maxRadius, radiusRatios) {
        var paper = raphael(container, dimension.width, dimension.height);

        this.paper = paper;

        this._renderCircles(dimension, maxRadius, radiusRatios);

        return paper;
    },

    /**
     * Render circles.
     * @param {{width: number, height: number}} dimension - dimension of circle legend area
     * @param {number} maxRadius - pixel type maximum radius
     * @param {Array.<number>} radiusRatios - radius ratios
     * @private
     */
    _renderCircles: function(dimension, maxRadius, radiusRatios) {
        var paper = this.paper;
        var left = dimension.width / 2;

        tui.util.forEachArray(radiusRatios, function(ratio) {
            var radius = maxRadius * ratio;
            var top = (dimension.height - radius) - 1;

            raphaelRenderUtil.renderCircle(paper, {
                left: left,
                top: top
            }, radius, {
                fill: 'none',
                opacity: 1,
                stroke: '#888',
                'stroke-width': 1
            });
        });
    }
});

module.exports = RaphaelCircleLegend;

},{"./raphaelRenderUtil":70}],65:[function(require,module,exports){
/**
 * @fileoverview Raphael line chart renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var RaphaelLineBase = require('./raphaelLineTypeBase'),
    raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael,
    EMPHASIS_OPACITY = 1,
    DE_EMPHASIS_OPACITY = 0.3;

var RaphaelLineChart = tui.util.defineClass(RaphaelLineBase, /** @lends RaphaelLineChart.prototype */ {
    /**
     * RaphaelLineCharts is graph renderer for line chart.
     * @constructs RaphaelLineChart
     * @extends RaphaelLineTypeBase
     */
    init: function() {
        /**
         * selected legend index
         * @type {?number}
         */
        this.selectedLegendIndex = null;

        /**
         * type of chart
         * @type {string}
         */
        this.chartType = 'line';
    },

    /**
     * Render function of line chart.
     * @param {HTMLElement} container container
     * @param {{groupPositions: Array.<Array>, dimension: object, theme: object, options: object}} data render data
     * @returns {object} paper raphael paper
     */
    render: function(container, data) {
        var dimension = data.dimension,
            groupPositions = data.groupPositions,
            theme = data.theme,
            colors = theme.colors,
            opacity = data.options.hasDot ? 1 : 0,
            isSpline = data.options.spline,
            groupPaths = isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions),
            borderStyle = this.makeBorderStyle(theme.borderColor, opacity),
            outDotStyle = this.makeOutDotStyle(opacity, borderStyle),
            paper;

        this.paper = paper = raphael(container, 1, dimension.height);
        this.isSpline = isSpline;
        this.dimension = dimension;

        this.groupLines = this._renderLines(paper, groupPaths, colors);
        this.tooltipLine = this._renderTooltipLine(paper, dimension.height);
        this.groupDots = this._renderDots(paper, groupPositions, colors, opacity);

        if (data.options.hasSelection) {
            this.selectionDot = this._makeSelectionDot(paper);
            this.selectionColor = theme.selectionColor;
        }

        this.colors = colors;
        this.borderStyle = borderStyle;
        this.outDotStyle = outDotStyle;
        this.groupPositions = groupPositions;
        this.groupPaths = groupPaths;
        this.dotOpacity = opacity;
        delete this.pivotGroupDots;

        return paper;
    },

    /**
     * Get lines path.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @returns {Array.<Array.<string>>} path
     * @private
     */
    _getLinesPath: function(groupPositions) {
        var self = this;

        return tui.util.map(groupPositions, function(positions) {
            positions[0].left -= 1;

            return self._makeLinesPath(positions);
        });
    },

    /**
     * Get spline lines path.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @returns {Array} path
     * @private
     */
    _getSplineLinesPath: function(groupPositions) {
        return tui.util.map(groupPositions, this._makeSplineLinesPath, this);
    },

    /**
     * Render lines.
     * @param {object} paper raphael paper
     * @param {Array.<Array.<string>>} groupPaths paths
     * @param {string[]} colors line colors
     * @param {?number} strokeWidth stroke width
     * @returns {Array.<Array.<object>>} lines
     * @private
     */
    _renderLines: function(paper, groupPaths, colors, strokeWidth) {
        return tui.util.map(groupPaths, function(path, groupIndex) {
            var color = colors[groupIndex] || 'transparent';
            return raphaelRenderUtil.renderLine(paper, path.join(' '), color, strokeWidth);
        });
    },

    /**
     * Resize graph of line chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {Array.<Array.<{left:number, top:number}>>} params.groupPositions group positions
     */
    resize: function(params) {
        var self = this,
            dimension = params.dimension,
            groupPositions = params.groupPositions;

        this.groupPositions = groupPositions;
        this.groupPaths = this.isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);
        this.paper.setSize(dimension.width, dimension.height);
        this.tooltipLine.attr({top: dimension.height});

        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {
            self.groupLines[groupIndex].attr({path: path.join(' ')});

            tui.util.forEachArray(self.groupDots[groupIndex], function(item, index) {
                self._moveDot(item.dot.dot, groupPositions[groupIndex][index]);
            });
        });
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var self = this,
            noneSelected = tui.util.isNull(legendIndex);

        this.selectedLegendIndex = legendIndex;

        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {
            var opacity = (noneSelected || legendIndex === groupIndex) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            self.groupLines[groupIndex].attr({'stroke-opacity': opacity});

            tui.util.forEachArray(self.groupDots[groupIndex], function(item) {
                item.opacity = opacity;

                if (self.dotOpacity) {
                    item.dot.dot.attr({'fill-opacity': opacity});
                }
            });
        });
    }
});

module.exports = RaphaelLineChart;

},{"./raphaelLineTypeBase":66,"./raphaelRenderUtil":70}],66:[function(require,module,exports){
/**
 * @fileoverview RaphaelLineTypeBase is base class for line type renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var ANIMATION_TIME = 700,
    DEFAULT_DOT_RADIUS = 3,
    HOVER_DOT_RADIUS = 4,
    SELECTION_DOT_RADIUS = 7,
    DE_EMPHASIS_OPACITY = 0.3;

var concat = Array.prototype.concat;

/**
 * @classdesc RaphaelLineTypeBase is base for line type renderer.
 * @class RaphaelLineTypeBase
 */
var RaphaelLineTypeBase = tui.util.defineClass(/** @lends RaphaelLineTypeBase.prototype */ {
    /**
     * Make lines path.
     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
     * @param {?string} posTopType position top type
     * @returns {Array.<string | number>} paths
     * @private
     */
    _makeLinesPath: function(positions, posTopType) {
        var path;

        posTopType = posTopType || 'top';
        path = tui.util.map(positions, function(position) {
            return ['L', position.left, position[posTopType]];
        });

        path = concat.apply([], path);
        path[0] = 'M';

        return path;
    },

    /**
     * Get anchor. (http://raphaeljs.com/analytics.js)
     * @param {{left: number, top: number}} fromPos from position
     * @param {{left: number, top: number}} pos position
     * @param {{left: number, top: number}} nextPos next position
     * @returns {{x1: number, y1: number, x2: number, y2: number}} anchor
     * @private
     */
    _getAnchor: function(fromPos, pos, nextPos) {
        var l1 = (pos.left - fromPos.left) / 2,
            l2 = (nextPos.left - pos.left) / 2,
            a = Math.atan((pos.left - fromPos.left) / Math.abs(pos.top - fromPos.top)),
            b = Math.atan((nextPos.left - pos.left) / Math.abs(pos.top - nextPos.top)),
            alpha, dx1, dy1, dx2, dy2;

        a = fromPos.top < pos.top ? Math.PI - a : a;
        b = nextPos.top < pos.top ? Math.PI - b : b;
        alpha = Math.PI / 2 - ((a + b) % (Math.PI * 2)) / 2;
        dx1 = l1 * Math.sin(alpha + a);
        dy1 = l1 * Math.cos(alpha + a);
        dx2 = l2 * Math.sin(alpha + b);
        dy2 = l2 * Math.cos(alpha + b);

        return {
            x1: pos.left - dx1,
            y1: pos.top + dy1,
            x2: pos.left + dx2,
            y2: pos.top + dy2
        };
    },

    /**
     * Make spline lines path.
     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
     * @returns {Array.<string | number>} paths
     * @private
     */
    _makeSplineLinesPath: function(positions) {
        var self = this,
            firstPos = positions[0],
            positionsLen = positions.length,
            fromPos = firstPos,
            lastPos = positions[positionsLen - 1],
            middlePositions = positions.slice(1).slice(0, positionsLen - 2),
            path = tui.util.map(middlePositions, function(position, index) {
                var nextPos = positions[index + 2],
                    anchor = self._getAnchor(fromPos, position, nextPos);
                fromPos = position;
                return [anchor.x1, anchor.y1, position.left, position.top, anchor.x2, anchor.y2];
            });

        firstPos.left -= 1;
        path.push([lastPos.left, lastPos.top, lastPos.left, lastPos.top]);
        path.unshift(['M', firstPos.left, firstPos.top, 'C', firstPos.left, firstPos.top]);

        return path;
    },

    /**
     * Render tooltip line.
     * @param {object} paper raphael paper
     * @param {number} height height
     * @returns {object} raphael object
     * @private
     */
    _renderTooltipLine: function(paper, height) {
        var linePath = raphaelRenderUtil.makeLinePath({
            left: 10,
            top: height
        }, {
            left: 10,
            top: 0
        });

        return raphaelRenderUtil.renderLine(paper, linePath, 'transparent', 1);
    },

    /**
     * Make border style.
     * @param {string} borderColor border color
     * @param {number} opacity opacity
     * @returns {{stroke: string, stroke-width: number, strike-opacity: number}} border style
     */
    makeBorderStyle: function(borderColor, opacity) {
        var borderStyle;

        if (borderColor) {
            borderStyle = {
                stroke: borderColor,
                'stroke-width': 1,
                'stroke-opacity': opacity
            };
        }

        return borderStyle;
    },

    /**
     * Make dot style for mouseout event.
     * @param {number} opacity opacity
     * @param {object} borderStyle border style
     * @returns {{fill-opacity: number, stroke-opacity: number, r: number}} style
     */
    makeOutDotStyle: function(opacity, borderStyle) {
        var outDotStyle = {
            'fill-opacity': opacity,
            'stroke-opacity': 0,
            r: DEFAULT_DOT_RADIUS
        };

        if (borderStyle) {
            tui.util.extend(outDotStyle, borderStyle);
        }

        return outDotStyle;
    },

    /**
     * Render dot.
     * @param {object} paper raphael papaer
     * @param {{left: number, top: number}} position dot position
     * @param {string} color dot color
     * @param {number} opacity opacity
     * @returns {object} raphael dot
     */
    renderDot: function(paper, position, color, opacity) {
        var dot = paper.circle(position.left, position.top, DEFAULT_DOT_RADIUS),
            dotStyle = {
                fill: color,
                'fill-opacity': opacity,
                'stroke-opacity': 0
            };

        dot.attr(dotStyle);

        return {
            dot: dot,
            color: color
        };
    },

    /**
     * Render dots.
     * @param {object} paper raphael paper
     * @param {Array.<Array.<object>>} groupPositions positions
     * @param {string[]} colors colors
     * @param {number} opacity opacity
     * @returns {Array.<object>} dots
     * @private
     */
    _renderDots: function(paper, groupPositions, colors, opacity) {
        var self = this,
            dots = tui.util.map(groupPositions, function(positions, groupIndex) {
                var color = colors[groupIndex];
                return tui.util.map(positions, function(position) {
                    var dotMap = {
                        dot: self.renderDot(paper, position, color, opacity)
                    };
                    var startPositon;

                    if (self.hasRangeData) {
                        startPositon = tui.util.extend({}, position);
                        startPositon.top = startPositon.startTop;
                        dotMap.startDot = self.renderDot(paper, startPositon, color, opacity);
                    }

                    return dotMap;
                });
            });

        return dots;
    },

    /**
     * Get center position
     * @param {{left: number, top: number}} fromPos from position
     * @param {{left: number, top: number}} toPos to position
     * @returns {{left: number, top: number}} position
     * @private
     */
    _getCenter: function(fromPos, toPos) {
        return {
            left: (fromPos.left + toPos.left) / 2,
            top: (fromPos.top + toPos.top) / 2
        };
    },

    /**
     * Show dot.
     * @param {object} dot raphael object
     * @private
     */
    _showDot: function(dot) {
        dot.attr({
            'fill-opacity': 1,
            'stroke-opacity': 0.3,
            'stroke-width': 2,
            r: HOVER_DOT_RADIUS
        });
    },

    /**
     * Update line stroke width.
     * @param {object} line raphael object
     * @param {number} strokeWidth stroke width
     * @private
     */
    _updateLineStrokeWidth: function(line, strokeWidth) {
        line.attr({
            'stroke-width': strokeWidth
        });
    },

    /**
     * Show animation.
     * @param {{groupIndex: number, index:number}} data show info
     */
    showAnimation: function(data) {
        var index = data.groupIndex, // Line chart has pivot values.
            groupIndex = data.index,
            line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex],
            item = this.groupDots[groupIndex][index],
            strokeWidth, startLine;

        if (this.chartType === 'area') {
            strokeWidth = 2;
            startLine = line.startLine;
            line = line.line;
        } else {
            strokeWidth = 3;
        }

        this._updateLineStrokeWidth(line, strokeWidth);

        if (startLine) {
            this._updateLineStrokeWidth(startLine, strokeWidth);
        }

        this._showDot(item.dot.dot);

        if (item.startDot) {
            this._showDot(item.startDot.dot);
        }
    },

    /**
     * Get pivot group dots.
     * @returns {Array.<Array>} dots
     * @private
     */
    _getPivotGroupDots: function() {
        if (!this.pivotGroupDots) {
            this.pivotGroupDots = tui.util.pivot(this.groupDots);
        }

        return this.pivotGroupDots;
    },

    /**
     * Show group dots.
     * @param {number} index index
     * @private
     */
    _showGroupDots: function(index) {
        var self = this,
            groupDots = this._getPivotGroupDots();

        tui.util.forEachArray(groupDots[index], function(item) {
            self._showDot(item.dot.dot);
        });
    },

    /**
     * Show line for group tooltip.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound bound
     */
    showGroupTooltipLine: function(bound) {
        var linePath = raphaelRenderUtil.makeLinePath({
            left: bound.position.left,
            top: bound.position.top + bound.dimension.height
        }, {
            left: bound.position.left,
            top: bound.position.top
        });

        this.tooltipLine.attr({
            path: linePath,
            stroke: '#999',
            'stroke-opacity': 1
        });
    },

    /**
     * Show group animation.
     * @param {number} index index
     */
    showGroupAnimation: function(index) {
        this._showGroupDots(index);
    },

    /**
     * Hide dot.
     * @param {object} dot raphael object
     * @param {?number} opacity opacity
     * @private
     */
    _hideDot: function(dot, opacity) {
        var outDotStyle = this.outDotStyle;

        if (!tui.util.isUndefined(opacity)) {
            outDotStyle = tui.util.extend({}, this.outDotStyle, {
                'fill-opacity': opacity
            });
        }

        dot.attr(outDotStyle);
    },

    /**
     * Hide animation.
     * @param {{groupIndex: number, index:number}} data hide info
     */
    hideAnimation: function(data) {
        var index = data.groupIndex, // Line chart has pivot values.
            groupIndex = data.index,
            line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex],
            item = this.groupDots[groupIndex][index],
            opacity = this.dotOpacity,
            strokeWidth, startLine;

        if (this.chartType === 'area') {
            strokeWidth = 1;
            startLine = line.startLine;
            line = line.line;
        } else {
            strokeWidth = 2;
        }

        if (opacity && !tui.util.isNull(this.selectedLegendIndex) && this.selectedLegendIndex !== groupIndex) {
            opacity = DE_EMPHASIS_OPACITY;
        }

        if (line) {
            this._updateLineStrokeWidth(line, strokeWidth);
        }

        if (startLine) {
            this._updateLineStrokeWidth(startLine, strokeWidth);
        }

        if (item) {
            this._hideDot(item.dot.dot, opacity);

            if (item.startDot) {
                this._hideDot(item.startDot.dot, opacity);
            }
        }
    },

    /**
     * Hide group dots.
     * @param {number} index index
     * @private
     */
    _hideGroupDots: function(index) {
        var self = this,
            dots = this._getPivotGroupDots(),
            hasSelectedIndex = !tui.util.isNull(this.selectedLegendIndex),
            baseOpacity = this.dotOpacity;

        tui.util.forEachArray(dots[index], function(item, groupIndex) {
            var opacity = baseOpacity;

            if (opacity && hasSelectedIndex && self.selectedLegendIndex !== groupIndex) {
                opacity = DE_EMPHASIS_OPACITY;
            }

            self._hideDot(item.dot.dot, opacity);
        });
    },

    /**
     * Hide line for group tooltip.
     */
    hideGroupTooltipLine: function() {
        this.tooltipLine.attr({
            'stroke-opacity': 0
        });
    },

    /**
     * Hide group animation.
     * @param {number} index index
     */
    hideGroupAnimation: function(index) {
        this._hideGroupDots(index);
    },

    _moveDot: function(dot, position) {
        var dotAttrs = {
            cx: position.left,
            cy: position.top
        };

        if (this.dotOpacity) {
            dotAttrs = tui.util.extend({'fill-opacity': this.dotOpacity}, dotAttrs, this.borderStyle);
        }

        dot.attr(dotAttrs);
    },

    /**
     * Animate.
     * @param {function} onFinish callback
     */
    animate: function(onFinish) {
        var self = this,
            seriesWidth = this.dimension.width,
            seriesHeight = this.dimension.height;

        tui.chart.renderUtil.cancelAnimation(this.animation);

        this.animation = tui.chart.renderUtil.startAnimation(ANIMATION_TIME, function(ratio) {
            var width = Math.min(seriesWidth * ratio, seriesWidth);

            self.paper.setSize(width, seriesHeight);

            if (ratio === 1) {
                onFinish();
            }
        });
    },

    /**
     * Make selection dot.
     * @param {object} paper raphael paper
     * @returns {object} selection dot
     * @private
     */
    _makeSelectionDot: function(paper) {
        var selectionDot = paper.circle(0, 0, SELECTION_DOT_RADIUS);

        selectionDot.attr({
            'fill': '#ffffff',
            'fill-opacity': 0,
            'stroke-opacity': 0,
            'stroke-width': 2
        });
        return selectionDot;
    },

    /**
     * Select series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    selectSeries: function(indexes) {
        var item = this.groupDots[indexes.index][indexes.groupIndex],
            position = this.groupPositions[indexes.index][indexes.groupIndex];

        this.selectedItem = item;
        this.selectionDot.attr({
            cx: position.left,
            cy: position.top,
            'fill-opacity': 0.5,
            'stroke-opacity': 1,
            stroke: this.selectionColor || item.dot.color
        });

        if (this.selectionStartDot) {
            this.selectionStartDot.attr({
                cx: position.left,
                cy: position.startTop,
                'fill-opacity': 0.5,
                'stroke-opacity': 1,
                stroke: this.selectionColor || item.startDot.color
            });
        }
    },

    /**
     * Unselect series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    unselectSeries: function(indexes) {
        var item = this.groupDots[indexes.index][indexes.groupIndex];

        if (this.selectedItem === item) {
            this.selectionDot.attr({
                'fill-opacity': 0,
                'stroke-opacity': 0
            });
        }

        if (this.selectionStartDot) {
            this.selectionStartDot.attr({
                'fill-opacity': 0,
                'stroke-opacity': 0
            });
        }
    }
});

module.exports = RaphaelLineTypeBase;

},{"./raphaelRenderUtil":70}],67:[function(require,module,exports){
/**
 * @fileoverview RaphaelPieCharts is graph renderer for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

var STROKE_COLOR = 'gray',
    ANIMATION_TIME = 100;

/**
 * @classdesc RaphaelMapCharts is graph renderer for map chart.
 * @class RaphaelMapChart
 */
var RaphaelMapChart = tui.util.defineClass(/** @lends RaphaelMapChart.prototype */ {
    /**
     * Render function of map chart.
     * @param {HTMLElement} container container
     * @param {object} data data
     *      @param {{width: number, height: number}} data.dimension series dimension
     *      @param {Array.<{code: string, path: string}>} data.map mapData
     *      @param {MapChartColorModel} data.colorModel color model
     * @returns {object} paper raphael paper
     */
    render: function(container, data) {
        var dimension = data.dimension,
            mapDimension = data.mapModel.getMapDimension(),
            paper;

        this.paper = paper = raphael(container, dimension.width, dimension.height);
        this.sectors = this._renderMap(data);
        this.overColor = data.theme.overColor;

        paper.setViewBox(0, 0, mapDimension.width, mapDimension.height, false);

        return paper;
    },

    /**
     * Render map graph.
     * @param {object} data data
     *      @param {{width: number, height: number}} data.dimension series dimension
     *      @param {Array.<{code: string, path: string}>} data.map mapData
     *      @param {MapChartColorModel} data.colorModel color model
     * @returns {Array.<{sector: object, color: string, data: object}>} rendered map information
     * @private
     */
    _renderMap: function(data) {
        var paper = this.paper,
            colorModel = data.colorModel;

        return tui.util.map(data.mapModel.getMapData(), function(datum, index) {
            var ratio = datum.ratio || 0,
                color = colorModel.getColor(ratio),
                sector = raphaelRenderUtil.renderArea(paper, datum.path, {
                    fill: color,
                    opacity: 1,
                    stroke: STROKE_COLOR,
                    'stroke-opacity': 1
                });

            sector.data('index', index);

            return {
                sector: sector,
                color: color,
                ratio: datum.ratio
            };
        });
    },

    /**
     * Find sector index.
     * @param {{left: number, top: number}} position position
     * @returns {?number} found index
     */
    findSectorIndex: function(position) {
        var sector = this.paper.getElementByPoint(position.left, position.top),
            foundIndex = sector && sector.data('index'),
            data = !tui.util.isUndefined(foundIndex) && this.sectors[foundIndex];

        return data && !tui.util.isUndefined(data.ratio) ? foundIndex : null;
    },

    /**
     * Change color.
     * @param {number} index index
     */
    changeColor: function(index) {
        var sector = this.sectors[index];

        sector.sector.animate({
            fill: this.overColor
        }, ANIMATION_TIME);
    },

    /**
     * Restore color.
     * @param {number} index index
     */
    restoreColor: function(index) {
        var sector = this.sectors[index];

        sector.sector.animate({
            fill: sector.color
        }, ANIMATION_TIME);
    },

    /**
     * Set size
     * @param {{width: number, height: number}} dimension dimension
     */
    setSize: function(dimension) {
        this.paper.setSize(dimension.width, dimension.height);
    }
});

module.exports = RaphaelMapChart;

},{"./raphaelRenderUtil":70}],68:[function(require,module,exports){
/**
 * @fileoverview RaphaelMapLegend is graph renderer for map chart legend.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/*eslint no-magic-numbers: 0*/

var raphael = window.Raphael;

var PADDING = 10;

/**
 * @classdesc RaphaelMapLegend is graph renderer for map chart legend.
 * @class RaphaelMapLegend
 */
var RaphaelMapLegend = tui.util.defineClass(/** @lends RaphaelMapLegend.prototype */ {
    /**
     * Render function of map chart legend.
     * @param {HTMLElement} container container
     * @param {{width: number, height: number}} dimension legend dimension
     * @param {MapChartColorModel} colorModel map chart color model
     * @param {boolean} isHorizontal whether horizontal legend or not
     * @returns {object} paper raphael paper
     */
    render: function(container, dimension, colorModel, isHorizontal) {
        var paper = raphael(container, dimension.width, dimension.height);

        this._renderGradientBar(paper, dimension, colorModel, isHorizontal);
        this.wedge = this._renderWedge(paper);

        return paper;
    },

    /**
     * Render gradient bar.
     * @param {object} paper raphael object
     * @param {{width: number, height: number}} dimension legend dimension
     * @param {MapChartColorModel} colorModel map chart color model
     * @param {boolean} isHorizontal whether horizontal legend or not
     * @private
     */
    _renderGradientBar: function(paper, dimension, colorModel, isHorizontal) {
        var rectWidth = dimension.width - PADDING,
            rectHeight = dimension.height,
            left = 0,
            degree;

        if (isHorizontal) {
            rectHeight -= PADDING;
            left = PADDING / 2;
            degree = 360;
            this._makeWedghPath = this._makeHorizontalWedgePath;
        } else {
            degree = 270;
            this._makeWedghPath = this._makeVerticalWedgePath;
        }

        paper.rect(left, 0, rectWidth, rectHeight).attr({
            fill: degree + '-' + colorModel.start + '-' + colorModel.end,
            stroke: 'none'
        });
    },

    /**
     * Render wedge.
     * @param {object} paper raphael object
     * @returns {object} raphael object
     * @private
     */
    _renderWedge: function(paper) {
        var wedge = paper.path(this.verticalBasePath).attr({
            'fill': 'gray',
            stroke: 'none',
            opacity: 0
        });

        return wedge;
    },

    /**
     * Vertical base path
     * @type {Array}
     */
    verticalBasePath: ['M', 16, 6, 'L', 24, 3, 'L', 24, 9],

    /**
     * Make vertical wedge path.
     * @param {number} top top
     * @returns {Array} path
     * @private
     */
    _makeVerticalWedgePath: function(top) {
        var path = this.verticalBasePath;

        path[2] = top;
        path[5] = top - 3;
        path[8] = top + 3;

        return path;
    },

    /**
     * Horizontal base path
     * @type {Array}
     */
    horizontalBasePath: ['M', 5, 16, 'L', 8, 24, 'L', 2, 24],

    /**
     * Make horizontal wedge path.
     * @param {number} left left
     * @returns {Array} path
     * @private
     */
    _makeHorizontalWedgePath: function(left) {
        var path = this.horizontalBasePath;

        left += PADDING / 2;

        path[1] = left;
        path[4] = left + 3;
        path[7] = left - 3;

        return path;
    },

    /**
     * Show wedge.
     * @param {number} positionValue top
     */
    showWedge: function(positionValue) {
        var path = this._makeWedghPath(positionValue);

        this.wedge.attr({
            path: path,
            opacity: 1
        });
    },

    /**
     * Hide wedge
     */
    hideWedge: function() {
        this.wedge.attr({
            opacity: 0
        });
    }
});

module.exports = RaphaelMapLegend;

},{}],69:[function(require,module,exports){
/**
 * @fileoverview RaphaelPieCharts is graph renderer for pie chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael,
    DEGREE_180 = 180,
    DEGREE_360 = 360,
    MIN_DEGREE = 0.01,
    RAD = Math.PI / DEGREE_180,
    ANIMATION_TIME = 500,
    LOADING_ANIMATION_TIME = 700,
    EMPHASIS_OPACITY = 1,
    DE_EMPHASIS_OPACITY = 0.3,
    DEFAULT_LUMINANC = 0.2;

/**
 * @classdesc RaphaelPieCharts is graph renderer for pie chart.
 * @class RaphaelPieChart
 */
var RaphaelPieChart = tui.util.defineClass(/** @lends RaphaelPieChart.prototype */ {
    /**
     * Render function of pie chart.
     * @param {HTMLElement} container container
     * @param {{
     *      sectorData: Array.<object>,
     *      circleBound: {cx: number, cy: number, r: number},
     *      dimension: object, theme: object, options: object
     * }} data render data
     * @param {object} callbacks callbacks
     *      @param {function} callbacks.showTooltip show tooltip function
     *      @param {function} callbacks.hideTooltip hide tooltip function
     * @returns {object} paper raphael paper
     */
    render: function(container, data, callbacks) {
        var dimension = data.dimension,
            paper;

        //Raphael._oid = 0;
        this.paper = paper = raphael(container, dimension.width, dimension.height);

        if (!paper.customAttributes.sector) {
            paper.customAttributes.sector = tui.util.bind(this._makeSectorPath, this);
        }

        this.container = container;
        this.callbacks = callbacks;
        this.selectionColor = data.theme.selectionColor;
        this.circleBound = data.circleBound;

        this._renderPie(paper, data);
        return paper;
    },

    /**
     * Clear paper.
     */
    clear: function() {
        this.paper.clear();
    },
    /**
     * Make sector path.
     * @param {number} cx center x
     * @param {number} cy center y
     * @param {number} r radius
     * @param {number} startAngle start angle
     * @param {number} endAngle end angel
     * @returns {{path: Array}} sector path
     * @private
     */
    _makeSectorPath: function(cx, cy, r, startAngle, endAngle) {
        var x1 = cx + r * Math.sin(startAngle * RAD), // 원 호의 시작 x 좌표
            y1 = cy - r * Math.cos(startAngle * RAD), // 원 호의 시작 y 좌표
            x2 = cx + r * Math.sin(endAngle * RAD), // 원 호의 종료 x 좌표
            y2 = cy - r * Math.cos(endAngle * RAD), // 원 호의 종료 y 좌표
            largeArcFlag = endAngle - startAngle > DEGREE_180 ? 1 : 0,
            path = ['M', cx, cy,
                'L', x1, y1,
                'A', r, r, 0, largeArcFlag, 1, x2, y2,
                'Z'
            ];
        // path에 대한 자세한 설명은 아래 링크를 참고
        // http://www.w3schools.com/svg/svg_path.asp
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
        return {path: path};
    },

    /**
     * Render sector
     * @param {object} params parameters
     *      @param {object} params.paper raphael paper
     *      @param {{cx: number, cy: number, r:number}} params.circleBound circle bounds
     *      @param {number} params.startAngle start angle
     *      @param {number} params.endAngle end angle
     *      @param {{fill: string, stroke: string, strike-width: string}} params.attrs attrs
     * @returns {object} raphael object
     * @private
     */
    _renderSector: function(params) {
        var circleBound = params.circleBound,
            angles = params.angles;

        return params.paper.path().attr({
            sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]
        }).attr(params.attrs);
    },

    /**
     * Render pie graph.
     * @param {object} paper raphael paper
     * @param {{
     *      sectorData: Array.<object>,
     *      circleBound: {cx: number, cy: number, r: number},
     *      dimension: object, theme: object, options: object
     * }} data render data
     * @private
     */
    _renderPie: function(paper, data) {
        var self = this,
            circleBound = data.circleBound,
            colors = data.theme.colors,
            chartBackground = data.chartBackground,
            sectors = [];

        tui.util.forEachArray(data.sectorData, function(sectorDatum, index) {
            var percentValue = sectorDatum.percentValue,
                color = colors[index],
                sector = self._renderSector({
                    paper: paper,
                    circleBound: circleBound,
                    angles: sectorDatum.angles.start,
                    attrs: {
                        fill: color,
                        stroke: chartBackground,
                        'stroke-width': 1
                    }
                });
            sector.data('index', index);
            sectors.push({
                sector: sector,
                color: color,
                angles: sectorDatum.angles.end,
                percentValue: percentValue
            });
        });

        this.sectors = sectors;
    },

    /**
     * Render legend lines.
     * @param {Array.<object>} outerPositions outer position
     */
    renderLegendLines: function(outerPositions) {
        var paper = this.paper,
            paths;

        if (!this.legendLines) {
            paths = this._makeLinePaths(outerPositions);
            this.legendLines = tui.util.map(paths, function(path) {
                return raphaelRenderUtil.renderLine(paper, path, 'transparent', 1);
            });
        }
    },

    /**
     * Make line paths.
     * @param {Array.<object>} outerPositions outer positions
     * @returns {Array} line paths.
     * @private
     */
    _makeLinePaths: function(outerPositions) {
        var paths = tui.util.map(outerPositions, function(positions) {
            return [
                raphaelRenderUtil.makeLinePath(positions.start, positions.middle),
                raphaelRenderUtil.makeLinePath(positions.middle, positions.end),
                'Z'
            ].join('');
        });

        return paths;
    },

    /**
     * Expand selector radius.
     * @param {object} sector pie sector
     */
    _expandSector: function(sector) {
        var cx = this.circleBound.cx,
            cy = this.circleBound.cy;

        sector.animate({
            transform: 's1.1 1.1 ' + cx + ' ' + cy
        }, ANIMATION_TIME, 'elastic');
    },

    /**
     * Restore selector radius.
     * @param {object} sector pie sector
     */
    _restoreSector: function(sector) {
        sector.animate({transform: ''}, ANIMATION_TIME, 'elastic');
    },

    /**
     * animate expanding.
     * @param {number} index sector index
     */
    _animateExpanding: function(index) {
        var sector = this.sectors[index].sector;

        if (this.prevMovedSector) {
            this._animateRestoring(this.prevMovedSector.data('index'));
        }

        this._expandSector(sector);
    },

    /**
     * Animate restoring.
     * @param {number} index sector index
     */
    _animateRestoring: function(index) {
        var sector = this.sectors[index].sector;
        this._restoreSector(sector);
    },

    /**
     * Animate.
     * @param {function} callback callback
     */
    animate: function(callback) {
        var delayTime = 0,
            circleBound = this.circleBound;

        tui.util.forEachArray(this.sectors, function(item) {
            var angles = item.angles,
                animationTime, anim;

            if (angles.startAngle === 0 && angles.endAngle === DEGREE_360) {
                angles.endAngle = DEGREE_360 - MIN_DEGREE;
            }

            animationTime = LOADING_ANIMATION_TIME * item.percentValue;
            anim = raphael.animation({
                sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]
            }, animationTime);

            item.sector.animate(anim.delay(delayTime));
            delayTime += animationTime;
        });

        if (callback) {
            setTimeout(callback, delayTime);
        }
    },

    /**
     * Animate legend lines.
     */
    animateLegendLines: function() {
        if (!this.legendLines) {
            return;
        }

        tui.util.forEachArray(this.legendLines, function(line) {
            line.animate({
                'stroke': 'black',
                'stroke-opacity': 1
            });
        });
    },


    /**
     * Resize graph of pie chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {{cx:number, cy:number, r: number}} params.circleBound circle bound
     */
    resize: function(params) {
        var dimension = params.dimension,
            circleBound = params.circleBound;

        this.circleBound = circleBound;
        this.paper.setSize(dimension.width, dimension.height);
        delete this.containerBound;

        tui.util.forEachArray(this.sectors, function(item) {
            var angles = item.angles;
            item.sector.attr({
                sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]
            });
        });
    },

    /**
     * Move legend lines.
     * @param {Array.<object>} outerPositions outer positions
     */
    moveLegendLines: function(outerPositions) {
        var paths;

        if (!this.legendLines) {
            return;
        }

        paths = this._makeLinePaths(outerPositions);
        tui.util.forEachArray(this.legendLines, function(line, index) {
            line.attr({path: paths[index]});
            return line;
        });
    },

    /**
     * Click series.
     * @param {{left: number, top: number}} position mouse position
     */
    clickSeries: function(position) {
        var sector = this.paper.getElementByPoint(position.left, position.top);

        if (sector && this.prevSelectedSector) {
            this._unselectSeries(this.prevSelectedSector.data('index'));
        }

        if (this.prevSelectedSector === sector) {
            sector = null;
            delete this.prevSelectedSector;
        } else if (sector) {
            this._selectSeries(sector.data('index'));
            this.prevSelectedSector = sector;
        }
    },


    /**
     * Get series container bound.
     * @returns {{left: number, top: number}} container bound
     * @private
     */
    _getContainerBound: function() {
        if (!this.containerBound) {
            this.containerBound = this.container.getBoundingClientRect();
        }
        return this.containerBound;
    },

    /**
     * Whether changed or not.
     * @param {{left: number, top: number}} prevPosition previous position
     * @param {{left: number, top: number}} position position
     * @returns {boolean} result boolean
     * @private
     */
    _isChangedPosition: function(prevPosition, position) {
        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
    },

    /**
     * Move mouse on series.
     * @param {{left: number, top: number}} position mouse position
     */
    moveMouseOnSeries: function(position) {
        var sector = this.paper.getElementByPoint(position.left, position.top),
            containerBound, args, changedSector;

        if (sector && this.sectors[sector.data('index')]) {
            containerBound = this._getContainerBound();
            changedSector = this.prevMovedSector !== sector;
            args = [{}, 0, sector.data('index'), {
                left: position.left - containerBound.left,
                top: position.top - containerBound.top
            }];

            if (changedSector) {
                this._animateExpanding(sector.data('index'));
            }

            if (this._isChangedPosition(this.prevPosition, position)) {
                this.callbacks.showTooltip.apply(null, args);
                this.prevMovedSector = sector;
            }
        } else if (this.prevMovedSector) {
            this._animateRestoring(this.prevMovedSector.data('index'));
            this.callbacks.hideTooltip();
            this.prevMovedSector = null;
        }
        this.prevPosition = position;
    },

    /**
     * Select series.
     * @param {number} index index
     * @private
     */
    _selectSeries: function(index) {
        var item = this.sectors[index],
            objColor = raphael.color(item.color),
            color = this.selectionColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC);

        item.sector.attr({
            fill: color
        });
    },

    /**
     * Unelect series.
     * @param {number} index index
     * @private
     */
    _unselectSeries: function(index) {
        var sector = this.sectors[index];

        sector.sector.attr({
            fill: sector.color
        });
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var isNull = tui.util.isNull(legendIndex);

        tui.util.forEachArray(this.sectors, function(item, index) {
            var opacity;

            opacity = (isNull || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            item.sector.attr({
                'fill-opacity': opacity
            });
        });
    }
});

module.exports = RaphaelPieChart;

},{"./raphaelRenderUtil":70}],70:[function(require,module,exports){
/**
 * @fileoverview Util for raphael rendering.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * Util for raphael rendering.
 * @module raphaelRenderUtil
 */
var raphaelRenderUtil = {
    /**
     * Make line path.
     * @memberOf module:raphaelRenderUtil
     * @param {{top: number, left: number}} fromPos from position
     * @param {{top: number, left: number}} toPos to position
     * @param {number} width width
     * @returns {string} path
     */
    makeLinePath: function(fromPos, toPos, width) {
        var fromPoint = [fromPos.left, fromPos.top],
            toPoint = [toPos.left, toPos.top];

        width = width || 1;

        tui.util.forEachArray(fromPoint, function(from, index) {
            if (from === toPoint[index]) {
                fromPoint[index] = toPoint[index] = Math.round(from) - (width % 2 / 2);
            }
        });
        return ['M'].concat(fromPoint).concat('L').concat(toPoint);
    },

    /**
     * Render line.
     * @memberOf module:raphaelRenderUtil
     * @param {object} paper raphael paper
     * @param {string} path line path
     * @param {string} color line color
     * @param {number} strokeWidth stroke width
     * @returns {object} raphael line
     */
    renderLine: function(paper, path, color, strokeWidth) {
        var line = paper.path([path]),
            strokeStyle = {
                stroke: color,
                'stroke-width': strokeWidth || 2
            };

        if (color === 'transparent') {
            strokeStyle.stroke = '#fff';
            strokeStyle['stroke-opacity'] = 0;
        }
        line.attr(strokeStyle);

        return line;
    },

    /**
     * Render area graph.
     * @param {object} paper raphael paper
     * @param {string} path path
     * @param {object} fillStyle fill style
     *      @param {string} fillStyle.fill fill color
     *      @param {?number} fillStyle.opacity fill opacity
     *      @param {string} fillStyle.stroke stroke color
     *      @param {?number} fillStyle.stroke-opacity stroke opacity
     * @returns {Array.<object>} raphael object
     */
    renderArea: function(paper, path, fillStyle) {
        var area = paper.path(path);

        fillStyle = tui.util.extend({
            'stroke-opacity': 0
        }, fillStyle);
        area.attr(fillStyle);

        return area;
    },

    /**
     * Render circle.
     * @param {object} paper - raphael object
     * @param {{left: number, top: number}} position - position
     * @param {number} radius - radius
     * @param {object} attributes - attributes
     * @returns {object}
     * @private
     */
    renderCircle: function(paper, position, radius, attributes) {
        var circle = paper.circle(position.left, position.top, radius);

        circle.attr(attributes);

        return circle;
    },

    /**
     * Render items of line type chart.
     * @param {Array.<Array.<object>>} groupItems group items
     * @param {function} funcRenderItem function
     */
    forEach2dArray: function(groupItems, funcRenderItem) {
        tui.util.forEachArray(groupItems, function(items, groupIndex) {
            tui.util.forEachArray(items, function(item, index) {
                funcRenderItem(item, groupIndex, index);
            });
        });
    },

    /**
     * Make changed luminance color.
     * @param {string} hex hax color
     * @param {number} lum luminance
     * @returns {string} changed color
     */
    makeChangedLuminanceColor: function(hex, lum) {
        /*eslint no-magic-numbers: 0*/
        var changedHex;

        hex = hex.replace('#', '');
        lum = lum || 0;

        changedHex = tui.util.map(tui.util.range(3), function(index) {
            var hd = parseInt(hex.substr(index * 2, 2), 16);
            var newHd = hd + (hd * lum);

            newHd = Math.round(Math.min(Math.max(0, newHd), 255)).toString(16);
            return tui.chart.renderUtil.formatToZeroFill(newHd, 2);
        }).join('');

        return '#' + changedHex;
    }
};

module.exports = raphaelRenderUtil;

},{}],71:[function(require,module,exports){
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON
if (!window.JSON) {
    window.JSON = {
        parse: function(sJSON) { return eval('(' + sJSON + ')'); },
        stringify: (function () {
            var toString = Object.prototype.toString;
            var isArray = Array.isArray || function (a) { return toString.call(a) === '[object Array]'; };
            var escMap = {'"': '\\"', '\\': '\\\\', '\b': '\\b', '\f': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'};
            var escFunc = function (m) { return escMap[m] || '\\u' + (m.charCodeAt(0) + 0x10000).toString(16).substr(1); };
            var escRE = /[\\"\u0000-\u001F\u2028\u2029]/g;
            return function stringify(value) {
                if (value == null) {
                    return 'null';
                } else if (typeof value === 'number') {
                    return isFinite(value) ? value.toString() : 'null';
                } else if (typeof value === 'boolean') {
                    return value.toString();
                } else if (typeof value === 'object') {
                    if (typeof value.toJSON === 'function') {
                        return stringify(value.toJSON());
                    } else if (isArray(value)) {
                        var res = '[';
                        for (var i = 0; i < value.length; i++)
                            res += (i ? ', ' : '') + stringify(value[i]);
                        return res + ']';
                    } else if (toString.call(value) === '[object Object]') {
                        var tmp = [];
                        for (var k in value) {
                            if (value.hasOwnProperty(k))
                                tmp.push(stringify(k) + ': ' + stringify(value[k]));
                        }
                        return '{' + tmp.join(', ') + '}';
                    }
                }
                return '"' + value.toString().replace(escRE, escFunc) + '"';
            };
        })()
    };
}

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

// MIT license

(function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function (callback) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () {
                    callback(currTime + timeToCall);
                },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }

    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
    }
}());

},{}],72:[function(require,module,exports){
'use strict';

var chartConst = require('./const'),
    chartFactory = require('./factories/chartFactory'),
    BarChart = require('./charts/barChart'),
    ColumnChart = require('./charts/columnChart'),
    LineChart = require('./charts/lineChart'),
    AreaChart = require('./charts/areaChart'),
    ComboChart = require('./charts/comboChart'),
    PieChart = require('./charts/pieChart'),
    BubbleChart = require('./charts/bubbleChart'),
    MapChart = require('./charts/mapChart');

chartFactory.register(chartConst.CHART_TYPE_BAR, BarChart);
chartFactory.register(chartConst.CHART_TYPE_COLUMN, ColumnChart);
chartFactory.register(chartConst.CHART_TYPE_LINE, LineChart);
chartFactory.register(chartConst.CHART_TYPE_AREA, AreaChart);
chartFactory.register(chartConst.CHART_TYPE_COMBO, ComboChart);
chartFactory.register(chartConst.CHART_TYPE_PIE, PieChart);
chartFactory.register(chartConst.CHART_TYPE_BUBBLE, BubbleChart);
chartFactory.register(chartConst.CHART_TYPE_MAP, MapChart);

},{"./charts/areaChart":4,"./charts/barChart":6,"./charts/bubbleChart":8,"./charts/columnChart":10,"./charts/comboChart":11,"./charts/lineChart":13,"./charts/mapChart":15,"./charts/pieChart":18,"./const":20,"./factories/chartFactory":36}],73:[function(require,module,exports){
'use strict';

var chartConst = require('./const'),
    themeFactory = require('./factories/themeFactory'),
    defaultTheme = require('./themes/defaultTheme');

themeFactory.register(chartConst.DEFAULT_THEME_NAME, defaultTheme);

},{"./const":20,"./factories/themeFactory":39,"./themes/defaultTheme":86}],74:[function(require,module,exports){
/**
 * @fileoverview Area chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    LineTypeSeriesBase = require('./lineTypeSeriesBase'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate');

var AreaChartSeries = tui.util.defineClass(Series, /** @lends AreaChartSeries.prototype */ {
    /**
     * Area chart series component.
     * @constructs AreaChartSeries
     * @extends Series
     * @mixes LineTypeSeriesBase
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make position top of zero point.
     * @param {{height: number}} dimension dimension
     * @returns {number} position top
     * @private
     */
    _makePositionTopOfZeroPoint: function() {
        var dimension = this.boundsMaker.getDimension('series'),
            limit = this.data.limit,
            limitDistance = this._getLimitDistanceFromZeroPoint(dimension.height, limit),
            top = limitDistance.toMax;

        if (limit.min >= 0 && !top) {
            top = dimension.height;
        }

        return top + chartConst.SERIES_EXPAND_SIZE;
    },

    /**
     * Make stacked positions.
     * @param {Array.<Array.<{left: number, top: number}>>} groupPositions group positions
     * @returns {Array.<Array.<{left: number, top: number, startTop: number}>>} stacked positions
     * @private
     */
    _makeStackedPositions: function(groupPositions) {
        var height = this.boundsMaker.getDimension('series').height + chartConst.SERIES_EXPAND_SIZE,
            firstStartTop = this._makePositionTopOfZeroPoint(),
            prevPositionTops = [];

        return tui.util.map(groupPositions, function(positions) {
            return tui.util.map(positions, function(position, index) {
                var prevTop = prevPositionTops[index] || firstStartTop,
                    stackedHeight = height - position.top,
                    top = prevTop - stackedHeight;

                position.startTop = prevTop;
                position.top = top;

                prevPositionTops[index] = top;
                return position;
            });
        });
    },

    /**
     * Make positions.
     * @returns {Array.<Array.<{left: number, top: number, startTop: number}>>} stacked positions
     * @private
     */
    _makePositions: function() {
        var groupPositions = this._makeBasicPositions();

        if (predicate.isValidStackedOption(this.options.stacked)) {
            groupPositions = this._makeStackedPositions(groupPositions);
        }

        return groupPositions;
    },

    /**
     * Make series data.
     * @returns {object} series data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        var dimension = this.boundsMaker.getDimension('series'),
            zeroTop = this._getLimitDistanceFromZeroPoint(dimension.height, this.data.limit).toMax;

        return {
            groupPositions: this._makePositions(),
            hasRangeData: this.dataProcessor.getSeriesDataModel(this.chartType).hasRangeData(),
            zeroTop: zeroTop + chartConst.SERIES_EXPAND_SIZE
        };
    }
});

LineTypeSeriesBase.mixin(AreaChartSeries);

module.exports = AreaChartSeries;

},{"../const":20,"../helpers/predicate":47,"./lineTypeSeriesBase":80,"./series":83}],75:[function(require,module,exports){
/**
 * @fileoverview Bar chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    BarTypeSeriesBase = require('./barTypeSeriesBase'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil'),
    calculator = require('../helpers/calculator');

var BarChartSeries = tui.util.defineClass(Series, /** @lends BarChartSeries.prototype */ {
    /**
     * Bar chart series component.
     * @constructs BarChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make bound of bar chart.
     * @param {number} width width
     * @param {number} height height
     * @param {number} top top position value
     * @param {number} startLeft start left position value
     * @param {number} endLeft end left position value
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeBound: function(width, height, top, startLeft, endLeft) {
        return {
            start: {
                top: top,
                left: startLeft,
                width: 0,
                height: height
            },
            end: {
                top: top,
                left: endLeft,
                width: width,
                height: height
            }
        };
    },

    /**
     * Calculate additional left for divided option.
     * @param {number} value value
     * @returns {number}
     * @private
     */
    _calculateAdditionalLeft: function(value) {
        var additionalLeft = 0;

        if (this.options.divided && value > 0) {
            additionalLeft = this.boundsMaker.getDimension('yAxis').width + chartConst.OVERLAPPING_WIDTH;
        }

        return additionalLeft;
    },

    /**
     * Make bar chart bound.
     * @param {{
     *      baseSize: number,
     *      basePosition: number,
     *      step: number,
     *      additionalPosition: ?number,
     *      barSize: number
     * }} baseData base data for making bound
     * @param {{
     *      baseTop: number,
     *      top: number,
     *      plusLeft: number,
     *      minusLeft: number,
     *      prevStack: ?string
     * }} iterationData iteration data
     * @param {?boolean} isStacked whether stacked option or not.
     * @param {SeriesItem} seriesItem series item
     * @param {number} index index
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }}
     * @private
     */
    _makeBarChartBound: function(baseData, iterationData, isStacked, seriesItem, index) {
        var barWidth = baseData.baseBarSize * seriesItem.ratioDistance,
            additionalLeft = this._calculateAdditionalLeft(seriesItem.value),
            barStartLeft = baseData.baseBarSize * seriesItem.startRatio,
            startLeft = baseData.basePosition + barStartLeft + additionalLeft + chartConst.SERIES_EXPAND_SIZE,
            changedStack = (seriesItem.stack !== iterationData.prevStack),
            stepCount, endLeft, bound;

        if (!isStacked || (!this.options.diverging && changedStack)) {
            stepCount = isStacked ? this.dataProcessor.findStackIndex(seriesItem.stack) : index;
            iterationData.top = (baseData.step * stepCount) + iterationData.baseTop + baseData.additionalPosition;
            iterationData.plusLeft = 0;
            iterationData.minusLeft = 0;
        }

        if (seriesItem.value >= 0) {
            endLeft = startLeft + iterationData.plusLeft;
            iterationData.plusLeft += barWidth;
        } else {
            iterationData.minusLeft -= barWidth;
            endLeft = startLeft + iterationData.minusLeft;
        }

        iterationData.prevStack = seriesItem.stack;

        bound = this._makeBound(barWidth, baseData.barSize, iterationData.top, startLeft, endLeft);

        return bound;
    },

    /**
     * Make bounds of bar chart.
     * @returns {Array.<Array.<object>>} bounds
     * @private
     */
    _makeBounds: function() {
        var self = this,
            seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType),
            isStacked = predicate.isValidStackedOption(this.options.stacked),
            dimension = this.boundsMaker.getDimension('series'),
            baseData = this._makeBaseDataForMakingBound(dimension.height, dimension.width);

        return seriesDataModel.map(function(seriesGroup, groupIndex) {
            var baseTop = (groupIndex * baseData.groupSize) + baseData.firstAdditionalPosition
                        + chartConst.SERIES_EXPAND_SIZE,
                iterationData = {
                    baseTop: baseTop,
                    top: baseTop,
                    plusLeft: 0,
                    minusLeft: 0,
                    prevStack: null
                },
                iteratee = tui.util.bind(self._makeBarChartBound, self, baseData, iterationData, isStacked);

            return seriesGroup.map(iteratee);
        });
    },

    /**
     * Make series rendering position
     * @param {{left: number, top: number, width:number, height: number}} bound - bound
     * @param {number} labelHeight - label height
     * @param {number} value - value
     * @param {string} label - label
     * @param {?boolean} isStart - whether start or not
     * @returns {{left: number, top: number}} - rendering position
     * @private
     */
    _makeSeriesRenderingPosition: function(bound, labelHeight, value, label, isStart) {
        var labelWidth = renderUtil.getRenderedLabelWidth(label, this.theme.label),
            left = bound.left,
            top = bound.top + (bound.height - labelHeight + chartConst.TEXT_PADDING) / 2;

        if ((value >= 0 && !isStart) || (value < 0 && isStart)) {
            left += bound.width + chartConst.SERIES_LABEL_PADDING;
        } else {
            left -= labelWidth + chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: top
        };
    },

    /**
     * Calculate top position of sum label.
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {number} top position value
     * @private
     */
    _calculateTopPositionOfSumLabel: function(bound, labelHeight) {
        return bound.top + ((bound.height - labelHeight + chartConst.TEXT_PADDING) / 2);
    },

    /**
     * Make html of plus sum label.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {string} plus sum label html
     * @private
     */
    _makePlusSumLabelHtml: function(values, bound, labelHeight) {
        var sum, formattedSum,
            html = '';

        if (bound) {
            sum = calculator.sumPlusValues(values);
            formattedSum = renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions(), 'series');
            html = this._makeSeriesLabelHtml({
                left: bound.left + bound.width + chartConst.SERIES_LABEL_PADDING,
                top: this._calculateTopPositionOfSumLabel(bound, labelHeight)
            }, formattedSum, -1);
        }

        return html;
    },

    /**
     * Make minus sum label html.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {string} plus minus label html
     * @private
     */
    _makeMinusSumLabelHtml: function(values, bound, labelHeight) {
        var sum, formattedSum, labelWidth,
            html = '';

        if (bound) {
            sum = calculator.sumMinusValues(values);

            if (this.options.diverging) {
                sum = Math.abs(sum);
            }

            formattedSum = renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions(), 'series');
            labelWidth = renderUtil.getRenderedLabelWidth(formattedSum, this.theme.label);
            html = this._makeSeriesLabelHtml({
                left: bound.left - labelWidth - chartConst.SERIES_LABEL_PADDING,
                top: this._calculateTopPositionOfSumLabel(bound, labelHeight)
            }, formattedSum, -1);
        }

        return html;
    }
});

BarTypeSeriesBase.mixin(BarChartSeries);

module.exports = BarChartSeries;

},{"../const":20,"../helpers/calculator":43,"../helpers/predicate":47,"../helpers/renderUtil":49,"./barTypeSeriesBase":76,"./series":83}],76:[function(require,module,exports){
/**
 * @fileoverview Column chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil');

var BarTypeSeriesBase = tui.util.defineClass(/** @lends BarTypeSeriesBase.prototype */ {
    /**
     * Make series data.
     * @returns {object} add data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        this.groupBounds = this._makeBounds(this.boundsMaker.getDimension('series'));

        return {
            groupBounds: this.groupBounds,
            seriesDataModel: this.dataProcessor.getSeriesDataModel(this.chartType)
        };
    },

    /**
     * Make bar gutter.
     * @param {number} groupSize bar group size
     * @param {number} itemCount group item count
     * @returns {number} bar gutter
     * @private
     */
    _makeBarGutter: function(groupSize, itemCount) {
        var baseSize = groupSize / (itemCount + 1) / 2,
            standardSize = 6,
            gutter;

        if (baseSize <= 2) {
            gutter = 0;
        } else if (baseSize <= standardSize) {
            gutter = 2;
        } else {
            gutter = 4;
        }
        return gutter;
    },

    /**
     * Make bar size.
     * @param {number} groupSize bar group size
     * @param {number} barGutter bar padding
     * @param {number} itemCount group item count
     * @returns {number} bar size (width or height)
     * @private
     */
    _makeBarSize: function(groupSize, barGutter, itemCount) {
        return (groupSize - (barGutter * (itemCount - 1))) / (itemCount + 1);
    },

    /**
     * Make option size.
     * @param {number} barSize bar size
     * @param {?number} optionBarWidth barWidth option
     * @returns {number} option size
     * @private
     */
    _makeOptionSize: function(barSize, optionBarWidth) {
        var optionsSize = 0;
        if (optionBarWidth) {
            optionsSize = Math.min(barSize, optionBarWidth);
        }
        return optionsSize;
    },

    /**
     * Calculate difference between optionSize and barSize.
     * @param {number} barSize bar size
     * @param {number} optionSize option size
     * @param {number} itemCount item count
     * @returns {number} addition padding
     * @private
     */
    _calculateAdditionalPosition: function(barSize, optionSize, itemCount) {
        var additionalPosition = 0;

        if (optionSize && optionSize < barSize) {
            additionalPosition = (barSize / 2) + ((barSize - optionSize) * itemCount / 2);
        }

        return additionalPosition;
    },

    /**
     * Make base data for making bound.
     * @param {number} baseGroupSize base group size
     * @param {number} baseBarSize base bar size
     * @returns {{
     *      baseBarSize: number,
     *      groupSize: number,
     *      barSize: number,
     *      step: number,
     *      firstAdditionalPosition: number,
     *      additionalPosition: number,
     *      basePosition: number
     * }}
     * @private
     */
    _makeBaseDataForMakingBound: function(baseGroupSize, baseBarSize) {
        var isStacked = predicate.isValidStackedOption(this.options.stacked),
            seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType),
            groupSize = baseGroupSize / seriesDataModel.getGroupCount(),
            firstAdditionalPosition = 0,
            itemCount, barGutter, barSize, optionSize, additionalPosition, basePosition;

        if (!isStacked) {
            itemCount = seriesDataModel.getFirstSeriesGroup().getSeriesItemCount();
        } else {
            itemCount = this.options.diverging ? 1 : this.dataProcessor.getStackCount();
        }

        barGutter = this._makeBarGutter(groupSize, itemCount);
        barSize = this._makeBarSize(groupSize, barGutter, itemCount);
        optionSize = this._makeOptionSize(barSize, this.options.barWidth);
        additionalPosition = this._calculateAdditionalPosition(barSize, optionSize, itemCount);
        barSize = optionSize || barSize;
        basePosition = this._getLimitDistanceFromZeroPoint(baseBarSize, this.data.limit).toMin;

        if (predicate.isColumnChart(this.chartType)) {
            basePosition = baseBarSize - basePosition;
        }

        if (!this.options.barWidth || barSize < this.options.barWidth) {
            firstAdditionalPosition = (barSize / 2) + additionalPosition;
        }

        return {
            baseBarSize: baseBarSize,
            groupSize: groupSize,
            barSize: barSize,
            step: barGutter + barSize,
            firstAdditionalPosition: firstAdditionalPosition,
            additionalPosition: additionalPosition,
            basePosition: basePosition
        };
    },

    /**
     * Make html for series labels
     * @param {number} groupIndex index of series groups
     * @param {number} labelHeight label height
     * @param {SeriesItem} seriesItem series item
     * @param {number} index index of series group
     * @returns {string}
     * @private
     */
    _makeSeriesLabelsHtml: function(groupIndex, labelHeight, seriesItem, index) {
        var bound = this.seriesData.groupBounds[groupIndex][index].end,
            value = seriesItem.value,
            position = this._makeSeriesRenderingPosition(bound, labelHeight, value, seriesItem.label),
            labelHtml = this._makeSeriesLabelHtml(position, seriesItem.endLabel, index);

        if (seriesItem.isRange) {
            position = this._makeSeriesRenderingPosition(bound, labelHeight, value, seriesItem.startLabel, true);
            labelHtml += this._makeSeriesLabelHtml(position, seriesItem.startLabel, index);
        }

        return labelHtml;
    },

    /**
     * Render normal series label.
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderNormalSeriesLabel: function(elSeriesLabelArea) {
        var self = this,
            seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType),
            firstLabel = seriesDataModel.getFirstItemLabel(),
            labelHeight = renderUtil.getRenderedLabelHeight(firstLabel, this.theme.label),
            html;

        html = seriesDataModel.map(function(seriesGroup, groupIndex) {
            var makeSeriesLabelsHtml = tui.util.bind(self._makeSeriesLabelsHtml, self, groupIndex, labelHeight);

            return seriesGroup.map(makeSeriesLabelsHtml).join('');
        }).join('');

        elSeriesLabelArea.innerHTML = html;
    },

    /**
     * Make sum values.
     * @param {Array.<number>} values values
     * @returns {number} sum result.
     */
    _makeSumValues: function(values) {
        var sum = tui.util.sum(values);

        return renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions(), 'seires');
    },

    /**
     * Make stacked label position.
     * @param {{width: number, height: number, left: number, top: number}} bound element bound
     * @param {string} label label
     * @param {number} labelHeight label height
     * @returns {{left: number, top: number}} position
     * @private
     */
    _makeStackedLabelPosition: function(bound, label, labelHeight) {
        var labelWidth = renderUtil.getRenderedLabelWidth(label, this.theme.label),
            left = bound.left + ((bound.width - labelWidth + chartConst.TEXT_PADDING) / 2),
            top = bound.top + ((bound.height - labelHeight + chartConst.TEXT_PADDING) / 2);

        return {
            left: left,
            top: top
        };
    },

    /**
     * Make stacked labels html.
     * @param {object} params parameters
     *      @param {number} params.groupIndex group index
     *      @param {Array.<object>} params.bounds bounds,
     *      @param {number} params.labelHeight label height
     * @returns {string} labels html
     * @private
     */
    _makeStackedLabelsHtml: function(params) {
        var self = this,
            seriesGroup = params.seriesGroup,
            labelHeight = params.labelHeight,
            htmls, plusBound, minusBound, values;

        htmls = seriesGroup.map(function(seriesItem, index) {
            var bound = params.bounds[index],
                labelHtml = '',
                boundEnd, position;

            if (bound && seriesItem) {
                boundEnd = bound.end;
                position = self._makeStackedLabelPosition(boundEnd, seriesItem.label, params.labelHeight);
                labelHtml = self._makeSeriesLabelHtml(position, seriesItem.label, index);
            }

            if (seriesItem.value > 0) {
                plusBound = boundEnd;
            } else if (seriesItem.value < 0) {
                minusBound = boundEnd;
            }

            return labelHtml;
        });

        if (this.options.stacked === 'normal') {
            values = seriesGroup.pluck('value');
            htmls.push(this._makePlusSumLabelHtml(values, plusBound, labelHeight));
            htmls.push(this._makeMinusSumLabelHtml(values, minusBound, labelHeight));
        }

        return htmls.join('');
    },

    /**
     * Render stacked series label.
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderStackedSeriesLabel: function(elSeriesLabelArea) {
        var self = this,
            groupBounds = this.seriesData.groupBounds,
            seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType),
            firstLabel = seriesDataModel.getFirstItemLabel(this.chartType),
            labelHeight = renderUtil.getRenderedLabelHeight(firstLabel, this.theme.label),
            html;

        html = seriesDataModel.map(function(seriesGroup, index) {
            var labelsHtml = self._makeStackedLabelsHtml({
                groupIndex: index,
                seriesGroup: seriesGroup,
                bounds: groupBounds[index],
                labelHeight: labelHeight
            });
            return labelsHtml;
        }).join('');

        elSeriesLabelArea.innerHTML = html;
    },

    /**
     * Render series label.
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderSeriesLabel: function(elSeriesLabelArea) {
        if (this.options.stacked) {
            this._renderStackedSeriesLabel(elSeriesLabelArea);
        } else {
            this._renderNormalSeriesLabel(elSeriesLabelArea);
        }
    }
});

BarTypeSeriesBase.mixin = function(func) {
    tui.util.extend(func.prototype, BarTypeSeriesBase.prototype);
};

module.exports = BarTypeSeriesBase;

},{"../const":20,"../helpers/predicate":47,"../helpers/renderUtil":49}],77:[function(require,module,exports){
/**
 * @fileoverview Bubble chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    chartConst = require('../const'),
    renderUtil = require('../helpers/renderUtil');

var BubbleChartSeries = tui.util.defineClass(Series, /** @lends BubbleChartSeries.prototype */ {
    /**
     * Bubble chart series component.
     * @constructs BubbleChartSeries
     * @extends Series
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Calculate step value for label axis.
     * @returns {number}
     * @private
     */
    _calculateStep: function() {
        var step = 0;
        var dimension, seriesDataModel, size, len;

        if (this.dataProcessor.hasCategories()) {
            dimension = this.boundsMaker.getDimension('series');
            seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType);
            len = this.dataProcessor.getCategories().length;

            if (seriesDataModel.isXCountGreaterThanYCount()) {
                size = dimension.height;
            } else {
                size = dimension.width;
            }

            step = size / len;
        }

        return step;
    },

    /**
     * Make bound for bubble chart.
     * @param {{x: number, y: number, r: number}} ratioMap - ratio map
     * @param {number} positionByStep - position value by step
     * @param {number} maxRadius - max radius
     * @returns {{left: number, top: number, raius: number}}
     * @private
     */
    _makeBound: function(ratioMap, positionByStep, maxRadius) {
        var dimension = this.boundsMaker.getDimension('series');
        var left = tui.util.isExisty(ratioMap.x) ? (ratioMap.x * dimension.width) : positionByStep;
        var top = tui.util.isExisty(ratioMap.y) ? (ratioMap.y * dimension.height) : positionByStep;

        return {
            left: left,
            top: dimension.height - top,
            radius: Math.max(maxRadius * ratioMap.r, 2)
        };
    },

    /**
     * Make bounds for bubble chart.
     * @returns {Array.<Array.<{left: number, top: number, radius: number}>>} positions
     * @private
     */
    _makeBounds: function() {
        var self = this;
        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType);
        var maxRadius = this.boundsMaker.getMinimumPixelStepForAxis();
        var step = this._calculateStep();
        var start = step ? step / 2 : 0;

        return seriesDataModel.map(function(seriesGroup, index) {
            var positionByStep = start + (step * index);

            return seriesGroup.map(function(seriesItem) {
                var hasRationMap = (seriesItem && seriesItem.ratioMap);

                return hasRationMap ? self._makeBound(seriesItem.ratioMap, positionByStep, maxRadius) : null;
            });
        });
    },

    /**
     * Make series data.
     * @returns {{
     *      groupBounds: Array.<Array.<{left: number, top: number, radius: number}>>,
     *      seriesDataModel: SeriesDataModel
     * }} series data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        return {
            groupBounds: this._makeBounds(),
            seriesDataModel: this.dataProcessor.getSeriesDataModel(this.chartType)
        };
    },

    /**
     * Make series rendering position
     * @param {{left: number, top: number, width:number, height: number}} bound - bound
     * @param {number} labelHeight - label height
     * @param {number} value - value
     * @param {string} label - label
     * @param {?boolean} isStart - whether start or not
     * @returns {{left: number, top: number}} - rendering position
     * @private
     */
    _makeSeriesRenderingPosition: function(bound, labelHeight, value, label, isStart) {
        var labelWidth = renderUtil.getRenderedLabelWidth(label, this.theme.label),
            left = bound.left,
            top = bound.top + (bound.height - labelHeight + chartConst.TEXT_PADDING) / 2;

        if ((value >= 0 && !isStart) || (value < 0 && isStart)) {
            left += bound.width + chartConst.SERIES_LABEL_PADDING;
        } else {
            left -= labelWidth + chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: top
        };
    },

    /**
     * showTooltip is mouseover event callback on series graph.
     * @param {object} params parameters
     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
     * @param {{top:number, left: number, width: number, height: number}} bound graph bound information
     * @param {number} groupIndex group index
     * @param {number} index index
     * @param {{left: number, top: number}} mousePosition mouse position
     */
    showTooltip: function(params, bound, groupIndex, index, mousePosition) {
        this.fire('showTooltip', tui.util.extend({
            indexes: {
                groupIndex: groupIndex,
                index: index
            },
            mousePosition: mousePosition
        }, params));
    },

    /**
     * hideTooltip is mouseout event callback on series graph.
     * @param {string} id tooltip id
     */
    hideTooltip: function() {
        this.fire('hideTooltip');
    },

    /**
     * Render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     * @override
     */
    _renderGraph: function(dimension, seriesData) {
        var showTooltip = tui.util.bind(this.showTooltip, this, {
            chartType: this.chartType
        });
        var callbacks = {
            showTooltip: showTooltip,
            hideTooltip: tui.util.bind(this.hideTooltip, this)
        };
        var params = this._makeParamsForGraphRendering(dimension, seriesData);

        this.graphRenderer.render(this.seriesContainer, params, callbacks);
    },

    /**
     * Make html for label of series area.
     * @param {{left: number, top: number}} basePosition - position
     * @param {string} label - label of SeriesItem
     * @param {number} index - index
     * @returns {string}
     * @private
     */
    _makeSeriesLabelsHtml: function(basePosition, label, index) {
        var labelHeight = renderUtil.getRenderedLabelHeight(label, this.theme.label);
        var labelWidth = renderUtil.getRenderedLabelWidth(label, this.theme.label);
        var position = {
            left: basePosition.left - (labelWidth / 2),
            top: basePosition.top - (labelHeight / 2)
        };

        return this._makeSeriesLabelHtml(position, label, index);
    },

    /**
     * Render series label.
     * @param {HTMLElement} labelContainer - container for label area
     * @private
     */
    _renderSeriesLabel: function(labelContainer) {
        var self = this;
        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType);
        var html = seriesDataModel.map(function(seriesGroup, groupIndex) {
            return seriesGroup.map(function(seriesItem, index) {
                var bound = self.seriesData.groupBounds[groupIndex][index];

                return seriesItem ? self._makeSeriesLabelsHtml(bound, seriesItem.label, index) : '';
            }).join('');
        }).join('');

        labelContainer.innerHTML = html;
    },

    /**
     * On click series.
     * @param {{left: number, top: number}} position mouse position
     */
    onClickSeries: function(position) {
        this._executeGraphRenderer(position, 'clickSeries');
    },

    /**
     * On move series.
     * @param {{left: number, top: number}} position mouse position
     */
    onMoveSeries: function(position) {
        this._executeGraphRenderer(position, 'moveMouseOnSeries');
    }
});

tui.util.CustomEvents.mixin(BubbleChartSeries);

module.exports = BubbleChartSeries;

},{"../const":20,"../helpers/renderUtil":49,"./series":83}],78:[function(require,module,exports){
/**
 * @fileoverview Column chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    BarTypeSeriesBase = require('./barTypeSeriesBase'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil'),
    calculator = require('../helpers/calculator');

var ColumnChartSeries = tui.util.defineClass(Series, /** @lends ColumnChartSeries.prototype */ {
    /**
     * Column chart series component.
     * @constructs ColumnChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make bound of column chart.
     * @param {number} width width
     * @param {number} height height
     * @param {number} left top position value
     * @param {number} startTop start top position value
     * @param {number} endTop end top position value
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeBound: function(width, height, left, startTop, endTop) {
        return {
            start: {
                top: startTop,
                left: left,
                width: width,
                height: 0
            },
            end: {
                top: endTop,
                left: left,
                width: width,
                height: height
            }
        };
    },

    /**
     * Make column chart bound.
     * @param {{
     *      baseSize: number,
     *      basePosition: number,
     *      step: number,
     *      additionalPosition: ?number,
     *      barSize: number
     * }} baseData base data for making bound
     * @param {{
     *      baseLeft: number,
     *      left: number,
     *      plusTop: number,
     *      minusTop: number,
     *      prevStack: ?string
     * }} iterationData iteration data
     * @param {?boolean} isStacked whether stacked option or not.
     * @param {SeriesItem} seriesItem series item
     * @param {number} index index
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }}
     * @private
     */
    _makeColumnChartBound: function(baseData, iterationData, isStacked, seriesItem, index) {
        var barHeight = Math.abs(baseData.baseBarSize * seriesItem.ratioDistance),
            barStartTop = baseData.baseBarSize * seriesItem.startRatio,
            startTop = baseData.basePosition - barStartTop + chartConst.SERIES_EXPAND_SIZE,
            changedStack = (seriesItem.stack !== iterationData.prevStack),
            stepCount, endTop, bound;

        if (!isStacked || (!this.options.diverging && changedStack)) {
            stepCount = isStacked ? this.dataProcessor.findStackIndex(seriesItem.stack) : index;
            iterationData.left = (baseData.step * stepCount) + iterationData.baseLeft + baseData.additionalPosition;
            iterationData.plusTop = 0;
            iterationData.minusTop = 0;
        }

        if (seriesItem.value >= 0) {
            iterationData.plusTop -= barHeight;
            endTop = startTop + iterationData.plusTop;
        } else {
            endTop = startTop + iterationData.minusTop;
            iterationData.minusTop += barHeight;
        }

        iterationData.prevStack = seriesItem.stack;
        bound = this._makeBound(baseData.barSize, barHeight, iterationData.left, startTop, endTop);

        return bound;
    },

    /**
     * Make bounds of column chart.
     * @returns {Array.<Array.<object>>} bounds
     * @private
     */
    _makeBounds: function() {
        var self = this,
            seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType),
            isStacked = predicate.isValidStackedOption(this.options.stacked),
            dimension = this.boundsMaker.getDimension('series'),
            baseData = this._makeBaseDataForMakingBound(dimension.width, dimension.height);

        return seriesDataModel.map(function(seriesGroup, groupIndex) {
            var baseLeft = (groupIndex * baseData.groupSize) + baseData.firstAdditionalPosition
                        + chartConst.SERIES_EXPAND_SIZE,
                iterationData = {
                    baseLeft: baseLeft,
                    left: baseLeft,
                    plusTop: 0,
                    minusTop: 0,
                    prevStack: null
                },
                iteratee = tui.util.bind(self._makeColumnChartBound, self, baseData, iterationData, isStacked);

            return seriesGroup.map(iteratee);
        });
    },

    /**
     * Make series rendering position
     * @param {{left: number, top: number, width:number, height: number}} bound - bound
     * @param {number} labelHeight - label height
     * @param {number} value - value
     * @param {string} label - label of seriesItem
     * @param {?boolean} isStart - whether start or not
     * @returns {{left: number, top: number}} rendering position
     * @private
     */
    _makeSeriesRenderingPosition: function(bound, labelHeight, value, label, isStart) {
        var labelWidth = renderUtil.getRenderedLabelWidth(label, this.theme.label),
            top = bound.top,
            left = bound.left + (bound.width - labelWidth) / 2;

        if ((value >= 0 && !isStart) || (value < 0 && isStart)) {
            top -= labelHeight + chartConst.SERIES_LABEL_PADDING;
        } else {
            top += bound.height + chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: top
        };
    },

    /**
     * Calculate left position of sum label.
     * @param {{left: number, top: number}} bound bound
     * @param {string} formattedSum formatted sum.
     * @returns {number} left position value
     * @private
     */
    _calculateLeftPositionOfSumLabel: function(bound, formattedSum) {
        var labelWidth = renderUtil.getRenderedLabelWidth(formattedSum, this.theme.label);
        return bound.left + ((bound.width - labelWidth + chartConst.TEXT_PADDING) / 2);
    },

    /**
     * Make plus sum label html.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {string} plus sum label html
     * @private
     */
    _makePlusSumLabelHtml: function(values, bound, labelHeight) {
        var sum, formattedSum,
            html = '';

        if (bound) {
            sum = calculator.sumPlusValues(values);
            formattedSum = renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions(), 'series');
            html = this._makeSeriesLabelHtml({
                left: this._calculateLeftPositionOfSumLabel(bound, formattedSum),
                top: bound.top - labelHeight - chartConst.SERIES_LABEL_PADDING
            }, formattedSum, -1);
        }

        return html;
    },

    /**
     * Make minus sum label html.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @returns {string} plus minus label html
     * @private
     */
    _makeMinusSumLabelHtml: function(values, bound) {
        var sum, formattedSum,
            html = '';

        if (bound) {
            sum = calculator.sumMinusValues(values);

            if (this.options.diverging) {
                sum = Math.abs(sum);
            }

            formattedSum = renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions(), 'series');
            html = this._makeSeriesLabelHtml({
                left: this._calculateLeftPositionOfSumLabel(bound, formattedSum),
                top: bound.top + bound.height + chartConst.SERIES_LABEL_PADDING
            }, formattedSum, -1);
        }

        return html;
    }
});

BarTypeSeriesBase.mixin(ColumnChartSeries);

module.exports = ColumnChartSeries;

},{"../const":20,"../helpers/calculator":43,"../helpers/predicate":47,"../helpers/renderUtil":49,"./barTypeSeriesBase":76,"./series":83}],79:[function(require,module,exports){
/**
 * @fileoverview Line chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    LineTypeSeriesBase = require('./lineTypeSeriesBase');

var LineChartSeries = tui.util.defineClass(Series, /** @lends LineChartSeries.prototype */ {
    /**
     * Line chart series component.
     * @constructs LineChartSeries
     * @extends Series
     * @mixes LineTypeSeriesBase
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make positions.
     * @returns {Array.<Array.<{left: number, top: number}>>} positions
     * @private
     */
    _makePositions: function() {
        return this._makeBasicPositions();
    },

    /**
     * Make series data.
     * @returns {object} series data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        return {
            groupPositions: this._makePositions()
        };
    }
});

LineTypeSeriesBase.mixin(LineChartSeries);

module.exports = LineChartSeries;

},{"./lineTypeSeriesBase":80,"./series":83}],80:[function(require,module,exports){
/**
 * @fileoverview LineTypeSeriesBase is base class for line type series.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil');
/**
 * @classdesc LineTypeSeriesBase is base class for line type series.
 * @class LineTypeSeriesBase
 * @mixin
 */
var LineTypeSeriesBase = tui.util.defineClass(/** @lends LineTypeSeriesBase.prototype */ {
    /**
     * Make positions of line chart.
     * @returns {Array.<Array.<object>>} positions
     * @private
     */
    _makeBasicPositions: function() {
        var dimension = this.boundsMaker.getDimension('series'),
            seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType),
            width = dimension.width,
            height = dimension.height,
            len = seriesDataModel.getGroupCount(),
            start = chartConst.SERIES_EXPAND_SIZE,
            step;

        if (this.data.aligned) {
            step = width / (len - 1);
        } else {
            step = width / len;
            start += (step / 2);
        }

        return seriesDataModel.map(function(seriesGroup) {
            return seriesGroup.map(function(seriesItem, index) {
                var position = {
                    left: start + (step * index),
                    top: height - (seriesItem.ratio * height) + chartConst.SERIES_EXPAND_SIZE
                };

                if (tui.util.isExisty(seriesItem.startRatio)) {
                    position.startTop = height - (seriesItem.startRatio * height) + chartConst.SERIES_EXPAND_SIZE;
                }

                return position;
            });
        }, true);
    },

    /**
     * Calculate label position top.
     * @param {{top: number, startTop: number}} basePosition - base position
     * @param {number} value - value of seriesItem
     * @param {number} labelHeight - label height
     * @param {boolean} isStart - whether start value of seriesItem or not
     * @returns {number} position top
     * @private
     */
    _calculateLabelPositionTop: function(basePosition, value, labelHeight, isStart) {
        var baseTop = basePosition.top,
            top;

        if (predicate.isValidStackedOption(this.options.stacked)) {
            top = (basePosition.startTop + baseTop - labelHeight) / 2 + 1;
        } else if ((value >= 0 && !isStart) || (value < 0 && isStart)) {
            top = baseTop - labelHeight - chartConst.SERIES_LABEL_PADDING;
        } else {
            top = baseTop + chartConst.SERIES_LABEL_PADDING;
        }

        return top;
    },

    /**
     * Make label position for rendering label of series area.
     * @param {{left: number, top: number, startTop: ?number}} basePosition - base position for calculating
     * @param {number} labelHeight - label height
     * @param {(string | number)} label - label of seriesItem
     * @param {number} value - value of seriesItem
     * @param {boolean} isStart - whether start label position or not
     * @returns {{left: number, top: number}}
     * @private
     */
    _makeLabelPosition: function(basePosition, labelHeight, label, value, isStart) {
        var labelWidth = renderUtil.getRenderedLabelWidth(label, this.theme.label);

        return {
            left: basePosition.left - (labelWidth / 2),
            top: this._calculateLabelPositionTop(basePosition, value, labelHeight, isStart)
        };
    },

    /**
     * Make html for series label for line type chart.
     * @param {number} groupIndex - index of seriesDataModel.groups
     * @param {number} index - index of seriesGroup.items
     * @param {SeriesItem} seriesItem - series item
     * @param {number} labelHeight - label height
     * @param {boolean} isStart - whether start label position or not
     * @returns {string}
     * @private
     */
    _makeSeriesLabelHtmlForLineType: function(groupIndex, index, seriesItem, labelHeight, isStart) {
        var basePosition = tui.util.extend({}, this.seriesData.groupPositions[groupIndex][index]),
            label, position;

        if (isStart) {
            label = seriesItem.startLabel;
            basePosition.top = basePosition.startTop;
        } else {
            label = seriesItem.endLabel;
        }

        position = this._makeLabelPosition(basePosition, labelHeight, label, seriesItem.value, isStart);

        return this._makeSeriesLabelHtml(position, label, groupIndex);
    },

    /**
     * Render series label.
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderSeriesLabel: function(elSeriesLabelArea) {
        var self = this,
            seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType),
            firstLabel = seriesDataModel.getFirstItemLabel(),
            labelHeight = renderUtil.getRenderedLabelHeight(firstLabel, this.theme.label),
            htmls;

        htmls = seriesDataModel.map(function(seriesGroup, groupIndex) {
            return seriesGroup.map(function(seriesItem, index) {
                var labelHtml = self._makeSeriesLabelHtmlForLineType(groupIndex, index, seriesItem, labelHeight);

                if (seriesItem.isRange) {
                    labelHtml += self._makeSeriesLabelHtmlForLineType(groupIndex, index, seriesItem, labelHeight, true);
                }

                return labelHtml;
            }).join('');
        }, true);

        elSeriesLabelArea.innerHTML = htmls.join('');
    },

    /**
     * Whether changed or not.
     * @param {number} groupIndex group index
     * @param {number} index index
     * @returns {boolean} whether changed or not
     * @private
     */
    _isChanged: function(groupIndex, index) {
        var prevIndexes = this.prevIndexes;

        this.prevIndexes = {
            groupIndex: groupIndex,
            index: index
        };

        return !prevIndexes || (prevIndexes.groupIndex !== groupIndex) || (prevIndexes.index !== index);
    },

    /**
     * To call showGroupTooltipLine function of graphRenderer.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound bound
     */
    onShowGroupTooltipLine: function(bound) {
        if (!this.graphRenderer.showGroupTooltipLine) {
            return;
        }
        this.graphRenderer.showGroupTooltipLine(bound);
    },

    /**
     * To call hideGroupTooltipLine function of graphRenderer.
     */
    onHideGroupTooltipLine: function() {
        if (!this.graphRenderer.hideGroupTooltipLine) {
            return;
        }
        this.graphRenderer.hideGroupTooltipLine();
    }
});

LineTypeSeriesBase.mixin = function(func) {
    tui.util.extend(func.prototype, LineTypeSeriesBase.prototype);
};

module.exports = LineTypeSeriesBase;

},{"../const":20,"../helpers/predicate":47,"../helpers/renderUtil":49}],81:[function(require,module,exports){
/**
 * @fileoverview Map chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

var MapChartSeries = tui.util.defineClass(Series, /** @lends MapChartSeries.prototype */ {
    /**
     * Map chart series component.
     * @constructs MapChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     *      @param {MapChartDataProcessor} params.dataProcessor data processor for map chart
     */
    init: function(params) {
        /**
         * Base position.
         * @type {{left: number, top: number}}
         */
        this.basePosition = {
            left: 0,
            top: 0
        };

        /**
         * Zoom magnification.
         * @type {number}
         */
        this.zoomMagn = 1;

        /**
         * Map ratio.
         * @type {number}
         */
        this.mapRatio = 1;

        /**
         * Graph dimension.
         * @type {{}}
         */
        this.graphDimension = {};

        /**
         * Limit position.
         * @type {{}}
         */
        this.limitPosition = {};

        /**
         * Map model.
         * @type {MapChartMapModel}
         */
        this.mapModel = null;

        /**
         * Previous mouse position.
         * @type {?{left: number, top: number}}
         */
        this.prevPosition = null;


        /**
         * Previous moved index.
         * @type {?number}
         */
        this.prevMovedIndex = null;

        /**
         * Whether drag or not.
         * @type {boolean}
         */
        this.isDrag = false;

        /**
         * Start position.
         * @type {?{left: number, top: number}}
         */
        this.startPosition = null;

        Series.call(this, params);
    },

    /**
     * Set map ratio.
     * @private
     */
    _setMapRatio: function() {
        var seriesDimension = this.boundsMaker.getDimension('series'),
            mapDimension = this.mapModel.getMapDimension(),
            widthRatio = seriesDimension.width / mapDimension.width,
            heightRatio = seriesDimension.height / mapDimension.height;

        this.mapRatio = Math.min(widthRatio, heightRatio);
    },

    /**
     * Set graph dimension.
     * @private
     */
    _setGraphDimension: function() {
        var seriesDimension = this.boundsMaker.getDimension('series');

        this.graphDimension = {
            width: seriesDimension.width * this.zoomMagn,
            height: seriesDimension.height * this.zoomMagn
        };
    },

    /**
     * Render series component.
     * @param {object} data data for rendering
     * @returns {HTMLElement} series element
     */
    render: function(data) {
        var container;

        this.mapModel = data.mapModel;
        this._setMapRatio();

        container = Series.prototype.render.call(this, data);
        return container;
    },

    /**
     * Set limit position to move map.
     * @private
     */
    _setLimitPositionToMoveMap: function() {
        var seriesDimension = this.boundsMaker.getDimension('series'),
            graphDimension = this.graphDimension;

        this.limitPosition = {
            left: seriesDimension.width - graphDimension.width,
            top: seriesDimension.height - graphDimension.height
        };
    },

    /**
     * Render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @private
     * @override
     */
    _renderGraph: function() {
        if (!this.graphContainer) {
            this.graphContainer = dom.create('DIV', 'tui-chart-series-graph-area');
            this.seriesContainer.appendChild(this.graphContainer);
        }

        this._setGraphDimension();
        renderUtil.renderDimension(this.graphContainer, this.graphDimension);

        this._setLimitPositionToMoveMap();

        this.graphRenderer.render(this.graphContainer, {
            colorModel: this.data.colorModel,
            mapModel: this.mapModel,
            dimension: this.graphDimension,
            theme: this.theme
        });
    },

    /**
     * Render series label.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderSeriesLabel: function(seriesLabelContainer) {
        var self = this,
            htmls = tui.util.map(this.mapModel.getLabelData(this.zoomMagn * this.mapRatio), function(datum, index) {
                var label = datum.name || datum.code,
                    left = datum.labelPosition.left - (renderUtil.getRenderedLabelWidth(label, self.theme.label) / 2),
                    top = datum.labelPosition.top - (renderUtil.getRenderedLabelHeight(label, self.theme.label) / 2);

                return self._makeSeriesLabelHtml({
                    left: left,
                    top: top
                }, datum.name, index);
            });
        seriesLabelContainer.innerHTML = htmls.join('');
    },

    /**
     * Render series area.
     * @param {HTMLElement} seriesContainer series area element
     * @param {object} data data for rendering
     * @param {function} funcRenderGraph function for graph rendering
     * @private
     */
    _renderSeriesArea: function(seriesContainer, data, funcRenderGraph) {
        Series.prototype._renderSeriesArea.call(this, seriesContainer, data, funcRenderGraph);
        this.graphContainer.appendChild(this.seriesLabelContainer);
    },

    /**
     * Adjust map position.
     * @param {{left: number, top: number}} targetPosition target position
     * @returns {{left: number, top: number}} adjusted position
     * @private
     */
    _adjustMapPosition: function(targetPosition) {
        return {
            left: Math.max(Math.min(targetPosition.left, 0), this.limitPosition.left),
            top: Math.max(Math.min(targetPosition.top, 0), this.limitPosition.top)
        };
    },

    /**
     * Update base position for zoom.
     * @param {{width: number, height: number}} prevDimension previous dimension
     * @param {{left: number, top: number}} prevLimitPosition previous limit position
     * @param {number} changedRatio changed ratio
     * @private
     */
    _updateBasePositionForZoom: function(prevDimension, prevLimitPosition, changedRatio) {
        var prevBasePosition = this.basePosition,
            prevLeft = prevBasePosition.left - (prevLimitPosition.left / 2),
            prevTop = prevBasePosition.top - (prevLimitPosition.top / 2),
            newBasePosition = {
                left: (prevLeft * changedRatio) + (this.limitPosition.left / 2),
                top: (prevTop * changedRatio) + (this.limitPosition.top / 2)
            };

        this.basePosition = this._adjustMapPosition(newBasePosition);
    },

    /**
     * Zoom.
     * @param {number} changedRatio changed ratio
     * @private
     */
    _zoom: function(changedRatio) {
        var prevDimension = this.graphDimension,
            prevLimitPosition = this.limitPosition;

        this._setGraphDimension();
        renderUtil.renderDimension(this.graphContainer, this.graphDimension);
        this.graphRenderer.setSize(this.graphDimension);

        this._setLimitPositionToMoveMap();
        this._updateBasePositionForZoom(prevDimension, prevLimitPosition, changedRatio);
        renderUtil.renderPosition(this.graphContainer, this.basePosition);

        this._renderSeriesLabel(this.seriesLabelContainer);
    },

    /**
     * Update positions to resize.
     * @param {number} prevMapRatio previous ratio
     * @private
     */
    _updatePositionsToResize: function(prevMapRatio) {
        var changedRatio = this.mapRatio / prevMapRatio;

        this.basePosition.left *= changedRatio;
        this.basePosition.top *= changedRatio;

        this.limitPosition.left *= changedRatio;
        this.limitPosition.top *= changedRatio;
    },

    /**
     * Resize graph.
     * @private
     */
    _resizeGraph: function() {
        var prevRatio = this.mapRatio;

        this._setMapRatio();

        this._setGraphDimension();
        renderUtil.renderDimension(this.graphContainer, this.graphDimension);
        this.graphRenderer.setSize(this.graphDimension);

        this._updatePositionsForResizing(prevRatio);
        renderUtil.renderPosition(this.graphContainer, this.basePosition);

        this._renderSeriesLabel(this.seriesLabelContainer);
    },

    /**
     * On click series.
     */
    onClickSeries: function() {},

    /**
     * Whether changed or not.
     * @param {?{left: number, top: number}} prevPosition previous position
     * @param {{left: number, top: number}} position position
     * @returns {boolean} result boolean
     * @private
     */
    _isChangedPosition: function(prevPosition, position) {
        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
    },

    /**
     * Show wedge.
     * @param {number} index map data index
     * @private
     */
    _showWedge: function(index) {
        var datum = this.mapModel.getDatum(index);

        if (!tui.util.isUndefined(datum.ratio)) {
            this.fire('showWedge', datum.ratio);
        }
    },

    /**
     * Show tooltip
     * @param {number} index map data index
     * @param {{left: number, top: number}} mousePosition mouse position
     * @private
     */
    _showTooltip: function(index, mousePosition) {
        this.fire('showTooltip', {
            chartType: this.chartType,
            indexes: {
                index: index
            },
            mousePosition: mousePosition
        });
    },

    /**
     * Get series container bound.
     * @returns {{left: number, top: number}} container bound
     * @private
     */
    _getContainerBound: function() {
        if (!this.containerBound) {
            this.containerBound = this.seriesContainer.getBoundingClientRect();
        }
        return this.containerBound;
    },

    /**
     * On move series.
     * @param {{left: number, top: number}} position position
     */
    onMoveSeries: function(position) {
        var foundIndex = this._executeGraphRenderer(position, 'findSectorIndex'),
            containerBound;

        if (!tui.util.isNull(foundIndex)) {
            if (this.prevMovedIndex !== foundIndex) {
                if (!tui.util.isNull(this.prevMovedIndex)) {
                    this.graphRenderer.restoreColor(this.prevMovedIndex);
                    this.fire('hideWedge');
                    this.fire('hideTooltip');
                }

                this.graphRenderer.changeColor(foundIndex);
            }

            if (this._isChangedPosition(this.prevPosition, position)) {
                containerBound = this._getContainerBound();
                this._showTooltip(foundIndex, {
                    left: position.left - containerBound.left,
                    top: position.top - containerBound.top
                });
                this.prevMovedIndex = foundIndex;
            }

            this._showWedge(foundIndex);
        } else if (!tui.util.isNull(this.prevMovedIndex)) {
            this.graphRenderer.restoreColor(this.prevMovedIndex);
            this.fire('hideWedge');
            this.fire('hideTooltip');
            this.prevMovedIndex = null;
        }
        this.prevPosition = position;
    },

    /**
     * On drag start series.
     * @param {{left: number, top: number}} position position
     */
    onDragStartSeries: function(position) {
        this.startPosition = {
            left: position.left,
            top: position.top
        };
    },

    /**
     * Move position.
     * @param {{left: number, top: number}} startPosition start position
     * @param {{left: number, top: number}} endPosition end position
     * @private
     */
    _movePosition: function(startPosition, endPosition) {
        var movementPosition = this._adjustMapPosition({
            left: this.basePosition.left + (endPosition.left - startPosition.left),
            top: this.basePosition.top + (endPosition.top - startPosition.top)
        });

        renderUtil.renderPosition(this.graphContainer, movementPosition);

        this.basePosition = movementPosition;
    },

    /**
     * On drag series.
     * @param {{left: number, top: number}} position position
     */
    onDragSeries: function(position) {
        this._movePosition(this.startPosition, position);

        this.startPosition = position;

        if (!this.isDrag) {
            this.isDrag = true;
            this.fire('hideTooltip');
        }
    },

    /**
     * On drag end series.
     */
    onDragEndSeries: function() {
        this.isDrag = false;
    },

    /**
     * Move position for zoom.
     * @param {{left: number, top: number}} position mouse position
     * @param {number} changedRatio changed ratio
     * @private
     */
    _movePositionForZoom: function(position, changedRatio) {
        var seriesDimension = this.boundsMaker.getDimension('series'),
            containerBound = this._getContainerBound(),
            startPosition = {
                left: (seriesDimension.width / 2) + containerBound.left,
                top: (seriesDimension.height / 2) + containerBound.top
            },
            movementPosition = {
                left: position.left - startPosition.left,
                top: position.top - startPosition.top
            },
            endPosition;

        changedRatio = changedRatio > 1 ? -(changedRatio / 2) : changedRatio;

        endPosition = {
            left: startPosition.left + (movementPosition.left * changedRatio),
            top: startPosition.top + (movementPosition.top * changedRatio)
        };

        this._movePosition(startPosition, endPosition);
    },

    /**
     * On zoom.
     * @param {number} newMagn new zoom magnification
     * @param {?{left: number, top: number}} position mouse position
     */
    onZoom: function(newMagn, position) {
        var changedRatio = newMagn / this.zoomMagn;

        this.zoomMagn = newMagn;

        this._zoom(changedRatio);

        if (position) {
            this._movePositionForZoom(position, changedRatio);
        }

        this.userEvent.fire('zoom', newMagn);
    },

    /**
     * Animate component.
     */
    animateComponent: function() {
        this.animateShowingAboutSeriesLabelArea();
    }
});

tui.util.CustomEvents.mixin(MapChartSeries);

module.exports = MapChartSeries;

},{"../helpers/domHandler":45,"../helpers/renderUtil":49,"./series":83}],82:[function(require,module,exports){
/**
 * @fileoverview Pie chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil');

var PieChartSeries = tui.util.defineClass(Series, /** @lends PieChartSeries.prototype */ {
    /**
     * Line chart series component.
     * @constructs PieChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function(params) {
        /**
         * legend align option.
         * @type {boolean}
         */
        this.legendAlign = params.legendAlign;

        /**
         * chart background.
         * @type {string}
         */
        this.chartBackground = params.chartBackground;

        Series.call(this, params);
    },

    /**
     * Make sectors information.
     * @param {{cx: number, cy: number, r: number}} circleBound circle bound
     * @returns {Array.<object>} sectors information
     * @private
     */
    _makeSectorData: function(circleBound) {
        var self = this,
            seriesGroup = this.dataProcessor.getSeriesDataModel(this.chartType).getFirstSeriesGroup(),
            cx = circleBound.cx,
            cy = circleBound.cy,
            r = circleBound.r,
            angle = 0,
            delta = 10,
            paths;

        paths = seriesGroup.map(function(seriesItem) {
            var additionalAngle = chartConst.ANGLE_360 * seriesItem.ratio,
                endAngle = angle + additionalAngle,
                popupAngle = angle + (additionalAngle / 2),
                angles = {
                    start: {
                        startAngle: angle,
                        endAngle: angle
                    },
                    end: {
                        startAngle: angle,
                        endAngle: endAngle
                    }
                },
                positionData = {
                    cx: cx,
                    cy: cy,
                    angle: popupAngle
                };

            angle = endAngle;

            return {
                percentValue: seriesItem.ratio,
                angles: angles,
                centerPosition: self._getArcPosition(tui.util.extend({
                    r: (r / 2) + delta
                }, positionData)),
                outerPosition: {
                    start: self._getArcPosition(tui.util.extend({
                        r: r
                    }, positionData)),
                    middle: self._getArcPosition(tui.util.extend({
                        r: r + delta
                    }, positionData))
                }
            };
        });

        return paths;
    },

    /**
     * Make series data.
     * @returns {{
     *      chartBackground: string,
     *      circleBound: ({cx: number, cy: number, r: number}),
     *      sectorData: Array.<object>
     * }} add data for graph rendering
     * @private
     * @override
     */
    _makeSeriesData: function() {
        var circleBound = this._makeCircleBound(this.boundsMaker.getDimension('series'), {
                showLabel: this.options.showLabel,
                legendAlign: this.legendAlign
            }),
            sectorData = this._makeSectorData(circleBound);

        return {
            chartBackground: this.chartBackground,
            circleBound: circleBound,
            sectorData: sectorData
        };
    },

    /**
     * Make circle bound
     * @param {{width: number, height:number}} dimension chart dimension
     * @param {{showLabel: boolean, legendAlign: string}} options options
     * @returns {{cx: number, cy: number, r: number}} circle bounds
     * @private
     */
    _makeCircleBound: function(dimension, options) {
        var width = dimension.width,
            height = dimension.height,
            isSmallPie = predicate.isLegendAlignOuter(options.legendAlign) && options.showLabel,
            radiusRate = isSmallPie ? chartConst.PIE_GRAPH_SMALL_RATE : chartConst.PIE_GRAPH_DEFAULT_RATE,
            diameter = tui.util.multiplication(Math.min(width, height), radiusRate);

        return {
            cx: tui.util.division(width, 2),
            cy: tui.util.division(height, 2),
            r: tui.util.division(diameter, 2)
        };
    },

    /**
     * Get arc position.
     * @param {object} params parameters
     *      @param {number} params.cx center x
     *      @param {number} params.cy center y
     *      @param {number} params.r radius
     *      @param {number} params.angle angle(degree)
     * @returns {{left: number, top: number}} arc position
     * @private
     */
    _getArcPosition: function(params) {
        return {
            left: params.cx + (params.r * Math.sin(params.angle * chartConst.RAD)),
            top: params.cy - (params.r * Math.cos(params.angle * chartConst.RAD))
        };
    },

    /**
     * Render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     * @override
     */
    _renderGraph: function(dimension, seriesData) {
        var showTootltip = tui.util.bind(this.showTooltip, this, {
                allowNegativeTooltip: !!this.allowNegativeTooltip,
                chartType: this.chartType
            }),
            callbacks = {
                showTooltip: showTootltip,
                hideTooltip: tui.util.bind(this.hideTooltip, this)
            },
            params = this._makeParamsForGraphRendering(dimension, seriesData);

        this.graphRenderer.render(this.seriesContainer, params, callbacks);
    },

    /**
     * Resize.
     * @override
     */
    resize: function() {
        Series.prototype.resize.apply(this, arguments);
        this._moveLegendLines();
    },

    /**
     * showTooltip is mouseover event callback on series graph.
     * @param {object} params parameters
     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
     * @param {{top:number, left: number, width: number, height: number}} bound graph bound information
     * @param {number} groupIndex group index
     * @param {number} index index
     * @param {{left: number, top: number}} mousePosition mouse position
     */
    showTooltip: function(params, bound, groupIndex, index, mousePosition) {
        this.fire('showTooltip', tui.util.extend({
            indexes: {
                groupIndex: groupIndex,
                index: index
            },
            mousePosition: mousePosition
        }, params));
    },

    /**
     * hideTooltip is mouseout event callback on series graph.
     * @param {string} id tooltip id
     */
    hideTooltip: function() {
        this.fire('hideTooltip');
    },

    /**
     * Make series data by selection.
     * @param {number} index index
     * @returns {{indexes: {index: number, groupIndex: number}}} series data
     * @private
     */
    _makeSeriesDataBySelection: function(index) {
        return {
            indexes: {
                index: index,
                groupIndex: index
            }
        };
    },

    /**
     * Get series label.
     * @param {object} params parameters
     *      @param {string} params.legend legend
     *      @param {string} params.label label
     *      @param {string} params.separator separator
     *      @param {{legendAlign: ?string, showLabel: boolean}} params.options options
     * @returns {string} series label
     * @private
     */
    _getSeriesLabel: function(params) {
        var seriesLabel = '';

        if (this.legendAlign) {
            seriesLabel = '<span class="tui-chart-series-legend">' + params.legend + '</span>';
        }

        if (this.options.showLabel) {
            seriesLabel += (seriesLabel ? params.separator : '') + params.label;
        }

        return seriesLabel;
    },

    /**
     * Render center legend.
     * @param {object} params parameters
     *      @param {Array.<object>} params.positions positions
     *      @param {string} params.separator separator
     *      @param {object} params.options options
     *      @param {function} params.funcMoveToPosition function
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderLegendLabel: function(params, seriesLabelContainer) {
        var self = this,
            positions = params.positions,
            htmls;

        htmls = tui.util.map(this.dataProcessor.getLegendLabels(), function(legend, index) {
            var html = '',
                label, position;

            if (positions[index]) {
                label = self._getSeriesLabel({
                    legend: legend,
                    label: self.dataProcessor.getFirstItemLabel(self.chartType),
                    separator: params.separator
                });
                position = params.funcMoveToPosition(positions[index], label);
                html = self._makeSeriesLabelHtml(position, label, index);
            }

            return html;
        });
        seriesLabelContainer.innerHTML = htmls.join('');
    },

    /**
     * Move to center position.
     * @param {{left: number, top: number}} position position
     * @param {string} label label
     * @returns {{left: number, top: number}} center position
     * @private
     */
    _moveToCenterPosition: function(position, label) {
        var left = position.left - (renderUtil.getRenderedLabelWidth(label, this.theme.label) / 2),
            top = position.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);

        return {
            left: left,
            top: top
        };
    },

    /**
     * Pick poistions from sector data.
     * @param {string} positionType position type
     * @returns {Array} positions
     * @private
     */
    _pickPositionsFromSectorData: function(positionType) {
        return tui.util.map(this.seriesData.sectorData, function(datum) {
            return datum.percentValue ? datum[positionType] : null;
        });
    },

    /**
     * Render center legend.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderCenterLegend: function(seriesLabelContainer) {
        this._renderLegendLabel({
            positions: this._pickPositionsFromSectorData('centerPosition'),
            funcMoveToPosition: tui.util.bind(this._moveToCenterPosition, this),
            separator: '<br>'
        }, seriesLabelContainer);
    },

    /**
     * Add end position.
     * @param {number} centerLeft center left
     * @param {Array.<object>} positions positions
     * @private
     */
    _addEndPosition: function(centerLeft, positions) {
        tui.util.forEachArray(positions, function(position) {
            var end;

            if (!position) {
                return;
            }

            end = tui.util.extend({}, position.middle);
            if (end.left < centerLeft) {
                end.left -= chartConst.SERIES_OUTER_LABEL_PADDING;
            } else {
                end.left += chartConst.SERIES_OUTER_LABEL_PADDING;
            }
            position.end = end;
        });
    },

    /**
     * Move to outer position.
     * @param {number} centerLeft center left
     * @param {object} position position
     * @param {string} label label
     * @returns {{left: number, top: number}} outer position
     * @private
     */
    _moveToOuterPosition: function(centerLeft, position, label) {
        var positionEnd = position.end,
            left = positionEnd.left,
            top = positionEnd.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);

        if (left < centerLeft) {
            left -= renderUtil.getRenderedLabelWidth(label, this.theme.label) + chartConst.SERIES_LABEL_PADDING;
        } else {
            left += chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: top
        };
    },

    /**
     * Render outer legend.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderOuterLegend: function(seriesLabelContainer) {
        var centerLeft = this.boundsMaker.getDimension('chart').width / 2,
            outerPositions = this._pickPositionsFromSectorData('outerPosition'),
            filteredPositions = tui.util.filter(outerPositions, function(position) {
                return position;
            });

        this._addEndPosition(centerLeft, filteredPositions);
        this._renderLegendLabel({
            positions: outerPositions,
            funcMoveToPosition: tui.util.bind(this._moveToOuterPosition, this, centerLeft),
            separator: ':&nbsp;'
        }, seriesLabelContainer);

        this.graphRenderer.renderLegendLines(filteredPositions);
    },

    /**
     * Render series label.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderSeriesLabel: function(seriesLabelContainer) {
        var legendAlign = this.legendAlign;

        if (predicate.isLegendAlignOuter(legendAlign)) {
            this._renderOuterLegend(seriesLabelContainer);
        } else {
            this._renderCenterLegend(seriesLabelContainer);
        }
    },

    /**
     * Animate showing about series label area.
     * @override
     */
    animateShowingAboutSeriesLabelArea: function() {
        this.graphRenderer.animateLegendLines();
        Series.prototype.animateShowingAboutSeriesLabelArea.call(this);
    },

    /**
     * Move legend lines.
     * @private
     * @override
     */
    _moveLegendLines: function() {
        var centerLeft = this.boundsMaker.getDimension('chart').width / 2,
            outerPositions = this._pickPositionsFromSectorData('outerPosition'),
            filteredPositions = tui.util.filter(outerPositions, function(position) {
                return position;
            });

        this._addEndPosition(centerLeft, filteredPositions);
        this.graphRenderer.moveLegendLines(filteredPositions);
    },

    /**
     * On click series.
     * @param {{left: number, top: number}} position mouse position
     */
    onClickSeries: function(position) {
        this._executeGraphRenderer(position, 'clickSeries');
    },

    /**
     * On move series.
     * @param {{left: number, top: number}} position mouse position
     */
    onMoveSeries: function(position) {
        this._executeGraphRenderer(position, 'moveMouseOnSeries');
    }
});

tui.util.CustomEvents.mixin(PieChartSeries);

module.exports = PieChartSeries;

},{"../const":20,"../helpers/predicate":47,"../helpers/renderUtil":49,"./series":83}],83:[function(require,module,exports){
/**
 * @fileoverview Series base component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var seriesTemplate = require('./seriesTemplate'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    pluginFactory = require('../factories/pluginFactory');

var Series = tui.util.defineClass(/** @lends Series.prototype */ {
    /**
     * Series base component.
     * @constructs Series
     * @param {object} params parameters
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function(params) {
        var libType = params.libType || chartConst.DEFAULT_PLUGIN;

        /**
         * Chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * Component type
         * @type {string}
         */
        this.componentType = params.componentType;

        /**
         * Data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * User event listener
         * @type {UserEventListener}
         */
        this.userEvent = params.userEvent;

        /**
         * Options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * Theme
         * @type {object}
         */
        this.orgTheme = this.theme = params.theme;

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = !!params.hasAxes;

        /**
         * Graph renderer
         * @type {object}
         */
        this.graphRenderer = pluginFactory.get(libType, params.chartType);

        /**
         * Series view className
         * @type {string}
         */
        this.className = 'tui-chart-series-area';

        /**
         * series container
         * @type {HTMLElement}
         */
        this.seriesContainer = null;

        /**
         * series label container
         * @type {HTMLElement}
         */
        this.seriesLabelContainer = null;

        /**
         * series data
         * @type {Array.<object>}
         */
        this.seriesData = [];

        /**
         * Selected legend index
         * @type {?number}
         */
        this.selectedLegendIndex = null;
    },

    /**
     * Make series data.
     * @private
     * @abstract
     */
    _makeSeriesData: function() {},

    /**
     * Get seriesData
     * @returns {object} series data
     */
    getSeriesData: function() {
        return this.seriesData;
    },

    /**
     * Render series label.
     * @private
     * @abstract
     */
    _renderSeriesLabel: function() {},

    /**
     * Render series label area
     * @param {?HTMLElement} seriesLabelContainer series label area element
     * @returns {HTMLElement} series label area element
     * @private
     */
    _renderSeriesLabelArea: function(seriesLabelContainer) {
        if (!seriesLabelContainer) {
            seriesLabelContainer = dom.create('div', 'tui-chart-series-label-area');
        }

        this._renderSeriesLabel(seriesLabelContainer);
        return seriesLabelContainer;
    },

    /**
     * Render series area.
     * @param {HTMLElement} seriesContainer series area element
     * @param {object} data data for rendering
     * @param {function} funcRenderGraph function for graph rendering
     * @private
     */
    _renderSeriesArea: function(seriesContainer, data, funcRenderGraph) {
        var expansionBound = this.boundsMaker.getBound('extendedSeries'),
            seriesData, seriesLabelContainer;

        this.data = data;

        this.seriesData = seriesData = this._makeSeriesData();

        renderUtil.renderDimension(seriesContainer, expansionBound.dimension);
        this._renderPosition(seriesContainer, expansionBound.position);

        if (funcRenderGraph) {
            funcRenderGraph(expansionBound.dimension, seriesData);
        }

        seriesLabelContainer = this._renderSeriesLabelArea(this.seriesLabelContainer);

        if (!this.seriesLabelContainer) {
            this.seriesLabelContainer = seriesLabelContainer;
            dom.append(seriesContainer, seriesLabelContainer);
        }
    },

    /**
     * Make parameters for graph rendering.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @returns {object} parameters for graph rendering
     * @private
     */
    _makeParamsForGraphRendering: function(dimension, seriesData) {
        return tui.util.extend({
            dimension: dimension,
            chartType: this.chartType,
            theme: this.theme,
            options: this.options
        }, seriesData);
    },

    /**
     * Render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     */
    _renderGraph: function(dimension, seriesData) {
        var params = this._makeParamsForGraphRendering(dimension, seriesData);
        this.graphRenderer.render(this.seriesContainer, params);
    },

    /**
     * Render series component.
     * @param {object} data data for rendering
     * @returns {HTMLElement} series element
     */
    render: function(data) {
        var el = dom.create('DIV', this.className);

        this.seriesContainer = el;
        this._renderSeriesArea(el, data, tui.util.bind(this._renderGraph, this));

        return el;
    },

    /**
     * Update theme.
     * @param {object} theme legend theme
     * @param {?Array.<?boolean>} checkedLegends checked legends
     * @returns {object} updated theme
     * @private
     */
    _updateTheme: function(theme, checkedLegends) {
        var cloneTheme;

        if (!checkedLegends.length) {
            return theme;
        }

        cloneTheme = JSON.parse(JSON.stringify(theme));
        cloneTheme.colors = tui.util.filter(cloneTheme.colors, function(color, index) {
            return checkedLegends[index];
        });

        return cloneTheme;
    },

    /**
     * Rerender
     * @param {object} data data for rendering
     */
    rerender: function(data) {
        if (this.graphRenderer.clear) {
            this.graphRenderer.clear();
        }

        this.seriesContainer.innerHTML = '';
        this.seriesLabelContainer = null;
        this.selectedLegendIndex = null;
        this.seriesData = [];

        if (this.dataProcessor.getGroupCount(this.chartType)) {
            this.theme = this._updateTheme(this.orgTheme, data.checkedLegends);
            this._renderSeriesArea(this.seriesContainer, data, tui.util.bind(this._renderGraph, this));
            if (this.labelShower) {
                clearInterval(this.labelShower.timerId);
            }
            this.animateComponent();
        }
    },

    /**
     * Resize raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     */
    _resizeGraph: function(dimension, seriesData) {
        this.graphRenderer.resize(tui.util.extend({
            dimension: dimension
        }, seriesData));
    },

    /**
     * Resize series component.
     * }} bound series bound
     * @param {object} data data for rendering
     */
    resize: function(data) {
        this._renderSeriesArea(this.seriesContainer, data, tui.util.bind(this._resizeGraph, this));
    },

    /**
     * Render bounds
     * @param {HTMLElement} el series element
     * @param {{top: number, left: number}} position series position
     * @private
     */
    _renderPosition: function(el, position) {
        var hiddenWidth = renderUtil.isOldBrowser() ? 0 : 0;

        renderUtil.renderPosition(el, {
            top: position.top - (hiddenWidth * 2),
            left: position.left - hiddenWidth
        });
    },

    /**
     * Get limit distance from zero point.
     * @param {number} size chart size (width or height)
     * @param {{min: number, max: number}} limit limit
     * @returns {{toMax: number, toMin: number}} pixel distance
     * @private
     */
    _getLimitDistanceFromZeroPoint: function(size, limit) {
        var min = limit.min,
            max = limit.max,
            distance = max - min,
            toMax = 0,
            toMin = 0;

        if (min <= 0 && max >= 0) {
            toMax = (distance + min) / distance * size;
            toMin = (distance - max) / distance * size;
        }

        return {
            toMax: toMax,
            toMin: toMin
        };
    },

    /**
     * Find label element.
     * @param {HTMLElement} elTarget target element
     * @returns {HTMLElement} label element
     * @private
     */
    _findLabelElement: function(elTarget) {
        var elLabel = null;

        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_SERIES_LABEL)) {
            elLabel = elTarget;
        } else {
            elLabel = dom.findParentByClass(elTarget, chartConst.CLASS_NAME_SERIES_LABEL);
        }

        return elLabel;
    },

    /**
     * To call showAnimation function of graphRenderer.
     * @param {{groupIndex: number, index: number}} data data
     */
    onShowAnimation: function(data) {
        if (!this.graphRenderer.showAnimation) {
            return;
        }
        this.graphRenderer.showAnimation(data);
    },

    /**
     * To call hideAnimation function of graphRenderer.
     * @param {{groupIndex: number, index: number}} data data
     */
    onHideAnimation: function(data) {
        if (!this.graphRenderer.hideAnimation) {
            return;
        }
        this.graphRenderer.hideAnimation(data);
    },

    /**
     * To call showGroupAnimation function of graphRenderer.
     * @param {number} index index
     */
    onShowGroupAnimation: function(index) {
        if (!this.graphRenderer.showGroupAnimation) {
            return;
        }
        this.graphRenderer.showGroupAnimation(index);
    },

    /**
     * To call hideGroupAnimation function of graphRenderer.
     * @param {number} index index
     */
    onHideGroupAnimation: function(index) {
        if (!this.graphRenderer.hideGroupAnimation) {
            return;
        }
        this.graphRenderer.hideGroupAnimation(index);
    },

    /**
     * Animate component.
     */
    animateComponent: function() {
        if (this.graphRenderer.animate) {
            this.graphRenderer.animate(tui.util.bind(this.animateShowingAboutSeriesLabelArea, this));
        }
    },

    /**
     * Make opacity cssText.
     * @param {number} opacity opacity
     * @returns {string} cssText
     * @private
     */
    _makeOpacityCssText: (function() {
        var funcMakeOpacityCssText;
        if (renderUtil.isOldBrowser()) {
            funcMakeOpacityCssText = function(opacity) {
                return ';filter: alpha(opacity=' + (opacity * chartConst.OLD_BROWSER_OPACITY_100) + ')';
            };
        } else {
            funcMakeOpacityCssText = function(_opacity) {
                return ';opacity: ' + _opacity;
            };
        }
        return funcMakeOpacityCssText;
    })(),

    /**
     * Make html about series label.
     * @param {{left: number, top: number}} position - position for rendering
     * @param {string} label - label of SeriesItem
     * @param {number} index - index of legend
     * @returns {string}
     * @private
     */
    _makeSeriesLabelHtml: function(position, label, index) {
        var cssObj = tui.util.extend(position, this.theme.label);

        if (!tui.util.isNull(this.selectedLegendIndex) && (this.selectedLegendIndex !== index)) {
            cssObj.opacity = this._makeOpacityCssText(chartConst.SERIES_LABEL_OPACITY);
        } else {
            cssObj.opacity = '';
        }
        return seriesTemplate.tplSeriesLabel({
            cssText: seriesTemplate.tplCssText(cssObj),
            label: label
        });
    },

    /**
     * Animate showing about series label area.
     */
    animateShowingAboutSeriesLabelArea: function() {
        var self = this;

        if ((!this.options.showLabel && !this.legendAlign) || !this.seriesLabelContainer) {
            return;
        }

        dom.addClass(this.seriesLabelContainer, 'show');

        if (renderUtil.isIE7()) {
            this.seriesLabelContainer.style.filter = '';
        } else {
            this.labelShower = new tui.component.Effects.Fade({
                element: this.seriesLabelContainer,
                duration: 300
            });
            this.labelShower.action({
                start: 0,
                end: 1,
                complete: function() {
                    clearInterval(self.labelShower.timerId);
                    delete self.labelShower;
                }
            });
        }
    },

    /**
     * Make exportation data for series type userEvent.
     * @param {object} seriesData series data
     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} export data
     * @private
     */
    _makeExportationSeriesData: function(seriesData) {
        var legendIndex = seriesData.indexes.index,
            legendData = this.dataProcessor.getLegendItem(legendIndex);

        return {
            chartType: legendData.chartType,
            legend: legendData.label,
            legendIndex: legendIndex,
            index: seriesData.indexes.groupIndex
        };
    },

    /**
     * Execute graph renderer.
     * @param {{left: number, top: number}} position mouse position
     * @param {string} funcName function name
     * @returns {*} result.
     * @private
     */
    _executeGraphRenderer: function(position, funcName) {
        var result;

        this.fire('hideTooltipContainer');

        if (this.options.showLabel) {
            dom.removeClass(this.seriesLabelContainer, 'show');
        }

        result = this.graphRenderer[funcName](position);

        if (this.options.showLabel) {
            dom.addClass(this.seriesLabelContainer, 'show');
        }

        this.fire('showTooltipContainer');

        return result;
    },

    /**
     * To call selectSeries callback of userEvent.
     * @param {object} seriesData series data
     */
    onSelectSeries: function(seriesData) {
        this.userEvent.fire('selectSeries', this._makeExportationSeriesData(seriesData));
        if (this.options.hasSelection) {
            this.graphRenderer.selectSeries(seriesData.indexes);
        }
    },

    /**
     * To call unselectSeries callback of userEvent.
     * @param {object} seriesData series data.
     */
    onUnselectSeries: function(seriesData) {
        this.userEvent.fire('unselectSeries', this._makeExportationSeriesData(seriesData));
        if (this.options.hasSelection) {
            this.graphRenderer.unselectSeries(seriesData.indexes);
        }
    },

    /**
     *On select legend.
     * @param {string} chartType chart type
     * @param {?number} legendIndex legend index
     */
    onSelectLegend: function(chartType, legendIndex) {
        if (this.chartType !== chartType && !tui.util.isNull(legendIndex)) {
            legendIndex = -1;
        }

        this.selectedLegendIndex = legendIndex;

        if (this.dataProcessor.getSeriesDataModel(this.chartType).getGroupCount()) {
            this._renderSeriesArea(this.seriesContainer, this.data);
            this.graphRenderer.selectLegend(legendIndex);
        }
    },

    /**
     * Show label.
     */
    showLabel: function() {
        this.options.showLabel = true;
        dom.addClass(this.seriesLabelContainer, 'show opacity');
    },

    /**
     * Hide label.
     */
    hideLabel: function() {
        this.options.showLabel = false;
        dom.removeClass(this.seriesLabelContainer, 'show');
    }
});

module.exports = Series;

},{"../const":20,"../factories/pluginFactory":38,"../helpers/domHandler":45,"../helpers/renderUtil":49,"./seriesTemplate":84}],84:[function(require,module,exports){
/**
 * @fileoverview This is templates of series.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var htmls = {
    HTML_SERIES_LABEL: '<div class="tui-chart-series-label" style="{{ cssText }}">{{ label }}</div>',
    TEXT_CSS_TEXT: 'left:{{ left }}px;top:{{ top }}px;font-family:{{ fontFamily }};' +
        'font-size:{{ fontSize }}px{{opacity}}',
    HTML_ZOOM_BUTTONS: '<a class="tui-chart-zoom-btn" href="#" data-magn="2">' +
            '<div class="horizontal-line"></div><div class="vertical-line"></div></a>' +
        '<a class="tui-chart-zoom-btn" href="#" data-magn="0.5"><div class="horizontal-line"></div></a>'
};

module.exports = {
    tplSeriesLabel: templateMaker.template(htmls.HTML_SERIES_LABEL),
    tplCssText: templateMaker.template(htmls.TEXT_CSS_TEXT),
    ZOOM_BUTTONS: htmls.HTML_ZOOM_BUTTONS
};

},{"../helpers/templateMaker":50}],85:[function(require,module,exports){
/**
 * @fileoverview Zoom component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var seriesTemplate = require('./seriesTemplate'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    eventListener = require('../helpers/eventListener');

var Zoom = tui.util.defineClass(/** @lends Zoom.prototype */{
    /**
     * Zoom component.
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     * @constructs Zoom
     */
    init: function(params) {
        this.className = 'tui-chart-zoom-area';

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Magnification.
         * @type {number}
         */
        this.magn = 1;

        /**
         * Stacked wheelDelta.
         * @type {number}
         */
        this.stackedWheelDelta = 0;
    },

    /**
     * Render.
     * @returns {HTMLElement} zoom container
     */
    render: function() {
        var container = dom.create('DIV', this.className);

        container.innerHTML += seriesTemplate.ZOOM_BUTTONS;
        renderUtil.renderPosition(container, this.boundsMaker.getPosition('series'));
        this._attachEvent(container);

        return container;
    },

    /**
     * Find button element.
     * @param {HTMLElement} target target element.
     * @returns {?HTMLElement} button element
     * @private
     */
    _findBtnElement: function(target) {
        var btnClassName = 'tui-chart-zoom-btn',
            btnElement = target;

        if (!dom.hasClass(target, btnClassName)) {
            btnElement = dom.findParentByClass(target, btnClassName);
        }

        return btnElement;
    },

    /**
     * Zoom
     * @param {number} magn magnification
     * @param {?{left: number, top: number}} position mouse position
     * @private
     */
    _zoom: function(magn, position) {
        var changedMagn = Math.min(Math.max(1, this.magn * magn), chartConst.MAX_ZOOM_MAGN);

        if (changedMagn !== this.magn) {
            this.magn = changedMagn;
            this.fire('zoom', this.magn, position);
        }
    },

    /**
     * On click.
     * @param {MouseEvent} e mouse event
     * @returns {?boolean} prevent default for ie
     * @private
     */
    _onClick: function(e) {
        var target = e.target || e.srcElement,
            btnElement = this._findBtnElement(target),
            magn;

        if (btnElement) {
            magn = parseFloat(btnElement.getAttribute('data-magn'));
            this._zoom(magn);
        }

        if (e.preventDefault) {
            e.preventDefault();
        }

        return false;
    },

    /**
     * Attach event.
     * @param {HTMLElement} target target element
     * @private
     */
    _attachEvent: function(target) {
        eventListener.bindEvent('click', target, this._onClick, this);
    },

    /**
     * Calculate magnification from wheelDelta.
     * @param {number} wheelDelta wheelDelta
     * @returns {number} magnification
     * @private
     */
    _calculateMagn: function(wheelDelta) {
        var tick = parseInt(wheelDelta / chartConst.WHEEL_TICK, 10),
            magn;

        if (tick > 0) {
            magn = Math.pow(2, tick);
        } else {
            magn = Math.pow(0.5, Math.abs(tick));
        }

        return magn;
    },

    /**
     * On wheel.
     * @param {number} wheelDelta wheelDelta
     * @param {{left: number, top: number}} position mouse position
     */
    onWheel: function(wheelDelta, position) {
        var magn;

        if (Math.abs(wheelDelta) < chartConst.WHEEL_TICK) {
            this.stackedWheelDelta += wheelDelta;
        } else {
            this.stackedWheelDelta = wheelDelta;
        }

        if (Math.abs(this.stackedWheelDelta) < chartConst.WHEEL_TICK) {
            return;
        }

        magn = this._calculateMagn(this.stackedWheelDelta);

        this._zoom(magn, position);

        this.stackedWheelDelta = this.stackedWheelDelta % chartConst.WHEEL_TICK;
    }
});

tui.util.CustomEvents.mixin(Zoom);

module.exports = Zoom;

},{"../const":20,"../helpers/domHandler":45,"../helpers/eventListener":46,"../helpers/renderUtil":49,"./seriesTemplate":84}],86:[function(require,module,exports){
'use strict';

var DEFAULT_COLOR = '#000000',
    DEFAULT_BACKGROUND = '#ffffff',
    EMPTY = '',
    DEFAULT_AXIS = {
        tickColor: DEFAULT_COLOR,
        title: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        },
        label: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        }
    };

var defaultTheme = {
    chart: {
        background: DEFAULT_BACKGROUND,
        fontFamily: 'Verdana'
    },
    title: {
        fontSize: 18,
        fontFamily: EMPTY,
        color: DEFAULT_COLOR
    },
    yAxis: DEFAULT_AXIS,
    xAxis: DEFAULT_AXIS,
    plot: {
        lineColor: '#dddddd',
        background: '#ffffff'
    },
    series: {
        label: {
            fontSize: 11,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        },
        colors: ['#ac4142', '#d28445', '#f4bf75', '#90a959', '#75b5aa', '#6a9fb5', '#aa759f', '#8f5536'],
        singleColors: [],
        borderColor: EMPTY,
        selectionColor: EMPTY,
        startColor: '#F4F4F4',
        endColor: '#345391',
        overColor: '#F0C952'
    },
    legend: {
        label: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        }
    },
    tooltip: {}
};

module.exports = defaultTheme;

},{}],87:[function(require,module,exports){
/**
 * @fileoverview Group tooltip component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var TooltipBase = require('./tooltipBase'),
    GroupTooltipPositionModel = require('./groupTooltipPositionModel'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    defaultTheme = require('../themes/defaultTheme'),
    tooltipTemplate = require('./tooltipTemplate');

/**
 * @classdesc GroupTooltip component.
 * @class GroupTooltip
 */
var GroupTooltip = tui.util.defineClass(TooltipBase, /** @lends GroupTooltip.prototype */ {
    /**
     * Group tooltip component.
     * @constructs GroupTooltip
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        TooltipBase.call(this, params);
    },

    /**
     * Make tooltip html.
     * @param {string} category category
     * @param {Array.<{value: string, legend: string, chartType: string, suffix: ?string}>} items items data
     * @returns {string} tooltip html
     * @private
     */
    _makeTooltipHtml: function(category, items) {
        var template = tooltipTemplate.tplGroupItem,
            cssTextTemplate = tooltipTemplate.tplGroupCssText,
            colors = this._makeColors(this.theme),
            itemsHtml = tui.util.map(items, function(item, index) {
                return template(tui.util.extend({
                    cssText: cssTextTemplate({color: colors[index]})
                }, item));
            }).join('');

        return tooltipTemplate.tplGroup({
            category: category,
            items: itemsHtml
        });
    },

    /**
     * Set default align option of tooltip.
     * @private
     * @override
     */
    _setDefaultTooltipPositionOption: function() {
        if (this.options.align) {
            return;
        }

        if (this.isVertical) {
            this.options.align = chartConst.TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION;
        } else {
            this.options.align = chartConst.TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION;
        }
    },

    /**
     * Render tooltip component.
     * @returns {HTMLElement} tooltip element
     * @override
     */
    render: function() {
        var el = TooltipBase.prototype.render.call(this),
            chartDimension = this.boundsMaker.getDimension('chart'),
            bound = this.boundsMaker.getBound('tooltip');

        this.positionModel = new GroupTooltipPositionModel(chartDimension, bound, this.isVertical, this.options);

        return el;
    },

    /**
     * Rerender.
     * @param {{checkedLegends: Array.<boolean>}} data rendering data
     * @override
     */
    rerender: function(data) {
        TooltipBase.prototype.rerender.call(this, data);

        this.theme = this._updateLegendTheme(data.checkedLegends);
    },

    /**
     * Update legend theme.
     * @param {object | Array.<boolean>}checkedLegends checked legends
     * @returns {{colors: Array.<string>}} legend theme
     * @private
     */
    _updateLegendTheme: function(checkedLegends) {
        var colors = [];

        tui.util.forEachArray(this.dataProcessor.getOriginalLegendData(), function(item) {
            var _checkedLegends = checkedLegends[item.chartType] || checkedLegends;
            if (_checkedLegends[item.index]) {
                colors.push(item.theme.color);
            }
        });

        return {
            colors: colors
        };
    },

    /**
     * Make tooltip data.
     * @returns {Array.<object>} tooltip data
     * @override
     */
    _makeTooltipData: function() {
        var self = this;

        return tui.util.map(this.dataProcessor.getSeriesGroups(), function(seriesGroup, index) {
            return {
                category: self.dataProcessor.getCategory(index),
                values: seriesGroup.pluck('label')
            };
        });
    },

    /**
     * Make colors.
     * @param {object} theme tooltip theme
     * @returns {Array.<string>} colors
     * @private
     */
    _makeColors: function(theme) {
        var colorIndex = 0,
            legendLabels = this.dataProcessor.getLegendData(),
            defaultColors, colors, prevChartType;

        if (theme.colors) {
            return theme.colors;
        }

        defaultColors = defaultTheme.series.colors.slice(0, legendLabels.length);

        return tui.util.map(tui.util.pluck(legendLabels, 'chartType'), function(chartType) {
            var color;
            if (prevChartType !== chartType) {
                colors = theme[chartType] ? theme[chartType].colors : defaultColors;
                colorIndex = 0;
            }
            prevChartType = chartType;
            color = colors[colorIndex];
            colorIndex += 1;
            return color;
        });
    },

    /**
     * Make rendering data about legend item.
     * @param {Array.<string>} values values
     * @returns {Array.<{value: string, legend: string, chartType: string, suffix: ?string}>} legend item data.
     * @private
     */
    _makeItemRenderingData: function(values) {
        var dataProcessor = this.dataProcessor,
            suffix = this.suffix;

        return tui.util.map(values, function(value, index) {
            var legendLabel = dataProcessor.getLegendItem(index);

            return {
                value: value,
                legend: legendLabel.label,
                chartType: legendLabel.chartType,
                suffix: suffix
            };
        });
    },

    /**
     * Make tooltip.
     * @param {number} groupIndex group index
     * @returns {string} tooltip html
     * @private
     */
    _makeGroupTooltipHtml: function(groupIndex) {
        var data = this.data[groupIndex],
            items = this._makeItemRenderingData(data.values);

        return this.templateFunc(data.category, items);
    },

    /**
     * Get tooltip sector element.
     * @returns {HTMLElement} sector element
     * @private
     */
    _getTooltipSectorElement: function() {
        var groupTooltipSector;

        if (!this.groupTooltipSector) {
            this.groupTooltipSector = groupTooltipSector = dom.create('DIV', 'tui-chart-group-tooltip-sector');
            dom.append(this.tooltipContainer, groupTooltipSector);
        }

        return this.groupTooltipSector;
    },

    /**
     * Make bound about tooltip sector of vertical type chart.
     * @param {number} height height
     * @param {{start: number, end: number}} range range
     * @param {boolean} isLine whether line or not
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeVerticalTooltipSectorBound: function(height, range, isLine) {
        var width;

        if (isLine) {
            width = 1;
            height += 6;
        } else {
            width = range.end - range.start;
        }

        return {
            dimension: {
                width: width,
                height: height
            },
            position: {
                left: range.start + chartConst.SERIES_EXPAND_SIZE,
                top: chartConst.SERIES_EXPAND_SIZE
            }
        };
    },

    /**
     * Make bound about tooltip sector of horizontal type chart.
     * @param {number} width width
     * @param {{start: number, end:number}} range range
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeHorizontalTooltipSectorBound: function(width, range) {
        return {
            dimension: {
                width: width,
                height: range.end - range.start
            },
            position: {
                left: chartConst.SERIES_EXPAND_SIZE,
                top: range.start + chartConst.SERIES_EXPAND_SIZE
            }
        };
    },

    /**
     * Make bound about tooltip sector.
     * @param {number} size width or height
     * @param {{start: number, end:number}} range range
     * @param {boolean} isVertical whether vertical or not
     * @param {boolean} isLine whether line type or not
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeTooltipSectorBound: function(size, range, isVertical, isLine) {
        var bound;

        if (isVertical) {
            bound = this._makeVerticalTooltipSectorBound(size, range, isLine);
        } else {
            bound = this._makeHorizontalTooltipSectorBound(size, range);
        }

        return bound;
    },

    /**
     * Show tooltip sector.
     * @param {number} size width or height
     * @param {{start: number, end:number}} range range
     * @param {boolean} isVertical whether vertical or not
     * @param {number} index index
     * @private
     */
    _showTooltipSector: function(size, range, isVertical, index) {
        var groupTooltipSector = this._getTooltipSectorElement(),
            isLine = (range.start === range.end),
            bound = this._makeTooltipSectorBound(size, range, isVertical, isLine);

        if (isLine) {
            this.fire('showGroupTooltipLine', bound);
        } else {
            renderUtil.renderDimension(groupTooltipSector, bound.dimension);
            renderUtil.renderPosition(groupTooltipSector, bound.position);
            dom.addClass(groupTooltipSector, 'show');
        }

        this.fire('showGroupAnimation', index);
    },

    /**
     * Hide tooltip sector.
     * @param {number} index index
     * @private
     */
    _hideTooltipSector: function(index) {
        var groupTooltipSector = this._getTooltipSectorElement();

        dom.removeClass(groupTooltipSector, 'show');
        this.fire('hideGroupAnimation', index);
        this.fire('hideGroupTooltipLine');
    },

    /**
     * Show tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{index: number, range: {start: number, end: number},
     *          size: number, direction: string, isVertical: boolean
     *        }} params coordinate event parameters
     * @param {{left: number, top: number}} prevPosition prev position
     * @private
     */
    _showTooltip: function(elTooltip, params, prevPosition) {
        var dimension, position;

        if (!tui.util.isUndefined(this.prevIndex)) {
            this.fire('hideGroupAnimation', this.prevIndex);
        }

        elTooltip.innerHTML = this._makeGroupTooltipHtml(params.index);

        this._fireBeforeShowTooltip(params.index, params.range);

        dom.addClass(elTooltip, 'show');

        this._showTooltipSector(params.size, params.range, params.isVertical, params.index);

        dimension = this.getTooltipDimension(elTooltip);
        position = this.positionModel.calculatePosition(dimension, params.range);

        this._moveToPosition(elTooltip, position, prevPosition);

        this._fireAfterShowTooltip(params.index, params.range, {
            element: elTooltip,
            position: position
        });

        this.prevIndex = params.index;
    },

    /**
     * To call beforeShowTooltip callback of userEvent.
     * @param {number} index index
     * @param {{start: number, end: number}} range range
     * @private
     */
    _fireBeforeShowTooltip: function(index, range) {
        this.userEvent.fire('beforeShowTooltip', {
            index: index,
            range: range
        });
    },

    /**
     * To call afterShowTooltip callback of userEvent.
     * @param {number} index index
     * @param {{start: number, end: number}} range range
     * @param {object} additionParams addition parameters
     * @private
     */
    _fireAfterShowTooltip: function(index, range, additionParams) {
        this.userEvent.fire('afterShowTooltip', tui.util.extend({
            index: index,
            range: range
        }, additionParams));
    },

    /**
     * Hide tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {number} index index
     * @private
     */
    _hideTooltip: function(elTooltip, index) {
        delete this.prevIndex;
        this._hideTooltipSector(index);
        dom.removeClass(elTooltip, 'show');
        elTooltip.style.cssText = '';
    }
});

module.exports = GroupTooltip;

},{"../const":20,"../helpers/domHandler":45,"../helpers/renderUtil":49,"../themes/defaultTheme":86,"./groupTooltipPositionModel":88,"./tooltipBase":92,"./tooltipTemplate":93}],88:[function(require,module,exports){
/**
 * @fileoverview GroupTooltipPositionModel is position model for group tooltip..
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

var GroupTooltipPositionModel = tui.util.defineClass(/** @lends GroupTooltipPositionModel.prototype */ {
    /**
     * GroupTooltipPositionModel is position model for group tooltip.
     * @constructs GroupTooltipPositionModel
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {boolean} isVertical whether vertical or not
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     */
    init: function(chartDimension, areaBound, isVertical, options) {
        /**
         * chart dimension
         * @type {{width: number, height: number}}
         */
        this.chartDimension = chartDimension;

        /**
         * tooltip area bound
         * @type {{dimension: {width: number, height: number}, position: {left: number, top: number}}}
         */
        this.areaBound = areaBound;

        /**
         * Whether vertical or not
         * @type {boolean}
         */
        this.isVertical = isVertical;

        /**
         * tooltip options
         * @type {{align: ?string, position: {left: number, top: number}}}
         */
        this.options = options;

        /**
         * For caching
         * @type {object}
         */
        this.positions = {};

        this._setData(chartDimension, areaBound, isVertical, options);
    },

    /**
     * Get horizontal direction.
     * @param {?string} alignOption align option
     * @returns {string} direction
     * @private
     */
    _getHorizontalDirection: function(alignOption) {
        var direction;

        alignOption = alignOption || '';
        if (alignOption.indexOf('left') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_BACKWARD;
        } else if (alignOption.indexOf('center') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_CENTER;
        } else {
            direction = chartConst.TOOLTIP_DIRECTION_FORWARD;
        }

        return direction;
    },

    /**
     * Make vertical data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {?string} alignOption align option
     * @returns {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} vertical data
     * @private
     */
    _makeVerticalData: function(chartDimension, areaBound, alignOption) {
        var hDirection = this._getHorizontalDirection(alignOption);

        return {
            positionType: 'left',
            sizeType: 'width',
            direction: hDirection,
            areaPosition: areaBound.position.left,
            areaSize: areaBound.dimension.width,
            chartSize: chartDimension.width,
            basePosition: chartConst.SERIES_EXPAND_SIZE
        };
    },

    /**
     * Get vertical direction.
     * @param {?string} alignOption align option
     * @returns {string} direction
     * @private
     */
    _getVerticalDirection: function(alignOption) {
        var direction;

        alignOption = alignOption || '';

        if (alignOption.indexOf('top') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_BACKWARD;
        } else if (alignOption.indexOf('bottom') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_FORWARD;
        } else {
            direction = chartConst.TOOLTIP_DIRECTION_CENTER;
        }

        return direction;
    },

    /**
     * Make horizontal data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {?string} alignOption align option
     * @returns {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} horizontal data
     * @private
     */
    _makeHorizontalData: function(chartDimension, areaBound, alignOption) {
        var vDirection = this._getVerticalDirection(alignOption);

        return {
            positionType: 'top',
            sizeType: 'height',
            direction: vDirection,
            areaPosition: areaBound.position.top,
            areaSize: areaBound.dimension.height,
            chartSize: chartDimension.height,
            basePosition: chartConst.SERIES_EXPAND_SIZE
        };
    },

    /**
     * Set data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {boolean} isVertical whether vertical or not
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     * @private
     */
    _setData: function(chartDimension, areaBound, isVertical, options) {
        var verticalData = this._makeVerticalData(chartDimension, areaBound, options.align),
            horizontalData = this._makeHorizontalData(chartDimension, areaBound, options.align);

        if (isVertical) {
            this.mainData = verticalData;
            this.subData = horizontalData;
        } else {
            this.mainData = horizontalData;
            this.subData = verticalData;
        }

        this.positionOption = tui.util.extend({
            left: 0,
            top: 0
        }, options.position);

        this.positions = {};
    },

    /**
     * Calculate main position value.
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {{start: number, end: number}} range range
     * @param {object} data data
     *      @param {string} data.direction direction
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _calculateMainPositionValue: function(tooltipSize, range, data) {
        var isLine = (range.start === range.end),
            lineTypePadding = 9,
            otherTypePadding = 5,
            padding = isLine ? lineTypePadding : otherTypePadding,
            value = data.basePosition;

        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value += range.end + padding;
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value += range.start - tooltipSize - padding;
        } else if (isLine) {
            value += range.start - tooltipSize / 2;
        } else {
            value += range.start + ((range.end - range.start - tooltipSize) / 2);
        }

        return value;
    },

    /**
     * Calculate sub position value.
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.areaSize tooltip area size (width or height)
     *      @param {string} data.direction direction
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _calculateSubPositionValue: function(tooltipSize, data) {
        var middle = data.areaSize / 2,
            value;

        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = middle + data.basePosition;
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value = middle - tooltipSize + data.basePosition;
        } else {
            value = middle - (tooltipSize / 2) + data.basePosition;
        }

        return value;
    },

    /**
     * Make position value diff.
     * @param {number} value positoin value
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     * @returns {number} diff
     * @private
     */
    _makePositionValueDiff: function(value, tooltipSize, data) {
        return value + data.areaPosition + tooltipSize - data.chartSize;
    },

    /**
     * Adjust backward position value.
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustBackwardPositionValue: function(value, range, tooltipSize, data) {
        var changedValue;

        if (value < -data.areaPosition) {
            changedValue = this._calculateMainPositionValue(tooltipSize, range, {
                direction: chartConst.TOOLTIP_DIRECTION_FORWARD,
                basePosition: data.basePosition
            });
            if (this._makePositionValueDiff(changedValue, tooltipSize, data) > 0) {
                value = -data.areaPosition;
            } else {
                value = changedValue;
            }
        }

        return value;
    },

    /**
     * Adjust forward position value.
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustForwardPositionValue: function(value, range, tooltipSize, data) {
        var diff = this._makePositionValueDiff(value, tooltipSize, data),
            changedValue;

        if (diff > 0) {
            changedValue = this._calculateMainPositionValue(tooltipSize, range, {
                direction: chartConst.TOOLTIP_DIRECTION_BACKWARD,
                basePosition: data.basePosition
            });
            if (changedValue < -data.areaPosition) {
                value -= diff;
            } else {
                value = changedValue;
            }
        }

        return value;
    },

    /**
     * Adjust main position value
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     * @returns {number} position value
     * @private
     */
    _adjustMainPositionValue: function(value, range, tooltipSize, data) {
        if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value = this._adjustBackwardPositionValue(value, range, tooltipSize, data);
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = this._adjustForwardPositionValue(value, range, tooltipSize, data);
        } else {
            value = Math.max(value, -data.areaPosition);
            value = Math.min(value, data.chartSize - data.areaPosition - tooltipSize);
        }

        return value;
    },

    /**
     * Adjust sub position value.
     * @param {number} value position value
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustSubPositionValue: function(value, tooltipSize, data) {
        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = Math.min(value, data.chartSize - data.areaPosition - tooltipSize);
        } else {
            value = Math.max(value, -data.areaPosition);
        }

        return value;
    },

    /**
     * Make caching key.
     * @param {{start: number, end: number}} range range
     * @returns {string} key
     * @private
     */
    _makeCachingKey: function(range) {
        return range.start + '-' + range.end;
    },

    /**
     * Add position option.
     * @param {number} position position
     * @param {string} positionType position type (left or top)
     * @returns {number} position
     * @private
     */
    _addPositionOptionValue: function(position, positionType) {
        return position + this.positionOption[positionType];
    },

    /**
     * Make main position value.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{start: number, end: number}} range tooltip sector range
     * @param {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} main main data
     * @returns {number} position value
     * @private
     */
    _makeMainPositionValue: function(tooltipDimension, range, main) {
        var value;

        value = this._calculateMainPositionValue(tooltipDimension[main.sizeType], range, main);
        value = this._addPositionOptionValue(value, main.positionType);
        value = this._adjustMainPositionValue(value, range, tooltipDimension[main.sizeType], main);

        return value;
    },

    /**
     * Make sub position value.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} sub sub data
     * @returns {number} position value
     * @private
     */
    _makeSubPositionValue: function(tooltipDimension, sub) {
        var value;

        value = this._calculateSubPositionValue(tooltipDimension[sub.sizeType], sub);
        value = this._addPositionOptionValue(value, sub.positionType);
        value = this._adjustSubPositionValue(value, tooltipDimension[sub.sizeType], sub);

        return value;
    },

    /**
     * Calculate group tooltip position.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{start: number, end: number}} range tooltip sector range
     * @returns {{left: number, top: number}} group tooltip position
     */
    calculatePosition: function(tooltipDimension, range) {
        var key = this._makeCachingKey(range),
            main = this.mainData,
            sub = this.subData,
            position = this.positions[key];

        if (!position) {
            position = {};
            position[main.positionType] = this._makeMainPositionValue(tooltipDimension, range, main);
            position[sub.positionType] = this._makeSubPositionValue(tooltipDimension, sub);
            this.positions[key] = position;
        }

        return position;
    },

    /**
     * Update tooltip options for position calculation.
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     */
    updateOptions: function(options) {
        this.options = options;
        this._setData(this.chartDimension, this.areaBound, this.isVertical, options);
    },

    /**
     * Update tooltip bound for position calculation.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound tooltip area bound
     */
    updateBound: function(bound) {
        this.areaBound = bound;
        this._setData(this.chartDimension, bound, this.isVertical, this.options);
    }
});

module.exports = GroupTooltipPositionModel;

},{"../const":20}],89:[function(require,module,exports){
/**
 * @fileoverview Tooltip component for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    TooltipBase = require('./tooltipBase'),
    singleTooltipMixer = require('./singleTooltipMixer'),
    tooltipTemplate = require('./tooltipTemplate');

/**
 * @classdesc MapChartTooltip component.
 * @class MapChartTooltip
 */
var MapChartTooltip = tui.util.defineClass(TooltipBase, /** @lends MapChartTooltip.prototype */ {
    /**
     * Map chart tooltip component.
     * @constructs MapChartTooltip
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        /**
         * Map model
         * @type {MapChartMapModel}
         */
        this.mapModel = null;

        TooltipBase.call(this, params);
    },

    /**
     * Make tooltip html.
     * @param {{name: string, value: number}} datum tooltip datum
     * @returns {string} tooltip html
     * @private
     */
    _makeTooltipHtml: function(datum) {
        return tooltipTemplate.tplMapChartDefault(datum);
    },

    /**
     * Make single tooltip html.
     * @param {string} chartType chart type
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @returns {string} tooltip html
     * @private
     */
    _makeSingleTooltipHtml: function(chartType, indexes) {
        var datum = this.mapModel.getDatum(indexes.index),
            suffix = this.options.suffix ? ' ' + this.options.suffix : '';

        return this.templateFunc({
            name: datum.name || datum.code,
            value: datum.label,
            suffix: suffix
        });
    },

    /**
     * Make parameters for show tooltip user event.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {object} additionParams addition parameters
     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} parameters for show tooltip
     * @private
     */
    _makeShowTooltipParams: function(indexes, additionParams) {
        var datum = this.mapModel.getDatum(indexes.index),
            params;

        params = tui.util.extend({
            chartType: this.chartType,
            code: datum.code,
            name: datum.name,
            value: datum.label,
            index: indexes.index
        }, additionParams);

        return params;
    },


    /**
     * Set default align option of tooltip.
     * @private
     * @override
     */
    _setDefaultTooltipPositionOption: function() {
        if (!this.options.align) {
            this.options.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        }
    },

    /**
     * Render.
     * @param {{mapModel: MapChartMapModel}} data data for rendering
     * @returns {HTMLElement} tooltip element
     */
    render: function(data) {
        this.mapModel = data.mapModel;

        return TooltipBase.prototype.render.call(this);
    }
});

singleTooltipMixer.mixin(MapChartTooltip);
module.exports = MapChartTooltip;

},{"../const":20,"./singleTooltipMixer":90,"./tooltipBase":92,"./tooltipTemplate":93}],90:[function(require,module,exports){
/**
 * @fileoverview singleTooltipMixer is single tooltip mixer of map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

/**
 * singleTooltipMixer is single tooltip mixer of map chart.
 * @mixin
 */
var singleTooltipMixer = {

    /**
     * Fire custom event showAnimation.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} chartType chart type
     * @private
     */
    _fireShowAnimation: function(indexes, chartType) {
        var eventName = renderUtil.makeCustomEventName('show', chartType, 'animation');

        this.fire(eventName, indexes);
    },

    /**
     * Fire custom event hideAnimation.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} chartType chart type
     * @private
     */
    _fireHideAnimation: function(indexes, chartType) {
        var eventName = renderUtil.makeCustomEventName('hide', chartType, 'animation');

        this.fire(eventName, indexes);
    },

    /**
     * Set data indexes.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{groupIndex: number, index:number}} indexes indexes
     * @private
     */
    _setIndexesCustomAttribute: function(elTooltip, indexes) {
        elTooltip.setAttribute('data-groupIndex', indexes.groupIndex);
        elTooltip.setAttribute('data-index', indexes.index);
    },

    /**
     * Get data indexes
     * @param {HTMLElement} elTooltip tooltip element
     * @returns {{groupIndex: number, index: number}} indexes
     * @private
     */
    _getIndexesCustomAttribute: function(elTooltip) {
        var groupIndex = elTooltip.getAttribute('data-groupIndex'),
            index = elTooltip.getAttribute('data-index'),
            indexes = null;

        if (!tui.util.isNull(groupIndex) && !tui.util.isNull(index)) {
            indexes = {
                groupIndex: parseInt(groupIndex, 10),
                index: parseInt(index, 10)
            };
        }
        return indexes;
    },

    /**
     * Set showed custom attribute.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {boolean} status whether showed or not
     * @private
     */
    _setShowedCustomAttribute: function(elTooltip, status) {
        elTooltip.setAttribute('data-showed', status);
    },

    /**
     * Whether showed tooltip or not.
     * @param {HTMLElement} elTooltip tooltip element
     * @returns {boolean} whether showed tooltip or not
     * @private
     */
    _isShowedTooltip: function(elTooltip) {
        var isShowed = elTooltip.getAttribute('data-showed');

        return isShowed === 'true' || isShowed === true; // ie7에서는 boolean형태의 true를 반환함
    },

    /**
     * Make left position of not bar chart.
     * @param {number} baseLeft base left
     * @param {string} alignOption align option
     * @param {number} minusWidth minus width
     * @param {number} lineGap line gap
     * @returns {number} left position value
     * @private
     */
    _makeLeftPositionOfNotBarChart: function(baseLeft, alignOption, minusWidth, lineGap) {
        var left = baseLeft;

        if (alignOption.indexOf('left') > -1) {
            left -= minusWidth + lineGap;
        } else if (alignOption.indexOf('center') > -1) {
            left -= minusWidth / 2;
        } else {
            left += lineGap;
        }

        return left;
    },

    /**
     * Make top position of not bar chart.
     * @param {number} baseTop base top
     * @param {string} alignOption align option
     * @param {number} tooltipHeight tooltip height
     * @param {number} lineGap line gap
     * @returns {number} top position value
     * @private
     */
    _makeTopPositionOfNotBarChart: function(baseTop, alignOption, tooltipHeight, lineGap) {
        var top = baseTop;

        if (alignOption.indexOf('bottom') > -1) {
            top += tooltipHeight + lineGap;
        } else if (alignOption.indexOf('middle') > -1) {
            top += tooltipHeight / 2;
        } else {
            top -= chartConst.TOOLTIP_GAP;
        }

        return top;
    },

    /**
     * Make tooltip position of not bar chart.
     * @param {object} params parameters
     *      @param {{bound: object}} params.data graph information
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _makeTooltipPositionOfNotBarChart: function(params) {
        var bound = params.bound,
            positionOption = params.positionOption,
            minusWidth = params.dimension.width - (bound.width || 0),
            lineGap = bound.width ? 0 : chartConst.TOOLTIP_GAP,
            alignOption = params.alignOption || '',
            tooltipHeight = params.dimension.height,
            baseLeft = bound.left + positionOption.left,
            baseTop = bound.top - tooltipHeight + positionOption.top;

        return {
            left: this._makeLeftPositionOfNotBarChart(baseLeft, alignOption, minusWidth, lineGap),
            top: this._makeTopPositionOfNotBarChart(baseTop, alignOption, tooltipHeight, lineGap)
        };
    },

    /**
     * Make tooltip position to event position.
     * @param {object} params parameters
     *      @param {{left: number, top: number}} params.bound bound
     *      @param {{left: number, top: number}} params.mousePosition mouse position
     * @returns {{top: number, left: number}} position
     * @private
     */
    _makeTooltipPositionToMousePosition: function(params) {
        params.bound = params.bound || {};
        tui.util.extend(params.bound, params.mousePosition);
        return this._makeTooltipPositionOfNotBarChart(params);
    },

    /**
     * Make left position of bar chart.
     * @param {number} baseLeft base left
     * @param {string} alignOption align option
     * @param {number} tooltipWidth tooltip width
     * @returns {number} left position value
     * @private
     */
    _makeLeftPositionOfBarChart: function(baseLeft, alignOption, tooltipWidth) {
        var left = baseLeft;

        if (alignOption.indexOf('left') > -1) {
            left -= tooltipWidth;
        } else if (alignOption.indexOf('center') > -1) {
            left -= tooltipWidth / 2;
        } else {
            left += chartConst.TOOLTIP_GAP;
        }

        return left;
    },

    /**
     * Make top position of bar chart.
     * @param {number} baseTop base top
     * @param {string} alignOption align option
     * @param {number} minusHeight minus width
     * @returns {number} top position value
     * @private
     */
    _makeTopPositionOfBarChart: function(baseTop, alignOption, minusHeight) {
        var top = baseTop;

        if (alignOption.indexOf('top') > -1) {
            top -= minusHeight;
        } else if (alignOption.indexOf('middle') > -1) {
            top -= minusHeight / 2;
        }

        return top;
    },

    /**
     * Make tooltip position of bar chart.
     * @param {object} params parameters
     *      @param {{bound: object}} params.data graph information
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _makeTooltipPositionOfBarChart: function(params) {
        var bound = params.bound,
            positionOption = params.positionOption,
            minusHeight = params.dimension.height - (bound.height || 0),
            alignOption = params.alignOption || '',
            tooltipWidth = params.dimension.width,
            baseLeft = bound.left + bound.width + positionOption.left,
            baseTop = bound.top + positionOption.top;

        return {
            left: this._makeLeftPositionOfBarChart(baseLeft, alignOption, tooltipWidth),
            top: this._makeTopPositionOfBarChart(baseTop, alignOption, minusHeight)
        };
    },

    /**
     * Adjust position.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{left: number, top: number}} position position
     * @returns {{left: number, top: number}} adjusted position
     * @private
     */
    _adjustPosition: function(tooltipDimension, position) {
        var chartDimension = this.boundsMaker.getDimension('chart'),
            areaPosition = this.boundsMaker.getPosition('tooltip');

        position.left = Math.max(position.left, -areaPosition.left);
        position.left = Math.min(position.left, chartDimension.width - areaPosition.left - tooltipDimension.width);
        position.top = Math.max(position.top, -areaPosition.top);
        position.top = Math.min(position.top, chartDimension.height - areaPosition.top - tooltipDimension.height);
        return position;
    },

    /**
     * Make tooltip position.
     * @param {object} params parameters
     *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
     *      @param {string} params.chartType chart type
     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _makeTooltipPosition: function(params) {
        var position = {},
            sizeType, positionType, addPadding;

        if (params.mousePosition) {
            position = this._makeTooltipPositionToMousePosition(params);
        } else {
            if (predicate.isBarChart(params.chartType)) {
                position = this._makeTooltipPositionOfBarChart(params);
                sizeType = 'width';
                positionType = 'left';
                addPadding = 1;
            } else {
                position = this._makeTooltipPositionOfNotBarChart(params);
                sizeType = 'height';
                positionType = 'top';
                addPadding = -1;
            }

            if (params.allowNegativeTooltip) {
                position = this._moveToSymmetry(position, {
                    bound: params.bound,
                    indexes: params.indexes,
                    dimension: params.dimension,
                    chartType: params.chartType,
                    sizeType: sizeType,
                    positionType: positionType,
                    addPadding: addPadding
                });
            }

            position = this._adjustPosition(params.dimension, position);
        }

        return position;
    },

    /**
     * Move to symmetry.
     * @param {{left: number, top: number}} position tooltip position
     * @param {object} params parameters
     *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
     *      @param {string} params.id tooltip id
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.sizeType size type (width or height)
     *      @param {string} params.positionType position type (left or top)
     *      @param {number} params.addPadding add padding
     * @returns {{left: number, top: number}} moved position
     * @private
     */
    _moveToSymmetry: function(position, params) {
        var bound = params.bound,
            sizeType = params.sizeType,
            positionType = params.positionType,
            value = this.dataProcessor.getValue(params.indexes.groupIndex, params.indexes.index, params.chartType),
            tooltipSizeHalf, barPosition, barSizeHalf, movedPositionValue;

        if (value < 0) {
            tooltipSizeHalf = params.dimension[sizeType] / 2;
            barPosition = bound[positionType];
            barSizeHalf = bound[sizeType] / 2;
            movedPositionValue = (barPosition + barSizeHalf - tooltipSizeHalf) * 2 - position[positionType];
            position[positionType] = movedPositionValue;
        }

        return position;
    },

    /**
     * Whether changed indexes or not.
     * @param {{groupIndex: number, index: number}} prevIndexes prev indexes
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @returns {boolean} whether changed or not
     * @private
     */
    _isChangedIndexes: function(prevIndexes, indexes) {
        return !!prevIndexes && (prevIndexes.groupIndex !== indexes.groupIndex || prevIndexes.index !== indexes.index);
    },

    /**
     * Show tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{indexes: {groupIndex: number, index: number}, bound: object}} params tooltip data
     * @param {{left: number, top: number}} prevPosition prev position
     * @private
     */
    _showTooltip: function(elTooltip, params, prevPosition) {
        var indexes = params.indexes,
            prevIndexes = this._getIndexesCustomAttribute(elTooltip),
            prevChartType, position;

        if (this._isChangedIndexes(prevIndexes, indexes)) {
            prevChartType = elTooltip.getAttribute('data-chart-type');
            this._fireHideAnimation(prevIndexes, prevChartType);
        }

        elTooltip.innerHTML = this._makeSingleTooltipHtml(params.chartType, indexes);

        elTooltip.setAttribute('data-chart-type', params.chartType);
        this._setIndexesCustomAttribute(elTooltip, indexes);
        this._setShowedCustomAttribute(elTooltip, true);

        this._fireBeforeShowTooltip(indexes);

        dom.addClass(elTooltip, 'show');

        position = this._makeTooltipPosition(tui.util.extend({
            dimension: this.getTooltipDimension(elTooltip),
            positionOption: tui.util.extend({
                left: 0,
                top: 0
            }, this.options.position),
            alignOption: this.options.align || ''
        }, params));

        this._moveToPosition(elTooltip, position, prevPosition);
        this._fireShowAnimation(indexes, params.chartType);
        this._fireAfterShowTooltip(indexes, {
            element: elTooltip,
            position: position
        });
    },

    /**
     * To call beforeShowTooltip callback of userEvent.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @private
     */
    _fireBeforeShowTooltip: function(indexes) {
        var params = this._makeShowTooltipParams(indexes);

        this.userEvent.fire('beforeShowTooltip', params);
    },

    /**
     * To call afterShowTooltip callback of userEvent.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {object} additionParams addition parameters
     * @private
     */
    _fireAfterShowTooltip: function(indexes, additionParams) {
        var params = this._makeShowTooltipParams(indexes, additionParams);

        this.userEvent.fire('afterShowTooltip', params);
    },

    /**
     * Hide tooltip.
     * @param {HTMLElement} tooltipElement tooltip element
     * @private
     */
    _hideTooltip: function(tooltipElement) {
        var self = this,
            indexes = this._getIndexesCustomAttribute(tooltipElement),
            chartType = tooltipElement.getAttribute('data-chart-type');

        if (predicate.isMousePositionChart(chartType)) {
            dom.removeClass(tooltipElement, 'show');
        } else if (chartType) {
            this._setShowedCustomAttribute(tooltipElement, false);
            this._fireHideAnimation(indexes, chartType);

            if (this._isChangedIndexes(this.prevIndexes, indexes)) {
                delete this.prevIndexes;
            }

            setTimeout(function() {
                if (self._isShowedTooltip(tooltipElement)) {
                    return;
                }

                dom.removeClass(tooltipElement, 'show');
                tooltipElement.style.cssText = '';

                indexes = null;
            }, chartConst.HIDE_DELAY);
        }
    },

    /**
     * On show tooltip container.
     */
    onShowTooltipContainer: function() {
        this.tooltipContainer.style.zIndex = chartConst.TOOLTIP_ZINDEX;
    },

    /**
     * On hide tooltip container.
     */
    onHideTooltipContainer: function() {
        this.tooltipContainer.style.zIndex = 0;
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = singleTooltipMixer;

},{"../const":20,"../helpers/domHandler":45,"../helpers/predicate":47,"../helpers/renderUtil":49}],91:[function(require,module,exports){
/**
 * @fileoverview Tooltip component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var TooltipBase = require('./tooltipBase');
var singleTooltipMixer = require('./singleTooltipMixer');
var chartConst = require('../const');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');
var tooltipTemplate = require('./tooltipTemplate');

/**
 * @classdesc Tooltip component.
 * @class Tooltip
 */
var Tooltip = tui.util.defineClass(TooltipBase, /** @lends Tooltip.prototype */ {
    /**
     * Tooltip component.
     * @constructs Tooltip
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        TooltipBase.call(this, params);
    },

    /**
     * Make tooltip html.
     * @param {string} category category
     * @param {{value: string, legend: string, chartType: string, suffix: ?string}} item item data
     * @returns {string} tooltip html
     * @private
     */
    _makeTooltipHtml: function(category, item) {
        var template;

        if (predicate.isBubbleChart(this.chartType)) {
            template = tooltipTemplate.tplBubbleChart;
        } else {
            template = tooltipTemplate.tplDefault;
        }

        return template(tui.util.extend({
            category: category || ''
        }, item));
    },

    /**
     * Make html for value types like x, y, r
     * @param {{x: ?number, y: ?number, r: ?number}} data - data
     * @param {Array.<string>} valueTypes - types of value
     * @returns {string}
     * @private
     */
    _makeHtmlForValueTypes: function(data, valueTypes) {
        return tui.util.map(valueTypes, function(type) {
            return (data[type]) ? '<div>' + type + ': ' + data[type] + '</div>' : '';
        }).join('');
    },

    /**
     * Make single tooltip html.
     * @param {string} chartType chart type
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @returns {string} tooltip html
     * @private
     */
    _makeSingleTooltipHtml: function(chartType, indexes) {
        var data = tui.util.pick(this.data, chartType, indexes.groupIndex, indexes.index);

        data = tui.util.extend({
            suffix: this.suffix
        }, data);
        data.valueTypes = this._makeHtmlForValueTypes(data, ['x', 'y', 'r']);

        return this.templateFunc(data.category, data);
    },

    /**
     * Set default align option of tooltip.
     * @private
     * @override
     */
    _setDefaultTooltipPositionOption: function() {
        if (this.options.align) {
            return;
        }

        if (this.isVertical) {
            this.options.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        } else {
            this.options.align = chartConst.TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION;
        }
    },

    /**
     * Make parameters for show tooltip user event.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {object} additionParams addition parameters
     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} parameters for show tooltip
     * @private
     */
    _makeShowTooltipParams: function(indexes, additionParams) {
        var legendIndex = indexes.index,
            legendData = this.dataProcessor.getLegendItem(legendIndex),
            params;

        if (!legendData) {
            return null;
        }
        params = tui.util.extend({
            chartType: legendData.chartType,
            legend: legendData.label,
            legendIndex: legendIndex,
            index: indexes.groupIndex
        }, additionParams);
        return params;
    },

    /**
     * Format value of valueMap
     * @param {object} valueMap - map of value like value, x, y, r
     * @returns {{}}
     * @private
     */
    _formatValueMap: function(valueMap) {
        var formattedValueMap = {};
        var formatFunctions = this.dataProcessor.getFormatFunctions();

        tui.util.forEach(valueMap, function(value, valueType) {
            formattedValueMap[valueType] = renderUtil.formatValue(value, formatFunctions, 'tooltip', valueType);
        });

        return formattedValueMap;
    },

    /**
     * Make tooltip datum.
     * @param {Array.<string>} legendLabels - legend labels
     * @param {string} category - category
     * @param {string} chartType - chart type
     * @param {SeriesItem} seriesItem - SeriesItem
     * @param {number} index - index
     * @returns {Object}
     * @private
     */
    _makeTooltipDatum: function(legendLabels, category, chartType, seriesItem, index) {
        var legend = legendLabels[chartType][index];

        var labelPrefix = (legend && seriesItem.label) ? ':&nbsp;' : '';
        var label = seriesItem.label ? labelPrefix + seriesItem.label : '';
        var valueMap = this._formatValueMap(seriesItem.pickValueMap());

        return tui.util.extend({
            category: category,
            legend: legend,
            label: label
        }, valueMap);
    },

    /**
     * Make tooltip data.
     * @returns {Array.<object>} tooltip data
     * @override
     */
    _makeTooltipData: function() {
        var self = this,
            categories = this.dataProcessor.getCategories(),
            orgLegendLabels = this.dataProcessor.getLegendLabels(),
            legendLabels = {},
            tooltipData = {};

        if (tui.util.isArray(orgLegendLabels)) {
            legendLabels[this.chartType] = orgLegendLabels;
        } else {
            legendLabels = orgLegendLabels;
        }

        this.dataProcessor.eachBySeriesGroup(function(seriesGroup, groupIndex, chartType) {
            var category = categories[groupIndex] || '';
            var data;

            chartType = chartType || self.chartType;

            data = seriesGroup.map(function(seriesItem, index) {
                return seriesItem ? self._makeTooltipDatum(legendLabels, category, chartType, seriesItem, index) : null;
            });

            if (!tooltipData[chartType]) {
                tooltipData[chartType] = [];
            }

            tooltipData[chartType].push(data);
        });

        return tooltipData;
    }
});

singleTooltipMixer.mixin(Tooltip);
module.exports = Tooltip;

},{"../const":20,"../helpers/predicate":47,"../helpers/renderUtil":49,"./singleTooltipMixer":90,"./tooltipBase":92,"./tooltipTemplate":93}],92:[function(require,module,exports){
/**
 * @fileoverview TooltipBase is base class of tooltip components.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil');

var TooltipBase = tui.util.defineClass(/** @lends TooltipBase.prototype */ {
    /**
     * TooltipBase is base class of tooltip components.
     * @constructs TooltipBase
     * @param {object} params parameters
     *      @param {Array.<number>} params.values converted values
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        var isPieChart = predicate.isPieChart(params.chartType);

        tui.util.extend(this, params);
        /**
         * className
         * @type {string}
         */
        this.className = 'tui-chart-tooltip-area';

        /**
         * Tooltip container.
         * @type {HTMLElement}
         */
        this.tooltipContainer = null;

        /**
         * Tooltip suffix.
         * @type {string}
         */
        this.suffix = this.options.suffix ? '&nbsp;' + this.options.suffix : '';

        /**
         * Tooltip template function.
         * @type {function}
         */
        this.templateFunc = this.options.template || tui.util.bind(this._makeTooltipHtml, this);

        /**
         * Tooltip animation time.
         * @type {number}
         */
        this.animationTime = isPieChart ? chartConst.TOOLTIP_PIE_ANIMATION_TIME : chartConst.TOOLTIP_ANIMATION_TIME;

        this.chartType = params.chartType;

        /**
         * TooltipBase base data.
         * @type {Array.<Array.<object>>}
         */
        this.data = [];

        this._setDefaultTooltipPositionOption();
        this._saveOriginalPositionOptions();
    },

    /**
     * Make tooltip html.
     * @private
     * @abstract
     */
    _makeTooltipHtml: function() {},

    /**
     * Set default align option of tooltip.
     * @private
     * @abstract
     */
    _setDefaultTooltipPositionOption: function() {},

    /**
     * Save position options.
     * @private
     */
    _saveOriginalPositionOptions: function() {
        this.orgPositionOptions = {
            align: this.options.align,
            position: this.options.position
        };
    },

    /**
     * Make tooltip data.
     * @private
     * @abstract
     */
    _makeTooltipData: function() {},

    /**
     * Render tooltip component.
     * @returns {HTMLElement} tooltip element
     */
    render: function() {
        var el = dom.create('DIV', this.className);

        this.data = this._makeTooltipData();

        renderUtil.renderPosition(el, this.boundsMaker.getPosition('tooltip'));

        this.tooltipContainer = el;

        return el;
    },

    /**
     * Rerender.
     */
    rerender: function() {
        this.data = this._makeTooltipData();
        if (this.positionModel) {
            this.positionModel.updateBound(this.boundsMaker.getBound('tooltip'));
        }
    },

    /**
     * Resize tooltip component.
     * @override
     */
    resize: function() {
        renderUtil.renderPosition(this.tooltipContainer, this.boundsMaker.getPosition('tooltip'));
        if (this.positionModel) {
            this.positionModel.updateBound(this.boundsMaker.getBound('tooltip'));
        }
    },

    /**
     * Get tooltip element.
     * @returns {HTMLElement} tooltip element
     * @private
     */
    _getTooltipElement: function() {
        var tooltipElement;

        if (!this.tooltipElement) {
            this.tooltipElement = tooltipElement = dom.create('DIV', 'tui-chart-tooltip');
            dom.append(this.tooltipContainer, tooltipElement);
        }

        return this.tooltipElement;
    },

    /**
     * onShow is callback of custom event showTooltip for SeriesView.
     * @param {object} params coordinate event parameters
     */
    onShow: function(params) {
        var tooltipElement = this._getTooltipElement(),
            prevPosition;

        if (!predicate.isMousePositionChart(params.chartType) && tooltipElement.offsetWidth) {
            prevPosition = {
                left: tooltipElement.offsetLeft,
                top: tooltipElement.offsetTop
            };
        }

        this._showTooltip(tooltipElement, params, prevPosition);
    },

    /**
     * Get tooltip dimension
     * @param {HTMLElement} tooltipElement tooltip element
     * @returns {{width: number, height: number}} rendered tooltip dimension
     */
    getTooltipDimension: function(tooltipElement) {
        return {
            width: tooltipElement.offsetWidth,
            height: tooltipElement.offsetHeight
        };
    },

    /**
     * Move to Position.
     * @param {HTMLElement} tooltipElement tooltip element
     * @param {{left: number, top: number}} position position
     * @param {{left: number, top: number}} prevPosition prev position
     * @private
     */
    _moveToPosition: function(tooltipElement, position, prevPosition) {
        if (prevPosition) {
            this._slideTooltip(tooltipElement, prevPosition, position);
        } else {
            renderUtil.renderPosition(tooltipElement, position);
        }
    },

    /**
     * Slide tooltip
     * @param {HTMLElement} tooltipElement tooltip element
     * @param {{left: number, top: number}} prevPosition prev position
     * @param {{left: number, top: number}} position position
     * @private
     */
    _slideTooltip: function(tooltipElement, prevPosition, position) {
        var moveTop = position.top - prevPosition.top,
            moveLeft = position.left - prevPosition.left;

        renderUtil.cancelAnimation(this.slidingAnimation);

        this.slidingAnimation = renderUtil.startAnimation(this.animationTime, function(ratio) {
            var left = moveLeft * ratio,
                top = moveTop * ratio;
            tooltipElement.style.left = (prevPosition.left + left) + 'px';
            tooltipElement.style.top = (prevPosition.top + top) + 'px';
        });
    },

    /**
     * onHide is callback of custom event hideTooltip for SeriesView
     * @param {number} index index
     */
    onHide: function(index) {
        var tooltipElement = this._getTooltipElement();

        this._hideTooltip(tooltipElement, index);
    },

    /**
     * Set tooltip align option.
     * @param {string} align align
     */
    setAlign: function(align) {
        this.options.align = align;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Set position option.
     * @param {{left: number, top: number}} position moving position
     */
    setPosition: function(position) {
        this.options.position = tui.util.extend({}, this.options.position, position);
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Reset tooltip align option.
     */
    resetAlign: function() {
        var align = this.orgPositionOptions.align;

        this.options.align = align;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Reset tooltip position.
     */
    resetPosition: function() {
        var position = this.orgPositionOptions.position;

        this.options.position = position;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    }
});

tui.util.CustomEvents.mixin(TooltipBase);

module.exports = TooltipBase;

},{"../const":20,"../helpers/domHandler":45,"../helpers/predicate":47,"../helpers/renderUtil":49}],93:[function(require,module,exports){
/**
 * @fileoverview This is templates of tooltip.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var htmls = {
    HTML_DEFAULT_TEMPLATE: '<div class="tui-chart-default-tooltip">' +
        '<div>{{ category }}</div>' +
        '<div>' +
            '<span>{{ legend }}</span>' +
            '<span>{{ label }}</span>' +
            '<span>{{ suffix }}</span>' +
        '</div>' +
    '</div>',
    HTML_BUBBLE_CHART_TEMPLATE: '<div class="tui-chart-default-tooltip">' +
        '<div>{{ category }}</div>' +
        '<div>' +
            '<span>{{ legend }}</span>' +
            '<span>{{ label }}</span>' +
        '</div>{{ valueTypes }}' +
    '</div>',
    HTML_GROUP: '<div class="tui-chart-default-tooltip tui-chart-group-tooltip">' +
        '<div>{{ category }}</div>' +
        '{{ items }}' +
    '</div>',
    HTML_GROUP_ITEM: '<div>' +
        '<div class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></div>' +
        '&nbsp;<span>{{ legend }}</span>:&nbsp;<span>{{ value }}</span>' +
        '<span>{{ suffix }}</span>' +
    '</div>',
    GROUP_CSS_TEXT: 'background-color:{{ color }}',
    HTML_MAP_CHART_DEFAULT_TEMPLATE: '<div class="tui-chart-default-tooltip">' +
        '<div>{{ name }}: {{ value }}{{ suffix }}</div>' +
    '</div>'
};

module.exports = {
    tplDefault: templateMaker.template(htmls.HTML_DEFAULT_TEMPLATE),
    tplBubbleChart: templateMaker.template(htmls.HTML_BUBBLE_CHART_TEMPLATE),
    tplGroup: templateMaker.template(htmls.HTML_GROUP),
    tplGroupItem: templateMaker.template(htmls.HTML_GROUP_ITEM),
    tplGroupCssText: templateMaker.template(htmls.GROUP_CSS_TEXT),
    tplMapChartDefault: templateMaker.template(htmls.HTML_MAP_CHART_DEFAULT_TEMPLATE)
};

},{"../helpers/templateMaker":50}]},{},[3,60])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvanMvYXhlcy9heGlzLmpzIiwic3JjL2pzL2F4ZXMvYXhpc1RlbXBsYXRlLmpzIiwic3JjL2pzL2NoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9hcmVhQ2hhcnQuanMiLCJzcmMvanMvY2hhcnRzL2F4aXNUeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL2JhckNoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9iYXJUeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL2J1YmJsZUNoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9jaGFydEJhc2UuanMiLCJzcmMvanMvY2hhcnRzL2NvbHVtbkNoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9jb21ib0NoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9jb21wb25lbnRNYW5hZ2VyLmpzIiwic3JjL2pzL2NoYXJ0cy9saW5lQ2hhcnQuanMiLCJzcmMvanMvY2hhcnRzL2xpbmVUeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL21hcENoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9tYXBDaGFydENvbG9yTW9kZWwuanMiLCJzcmMvanMvY2hhcnRzL21hcENoYXJ0TWFwTW9kZWwuanMiLCJzcmMvanMvY2hhcnRzL3BpZUNoYXJ0LmpzIiwic3JjL2pzL2NvZGUtc25pcHBldC11dGlsLmpzIiwic3JjL2pzL2NvbnN0LmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9hcmVhVHlwZUN1c3RvbUV2ZW50LmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9hcmVhVHlwZURhdGFNb2RlbC5qcyIsInNyYy9qcy9jdXN0b21FdmVudHMvYm91bmRzQmFzZUNvb3JkaW5hdGVNb2RlbC5qcyIsInNyYy9qcy9jdXN0b21FdmVudHMvYm91bmRzVHlwZUN1c3RvbUV2ZW50LmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9jdXN0b21FdmVudEJhc2UuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL2dyb3VwVHlwZUN1c3RvbUV2ZW50LmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9tYXBDaGFydEN1c3RvbUV2ZW50LmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9zaW1wbGVDdXN0b21FdmVudC5qcyIsInNyYy9qcy9jdXN0b21FdmVudHMvdGlja0Jhc2VDb29yZGluYXRlTW9kZWwuanMiLCJzcmMvanMvZGF0YU1vZGVscy9kYXRhUHJvY2Vzc29yLmpzIiwic3JjL2pzL2RhdGFNb2RlbHMvbWFwQ2hhcnREYXRhUHJvY2Vzc29yLmpzIiwic3JjL2pzL2RhdGFNb2RlbHMvc2VyaWVzRGF0YU1vZGVsLmpzIiwic3JjL2pzL2RhdGFNb2RlbHMvc2VyaWVzR3JvdXAuanMiLCJzcmMvanMvZGF0YU1vZGVscy9zZXJpZXNJdGVtLmpzIiwic3JjL2pzL2RhdGFNb2RlbHMvc2VyaWVzSXRlbUZvckNvb3JkaW5hdGVUeXBlLmpzIiwic3JjL2pzL2ZhY3Rvcmllcy9jaGFydEZhY3RvcnkuanMiLCJzcmMvanMvZmFjdG9yaWVzL21hcEZhY3RvcnkuanMiLCJzcmMvanMvZmFjdG9yaWVzL3BsdWdpbkZhY3RvcnkuanMiLCJzcmMvanMvZmFjdG9yaWVzL3RoZW1lRmFjdG9yeS5qcyIsInNyYy9qcy9oZWxwZXJzL2F4aXNEYXRhTWFrZXIuanMiLCJzcmMvanMvaGVscGVycy9heGlzU2NhbGVNYWtlci5qcyIsInNyYy9qcy9oZWxwZXJzL2JvdW5kc01ha2VyLmpzIiwic3JjL2pzL2hlbHBlcnMvY2FsY3VsYXRvci5qcyIsInNyYy9qcy9oZWxwZXJzL2NvbG9ydXRpbC5qcyIsInNyYy9qcy9oZWxwZXJzL2RvbUhhbmRsZXIuanMiLCJzcmMvanMvaGVscGVycy9ldmVudExpc3RlbmVyLmpzIiwic3JjL2pzL2hlbHBlcnMvcHJlZGljYXRlLmpzIiwic3JjL2pzL2hlbHBlcnMvcmF3RGF0YUhhbmRsZXIuanMiLCJzcmMvanMvaGVscGVycy9yZW5kZXJVdGlsLmpzIiwic3JjL2pzL2hlbHBlcnMvdGVtcGxhdGVNYWtlci5qcyIsInNyYy9qcy9oZWxwZXJzL3VzZXJFdmVudExpc3RlbmVyLmpzIiwic3JjL2pzL2xlZ2VuZHMvY2lyY2xlTGVnZW5kLmpzIiwic3JjL2pzL2xlZ2VuZHMvbGVnZW5kLmpzIiwic3JjL2pzL2xlZ2VuZHMvbGVnZW5kRGltZW5zaW9uTW9kZWwuanMiLCJzcmMvanMvbGVnZW5kcy9sZWdlbmRNb2RlbC5qcyIsInNyYy9qcy9sZWdlbmRzL2xlZ2VuZFRlbXBsYXRlLmpzIiwic3JjL2pzL2xlZ2VuZHMvbWFwQ2hhcnRMZWdlbmQuanMiLCJzcmMvanMvcGxvdHMvcGxvdC5qcyIsInNyYy9qcy9wbG90cy9wbG90VGVtcGxhdGUuanMiLCJzcmMvanMvcGx1Z2lucy9wbHVnaW5SYXBoYWVsLmpzIiwic3JjL2pzL3BsdWdpbnMvcmFwaGFlbEFyZWFDaGFydC5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxCYXJDaGFydC5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxCdWJibGVDaGFydC5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxDaXJjbGVMZWdlbmQuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsTGluZUNoYXJ0LmpzIiwic3JjL2pzL3BsdWdpbnMvcmFwaGFlbExpbmVUeXBlQmFzZS5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxNYXBDaGFydC5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxNYXBMZWdlbmQuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsUGllQ2hhcnQuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsUmVuZGVyVXRpbC5qcyIsInNyYy9qcy9wb2x5ZmlsbC5qcyIsInNyYy9qcy9yZWdpc3RlckNoYXJ0cy5qcyIsInNyYy9qcy9yZWdpc3RlclRoZW1lcy5qcyIsInNyYy9qcy9zZXJpZXMvYXJlYUNoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9iYXJDaGFydFNlcmllcy5qcyIsInNyYy9qcy9zZXJpZXMvYmFyVHlwZVNlcmllc0Jhc2UuanMiLCJzcmMvanMvc2VyaWVzL2J1YmJsZUNoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9jb2x1bW5DaGFydFNlcmllcy5qcyIsInNyYy9qcy9zZXJpZXMvbGluZUNoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9saW5lVHlwZVNlcmllc0Jhc2UuanMiLCJzcmMvanMvc2VyaWVzL21hcENoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9waWVDaGFydFNlcmllcy5qcyIsInNyYy9qcy9zZXJpZXMvc2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9zZXJpZXNUZW1wbGF0ZS5qcyIsInNyYy9qcy9zZXJpZXMvem9vbS5qcyIsInNyYy9qcy90aGVtZXMvZGVmYXVsdFRoZW1lLmpzIiwic3JjL2pzL3Rvb2x0aXBzL2dyb3VwVG9vbHRpcC5qcyIsInNyYy9qcy90b29sdGlwcy9ncm91cFRvb2x0aXBQb3NpdGlvbk1vZGVsLmpzIiwic3JjL2pzL3Rvb2x0aXBzL21hcENoYXJ0VG9vbHRpcC5qcyIsInNyYy9qcy90b29sdGlwcy9zaW5nbGVUb29sdGlwTWl4ZXIuanMiLCJzcmMvanMvdG9vbHRpcHMvdG9vbHRpcC5qcyIsInNyYy9qcy90b29sdGlwcy90b29sdGlwQmFzZS5qcyIsInNyYy9qcy90b29sdGlwcy90b29sdGlwVGVtcGxhdGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ251QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgQXhpcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxjdWxhdG9yJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIGF4aXNUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vYXhpc1RlbXBsYXRlJyk7XG5cbnZhciBBeGlzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBBeGlzLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQXhpcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgQXhpc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7XG4gICAgICogICAgICAgICAgbGFiZWxzOiBBcnJheS48c3RyaW5nPixcbiAgICAgKiAgICAgICAgICB0aWNrQ291bnQ6IG51bWJlcixcbiAgICAgKiAgICAgICAgICBpc0xhYmVsQXhpczogYm9vbGVhbixcbiAgICAgKiAgICAgICAgICBpc1ZlcnRpY2FsOiBib29sZWFuXG4gICAgICogICAgICB9fSBwYXJhbXMuZGF0YSBheGlzIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYm91bmQgYXhpcyBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBheGlzIHRoZW1lXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgYXhpcyBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBeGlzIHZpZXcgY2xhc3NOYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktY2hhcnQtYXhpcy1hcmVhJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhcnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIHByb2Nlc3NvclxuICAgICAgICAgKiBAdHlwZSB7RGF0YVByb2Nlc3Nvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IHBhcmFtcy5kYXRhUHJvY2Vzc29yO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZHMgbWFrZXJcbiAgICAgICAgICogQHR5cGUge0JvdW5kc01ha2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlciA9IHBhcmFtcy5ib3VuZHNNYWtlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uc1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gcGFyYW1zLm9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZW1lXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRoZW1lID0gcGFyYW1zLnRoZW1lIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIGxhYmVsIHR5cGUgb3Igbm90LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNMYWJlbCA9IHBhcmFtcy5pc0xhYmVsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIGZvciByZW5kZXJpbmdcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGhlaWdodCBvZiB4IGF4aXMgYXJlYS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlWEF4aXNIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgICAgIHZhciB0aXRsZUhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodCh0aXRsZSwgdGhpcy50aGVtZS50aXRsZSk7XG4gICAgICAgIHZhciB0aXRsZUFyZWFIZWlnaHQgPSB0aXRsZUhlaWdodCA/ICh0aXRsZUhlaWdodCArIGNoYXJ0Q29uc3QuVElUTEVfUEFERElORykgOiAwO1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQoY2hhcnRDb25zdC5NQVhfSEVJR0hUX1dPUkxELCB0aGlzLnRoZW1lLmxhYmVsKTtcblxuICAgICAgICByZXR1cm4gdGl0bGVBcmVhSGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyBjaGFydENvbnN0LkNIQVJUX1BBRERJTkc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugd2lkdGggb2YgeSBheGlzIGFyZWEuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nIHwgbnVtYmVyPn0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVlBeGlzV2lkdGg6IGZ1bmN0aW9uKGxhYmVscykge1xuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGUgfHwgJycsXG4gICAgICAgICAgICB0aXRsZUFyZWFXaWR0aCA9IDAsXG4gICAgICAgICAgICB3aWR0aCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc0NlbnRlcikge1xuICAgICAgICAgICAgd2lkdGggKz0gY2hhcnRDb25zdC5BWElTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aXRsZUFyZWFXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodCh0aXRsZSwgdGhpcy50aGVtZS50aXRsZSkgKyBjaGFydENvbnN0LlRJVExFX1BBRERJTkc7XG4gICAgICAgIH1cblxuICAgICAgICB3aWR0aCArPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxzTWF4V2lkdGgobGFiZWxzLCB0aGlzLnRoZW1lLmxhYmVsKSArIHRpdGxlQXJlYVdpZHRoICtcbiAgICAgICAgICAgIGNoYXJ0Q29uc3QuQVhJU19MQUJFTF9QQURESU5HO1xuXG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB2YWxpZCBheGlzIG9yIG5vdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB2YWxpZCBheGlzIG9yIG5vdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1ZhbGlkQXhpczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnROYW1lID09PSAncmlnaHRZQXhpcycpIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSB0aGlzLmRhdGFQcm9jZXNzb3IuaXNWYWxpZEFsbFNlcmllc0RhdGFNb2RlbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGxlZ2VuZCBkaW1lbnNpb24gdG8gYm91bmRzTWFrZXIuXG4gICAgICovXG4gICAgcmVnaXN0ZXJEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0ge307XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkQXhpcygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnRUeXBlID09PSAneEF4aXMnKSB7XG4gICAgICAgICAgICBkaW1lbnNpb24uaGVpZ2h0ID0gdGhpcy5fbWFrZVhBeGlzSGVpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kc01ha2VyLnJlZ2lzdGVyQmFzZURpbWVuc2lvbih0aGlzLmNvbXBvbmVudE5hbWUsIGRpbWVuc2lvbik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0xhYmVsKSB7XG4gICAgICAgICAgICBkaW1lbnNpb24ud2lkdGggPSB0aGlzLl9tYWtlWUF4aXNXaWR0aCh0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Q2F0ZWdvcmllcygpKTtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCYXNlRGltZW5zaW9uKHRoaXMuY29tcG9uZW50TmFtZSwgZGltZW5zaW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBsZWdlbmQgYWRkaXRpb25hbCBkaW1lbnNpb24gdG8gYm91bmRzTWFrZXIuXG4gICAgICovXG4gICAgcmVnaXN0ZXJBZGRpdGlvbmFsRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbixcbiAgICAgICAgICAgIGF4ZXNEYXRhID0gdGhpcy5ib3VuZHNNYWtlci5heGVzRGF0YTtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRBeGlzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodGhpcy5jb21wb25lbnRUeXBlID09PSAneUF4aXMnKSAmJiAhdGhpcy5pc0xhYmVsKSB7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuX21ha2VZQXhpc1dpZHRoKGF4ZXNEYXRhLnlBeGlzLmxhYmVscylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmJvdW5kc01ha2VyLnJlZ2lzdGVyQmFzZURpbWVuc2lvbih0aGlzLmNvbXBvbmVudE5hbWUsIGRpbWVuc2lvbik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG9wcG9zaXRlIHNpZGUgdGljayBhcmVhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aWNrSHRtbCB0aWNrIGh0bWxcbiAgICAgKiBAcmV0dXJucyB7P0hUTUxFbGVtZW50fSByaWdodCB0aWNrIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlck9wcG9zaXRlU2lkZVRpY2tBcmVhOiBmdW5jdGlvbih0aWNrSHRtbCkge1xuICAgICAgICB2YXIgdGlja0NvbnRhaW5lcjtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzQ2VudGVyKSB7XG4gICAgICAgICAgICB0aWNrQ29udGFpbmVyID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC10aWNrLWFyZWEgb3Bwb3NpdGUtc2lkZScpO1xuICAgICAgICAgICAgdGlja0NvbnRhaW5lci5pbm5lckhUTUwgPSB0aWNrSHRtbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aWNrQ29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY3NzIGNsYXNzZXMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYXhpc0NvbnRhaW5lciBheGlzIGNvbnRhaW5lclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENzc0NsYXNzZXM6IGZ1bmN0aW9uKGF4aXNDb250YWluZXIpIHtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF4aXNDb250YWluZXIsIHRoaXMuZGF0YS5pc1ZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhheGlzQ29udGFpbmVyLCB0aGlzLm9wdGlvbnMuaXNDZW50ZXIgPyAnY2VudGVyJyA6ICcnKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF4aXNDb250YWluZXIsIHRoaXMub3B0aW9ucy5kaXZpZGVkID8gJ2RpdmlzaW9uJyA6ICcnKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF4aXNDb250YWluZXIsIHRoaXMuZGF0YS5pc1Bvc2l0aW9uUmlnaHQgPyAncmlnaHQnIDogJycpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjaGlsZCBjb250YWluZXJzIGxpa2UgdGl0bGUgYXJlYSwgbGFibGUgYXJlYSBhbmQgdGljayBhcmVhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHhBeGlzIHdpZHRoIG9yIHlBeGlzIGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBheGlzIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyfHN0cmluZz59IGNhdGVnb3JpZXMgY2F0ZWdvcmllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRpdGlvbmFsV2lkdGggYWRpdGlvbmFsIHdpZHRoXG4gICAgICogQHJldHVybnMge0FycmF5LjxIVE1MRWxlbWVudD59IGNoaWxkIGNvbnRhaW5lcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJDaGlsZENvbnRhaW5lcnM6IGZ1bmN0aW9uKHNpemUsIHdpZHRoLCB0aWNrQ291bnQsIGNhdGVnb3JpZXMsIGFkZGl0aW9uYWxXaWR0aCkge1xuICAgICAgICB2YXIgdGl0bGVDb250YWluZXIgPSB0aGlzLl9yZW5kZXJUaXRsZUFyZWEoc2l6ZSksXG4gICAgICAgICAgICBsYWJlbENvbnRhaW5lciA9IHRoaXMuX3JlbmRlckxhYmVsQXJlYShzaXplLCB3aWR0aCwgdGlja0NvdW50LCBjYXRlZ29yaWVzLCBhZGRpdGlvbmFsV2lkdGgpLFxuICAgICAgICAgICAgY2hpbGRDb250YWluZXJzID0gW3RpdGxlQ29udGFpbmVyLCBsYWJlbENvbnRhaW5lcl0sXG4gICAgICAgICAgICBpc0xpbmVUeXBlID0gdGhpcy5kYXRhLmlzVmVydGljYWwgJiYgdGhpcy5kYXRhLmFsaWduZWQsXG4gICAgICAgICAgICB0aWNrQ29udGFpbmVyLCBvcHBvc2l0ZVNpZGVUaWNrQ29udGFpbmVyO1xuXG4gICAgICAgIGlmICghaXNMaW5lVHlwZSkge1xuICAgICAgICAgICAgdGlja0NvbnRhaW5lciA9IHRoaXMuX3JlbmRlclRpY2tBcmVhKHNpemUsIHRpY2tDb3VudCwgY2F0ZWdvcmllcywgYWRkaXRpb25hbFdpZHRoKTtcbiAgICAgICAgICAgIG9wcG9zaXRlU2lkZVRpY2tDb250YWluZXIgPSB0aGlzLl9yZW5kZXJPcHBvc2l0ZVNpZGVUaWNrQXJlYSh0aWNrQ29udGFpbmVyLmlubmVySFRNTCk7XG4gICAgICAgICAgICBjaGlsZENvbnRhaW5lcnMgPSBjaGlsZENvbnRhaW5lcnMuY29uY2F0KFt0aWNrQ29udGFpbmVyLCBvcHBvc2l0ZVNpZGVUaWNrQ29udGFpbmVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGRDb250YWluZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgUmVuZGVyIGRpdmlzaW9uIHhBeGlzIGFyZWEgaWYgeUF4aXMgcmVuZGVyZWQgaW4gdGhlIGNlbnRlci5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBheGlzQ29udGFpbmVyIGF4aXMgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggYXhpcyBhcmVhIHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyRGl2aXNpb25BeGlzQXJlYTogZnVuY3Rpb24oYXhpc0NvbnRhaW5lciwgd2lkdGgpIHtcbiAgICAgICAgdmFyIGxlZnRXaWR0aCA9IE1hdGgucm91bmQod2lkdGggLyAyKSxcbiAgICAgICAgICAgIHJpZ2h0V2lkdGggPSB3aWR0aCAtIGxlZnRXaWR0aCxcbiAgICAgICAgICAgIHRpY2tDb3VudCA9IHRoaXMuZGF0YS50aWNrQ291bnQsXG4gICAgICAgICAgICBoYWxmVGlja0NvdW50ID0gcGFyc2VJbnQodGlja0NvdW50IC8gMiwgMTApICsgMSxcbiAgICAgICAgICAgIGNhdGVnb3JpZXMgPSB0aGlzLmRhdGEubGFiZWxzLFxuICAgICAgICAgICAgbGVmdENhdGVzID0gY2F0ZWdvcmllcy5zbGljZSgwLCBoYWxmVGlja0NvdW50KSxcbiAgICAgICAgICAgIHJpZ2h0Q2F0ZXMgPSBjYXRlZ29yaWVzLnNsaWNlKGhhbGZUaWNrQ291bnQgLSAxLCB0aWNrQ291bnQpLFxuICAgICAgICAgICAgYWRkaXRpb25XaWR0aCA9IGxlZnRXaWR0aCArIHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCd5QXhpcycpLndpZHRoLFxuICAgICAgICAgICAgbGVmdENvbnRhaW5lcnMsIHJpZ2h0Q29udGFpbmVycywgcmlnaHRUaXRsZUNvbnRhaW5lcjtcblxuICAgICAgICBsZWZ0Q29udGFpbmVycyA9IHRoaXMuX3JlbmRlckNoaWxkQ29udGFpbmVycyhsZWZ0V2lkdGgsIGxlZnRXaWR0aCwgaGFsZlRpY2tDb3VudCwgbGVmdENhdGVzKTtcbiAgICAgICAgcmlnaHRDb250YWluZXJzID0gdGhpcy5fcmVuZGVyQ2hpbGRDb250YWluZXJzKHJpZ2h0V2lkdGgsIHJpZ2h0V2lkdGgsIGhhbGZUaWNrQ291bnQsIHJpZ2h0Q2F0ZXMsIGFkZGl0aW9uV2lkdGgpO1xuXG4gICAgICAgIHJpZ2h0VGl0bGVDb250YWluZXIgPSByaWdodENvbnRhaW5lcnNbMF07XG4gICAgICAgIGRvbS5hZGRDbGFzcyhyaWdodFRpdGxlQ29udGFpbmVyLCAncmlnaHQnKTtcbiAgICAgICAgZG9tLmFwcGVuZChheGlzQ29udGFpbmVyLCBsZWZ0Q29udGFpbmVycy5jb25jYXQocmlnaHRDb250YWluZXJzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzaW5nbGUgYXhpcyBhcmVhIGlmIHlBeGlzIGRpZCBub3QgcmVuZGVyZWQgaW4gdGhlIGNlbnRlci5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBheGlzQ29udGFpbmVyIGF4aXMgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBheGlzIGFyZWEgZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU2luZ2xlQXhpc0FyZWE6IGZ1bmN0aW9uKGF4aXNDb250YWluZXIsIGRpbWVuc2lvbikge1xuICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9ICEhdGhpcy5kYXRhLmlzVmVydGljYWwsXG4gICAgICAgICAgICBzaXplID0gaXNWZXJ0aWNhbCA/IGRpbWVuc2lvbi5oZWlnaHQgOiBkaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBjaGlsZENvbnRhaW5lcnMgPSB0aGlzLl9yZW5kZXJDaGlsZENvbnRhaW5lcnMoc2l6ZSwgZGltZW5zaW9uLndpZHRoLCB0aGlzLmRhdGEudGlja0NvdW50LCB0aGlzLmRhdGEubGFiZWxzKTtcblxuICAgICAgICBkb20uYXBwZW5kKGF4aXNDb250YWluZXIsIGNoaWxkQ29udGFpbmVycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBheGlzIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYXhpc0NvbnRhaW5lciBheGlzIGFyZWEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2lzVmVydGljYWw6IGJvb2xlYW4sIGlzUG9zaXRpb25SaWdodDogYm9vbGVhbiwgYWxpZ25lZDogYWxpZ25lZH19IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJBeGlzQXJlYTogZnVuY3Rpb24oYXhpc0NvbnRhaW5lcikge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdHVpLnV0aWwuZXh0ZW5kKHt9LCB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbih0aGlzLmNvbXBvbmVudE5hbWUpKTtcblxuICAgICAgICB0aGlzLl9hZGRDc3NDbGFzc2VzKGF4aXNDb250YWluZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGl2aWRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyRGl2aXNpb25BeGlzQXJlYShheGlzQ29udGFpbmVyLCBkaW1lbnNpb24ud2lkdGgpO1xuICAgICAgICAgICAgZGltZW5zaW9uLndpZHRoICs9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCd5QXhpcycpLndpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyU2luZ2xlQXhpc0FyZWEoYXhpc0NvbnRhaW5lciwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIGRpbWVuc2lvbi53aWR0aCArPSB0aGlzLm9wdGlvbnMuaXNDZW50ZXIgPyAyIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKGF4aXNDb250YWluZXIsIGRpbWVuc2lvbik7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24oYXhpc0NvbnRhaW5lciwgdGhpcy5ib3VuZHNNYWtlci5nZXRQb3NpdGlvbih0aGlzLmNvbXBvbmVudE5hbWUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGF4aXMgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7e2lzVmVydGljYWw6IGJvb2xlYW4sIGlzUG9zaXRpb25SaWdodDogYm9vbGVhbiwgYWxpZ25lZDogYWxpZ25lZH19IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGF4aXMgYXJlYSBiYXNlIGVsZW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpO1xuXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuX3JlbmRlckF4aXNBcmVhKGVsKTtcbiAgICAgICAgdGhpcy5heGlzQ29udGFpbmVyID0gZWw7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVyZW5kZXIgYXhpcyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKi9cbiAgICByZXJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLmF4aXNDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRBeGlzKCkpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBkYXRhLm9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQXhpc0FyZWEodGhpcy5heGlzQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgYXhpcyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmQgYXhpcyBib3VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihib3VuZCwgZGF0YSkge1xuICAgICAgICB0aGlzLnJlcmVuZGVyKGJvdW5kLCBkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGNzcyBzdHlsZSBvZiB0aXRsZSBhcmVhXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGl0bGVDb250YWluZXIgdGl0bGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHdpZHRoIG9yIGhlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclRpdGxlQXJlYVN0eWxlOiBmdW5jdGlvbih0aXRsZUNvbnRhaW5lciwgc2l6ZSkge1xuICAgICAgICB2YXIgaXNQb3NpdGlvblJpZ2h0ID0gdGhpcy5kYXRhLmlzUG9zaXRpb25SaWdodCxcbiAgICAgICAgICAgIGNzc1RleHRzID0gW1xuICAgICAgICAgICAgICAgIHJlbmRlclV0aWwuY29uY2F0U3RyKCd3aWR0aDonLCBzaXplLCAncHgnKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHRpdGxlV2lkdGgsIHlBeGlzV2lkdGgsIHhBeGlzSGVpZ2h0O1xuXG4gICAgICAgIGlmIChpc1Bvc2l0aW9uUmlnaHQpIHtcbiAgICAgICAgICAgIGlmIChyZW5kZXJVdGlsLmlzSUU3KCkpIHtcbiAgICAgICAgICAgICAgICBjc3NUZXh0cy5wdXNoKHJlbmRlclV0aWwuY29uY2F0U3RyKCdyaWdodDonLCAnMHB4JykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjc3NUZXh0cy5wdXNoKHJlbmRlclV0aWwuY29uY2F0U3RyKCdyaWdodDonLCAtc2l6ZSwgJ3B4JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3NzVGV4dHMucHVzaCgndG9wOjBweCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5pc0NlbnRlcikge1xuICAgICAgICAgICAgdGl0bGVXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKHRoaXMub3B0aW9ucy50aXRsZSwgdGhpcy50aGVtZS50aXRsZSk7XG4gICAgICAgICAgICB5QXhpc1dpZHRoID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3lBeGlzJykud2lkdGg7XG4gICAgICAgICAgICB4QXhpc0hlaWdodCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCd4QXhpcycpLmhlaWdodDtcblxuICAgICAgICAgICAgY3NzVGV4dHMgPSBbXG4gICAgICAgICAgICAgICAgJ2xlZnQ6JyArICgoeUF4aXNXaWR0aCAtIHRpdGxlV2lkdGgpIC8gMikgKyAncHgnLFxuICAgICAgICAgICAgICAgICdib3R0b206IC0nICsgeEF4aXNIZWlnaHQgKyAncHgnXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzVGV4dHMucHVzaCgnbGVmdDowcHgnKTtcbiAgICAgICAgICAgIGlmICghcmVuZGVyVXRpbC5pc09sZEJyb3dzZXIoKSkge1xuICAgICAgICAgICAgICAgIGNzc1RleHRzLnB1c2gocmVuZGVyVXRpbC5jb25jYXRTdHIoJ3RvcDonLCBzaXplLCAncHgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aXRsZUNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ICs9ICc7JyArIGNzc1RleHRzLmpvaW4oJzsnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGl0bGUgYXJlYSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdGl0bGUgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclRpdGxlQXJlYTogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICB2YXIgdGl0bGVDb250YWluZXIgPSByZW5kZXJVdGlsLnJlbmRlclRpdGxlKHRoaXMub3B0aW9ucy50aXRsZSwgdGhpcy50aGVtZS50aXRsZSwgJ3R1aS1jaGFydC10aXRsZS1hcmVhJyk7XG5cbiAgICAgICAgaWYgKHRpdGxlQ29udGFpbmVyICYmIHRoaXMuZGF0YS5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUaXRsZUFyZWFTdHlsZSh0aXRsZUNvbnRhaW5lciwgc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGl0bGVDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aWNrIGFyZWEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgc2l6ZSBvciBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlja0NvdW50IHRpY2sgY291bnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjYXRlZ29yaWVzIGNhdGVnb3JpZXNcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGFkZGl0aW9uYWxTaXplIGFkZGl0aW9uYWwgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdGljayBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJUaWNrQXJlYTogZnVuY3Rpb24oc2l6ZSwgdGlja0NvdW50LCBjYXRlZ29yaWVzLCBhZGRpdGlvbmFsU2l6ZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGlzU2luZ2xlWEF4aXMgPSAhZGF0YS5pc1ZlcnRpY2FsICYmICF0aGlzLm9wdGlvbnMuZGl2aWRlZCxcbiAgICAgICAgICAgIHRpY2tDb2xvciA9IHRoaXMudGhlbWUudGlja0NvbG9yLFxuICAgICAgICAgICAgcG9zaXRpb25zID0gY2FsY3VsYXRvci5tYWtlVGlja1BpeGVsUG9zaXRpb25zKHNpemUsIHRpY2tDb3VudCksXG4gICAgICAgICAgICBlbFRpY2tBcmVhID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC10aWNrLWFyZWEnKSxcbiAgICAgICAgICAgIHRlbXBsYXRlID0gYXhpc1RlbXBsYXRlLnRwbEF4aXNUaWNrLFxuICAgICAgICAgICAgdGlja0xpbmVFeHRlbmQgPSBpc1NpbmdsZVhBeGlzID8gMSA6IDAsXG4gICAgICAgICAgICBwb3NUeXBlLCBsaW5lU2l6ZVR5cGUsIGxpbmVIdG1sLCB0aWNrc0h0bWw7XG5cbiAgICAgICAgYWRkaXRpb25hbFNpemUgPSBhZGRpdGlvbmFsU2l6ZSB8fCAwO1xuXG4gICAgICAgIGlmIChkYXRhLmlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHBvc1R5cGUgPSAnYm90dG9tJztcbiAgICAgICAgICAgIGxpbmVTaXplVHlwZSA9ICdoZWlnaHQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zVHlwZSA9ICdsZWZ0JztcbiAgICAgICAgICAgIGxpbmVTaXplVHlwZSA9ICd3aWR0aCc7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lSHRtbCA9IGF4aXNUZW1wbGF0ZS50cGxUaWNrTGluZSh7XG4gICAgICAgICAgICBwb3NpdGlvblR5cGU6IHBvc1R5cGUsXG4gICAgICAgICAgICBwb3NpdGlvblZhbHVlOiBhZGRpdGlvbmFsU2l6ZSAtIHRpY2tMaW5lRXh0ZW5kLFxuICAgICAgICAgICAgc2l6ZVR5cGU6IGxpbmVTaXplVHlwZSxcbiAgICAgICAgICAgIHNpemU6IHNpemUgKyB0aWNrTGluZUV4dGVuZFxuICAgICAgICB9KTtcblxuICAgICAgICB0aWNrc0h0bWwgPSB0dWkudXRpbC5tYXAocG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB0aWNrSHRtbCwgY3NzVGV4dHM7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmFsaWduZWQgJiYgKGNhdGVnb3JpZXNbaW5kZXhdID09PSBjaGFydENvbnN0LkVNUFRZX0FYSVNfTEFCRUwpKSB7XG4gICAgICAgICAgICAgICAgdGlja0h0bWwgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gKGluZGV4ID09PSAwICYmIGlzU2luZ2xlWEF4aXMpID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgY3NzVGV4dHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclV0aWwuY29uY2F0U3RyKCdiYWNrZ3JvdW5kLWNvbG9yOicsIHRpY2tDb2xvciksXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclV0aWwuY29uY2F0U3RyKHBvc1R5cGUsICc6ICcsIGFkZGl0aW9uYWxTaXplICsgcG9zaXRpb24sICdweCcpXG4gICAgICAgICAgICAgICAgXS5qb2luKCc7Jyk7XG4gICAgICAgICAgICAgICAgdGlja0h0bWwgPSB0ZW1wbGF0ZSh7Y3NzVGV4dDogY3NzVGV4dHN9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRpY2tIdG1sO1xuICAgICAgICB9KS5qb2luKCcnKTtcblxuICAgICAgICBlbFRpY2tBcmVhLmlubmVySFRNTCA9IGxpbmVIdG1sICsgdGlja3NIdG1sO1xuXG4gICAgICAgIHJldHVybiBlbFRpY2tBcmVhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNzc1RleHQgb2YgdmVydGljYWwgbGFiZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNXaWR0aCBheGlzIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpdGxlQXJlYVdpZHRoIHRpdGxlIGFyZWEgd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjc3NUZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsTGFiZWxDc3NUZXh0OiBmdW5jdGlvbihheGlzV2lkdGgsIHRpdGxlQXJlYVdpZHRoKSB7XG4gICAgICAgIHJldHVybiAnO3dpZHRoOicgKyAoYXhpc1dpZHRoIC0gdGl0bGVBcmVhV2lkdGggKyBjaGFydENvbnN0LlZfTEFCRUxfUklHSFRfUEFERElORykgKyAncHgnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBjc3Mgc3R5bGUgb2YgbGFiZWwgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBsYWJlbENvbnRhaW5lciBsYWJlbCBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc1dpZHRoIGF4aXMgd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hcHBseUxhYmVsQXJlYVN0eWxlOiBmdW5jdGlvbihsYWJlbENvbnRhaW5lciwgYXhpc1dpZHRoKSB7XG4gICAgICAgIHZhciBjc3NUZXh0ID0gcmVuZGVyVXRpbC5tYWtlRm9udENzc1RleHQodGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICB0aXRsZUFyZWFXaWR0aDtcblxuICAgICAgICBpZiAodGhpcy5kYXRhLmlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHRpdGxlQXJlYVdpZHRoID0gdGhpcy5fZ2V0UmVuZGVyZWRUaXRsZUhlaWdodCgpICsgY2hhcnRDb25zdC5USVRMRV9BUkVBX1dJRFRIX1BBRERJTkc7XG4gICAgICAgICAgICBjc3NUZXh0ICs9IHRoaXMuX21ha2VWZXJ0aWNhbExhYmVsQ3NzVGV4dChheGlzV2lkdGgsIHRpdGxlQXJlYVdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhYmVsQ29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBjc3NUZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbGFiZWwgYXJlYS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBsYWJlbCBhcmVhIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc1dpZHRoIGF4aXMgYXJlYSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNhdGVnb3JpZXMgY2F0ZWdvcmllc1xuICAgICAqIEBwYXJhbSB7P251bWJlcn0gYWRkaXRpb25hbFNpemUgYWRkaXRpb25hbCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJMYWJlbEFyZWE6IGZ1bmN0aW9uKHNpemUsIGF4aXNXaWR0aCwgdGlja0NvdW50LCBjYXRlZ29yaWVzLCBhZGRpdGlvbmFsU2l6ZSkge1xuICAgICAgICB2YXIgbGFiZWxDb250YWluZXIgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LWxhYmVsLWFyZWEnKSxcbiAgICAgICAgICAgIHRpY2tQaXhlbFBvc2l0aW9ucyA9IGNhbGN1bGF0b3IubWFrZVRpY2tQaXhlbFBvc2l0aW9ucyhzaXplLCB0aWNrQ291bnQpLFxuICAgICAgICAgICAgbGFiZWxTaXplID0gdGlja1BpeGVsUG9zaXRpb25zWzFdIC0gdGlja1BpeGVsUG9zaXRpb25zWzBdLFxuICAgICAgICAgICAgbGFiZWxzSHRtbDtcblxuICAgICAgICBhZGRpdGlvbmFsU2l6ZSA9IGFkZGl0aW9uYWxTaXplIHx8IDA7XG4gICAgICAgIGxhYmVsc0h0bWwgPSB0aGlzLl9tYWtlTGFiZWxzSHRtbCh0aWNrUGl4ZWxQb3NpdGlvbnMsIGNhdGVnb3JpZXMsIGxhYmVsU2l6ZSwgYWRkaXRpb25hbFNpemUpO1xuICAgICAgICBsYWJlbENvbnRhaW5lci5pbm5lckhUTUwgPSBsYWJlbHNIdG1sO1xuXG4gICAgICAgIHRoaXMuX2FwcGx5TGFiZWxBcmVhU3R5bGUobGFiZWxDb250YWluZXIsIGF4aXNXaWR0aCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZUxhYmVsQXJlYVBvc2l0aW9uKGxhYmVsQ29udGFpbmVyLCBsYWJlbFNpemUpO1xuXG4gICAgICAgIHJldHVybiBsYWJlbENvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGhlaWdodCBvZiB0aXRsZSBhcmVhIDtcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRSZW5kZXJlZFRpdGxlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlLFxuICAgICAgICAgICAgdGhlbWUgPSB0aGlzLnRoZW1lLnRpdGxlLFxuICAgICAgICAgICAgcmVzdWx0ID0gdGl0bGUgPyByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQodGl0bGUsIHRoZW1lKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjc3NUZXh0IG9mIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbFNpemUgbGFiZWwgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gY3NzVGV4dHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxDc3NUZXh0OiBmdW5jdGlvbihsYWJlbFNpemUpIHtcbiAgICAgICAgdmFyIGlzVmVydGljYWwgPSB0aGlzLmRhdGEuaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgIGNzc1RleHRzID0gW107XG5cbiAgICAgICAgaWYgKGlzVmVydGljYWwgJiYgdGhpcy5kYXRhLmlzTGFiZWxBeGlzKSB7XG4gICAgICAgICAgICBjc3NUZXh0cy5wdXNoKHJlbmRlclV0aWwuY29uY2F0U3RyKCdoZWlnaHQ6JywgbGFiZWxTaXplLCAncHgnKSk7XG4gICAgICAgICAgICBjc3NUZXh0cy5wdXNoKHJlbmRlclV0aWwuY29uY2F0U3RyKCdsaW5lLWhlaWdodDonLCBsYWJlbFNpemUsICdweCcpKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgY3NzVGV4dHMucHVzaChyZW5kZXJVdGlsLmNvbmNhdFN0cignd2lkdGg6JywgbGFiZWxTaXplLCAncHgnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3NzVGV4dHMubGVuZ3RoID8gY3NzVGV4dHMuam9pbignOycpICsgJzsnIDogJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSByb3RhdGlvbiBtb3ZpbmcgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sZWZ0IG5vcm1hbCBsZWZ0XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1vdmVMZWZ0IG1vdmUgbGVmdFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy50b3AgdG9wXG4gICAgICogQHJldHVybnMge3t0b3A6bnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVJvdGF0aW9uTW92aW5nUG9zaXRpb246IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbW92ZUxlZnQgPSBwYXJhbXMubW92ZUxlZnQsXG4gICAgICAgICAgICBkZWdyZWUgPSB0aGlzLmJvdW5kc01ha2VyLnhBeGlzRGVncmVlO1xuXG4gICAgICAgIGlmIChkZWdyZWUgPT09IGNoYXJ0Q29uc3QuQU5HTEVfODUpIHtcbiAgICAgICAgICAgIG1vdmVMZWZ0ICs9IGNhbGN1bGF0b3IuY2FsY3VsYXRlQWRqYWNlbnQoY2hhcnRDb25zdC5BTkdMRV85MCAtIGRlZ3JlZSwgcGFyYW1zLmxhYmVsSGVpZ2h0IC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBwYXJhbXMudG9wLFxuICAgICAgICAgICAgbGVmdDogcGFyYW1zLmxlZnQgLSBtb3ZlTGVmdFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgcm90YXRpb24gbW92aW5nIHBvc2l0aW9uIGZvciBvbGQgYnJvd3NlcihJRTcsIElFOCkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxhYmVsV2lkdGggbGFiZWwgd2lkdGhcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxlZnQgbm9ybWFsIGxlZnRcbiAgICAgKiAgICAgIEBwYXJhbSB7KHN0cmluZyB8IG51bWJlcil9IHBhcmFtcy5sYWJlbCBsYWJlbFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge3t0b3A6bnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVJvdGF0aW9uTW92aW5nUG9zaXRpb25Gb3JPbGRCcm93c2VyOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChwYXJhbXMubGFiZWwsIHBhcmFtcy50aGVtZSksXG4gICAgICAgICAgICBkZWdyZWUgPSB0aGlzLmJvdW5kc01ha2VyLnhBeGlzRGVncmVlLFxuICAgICAgICAgICAgc21hbGxBcmVhV2lkdGggPSBjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KGNoYXJ0Q29uc3QuQU5HTEVfOTAgLSBkZWdyZWUsIHBhcmFtcy5sYWJlbEhlaWdodCAvIDIpLFxuICAgICAgICAgICAgbmV3TGFiZWxXaWR0aCA9IChjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KGRlZ3JlZSwgbGFiZWxXaWR0aCAvIDIpICsgc21hbGxBcmVhV2lkdGgpICogMixcbiAgICAgICAgICAgIGNoYW5nZWRXaWR0aCA9IHJlbmRlclV0aWwuaXNJRTcoKSA/IDAgOiAobGFiZWxXaWR0aCAtIG5ld0xhYmVsV2lkdGgpLFxuICAgICAgICAgICAgbW92ZUxlZnQgPSAocGFyYW1zLmxhYmVsV2lkdGggLyAyKSAtIChzbWFsbEFyZWFXaWR0aCAqIDIpO1xuXG4gICAgICAgIGlmIChkZWdyZWUgPT09IGNoYXJ0Q29uc3QuQU5HTEVfODUpIHtcbiAgICAgICAgICAgIG1vdmVMZWZ0ICs9IHNtYWxsQXJlYVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogY2hhcnRDb25zdC5YQVhJU19MQUJFTF9UT1BfTUFSR0lOLFxuICAgICAgICAgICAgbGVmdDogcGFyYW1zLmxlZnQgKyBjaGFuZ2VkV2lkdGggLSBtb3ZlTGVmdFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNzc1RleHQgZm9yIHJvdGF0aW9uIG1vdmluZy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxXaWR0aCBsYWJlbCB3aWR0aFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGVmdCBub3JtYWwgbGVmdFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tb3ZlTGVmdCBtb3ZlIGxlZnRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudG9wIHRvcFxuICAgICAqICAgICAgQHBhcmFtIHsoc3RyaW5nIHwgbnVtYmVyKX0gcGFyYW1zLmxhYmVsIGxhYmVsXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjc3NUZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNzc1RleHRGb3JSb3RhdGlvbk1vdmluZzogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbjtcblxuICAgICAgICBpZiAocmVuZGVyVXRpbC5pc09sZEJyb3dzZXIoKSkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9jYWxjdWxhdGVSb3RhdGlvbk1vdmluZ1Bvc2l0aW9uRm9yT2xkQnJvd3NlcihwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9jYWxjdWxhdGVSb3RhdGlvbk1vdmluZ1Bvc2l0aW9uKHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZGVyVXRpbC5jb25jYXRTdHIoJ2xlZnQ6JywgcG9zaXRpb24ubGVmdCwgJ3B4JywgJzt0b3A6JywgcG9zaXRpb24udG9wLCAncHgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBodG1sIG9mIHJvdGF0aW9uIGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBwb3NpdGlvbnMgbGFiZWwgcG9zaXRpb24gYXJyYXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjYXRlZ29yaWVzIGNhdGVnb3JpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxTaXplIGxhYmVsIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkaXRpb25hbFNpemUgYWRkaXRpb25hbCBzaXplXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbGFiZWxzIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUm90YXRpb25MYWJlbHNIdG1sOiBmdW5jdGlvbihwb3NpdGlvbnMsIGNhdGVnb3JpZXMsIGxhYmVsU2l6ZSwgYWRkaXRpb25hbFNpemUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgZGVncmVlID0gdGhpcy5ib3VuZHNNYWtlci54QXhpc0RlZ3JlZSxcbiAgICAgICAgICAgIHRlbXBsYXRlID0gYXhpc1RlbXBsYXRlLnRwbEF4aXNMYWJlbCxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGNhdGVnb3JpZXNbMF0sIHRoaXMudGhlbWUubGFiZWwpLFxuICAgICAgICAgICAgbGFiZWxDc3NUZXh0ID0gdGhpcy5fbWFrZUxhYmVsQ3NzVGV4dChsYWJlbFNpemUpLFxuICAgICAgICAgICAgYWRkaXRpb25hbENsYXNzID0gJyB0dWktY2hhcnQteGF4aXMtcm90YXRpb24gdHVpLWNoYXJ0LXhheGlzLXJvdGF0aW9uJyArIGRlZ3JlZSxcbiAgICAgICAgICAgIGhhbGZXaWR0aCA9IGxhYmVsU2l6ZSAvIDIsXG4gICAgICAgICAgICBtb3ZlTGVmdCA9IGNhbGN1bGF0b3IuY2FsY3VsYXRlQWRqYWNlbnQoZGVncmVlLCBoYWxmV2lkdGgpLFxuICAgICAgICAgICAgdG9wID0gY2FsY3VsYXRvci5jYWxjdWxhdGVPcHBvc2l0ZShkZWdyZWUsIGhhbGZXaWR0aCkgK1xuICAgICAgICAgICAgICAgIGNoYXJ0Q29uc3QuWEFYSVNfTEFCRUxfVE9QX01BUkdJTixcbiAgICAgICAgICAgIHNwYW5Dc3NUZXh0ID0gKHJlbmRlclV0aWwuaXNJRTcoKSAmJiBkZWdyZWUpID8gY2hhcnRDb25zdC5JRTdfUk9UQVRJT05fRklMVEVSX1NUWUxFX01BUFtkZWdyZWVdIDogJycsXG4gICAgICAgICAgICBsYWJlbHNIdG1sO1xuXG4gICAgICAgIGFkZGl0aW9uYWxTaXplID0gYWRkaXRpb25hbFNpemUgfHwgMDtcbiAgICAgICAgbGFiZWxzSHRtbCA9IHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gY2F0ZWdvcmllc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgcm90YXRpb25Dc3NUZXh0ID0gc2VsZi5fbWFrZUNzc1RleHRGb3JSb3RhdGlvbk1vdmluZyh7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsSGVpZ2h0OiBsYWJlbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxXaWR0aDogbGFiZWxTaXplLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24gKyBhZGRpdGlvbmFsU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgbW92ZUxlZnQ6IG1vdmVMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lOiBzZWxmLnRoZW1lLmxhYmVsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbENsYXNzOiBhZGRpdGlvbmFsQ2xhc3MsXG4gICAgICAgICAgICAgICAgY3NzVGV4dDogbGFiZWxDc3NUZXh0ICsgcm90YXRpb25Dc3NUZXh0LFxuICAgICAgICAgICAgICAgIHNwYW5Dc3NUZXh0OiBzcGFuQ3NzVGV4dCxcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gbGFiZWxzSHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBodG1sIG9mIG5vcm1hbCBsYWJlbHMuXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gcG9zaXRpb25zIGxhYmVsIHBvc2l0aW9uIGFycmF5XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY2F0ZWdvcmllcyBjYXRlZ29yaWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsU2l6ZSBsYWJlbCBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGl0aW9uYWxTaXplIGFkZGl0aW9uYWwgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGxhYmVscyBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU5vcm1hbExhYmVsc0h0bWw6IGZ1bmN0aW9uKHBvc2l0aW9ucywgY2F0ZWdvcmllcywgbGFiZWxTaXplLCBhZGRpdGlvbmFsU2l6ZSkge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBheGlzVGVtcGxhdGUudHBsQXhpc0xhYmVsLFxuICAgICAgICAgICAgbGFiZWxDc3NUZXh0ID0gdGhpcy5fbWFrZUxhYmVsQ3NzVGV4dChsYWJlbFNpemUpLFxuICAgICAgICAgICAgcG9zVHlwZSwgbGFiZWxzSHRtbDtcblxuICAgICAgICBhZGRpdGlvbmFsU2l6ZSA9IGFkZGl0aW9uYWxTaXplIHx8IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICBwb3NUeXBlID0gdGhpcy5kYXRhLmlzTGFiZWxBeGlzID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc1R5cGUgPSAnbGVmdCc7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbHNIdG1sID0gdHVpLnV0aWwubWFwKHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYWRkQ3NzVGV4dCA9IHJlbmRlclV0aWwuY29uY2F0U3RyKHBvc1R5cGUsICc6JywgKHBvc2l0aW9uICsgYWRkaXRpb25hbFNpemUpLCAncHgnKTtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbENsYXNzOiAnJyxcbiAgICAgICAgICAgICAgICBjc3NUZXh0OiBsYWJlbENzc1RleHQgKyBhZGRDc3NUZXh0LFxuICAgICAgICAgICAgICAgIGxhYmVsOiBjYXRlZ29yaWVzW2luZGV4XSxcbiAgICAgICAgICAgICAgICBzcGFuQ3NzVGV4dDogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gbGFiZWxzSHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsYWJlbHMgaHRtbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBwb3NpdGlvbnMgbGFiZWwgcG9zaXRpb24gYXJyYXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjYXRlZ29yaWVzIGNhdGVnb3JpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxTaXplIGxhYmVsIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkaXRpb25hbFNpemUgYWRkaXRpb25hbCBzaXplXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbGFiZWxzIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxzSHRtbDogZnVuY3Rpb24ocG9zaXRpb25zLCBjYXRlZ29yaWVzLCBsYWJlbFNpemUsIGFkZGl0aW9uYWxTaXplKSB7XG4gICAgICAgIHZhciBpc1JvdGF0aW9ubGVzc1hBeGlzID0gIXRoaXMuZGF0YS5pc1ZlcnRpY2FsICYmIHRoaXMuZGF0YS5pc0xhYmVsQXhpcyAmJiB0aGlzLm9wdGlvbnMucm90YXRpb24gPT09IGZhbHNlLFxuICAgICAgICAgICAgaGFzUm90YXRlZFhBeGlzTGFiZWwgPSB0aGlzLmNvbXBvbmVudE5hbWUgPT09ICd4QXhpcycgJiYgdGhpcy5ib3VuZHNNYWtlci54QXhpc0RlZ3JlZSxcbiAgICAgICAgICAgIGxhYmVsc0h0bWw7XG5cbiAgICAgICAgaWYgKGlzUm90YXRpb25sZXNzWEF4aXMpIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0TXVsdGlsaW5lQ2F0ZWdvcmllcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zaXRpb25zLmxlbmd0aCA9IGNhdGVnb3JpZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChoYXNSb3RhdGVkWEF4aXNMYWJlbCkge1xuICAgICAgICAgICAgbGFiZWxzSHRtbCA9IHRoaXMuX21ha2VSb3RhdGlvbkxhYmVsc0h0bWwocG9zaXRpb25zLCBjYXRlZ29yaWVzLCBsYWJlbFNpemUsIGFkZGl0aW9uYWxTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsc0h0bWwgPSB0aGlzLl9tYWtlTm9ybWFsTGFiZWxzSHRtbChwb3NpdGlvbnMsIGNhdGVnb3JpZXMsIGxhYmVsU2l6ZSwgYWRkaXRpb25hbFNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsc0h0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBwb3NpdGlvbiBvZiBsYWJlbCBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxhYmVsQ29udGFpbmVyIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbFNpemUgbGFiZWwgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NoYW5nZUxhYmVsQXJlYVBvc2l0aW9uOiBmdW5jdGlvbihsYWJlbENvbnRhaW5lciwgbGFiZWxTaXplKSB7XG4gICAgICAgIHZhciBsYWJlbEhlaWdodDtcblxuICAgICAgICBpZiAodGhpcy5kYXRhLmlzTGFiZWxBeGlzICYmICF0aGlzLmRhdGEuYWxpZ25lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodCgnQUJDJywgdGhpcy50aGVtZS5sYWJlbCk7XG4gICAgICAgICAgICBsYWJlbENvbnRhaW5lci5zdHlsZS50b3AgPSByZW5kZXJVdGlsLmNvbmNhdFN0cihwYXJzZUludChsYWJlbEhlaWdodCAvIDIsIDEwKSwgJ3B4Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYWJlbENvbnRhaW5lci5zdHlsZS5sZWZ0ID0gcmVuZGVyVXRpbC5jb25jYXRTdHIoJy0nLCBwYXJzZUludChsYWJlbFNpemUgLyAyLCAxMCksICdweCcpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpcztcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIHRlbXBsYXRlcyBvciBheGlzIHZpZXcuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0ZW1wbGF0ZU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy90ZW1wbGF0ZU1ha2VyJyk7XG5cbnZhciBodG1scyA9IHtcbiAgICBIVE1MX0FYSVNfVElDS19MSU5FOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC10aWNrLWxpbmVcIicgK1xuICAgICAgICAnIHN0eWxlPVwie3sgcG9zaXRpb25UeXBlIH19Ont7IHBvc2l0aW9uVmFsdWUgfX1weDt7eyBzaXplVHlwZSB9fTp7eyBzaXplIH19cHhcIj48L2Rpdj4nLFxuICAgIEhUTUxfQVhJU19USUNLOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC10aWNrXCIgc3R5bGU9XCJ7eyBjc3NUZXh0IH19XCI+PC9kaXY+JyxcbiAgICBIVE1MX0FYSVNfTEFCRUw6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LWxhYmVse3sgYWRkaXRpb25hbENsYXNzIH19XCIgc3R5bGU9XCJ7eyBjc3NUZXh0IH19XCI+JyArXG4gICAgICAgICc8c3Bhbnt7IHNwYW5Dc3NUZXh0IH19Pnt7IGxhYmVsIH19PC9zcGFuPjwvZGl2Pidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRwbFRpY2tMaW5lOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfQVhJU19USUNLX0xJTkUpLFxuICAgIHRwbEF4aXNUaWNrOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfQVhJU19USUNLKSxcbiAgICB0cGxBeGlzTGFiZWw6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9BWElTX0xBQkVMKVxufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBjaGFydC5qcyBpcyBlbnRyeSBwb2ludCBvZiBUb2FzdCBVSSBDaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi9jb25zdCcpLFxuICAgIGNoYXJ0RmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yaWVzL2NoYXJ0RmFjdG9yeScpLFxuICAgIHBsdWdpbkZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3Rvcmllcy9wbHVnaW5GYWN0b3J5JyksXG4gICAgdGhlbWVGYWN0b3J5ID0gcmVxdWlyZSgnLi9mYWN0b3JpZXMvdGhlbWVGYWN0b3J5JyksXG4gICAgbWFwRmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yaWVzL21hcEZhY3RvcnknKTtcblxudmFyIF9jcmVhdGVDaGFydDtcblxucmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xucmVxdWlyZSgnLi9jb2RlLXNuaXBwZXQtdXRpbCcpO1xucmVxdWlyZSgnLi9yZWdpc3RlckNoYXJ0cycpO1xucmVxdWlyZSgnLi9yZWdpc3RlclRoZW1lcycpO1xuXG4vKipcbiAqIFJhdyBzZXJpZXMgZGF0dW0uXG4gKiBAdHlwZWRlZiB7e25hbWU6ID9zdHJpbmcsIGRhdGE6IEFycmF5LjxudW1iZXI+LCBzdGFjazogP3N0cmluZ319IHJhd1Nlcmllc0RhdHVtXG4gKi9cblxuLyoqXG4gKiBSYXcgc2VyaWVzIGRhdGEuXG4gKiBAdHlwZWRlZiB7QXJyYXkuPHJhd1Nlcmllc0RhdHVtPn0gcmF3U2VyaWVzRGF0YVxuICovXG5cbi8qKlxuICogUmF3IGRhdGEuXG4gKiBAdHlwZWRlZiB7e1xuICogICAgICBjYXRlZ29yaWVzOiA/QXJyYXkuPHN0cmluZz4sXG4gKiAgICAgIHNlcmllczogKHJhd1Nlcmllc0RhdGF8e2xpbmU6ID9yYXdTZXJpZXNEYXRhLCBjb2x1bW46ID9yYXdTZXJpZXNEYXRhfSlcbiAqIH19IHJhd0RhdGFcbiAqL1xuXG4vKipcbiAqIE5ITiBFbnRlcnRhaW5tZW50IFRvYXN0IFVJIENoYXJ0LlxuICogQG5hbWVzcGFjZSB0dWkuY2hhcnRcbiAqL1xudHVpLnV0aWwuZGVmaW5lTmFtZXNwYWNlKCd0dWkuY2hhcnQnKTtcblxuLyoqXG4gKiBDcmVhdGUgY2hhcnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyXG4gKiBAcGFyYW0ge3Jhd0RhdGF9IHJhd0RhdGEgcmF3IGRhdGFcbiAqIEBwYXJhbSB7e1xuICogICBjaGFydDoge1xuICogICAgIHdpZHRoOiBudW1iZXIsXG4gKiAgICAgaGVpZ2h0OiBudW1iZXIsXG4gKiAgICAgdGl0bGU6IHN0cmluZyxcbiAqICAgICBmb3JtYXQ6IHN0cmluZ1xuICogICB9LFxuICogICB5QXhpczoge1xuICogICAgIHRpdGxlOiBzdHJpbmcsXG4gKiAgICAgbWluOiBudW1iZXJcbiAqICAgfSxcbiAqICAgeEF4aXM6IHtcbiAqICAgICB0aXRsZTogc3RyaW5nLFxuICogICAgIG1pbjogbnVtYmVyXG4gKiAgIH0sXG4gKiAgIHRvb2x0aXA6IHtcbiAqICAgICBzdWZmaXg6IHN0cmluZyxcbiAqICAgICB0ZW1wbGF0ZTogZnVuY3Rpb25cbiAqICAgfSxcbiAqICAgdGhlbWU6IHN0cmluZ1xuICogfX0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBjaGFydCBpbnN0YW5jZS5cbiAqIEBwcml2YXRlXG4gKiBAaWdub3JlXG4gKi9cbl9jcmVhdGVDaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucykge1xuICAgIHZhciB0aGVtZU5hbWUsIHRoZW1lLCBjaGFydDtcblxuICAgIHJhd0RhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJhd0RhdGEpKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IHR1aS51dGlsLmRlZXBDb3B5KG9wdGlvbnMpIDoge307XG4gICAgdGhlbWVOYW1lID0gb3B0aW9ucy50aGVtZSB8fCBjaGFydENvbnN0LkRFRkFVTFRfVEhFTUVfTkFNRTtcbiAgICB0aGVtZSA9IHRoZW1lRmFjdG9yeS5nZXQodGhlbWVOYW1lKTtcblxuICAgIGNoYXJ0ID0gY2hhcnRGYWN0b3J5LmdldChvcHRpb25zLmNoYXJ0VHlwZSwgcmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGFydC5yZW5kZXIoKSk7XG4gICAgY2hhcnQuYW5pbWF0ZUNoYXJ0KCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG4vKipcbiAqIEJhciBjaGFydCBjcmVhdG9yLlxuICogQG1lbWJlck9mIHR1aS5jaGFydFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNoYXJ0IGNvbnRhaW5lclxuICogQHBhcmFtIHtyYXdEYXRhfSByYXdEYXRhIHJhdyBkYXRhXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHJhd0RhdGEuY2F0ZWdvcmllcyBjYXRlZ29yaWVzXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YS5zZXJpZXMgc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2hhcnQgY2hhcnQgb3B0aW9uc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCBjaGFydCBoZWlnaHRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LnRpdGxlIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC5mb3JtYXQgdmFsdWUgZm9ybWF0XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnlBeGlzIG9wdGlvbnMgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueUF4aXMudGl0bGUgdGl0bGUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueUF4aXMuYWxpZ24gYWxpZ24gb3B0aW9uIGZvciBkaXZlcmdpbmcgb3B0aW9uXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnhBeGlzIG9wdGlvbnMgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy54QXhpcy50aXRsZSB0aXRsZSBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnhBeGlzLm1pbiBtaW5pbWFsIHZhbHVlIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueEF4aXMubWF4IG1heGltdW0gdmFsdWUgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyBvcHRpb25zIG9mIHNlcmllc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc2VyaWVzLnN0YWNrZWQgc3RhY2tlZCB0eXBlXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dMYWJlbCB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zZXJpZXMuYmFyV2lkdGggYmFyIHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmhhc1NlbGVjdGlvbiB3aGV0aGVyIGhhcyBzZWxlY3Rpb24gb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmRpdmVyZ2luZyB3aGV0aGVyIGRpdmVyZ2luZyBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSB0ZW1wbGF0ZSBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy50b29sdGlwLmdyb3VwZWQgd2hldGhlciBncm91cCB0b29sdGlwIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgb3B0aW9ucyBvZiBsZWdlbmRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxlZ2VuZC5hbGlnbiBsZWdlbmQgYWxpZ24gKHRvcHxib3R0b218bGVmdClcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuaGFzQ2hlY2tib3ggd2hldGhlciBoYXMgY2hlY2tib3ggb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oaWRkZW4gd2hldGhlciBoaWRkZW4gb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIHRoZW1lIG5hbWVcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGliVHlwZSBncmFwaCBsaWJyYXJ5IHR5cGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGJhciBjaGFydFxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgcmF3RGF0YSA9IHtcbiAqICAgICAgIGNhdGVnb3JpZXM6IFsnY2F0ZTEnLCAnY2F0ZTInLCAnY2F0ZTMnXSxcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDEnLFxuICogICAgICAgICAgIGRhdGE6IFsyMCwgMzAsIDUwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDInLFxuICogICAgICAgICAgIGRhdGE6IFs0MCwgNDAsIDYwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDMnLFxuICogICAgICAgICAgIGRhdGE6IFs2MCwgNTAsIDEwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDQnLFxuICogICAgICAgICAgIGRhdGE6IFs4MCwgMTAsIDcwXVxuICogICAgICAgICB9XG4gKiAgICAgICBdXG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdCYXIgQ2hhcnQnXG4gKiAgICAgICB9LFxuICogICAgICAgeUF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdZIEF4aXMnXG4gKiAgICAgICB9LFxuICogICAgICAgeEF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdYIEF4aXMnXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5iYXJDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xuICovXG50dWkuY2hhcnQuYmFyQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9CQVI7XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb2x1bW4gY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7cmF3RGF0YX0gcmF3RGF0YSByYXcgZGF0YVxuICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSByYXdEYXRhLmNhdGVnb3JpZXMgY2F0ZWdvcmllc1xuICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEuc2VyaWVzIHNlcmllcyBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNoYXJ0IGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LndpZHRoIGNoYXJ0IHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC5oZWlnaHQgY2hhcnQgaGVpZ2h0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC50aXRsZSBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQuZm9ybWF0IHZhbHVlIGZvcm1hdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy55QXhpcyBvcHRpb25zIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnlBeGlzLnRpdGxlIHRpdGxlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1pbiBtaW5pbWFsIHZhbHVlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1heCBtYXhpbXVtIHZhbHVlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueEF4aXMgb3B0aW9ucyBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnhBeGlzLnRpdGxlIHRpdGxlIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueEF4aXMubGFiZWxJbnRlcnZhbCBsYWJlbCBpbnRlcnZhbCBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy54QXhpcy5yb3RhdGlvbiB3aGV0aGVyIGxhYmVsIHJvdGF0aW9uIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzIG9wdGlvbnMgb2Ygc2VyaWVzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zZXJpZXMuc3RhY2tlZCBzdGFja2VkIHR5cGVcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0xhYmVsIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnNlcmllcy5iYXJXaWR0aCBiYXIgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuaGFzU2VsZWN0aW9uIHdoZXRoZXIgaGFzIHNlbGVjdGlvbiBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuZGl2ZXJnaW5nIHdoZXRoZXIgZGl2ZXJnaW5nIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwIG9wdGlvbnMgb2YgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5zdWZmaXggc3VmZml4IG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIHRlbXBsYXRlIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuYWxpZ24gdG9vbHRpcCBhbGlnbiBvcHRpb25cbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLmxlZnQgcG9zaXRpb24gbGVmdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24udG9wIHBvc2l0aW9uIHRvcFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnRvb2x0aXAuZ3JvdXBlZCB3aGV0aGVyIGdyb3VwIHRvb2x0aXAgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmxlZ2VuZCBvcHRpb25zIG9mIGxlZ2VuZFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGVnZW5kLmFsaWduIGxlZ2VuZCBhbGlnbiAodG9wfGJvdHRvbXxsZWZ0KVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oYXNDaGVja2JveCB3aGV0aGVyIGhhcyBjaGVja2JveCBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubGVnZW5kLmhpZGRlbiB3aGV0aGVyIGhpZGRlbiBvciBub3RcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGhlbWUgdGhlbWUgbmFtZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIGdyYXBoIGxpYnJhcnkgdHlwZVxuICogQHJldHVybnMge29iamVjdH0gY29sdW1uIGNoYXJ0XG4gKiBAYXBpXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXItaWQnKSxcbiAqICAgICByYXdEYXRhID0ge1xuICogICAgICAgY2F0ZWdvcmllczogWydjYXRlMScsICdjYXRlMicsICdjYXRlMyddLFxuICogICAgICAgc2VyaWVzOiBbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMScsXG4gKiAgICAgICAgICAgZGF0YTogWzIwLCAzMCwgNTBdXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMicsXG4gKiAgICAgICAgICAgZGF0YTogWzQwLCA0MCwgNjBdXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMycsXG4gKiAgICAgICAgICAgZGF0YTogWzYwLCA1MCwgMTBdXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kNCcsXG4gKiAgICAgICAgICAgZGF0YTogWzgwLCAxMCwgNzBdXG4gKiAgICAgICAgIH1cbiAqICAgICAgIF1cbiAqICAgICB9LFxuICogICAgIG9wdGlvbnMgPSB7XG4gKiAgICAgICBjaGFydDoge1xuICogICAgICAgICB0aXRsZTogJ0NvbHVtbiBDaGFydCdcbiAqICAgICAgIH0sXG4gKiAgICAgICB5QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1kgQXhpcydcbiAqICAgICAgIH0sXG4gKiAgICAgICB4QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1ggQXhpcydcbiAqICAgICAgIH1cbiAqICAgICB9O1xuICogdHVpLmNoYXJ0LmNvbHVtbkNoYXJ0KGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucyk7XG4gKi9cbnR1aS5jaGFydC5jb2x1bW5DaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2hhcnRUeXBlID0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0NPTFVNTjtcbiAgICByZXR1cm4gX2NyZWF0ZUNoYXJ0KGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIExpbmUgY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7cmF3RGF0YX0gcmF3RGF0YSByYXcgZGF0YVxuICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSByYXdEYXRhLmNhdGVnb3JpZXMgY2F0ZWdvcmllc1xuICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEuc2VyaWVzIHNlcmllcyBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNoYXJ0IGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LndpZHRoIGNoYXJ0IHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC5oZWlnaHQgY2hhcnQgaGVpZ2h0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC50aXRsZSBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQuZm9ybWF0IHZhbHVlIGZvcm1hdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy55QXhpcyBvcHRpb25zIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnlBeGlzLnRpdGxlIHRpdGxlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1pbiBtaW5pbWFsIHZhbHVlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1heCBtYXhpbXVtIHZhbHVlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueEF4aXMgb3B0aW9ucyBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnhBeGlzLnRpdGxlIHRpdGxlIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueEF4aXMubGFiZWxJbnRlcnZhbCBsYWJlbCBpbnRlcnZhbCBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy54QXhpcy5yb3RhdGlvbiB3aGV0aGVyIGxhYmVsIHJvdGF0aW9uIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzIG9wdGlvbnMgb2Ygc2VyaWVzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmhhc0RvdCB3aGV0aGVyIGhhcyBkb3Qgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dMYWJlbCB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmhhc1NlbGVjdGlvbiB3aGV0aGVyIGhhcyBzZWxlY3Rpb24gb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNwbGluZSB3aGV0aGVyIHNwbGluZSBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSB0ZW1wbGF0ZSBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy50b29sdGlwLmdyb3VwZWQgd2hldGhlciBncm91cCB0b29sdGlwIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgb3B0aW9ucyBvZiBsZWdlbmRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxlZ2VuZC5hbGlnbiBsZWdlbmQgYWxpZ24gKHRvcHxib3R0b218bGVmdClcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuaGFzQ2hlY2tib3ggd2hldGhlciBoYXMgY2hlY2tib3ggb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oaWRkZW4gd2hldGhlciBoaWRkZW4gb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIHRoZW1lIG5hbWVcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGliVHlwZSBncmFwaCBsaWJyYXJ5IHR5cGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGJhciBjaGFydFxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgcmF3RGF0YSA9IHtcbiAqICAgICAgIGNhdGVnb3JpZXM6IFsnY2F0ZTEnLCAnY2F0ZTInLCAnY2F0ZTMnXSxcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDEnLFxuICogICAgICAgICAgIGRhdGE6IFsyMCwgMzAsIDUwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDInLFxuICogICAgICAgICAgIGRhdGE6IFs0MCwgNDAsIDYwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDMnLFxuICogICAgICAgICAgIGRhdGE6IFs2MCwgNTAsIDEwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDQnLFxuICogICAgICAgICAgIGRhdGE6IFs4MCwgMTAsIDcwXVxuICogICAgICAgICB9XG4gKiAgICAgICBdXG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdMaW5lIENoYXJ0J1xuICogICAgICAgfSxcbiAqICAgICAgIHlBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWSBBeGlzJ1xuICogICAgICAgfSxcbiAqICAgICAgIHhBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWCBBeGlzJ1xuICogICAgICAgfSxcbiAqICAgICAgIHNlcmllczoge1xuICogICAgICAgICBoYXNEb3Q6IHRydWVcbiAqICAgICAgIH1cbiAqICAgICB9O1xuICogdHVpLmNoYXJ0LmxpbmVDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xuICovXG50dWkuY2hhcnQubGluZUNoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jaGFydFR5cGUgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfTElORTtcbiAgICByZXR1cm4gX2NyZWF0ZUNoYXJ0KGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEFyZWEgY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7cmF3RGF0YX0gcmF3RGF0YSByYXcgZGF0YVxuICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSByYXdEYXRhLmNhdGVnb3JpZXMgY2F0ZWdvcmllc1xuICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEuc2VyaWVzIHNlcmllcyBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNoYXJ0IGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LndpZHRoIGNoYXJ0IHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC5oZWlnaHQgY2hhcnQgaGVpZ2h0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC50aXRsZSBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQuZm9ybWF0IHZhbHVlIGZvcm1hdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy55QXhpcyBvcHRpb25zIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnlBeGlzLnRpdGxlIHRpdGxlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1pbiBtaW5pbWFsIHZhbHVlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1heCBtYXhpbXVtIHZhbHVlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueEF4aXMgb3B0aW9ucyBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnhBeGlzLnRpdGxlIHRpdGxlIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueEF4aXMubGFiZWxJbnRlcnZhbCBsYWJlbCBpbnRlcnZhbCBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy54QXhpcy5yb3RhdGlvbiB3aGV0aGVyIGxhYmVsIHJvdGF0aW9uIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzIG9wdGlvbnMgb2Ygc2VyaWVzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmhhc0RvdCB3aGV0aGVyIGhhcyBkb3Qgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dMYWJlbCB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmhhc1NlbGVjdGlvbiB3aGV0aGVyIGhhcyBzZWxlY3Rpb24gb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNwbGluZSB3aGV0aGVyIHNwbGluZSBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSB0ZW1wbGF0ZSBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy50b29sdGlwLmdyb3VwZWQgd2hldGhlciBncm91cCB0b29sdGlwIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgb3B0aW9ucyBvZiBsZWdlbmRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxlZ2VuZC5hbGlnbiBsZWdlbmQgYWxpZ24gKHRvcHxib3R0b218bGVmdClcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuaGFzQ2hlY2tib3ggd2hldGhlciBoYXMgY2hlY2tib3ggb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oaWRkZW4gd2hldGhlciBoaWRkZW4gb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIHRoZW1lIG5hbWVcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGliVHlwZSBncmFwaCBsaWJyYXJ5IHR5cGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGJhciBjaGFydFxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgcmF3RGF0YSA9IHtcbiAqICAgICAgIGNhdGVnb3JpZXM6IFsnY2F0ZTEnLCAnY2F0ZTInLCAnY2F0ZTMnXSxcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDEnLFxuICogICAgICAgICAgIGRhdGE6IFsyMCwgMzAsIDUwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDInLFxuICogICAgICAgICAgIGRhdGE6IFs0MCwgNDAsIDYwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDMnLFxuICogICAgICAgICAgIGRhdGE6IFs2MCwgNTAsIDEwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDQnLFxuICogICAgICAgICAgIGRhdGE6IFs4MCwgMTAsIDcwXVxuICogICAgICAgICB9XG4gKiAgICAgICBdXG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdBcmVhIENoYXJ0J1xuICogICAgICAgfSxcbiAqICAgICAgIHlBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWSBBeGlzJ1xuICogICAgICAgfSxcbiAqICAgICAgIHhBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWCBBeGlzJ1xuICogICAgICAgfVxuICogICAgIH07XG4gKiB0dWkuY2hhcnQuYXJlYUNoYXJ0KGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucyk7XG4gKi9cbnR1aS5jaGFydC5hcmVhQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9BUkVBO1xuICAgIHJldHVybiBfY3JlYXRlQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQnViYmxlIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge3Jhd0RhdGF9IHJhd0RhdGEgcmF3IGRhdGFcbiAqICAgICAgQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gcmF3RGF0YS5jYXRlZ29yaWVzIGNhdGVnb3JpZXNcbiAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhLnNlcmllcyBzZXJpZXMgZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jaGFydCBjaGFydCBvcHRpb25zXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC53aWR0aCBjaGFydCB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQuaGVpZ2h0IGNoYXJ0IGhlaWdodFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQudGl0bGUgY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LmZvcm1hdCB2YWx1ZSBmb3JtYXRcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueUF4aXMgb3B0aW9ucyBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy55QXhpcy50aXRsZSB0aXRsZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy55QXhpcy5taW4gbWluaW1hbCB2YWx1ZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy55QXhpcy5tYXggbWF4aW11bSB2YWx1ZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnhBeGlzIG9wdGlvbnMgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy54QXhpcy50aXRsZSB0aXRsZSBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnhBeGlzLmxhYmVsSW50ZXJ2YWwgbGFiZWwgaW50ZXJ2YWwgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMueEF4aXMucm90YXRpb24gd2hldGhlciBsYWJlbCByb3RhdGlvbiBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyBvcHRpb25zIG9mIHNlcmllc1xuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5zaG93TGFiZWwgd2hldGhlciBzaG93IGxhYmVsIG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5oYXNTZWxlY3Rpb24gd2hldGhlciBoYXMgc2VsZWN0aW9uIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwIG9wdGlvbnMgb2YgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5zdWZmaXggc3VmZml4IG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIHRlbXBsYXRlIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuYWxpZ24gdG9vbHRpcCBhbGlnbiBvcHRpb25cbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLmxlZnQgcG9zaXRpb24gbGVmdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24udG9wIHBvc2l0aW9uIHRvcFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnRvb2x0aXAuZ3JvdXBlZCB3aGV0aGVyIGdyb3VwIHRvb2x0aXAgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmxlZ2VuZCBvcHRpb25zIG9mIGxlZ2VuZFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGVnZW5kLmFsaWduIGxlZ2VuZCBhbGlnbiAodG9wfGJvdHRvbXxsZWZ0KVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oYXNDaGVja2JveCB3aGV0aGVyIGhhcyBjaGVja2JveCBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubGVnZW5kLmhpZGRlbiB3aGV0aGVyIGhpZGRlbiBvciBub3RcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGhlbWUgdGhlbWUgbmFtZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIGdyYXBoIGxpYnJhcnkgdHlwZVxuICogQHJldHVybnMge29iamVjdH0gYnViYmxlIGNoYXJ0XG4gKiBAYXBpXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXItaWQnKSxcbiAqICAgICByYXdEYXRhID0ge1xuICogICAgICAgc2VyaWVzOiBbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMScsXG4gKiAgICAgICAgICAgZGF0YTogW3tcbiAqICAgICAgICAgICAgICB4OiAxMCxcbiAqICAgICAgICAgICAgICB5OiAyMCxcbiAqICAgICAgICAgICAgICByOiAxNSxcbiAqICAgICAgICAgICAgICBsYWJlbDogJ0xhYmxlMSdcbiAqICAgICAgICAgICB9LCB7XG4gKiAgICAgICAgICAgICAgeDogMjAsXG4gKiAgICAgICAgICAgICAgeTogNDAsXG4gKiAgICAgICAgICAgICAgcjogMTAsXG4gKiAgICAgICAgICAgICAgbGFiZWw6ICdMYWJsZTInXG4gKiAgICAgICAgICAgfV1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQyJyxcbiAqICAgICAgICAgICBkYXRhOiBbe1xuICogICAgICAgICAgICAgIHg6IDQwLFxuICogICAgICAgICAgICAgIHk6IDEwLFxuICogICAgICAgICAgICAgIHI6IDUsXG4gKiAgICAgICAgICAgICAgbGFiZWw6ICdMYWJsZTMnXG4gKiAgICAgICAgICAgfSwge1xuICogICAgICAgICAgICAgIHg6IDMwLFxuICogICAgICAgICAgICAgIHk6IDQwLFxuICogICAgICAgICAgICAgIHI6IDgsXG4gKiAgICAgICAgICAgICAgbGFiZWw6ICdMYWJsZTQnXG4gKiAgICAgICAgICAgfV1cbiAqICAgICAgICAgfVxuICogICAgICAgXVxuICogICAgIH0sXG4gKiAgICAgb3B0aW9ucyA9IHtcbiAqICAgICAgIGNoYXJ0OiB7XG4gKiAgICAgICAgIHRpdGxlOiAnQnViYmxlIENoYXJ0J1xuICogICAgICAgfSxcbiAqICAgICAgIHlBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWSBBeGlzJ1xuICogICAgICAgfSxcbiAqICAgICAgIHhBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWCBBeGlzJ1xuICogICAgICAgfVxuICogICAgIH07XG4gKiB0dWkuY2hhcnQuYnViYmxlQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbiAqL1xudHVpLmNoYXJ0LmJ1YmJsZUNoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jaGFydFR5cGUgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfQlVCQkxFO1xuICAgIHJldHVybiBfY3JlYXRlQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ29tYm8gY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7cmF3RGF0YX0gcmF3RGF0YSByYXcgZGF0YVxuICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSByYXdEYXRhLmNhdGVnb3JpZXMgY2F0ZWdvcmllc1xuICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEuc2VyaWVzIHNlcmllcyBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNoYXJ0IGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LndpZHRoIGNoYXJ0IHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC5oZWlnaHQgY2hhcnQgaGVpZ2h0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC50aXRsZSBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQuZm9ybWF0IHZhbHVlIGZvcm1hdFxuICogICAgICBAcGFyYW0ge29iamVjdHxBcnJheX0gb3B0aW9ucy55QXhpcyBvcHRpb25zIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnlBeGlzLnRpdGxlIHRpdGxlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1pbiBtaW5pbWFsIHZhbHVlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1heCBtYXhpbXVtIHZhbHVlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueEF4aXMgb3B0aW9ucyBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnhBeGlzLnRpdGxlIHRpdGxlIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueEF4aXMubGFiZWxJbnRlcnZhbCBsYWJlbCBpbnRlcnZhbCBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy54QXhpcy5yb3RhdGlvbiB3aGV0aGVyIGxhYmVsIHJvdGF0aW9uIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzIG9wdGlvbnMgb2Ygc2VyaWVzXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMuY29sdW1uIG9wdGlvbnMgb2YgY29sdW1uIHNlcmllc1xuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnNlcmllcy5jb2x1bW4uc3RhY2tlZCBzdGFja2VkIHR5cGVcbiAqICAgICAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmNvbHVtbi5zaG93TGFiZWwgd2hldGhlciBzaG93IGxhYmVsIG9yIG5vdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnNlcmllcy5jb2x1bW4uYmFyV2lkdGggYmFyIHdpZHRoXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5jb2x1bW4uaGFzU2VsZWN0aW9uIHdoZXRoZXIgaGFzIHNlbGVjdGlvbiBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcy5saW5lIG9wdGlvbnMgb2YgbGluZSBzZXJpZXNcbiAqICAgICAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmxpbmUuaGFzRG90IHdoZXRoZXIgaGFzIGRvdCBvciBub3RcbiAqICAgICAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmxpbmUuc2hvd0xhYmVsIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmxpbmUuaGFzU2VsZWN0aW9uIHdoZXRoZXIgaGFzIHNlbGVjdGlvbiBvciBub3RcbiAqICAgICAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmxpbmUuc3BsaW5lIHdoZXRoZXIgc3BsaW5lIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwIG9wdGlvbnMgb2YgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4gb3B0aW9ucyBvZiBjb2x1bW4gdG9vbHRpcFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuY29sdW1uLnN1ZmZpeCBzdWZmaXggb2YgdG9vbHRpcFxuICogICAgICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRvb2x0aXAuY29sdW1uLnRlbXBsYXRlXSB0ZW1wbGF0ZSBvZiB0b29sdGlwXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4uYWxpZ24gdG9vbHRpcCBhbGlnbiBvcHRpb25cbiAqICAgICAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLmNvbHVtbi5wb3NpdGlvbiByZWxhdGl2ZSBwb3NpdGlvblxuICogICAgICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLmNvbHVtbi5wb3NpdGlvbi5sZWZ0IHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4ucG9zaXRpb24udG9wIHBvc2l0aW9uIHRvcFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnRvb2x0aXAuZ3JvdXBlZCB3aGV0aGVyIGdyb3VwIHRvb2x0aXAgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmxlZ2VuZCBvcHRpb25zIG9mIGxlZ2VuZFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGVnZW5kLmFsaWduIGxlZ2VuZCBhbGlnbiAodG9wfGJvdHRvbXxsZWZ0KVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oYXNDaGVja2JveCB3aGV0aGVyIGhhcyBjaGVja2JveCBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubGVnZW5kLmhpZGRlbiB3aGV0aGVyIGhpZGRlbiBvciBub3RcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGhlbWUgdGhlbWUgbmFtZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIGdyYXBoIGxpYnJhcnkgdHlwZVxuICogQHJldHVybnMge29iamVjdH0gYmFyIGNoYXJ0XG4gKiBAYXBpXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXItaWQnKSxcbiAqICAgICByYXdEYXRhID0ge1xuICogICAgICAgY2F0ZWdvcmllczogWydjYXRlMScsICdjYXRlMicsICdjYXRlMyddLFxuICogICAgICAgc2VyaWVzOiB7XG4gKiAgICAgICAgIGNvbHVtbjogW1xuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICdMZWdlbmQxJyxcbiAqICAgICAgICAgICAgIGRhdGE6IFsyMCwgMzAsIDUwXV1cbiAqICAgICAgICAgICB9LFxuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICdMZWdlbmQyJyxcbiAqICAgICAgICAgICAgIGRhdGE6IFs0MCwgNDAsIDYwXVxuICogICAgICAgICAgIH0sXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDMnLFxuICogICAgICAgICAgICAgZGF0YTogWzYwLCA1MCwgMTBdXG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBuYW1lOiAnTGVnZW5kNCcsXG4gKiAgICAgICAgICAgICBkYXRhOiBbODAsIDEwLCA3MF1cbiAqICAgICAgICAgICB9XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIGxpbmU6IFtcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBuYW1lOiAnTGVnZW5kNScsXG4gKiAgICAgICAgICAgICBkYXRhOiBbMSwgMiwgM11cbiAqICAgICAgICAgICB9XG4gKiAgICAgICAgIF1cbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIG9wdGlvbnMgPSB7XG4gKiAgICAgICBjaGFydDoge1xuICogICAgICAgICB0aXRsZTogJ0NvbWJvIENoYXJ0J1xuICogICAgICAgfSxcbiAqICAgICAgIHlBeGlzOltcbiAqICAgICAgICAge1xuICogICAgICAgICAgIHRpdGxlOiAnWSBBeGlzJyxcbiAqICAgICAgICAgICBjaGFydFR5cGU6ICdsaW5lJ1xuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgdGl0bGU6ICdZIFJpZ2h0IEF4aXMnXG4gKiAgICAgICAgIH1cbiAqICAgICAgIF0sXG4gKiAgICAgICB4QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1ggQXhpcydcbiAqICAgICAgIH0sXG4gKiAgICAgICBzZXJpZXM6IHtcbiAqICAgICAgICAgaGFzRG90OiB0cnVlXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5jb21ib0NoYXJ0KGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucyk7XG4gKi9cbnR1aS5jaGFydC5jb21ib0NoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jaGFydFR5cGUgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfQ09NQk87XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQaWUgY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7cmF3RGF0YX0gcmF3RGF0YSByYXcgZGF0YVxuICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEuc2VyaWVzIHNlcmllcyBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNoYXJ0IGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LndpZHRoIGNoYXJ0IHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC5oZWlnaHQgY2hhcnQgaGVpZ2h0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC50aXRsZSBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQuZm9ybWF0IHZhbHVlIGZvcm1hdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMgb3B0aW9ucyBvZiBzZXJpZXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0xhYmVsIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuaGFzU2VsZWN0aW9uIHdoZXRoZXIgaGFzIHNlbGVjdGlvbiBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSB0ZW1wbGF0ZSBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMubGVnZW5kIG9wdGlvbnMgb2YgbGVnZW5kXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sZWdlbmQuYWxpZ24gbGVnZW5kIGFsaWduICh0b3B8Ym90dG9tfGxlZnR8Y2VudGVyfG91dGVyKVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oYXNDaGVja2JveCB3aGV0aGVyIGhhcyBjaGVja2JveCBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubGVnZW5kLmhpZGRlbiB3aGV0aGVyIGhpZGRlbiBvciBub3RcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGhlbWUgdGhlbWUgbmFtZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIGdyYXBoIGxpYnJhcnkgdHlwZVxuICogQHJldHVybnMge29iamVjdH0gYmFyIGNoYXJ0XG4gKiBAYXBpXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXItaWQnKSxcbiAqICAgICByYXdEYXRhID0ge1xuICogICAgICAgc2VyaWVzOiBbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMScsXG4gKiAgICAgICAgICAgZGF0YTogMjBcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQyJyxcbiAqICAgICAgICAgICBkYXRhOiA0MFxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDMnLFxuICogICAgICAgICAgIGRhdGE6IDYwXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kNCcsXG4gKiAgICAgICAgICAgZGF0YTogODBcbiAqICAgICAgICAgfVxuICogICAgICAgXVxuICogICAgIH0sXG4gKiAgICAgb3B0aW9ucyA9IHtcbiAqICAgICAgIGNoYXJ0OiB7XG4gKiAgICAgICAgIHRpdGxlOiAnUGllIENoYXJ0J1xuICogICAgICAgfVxuICogICAgIH07XG4gKiB0dWkuY2hhcnQucGllQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbiAqL1xudHVpLmNoYXJ0LnBpZUNoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jaGFydFR5cGUgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfUElFO1xuICAgIHJldHVybiBfY3JlYXRlQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogTWFwIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge3Jhd0RhdGF9IHJhd0RhdGEgY2hhcnQgZGF0YVxuICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEuc2VyaWVzIHNlcmllcyBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNoYXJ0IGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LndpZHRoIGNoYXJ0IHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC5oZWlnaHQgY2hhcnQgaGVpZ2h0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC50aXRsZSBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQuZm9ybWF0IHZhbHVlIGZvcm1hdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMgb3B0aW9ucyBvZiBzZXJpZXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0xhYmVsIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSB0ZW1wbGF0ZSBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMubGVnZW5kIG9wdGlvbnMgb2YgbGVnZW5kXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sZWdlbmQuYWxpZ24gbGVnZW5kIGFsaWduICh0b3B8Ym90dG9tfGxlZnR8Y2VudGVyfG91dGVyKVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aGVtZSB0aGVtZSBuYW1lXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1hcCBtYXAgdHlwZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIGdyYXBoIGxpYnJhcnkgdHlwZVxuICogQHJldHVybnMge29iamVjdH0gYmFyIGNoYXJ0XG4gKiBAYXBpXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXItaWQnKSxcbiAqICAgICByYXdEYXRhID0ge1xuICogICAgICAgc2VyaWVzOiBbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBjb2RlOiAnS1InLFxuICogICAgICAgICAgIGRhdGE6IDEwMCxcbiAqICAgICAgICAgICBsYWJlbENvb3JkaW5hdGU6IHtcbiAqICAgICAgICAgICAgIHg6IDAuNixcbiAqICAgICAgICAgICAgIHk6IDAuN1xuICogICAgICAgICAgIH1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIGNvZGU6ICdKUCcsXG4gKiAgICAgICAgICAgZGF0YTogNTBcbiAqICAgICAgICAgfVxuICogICAgICAgXVxuICogICAgIH0sXG4gKiAgICAgb3B0aW9ucyA9IHtcbiAqICAgICAgIGNoYXJ0OiB7XG4gKiAgICAgICAgIHRpdGxlOiAnTWFwIENoYXJ0J1xuICogICAgICAgfSxcbiAqICAgICAgIG1hcDogJ3dvcmxkJ1xuICogICAgIH07XG4gKiB0dWkuY2hhcnQubWFwQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbiAqL1xudHVpLmNoYXJ0Lm1hcENoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jaGFydFR5cGUgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfTUFQO1xuICAgIG9wdGlvbnMubWFwID0gbWFwRmFjdG9yeS5nZXQob3B0aW9ucy5tYXApO1xuXG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGVtZS5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGVtZU5hbWUgdGhlbWUgbmFtZVxuICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGFwcGxpY2F0aW9uIGNoYXJ0IHRoZW1lXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS5jaGFydCBjaGFydCB0aGVtZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLmNoYXJ0LmZvbnRGYW1pbHkgZm9udCBmYW1pbHkgb2YgY2hhcnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5jaGFydC5iYWNrZ3JvdW5kIGJhY2tncm91bmQgb2YgY2hhcnRcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnRpdGxlIGNoYXJ0IHRoZW1lXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gdGhlbWUudGl0bGUuZm9udFNpemUgZm9udCBzaXplIG9mIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUudGl0bGUuZm9udEZhbWlseSBmb250IGZhbWlseSBvZiBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnRpdGxlLmNvbG9yIGZvbnQgY29sb3Igb2YgY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS50aXRsZS5iYWNrZ3JvdW5kIGJhY2tncm91bmQgb2YgY2hhcnQgdGl0bGVcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnlBeGlzIHRoZW1lIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS55QXhpcy50aXRsZSB0aGVtZSBvZiB2ZXJ0aWNhbCBheGlzIHRpdGxlXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IHRoZW1lLnlBeGlzLnRpdGxlLmZvbnRTaXplIGZvbnQgc2l6ZSBvZiB2ZXJ0aWNhbCBheGlzIHRpdGxlXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnlBeGlzLnRpdGxlLmZvbnRGYW1pbHkgZm9udCBmYW1pbHkgb2YgdmVydGljYWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS55QXhpcy50aXRsZS5jb2xvciBmb250IGNvbG9yIG9mIHZlcnRpY2FsIGF4aXMgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS55QXhpcy5sYWJlbCB0aGVtZSBvZiB2ZXJ0aWNhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IHRoZW1lLnlBeGlzLmxhYmVsLmZvbnRTaXplIGZvbnQgc2l6ZSBvZiB2ZXJ0aWNhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnlBeGlzLmxhYmVsLmZvbnRGYW1pbHkgZm9udCBmYW1pbHkgb2YgdmVydGljYWwgYXhpcyBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS55QXhpcy5sYWJlbC5jb2xvciBmb250IGNvbG9yIG9mIHZlcnRpY2FsIGF4aXMgbGFiZWxcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS55QXhpcy50aWNrQ29sb3IgY29sb3Igb2YgdmVydGljYWwgYXhpcyB0aWNrXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS54QXhpcyB0aGVtZSBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS54QXhpcy50aXRsZSB0aGVtZSBvZiBob3Jpem9udGFsIGF4aXMgdGl0bGVcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gdGhlbWUueEF4aXMudGl0bGUuZm9udFNpemUgZm9udCBzaXplIG9mIGhvcml6b250YWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS54QXhpcy50aXRsZS5mb250RmFtaWx5IGZvbnQgZmFtaWx5IG9mIGhvcml6b250YWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS54QXhpcy50aXRsZS5jb2xvciBmb250IGNvbG9yIG9mIGhvcml6b250YWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnhBeGlzLmxhYmVsIHRoZW1lIG9mIGhvcml6b250YWwgYXhpcyBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSB0aGVtZS54QXhpcy5sYWJlbC5mb250U2l6ZSBmb250IHNpemUgb2YgaG9yaXpvbnRhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnhBeGlzLmxhYmVsLmZvbnRGYW1pbHkgZm9udCBmYW1pbHkgb2YgaG9yaXpvbnRhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnhBeGlzLmxhYmVsLmNvbG9yIGZvbnQgY29sb3Igb2YgaG9yaXpvbnRhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUueEF4aXMudGlja0NvbG9yIGNvbG9yIG9mIGhvcml6b250YWwgYXhpcyB0aWNrXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS5wbG90IHBsb3QgdGhlbWVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5wbG90LmxpbmVDb2xvciBwbG90IGxpbmUgY29sb3JcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5wbG90LmJhY2tncm91bmQgcGxvdCBiYWNrZ3JvdW5kXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS5zZXJpZXMgc2VyaWVzIHRoZW1lXG4gKiAgICAgICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSB0aGVtZS5zZXJpZXMuY29sb3JzIHNlcmllcyBjb2xvcnNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5zZXJpZXMuYm9yZGVyQ29sb3Igc2VyaWVzIGJvcmRlciBjb2xvclxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnNlcmllcy5zZWxlY3Rpb25Db2xvciBzZXJpZXMgc2VsZWN0aW9uIGNvbG9yXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUuc2VyaWVzLnN0YXJ0Q29sb3Igc3RhcnQgY29sb3IgZm9yIG1hcCBjaGFydFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnNlcmllcy5lbmRDb2xvciBlbmQgY29sb3IgZm9yIG1hcCBjaGFydFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnNlcmllcy5vdmVyQ29sb3IgZW5kIGNvbG9yIGZvciBtYXAgY2hhcnRcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLmxlZ2VuZCBsZWdlbmQgdGhlbWVcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS5sZWdlbmQubGFiZWwgdGhlbWUgb2YgbGVnZW5kIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IHRoZW1lLmxlZ2VuZC5sYWJlbC5mb250U2l6ZSBmb250IHNpemUgb2YgbGVnZW5kIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLmxlZ2VuZC5sYWJlbC5mb250RmFtaWx5IGZvbnQgZmFtaWx5IG9mIGxlZ2VuZCBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5sZWdlbmQubGFiZWwuY29sb3IgZm9udCBjb2xvciBvZiBsZWdlbmQgbGFiZWxcbiAqIEBhcGlcbiAqIEBleGFtcGxlXG4gKiB2YXIgdGhlbWUgPSB7XG4gKiAgIHlBeGlzOiB7XG4gKiAgICAgdGlja0NvbG9yOiAnI2NjYmQ5YScsXG4gKiAgICAgICB0aXRsZToge1xuICogICAgICAgICBjb2xvcjogJyMzMzMzMzMnXG4gKiAgICAgICB9LFxuICogICAgICAgbGFiZWw6IHtcbiAqICAgICAgICAgY29sb3I6ICcjNmY0OTFkJ1xuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAgeEF4aXM6IHtcbiAqICAgICAgIHRpY2tDb2xvcjogJyNjY2JkOWEnLFxuICogICAgICAgdGl0bGU6IHtcbiAqICAgICAgICAgY29sb3I6ICcjMzMzMzMzJ1xuICogICAgICAgfSxcbiAqICAgICAgIGxhYmVsOiB7XG4gKiAgICAgICAgIGNvbG9yOiAnIzZmNDkxZCdcbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHBsb3Q6IHtcbiAqICAgICAgIGxpbmVDb2xvcjogJyNlNWRiYzQnLFxuICogICAgICAgYmFja2dyb3VuZDogJyNmNmYxZTUnXG4gKiAgICAgfSxcbiAqICAgICBzZXJpZXM6IHtcbiAqICAgICAgIGNvbG9yczogWycjNDBhYmI0JywgJyNlNzhhMzEnLCAnI2MxYzQ1MicsICcjNzk1MjI0JywgJyNmNWY1ZjUnXSxcbiAqICAgICAgIGJvcmRlckNvbG9yOiAnIzhlNjUzNScsXG4gKiAgICAgICBzZWxlY3Rpb25Db2xvcjogJyNjY2NjY2MnLFxuICogICAgICAgc3RhcnRDb2xvcjogJyNlZmVmZWYnLFxuICogICAgICAgZW5kQ29sb3I6ICdibHVlJyxcbiAqICAgICAgIG92ZXJDb2xvcjogJ3llbGxvdydcbiAqICAgICB9LFxuICogICAgIGxlZ2VuZDoge1xuICogICAgICAgbGFiZWw6IHtcbiAqICAgICAgICAgY29sb3I6ICcjNmY0OTFkJ1xuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfTtcbiAqIHR1aS5jaGFydC5yZWdpc3RlclRoZW1lKCduZXdUaGVtZScsIHRoZW1lKTtcbiAqL1xudHVpLmNoYXJ0LnJlZ2lzdGVyVGhlbWUgPSBmdW5jdGlvbih0aGVtZU5hbWUsIHRoZW1lKSB7XG4gICAgdGhlbWVGYWN0b3J5LnJlZ2lzdGVyKHRoZW1lTmFtZSwgdGhlbWUpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBtYXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFwTmFtZSBtYXAgbmFtZVxuICogQHBhcmFtIHtBcnJheS48e2NvZGU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmd9Pn0gZGF0YSBtYXAgZGF0YVxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBkYXRhID0gW1xuICogICB7XG4gKiAgICAgY29kZTogJ0tSJyxcbiAqICAgICBuYW1lOiAnU291dGggS29yZWEnLFxuICogICAgIHBhdGg6ICdNODM1LjEzLDM0Ni41M0w4MzcuNTUsMzUwLjcxLi4uJyxcbiAqICAgICBsYWJlbENvb3JkaW5hdGU6IHtcbiAqICAgICAgIHg6IDAuNixcbiAqICAgICAgIHk6IDAuN1xuICogICAgIH1cbiAqICAgfSxcbiAqICAgLy8uLi5cbiAqIF07XG4gKiB0dWkuY2hhcnQucmVnaXN0ZXJNYXAoJ25ld01hcCcsIGRhdGEpO1xuICovXG50dWkuY2hhcnQucmVnaXN0ZXJNYXAgPSBmdW5jdGlvbihtYXBOYW1lLCBkYXRhKSB7XG4gICAgbWFwRmFjdG9yeS5yZWdpc3RlcihtYXBOYW1lLCBkYXRhKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgZ3JhcGggcGx1Z2luLlxuICogQG1lbWJlck9mIHR1aS5jaGFydFxuICogQHBhcmFtIHtzdHJpbmd9IGxpYlR5cGUgdHlwZSBvZiBncmFwaCBsaWJyYXJ5XG4gKiBAcGFyYW0ge29iamVjdH0gcGx1Z2luIHBsdWdpbiB0byBjb250cm9sIGxpYnJhcnlcbiAqIEBleGFtcGxlXG4gKiB2YXIgcGx1Z2luUmFwaGFlbCA9IHtcbiAqICAgYmFyOiBmdW5jdGlvbigpIHt9IC8vIFJlbmRlciBjbGFzc1xuICogfTtcbiAqIHR1aS5jaGFydC5yZWdpc3RlclBsdWdpbigncmFwaGFlbCcsIHBsdWdpblJhcGhhZWwpO1xuICovXG50dWkuY2hhcnQucmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbihsaWJUeXBlLCBwbHVnaW4pIHtcbiAgICBwbHVnaW5GYWN0b3J5LnJlZ2lzdGVyKGxpYlR5cGUsIHBsdWdpbik7XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFyZWEgY2hhcnRcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyksXG4gICAgbGluZVR5cGVNaXhlciA9IHJlcXVpcmUoJy4vbGluZVR5cGVNaXhlcicpLFxuICAgIGF4aXNUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2F4aXNUeXBlTWl4ZXInKSxcbiAgICByYXdEYXRhSGFuZGxlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmF3RGF0YUhhbmRsZXInKSxcbiAgICBTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvYXJlYUNoYXJ0U2VyaWVzJyk7XG5cbnZhciBBcmVhQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDaGFydEJhc2UsIC8qKiBAbGVuZHMgTGluZUNoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogY2xhc3NOYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBjbGFzc05hbWU6ICd0dWktYXJlYS1jaGFydCcsXG5cbiAgICAvKipcbiAgICAgKiBTZXJpZXMgY2xhc3NcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgU2VyaWVzOiBTZXJpZXMsXG5cbiAgICAvKipcbiAgICAgKiBBcmVhIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIEFyZWFDaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAbWl4ZXMgYXhpc1R5cGVNaXhlclxuICAgICAqIEBtaXhlcyBsaW5lVHlwZU1peGVyXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmF3RGF0YUhhbmRsZXIucmVtb3ZlU2VyaWVzU3RhY2socmF3RGF0YS5zZXJpZXMpO1xuICAgICAgICB0aGlzLl9saW5lVHlwZUluaXQocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpO1xuICAgIH1cbn0pO1xuXG5heGlzVHlwZU1peGVyLm1peGluKEFyZWFDaGFydCk7XG5saW5lVHlwZU1peGVyLm1peGluKEFyZWFDaGFydCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJlYUNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGF4aXNUeXBlTWl4ZXIgaXMgbWl4ZXIgb2YgYXhpcyB0eXBlIGNoYXJ0KGJhciwgY29sdW1uLCBsaW5lLCBhcmVhKS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpLFxuICAgIEF4aXMgPSByZXF1aXJlKCcuLi9heGVzL2F4aXMnKSxcbiAgICBQbG90ID0gcmVxdWlyZSgnLi4vcGxvdHMvcGxvdCcpLFxuICAgIExlZ2VuZCA9IHJlcXVpcmUoJy4uL2xlZ2VuZHMvbGVnZW5kJyksXG4gICAgR3JvdXBUeXBlQ3VzdG9tRXZlbnQgPSByZXF1aXJlKCcuLi9jdXN0b21FdmVudHMvZ3JvdXBUeXBlQ3VzdG9tRXZlbnQnKSxcbiAgICBCb3VuZHNUeXBlQ3VzdG9tRXZlbnQgPSByZXF1aXJlKCcuLi9jdXN0b21FdmVudHMvYm91bmRzVHlwZUN1c3RvbUV2ZW50JyksXG4gICAgVG9vbHRpcCA9IHJlcXVpcmUoJy4uL3Rvb2x0aXBzL3Rvb2x0aXAnKSxcbiAgICBHcm91cFRvb2x0aXAgPSByZXF1aXJlKCcuLi90b29sdGlwcy9ncm91cFRvb2x0aXAnKTtcblxuXG4vKipcbiAqIEF4aXMgbGltaXQgdmFsdWUuXG4gKiBAdHlwZWRlZiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGF4aXNMaW1pdFxuICovXG5cbi8qKlxuICogYXhpc1R5cGVNaXhlciBpcyBiYXNlIGNsYXNzIG9mIGF4aXMgdHlwZSBjaGFydChiYXIsIGNvbHVtbiwgbGluZSwgYXJlYSkuXG4gKiBAbWl4aW5cbiAqL1xudmFyIGF4aXNUeXBlTWl4ZXIgPSB7XG4gICAgLyoqXG4gICAgICogQWRkIGF4aXMgY29tcG9uZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBheGVzIGF4ZXMgb3B0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbGlnbmVkIHdoZXRoZXIgYWxpZ25lZCBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRBeGlzQ29tcG9uZW50czogZnVuY3Rpb24oYXhlcywgYWxpZ25lZCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2goYXhlcywgZnVuY3Rpb24oYXhpcykge1xuICAgICAgICAgICAgdmFyIGF4aXNQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYWxpZ25lZDogYWxpZ25lZCxcbiAgICAgICAgICAgICAgICBpc0xhYmVsOiAhIWF4aXMuaXNMYWJlbCxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGF4aXMuY2hhcnRUeXBlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoYXhpcy5uYW1lID09PSAncmlnaHRZQXhpcycpIHtcbiAgICAgICAgICAgICAgICBheGlzUGFyYW1zLmNvbXBvbmVudFR5cGUgPSAneUF4aXMnO1xuICAgICAgICAgICAgICAgIGF4aXNQYXJhbXMuaW5kZXggPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoYXhpcy5uYW1lLCBBeGlzLCBheGlzUGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBzZXJpZXMgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gc2VyaWVzZXMgc2VyaWVzZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbGlnbmVkIHdoZXRoZXIgYWxpZ25lZCBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRTZXJpZXNDb21wb25lbnRzOiBmdW5jdGlvbihzZXJpZXNlcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZXJpZXNCYXNlUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGxpYlR5cGU6IG9wdGlvbnMubGliVHlwZSxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IG9wdGlvbnMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogdGhpcy51c2VyRXZlbnQsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZTogJ3NlcmllcydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzUGFyYW1zID0gdHVpLnV0aWwuZXh0ZW5kKHNlcmllc0Jhc2VQYXJhbXMsIHNlcmllcy5kYXRhKTtcbiAgICAgICAgICAgIHNlbGYuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcihzZXJpZXMubmFtZSwgc2VyaWVzLlNlcmllc0NsYXNzLCBzZXJpZXNQYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHRvb2x0aXAgY29tcG9uZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkVG9vbHRpcENvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBUb29sdGlwQ2xhc3MgPSB0aGlzLmhhc0dyb3VwVG9vbHRpcCA/IEdyb3VwVG9vbHRpcCA6IFRvb2x0aXA7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcigndG9vbHRpcCcsIFRvb2x0aXBDbGFzcywgdGhpcy5fbWFrZVRvb2x0aXBEYXRhKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgbGVnZW5kIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIHNlcmllcyBjaGFydCB0eXBlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnRUeXBlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGxlZ2VuZE9wdGlvbnMgbGVnZW5kIG9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRMZWdlbmRDb21wb25lbnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZXMsIGNoYXJ0VHlwZSwgbGVnZW5kT3B0aW9ucykge1xuICAgICAgICBpZiAoIWxlZ2VuZE9wdGlvbnMgfHwgIWxlZ2VuZE9wdGlvbnMuaGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2xlZ2VuZCcsIExlZ2VuZCwge1xuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZXM6IGNoYXJ0VHlwZXMsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiB0aGlzLnVzZXJFdmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHMgZm9yIGF4aXMgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYXhlcyBheGVzIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMucGxvdERhdGEgcGxvdCBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBwYXJhbXMuc2VyaWVzZXMgc2VyaWVzZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzRm9yQXhpc1R5cGU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGFsaWduZWQgPSAhIXBhcmFtcy5hbGlnbmVkO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcigncGxvdCcsIFBsb3QpO1xuICAgICAgICB0aGlzLl9hZGRBeGlzQ29tcG9uZW50cyhwYXJhbXMuYXhlcywgYWxpZ25lZCk7XG4gICAgICAgIHRoaXMuX2FkZExlZ2VuZENvbXBvbmVudChwYXJhbXMuc2VyaWVzQ2hhcnRUeXBlcywgcGFyYW1zLmNoYXJ0VHlwZSwgdGhpcy5vcHRpb25zLmxlZ2VuZCk7XG4gICAgICAgIHRoaXMuX2FkZFNlcmllc0NvbXBvbmVudHMocGFyYW1zLnNlcmllc2VzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fYWRkVG9vbHRpcENvbXBvbmVudChvcHRpb25zLmNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBsaW1pdCBtYXAuXG4gICAgICogQHBhcmFtIHt7eUF4aXM6IG9iamVjdCwgeEF4aXM6IG9iamVjdH19IGF4ZXNEYXRhIGF4ZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNoYXJ0VHlwZXMgY2hhcnQgdHlwZXNcbiAgICAgKiBAcmV0dXJucyB7e2NvbHVtbjogP2F4aXNMaW1pdCwgbGluZTogP2F4aXNMaW1pdH19IGxpbWl0IG1hcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbWl0TWFwOiBmdW5jdGlvbihheGVzRGF0YSwgY2hhcnRUeXBlcykge1xuICAgICAgICB2YXIgbGltaXRNYXAgPSB7fSxcbiAgICAgICAgICAgIHlBeGlzTGltaXQgPSBheGVzRGF0YS55QXhpcyA/IGF4ZXNEYXRhLnlBeGlzLmxpbWl0IDogYXhlc0RhdGEucmlnaHRZQXhpcy5saW1pdDtcblxuICAgICAgICBsaW1pdE1hcFtjaGFydFR5cGVzWzBdXSA9IHRoaXMuaXNWZXJ0aWNhbCA/IHlBeGlzTGltaXQgOiBheGVzRGF0YS54QXhpcy5saW1pdDtcblxuICAgICAgICBpZiAoY2hhcnRUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsaW1pdE1hcFtjaGFydFR5cGVzWzFdXSA9IGF4ZXNEYXRhLnJpZ2h0WUF4aXMgPyBheGVzRGF0YS5yaWdodFlBeGlzLmxpbWl0IDogeUF4aXNMaW1pdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW1pdE1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YSBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7e3lBeGlzOiBvYmplY3QsIHhBeGlzOiBvYmplY3R9fSBheGVzRGF0YSBheGVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIGNoYXJ0IHR5cGVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YUZvclJlbmRlcmluZzogZnVuY3Rpb24oYXhlc0RhdGEsIGNoYXJ0VHlwZXMpIHtcbiAgICAgICAgdmFyIGxpbWl0TWFwID0gdGhpcy5fZ2V0TGltaXRNYXAoYXhlc0RhdGEsIGNoYXJ0VHlwZXMpLFxuICAgICAgICAgICAgYWxpZ25lZCA9IGF4ZXNEYXRhLnhBeGlzLmFsaWduZWQsXG4gICAgICAgICAgICBzZXJpZXNEYXRhID0ge307XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgc2VyaWVzRGF0YVtjaGFydFR5cGUgKyAnU2VyaWVzJ10gPSB7XG4gICAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0TWFwW2NoYXJ0VHlwZV0sXG4gICAgICAgICAgICAgICAgYWxpZ25lZDogYWxpZ25lZCxcbiAgICAgICAgICAgICAgICBoYXNBeGVzOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2FkZERhdGFSYXRpb3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBheGVzRGF0YSA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0QXhlc0RhdGEoKTtcbiAgICAgICAgdmFyIGNoYXJ0VHlwZXMgPSB0aGlzLmNoYXJ0VHlwZXMgfHwgW3RoaXMuY2hhcnRUeXBlXTtcbiAgICAgICAgdmFyIGxpbWl0TWFwID0gdGhpcy5fZ2V0TGltaXRNYXAoYXhlc0RhdGEsIGNoYXJ0VHlwZXMpO1xuICAgICAgICB2YXIgc3RhY2tlZE9wdGlvbiA9IHRoaXMub3B0aW9ucy5zZXJpZXMgJiYgdGhpcy5vcHRpb25zLnNlcmllcy5zdGFja2VkO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjaGFydFR5cGVzLCBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgICAgIHNlbGYuZGF0YVByb2Nlc3Nvci5hZGREYXRhUmF0aW9zKGxpbWl0TWFwW2NoYXJ0VHlwZV0sIHN0YWNrZWRPcHRpb24sIGNoYXJ0VHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJlbmRlcmluZyBkYXRhIGZvciBheGlzIHR5cGUgY2hhcnQuXG4gICAgICogQHJldHVybnMge29iamVjdH0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZVJlbmRlcmluZ0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXhlc0RhdGEgPSB0aGlzLmJvdW5kc01ha2VyLmdldEF4ZXNEYXRhKCk7XG4gICAgICAgIHZhciBvcHRpb25DaGFydFR5cGVzID0gdGhpcy5jaGFydFR5cGVzIHx8IFt0aGlzLmNoYXJ0VHlwZV07XG4gICAgICAgIHZhciBzZXJpZXNEYXRhID0gdGhpcy5fbWFrZVNlcmllc0RhdGFGb3JSZW5kZXJpbmcoYXhlc0RhdGEsIG9wdGlvbkNoYXJ0VHlwZXMsIHRoaXMuaXNWZXJ0aWNhbCk7XG4gICAgICAgIHZhciB5QXhpcyA9IGF4ZXNEYXRhLnlBeGlzID8gYXhlc0RhdGEueUF4aXMgOiBheGVzRGF0YS5yaWdodFlBeGlzO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgcGxvdDoge1xuICAgICAgICAgICAgICAgIHZUaWNrQ291bnQ6IHlBeGlzLnZhbGlkVGlja0NvdW50LFxuICAgICAgICAgICAgICAgIGhUaWNrQ291bnQ6IGF4ZXNEYXRhLnhBeGlzLnZhbGlkVGlja0NvdW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VzdG9tRXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB0aWNrQ291bnQ6IHRoaXMuaXNWZXJ0aWNhbCA/IGF4ZXNEYXRhLnhBeGlzLnRpY2tDb3VudCA6IHlBeGlzLnRpY2tDb3VudFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNEYXRhLCBheGVzRGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBncm91cGVkIGV2ZW50IGhhbmRsZXIgbGF5ZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfYWRkQ3VzdG9tRXZlbnRDb21wb25lbnRGb3JHcm91cFRvb2x0aXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2N1c3RvbUV2ZW50JywgR3JvdXBUeXBlQ3VzdG9tRXZlbnQsIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0aGlzLmlzVmVydGljYWxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjdXN0b20gZXZlbnQgY29tcG9uZW50IGZvciBub3JtYWwgdG9vbHRpcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDdXN0b21FdmVudENvbXBvbmVudEZvck5vcm1hbFRvb2x0aXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2N1c3RvbUV2ZW50JywgQm91bmRzVHlwZUN1c3RvbUV2ZW50LCB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDdXN0b21FdmVudENvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0dyb3VwVG9vbHRpcCkge1xuICAgICAgICAgICAgdGhpcy5fYWRkQ3VzdG9tRXZlbnRDb21wb25lbnRGb3JHcm91cFRvb2x0aXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50Rm9yTm9ybWFsVG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBjb29yZGluYXRlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Q3VzdG9tRXZlbnR9IGN1c3RvbUV2ZW50IGN1c3RvbSBldmVudCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1Rvb2x0aXB9IHRvb2x0aXAgdG9vbHRpcCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxTZXJpZXM+fSBzZXJpZXNlcyBzZXJpZXMgY29tcG9uZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50Rm9yR3JvdXBUb29sdGlwOiBmdW5jdGlvbihjdXN0b21FdmVudCwgdG9vbHRpcCwgc2VyaWVzZXMpIHtcbiAgICAgICAgY3VzdG9tRXZlbnQub24oJ3Nob3dHcm91cFRvb2x0aXAnLCB0b29sdGlwLm9uU2hvdywgdG9vbHRpcCk7XG4gICAgICAgIGN1c3RvbUV2ZW50Lm9uKCdoaWRlR3JvdXBUb29sdGlwJywgdG9vbHRpcC5vbkhpZGUsIHRvb2x0aXApO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2goc2VyaWVzZXMsIGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgaWYgKHNlcmllcy5vblNob3dHcm91cFRvb2x0aXBMaW5lKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5vbignc2hvd0dyb3VwVG9vbHRpcExpbmUnLCBzZXJpZXMub25TaG93R3JvdXBUb29sdGlwTGluZSwgc2VyaWVzKTtcbiAgICAgICAgICAgICAgICB0b29sdGlwLm9uKCdoaWRlR3JvdXBUb29sdGlwTGluZScsIHNlcmllcy5vbkhpZGVHcm91cFRvb2x0aXBMaW5lLCBzZXJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9vbHRpcC5vbignc2hvd0dyb3VwQW5pbWF0aW9uJywgc2VyaWVzLm9uU2hvd0dyb3VwQW5pbWF0aW9uLCBzZXJpZXMpO1xuICAgICAgICAgICAgdG9vbHRpcC5vbignaGlkZUdyb3VwQW5pbWF0aW9uJywgc2VyaWVzLm9uSGlkZUdyb3VwQW5pbWF0aW9uLCBzZXJpZXMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGN1c3RvbSBldmVudCBmb3Igbm9ybWFsIHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtDdXN0b21FdmVudH0gY3VzdG9tRXZlbnQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7VG9vbHRpcH0gdG9vbHRpcCB0b29sdGlwIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFNlcmllcz59IHNlcmllc2VzIHNlcmllcyBjb21wb25lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXR0YWNoQ3VzdG9tRXZlbnRGb3JOb3JtYWxUb29sdGlwOiBmdW5jdGlvbihjdXN0b21FdmVudCwgdG9vbHRpcCwgc2VyaWVzZXMpIHtcbiAgICAgICAgY3VzdG9tRXZlbnQub24oJ3Nob3dUb29sdGlwJywgdG9vbHRpcC5vblNob3csIHRvb2x0aXApO1xuICAgICAgICBjdXN0b21FdmVudC5vbignaGlkZVRvb2x0aXAnLCB0b29sdGlwLm9uSGlkZSwgdG9vbHRpcCk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICB2YXIgc2hvd0FuaW1hdGlvbkV2ZW50TmFtZSwgaGlkZUFuaW1hdGlvbkV2ZW50TmFtZTtcblxuICAgICAgICAgICAgaWYgKHNlcmllcy5vblNob3dBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzaG93QW5pbWF0aW9uRXZlbnROYW1lID0gcmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzaG93Jywgc2VyaWVzLmNoYXJ0VHlwZSwgJ2FuaW1hdGlvbicpO1xuICAgICAgICAgICAgICAgIGhpZGVBbmltYXRpb25FdmVudE5hbWUgPSByZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ2hpZGUnLCBzZXJpZXMuY2hhcnRUeXBlLCAnYW5pbWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5vbihzaG93QW5pbWF0aW9uRXZlbnROYW1lLCBzZXJpZXMub25TaG93QW5pbWF0aW9uLCBzZXJpZXMpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAub24oaGlkZUFuaW1hdGlvbkV2ZW50TmFtZSwgc2VyaWVzLm9uSGlkZUFuaW1hdGlvbiwgc2VyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBjdXN0b20gZXZlbnQgZm9yIHNlcmllcyBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtDdXN0b21FdmVudH0gY3VzdG9tRXZlbnQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFNlcmllcz59IHNlcmllc2VzIHNlcmllcyBjb21wb25lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXR0YWNoQ3VzdG9tRXZlbnRGb3JTZXJpZXNTZWxlY3Rpb246IGZ1bmN0aW9uKGN1c3RvbUV2ZW50LCBzZXJpZXNlcykge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHNlcmllc2VzLCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RTZXJpZXNFdmVudE5hbWUgPSByZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ3NlbGVjdCcsIHNlcmllcy5jaGFydFR5cGUsICdzZXJpZXMnKSxcbiAgICAgICAgICAgICAgICB1bnNlbGVjdFNlcmllc0V2ZW50TmFtZSA9IHJlbmRlclV0aWwubWFrZUN1c3RvbUV2ZW50TmFtZSgndW5zZWxlY3QnLCBzZXJpZXMuY2hhcnRUeXBlLCAnc2VyaWVzJyk7XG5cbiAgICAgICAgICAgIGN1c3RvbUV2ZW50Lm9uKHNlbGVjdFNlcmllc0V2ZW50TmFtZSwgc2VyaWVzLm9uU2VsZWN0U2VyaWVzLCBzZXJpZXMpO1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQub24odW5zZWxlY3RTZXJpZXNFdmVudE5hbWUsIHNlcmllcy5vblVuc2VsZWN0U2VyaWVzLCBzZXJpZXMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGN1c3RvbSBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9hdHRhY2hDdXN0b21FdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNlcyA9IHRoaXMuY29tcG9uZW50TWFuYWdlci53aGVyZSh7Y29tcG9uZW50VHlwZTogJ3Nlcmllcyd9KSxcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnY3VzdG9tRXZlbnQnKSxcbiAgICAgICAgICAgIHRvb2x0aXAgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCd0b29sdGlwJyk7XG5cbiAgICAgICAgQ2hhcnRCYXNlLnByb3RvdHlwZS5fYXR0YWNoQ3VzdG9tRXZlbnQuY2FsbCh0aGlzLCBzZXJpZXNlcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzR3JvdXBUb29sdGlwKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hDdXN0b21FdmVudEZvckdyb3VwVG9vbHRpcChjdXN0b21FdmVudCwgdG9vbHRpcCwgc2VyaWVzZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoQ3VzdG9tRXZlbnRGb3JOb3JtYWxUb29sdGlwKGN1c3RvbUV2ZW50LCB0b29sdGlwLCBzZXJpZXNlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hdHRhY2hDdXN0b21FdmVudEZvclNlcmllc1NlbGVjdGlvbihjdXN0b21FdmVudCwgc2VyaWVzZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXggaW4uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyB0YXJnZXQgZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgbWl4aW46IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKGZ1bmMucHJvdG90eXBlLCB0aGlzKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aXNUeXBlTWl4ZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmFyIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2hhcnRCYXNlID0gcmVxdWlyZSgnLi9jaGFydEJhc2UnKSxcbiAgICBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBheGlzVHlwZU1peGVyID0gcmVxdWlyZSgnLi9heGlzVHlwZU1peGVyJyksXG4gICAgYmFyVHlwZU1peGVyID0gcmVxdWlyZSgnLi9iYXJUeXBlTWl4ZXInKSxcbiAgICBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpLFxuICAgIGF4aXNEYXRhTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2F4aXNEYXRhTWFrZXInKSxcbiAgICBTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvYmFyQ2hhcnRTZXJpZXMnKTtcblxudmFyIEJhckNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIEJhckNoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQmFyIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIEJhckNoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQG1peGVzIGF4aXNUeXBlTWl4ZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsYXNzTmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWJhci1jaGFydCc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgaGFzIHJpZ2h0IHkgYXhpcyBvciBub3QuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNSaWdodFlBeGlzID0gZmFsc2U7XG5cbiAgICAgICAgb3B0aW9ucy55QXhpcyA9IG9wdGlvbnMueUF4aXMgfHwge307XG4gICAgICAgIG9wdGlvbnMueEF4aXMgPSBvcHRpb25zLnhBeGlzIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnBsb3QgPSBvcHRpb25zLnBsb3QgfHwge307XG4gICAgICAgIG9wdGlvbnMuc2VyaWVzID0gb3B0aW9ucy5zZXJpZXMgfHwge307XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc1ZhbGlkU3RhY2tlZE9wdGlvbihvcHRpb25zLnNlcmllcy5zdGFja2VkKSkge1xuICAgICAgICAgICAgcmF3RGF0YS5zZXJpZXMgPSB0aGlzLl9zb3J0UmF3U2VyaWVzRGF0YShyYXdEYXRhLnNlcmllcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMuZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICByYXdEYXRhLnNlcmllcyA9IHRoaXMuX21ha2VSYXdTZXJpZXNEYXRhRm9yRGl2ZXJnaW5nKHJhd0RhdGEuc2VyaWVzLCBvcHRpb25zLnNlcmllcy5zdGFja2VkKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpdmVyZ2luZ09wdGlvbihvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIENoYXJ0QmFzZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIHJhd0RhdGE6IHJhd0RhdGEsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgaGFzQXhlczogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzKG9wdGlvbnMuY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIG9wdGlvbnMgZm9yIGRpdmVyZ2luZyBvcHRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZURpdmVyZ2luZ09wdGlvbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgaXNDZW50ZXI7XG5cbiAgICAgICAgb3B0aW9ucy5zZXJpZXMuc3RhY2tlZCA9IG9wdGlvbnMuc2VyaWVzLnN0YWNrZWQgfHwgY2hhcnRDb25zdC5TVEFDS0VEX05PUk1BTF9UWVBFO1xuICAgICAgICB0aGlzLmhhc1JpZ2h0WUF4aXMgPSB0dWkudXRpbC5pc0FycmF5KG9wdGlvbnMueUF4aXMpICYmIG9wdGlvbnMueUF4aXMubGVuZ3RoID4gMTtcblxuICAgICAgICBpc0NlbnRlciA9IHByZWRpY2F0ZS5pc1lBeGlzQWxpZ25DZW50ZXIodGhpcy5oYXNSaWdodFlBeGlzLCBvcHRpb25zLnlBeGlzLmFsaWduKTtcblxuICAgICAgICBvcHRpb25zLnlBeGlzLmlzQ2VudGVyID0gaXNDZW50ZXI7XG4gICAgICAgIG9wdGlvbnMueEF4aXMuZGl2aWRlZCA9IGlzQ2VudGVyO1xuICAgICAgICBvcHRpb25zLnNlcmllcy5kaXZpZGVkID0gaXNDZW50ZXI7XG4gICAgICAgIG9wdGlvbnMucGxvdC5kaXZpZGVkID0gaXNDZW50ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYXhlcyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvdW5kcyBjaGFydCBib3VuZHNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBheGVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhlc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXhpc1NjYWxlTWFrZXIgPSB0aGlzLl9jcmVhdGVBeGlzU2NhbGVNYWtlcih7XG4gICAgICAgICAgICAgICAgbWluOiB0aGlzLm9wdGlvbnMueEF4aXMubWluLFxuICAgICAgICAgICAgICAgIG1heDogdGhpcy5vcHRpb25zLnhBeGlzLm1heFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGFyZWFUeXBlOiAneEF4aXMnXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHhBeGlzRGF0YSA9IGF4aXNEYXRhTWFrZXIubWFrZVZhbHVlQXhpc0RhdGEoe1xuICAgICAgICAgICAgICAgIGF4aXNTY2FsZU1ha2VyOiBheGlzU2NhbGVNYWtlclxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB5QXhpc0RhdGEgPSBheGlzRGF0YU1ha2VyLm1ha2VMYWJlbEF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICBsYWJlbHM6IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRDYXRlZ29yaWVzKCksXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBheGVzRGF0YSA9IHtcbiAgICAgICAgICAgICAgICB4QXhpczogeEF4aXNEYXRhLFxuICAgICAgICAgICAgICAgIHlBeGlzOiB5QXhpc0RhdGFcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzUmlnaHRZQXhpcykge1xuICAgICAgICAgICAgYXhlc0RhdGEucmlnaHRZQXhpcyA9IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgaXNQb3NpdGlvblJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9LCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHlBeGlzRGF0YSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBheGVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgdmFyIGF4ZXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3lBeGlzJyxcbiAgICAgICAgICAgICAgICBpc0xhYmVsOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4QXhpcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcblxuICAgICAgICBpZiAodGhpcy5oYXNSaWdodFlBeGlzKSB7XG4gICAgICAgICAgICBheGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdyaWdodFlBeGlzJyxcbiAgICAgICAgICAgICAgICBpc0xhYmU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHNGb3JBeGlzVHlwZSh7XG4gICAgICAgICAgICBheGVzOiBheGVzLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICBzZXJpZXNlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2JhclNlcmllcycsXG4gICAgICAgICAgICAgICAgICAgIFNlcmllc0NsYXNzOiBTZXJpZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjaGFuZ2Ugc2VsZWN0ZWQgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fSBjaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKi9cbiAgICBvbkNoYW5nZUNoZWNrZWRMZWdlbmRzOiBmdW5jdGlvbihjaGVja2VkTGVnZW5kcykge1xuICAgICAgICB2YXIgYm91bmRQYXJhbXM7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzUmlnaHRZQXhpcykge1xuICAgICAgICAgICAgYm91bmRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uQ2hhcnRUeXBlczogWydiYXInLCAnYmFyJ11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBDaGFydEJhc2UucHJvdG90eXBlLm9uQ2hhbmdlQ2hlY2tlZExlZ2VuZHMuY2FsbCh0aGlzLCBjaGVja2VkTGVnZW5kcywgbnVsbCwgYm91bmRQYXJhbXMpO1xuICAgIH1cbn0pO1xuXG5heGlzVHlwZU1peGVyLm1peGluKEJhckNoYXJ0KTtcbmJhclR5cGVNaXhlci5taXhpbihCYXJDaGFydCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFyQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYmFyVHlwZU1peGVyIGlzIG1peGVyIG9mIGJhciB0eXBlIGNoYXJ0KGJhciwgY29sdW1uKS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHJhd0RhdGFIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGVscGVycy9yYXdEYXRhSGFuZGxlcicpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG5cbi8qKlxuICogYmFyVHlwZU1peGVyIGlzIG1peGVyIG9mIGJhciB0eXBlIGNoYXJ0KGJhciwgY29sdW1uKS5cbiAqIEBtaXhpblxuICovXG52YXIgYmFyVHlwZU1peGVyID0ge1xuICAgIC8qKlxuICAgICAqIE1ha2UgbWludXMgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGEgbnVtYmVyIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IG1pbnVzIHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VNaW51c1ZhbHVlczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGRhdGEsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gMCA6IC12YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcGx1cyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YSBudW1iZXIgZGF0YVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGx1cyB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUGx1c1ZhbHVlczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGRhdGEsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gMCA6IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBub3JtYWwgZGl2ZXJnaW5nIHJhdyBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3tkYXRhOiBBcnJheS48bnVtYmVyPn19IHJhd1Nlcmllc0RhdGEgcmF3IHNlcmllcyBkYXRhXG4gICAgICogQHJldHVybnMge3tkYXRhOiBBcnJheS48bnVtYmVyPn19IGNoYW5nZWQgcmF3IHNlcmllcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU5vcm1hbERpdmVyZ2luZ1Jhd1Nlcmllc0RhdGE6IGZ1bmN0aW9uKHJhd1Nlcmllc0RhdGEpIHtcbiAgICAgICAgcmF3U2VyaWVzRGF0YS5sZW5ndGggPSBNYXRoLm1pbihyYXdTZXJpZXNEYXRhLmxlbmd0aCwgMik7XG5cbiAgICAgICAgcmF3U2VyaWVzRGF0YVswXS5kYXRhID0gdGhpcy5fbWFrZU1pbnVzVmFsdWVzKHJhd1Nlcmllc0RhdGFbMF0uZGF0YSk7XG5cbiAgICAgICAgaWYgKHJhd1Nlcmllc0RhdGFbMV0pIHtcbiAgICAgICAgICAgIHJhd1Nlcmllc0RhdGFbMV0uZGF0YSA9IHRoaXMuX21ha2VQbHVzVmFsdWVzKHJhd1Nlcmllc0RhdGFbMV0uZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmF3U2VyaWVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdGFja2VkIGRpdmVyZ2luZyByYXcgc2VyaWVzIGRhdGEuXG4gICAgICogQHBhcmFtIHt7ZGF0YTogQXJyYXkuPG51bWJlcj4sIHN0YWNrOiBzdHJpbmd9fSByYXdTZXJpZXNEYXRhIHJhdyBzZXJpZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHt7ZGF0YTogQXJyYXkuPG51bWJlcj59fSBjaGFuZ2VkIHJhdyBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTdGFja2VkRGl2ZXJnaW5nUmF3U2VyaWVzRGF0YTogZnVuY3Rpb24ocmF3U2VyaWVzRGF0YSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzdGFja3MgPSByYXdEYXRhSGFuZGxlci5waWNrU3RhY2tzKHJhd1Nlcmllc0RhdGEpLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBsZWZ0U3RhY2sgPSBzdGFja3NbMF0sXG4gICAgICAgICAgICByaWdodFN0YWNrID0gc3RhY2tzWzFdO1xuXG4gICAgICAgIHJhd1Nlcmllc0RhdGEgPSByYXdEYXRhSGFuZGxlci5zb3J0U2VyaWVzRGF0YShyYXdTZXJpZXNEYXRhLCBzdGFja3MpO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShyYXdTZXJpZXNEYXRhLCBmdW5jdGlvbihzZXJpZXNEYXR1bSkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gc2VyaWVzRGF0dW0uc3RhY2sgfHwgY2hhcnRDb25zdC5ERUZBVUxUX1NUQUNLO1xuICAgICAgICAgICAgaWYgKHN0YWNrID09PSBsZWZ0U3RhY2spIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNEYXR1bS5kYXRhID0gc2VsZi5fbWFrZU1pbnVzVmFsdWVzKHNlcmllc0RhdHVtLmRhdGEpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlcmllc0RhdHVtKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhY2sgPT09IHJpZ2h0U3RhY2spIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNEYXR1bS5kYXRhID0gc2VsZi5fbWFrZVBsdXNWYWx1ZXMoc2VyaWVzRGF0dW0uZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VyaWVzRGF0dW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSByYXcgc2VyaWVzIGRhdGEgZm9yIGRpdmVyZ2luZy5cbiAgICAgKiBAcGFyYW0ge3tkYXRhOiBBcnJheS48bnVtYmVyPiwgc3RhY2s6IHN0cmluZ319IHJhd1Nlcmllc0RhdGEgcmF3IHNlcmllcyBkYXRhXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBzdGFja2VkT3B0aW9uIHN0YWNrZWQgb3B0aW9uXG4gICAgICogQHJldHVybnMge3tkYXRhOiBBcnJheS48bnVtYmVyPn19IGNoYW5nZWQgcmF3IHNlcmllcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVJhd1Nlcmllc0RhdGFGb3JEaXZlcmdpbmc6IGZ1bmN0aW9uKHJhd1Nlcmllc0RhdGEsIHN0YWNrZWRPcHRpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc1ZhbGlkU3RhY2tlZE9wdGlvbihzdGFja2VkT3B0aW9uKSkge1xuICAgICAgICAgICAgcmF3U2VyaWVzRGF0YSA9IHRoaXMuX21ha2VTdGFja2VkRGl2ZXJnaW5nUmF3U2VyaWVzRGF0YShyYXdTZXJpZXNEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhd1Nlcmllc0RhdGEgPSB0aGlzLl9tYWtlTm9ybWFsRGl2ZXJnaW5nUmF3U2VyaWVzRGF0YShyYXdTZXJpZXNEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYXdTZXJpZXNEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTb3J0IHJhdyBzZXJpZXMgZGF0YSBmcm9tIHN0YWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7ZGF0YTogQXJyYXkuPG51bWJlcj4sIHN0YWNrOiBzdHJpbmd9Pn0gcmF3U2VyaWVzRGF0YSByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHtkYXRhOiBBcnJheS48bnVtYmVyPiwgc3RhY2s6IHN0cmluZ30+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NvcnRSYXdTZXJpZXNEYXRhOiBmdW5jdGlvbihyYXdTZXJpZXNEYXRhKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSByYXdEYXRhSGFuZGxlci5waWNrU3RhY2tzKHJhd1Nlcmllc0RhdGEpO1xuXG4gICAgICAgIHJldHVybiByYXdEYXRhSGFuZGxlci5zb3J0U2VyaWVzRGF0YShyYXdTZXJpZXNEYXRhLCBzdGFja3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXggaW4uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyB0YXJnZXQgZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgbWl4aW46IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKGZ1bmMucHJvdG90eXBlLCB0aGlzKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhclR5cGVNaXhlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBCdWJibGUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpO1xudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4uL3Nlcmllcy9idWJibGVDaGFydFNlcmllcycpO1xudmFyIENpcmNsZUxlZ2VuZCA9IHJlcXVpcmUoJy4uL2xlZ2VuZHMvY2lyY2xlTGVnZW5kJyk7XG52YXIgYXhpc1R5cGVNaXhlciA9IHJlcXVpcmUoJy4vYXhpc1R5cGVNaXhlcicpO1xudmFyIGF4aXNEYXRhTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2F4aXNEYXRhTWFrZXInKTtcbnZhciBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpO1xudmFyIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcbnZhciBTaW1wbGVDdXN0b21FdmVudCA9IHJlcXVpcmUoJy4uL2N1c3RvbUV2ZW50cy9zaW1wbGVDdXN0b21FdmVudCcpO1xuXG52YXIgQnViYmxlQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDaGFydEJhc2UsIC8qKiBAbGVuZHMgQnViYmxlQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBjbGFzc05hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogJ3R1aS1idWJibGUtY2hhcnQnLFxuICAgIC8qKlxuICAgICAqIEJ1YmJsZSBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBCdWJibGVDaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBtaXhlcyBheGlzVHlwZU1peGVyXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd0RhdGEsIHRoZW1lLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMudG9vbHRpcCA9IG9wdGlvbnMudG9vbHRpcCB8fCB7fTtcblxuICAgICAgICB0aGlzLmF4aXNTY2FsZU1ha2VyTWFwID0gbnVsbDtcblxuICAgICAgICBpZiAoIW9wdGlvbnMudG9vbHRpcC5hbGlnbikge1xuICAgICAgICAgICAgb3B0aW9ucy50b29sdGlwLmFsaWduID0gY2hhcnRDb25zdC5UT09MVElQX0RFRkFVTFRfQUxJR05fT1BUSU9OO1xuICAgICAgICB9XG5cbiAgICAgICAgQ2hhcnRCYXNlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgcmF3RGF0YTogcmF3RGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBoYXNBeGVzOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHMob3B0aW9ucy5jaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIGxpbWl0IGZyb20gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgdGl0bGU6IHN0cmluZ319IG9wdGlvbnMgLSBheGlzIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGlja0xpbWl0RnJvbU9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogb3B0aW9ucy5taW4sXG4gICAgICAgICAgICBtYXg6IG9wdGlvbnMubWF4XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBBeGlzU2NhbGVNYWtlciBmb3IgYnViYmxlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgdGl0bGU6IHN0cmluZ319IG9wdGlvbnMgLSBheGlzIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJlYVR5cGUgLSB0eXBlIG9mIGFyZWEgbGlrZSB4QXhpcywgeUF4aXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVUeXBlIC0gdHlwZSBvZiB2YWx1ZSBsaWtlIHgsIHksIHJcbiAgICAgKiBAcmV0dXJucyB7QXhpc1NjYWxlTWFrZXJ9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQXhpc1NjYWxlTWFrZXI6IGZ1bmN0aW9uKG9wdGlvbnMsIGFyZWFUeXBlLCB2YWx1ZVR5cGUpIHtcbiAgICAgICAgdmFyIGxpbWl0ID0gdGhpcy5fcGlja0xpbWl0RnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBhZGRpdGlvbmFsUGFyYW1zID0ge1xuICAgICAgICAgICAgYXJlYVR5cGU6IGFyZWFUeXBlLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiB2YWx1ZVR5cGVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ2hhcnRCYXNlLnByb3RvdHlwZS5fY3JlYXRlQXhpc1NjYWxlTWFrZXIuY2FsbCh0aGlzLCBsaW1pdCwgYWRkaXRpb25hbFBhcmFtcywgdGhpcy5jaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG1hcCBmb3IgQXhpc1NjYWxlTWFrZXIgb2YgYXhlcyh4QXhpcywgeUF4aXMpLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgQXhpc1NjYWxlTWFrZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBeGlzU2NhbGVNYWtlck1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYXNDYXRlZ29yaWVzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmhhc0NhdGVnb3JpZXMoKTtcbiAgICAgICAgdmFyIHNlcmllc0RhdGFNb2RlbCA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRTZXJpZXNEYXRhTW9kZWwodGhpcy5jaGFydFR5cGUpO1xuICAgICAgICB2YXIgaXNYQ291bnRHcmVhdGVyVGhhbllDb3VudCA9IHNlcmllc0RhdGFNb2RlbC5pc1hDb3VudEdyZWF0ZXJUaGFuWUNvdW50KCk7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgc2NhbGVNYWtlck1hcCA9IHt9O1xuXG4gICAgICAgIGlmIChoYXNDYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICBpZiAoaXNYQ291bnRHcmVhdGVyVGhhbllDb3VudCkge1xuICAgICAgICAgICAgICAgIHNjYWxlTWFrZXJNYXAueEF4aXMgPSB0aGlzLl9jcmVhdGVBeGlzU2NhbGVNYWtlcihvcHRpb25zLnhBeGlzLCAneEF4aXMnLCAneCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FsZU1ha2VyTWFwLnlBeGlzID0gdGhpcy5fY3JlYXRlQXhpc1NjYWxlTWFrZXIob3B0aW9ucy55QXhpcywgJ3lBeGlzJywgJ3knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjYWxlTWFrZXJNYXAueEF4aXMgPSB0aGlzLl9jcmVhdGVBeGlzU2NhbGVNYWtlcihvcHRpb25zLnhBeGlzLCAneEF4aXMnLCAneCcpO1xuICAgICAgICAgICAgc2NhbGVNYWtlck1hcC55QXhpcyA9IHRoaXMuX2NyZWF0ZUF4aXNTY2FsZU1ha2VyKG9wdGlvbnMueUF4aXMsICd5QXhpcycsICd5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NhbGVNYWtlck1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IG1hcCBmb3IgQXhpc1NjYWxlTWFrZXIgb2YgYXhlcyh4QXhpcywgeUF4aXMpLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgQXhpc1NjYWxlTWFrZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEF4aXNTY2FsZU1ha2VyTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmF4aXNTY2FsZU1ha2VyTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmF4aXNTY2FsZU1ha2VyTWFwID0gdGhpcy5fbWFrZUF4aXNTY2FsZU1ha2VyTWFwKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5heGlzU2NhbGVNYWtlck1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBheGlzIGRhdGEuXG4gICAgICogQHBhcmFtIHtBeGlzU2NhbGVNYWtlcn0gYXhpc1NjYWxlTWFrZXIgLSBBeGlzU2NhbGVNYWtlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzVmVydGljYWxdIC0gd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBeGlzRGF0YTogZnVuY3Rpb24oYXhpc1NjYWxlTWFrZXIsIGlzVmVydGljYWwpIHtcbiAgICAgICAgdmFyIGF4aXNEYXRhO1xuXG4gICAgICAgIGlmIChheGlzU2NhbGVNYWtlcikge1xuICAgICAgICAgICAgYXhpc0RhdGEgPSBheGlzRGF0YU1ha2VyLm1ha2VWYWx1ZUF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICBheGlzU2NhbGVNYWtlcjogYXhpc1NjYWxlTWFrZXIsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogISFpc1ZlcnRpY2FsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF4aXNEYXRhID0gYXhpc0RhdGFNYWtlci5tYWtlTGFiZWxBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgbGFiZWxzOiB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Q2F0ZWdvcmllcygpLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWw6ICEhaXNWZXJ0aWNhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXhpc0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYXhlcyBkYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gYXhlcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUF4ZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGF4aXNTY2FsZU1ha2VyTWFwID0gdGhpcy5fZ2V0QXhpc1NjYWxlTWFrZXJNYXAoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeEF4aXM6IHRoaXMuX21ha2VBeGlzRGF0YShheGlzU2NhbGVNYWtlck1hcC54QXhpcyksXG4gICAgICAgICAgICB5QXhpczogdGhpcy5fbWFrZUF4aXNEYXRhKGF4aXNTY2FsZU1ha2VyTWFwLnlBeGlzLCB0cnVlKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENvbXBvbmVudHM6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzRm9yQXhpc1R5cGUoe1xuICAgICAgICAgICAgYXhlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3lBeGlzJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneEF4aXMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgc2VyaWVzZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdidWJibGVTZXJpZXMnLFxuICAgICAgICAgICAgICAgICAgICBTZXJpZXNDbGFzczogU2VyaWVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLnBpY2sodGhpcy5vcHRpb25zLCAnY2lyY2xlTGVnZW5kJywgJ2hpZGRlbicpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2NpcmNsZUxlZ2VuZCcsIENpcmNsZUxlZ2VuZCwge1xuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgIGJhc2VGb250RmFtaWx5OiB0aGlzLnRoZW1lLmNoYXJ0LmZvbnRGYW1pbHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB3aWR0aCBvZiBtYXggbGFiZWwgb2YgQ2lyY2xlTGVnZW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TWF4Q2lyY2xlTGVnZW5kTGFiZWxXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYXhMYWJlbCA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGb3JtYXR0ZWRNYXhWYWx1ZSh0aGlzLmNoYXJ0VHlwZSwgJ2NpcmNsZUxlZ2VuZCcsICdyJyk7XG4gICAgICAgIHZhciBtYXhMYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobWF4TGFiZWwsIHtcbiAgICAgICAgICAgIGZvbnRTaXplOiBjaGFydENvbnN0LkNJUkNMRV9MRUdFTkRfTEFCRUxfRk9OVF9TSVpFLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy50aGVtZS5jaGFydC5mb250RmFtaWx5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXhMYWJlbFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgd2lkdGggb2YgY2lyY2xlIGxlZ2VuZCBhcmVhLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q2lyY2xlTGVnZW5kV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWF4UmFkaXVzID0gdGhpcy5ib3VuZHNNYWtlci5nZXRNaW5pbXVtUGl4ZWxTdGVwRm9yQXhpcygpO1xuICAgICAgICB2YXIgY2lyY2xlV2lkdGggPSAobWF4UmFkaXVzICogMikgKyBjaGFydENvbnN0LkNJUkNMRV9MRUdFTkRfUEFERElORztcbiAgICAgICAgdmFyIG1heExhYmVsV2lkdGggPSB0aGlzLl9nZXRNYXhDaXJjbGVMZWdlbmRMYWJlbFdpZHRoKCk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGNpcmNsZVdpZHRoLCBtYXhMYWJlbFdpZHRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHdpZHRoIG9mIGxlZ2VuZCBhbmQgc2VyaWVzIG9mIGJvdW5kc01ha2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNXaWR0aCAtIHdpZHRoIG9mIHNlcmllcyBhcmVhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZ2VuZFdpZHRoIC0gd2lkdGggb2YgbGVnZW5kIGFyZWFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVMZWdlbmRBbmRTZXJpZXNXaWR0aDogZnVuY3Rpb24oc2VyaWVzV2lkdGgsIGxlZ2VuZFdpZHRoKSB7XG4gICAgICAgIHZhciBjaXJjbGVMZWdlbmRXaWR0aCA9IHRoaXMuX2dldENpcmNsZUxlZ2VuZFdpZHRoKCk7XG4gICAgICAgIHZhciBsZWdlbmRBbGlnbk9wdGlvbiA9IHR1aS51dGlsLnBpY2sodGhpcy5vcHRpb25zLCAnbGVnZW5kJywgJ2FsaWduJyk7XG5cbiAgICAgICAgaWYgKCFwcmVkaWNhdGUuaXNIb3Jpem9udGFsTGVnZW5kKGxlZ2VuZEFsaWduT3B0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5ib3VuZHNNYWtlci5yZWdpc3RlckJhc2VEaW1lbnNpb24oJ2xlZ2VuZCcsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogY2lyY2xlTGVnZW5kV2lkdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlci5yZWdpc3RlckJhc2VEaW1lbnNpb24oJ3NlcmllcycsIHtcbiAgICAgICAgICAgIHdpZHRoOiBzZXJpZXNXaWR0aCAtIChjaXJjbGVMZWdlbmRXaWR0aCAtIGxlZ2VuZFdpZHRoKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGF4ZXNEYXRhIG9mIGJvdW5kc01ha2VyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUF4ZXNEYXRhT2ZCb3VuZHNNYWtlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdBeGVzRGF0YTtcblxuICAgICAgICB0aGlzLmF4aXNTY2FsZU1ha2VyTWFwID0gbnVsbDtcbiAgICAgICAgbmV3QXhlc0RhdGEgPSB0aGlzLl9tYWtlQXhlc0RhdGEoKTtcbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlci5yZWdpc3RlckF4ZXNEYXRhKG5ld0F4ZXNEYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjaGFuZ2VkIG1heCByYWRpdXMgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmVmb3JlTWF4UmFkaXVzIC0gYmVmb3JlIG1heCByYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0NoYW5nZWRNYXhSYWRpdXM6IGZ1bmN0aW9uKGJlZm9yZU1heFJhZGl1cykge1xuICAgICAgICB2YXIgYWZ0ZXJNYXhSYWRpdXMgPSB0aGlzLmJvdW5kc01ha2VyLmdldE1pbmltdW1QaXhlbFN0ZXBGb3JBeGlzKCk7XG5cbiAgICAgICAgcmV0dXJuIChiZWZvcmVNYXhSYWRpdXMgIT09IGFmdGVyTWF4UmFkaXVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHdpZHRoIG9mIGxlZ2VuZCBhcmVhIGJ5IHdpZHRoIG9mIGNpcmNsZSBsZWdlbmQgYXJlYS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVMZWdlbmRXaWR0aEJ5Q2lyY2xlTGVnZW5kV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYm91bmRzTWFrZXIgPSB0aGlzLmJvdW5kc01ha2VyO1xuICAgICAgICB2YXIgYXhlc0RhdGEgPSBib3VuZHNNYWtlci5nZXRBeGVzRGF0YSgpO1xuICAgICAgICB2YXIgY2lyY2xlTGVnZW5kV2lkdGggPSB0aGlzLl9nZXRDaXJjbGVMZWdlbmRXaWR0aCgpO1xuICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSBib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2NhbGN1bGF0aW9uTGVnZW5kJykud2lkdGg7XG4gICAgICAgIHZhciBpc1hBeGlzTGFiZWwsIGJlZm9yZU1heFJhZGl1cywgc2VyaWVzV2lkdGg7XG5cbiAgICAgICAgaWYgKGxlZ2VuZFdpZHRoID49IGNpcmNsZUxlZ2VuZFdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpc1hBeGlzTGFiZWwgPSBheGVzRGF0YS54QXhpcy5pc0xhYmVsO1xuICAgICAgICBzZXJpZXNXaWR0aCA9IGJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJykud2lkdGg7XG4gICAgICAgIGJlZm9yZU1heFJhZGl1cyA9IGJvdW5kc01ha2VyLmdldE1pbmltdW1QaXhlbFN0ZXBGb3JBeGlzKCk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlTGVnZW5kQW5kU2VyaWVzV2lkdGgoc2VyaWVzV2lkdGgsIGxlZ2VuZFdpZHRoKTtcblxuICAgICAgICBpZiAoIWlzWEF4aXNMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQXhlc0RhdGFPZkJvdW5kc01ha2VyKGlzWEF4aXNMYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0NoYW5nZWRNYXhSYWRpdXMoYmVmb3JlTWF4UmFkaXVzKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGVnZW5kQW5kU2VyaWVzV2lkdGgoc2VyaWVzV2lkdGgsIGxlZ2VuZFdpZHRoKTtcblxuICAgICAgICAgICAgaWYgKCFpc1hBeGlzTGFiZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBeGVzRGF0YU9mQm91bmRzTWFrZXIoaXNYQXhpc0xhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBkaW1lbnNpb24gb2YgY2lyY2xlIGxlZ2VuZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlckNpcmNsZUxlZ2VuZERpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaXJjbGVMZWdlbmRXaWR0aCA9IHRoaXMuX2dldENpcmNsZUxlZ2VuZFdpZHRoKCk7XG5cbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlci5yZWdpc3RlckJhc2VEaW1lbnNpb24oJ2NpcmNsZUxlZ2VuZCcsIHtcbiAgICAgICAgICAgIHdpZHRoOiBjaXJjbGVMZWdlbmRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY2lyY2xlTGVnZW5kV2lkdGhcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBkaW1lbnNpb25zLlxuICAgICAqIEBwYXJhbSB7e3hBeGlzOiBvYmplY3QsIHlBeGlzOiBvYmplY3R9fSBheGVzRGF0YSAtIGRhdGEgZm9yIHJlbmRlcmluZyBvZiBheGlzIGFyZWEoeCBheGlzIGFuZCB5IGF4aXMpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3VwZGF0ZURpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocHJlZGljYXRlLmlzSGlkZGVuKHRoaXMub3B0aW9ucy5jaXJjbGVMZWdlbmQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVMZWdlbmRXaWR0aEJ5Q2lyY2xlTGVnZW5kV2lkdGgoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJDaXJjbGVMZWdlbmREaW1lbnNpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVyZW5kZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmF4aXNTY2FsZU1ha2VyTWFwID0gbnVsbDtcbiAgICAgICAgQ2hhcnRCYXNlLnByb3RvdHlwZS5fcmVyZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG59KTtcblxuYXhpc1R5cGVNaXhlci5taXhpbihCdWJibGVDaGFydCk7XG5cbi8qKlxuICogQWRkIGRhdGEgcmF0aW9zLlxuICogQHByaXZhdGVcbiAqIEBvdmVycmlkZVxuICovXG5CdWJibGVDaGFydC5wcm90b3R5cGUuX2FkZERhdGFSYXRpb3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NhbGVNYWtlck1hcCA9IHRoaXMuX2dldEF4aXNTY2FsZU1ha2VyTWFwKCksXG4gICAgICAgIGxpbWl0TWFwID0ge307XG5cbiAgICBpZiAoc2NhbGVNYWtlck1hcC54QXhpcykge1xuICAgICAgICBsaW1pdE1hcC54ID0gc2NhbGVNYWtlck1hcC54QXhpcy5nZXRMaW1pdCgpO1xuICAgIH1cblxuICAgIGlmIChzY2FsZU1ha2VyTWFwLnlBeGlzKSB7XG4gICAgICAgIGxpbWl0TWFwLnkgPSBzY2FsZU1ha2VyTWFwLnlBeGlzLmdldExpbWl0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhUHJvY2Vzc29yLmFkZERhdGFSYXRpb3NGb3JDb29yZGluYXRlVHlwZShsaW1pdE1hcCk7XG59O1xuXG4vKipcbiAqIEFkZCBjdXN0b20gZXZlbnQgY29tcG9uZW50IGZvciBub3JtYWwgdG9vbHRpcC5cbiAqIEBwcml2YXRlXG4gKi9cbkJ1YmJsZUNoYXJ0LnByb3RvdHlwZS5fYXR0YWNoQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuY29tcG9uZW50TWFuYWdlcjtcbiAgICB2YXIgY3VzdG9tRXZlbnQgPSBjb21wb25lbnRNYW5hZ2VyLmdldCgnY3VzdG9tRXZlbnQnKTtcbiAgICB2YXIgYnViYmxlU2VyaWVzID0gY29tcG9uZW50TWFuYWdlci5nZXQoJ2J1YmJsZVNlcmllcycpO1xuICAgIHZhciB0b29sdGlwID0gY29tcG9uZW50TWFuYWdlci5nZXQoJ3Rvb2x0aXAnKTtcblxuICAgIGF4aXNUeXBlTWl4ZXIuX2F0dGFjaEN1c3RvbUV2ZW50LmNhbGwodGhpcyk7XG5cbiAgICBjdXN0b21FdmVudC5vbih7XG4gICAgICAgIGNsaWNrQnViYmxlU2VyaWVzOiBidWJibGVTZXJpZXMub25DbGlja1NlcmllcyxcbiAgICAgICAgbW92ZUJ1YmJsZVNlcmllczogYnViYmxlU2VyaWVzLm9uTW92ZVNlcmllc1xuICAgIH0sIGJ1YmJsZVNlcmllcyk7XG5cbiAgICBidWJibGVTZXJpZXMub24oe1xuICAgICAgICBzaG93VG9vbHRpcDogdG9vbHRpcC5vblNob3csXG4gICAgICAgIGhpZGVUb29sdGlwOiB0b29sdGlwLm9uSGlkZSxcbiAgICAgICAgc2hvd1Rvb2x0aXBDb250YWluZXI6IHRvb2x0aXAub25TaG93VG9vbHRpcENvbnRhaW5lcixcbiAgICAgICAgaGlkZVRvb2x0aXBDb250YWluZXI6IHRvb2x0aXAub25IaWRlVG9vbHRpcENvbnRhaW5lclxuICAgIH0sIHRvb2x0aXApO1xufTtcblxuLyoqXG4gKiBBZGQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbkJ1YmJsZUNoYXJ0LnByb3RvdHlwZS5fYWRkQ3VzdG9tRXZlbnRDb21wb25lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2N1c3RvbUV2ZW50JywgU2ltcGxlQ3VzdG9tRXZlbnQsIHtcbiAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZVxuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWJibGVDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDaGFydEJhc2VcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbXBvbmVudE1hbmFnZXIgPSByZXF1aXJlKCcuL2NvbXBvbmVudE1hbmFnZXInKSxcbiAgICBEZWZhdWx0RGF0YVByb2Nlc3NvciA9IHJlcXVpcmUoJy4uL2RhdGFNb2RlbHMvZGF0YVByb2Nlc3NvcicpLFxuICAgIEJvdW5kc01ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9ib3VuZHNNYWtlcicpLFxuICAgIEF4aXNTY2FsZU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9heGlzU2NhbGVNYWtlcicpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBVc2VyRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdXNlckV2ZW50TGlzdGVuZXInKTtcblxudmFyIENoYXJ0QmFzZSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgQ2hhcnRCYXNlLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQ2hhcnQgYmFzZS5cbiAgICAgKiBAY29uc3RydWN0cyBDaGFydEJhc2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMucmF3RGF0YSByYXcgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBjaGFydCB0aGVtZVxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmhhc0F4ZXMgd2hldGhlciBoYXMgYXhlcyBvciBub3RcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiAgICAgIEBwYXJhbSB7RGF0YVByb2Nlc3Nvcn0gcGFyYW1zLkRhdGFQcm9jZXNzb3IgRGF0YVByb2Nlc3NvclxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogcmF3IGRhdGEuXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhd0RhdGEgPSBwYXJhbXMucmF3RGF0YTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdGhlbWVcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGhlbWUgPSBwYXJhbXMudGhlbWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IHRoaXMub3B0aW9ucy5jaGFydFR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgY2hhcnQgaGFzIGF4ZXMgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNBeGVzID0gcGFyYW1zLmhhc0F4ZXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1ZlcnRpY2FsID0gISFwYXJhbXMuaXNWZXJ0aWNhbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciBjaGFydCBoYXMgZ3JvdXAgdG9vbHRpcCBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0dyb3VwVG9vbHRpcCA9ICEhdHVpLnV0aWwucGljayh0aGlzLm9wdGlvbnMsICd0b29sdGlwJywgJ2dyb3VwZWQnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZGF0YSBwcm9jZXNzb3JcbiAgICAgICAgICogQHR5cGUge0RhdGFQcm9jZXNzb3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IgPSB0aGlzLl9jcmVhdGVEYXRhUHJvY2Vzc29yKHBhcmFtcy5EYXRhUHJvY2Vzc29yIHx8IERlZmF1bHREYXRhUHJvY2Vzc29yLCBwYXJhbXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBib3VuZHMgbWFrZXJcbiAgICAgICAgICogQHR5cGUge0JvdW5kc01ha2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlciA9IG5ldyBCb3VuZHNNYWtlcih7XG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICB0aGVtZTogdGhpcy50aGVtZSxcbiAgICAgICAgICAgIGRhdGFQcm9jZXNzb3I6IHRoaXMuZGF0YVByb2Nlc3NvcixcbiAgICAgICAgICAgIGhhc0F4ZXM6IHRoaXMuaGFzQXhlcyxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRoaXMuaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbXBvbmVudCBtYW5hZ2VyXG4gICAgICAgICAqIEB0eXBlIHtDb21wb25lbnRNYW5hZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyID0gbmV3IENvbXBvbmVudE1hbmFnZXIoe1xuICAgICAgICAgICAgZGF0YVByb2Nlc3NvcjogdGhpcy5kYXRhUHJvY2Vzc29yLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXG4gICAgICAgICAgICBib3VuZHNNYWtlcjogdGhpcy5ib3VuZHNNYWtlcixcbiAgICAgICAgICAgIGhhc0F4ZXM6IHRoaXMuaGFzQXhlc1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdXNlciBldmVudCBsaXN0ZW5lclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VyRXZlbnQgPSBuZXcgVXNlckV2ZW50TGlzdGVuZXIoKTtcblxuICAgICAgICB0aGlzLl9hZGRDdXN0b21FdmVudENvbXBvbmVudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZGF0YVByb2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0ge0RhdGFQcm9jZXNzb3J9IERhdGFQcm9jZXNzb3IgRGF0YVByb2Nlc3NvciBjbGFzc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtcyB7b2JqZWN0fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogICAgICBAcGFyYW1zIHt7Y2hhcnQ6IG9iamVjdCwgY2hhcnRUeXBlOiBzdHJpbmd9fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbXMge0FycmF5fSBzZXJpZXNDaGFydFR5cGVzIHNlcmllcyBjaGFydCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGRhdGEgcHJvY2Vzc29yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlRGF0YVByb2Nlc3NvcjogZnVuY3Rpb24oRGF0YVByb2Nlc3NvciwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBkYXRhUHJvY2Vzc29yID0gbmV3IERhdGFQcm9jZXNzb3IocGFyYW1zLnJhd0RhdGEsIHRoaXMuY2hhcnRUeXBlLCBwYXJhbXMub3B0aW9ucywgcGFyYW1zLnNlcmllc0NoYXJ0VHlwZXMpO1xuXG4gICAgICAgIHJldHVybiBkYXRhUHJvY2Vzc29yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYXhpcyBzY2FsZSBtYWtlci5cbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdE9wdGlvbiBsaW1pdFxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gYWRkaXRpb25hbFBhcmFtcyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7QXhpc1NjYWxlTWFrZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQXhpc1NjYWxlTWFrZXI6IGZ1bmN0aW9uKGxpbWl0T3B0aW9uLCBhZGRpdGlvbmFsUGFyYW1zLCBjaGFydFR5cGUpIHtcbiAgICAgICAgdmFyIHNlcmllc09wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2VyaWVzIHx8IHt9O1xuXG4gICAgICAgIGNoYXJ0VHlwZSA9IGNoYXJ0VHlwZSB8fCB0aGlzLmNoYXJ0VHlwZTtcbiAgICAgICAgc2VyaWVzT3B0aW9ucyA9IHNlcmllc09wdGlvbnNbY2hhcnRUeXBlXSB8fCBzZXJpZXNPcHRpb25zO1xuXG4gICAgICAgIHJldHVybiBuZXcgQXhpc1NjYWxlTWFrZXIodHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGRhdGFQcm9jZXNzb3I6IHRoaXMuZGF0YVByb2Nlc3NvcixcbiAgICAgICAgICAgIGJvdW5kc01ha2VyOiB0aGlzLmJvdW5kc01ha2VyLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHN0YWNrZWQ6IHNlcmllc09wdGlvbnMuc3RhY2tlZCxcbiAgICAgICAgICAgICAgICBkaXZlcmdpbmc6IHNlcmllc09wdGlvbnMuZGl2ZXJnaW5nLFxuICAgICAgICAgICAgICAgIGxpbWl0OiBsaW1pdE9wdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRoaXMuaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlXG4gICAgICAgIH0sIGFkZGl0aW9uYWxQYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBkYXRhIGZvciB0b29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0b29sdGlwIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgdXNlckV2ZW50OiB0aGlzLnVzZXJFdmVudCxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGN1c3RvbSBldmVudCBjb21wb25lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfYWRkQ3VzdG9tRXZlbnRDb21wb25lbnQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJlbmRlcmluZyBkYXRhIGZvciBheGlzIHR5cGUgY2hhcnQuXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmVuZGVyaW5nIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVJlbmRlcmluZ0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBjdXN0b20gZXZuZXQuXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gc2VyaWVzZXMgc2VyaWVzZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdHRhY2hDdXN0b21FdmVudDogZnVuY3Rpb24oc2VyaWVzZXMpIHtcbiAgICAgICAgdmFyIGxlZ2VuZCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ2xlZ2VuZCcpO1xuXG4gICAgICAgIHNlcmllc2VzID0gc2VyaWVzZXMgfHwgdGhpcy5jb21wb25lbnRNYW5hZ2VyLndoZXJlKHtjb21wb25lbnRUeXBlOiAnc2VyaWVzJ30pO1xuXG4gICAgICAgIGlmIChsZWdlbmQpIHtcbiAgICAgICAgICAgIGxlZ2VuZC5vbignY2hhbmdlQ2hlY2tlZExlZ2VuZHMnLCB0aGlzLm9uQ2hhbmdlQ2hlY2tlZExlZ2VuZHMsIHRoaXMpO1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdExlZ2VuZEV2ZW50TmFtZSA9IHJlbmRlclV0aWwubWFrZUN1c3RvbUV2ZW50TmFtZSgnc2VsZWN0Jywgc2VyaWVzLmNoYXJ0VHlwZSwgJ2xlZ2VuZCcpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZC5vbihzZWxlY3RMZWdlbmRFdmVudE5hbWUsIHNlcmllcy5vblNlbGVjdExlZ2VuZCwgc2VyaWVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYXhlcyBkYXRhLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBeGVzRGF0YTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBkaW1lbnNpb25zLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZURpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSByYXRpb3MuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfYWRkRGF0YVJhdGlvczogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgY29tcG9uZW50IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jTmFtZSBmdW5jdGlvbiBuYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXhlY3V0ZUNvbXBvbmVudEZ1bmM6IGZ1bmN0aW9uKGZ1bmNOYW1lKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5lYWNoKGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFtmdW5jTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRbZnVuY05hbWVdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25SZW5kZXIgcmVuZGVyIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihvblJlbmRlcikge1xuICAgICAgICB2YXIgYXhlc0RhdGEsIHJlbmRlcmluZ0RhdGE7XG5cbiAgICAgICAgdGhpcy5fZXhlY3V0ZUNvbXBvbmVudEZ1bmMoJ3JlZ2lzdGVyRGltZW5zaW9uJyk7XG4gICAgICAgIGF4ZXNEYXRhID0gdGhpcy5fbWFrZUF4ZXNEYXRhKCk7XG5cbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlci5yZWdpc3RlckF4ZXNEYXRhKGF4ZXNEYXRhKTtcbiAgICAgICAgdGhpcy5fZXhlY3V0ZUNvbXBvbmVudEZ1bmMoJ3JlZ2lzdGVyQWRkaXRpb25hbERpbWVuc2lvbicpO1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyLnJlZ2lzdGVyU2VyaWVzRGltZW5zaW9uKCk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCb3VuZHNEYXRhKCk7XG4gICAgICAgIHRoaXMuX2FkZERhdGFSYXRpb3MoKTtcblxuICAgICAgICByZW5kZXJpbmdEYXRhID0gdGhpcy5fbWFrZVJlbmRlcmluZ0RhdGEoKTtcblxuICAgICAgICBvblJlbmRlcihyZW5kZXJpbmdEYXRhKTtcblxuICAgICAgICB0aGlzLl9zZW5kU2VyaWVzRGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgY2hhcnQuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBjaGFydCBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZG9tLmFkZENsYXNzKGVsLCAndHVpLWNoYXJ0Jyk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRpdGxlKGVsKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oZWwsIHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdjaGFydCcpKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJCYWNrZ3JvdW5kKGVsLCB0aGlzLnRoZW1lLmNoYXJ0LmJhY2tncm91bmQpO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckZvbnRGYW1pbHkoZWwsIHRoaXMudGhlbWUuY2hhcnQuZm9udEZhbWlseSk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyKGZ1bmN0aW9uKHJlbmRlcmluZ0RhdGEpIHtcbiAgICAgICAgICAgIHNlbGYuX3JlbmRlckNvbXBvbmVudHMocmVuZGVyaW5nRGF0YSwgJ3JlbmRlcicsIGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYXR0YWNoQ3VzdG9tRXZlbnQoKTtcbiAgICAgICAgdGhpcy5jaGFydENvbnRhaW5lciA9IGVsO1xuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHJhdyBkYXRhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48P2Jvb2xlYW4+IHwge2xpbmU6ID9BcnJheS48Ym9vbGVhbj4sIGNvbHVtbjogP0FycmF5Ljxib29sZWFuPn19IGNoZWNrZWRMZWdlbmRzIGNoZWNrZWQgbGVnZW5kc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJhd0RhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maWx0ZXJSYXdEYXRhOiBmdW5jdGlvbihyYXdEYXRhLCBjaGVja2VkTGVnZW5kcykge1xuICAgICAgICB2YXIgY2xvbmVEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyYXdEYXRhKSk7XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzQXJyYXkoY2xvbmVEYXRhLnNlcmllcykpIHtcbiAgICAgICAgICAgIGNsb25lRGF0YS5zZXJpZXMgPSB0dWkudXRpbC5maWx0ZXIoY2xvbmVEYXRhLnNlcmllcywgZnVuY3Rpb24oc2VyaWVzLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja2VkTGVnZW5kc1tpbmRleF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goY2xvbmVEYXRhLnNlcmllcywgZnVuY3Rpb24oc2VyaWVzZXMsIGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2tlZExlZ2VuZHNbY2hhcnRUeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZURhdGEuc2VyaWVzW2NoYXJ0VHlwZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoZWNrZWRMZWdlbmRzW2NoYXJ0VHlwZV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lRGF0YS5zZXJpZXNbY2hhcnRUeXBlXSA9IHR1aS51dGlsLmZpbHRlcihzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrZWRMZWdlbmRzW2NoYXJ0VHlwZV1baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9uZURhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcmVyZW5kZXJpbmcgZGF0YS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVuZGVyaW5nRGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fSBjaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VSZXJlbmRlcmluZ0RhdGE6IGZ1bmN0aW9uKHJlbmRlcmluZ0RhdGEsIGNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgIHZhciB0b29sdGlwRGF0YSA9IHRoaXMuX21ha2VUb29sdGlwRGF0YSgpLFxuICAgICAgICAgICAgc2VyaWVzZXMgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIud2hlcmUoe2NvbXBvbmVudFR5cGU6ICdzZXJpZXMnfSk7XG5cbiAgICAgICAgcmVuZGVyaW5nRGF0YS50b29sdGlwID0gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGNoZWNrZWRMZWdlbmRzOiBjaGVja2VkTGVnZW5kc1xuICAgICAgICB9LCB0b29sdGlwRGF0YSwgcmVuZGVyaW5nRGF0YS50b29sdGlwKTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHNlcmllc2VzLCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgIHJlbmRlcmluZ0RhdGFbc2VyaWVzLmNvbXBvbmVudE5hbWVdID0gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBjaGVja2VkTGVnZW5kczogY2hlY2tlZExlZ2VuZHNbc2VyaWVzLmNoYXJ0VHlwZV0gfHwgY2hlY2tlZExlZ2VuZHNcbiAgICAgICAgICAgIH0sIHJlbmRlcmluZ0RhdGFbc2VyaWVzLmNvbXBvbmVudE5hbWVdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmluZ0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcmVuZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fSBjaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHJhd0RhdGEgcmF3RGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlcmVuZGVyOiBmdW5jdGlvbihjaGVja2VkTGVnZW5kcywgcmF3RGF0YSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmF3RGF0YSA9IHJhd0RhdGEgfHwgdGhpcy5fZmlsdGVyUmF3RGF0YSh0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0T3JpZ2luYWxSYXdEYXRhKCksIGNoZWNrZWRMZWdlbmRzKTtcbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLmluaXREYXRhKHJhd0RhdGEpO1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyLmluaXRCb3VuZHNEYXRhKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcihmdW5jdGlvbihyZW5kZXJpbmdEYXRhKSB7XG4gICAgICAgICAgICByZW5kZXJpbmdEYXRhID0gc2VsZi5fbWFrZVJlcmVuZGVyaW5nRGF0YShyZW5kZXJpbmdEYXRhLCBjaGVja2VkTGVnZW5kcyk7XG4gICAgICAgICAgICBzZWxmLl9yZW5kZXJDb21wb25lbnRzKHJlbmRlcmluZ0RhdGEsICdyZXJlbmRlcicpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2hhbmdlIGNoZWNrZWQgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fSBjaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHJhd0RhdGEgcmF3RGF0YVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gYm91bmRzUGFyYW1zIGFkZGl0aW9uIHBhcmFtcyBmb3IgY2FsY3VsYXRpbmcgYm91bmRzXG4gICAgICovXG4gICAgb25DaGFuZ2VDaGVja2VkTGVnZW5kczogZnVuY3Rpb24oY2hlY2tlZExlZ2VuZHMsIHJhd0RhdGEsIGJvdW5kc1BhcmFtcykge1xuICAgICAgICB0aGlzLl9yZXJlbmRlcihjaGVja2VkTGVnZW5kcywgcmF3RGF0YSwgYm91bmRzUGFyYW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRpdGxlLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyVGl0bGU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciBjaGFydE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuY2hhcnQgfHwge30sXG4gICAgICAgICAgICBlbFRpdGxlID0gcmVuZGVyVXRpbC5yZW5kZXJUaXRsZShjaGFydE9wdGlvbnMudGl0bGUsIHRoaXMudGhlbWUudGl0bGUsICd0dWktY2hhcnQtdGl0bGUnKTtcblxuICAgICAgICBkb20uYXBwZW5kKGVsLCBlbFRpdGxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGNvbXBvbmVudHMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlbmRlcmluZ0RhdGEgZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmNOYW1lIGZ1bmN0aW9uIG5hbWUgZm9yIGV4ZWN1dGlvblxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckNvbXBvbmVudHM6IGZ1bmN0aW9uKHJlbmRlcmluZ0RhdGEsIGZ1bmNOYW1lLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLm1hcChmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gcmVuZGVyaW5nRGF0YVtjb21wb25lbnQuY29tcG9uZW50TmFtZV0sXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnRbZnVuY05hbWVdKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGNvbXBvbmVudFtmdW5jTmFtZV0oZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBkb20uYXBwZW5kKGNvbnRhaW5lciwgZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgc2VyaWVzIGRhdGEgdG8gY3VzdG9tIGV2ZW50IGNvbXBvbmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZW5kU2VyaWVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnY3VzdG9tRXZlbnQnKSxcbiAgICAgICAgICAgIHNlcmllc0luZm9zLCBjaGFydFR5cGVzO1xuXG4gICAgICAgIGlmICghY3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJ0VHlwZXMgPSB0aGlzLmNoYXJ0VHlwZXMgfHwgW3RoaXMuY2hhcnRUeXBlXTtcbiAgICAgICAgc2VyaWVzSW5mb3MgPSB0dWkudXRpbC5tYXAoY2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gc2VsZi5jb21wb25lbnRNYW5hZ2VyLmdldChjaGFydFR5cGUgKyAnU2VyaWVzJykgfHwgc2VsZi5jb21wb25lbnRNYW5hZ2VyLmdldCgnc2VyaWVzJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogY29tcG9uZW50LmdldFNlcmllc0RhdGEoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3VzdG9tRXZlbnQuaW5pdEN1c3RvbUV2ZW50RGF0YShzZXJpZXNJbmZvcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZXZlbnQgbmFtZSBmb3IgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggcHJlZml4XG4gICAgICogQHJldHVybnMge3N0cmluZ30gZXZlbnQgbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBbmltYXRpb25FdmVudE5hbWU6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyBjaGFydFR5cGUuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBjaGFydFR5cGUuc3Vic3RyaW5nKDEpICsgJ0FuaW1hdGlvbic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgY2hhcnQuXG4gICAgICovXG4gICAgYW5pbWF0ZUNoYXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmVhY2goZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmFuaW1hdGVDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuYW5pbWF0ZUNvbXBvbmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgb2YgdXNlciBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIGV2ZW50IGNhbGxiYWNrXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZnVuYykge1xuICAgICAgICB0aGlzLnVzZXJFdmVudC5yZWdpc3RlcihldmVudE5hbWUsIGZ1bmMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZGltZW5zaW9uIG9mIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHVwZGF0ZWQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2hhcnREaW1lbnNpb246IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xuICAgICAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChkaW1lbnNpb24ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jaGFydC53aWR0aCA9IGRpbWVuc2lvbi53aWR0aDtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpbWVuc2lvbi5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jaGFydC5oZWlnaHQgPSBkaW1lbnNpb24uaGVpZ2h0O1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSSBmb3IgcmVzaXphYmxlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGltZW5zaW9uLndpZHRoIHdpZHRoXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGltZW5zaW9uLmhlaWdodCBoZWlnaHRcbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgdXBkYXRlZDtcblxuICAgICAgICBpZiAoIWRpbWVuc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlZCA9IHRoaXMuX3VwZGF0ZUNoYXJ0RGltZW5zaW9uKGRpbWVuc2lvbik7XG5cbiAgICAgICAgaWYgKCF1cGRhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvdW5kc01ha2VyLmluaXRCb3VuZHNEYXRhKHRoaXMub3B0aW9ucy5jaGFydCk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKHRoaXMuY2hhcnRDb250YWluZXIsIGRpbWVuc2lvbik7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyKGZ1bmN0aW9uKHJlbmRlcmluZ0RhdGEpIHtcbiAgICAgICAgICAgIHNlbGYuX3JlbmRlckNvbXBvbmVudHMocmVuZGVyaW5nRGF0YSwgJ3Jlc2l6ZScpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvb2x0aXAgYWxpZ24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbiBhbGlnbiAobGVmdHxjZW50ZXJ8cmlnaHQsIHRvcHxtaWRkbGV8Ym90dG9tKVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICBzZXRUb29sdGlwQWxpZ246IGZ1bmN0aW9uKGFsaWduKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ3Rvb2x0aXAnKS5zZXRBbGlnbihhbGlnbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBwb3NpdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBvc2l0aW9uIG1vdmluZyBwb3NpdGlvblxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uLmxlZnQgbGVmdFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uLnRvcCB0b3BcbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgc2V0VG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCd0b29sdGlwJykuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0b29sdGlwIGFsaWduIG9wdGlvbi5cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgcmVzZXRUb29sdGlwQWxpZ246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCd0b29sdGlwJykucmVzZXRBbGlnbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0b29sdGlwIHBvc2l0aW9uLlxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICByZXNldFRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ3Rvb2x0aXAnKS5yZXNldFBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICBzaG93U2VyaWVzTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzZXMgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIud2hlcmUoe2NvbXBvbmVudFR5cGU6ICdzZXJpZXMnfSk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHNlcmllc2VzLCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgIHNlcmllcy5zaG93TGFiZWwoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICBoaWRlU2VyaWVzTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzZXMgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIud2hlcmUoe2NvbXBvbmVudFR5cGU6ICdzZXJpZXMnfSk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHNlcmllc2VzLCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgIHNlcmllcy5oaWRlTGFiZWwoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnRCYXNlO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbHVtbiBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgYXhpc1R5cGVNaXhlciA9IHJlcXVpcmUoJy4vYXhpc1R5cGVNaXhlcicpLFxuICAgIGJhclR5cGVNaXhlciA9IHJlcXVpcmUoJy4vYmFyVHlwZU1peGVyJyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICBheGlzRGF0YU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9heGlzRGF0YU1ha2VyJyksXG4gICAgU2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL2NvbHVtbkNoYXJ0U2VyaWVzJyk7XG5cbnZhciBDb2x1bW5DaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKENoYXJ0QmFzZSwgLyoqIEBsZW5kcyBDb2x1bW5DaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIENvbHVtbiBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBDb2x1bW5DaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBtaXhlcyBheGlzVHlwZU1peGVyXG4gICAgICogQG1peGVzIHZlcnRpY2FsVHlwZU1peGVyXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbml0ZWREYXRhIGluaXRpYWxpemVkIGRhdGEgZnJvbSBjb21ibyBjaGFydFxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd0RhdGEsIHRoZW1lLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbGFzc05hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jb2x1bW4tY2hhcnQnO1xuXG4gICAgICAgIG9wdGlvbnMuc2VyaWVzID0gb3B0aW9ucy5zZXJpZXMgfHwge307XG4gICAgICAgIG9wdGlvbnMueUF4aXMgPSBvcHRpb25zLnlBeGlzIHx8IHt9O1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNWYWxpZFN0YWNrZWRPcHRpb24ob3B0aW9ucy5zZXJpZXMuc3RhY2tlZCkpIHtcbiAgICAgICAgICAgIHJhd0RhdGEuc2VyaWVzID0gdGhpcy5fc29ydFJhd1Nlcmllc0RhdGEocmF3RGF0YS5zZXJpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWVzLmRpdmVyZ2luZykge1xuICAgICAgICAgICAgcmF3RGF0YS5zZXJpZXMgPSB0aGlzLl9tYWtlUmF3U2VyaWVzRGF0YUZvckRpdmVyZ2luZyhyYXdEYXRhLnNlcmllcywgb3B0aW9ucy5zZXJpZXMuc3RhY2tlZCk7XG4gICAgICAgICAgICBvcHRpb25zLnNlcmllcy5zdGFja2VkID0gb3B0aW9ucy5zZXJpZXMuc3RhY2tlZCB8fCBjaGFydENvbnN0LlNUQUNLRURfTk9STUFMX1RZUEU7XG4gICAgICAgIH1cblxuICAgICAgICBDaGFydEJhc2UuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICByYXdEYXRhOiByYXdEYXRhLFxuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGhhc0F4ZXM6IHRydWUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHMob3B0aW9ucy5jaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGF4ZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGF4ZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBeGVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYXhpc1NjYWxlTWFrZXIgPSB0aGlzLl9jcmVhdGVBeGlzU2NhbGVNYWtlcih7XG4gICAgICAgICAgICAgICAgbWluOiBvcHRpb25zLnlBeGlzLm1pbixcbiAgICAgICAgICAgICAgICBtYXg6IG9wdGlvbnMueUF4aXMubWF4XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgYXJlYVR5cGU6ICd5QXhpcydcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeEF4aXNEYXRhID0gYXhpc0RhdGFNYWtlci5tYWtlTGFiZWxBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgbGFiZWxzOiB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Q2F0ZWdvcmllcygpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMueEF4aXNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeUF4aXNEYXRhID0gYXhpc0RhdGFNYWtlci5tYWtlVmFsdWVBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgYXhpc1NjYWxlTWFrZXI6IGF4aXNTY2FsZU1ha2VyLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWw6IHRoaXMuaXNWZXJ0aWNhbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHhBeGlzOiB4QXhpc0RhdGEsXG4gICAgICAgICAgICB5QXhpczogeUF4aXNEYXRhXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjb21wb25lbnRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ29tcG9uZW50czogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHNGb3JBeGlzVHlwZSh7XG4gICAgICAgICAgICBheGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneUF4aXMnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4QXhpcycsXG4gICAgICAgICAgICAgICAgICAgIGlzTGFiZWw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICBzZXJpZXNlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvbHVtblNlcmllcycsXG4gICAgICAgICAgICAgICAgICAgIFNlcmllc0NsYXNzOiBTZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93TmVnYXRpdmVUb29sdGlwOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5heGlzVHlwZU1peGVyLm1peGluKENvbHVtbkNoYXJ0KTtcbmJhclR5cGVNaXhlci5taXhpbihDb2x1bW5DaGFydCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29tYm8gY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxjdWxhdG9yJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyksXG4gICAgYXhpc1R5cGVNaXhlciA9IHJlcXVpcmUoJy4vYXhpc1R5cGVNaXhlcicpLFxuICAgIGF4aXNEYXRhTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2F4aXNEYXRhTWFrZXInKSxcbiAgICBkZWZhdWx0VGhlbWUgPSByZXF1aXJlKCcuLi90aGVtZXMvZGVmYXVsdFRoZW1lJyksXG4gICAgQ29sdW1uQ2hhcnRTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvY29sdW1uQ2hhcnRTZXJpZXMnKSxcbiAgICBMaW5lQ2hhcnRTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvbGluZUNoYXJ0U2VyaWVzJyk7XG5cbnZhciBDb21ib0NoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIENvbWJvQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBDb21ibyBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBDb21ib0NoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd0RhdGEsIHRoZW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjaGFydFR5cGVzTWFwO1xuXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jb21iby1jaGFydCc7XG5cbiAgICAgICAgY2hhcnRUeXBlc01hcCA9IHRoaXMuX21ha2VDaGFydFR5cGVzTWFwKHJhd0RhdGEuc2VyaWVzLCBvcHRpb25zLnlBeGlzKTtcblxuICAgICAgICB0dWkudXRpbC5leHRlbmQodGhpcywgY2hhcnRUeXBlc01hcCk7XG5cbiAgICAgICAgQ2hhcnRCYXNlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgcmF3RGF0YTogcmF3RGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBoYXNBeGVzOiB0cnVlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZSxcbiAgICAgICAgICAgIHNlcmllc0NoYXJ0VHlwZXM6IGNoYXJ0VHlwZXNNYXAuc2VyaWVzQ2hhcnRUeXBlc1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogeUF4aXMgb3B0aW9ucyBtYXBcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueUF4aXNPcHRpb25zTWFwID0gdGhpcy5fbWFrZVlBeGlzT3B0aW9uc01hcChjaGFydFR5cGVzTWFwLmNoYXJ0VHlwZXMsIG9wdGlvbnMueUF4aXMpO1xuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzKGNoYXJ0VHlwZXNNYXApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHlBeGlzIG9wdGlvbnMgbWFwLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNoYXJ0VHlwZXMgY2hhcnQgdHlwZXNcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHlBeGlzT3B0aW9ucyB5QXhpcyBvcHRpb25zXG4gICAgICogQHJldHVybnMge3tjb2x1bW46ID9vYmplY3QsIGxpbmU6ID9vYmplY3R9fSBvcHRpb25zIG1hcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VZQXhpc09wdGlvbnNNYXA6IGZ1bmN0aW9uKGNoYXJ0VHlwZXMsIHlBeGlzT3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uTWFwID0ge307XG4gICAgICAgIHlBeGlzT3B0aW9ucyA9IHlBeGlzT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIG9wdGlvbk1hcFtjaGFydFR5cGVdID0geUF4aXNPcHRpb25zW2luZGV4XSB8fCB5QXhpc09wdGlvbnM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25NYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY2hhcnQgdHlwZXMgbWFwLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByYXdTZXJpZXNEYXRhIHJhdyBzZXJpZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB5QXhpc09wdGlvbiBvcHRpb24gZm9yIHkgYXhpc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGNoYXJ0IHR5cGVzIG1hcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDaGFydFR5cGVzTWFwOiBmdW5jdGlvbihyYXdTZXJpZXNEYXRhLCB5QXhpc09wdGlvbikge1xuICAgICAgICB2YXIgc2VyaWVzQ2hhcnRUeXBlcyA9IHR1aS51dGlsLmtleXMocmF3U2VyaWVzRGF0YSkuc29ydCgpLFxuICAgICAgICAgICAgb3B0aW9uQ2hhcnRUeXBlcyA9IHRoaXMuX2dldFlBeGlzT3B0aW9uQ2hhcnRUeXBlcyhzZXJpZXNDaGFydFR5cGVzLCB5QXhpc09wdGlvbiksXG4gICAgICAgICAgICBjaGFydFR5cGVzID0gb3B0aW9uQ2hhcnRUeXBlcy5sZW5ndGggPyBvcHRpb25DaGFydFR5cGVzIDogc2VyaWVzQ2hhcnRUeXBlcyxcbiAgICAgICAgICAgIHZhbGlkQ2hhcnRUeXBlcyA9IHR1aS51dGlsLmZpbHRlcihvcHRpb25DaGFydFR5cGVzLCBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3U2VyaWVzRGF0YVtjaGFydFR5cGVdLmxlbmd0aDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY2hhcnRUeXBlc01hcDtcblxuICAgICAgICBpZiAodmFsaWRDaGFydFR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY2hhcnRUeXBlc01hcCA9IHtcbiAgICAgICAgICAgICAgICBjaGFydFR5cGVzOiB2YWxpZENoYXJ0VHlwZXMsXG4gICAgICAgICAgICAgICAgc2VyaWVzQ2hhcnRUeXBlczogdmFsaWRDaGFydFR5cGVzLFxuICAgICAgICAgICAgICAgIG9wdGlvbkNoYXJ0VHlwZXM6ICFvcHRpb25DaGFydFR5cGVzLmxlbmd0aCA/IG9wdGlvbkNoYXJ0VHlwZXMgOiB2YWxpZENoYXJ0VHlwZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFydFR5cGVzTWFwID0ge1xuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZXM6IGNoYXJ0VHlwZXMsXG4gICAgICAgICAgICAgICAgc2VyaWVzQ2hhcnRUeXBlczogc2VyaWVzQ2hhcnRUeXBlcyxcbiAgICAgICAgICAgICAgICBvcHRpb25DaGFydFR5cGVzOiBvcHRpb25DaGFydFR5cGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0VHlwZXNNYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugb3B0aW9ucyBtYXBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IG9wdGlvbnMgbWFwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU9wdGlvbnNNYXA6IGZ1bmN0aW9uKGNoYXJ0VHlwZXMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgb3B0aW9uc01hcCA9IHt9O1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjaGFydFR5cGVzLCBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnNNYXBbY2hhcnRUeXBlXSA9IHNlbGYub3B0aW9ucy5zZXJpZXNbY2hhcnRUeXBlXSB8fCBzZWxmLm9wdGlvbnMuc2VyaWVzO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3B0aW9uc01hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aGVtZSBtYXBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZW1lIG1hcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUaGVtZU1hcDogZnVuY3Rpb24oY2hhcnRUeXBlcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB0aGVtZSA9IHRoaXMudGhlbWUsXG4gICAgICAgICAgICB0aGVtZU1hcCA9IHt9LFxuICAgICAgICAgICAgY29sb3JDb3VudCA9IDA7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0VGhlbWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoZW1lKSksXG4gICAgICAgICAgICAgICAgcmVtb3ZlZENvbG9ycztcblxuICAgICAgICAgICAgaWYgKGNoYXJ0VGhlbWUuc2VyaWVzW2NoYXJ0VHlwZV0pIHtcbiAgICAgICAgICAgICAgICB0aGVtZU1hcFtjaGFydFR5cGVdID0gY2hhcnRUaGVtZS5zZXJpZXNbY2hhcnRUeXBlXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNoYXJ0VGhlbWUuc2VyaWVzLmNvbG9ycykge1xuICAgICAgICAgICAgICAgIHRoZW1lTWFwW2NoYXJ0VHlwZV0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZmF1bHRUaGVtZS5zZXJpZXMpKTtcbiAgICAgICAgICAgICAgICB0aGVtZU1hcFtjaGFydFR5cGVdLmxhYmVsLmZvbnRGYW1pbHkgPSBjaGFydFRoZW1lLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRDb2xvcnMgPSBjaGFydFRoZW1lLnNlcmllcy5jb2xvcnMuc3BsaWNlKDAsIGNvbG9yQ291bnQpO1xuICAgICAgICAgICAgICAgIGNoYXJ0VGhlbWUuc2VyaWVzLmNvbG9ycyA9IGNoYXJ0VGhlbWUuc2VyaWVzLmNvbG9ycy5jb25jYXQocmVtb3ZlZENvbG9ycyk7XG4gICAgICAgICAgICAgICAgdGhlbWVNYXBbY2hhcnRUeXBlXSA9IGNoYXJ0VGhlbWUuc2VyaWVzO1xuICAgICAgICAgICAgICAgIGNvbG9yQ291bnQgKz0gc2VsZi5kYXRhUHJvY2Vzc29yLmdldExlZ2VuZExhYmVscyhjaGFydFR5cGUpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoZW1lTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllc2VzXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gc2VyaWVzZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzZXM6IGZ1bmN0aW9uKGNoYXJ0VHlwZXMpIHtcbiAgICAgICAgdmFyIHNlcmllc0NsYXNzZXMgPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBDb2x1bW5DaGFydFNlcmllcyxcbiAgICAgICAgICAgICAgICBsaW5lOiBMaW5lQ2hhcnRTZXJpZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zTWFwID0gdGhpcy5fbWFrZU9wdGlvbnNNYXAoY2hhcnRUeXBlcyksXG4gICAgICAgICAgICB0aGVtZU1hcCA9IHRoaXMuX21ha2VUaGVtZU1hcChjaGFydFR5cGVzKSxcbiAgICAgICAgICAgIHNlcmllc2VzO1xuXG4gICAgICAgIHNlcmllc2VzID0gdHVpLnV0aWwubWFwKGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZVRvb2x0aXA6IHRydWUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZTogJ3NlcmllcycsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc01hcFtjaGFydFR5cGVdLFxuICAgICAgICAgICAgICAgIHRoZW1lOiB0aGVtZU1hcFtjaGFydFR5cGVdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGNoYXJ0VHlwZSArICdTZXJpZXMnLFxuICAgICAgICAgICAgICAgIFNlcmllc0NsYXNzOiBzZXJpZXNDbGFzc2VzW2NoYXJ0VHlwZV0sXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGFydFR5cGVzTWFwIGNoYXJ0IHR5cGVzIG1hcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENvbXBvbmVudHM6IGZ1bmN0aW9uKGNoYXJ0VHlwZXNNYXApIHtcbiAgICAgICAgdmFyIGF4ZXMgPSBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd5QXhpcycsXG4gICAgICAgICAgICAgICAgaXNMYWJlbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZXNNYXAuY2hhcnRUeXBlc1swXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneEF4aXMnXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIHNlcmllc2VzID0gdGhpcy5fbWFrZVNlcmllc2VzKGNoYXJ0VHlwZXNNYXAuc2VyaWVzQ2hhcnRUeXBlcyk7XG5cbiAgICAgICAgaWYgKGNoYXJ0VHlwZXNNYXAub3B0aW9uQ2hhcnRUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF4ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3JpZ2h0WUF4aXMnLFxuICAgICAgICAgICAgICAgIGlzTGFiZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGVzTWFwLmNoYXJ0VHlwZXNbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50c0ZvckF4aXNUeXBlKHtcbiAgICAgICAgICAgIGF4ZXM6IGF4ZXMsXG4gICAgICAgICAgICBzZXJpZXNDaGFydFR5cGVzOiBjaGFydFR5cGVzTWFwLnNlcmllc0NoYXJ0VHlwZXMsXG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMub3B0aW9ucy5jaGFydFR5cGUsXG4gICAgICAgICAgICBzZXJpZXNlczogc2VyaWVzZXNcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB5IGF4aXMgb3B0aW9uIGNoYXJ0IHR5cGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNoYXJ0VHlwZXMgY2hhcnQgdHlwZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0geUF4aXNPcHRpb25zIHkgYXhpcyBvcHRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSBjaGFydCB0eXBlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFlBeGlzT3B0aW9uQ2hhcnRUeXBlczogZnVuY3Rpb24oY2hhcnRUeXBlcywgeUF4aXNPcHRpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHRDaGFydFR5cGVzID0gY2hhcnRUeXBlcy5zbGljZSgpLFxuICAgICAgICAgICAgaXNSZXZlcnNlID0gZmFsc2UsXG4gICAgICAgICAgICBvcHRpb25DaGFydFR5cGVzO1xuXG4gICAgICAgIHlBeGlzT3B0aW9ucyA9IHlBeGlzT3B0aW9ucyA/IFtdLmNvbmNhdCh5QXhpc09wdGlvbnMpIDogW107XG5cbiAgICAgICAgaWYgKHlBeGlzT3B0aW9ucy5sZW5ndGggPT09IDEgJiYgIXlBeGlzT3B0aW9uc1swXS5jaGFydFR5cGUpIHtcbiAgICAgICAgICAgIHJlc3VsdENoYXJ0VHlwZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmICh5QXhpc09wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvcHRpb25DaGFydFR5cGVzID0gdHVpLnV0aWwubWFwKHlBeGlzT3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5jaGFydFR5cGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KG9wdGlvbkNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpc1JldmVyc2UgPSBpc1JldmVyc2UgfHwgKGNoYXJ0VHlwZSAmJiByZXN1bHRDaGFydFR5cGVzW2luZGV4XSAhPT0gY2hhcnRUeXBlIHx8IGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaXNSZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Q2hhcnRUeXBlcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0Q2hhcnRUeXBlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB5IGF4aXMgZGF0YS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuaW5kZXggY2hhcnQgaW5kZXhcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLnNlcmllc0RpbWVuc2lvbiBzZXJpZXMgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIGNoYXJ0IHR5cGVcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gaXNTaW5nbGVZQXhpcyB3aGV0aGVyIHNpbmdsZSB5QXhpcyBvciBub3RcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBhZGRQYXJhbXMgYWRkIHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHkgYXhpcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVlBeGlzRGF0YTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHBhcmFtcy5pbmRleCxcbiAgICAgICAgICAgIGNoYXJ0VHlwZSA9IHBhcmFtcy5jaGFydFR5cGVzW2luZGV4XSxcbiAgICAgICAgICAgIHlBeGlzT3B0aW9ucyA9IHRoaXMueUF4aXNPcHRpb25zTWFwW2NoYXJ0VHlwZV0sXG4gICAgICAgICAgICBheGlzU2NhbGVNYWtlciwgeUF4aXNEYXRhO1xuXG4gICAgICAgIGlmICghY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cblxuICAgICAgICBheGlzU2NhbGVNYWtlciA9IHRoaXMuX2NyZWF0ZUF4aXNTY2FsZU1ha2VyKHtcbiAgICAgICAgICAgIG1pbjogeUF4aXNPcHRpb25zLm1pbixcbiAgICAgICAgICAgIG1heDogeUF4aXNPcHRpb25zLm1heFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBpc1NpbmdsZVlBeGlzOiBwYXJhbXMuaXNTaW5nbGVZQXhpcyxcbiAgICAgICAgICAgIGFyZWFUeXBlOiAneUF4aXMnXG4gICAgICAgIH0sIGNoYXJ0VHlwZSk7XG5cbiAgICAgICAgeUF4aXNEYXRhID0gYXhpc0RhdGFNYWtlci5tYWtlVmFsdWVBeGlzRGF0YSh7XG4gICAgICAgICAgICBheGlzU2NhbGVNYWtlcjogYXhpc1NjYWxlTWFrZXIsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlLFxuICAgICAgICAgICAgaXNTaW5nbGVZQXhpczogcGFyYW1zLmlzU2luZ2xlWUF4aXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgeUF4aXNEYXRhLm9wdGlvbnMgPSB5QXhpc09wdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIHlBeGlzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRpY2sgY291bnQgdG8gbWFrZSB0aGUgc2FtZSB0aWNrIGNvdW50IG9mIHlBeGVzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB5QXhpc0RhdGEgeUF4aXMgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByaWdodFlBeGlzRGF0YSByaWdodCB5QXhpcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlWUF4aXNUaWNrQ291bnQ6IGZ1bmN0aW9uKHlBeGlzRGF0YSwgcmlnaHRZQXhpc0RhdGEpIHtcbiAgICAgICAgdmFyIHRpY2tDb3VudERpZmYgPSByaWdodFlBeGlzRGF0YS50aWNrQ291bnQgLSB5QXhpc0RhdGEudGlja0NvdW50O1xuXG4gICAgICAgIGlmICh0aWNrQ291bnREaWZmID4gMCkge1xuICAgICAgICAgICAgdGhpcy5faW5jcmVhc2VZQXhpc1RpY2tDb3VudCh0aWNrQ291bnREaWZmLCB5QXhpc0RhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHRpY2tDb3VudERpZmYgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmNyZWFzZVlBeGlzVGlja0NvdW50KC10aWNrQ291bnREaWZmLCByaWdodFlBeGlzRGF0YSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBheGVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBheGVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhlc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeUF4aXNQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlczogdGhpcy5jaGFydFR5cGVzLFxuICAgICAgICAgICAgICAgIGlzU2luZ2xlWUF4aXM6ICF0aGlzLm9wdGlvbkNoYXJ0VHlwZXMubGVuZ3RoXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeEF4aXNEYXRhID0gYXhpc0RhdGFNYWtlci5tYWtlTGFiZWxBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgbGFiZWxzOiB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Q2F0ZWdvcmllcygpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHlBeGlzRGF0YSA9IHRoaXMuX21ha2VZQXhpc0RhdGEodHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgfSwgeUF4aXNQYXJhbXMpKSxcbiAgICAgICAgICAgIGF4ZXNEYXRhID0ge1xuICAgICAgICAgICAgICAgIHlBeGlzOiB5QXhpc0RhdGEsXG4gICAgICAgICAgICAgICAgeEF4aXM6IHhBeGlzRGF0YVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJpZ2h0WUF4aXNEYXRhO1xuXG4gICAgICAgIGlmICgheUF4aXNQYXJhbXMuaXNTaW5nbGVZQXhpcykge1xuICAgICAgICAgICAgcmlnaHRZQXhpc0RhdGEgPSB0aGlzLl9tYWtlWUF4aXNEYXRhKHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IDFcbiAgICAgICAgICAgIH0sIHlBeGlzUGFyYW1zKSk7XG4gICAgICAgICAgICByaWdodFlBeGlzRGF0YS5hbGlnbmVkID0geEF4aXNEYXRhLmFsaWduZWQ7XG4gICAgICAgICAgICByaWdodFlBeGlzRGF0YS5pc1Bvc2l0aW9uUmlnaHQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVZQXhpc1RpY2tDb3VudCh5QXhpc0RhdGEsIHJpZ2h0WUF4aXNEYXRhKTtcblxuICAgICAgICAgICAgYXhlc0RhdGEucmlnaHRZQXhpcyA9IHJpZ2h0WUF4aXNEYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF4ZXNEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmNyZWFzZSB5QXhpcyB0aWNrIGNvdW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmNyZWFzZVRpY2tDb3VudCBpbmNyZWFzZSB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHlBeGlzRGF0YSB5QXhpcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5jcmVhc2VZQXhpc1RpY2tDb3VudDogZnVuY3Rpb24oaW5jcmVhc2VUaWNrQ291bnQsIHlBeGlzRGF0YSkge1xuICAgICAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpLFxuICAgICAgICAgICAgbGFiZWxzO1xuXG4gICAgICAgIHlBeGlzRGF0YS5saW1pdC5tYXggKz0geUF4aXNEYXRhLnN0ZXAgKiBpbmNyZWFzZVRpY2tDb3VudDtcbiAgICAgICAgbGFiZWxzID0gY2FsY3VsYXRvci5tYWtlTGFiZWxzRnJvbUxpbWl0KHlBeGlzRGF0YS5saW1pdCwgeUF4aXNEYXRhLnN0ZXApO1xuICAgICAgICB5QXhpc0RhdGEubGFiZWxzID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZXMobGFiZWxzLCBmb3JtYXRGdW5jdGlvbnMsICd5QXhpcycpO1xuICAgICAgICB5QXhpc0RhdGEudGlja0NvdW50ICs9IGluY3JlYXNlVGlja0NvdW50O1xuICAgICAgICB5QXhpc0RhdGEudmFsaWRUaWNrQ291bnQgKz0gaW5jcmVhc2VUaWNrQ291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGNoYW5nZSBzZWxlY3RlZCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtBcnJheS48P2Jvb2xlYW4+IHwge2xpbmU6ID9BcnJheS48Ym9vbGVhbj4sIGNvbHVtbjogP0FycmF5Ljxib29sZWFuPn19IGNoZWNrZWRMZWdlbmRzIGNoZWNrZWQgbGVnZW5kc1xuICAgICAqL1xuICAgIG9uQ2hhbmdlQ2hlY2tlZExlZ2VuZHM6IGZ1bmN0aW9uKGNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgIHZhciByYXdEYXRhID0gdGhpcy5fZmlsdGVyUmF3RGF0YSh0aGlzLnJhd0RhdGEsIGNoZWNrZWRMZWdlbmRzKSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZXNNYXAgPSB0aGlzLl9tYWtlQ2hhcnRUeXBlc01hcChyYXdEYXRhLnNlcmllcywgdGhpcy5vcHRpb25zLnlBeGlzKTtcblxuICAgICAgICB0dWkudXRpbC5leHRlbmQodGhpcywgY2hhcnRUeXBlc01hcCk7XG5cbiAgICAgICAgQ2hhcnRCYXNlLnByb3RvdHlwZS5vbkNoYW5nZUNoZWNrZWRMZWdlbmRzLmNhbGwodGhpcywgY2hlY2tlZExlZ2VuZHMsIHJhd0RhdGEsIGNoYXJ0VHlwZXNNYXApO1xuICAgIH1cbn0pO1xuXG5heGlzVHlwZU1peGVyLm1peGluKENvbWJvQ2hhcnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbWJvQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29tcG9uZW50TWFuYWdlciBtYW5hZ2VzIGNvbXBvbmVudHMgb2YgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb21wb25lbnRNYW5hZ2VyID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBDb21wb25lbnRNYW5hZ2VyLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50TWFuYWdlciBtYW5hZ2VzIGNvbXBvbmVudHMgb2YgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIHRoZW1lXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtEYXRhUHJvY2Vzc29yfSBwYXJhbXMuZGF0YVByb2Nlc3NvciBkYXRhIHByb2Nlc3NvclxuICAgICAqICAgICAgQHBhcmFtIHtCb3VuZHNNYWtlcn0gcGFyYW1zLmJvdW5kc01ha2VyIGJvdW5kcyBtYWtlclxuICAgICAqIEBjb25zdHJ1Y3RzIENvbXBvbmVudE1hbmFnZXJcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBvbmVudHNcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxvYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBvbmVudCBtYXAuXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGVtZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IHBhcmFtcy50aGVtZSB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogb3B0aW9uc1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gcGFyYW1zLm9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcHJvY2Vzc29yXG4gICAgICAgICAqIEB0eXBlIHtEYXRhUHJvY2Vzc29yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gcGFyYW1zLmRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aGV0aGVyIGNoYXJ0IGhhcyBheGVzIG9yIG5vdFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQXhlcyA9IHBhcmFtcy5oYXNBeGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50VHlwZSBjb21wb25lbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBjb21wb25lbnQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNvbXBvbmVudE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMsIGNvbXBvbmVudFR5cGUsIGluZGV4KSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9uc1tjb21wb25lbnRUeXBlXTtcbiAgICAgICAgb3B0aW9ucyA9IHR1aS51dGlsLmlzQXJyYXkob3B0aW9ucykgPyBvcHRpb25zW2luZGV4XSA6IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGNvbXBvbmVudC5cbiAgICAgKiBUaGUgY29tcG9uZW50IHJlZmVycyB0byBhIGNvbXBvbmVudCBvZiB0aGUgY2hhcnQuXG4gICAgICogVGhlIGNvbXBvbmVudCB0eXBlcyBhcmUgYXhpcywgbGVnZW5kLCBwbG90LCBzZXJpZXMgYW5kIGN1c3RvbUV2ZW50LlxuICAgICAqIENoYXJ0IENvbXBvbmVudCBEZXNjcmlwdGlvbiA6IGh0dHBzOi8vaS1tc2RuLnNlYy5zLW1zZnQuY29tL2R5bmltZy9JQzI2Nzk5Ny5naWZcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb21wb25lbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IENvbXBvbmVudCBjb21wb25lbnQgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIGNvbXBvbmVudCBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKG5hbWUsIENvbXBvbmVudCwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICAgIGNvbXBvbmVudCwgY29tcG9uZW50VHlwZTtcblxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcmFtcy5jb21wb25lbnRUeXBlIHx8IG5hbWU7XG4gICAgICAgIGluZGV4ID0gcGFyYW1zLmluZGV4IHx8IDA7XG5cbiAgICAgICAgcGFyYW1zLnRoZW1lID0gcGFyYW1zLnRoZW1lIHx8IHRoaXMudGhlbWVbY29tcG9uZW50VHlwZV07XG4gICAgICAgIHBhcmFtcy5vcHRpb25zID0gdGhpcy5fbWFrZUNvbXBvbmVudE9wdGlvbnMocGFyYW1zLm9wdGlvbnMsIGNvbXBvbmVudFR5cGUsIGluZGV4KTtcblxuICAgICAgICBwYXJhbXMuZGF0YVByb2Nlc3NvciA9IHRoaXMuZGF0YVByb2Nlc3NvcjtcbiAgICAgICAgcGFyYW1zLmJvdW5kc01ha2VyID0gdGhpcy5ib3VuZHNNYWtlcjtcbiAgICAgICAgcGFyYW1zLmhhc0F4ZXMgPSB0aGlzLmhhc0F4ZXM7XG5cbiAgICAgICAgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudChwYXJhbXMpO1xuICAgICAgICBjb21wb25lbnQuY29tcG9uZW50TmFtZSA9IG5hbWU7XG4gICAgICAgIGNvbXBvbmVudC5jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcblxuICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hcFtuYW1lXSA9IGNvbXBvbmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBlYWNoIGNvbXBvbmVudHMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgaXRlcmF0ZWVcbiAgICAgKi9cbiAgICBlYWNoOiBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5jb21wb25lbnRzLCBpdGVyYXRlZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBjb21wb25lbnRzLlxuICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBpdGVyYXRlZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gY29tcG9uZW50c1xuICAgICAqL1xuICAgIG1hcDogZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0aGlzLmNvbXBvbmVudHMsIGl0ZXJhdGVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBjb21wb25lbnRzIHRvIGNvbmRpdGlvbk1hcC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZGl0aW9uTWFwIGNvbmRpdGlvbiBtYXBcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59IGZpbHRlcmVkIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICB3aGVyZTogZnVuY3Rpb24oY29uZGl0aW9uTWFwKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5maWx0ZXIodGhpcy5jb21wb25lbnRzLCBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGNvbmRpdGlvbk1hcCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRba2V5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVkO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb21wb25lbnQgbmFtZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRNYXBbbmFtZV07XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50TWFuYWdlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBMaW5lIGNoYXJ0XG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpLFxuICAgIGxpbmVUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2xpbmVUeXBlTWl4ZXInKSxcbiAgICBheGlzVHlwZU1peGVyID0gcmVxdWlyZSgnLi9heGlzVHlwZU1peGVyJyksXG4gICAgU2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL2xpbmVDaGFydFNlcmllcycpO1xuXG52YXIgTGluZUNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIExpbmVDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIGNsYXNzTmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgY2xhc3NOYW1lOiAndHVpLWxpbmUtY2hhcnQnLFxuXG4gICAgLyoqXG4gICAgICogU2VyaWVzIGNsYXNzXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIFNlcmllczogU2VyaWVzLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBMaW5lQ2hhcnRcbiAgICAgKiBAZXh0ZW5kcyBDaGFydEJhc2VcbiAgICAgKiBAbWl4ZXMgYXhpc1R5cGVNaXhlclxuICAgICAqIEBtaXhlcyBsaW5lVHlwZU1peGVyXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xpbmVUeXBlSW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbn0pO1xuXG5heGlzVHlwZU1peGVyLm1peGluKExpbmVDaGFydCk7XG5saW5lVHlwZU1peGVyLm1peGluKExpbmVDaGFydCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZUNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGxpbmVUeXBlTWl4ZXIgaXMgbWl4ZXIgb2YgbGluZSB0eXBlIGNoYXJ0KGxpbmUsIGFyZWEpLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2hhcnRCYXNlID0gcmVxdWlyZSgnLi9jaGFydEJhc2UnKSxcbiAgICBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpLFxuICAgIGF4aXNEYXRhTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2F4aXNEYXRhTWFrZXInKSxcbiAgICBBcmVhVHlwZUN1c3RvbUV2ZW50ID0gcmVxdWlyZSgnLi4vY3VzdG9tRXZlbnRzL2FyZWFUeXBlQ3VzdG9tRXZlbnQnKTtcblxuLyoqXG4gKiBsaW5lVHlwZU1peGVyIGlzIG1peGVyIG9mIGxpbmUgdHlwZSBjaGFydChsaW5lLCBhcmVhKS5cbiAqIEBtaXhpblxuICovXG52YXIgbGluZVR5cGVNaXhlciA9IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGxpbmUgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbGluZVR5cGVJbml0OiBmdW5jdGlvbihyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICBDaGFydEJhc2UuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICByYXdEYXRhOiByYXdEYXRhLFxuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGhhc0F4ZXM6IHRydWUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHMob3B0aW9ucy5jaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGF4ZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGF4ZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBeGVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYXhpc1NjYWxlTWFrZXIgPSB0aGlzLl9jcmVhdGVBeGlzU2NhbGVNYWtlcih7XG4gICAgICAgICAgICAgICAgbWluOiBvcHRpb25zLnlBeGlzLm1pbixcbiAgICAgICAgICAgICAgICBtYXg6IG9wdGlvbnMueUF4aXMubWF4XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgYXJlYVR5cGU6ICd5QXhpcydcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWxpZ25lZCA9IHByZWRpY2F0ZS5pc0xpbmVUeXBlQ2hhcnQob3B0aW9ucy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgeEF4aXNEYXRhID0gYXhpc0RhdGFNYWtlci5tYWtlTGFiZWxBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgbGFiZWxzOiB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Q2F0ZWdvcmllcygpLFxuICAgICAgICAgICAgICAgIGFsaWduZWQ6IGFsaWduZWQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucy54QXhpc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB5QXhpc0RhdGEgPSBheGlzRGF0YU1ha2VyLm1ha2VWYWx1ZUF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICBheGlzU2NhbGVNYWtlcjogYXhpc1NjYWxlTWFrZXIsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgICAgIGFsaWduZWQ6IGFsaWduZWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4QXhpczogeEF4aXNEYXRhLFxuICAgICAgICAgICAgeUF4aXM6IHlBeGlzRGF0YVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudCBmb3Igbm9ybWFsIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ3VzdG9tRXZlbnRDb21wb25lbnRGb3JOb3JtYWxUb29sdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCdjdXN0b21FdmVudCcsIEFyZWFUeXBlQ3VzdG9tRXZlbnQsIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0aGlzLmlzVmVydGljYWxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjb21wb25lbnRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ29tcG9uZW50czogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHNGb3JBeGlzVHlwZSh7XG4gICAgICAgICAgICBheGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneUF4aXMnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4QXhpcycsXG4gICAgICAgICAgICAgICAgICAgIGlzTGFiZWw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICBzZXJpZXNlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5vcHRpb25zLmNoYXJ0VHlwZSArICdTZXJpZXMnLFxuICAgICAgICAgICAgICAgICAgICBTZXJpZXNDbGFzczogdGhpcy5TZXJpZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGNoYXJ0IGVsZW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQ2hhcnRCYXNlLnByb3RvdHlwZS5yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWl4IGluLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgdGFyZ2V0IGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIG1peGluOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIHR1aS51dGlsLmV4dGVuZChmdW5jLnByb3RvdHlwZSwgdGhpcyk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBsaW5lVHlwZU1peGVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hcCBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgTWFwQ2hhcnRNYXBNb2RlbCA9IHJlcXVpcmUoJy4vbWFwQ2hhcnRNYXBNb2RlbCcpLFxuICAgIE1hcENoYXJ0Q29sb3JNb2RlbCA9IHJlcXVpcmUoJy4vbWFwQ2hhcnRDb2xvck1vZGVsJyksXG4gICAgTWFwQ2hhcnREYXRhUHJvY2Vzc29yID0gcmVxdWlyZSgnLi4vZGF0YU1vZGVscy9tYXBDaGFydERhdGFQcm9jZXNzb3InKSxcbiAgICBheGlzRGF0YU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9heGlzRGF0YU1ha2VyJyksXG4gICAgU2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL21hcENoYXJ0U2VyaWVzJyksXG4gICAgWm9vbSA9IHJlcXVpcmUoJy4uL3Nlcmllcy96b29tJyksXG4gICAgTGVnZW5kID0gcmVxdWlyZSgnLi4vbGVnZW5kcy9tYXBDaGFydExlZ2VuZCcpLFxuICAgIE1hcENoYXJ0VG9vbHRpcCA9IHJlcXVpcmUoJy4uL3Rvb2x0aXBzL21hcENoYXJ0VG9vbHRpcCcpLFxuICAgIG1hcENoYXJ0Q3VzdG9tRXZlbnQgPSByZXF1aXJlKCcuLi9jdXN0b21FdmVudHMvbWFwQ2hhcnRDdXN0b21FdmVudCcpO1xuXG52YXIgTWFwQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDaGFydEJhc2UsIC8qKiBAbGVuZHMgTWFwQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBNYXAgY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgTWFwQ2hhcnRcbiAgICAgKiBAZXh0ZW5kcyBDaGFydEJhc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsYXNzIG5hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1tYXAtY2hhcnQnO1xuXG4gICAgICAgIG9wdGlvbnMudG9vbHRpcCA9IG9wdGlvbnMudG9vbHRpcCB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5sZWdlbmQgPSBvcHRpb25zLmxlZ2VuZCB8fCB7fTtcblxuICAgICAgICBDaGFydEJhc2UuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICByYXdEYXRhOiByYXdEYXRhLFxuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIERhdGFQcm9jZXNzb3I6IE1hcENoYXJ0RGF0YVByb2Nlc3NvclxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMubGVnZW5kID0gb3B0aW9ucy5sZWdlbmQgfHwge307XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCdsZWdlbmQnLCBMZWdlbmQpO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcigndG9vbHRpcCcsIE1hcENoYXJ0VG9vbHRpcCwgdGhpcy5fbWFrZVRvb2x0aXBEYXRhKCkpO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcignbWFwU2VyaWVzJywgU2VyaWVzLCB7XG4gICAgICAgICAgICBsaWJUeXBlOiBvcHRpb25zLmxpYlR5cGUsXG4gICAgICAgICAgICBjaGFydFR5cGU6IG9wdGlvbnMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50VHlwZTogJ3NlcmllcycsXG4gICAgICAgICAgICB1c2VyRXZlbnQ6IHRoaXMudXNlckV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ3pvb20nLCBab29tKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGN1c3RvbSBldmVudCBjb21wb25lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ3VzdG9tRXZlbnRDb21wb25lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2N1c3RvbUV2ZW50JywgbWFwQ2hhcnRDdXN0b21FdmVudCwge1xuICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBheGVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBheGVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhlc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXhpc1NjYWxlTWFrZXIgPSB0aGlzLl9jcmVhdGVBeGlzU2NhbGVNYWtlcih7fSwge1xuICAgICAgICAgICAgdmFsdWVDb3VudDogY2hhcnRDb25zdC5NQVBfQ0hBUlRfTEVHRU5EX1RJQ0tfQ09VTlRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGF4aXNEYXRhTWFrZXIubWFrZVZhbHVlQXhpc0RhdGEoe1xuICAgICAgICAgICAgYXhpc1NjYWxlTWFrZXI6IGF4aXNTY2FsZU1ha2VyLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2FkZERhdGFSYXRpb3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXhlc0RhdGEgPSB0aGlzLmJvdW5kc01ha2VyLmdldEF4ZXNEYXRhKCk7XG5cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLmFkZERhdGFSYXRpb3MoYXhlc0RhdGEubGltaXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJlbmRlcmluZyBkYXRhIGZvciBtYXAgY2hhcnQuXG4gICAgICogQHJldHVybnMge29iamVjdH0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZVJlbmRlcmluZ0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXhlc0RhdGEgPSB0aGlzLmJvdW5kc01ha2VyLmdldEF4ZXNEYXRhKCk7XG4gICAgICAgIHZhciBzZXJpZXNUaGVtZSA9IHRoaXMudGhlbWUuc2VyaWVzO1xuICAgICAgICB2YXIgY29sb3JNb2RlbCA9IG5ldyBNYXBDaGFydENvbG9yTW9kZWwoc2VyaWVzVGhlbWUuc3RhcnRDb2xvciwgc2VyaWVzVGhlbWUuZW5kQ29sb3IpO1xuICAgICAgICB2YXIgbWFwTW9kZWwgPSBuZXcgTWFwQ2hhcnRNYXBNb2RlbCh0aGlzLmRhdGFQcm9jZXNzb3IsIHRoaXMub3B0aW9ucy5tYXApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICBjb2xvck1vZGVsOiBjb2xvck1vZGVsLFxuICAgICAgICAgICAgICAgIGF4ZXNEYXRhOiBheGVzRGF0YVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcFNlcmllczoge1xuICAgICAgICAgICAgICAgIG1hcE1vZGVsOiBtYXBNb2RlbCxcbiAgICAgICAgICAgICAgICBjb2xvck1vZGVsOiBjb2xvck1vZGVsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgIG1hcE1vZGVsOiBtYXBNb2RlbFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggY3VzdG9tIGV2bmV0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1c3RvbUV2ZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnY3VzdG9tRXZlbnQnKSxcbiAgICAgICAgICAgIG1hcFNlcmllcyA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ21hcFNlcmllcycpLFxuICAgICAgICAgICAgbGVnZW5kID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnbGVnZW5kJyksXG4gICAgICAgICAgICB0b29sdGlwID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgndG9vbHRpcCcpLFxuICAgICAgICAgICAgem9vbSA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ3pvb20nKTtcblxuICAgICAgICBjdXN0b21FdmVudC5vbih7XG4gICAgICAgICAgICBjbGlja01hcFNlcmllczogbWFwU2VyaWVzLm9uQ2xpY2tTZXJpZXMsXG4gICAgICAgICAgICBtb3ZlTWFwU2VyaWVzOiBtYXBTZXJpZXMub25Nb3ZlU2VyaWVzLFxuICAgICAgICAgICAgZHJhZ1N0YXJ0TWFwU2VyaWVzOiBtYXBTZXJpZXMub25EcmFnU3RhcnRTZXJpZXMsXG4gICAgICAgICAgICBkcmFnTWFwU2VyaWVzOiBtYXBTZXJpZXMub25EcmFnU2VyaWVzLFxuICAgICAgICAgICAgZHJhZ0VuZE1hcFNlcmllczogbWFwU2VyaWVzLm9uRHJhZ0VuZFNlcmllcyxcbiAgICAgICAgICAgIHdoZWVsOiB0dWkudXRpbC5iaW5kKHpvb20ub25XaGVlbCwgem9vbSlcbiAgICAgICAgfSwgbWFwU2VyaWVzKTtcblxuICAgICAgICBtYXBTZXJpZXMub24oe1xuICAgICAgICAgICAgc2hvd1dlZGdlOiBsZWdlbmQub25TaG93V2VkZ2UsXG4gICAgICAgICAgICBoaWRlV2VkZ2U6IGxlZ2VuZC5vbkhpZGVXZWRnZVxuICAgICAgICB9LCBsZWdlbmQpO1xuXG4gICAgICAgIG1hcFNlcmllcy5vbih7XG4gICAgICAgICAgICBzaG93VG9vbHRpcDogdG9vbHRpcC5vblNob3csXG4gICAgICAgICAgICBoaWRlVG9vbHRpcDogdG9vbHRpcC5vbkhpZGUsXG4gICAgICAgICAgICBzaG93VG9vbHRpcENvbnRhaW5lcjogdG9vbHRpcC5vblNob3dUb29sdGlwQ29udGFpbmVyLFxuICAgICAgICAgICAgaGlkZVRvb2x0aXBDb250YWluZXI6IHRvb2x0aXAub25IaWRlVG9vbHRpcENvbnRhaW5lclxuICAgICAgICB9LCB0b29sdGlwKTtcblxuICAgICAgICB6b29tLm9uKCd6b29tJywgbWFwU2VyaWVzLm9uWm9vbSwgbWFwU2VyaWVzLCBtYXBTZXJpZXMpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hcENoYXJ0Q29sb3JNb2RlbCBpcyBjb2xvciBtb2RlbCBmb3IgbWFwIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29sb3J1dGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb2xvcnV0aWwnKTtcblxudmFyIE1hcENoYXJ0Q29sb3JNb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgTWFwQ2hhcnRDb2xvck1vZGVsLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTWFwQ2hhcnRDb2xvck1vZGVsIGlzIGxlZ2VuZCBtb2RlbC5cbiAgICAgKiBAY29uc3RydWN0cyBNYXBDaGFydENvbG9yTW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRDb2xvciBoZXggY29sb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kQ29sb3IgaGV4IGNvbG9yXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oc3RhcnRDb2xvciwgZW5kQ29sb3IpIHtcbiAgICAgICAgdmFyIGVuZFJHQjtcblxuICAgICAgICB0aGlzLnN0YXJ0ID0gY29sb3J1dGlsLmNvbG9yTmFtZVRvSGV4KHN0YXJ0Q29sb3IpO1xuICAgICAgICB0aGlzLnN0YXJ0UkdCID0gY29sb3J1dGlsLmhleFRvUkdCKHRoaXMuc3RhcnQpO1xuICAgICAgICB0aGlzLmVuZCA9IGNvbG9ydXRpbC5jb2xvck5hbWVUb0hleChlbmRDb2xvcik7XG5cbiAgICAgICAgZW5kUkdCID0gY29sb3J1dGlsLmhleFRvUkdCKHRoaXMuZW5kKTtcbiAgICAgICAgdGhpcy5kaXN0YW5jZXMgPSB0aGlzLl9tYWtlRGlzdGFuY2VzKHRoaXMuc3RhcnRSR0IsIGVuZFJHQik7XG4gICAgICAgIHRoaXMuY29sb3JNYXAgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBkaXN0YW5jZXMgc3RhcnQgUkdCIHRvIGVuZCBSR0IuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gc3RhcnRSR0Igc3RhcnQgUkdCXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZW5kUkdCIGVuZCBSR0JcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IGRpc3RhbmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VEaXN0YW5jZXM6IGZ1bmN0aW9uKHN0YXJ0UkdCLCBlbmRSR0IpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChzdGFydFJHQiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kUkdCW2luZGV4XSAtIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGhleCBjb2xvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gcmF0aW9cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBoZXggY29sb3JcbiAgICAgKi9cbiAgICBnZXRDb2xvcjogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgdmFyIGhleENvbG9yID0gdGhpcy5jb2xvck1hcFtyYXRpb10sXG4gICAgICAgICAgICBkaXN0YW5jZXMsIHJnYkNvbG9yO1xuXG4gICAgICAgIGlmICghaGV4Q29sb3IpIHtcbiAgICAgICAgICAgIGRpc3RhbmNlcyA9IHRoaXMuZGlzdGFuY2VzO1xuICAgICAgICAgICAgcmdiQ29sb3IgPSB0dWkudXRpbC5tYXAodGhpcy5zdGFydFJHQiwgZnVuY3Rpb24oc3RhcnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgcGFyc2VJbnQoZGlzdGFuY2VzW2luZGV4XSAqIHJhdGlvLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhleENvbG9yID0gY29sb3J1dGlsLnJnYlRvSEVYLmFwcGx5KG51bGwsIHJnYkNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZXhDb2xvcjtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDaGFydENvbG9yTW9kZWw7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFwQ2hhcnRNYXBNb2RlbCBpcyBtYXAgbW9kZWwgb2YgbWFwIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbnZhciBNYXBDaGFydE1hcE1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBNYXBDaGFydE1hcE1vZGVsLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTWFwQ2hhcnRNYXBNb2RlbCBpcyBtYXAgbW9kZWwgb2YgbWFwIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIE1hcENoYXJ0TWFwTW9kZWxcbiAgICAgKiBAcGFyYW0ge01hcENoYXJ0RGF0YVByb2Nlc3Nvcn0gZGF0YVByb2Nlc3NvciBNYXAgY2hhcnQgZGF0YSBwcm9jZXNzb3JcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGxhYmVsQ29vcmRpbmF0ZTogP3t4OiBudW1iZXIsIHk6bnVtYmVyfX0+fSByYXdNYXBEYXRhIHJhdyBtYXAgZGF0YVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKGRhdGFQcm9jZXNzb3IsIHJhd01hcERhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbW1hbmQgZnVuY3Rpb24gbWFwLlxuICAgICAgICAgKiBAdHlwZSB7e1xuICAgICAgICAgKiAgICAgIE06IE1hcENoYXJ0TWFwTW9kZWwuX21ha2VDb29yZGluYXRlLCBtOiBNYXBDaGFydE1hcE1vZGVsLl9tYWtlQ29vcmRpbmF0ZUZyb21SZWxhdGl2ZUNvb3JkaW5hdGUsXG4gICAgICAgICAqICAgICAgTDogTWFwQ2hhcnRNYXBNb2RlbC5fbWFrZUNvb3JkaW5hdGUsIGw6IE1hcENoYXJ0TWFwTW9kZWwuX21ha2VDb29yZGluYXRlRnJvbVJlbGF0aXZlQ29vcmRpbmF0ZSxcbiAgICAgICAgICogICAgICBIOiBNYXBDaGFydE1hcE1vZGVsLl9tYWtlWENvb3JkaW5hdGUsIGg6IE1hcENoYXJ0TWFwTW9kZWwuX21ha2VYQ29vcmRpbmF0ZUZyb1JlbGF0aXZlQ29vcmRpbmF0ZSxcbiAgICAgICAgICogICAgICBWOiBNYXBDaGFydE1hcE1vZGVsLl9tYWtlWUNvb3JkaW5hdGUsIHY6IE1hcENoYXJ0TWFwTW9kZWwuX21ha2VZQ29vcmRpbmF0ZUZyb21SZWxhdGl2ZUNvb3JkaW5hdGVcbiAgICAgICAgICogfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tbWFuZEZ1bmNNYXAgPSB7XG4gICAgICAgICAgICBNOiB0dWkudXRpbC5iaW5kKHRoaXMuX21ha2VDb29yZGluYXRlLCB0aGlzKSxcbiAgICAgICAgICAgIG06IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZUNvb3JkaW5hdGVGcm9tUmVsYXRpdmVDb29yZGluYXRlLCB0aGlzKSxcbiAgICAgICAgICAgIEw6IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZUNvb3JkaW5hdGUsIHRoaXMpLFxuICAgICAgICAgICAgbDogdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlQ29vcmRpbmF0ZUZyb21SZWxhdGl2ZUNvb3JkaW5hdGUsIHRoaXMpLFxuICAgICAgICAgICAgSDogdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlWENvb3JkaW5hdGUsIHRoaXMpLFxuICAgICAgICAgICAgaDogdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlWENvb3JkaW5hdGVGcm9SZWxhdGl2ZUNvb3JkaW5hdGUsIHRoaXMpLFxuICAgICAgICAgICAgVjogdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlWUNvb3JkaW5hdGUsIHRoaXMpLFxuICAgICAgICAgICAgdjogdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlWUNvb3JkaW5hdGVGcm9tUmVsYXRpdmVDb29yZGluYXRlLCB0aGlzKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZ25vcmUgY29tbWFuZCBtYXAuXG4gICAgICAgICAqIEB0eXBlIHt7WjogYm9vbGVhbiwgejogYm9vbGVhbn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlnbm9yZUNvbW1hbmRNYXAgPSB7XG4gICAgICAgICAgICBaOiB0cnVlLFxuICAgICAgICAgICAgejogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgZGF0YS5cbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBEYXRhID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBkaW1lbnNpb25cbiAgICAgICAgICogQHR5cGUge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcERpbWVuc2lvbiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBjaGFydCBkYXRhIHByb2Nlc3Nvci5cbiAgICAgICAgICogQHR5cGUge01hcENoYXJ0RGF0YVByb2Nlc3Nvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IGRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlTWFwRGF0YShyYXdNYXBEYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgY29vcmRpbmF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkaW5hdGVTdHIgY29vcmRpbmF0ZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gY29vcmRpbmF0ZSBtYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zcGxpdENvb3JkaW5hdGU6IGZ1bmN0aW9uKGNvb3JkaW5hdGVTdHIpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZVN0ci5zcGxpdCgnLCcpLFxuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHg6IHBhcnNlRmxvYXQoY29vcmRpbmF0ZXNbMF0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb29yZGluYXRlc1sxXSkge1xuICAgICAgICAgICAgcmVzdWx0LnkgPSBwYXJzZUZsb2F0KGNvb3JkaW5hdGVzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZGluYXRlU3RyIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDb29yZGluYXRlOiBmdW5jdGlvbihjb29yZGluYXRlU3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zcGxpdENvb3JkaW5hdGUoY29vcmRpbmF0ZVN0cik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY29vcmRpbmF0ZSBmcm9tIHJlbGF0aXZlIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkaW5hdGVTdHIgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcHJldkNvb3JkaW5hdGUgcHJldmlvdXMgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBjb29yZGluYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNvb3JkaW5hdGVGcm9tUmVsYXRpdmVDb29yZGluYXRlOiBmdW5jdGlvbihjb29yZGluYXRlU3RyLCBwcmV2Q29vcmRpbmF0ZSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IHRoaXMuX3NwbGl0Q29vcmRpbmF0ZShjb29yZGluYXRlU3RyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY29vcmRpbmF0ZS54ICsgcHJldkNvb3JkaW5hdGUueCxcbiAgICAgICAgICAgIHk6IGNvb3JkaW5hdGUueSArIHByZXZDb29yZGluYXRlLnlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkaW5hdGVTdHIgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyfX0geCBjb29yZGluYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVhDb29yZGluYXRlOiBmdW5jdGlvbihjb29yZGluYXRlU3RyKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlID0gdGhpcy5fc3BsaXRDb29yZGluYXRlKGNvb3JkaW5hdGVTdHIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjb29yZGluYXRlLnhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB4IGNvb3JkaW5hdGUgZnJvbSByZWxhdGl2ZSBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZGluYXRlU3RyIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHByZXZDb29yZGluYXRlIHByZXZpb3VzIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlcn19IHggY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VYQ29vcmRpbmF0ZUZyb1JlbGF0aXZlQ29vcmRpbmF0ZTogZnVuY3Rpb24oY29vcmRpbmF0ZVN0ciwgcHJldkNvb3JkaW5hdGUpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSB0aGlzLl9zcGxpdENvb3JkaW5hdGUoY29vcmRpbmF0ZVN0cik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNvb3JkaW5hdGUueCArIHByZXZDb29yZGluYXRlLnhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB5IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkaW5hdGVTdHIgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHt7eTogbnVtYmVyfX0geSBjb29yZGluYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVlDb29yZGluYXRlOiBmdW5jdGlvbihjb29yZGluYXRlU3RyKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlID0gdGhpcy5fc3BsaXRDb29yZGluYXRlKGNvb3JkaW5hdGVTdHIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5OiBjb29yZGluYXRlLnhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB5IGNvb3JkaW5hdGUgZnJvbSByZWxhdGl2ZSBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZGluYXRlU3RyIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHByZXZDb29yZGluYXRlIHByZXZpb3VzIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7e3k6IG51bWJlcn19IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VZQ29vcmRpbmF0ZUZyb21SZWxhdGl2ZUNvb3JkaW5hdGU6IGZ1bmN0aW9uKGNvb3JkaW5hdGVTdHIsIHByZXZDb29yZGluYXRlKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlID0gdGhpcy5fc3BsaXRDb29yZGluYXRlKGNvb3JkaW5hdGVTdHIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5OiBjb29yZGluYXRlLnggKyBwcmV2Q29vcmRpbmF0ZS55XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNwbGl0IHBhdGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e3R5cGU6IHN0cmluZywgY29vcmRpbmF0ZTogc3RyaW5nfT59IHNwbGl0dGVkIHBhdGggZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NwbGl0UGF0aDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIHBhdGhEYXRhID0gW10sXG4gICAgICAgICAgICBjb29yZGluYXRlID0gJycsXG4gICAgICAgICAgICBjaHIsIGNvbW1hbmRUeXBlO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNociA9IHBhdGguY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tbWFuZEZ1bmNNYXBbY2hyXSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kVHlwZSAmJiBjb29yZGluYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29tbWFuZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlOiBjb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21tYW5kVHlwZSA9IGNocjtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlID0gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlnbm9yZUNvbW1hbmRNYXBbY2hyXSkge1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUgKz0gY2hyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1hbmRUeXBlICYmIGNvb3JkaW5hdGUpIHtcbiAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGNvbW1hbmRUeXBlLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGU6IGNvb3JkaW5hdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGhEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNvb3JkaW5hdGVzIGZyb20gcGF0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7eDogbnVtYmVyLCB5OiBudW1iZXJ9Pn0gY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ29vcmRpbmF0ZXNGcm9tUGF0aDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBwYXRoRGF0YSA9IHRoaXMuX3NwbGl0UGF0aChwYXRoKSxcbiAgICAgICAgICAgIHByZXZDb29yZGluYXRlID0ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHBhdGhEYXRhLCBmdW5jdGlvbihkYXR1bSkge1xuICAgICAgICAgICAgdmFyIGNvbW1hbmRGdW5jID0gc2VsZi5jb21tYW5kRnVuY01hcFtkYXR1bS50eXBlXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlID0gY29tbWFuZEZ1bmMoZGF0dW0uY29vcmRpbmF0ZSwgcHJldkNvb3JkaW5hdGUpO1xuXG4gICAgICAgICAgICB0dWkudXRpbC5leHRlbmQocHJldkNvb3JkaW5hdGUsIGNvb3JkaW5hdGUpO1xuXG4gICAgICAgICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYm91bmQgZnJvbSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn0+fSBjb29yZGluYXRlcyBjb29yZGluYXRlc1xuICAgICAqIEByZXR1cm5zIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fX0gYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kQm91bmRGcm9tQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHZhciB4cyA9IHR1aS51dGlsLmZpbHRlcih0dWkudXRpbC5wbHVjayhjb29yZGluYXRlcywgJ3gnKSwgZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdHVpLnV0aWwuaXNVbmRlZmluZWQoeCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHlzID0gdHVpLnV0aWwuZmlsdGVyKHR1aS51dGlsLnBsdWNrKGNvb3JkaW5hdGVzLCAneScpLCBmdW5jdGlvbih5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0dWkudXRpbC5pc1VuZGVmaW5lZCh5KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWF4TGVmdCA9IHR1aS51dGlsLm1heCh4cyksXG4gICAgICAgICAgICBtaW5MZWZ0ID0gdHVpLnV0aWwubWluKHhzKSxcbiAgICAgICAgICAgIG1heFRvcCA9IHR1aS51dGlsLm1heCh5cyksXG4gICAgICAgICAgICBtaW5Ub3AgPSB0dWkudXRpbC5taW4oeXMpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaW1lbnNpb246IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogbWF4TGVmdCAtIG1pbkxlZnQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtYXhUb3AgLSBtaW5Ub3BcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IG1pbkxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBtaW5Ub3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsYWJlbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIHBvc2l0aW9uOiB7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19fSBib3VuZCBib3VuZFxuICAgICAqIEBwYXJhbSB7P3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb25SYXRpbyBwb3NpdGlvbiByYXRpb1xuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGxhYmVsIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxhYmVsUG9zaXRpb246IGZ1bmN0aW9uKGJvdW5kLCBwb3NpdGlvblJhdGlvKSB7XG4gICAgICAgIHBvc2l0aW9uUmF0aW8gPSBwb3NpdGlvblJhdGlvIHx8IGNoYXJ0Q29uc3QuTUFQX0NIQVJUX0xBQkVMX0RFRkFVTFRfUE9TSVRJT05fUkFUSU87XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kLnBvc2l0aW9uLmxlZnQgKyAoYm91bmQuZGltZW5zaW9uLndpZHRoICogcG9zaXRpb25SYXRpby54KSxcbiAgICAgICAgICAgIHRvcDogYm91bmQucG9zaXRpb24udG9wICsgKGJvdW5kLmRpbWVuc2lvbi5oZWlnaHQgKiBwb3NpdGlvblJhdGlvLnkpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBtYXAgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGxhYmVsQ29vcmRpbmF0ZTogP3t4OiBudW1iZXIsIHk6bnVtYmVyfX0+fSByYXdNYXBEYXRhIHJhdyBtYXAgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZU1hcERhdGE6IGZ1bmN0aW9uKHJhd01hcERhdGEpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMubWFwRGF0YSA9IHR1aS51dGlsLm1hcChyYXdNYXBEYXRhLCBmdW5jdGlvbihkYXR1bSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSBzZWxmLl9tYWtlQ29vcmRpbmF0ZXNGcm9tUGF0aChkYXR1bS5wYXRoKSxcbiAgICAgICAgICAgICAgICBib3VuZCA9IHNlbGYuX2ZpbmRCb3VuZEZyb21Db29yZGluYXRlcyhjb29yZGluYXRlKSxcbiAgICAgICAgICAgICAgICB1c2VyRGF0YSA9IHNlbGYuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZU1hcERhdHVtKGRhdHVtLmNvZGUpLFxuICAgICAgICAgICAgICAgIG5hbWUsIGxhYmVsQ29vcmRpbmF0ZSwgbGFiZWwsIHJhdGlvLCByZXN1bHREYXRhO1xuXG4gICAgICAgICAgICBpZiAodXNlckRhdGEpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IHVzZXJEYXRhLmxhYmVsO1xuICAgICAgICAgICAgICAgIHJhdGlvID0gdXNlckRhdGEucmF0aW87XG4gICAgICAgICAgICAgICAgbmFtZSA9IHVzZXJEYXRhLm5hbWUgfHwgZGF0dW0ubmFtZTtcbiAgICAgICAgICAgICAgICBsYWJlbENvb3JkaW5hdGUgPSB1c2VyRGF0YS5sYWJlbENvb3JkaW5hdGUgfHwgZGF0dW0ubGFiZWxDb29yZGluYXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHREYXRhID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGRhdHVtLmNvZGUsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBwYXRoOiBkYXR1bS5wYXRoLFxuICAgICAgICAgICAgICAgIGJvdW5kOiBib3VuZCxcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uOiBzZWxmLl9tYWtlTGFiZWxQb3NpdGlvbihib3VuZCwgbGFiZWxDb29yZGluYXRlKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0RGF0YS5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmF0aW8pIHtcbiAgICAgICAgICAgICAgICByZXN1bHREYXRhLnJhdGlvID0gcmF0aW87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHREYXRhO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0TWFwRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcERhdGE7XG4gICAgfSxcblxuICAgIGdldERhdHVtOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBEYXRhW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxhYmVsIGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIHJhdGlvXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7bmFtZTogc3RyaW5nLCBib3VuZDoge2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgICAgICBwb3NpdGlvbjoge3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSwgbGFiZWxQb3NpdGlvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0+fSBtYXAgZGF0YVxuICAgICAqL1xuICAgIGdldExhYmVsRGF0YTogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgbGFiZWxEYXRhID0gdHVpLnV0aWwuZmlsdGVyKHRoaXMubWFwRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5kYXRhUHJvY2Vzc29yLmdldFZhbHVlTWFwRGF0dW0oZGF0dW0uY29kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGxhYmVsRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZGF0dW0ubmFtZSxcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGRhdHVtLmxhYmVsUG9zaXRpb24ubGVmdCAqIHJhdGlvLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IGRhdHVtLmxhYmVsUG9zaXRpb24udG9wICogcmF0aW9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBtYXAgZGltZW5zaW9uXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IG1hcCBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTWFwRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1hcERhdGEgPSB0aGlzLm1hcERhdGEsXG4gICAgICAgICAgICBsZWZ0cyA9IHR1aS51dGlsLm1hcChtYXBEYXRhLCBmdW5jdGlvbihkYXR1bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXR1bS5ib3VuZC5wb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByaWdodHMgPSB0dWkudXRpbC5tYXAobWFwRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW0uYm91bmQucG9zaXRpb24ubGVmdCArIGRhdHVtLmJvdW5kLmRpbWVuc2lvbi53aWR0aDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdG9wcyA9IHR1aS51dGlsLm1hcChtYXBEYXRhLCBmdW5jdGlvbihkYXR1bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXR1bS5ib3VuZC5wb3NpdGlvbi50b3A7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGJvdHRvbXMgPSB0dWkudXRpbC5tYXAobWFwRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW0uYm91bmQucG9zaXRpb24udG9wICsgZGF0dW0uYm91bmQuZGltZW5zaW9uLmhlaWdodDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHR1aS51dGlsLm1heChyaWdodHMpIC0gdHVpLnV0aWwubWluKGxlZnRzKSxcbiAgICAgICAgICAgIGhlaWdodDogdHVpLnV0aWwubWF4KGJvdHRvbXMpIC0gdHVpLnV0aWwubWluKHRvcHMpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBtYXAgZGltZW5zaW9uLlxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBtYXAgZGltZW5zaW9uXG4gICAgICovXG4gICAgZ2V0TWFwRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcERpbWVuc2lvbikge1xuICAgICAgICAgICAgdGhpcy5tYXBEaW1lbnNpb24gPSB0aGlzLl9tYWtlTWFwRGltZW5zaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tYXBEaW1lbnNpb247XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2hhcnRNYXBNb2RlbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBQaWUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgTGVnZW5kID0gcmVxdWlyZSgnLi4vbGVnZW5kcy9sZWdlbmQnKSxcbiAgICBUb29sdGlwID0gcmVxdWlyZSgnLi4vdG9vbHRpcHMvdG9vbHRpcCcpLFxuICAgIFNlcmllcyA9IHJlcXVpcmUoJy4uL3Nlcmllcy9waWVDaGFydFNlcmllcycpLFxuICAgIFNpbXBsZUN1c3RvbUV2ZW50ID0gcmVxdWlyZSgnLi4vY3VzdG9tRXZlbnRzL3NpbXBsZUN1c3RvbUV2ZW50Jyk7XG5cbnZhciBQaWVDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKENoYXJ0QmFzZSwgLyoqIEBsZW5kcyBQaWVDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFBpZSBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBQaWVDaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktcGllLWNoYXJ0JztcblxuICAgICAgICBvcHRpb25zLnRvb2x0aXAgPSBvcHRpb25zLnRvb2x0aXAgfHwge307XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnRvb2x0aXAuYWxpZ24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMudG9vbHRpcC5hbGlnbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ERUZBVUxUX0FMSUdOX09QVElPTjtcbiAgICAgICAgfVxuXG4gICAgICAgIENoYXJ0QmFzZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIHJhd0RhdGE6IHJhd0RhdGEsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHModGhlbWUuY2hhcnQuYmFja2dyb3VuZCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjb21wb25lbnRzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0QmFja2dyb3VuZCBjaGFydCBiYWNrZ3JvdW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENvbXBvbmVudHM6IGZ1bmN0aW9uKGNoYXJ0QmFja2dyb3VuZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGVnZW5kQWxpZ24sIGlzUGllTGVnZW5kVHlwZTtcblxuICAgICAgICBvcHRpb25zLmxlZ2VuZCA9IG9wdGlvbnMubGVnZW5kIHx8IHt9O1xuICAgICAgICBsZWdlbmRBbGlnbiA9IG9wdGlvbnMubGVnZW5kICYmIG9wdGlvbnMubGVnZW5kLmFsaWduO1xuICAgICAgICBpc1BpZUxlZ2VuZFR5cGUgPSBwcmVkaWNhdGUuaXNQaWVMZWdlbmRBbGlnbihsZWdlbmRBbGlnbik7XG5cbiAgICAgICAgaWYgKCFpc1BpZUxlZ2VuZFR5cGUgJiYgIW9wdGlvbnMubGVnZW5kLmhpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCdsZWdlbmQnLCBMZWdlbmQsIHtcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IG9wdGlvbnMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogdGhpcy51c2VyRXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCd0b29sdGlwJywgVG9vbHRpcCwgdGhpcy5fbWFrZVRvb2x0aXBEYXRhKCkpO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcigncGllU2VyaWVzJywgU2VyaWVzLCB7XG4gICAgICAgICAgICBsaWJUeXBlOiBvcHRpb25zLmxpYlR5cGUsXG4gICAgICAgICAgICBjaGFydFR5cGU6IG9wdGlvbnMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50VHlwZTogJ3NlcmllcycsXG4gICAgICAgICAgICBjaGFydEJhY2tncm91bmQ6IGNoYXJ0QmFja2dyb3VuZCxcbiAgICAgICAgICAgIHVzZXJFdmVudDogdGhpcy51c2VyRXZlbnQsXG4gICAgICAgICAgICBsZWdlbmRBbGlnbjogaXNQaWVMZWdlbmRUeXBlICYmICFvcHRpb25zLmxlZ2VuZC5oaWRkZW4gPyBsZWdlbmRBbGlnbiA6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjdXN0b20gZXZlbnQgY29tcG9uZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCdjdXN0b21FdmVudCcsIFNpbXBsZUN1c3RvbUV2ZW50LCB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSByYXRpb3MuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfYWRkRGF0YVJhdGlvczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3Nvci5hZGREYXRhUmF0aW9zT2ZQaWVDaGFydCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggY3VzdG9tIGV2bmV0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1c3RvbUV2ZW50LCB0b29sdGlwLCBwaWVTZXJpZXM7XG5cbiAgICAgICAgQ2hhcnRCYXNlLnByb3RvdHlwZS5fYXR0YWNoQ3VzdG9tRXZlbnQuY2FsbCh0aGlzKTtcblxuICAgICAgICBjdXN0b21FdmVudCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ2N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIHRvb2x0aXAgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCd0b29sdGlwJyk7XG4gICAgICAgIHBpZVNlcmllcyA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ3BpZVNlcmllcycpO1xuXG4gICAgICAgIGN1c3RvbUV2ZW50Lm9uKHtcbiAgICAgICAgICAgIGNsaWNrUGllU2VyaWVzOiBwaWVTZXJpZXMub25DbGlja1NlcmllcyxcbiAgICAgICAgICAgIG1vdmVQaWVTZXJpZXM6IHBpZVNlcmllcy5vbk1vdmVTZXJpZXNcbiAgICAgICAgfSwgcGllU2VyaWVzKTtcblxuICAgICAgICBwaWVTZXJpZXMub24oe1xuICAgICAgICAgICAgc2hvd1Rvb2x0aXA6IHRvb2x0aXAub25TaG93LFxuICAgICAgICAgICAgaGlkZVRvb2x0aXA6IHRvb2x0aXAub25IaWRlLFxuICAgICAgICAgICAgc2hvd1Rvb2x0aXBDb250YWluZXI6IHRvb2x0aXAub25TaG93VG9vbHRpcENvbnRhaW5lcixcbiAgICAgICAgICAgIGhpZGVUb29sdGlwQ29udGFpbmVyOiB0b29sdGlwLm9uSGlkZVRvb2x0aXBDb250YWluZXJcbiAgICAgICAgfSwgdG9vbHRpcCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGllQ2hhcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUGljayBtaW5pbXVtIHZhbHVlIGZyb20gdmFsdWUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgdmFsdWUgYXJyYXlcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjb25kaXRpb24gY29uZGl0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgdGFyZ2V0IGNvbnRleHRcbiAqIEByZXR1cm5zIHsqfSBtaW5pbXVtIHZhbHVlXG4gKi9cbnZhciBtaW4gPSBmdW5jdGlvbihhcnIsIGNvbmRpdGlvbiwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQsIG1pblZhbHVlLCByZXN0O1xuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gIE1hdGgubWluLmFwcGx5KG51bGwsIGFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYXJyWzBdO1xuICAgICAgICBtaW5WYWx1ZSA9IGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIHJlc3VsdCwgMCk7XG4gICAgICAgIHJlc3QgPSBhcnIuc2xpY2UoMSk7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShyZXN0LCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGNvbXBhcmVWYWx1ZSA9IGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIGl0ZW0sIGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyZVZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IGNvbXBhcmVWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQaWNrIG1heGltdW0gdmFsdWUgZnJvbSB2YWx1ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyciB2YWx1ZSBhcnJheVxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNvbmRpdGlvbiBjb25kaXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCB0YXJnZXQgY29udGV4dFxuICogQHJldHVybnMgeyp9IG1heGltdW0gdmFsdWVcbiAqL1xudmFyIG1heCA9IGZ1bmN0aW9uKGFyciwgY29uZGl0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCwgbWF4VmFsdWUsIHJlc3Q7XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICByZXN1bHQgPSBNYXRoLm1heC5hcHBseShudWxsLCBhcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGFyclswXTtcbiAgICAgICAgbWF4VmFsdWUgPSBjb25kaXRpb24uY2FsbChjb250ZXh0LCByZXN1bHQsIDApO1xuICAgICAgICByZXN0ID0gYXJyLnNsaWNlKDEpO1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkocmVzdCwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb21wYXJlVmFsdWUgPSBjb25kaXRpb24uY2FsbChjb250ZXh0LCBpdGVtLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVWYWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBjb21wYXJlVmFsdWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogV2hldGhlciBvbmUgb2YgdGhlbSBpcyB0cnVlIG9yIG5vdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyciB0YXJnZXQgYXJyYXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBjb25kaXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCB0YXJnZXQgY29udGV4dFxuICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gKi9cbnZhciBhbnkgPSBmdW5jdGlvbihhcnIsIGNvbmRpdGlvbiwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoYXJyLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoY29uZGl0aW9uLmNhbGwoY29udGV4dCwgaXRlbSwgaW5kZXgsIGFycikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBbGwgb2YgdGhlbSBpcyB0cnVlIG9yIG5vdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyciB0YXJnZXQgYXJyYXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBjb25kaXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSB7W29iamVjdF19IGNvbnRleHQgdGFyZ2V0IGNvbnRleHRcbiAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICovXG52YXIgYWxsID0gZnVuY3Rpb24oYXJyLCBjb25kaXRpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoYXJyLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIGl0ZW0sIGluZGV4LCBhcnIpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIE1ha2UgdW5pcXVlIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyciB0YXJnZXQgYXJyYXlcbiAqIEBwYXJhbSB7P2Jvb2xlYW59IHNvcnRlZCB3aGV0aGVyIHNvcnRlZCBvciBub3QuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gaXRlcmF0ZWUgaXRlcmF0ZWUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCB0YXJnZXQgY29udGV4dFxuICogQHJldHVybnMge0FycmF5fSB1bmlxdWUgdmFsdWVzXG4gKi9cbnZhciB1bmlxdWUgPSBmdW5jdGlvbihhcnIsIHNvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIHByZXZWYWx1ZTtcblxuICAgIGlmICghdHVpLnV0aWwuaXNCb29sZWFuKHNvcnRlZCkpIHtcbiAgICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgICBpdGVyYXRlZSA9IHNvcnRlZDtcbiAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaXRlcmF0ZWUgPSBpdGVyYXRlZSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGFyciwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFsdWUgPSBpdGVyYXRlZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgYXJyKTtcbiAgICAgICAgICAgIGlmICghaW5kZXggfHwgcHJldlZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoYXJyLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gaXRlcmF0ZWUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGFycik7XG4gICAgICAgICAgICBpZiAodHVpLnV0aWwuaW5BcnJheSh2YWx1ZSwgcmVzdWx0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEFycmF5IHBpdm90LlxuICogQG1lbWJlck9mIG1vZHVsZTpjYWxjdWxhdG9yXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IGFycjJkIHRhcmdldCAyZCBhcnJheVxuICogQHJldHVybnMge0FycmF5LjxBcnJheT59IHBpdm90ZWQgMmQgYXJyYXlcbiAqL1xudmFyIHBpdm90ID0gZnVuY3Rpb24oYXJyMmQpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGxlbiA9IHR1aS51dGlsLm1heCh0dWkudXRpbC5tYXAoYXJyMmQsIGZ1bmN0aW9uKGFycikge1xuICAgICAgICByZXR1cm4gYXJyLmxlbmd0aDtcbiAgICB9KSk7XG4gICAgdmFyIGluZGV4O1xuXG4gICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGFycjJkLCBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgZm9yKGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0W2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0ucHVzaChhcnJbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCBsZW5ndGggYWZ0ZXIgZGVjaW1hbCBwb2ludC5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHJlc3VsdCBsZW5ndGhcbiAqL1xudmFyIGdldERlY2ltYWxMZW5ndGggPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciB2YWx1ZUFyciA9IFN0cmluZyh2YWx1ZSkuc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gdmFsdWVBcnIubGVuZ3RoID09PSAyID8gdmFsdWVBcnJbMV0ubGVuZ3RoIDogMDtcbn07XG5cbi8qKlxuICogRmluZCBtdWx0aXBsZSBudW0uXG4gKiBAcGFyYW0gey4uLkFycmF5fSB0YXJnZXQgdmFsdWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtdWx0aXBsZSBudW1cbiAqL1xudmFyIGZpbmRNdWx0aXBsZU51bSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICB1bmRlclBvaW50TGVucyA9IHR1aS51dGlsLm1hcChhcmdzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLmdldERlY2ltYWxMZW5ndGgodmFsdWUpO1xuICAgICAgICB9KSxcbiAgICAgICAgdW5kZXJQb2ludExlbiA9IHR1aS51dGlsLm1heCh1bmRlclBvaW50TGVucyksXG4gICAgICAgIG11bHRpcGxlTnVtID0gTWF0aC5wb3coMTAsIHVuZGVyUG9pbnRMZW4pO1xuICAgIHJldHVybiBtdWx0aXBsZU51bTtcbn07XG5cbi8qKlxuICogTW9kdWxvIG9wZXJhdGlvbiBmb3IgZmxvYXRpbmcgcG9pbnQgb3BlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldCB0YXJnZXQgdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kTnVtIG1vZCBudW1cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHJlc3VsdCBtb2RcbiAqL1xudmFyIG1vZCA9IGZ1bmN0aW9uKHRhcmdldCwgbW9kTnVtKSB7XG4gICAgdmFyIG11bHRpcGxlTnVtID0gdHVpLnV0aWwuZmluZE11bHRpcGxlTnVtKG1vZE51bSk7XG4gICAgcmV0dXJuICgodGFyZ2V0ICogbXVsdGlwbGVOdW0pICUgKG1vZE51bSAqIG11bHRpcGxlTnVtKSkgLyBtdWx0aXBsZU51bTtcbn07XG5cbi8qKlxuICogQWRkaXRpb24gZm9yIGZsb2F0aW5nIHBvaW50IG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhIHRhcmdldCBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiB0YXJnZXQgYlxuICogQHJldHVybnMge251bWJlcn0gYWRkaXRpb24gcmVzdWx0XG4gKi9cbnZhciBhZGRpdGlvbiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgbXVsdGlwbGVOdW0gPSBmaW5kTXVsdGlwbGVOdW0oYSwgYik7XG4gICAgcmV0dXJuICgoYSAqIG11bHRpcGxlTnVtKSArIChiICogbXVsdGlwbGVOdW0pKSAvIG11bHRpcGxlTnVtO1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdGlvbiBmb3IgZmxvYXRpbmcgcG9pbnQgb3BlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGEgdGFyZ2V0IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIHRhcmdldCBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzdWJ0cmFjdGlvbiByZXN1bHRcbiAqL1xudmFyIHN1YnRyYWN0aW9uID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBtdWx0aXBsZU51bSA9IGZpbmRNdWx0aXBsZU51bShhLCBiKTtcbiAgICByZXR1cm4gKChhICogbXVsdGlwbGVOdW0pIC0gKGIgKiBtdWx0aXBsZU51bSkpIC8gbXVsdGlwbGVOdW07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpY2F0aW9uIGZvciBmbG9hdGluZyBwb2ludCBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gYSB0YXJnZXQgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgdGFyZ2V0IGJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG11bHRpcGxpY2F0aW9uIHJlc3VsdFxuICovXG52YXIgbXVsdGlwbGljYXRpb24gPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIG11bHRpcGxlTnVtID0gZmluZE11bHRpcGxlTnVtKGEsIGIpO1xuICAgIHJldHVybiAoKGEgKiBtdWx0aXBsZU51bSkgKiAoYiAqIG11bHRpcGxlTnVtKSkgLyAobXVsdGlwbGVOdW0gKiBtdWx0aXBsZU51bSk7XG59O1xuXG4vKipcbiAqIERpdmlzaW9uIGZvciBmbG9hdGluZyBwb2ludCBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gYSB0YXJnZXQgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgdGFyZ2V0IGJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRpdmlzaW9uIHJlc3VsdFxuICovXG52YXIgZGl2aXNpb24gPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIG11bHRpcGxlTnVtID0gZmluZE11bHRpcGxlTnVtKGEsIGIpO1xuICAgIHJldHVybiAoYSAqIG11bHRpcGxlTnVtKSAvIChiICogbXVsdGlwbGVOdW0pO1xufTtcblxuLyoqXG4gKiBTdW0uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgdGFyZ2V0IHZhbHVlc1xuICogQHJldHVybnMge251bWJlcn0gcmVzdWx0IHZhbHVlXG4gKi9cbnZhciBzdW0gPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICB2YXIgY29weUFyciA9IHZhbHVlcy5zbGljZSgpO1xuICAgIGNvcHlBcnIudW5zaGlmdCgwKTtcbiAgICByZXR1cm4gdHVpLnV0aWwucmVkdWNlKGNvcHlBcnIsIGZ1bmN0aW9uKGJhc2UsIGFkZCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChiYXNlKSArIHBhcnNlRmxvYXQoYWRkKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUHJvcGVyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBzdHJpbmcgdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbnZhciBwcm9wZXJDYXNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zdWJzdHJpbmcoMSk7XG59O1xuXG4vKipcbiAqIERlZXAgY29weS5cbiAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fCp9IG9yaWdpbiAtIG9yaWdpbmFsIGRhdGFcbiAqIEByZXR1cm5zIHsqfVxuICovXG52YXIgZGVlcENvcHkgPSBmdW5jdGlvbihvcmlnaW4pIHtcbiAgICB2YXIgY2xvbmU7XG5cbiAgICBpZiAodHVpLnV0aWwuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIGNsb25lID0gW107XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShvcmlnaW4sIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGNsb25lW2luZGV4XSA9IGRlZXBDb3B5KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0dWkudXRpbC5pc0Z1bmN0aW9uKG9yaWdpbikpIHtcbiAgICAgICAgY2xvbmUgPSBvcmlnaW47XG4gICAgfSBlbHNlIGlmICh0dWkudXRpbC5pc09iamVjdChvcmlnaW4pKSB7XG4gICAgICAgIGNsb25lID0ge307XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2gob3JpZ2luLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBjbG9uZVtrZXldID0gZGVlcENvcHkodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZSA9IG9yaWdpbjtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG59O1xuXG50dWkudXRpbC5taW4gPSBtaW47XG50dWkudXRpbC5tYXggPSBtYXg7XG50dWkudXRpbC5hbnkgPSBhbnk7XG50dWkudXRpbC5hbGwgPSBhbGw7XG50dWkudXRpbC51bmlxdWUgPSB1bmlxdWU7XG50dWkudXRpbC5waXZvdCA9IHBpdm90O1xudHVpLnV0aWwuZ2V0RGVjaW1hbExlbmd0aCA9IGdldERlY2ltYWxMZW5ndGg7XG50dWkudXRpbC5tb2QgPSBtb2Q7XG50dWkudXRpbC5maW5kTXVsdGlwbGVOdW0gPSBmaW5kTXVsdGlwbGVOdW07XG50dWkudXRpbC5hZGRpdGlvbiA9IGFkZGl0aW9uO1xudHVpLnV0aWwuc3VidHJhY3Rpb24gPSBzdWJ0cmFjdGlvbjtcbnR1aS51dGlsLm11bHRpcGxpY2F0aW9uID0gbXVsdGlwbGljYXRpb247XG50dWkudXRpbC5kaXZpc2lvbiA9IGRpdmlzaW9uO1xudHVpLnV0aWwuc3VtID0gc3VtO1xudHVpLnV0aWwucHJvcGVyQ2FzZSA9IHByb3BlckNhc2U7XG50dWkudXRpbC5kZWVwQ29weSA9IGRlZXBDb3B5O1xuXG52YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgZm4gdW50aWwgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzIGhhcyBlbGFwc2VkXG4gKiBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdWNlZCBmdW5jdGlvbiB3YXMgaW52b2tlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXlcbiAqIEBtZW1iZXJvZiB0dWkudXRpbFxuICogQHJldHVybnMge2Z1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNvbWVNZXRob2RUb0ludm9rZURlYm91bmNlZCgpIHt9XG4gKlxuICogdmFyIGRlYm91bmNlZCA9IHR1aS51dGlsLmRlYm91bmNlKHNvbWVNZXRob2RUb0ludm9rZURlYm91bmNlZCwgMzAwKTtcbiAqXG4gKiAvLyBpbnZva2UgcmVwZWF0ZWRseVxuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpO1xuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpOyAgICAvLyBsYXN0IGludm9rZSBvZiBkZWJvdW5jZWQoKVxuICpcbiAqIC8vIGludm9rZSBzb21lTWV0aG9kVG9JbnZva2VEZWJvdW5jZWQoKSBhZnRlciAzMDAgbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgICB2YXIgdGltZXIsXG4gICAgICAgIGFyZ3M7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGRlbGF5ID0gZGVsYXkgfHwgMDtcblxuICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgYXJncyA9IGFwcy5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBmbiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGludGVydmFsIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGlzIHRocm90dGxlIHNob3J0IHRpbWUgcmVwZWF0ZWRseSBpbnZva2luZyBmdW5jdGlvbnMuIChlLmcgTW91c2VNb3ZlLCBSZXNpemUgLi4uKVxuICpcbiAqIGlmIHlvdSBuZWVkIHJldXNlIHRocm90dGxlZCBtZXRob2QuIHlvdSBtdXN0IHJlbW92ZSBzbHVncyAoZS5nLiBmbGFnIHZhcmlhYmxlKSByZWxhdGVkIHdpdGggdGhyb3R0bGluZy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIGZ1bmN0aW9uIHRvIHRocm90dGxlXG4gKiBAcGFyYW0ge251bWJlcn0gW2ludGVydmFsPTBdIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQG1lbWJlcm9mIHR1aS51dGlsXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRocm90dGxlZCBmdW5jdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzb21lTWV0aG9kVG9JbnZva2VUaHJvdHRsZWQoKSB7fVxuICpcbiAqIHZhciB0aHJvdHRsZWQgPSB0dWkudXRpbC50aHJvdHRsZShzb21lTWV0aG9kVG9JbnZva2VUaHJvdHRsZWQsIDMwMCk7XG4gKlxuICogLy8gaW52b2tlIHJlcGVhdGVkbHlcbiAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKGxlYWRpbmcpXG4gKiB0aHJvdHRsZWQoKTtcbiAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKG5lYXIgMzAwIG1pbGxpc2Vjb25kcylcbiAqIHRocm90dGxlZCgpO1xuICogdGhyb3R0bGVkKCk7XG4gKiB0aHJvdHRsZWQoKTsgICAgLy8gaW52b2tlIChuZWFyIDYwMCBtaWxsaXNlY29uZHMpXG4gKiAvLyAuLi5cbiAqIC8vIGludm9rZSAodHJhaWxpbmcpXG4gKlxuICogLy8gaWYgeW91IG5lZWQgcmV1c2UgdGhyb3R0bGVkIG1ldGhvZC4gdGhlbiBpbnZva2UgcmVzZXQoKVxuICogdGhyb3R0bGVkLnJlc2V0KCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBpbnRlcnZhbCkge1xuICAgIHZhciBiYXNlLFxuICAgICAgICBfdGltZXN0YW1wID0gdHVpLnV0aWwudGltZXN0YW1wLFxuICAgICAgICBkZWJvdW5jZWQsXG4gICAgICAgIGlzTGVhZGluZyA9IHRydWUsXG4gICAgICAgIHN0YW1wLFxuICAgICAgICBhcmdzLFxuICAgICAgICB0aWNrID0gZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIF9hcmdzKTtcbiAgICAgICAgICAgIGJhc2UgPSBudWxsO1xuICAgICAgICB9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpbnRlcnZhbCA9IGludGVydmFsIHx8IDA7XG5cbiAgICBkZWJvdW5jZWQgPSB0dWkudXRpbC5kZWJvdW5jZSh0aWNrLCBpbnRlcnZhbCk7XG5cbiAgICBmdW5jdGlvbiB0aHJvdHRsZWQoKSB7XG4gICAgICAgIGFyZ3MgPSBhcHMuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgIGlmIChpc0xlYWRpbmcpIHtcbiAgICAgICAgICAgIHRpY2soYXJncyk7XG4gICAgICAgICAgICBpc0xlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YW1wID0gX3RpbWVzdGFtcCgpO1xuXG4gICAgICAgIGJhc2UgPSBiYXNlIHx8IHN0YW1wO1xuXG4gICAgICAgIGRlYm91bmNlZChhcmdzKTtcblxuICAgICAgICBpZiAoKHN0YW1wIC0gYmFzZSkgPj0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRpY2soYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgaXNMZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgYmFzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhyb3R0bGVkLnJlc2V0ID0gcmVzZXQ7XG4gICAgcmV0dXJuIHRocm90dGxlZDtcbn1cblxudHVpLnV0aWwuZGVib3VuY2UgPSBkZWJvdW5jZTtcbnR1aS51dGlsLnRocm90dGxlID0gdGhyb3R0bGU7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hhcnQgY29uc3RcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogMCovXG5cbi8qKlxuICogQ2hhcnQgY29uc3RcbiAqIEByZWFkb25seVxuICogQGVudW0ge251bWJlcn1cbiAqL1xudmFyIGNoYXJ0Q29uc3QgPSB7XG4gICAgLyoqIHR1aSBjbGFzcyBuYW1lc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgQ0xBU1NfTkFNRV9MRUdFTkRfTEFCRUw6ICd0dWktY2hhcnQtbGVnZW5kLWxhYmVsJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDTEFTU19OQU1FX0xFR0VORF9DSEVDS0JPWDogJ3R1aS1jaGFydC1sZWdlbmQtY2hlY2tib3gnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENMQVNTX05BTUVfU0VSSUVTX0xBQkVMOiAndHVpLWNoYXJ0LXNlcmllcy1sYWJlbCcsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0xBU1NfTkFNRV9TRVJJRVNfTEVHRU5EOiAndHVpLWNoYXJ0LXNlcmllcy1sZWdlbmQnLFxuICAgIC8qKiBjaGFydCB0eXBlc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgQ0hBUlRfVFlQRV9CQVI6ICdiYXInLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENIQVJUX1RZUEVfQ09MVU1OOiAnY29sdW1uJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX0xJTkU6ICdsaW5lJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX0FSRUE6ICdhcmVhJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX0NPTUJPOiAnY29tYm8nLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENIQVJUX1RZUEVfUElFOiAncGllJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX0JVQkJMRTogJ2J1YmJsZScsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0hBUlRfVFlQRV9NQVA6ICdtYXAnLFxuICAgIC8qKiBjaGFydCBwYWRkaW5nICovXG4gICAgQ0hBUlRfUEFERElORzogMTAsXG4gICAgLyoqIGNoYXJ0IGRlZmF1bHQgd2lkdGggKi9cbiAgICBDSEFSVF9ERUZBVUxUX1dJRFRIOiA1MDAsXG4gICAgLyoqIGNoYXJ0IGRlZmF1bHQgaGVpZ2h0ICovXG4gICAgQ0hBUlRfREVGQVVMVF9IRUlHSFQ6IDQwMCxcbiAgICAvKiogb3ZlcmxhcHBpbmcgd2lkdGggb2YgeEF4aXMgYW5kIHlBeGlzICovXG4gICAgT1ZFUkxBUFBJTkdfV0lEVEg6IDEsXG4gICAgLyoqIHJlbmRlcmVkIHRleHQgcGFkZGluZyAqL1xuICAgIFRFWFRfUEFERElORzogMixcbiAgICAvKiogc2VyaWVzIGV4cGFuZCBzaXplICovXG4gICAgU0VSSUVTX0VYUEFORF9TSVpFOiAxMCxcbiAgICAvKiogc2VyaWVzIGxhYmVsIHBhZGRpbmcgKi9cbiAgICBTRVJJRVNfTEFCRUxfUEFERElORzogNSxcbiAgICAvKiogZGVmYXVsdCBmb250IHNpemUgb2YgdGl0bGUgKi9cbiAgICBERUZBVUxUX1RJVExFX0ZPTlRfU0laRTogMTQsXG4gICAgLyoqIGRlZmF1bHQgZm9udCBzaXplIG9mIGF4aXMgdGl0bGUgKi9cbiAgICBERUZBVUxUX0FYSVNfVElUTEVfRk9OVF9TSVpFOiAxMCxcbiAgICAvKiogZGVmYXVsdCBmb250IHNpemUgb2YgbGFiZWwgKi9cbiAgICBERUZBVUxUX0xBQkVMX0ZPTlRfU0laRTogMTIsXG4gICAgLyoqIGRlZmF1bHQgZm9udCBzaXplIG9mIHNlcmllcyBsYWJlbCAqL1xuICAgIERFRkFVTFRfU0VSSUVTX0xBQkVMX0ZPTlRfU0laRTogMTEsXG4gICAgLyoqIGRlZmF1bHQgZ3JhcGggcGx1Z2luXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBERUZBVUxUX1BMVUdJTjogJ3JhcGhhZWwnLFxuICAgIC8qKiBkZWZhdWx0IHRpY2sgY29sb3JcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIERFRkFVTFRfVElDS19DT0xPUjogJ2JsYWNrJyxcbiAgICAvKiogZGVmYXVsdCB0aGVtZSBuYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBERUZBVUxUX1RIRU1FX05BTUU6ICdkZWZhdWx0JyxcbiAgICBNQVhfSEVJR0hUX1dPUkxEOiAnQScsXG4gICAgLyoqIHN0YWNrZWQgb3B0aW9uIHR5cGVzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBTVEFDS0VEX05PUk1BTF9UWVBFOiAnbm9ybWFsJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBTVEFDS0VEX1BFUkNFTlRfVFlQRTogJ3BlcmNlbnQnLFxuICAgIERFRkFVTFRfU1RBQ0s6ICdfX19ERUZBVUxUX19fU1RBQ0tfX18nLFxuICAgIERVTU1ZX0tFWTogJ19fX0RVTU1ZX19fS0VZX19fJyxcbiAgICAvKiogZW1wdHkgYXhpcyBsYWJlbCAqL1xuICAgIEVNUFRZX0FYSVNfTEFCRUw6ICcnLFxuICAgIC8qKiBhbmdlbCAqL1xuICAgIEFOR0xFXzg1OiA4NSxcbiAgICBBTkdMRV85MDogOTAsXG4gICAgQU5HTEVfMzYwOiAzNjAsXG4gICAgLyoqIHJhZGlhbiAqL1xuICAgIFJBRDogTWF0aC5QSSAvIDE4MCxcbiAgICAvKiogc2VyaWVzIGxlZ2VuZCBhbGlnbnNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIExFR0VORF9BTElHTl9PVVRFUjogJ291dGVyJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBMRUdFTkRfQUxJR05fQ0VOVEVSOiAnY2VudGVyJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBMRUdFTkRfQUxJR05fVE9QOiAndG9wJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBMRUdFTkRfQUxJR05fQk9UVE9NOiAnYm90dG9tJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBMRUdFTkRfQUxJR05fTEVGVDogJ2xlZnQnLFxuICAgIC8qKiBzZXJpZXMgb3V0ZXIgbGFiZWwgcGFkZGluZyAqL1xuICAgIFNFUklFU19PVVRFUl9MQUJFTF9QQURESU5HOiAyMCxcbiAgICAvKiogZGVmYXVsdCByYXRlIG9mIHBpZSBncmFwaCAqL1xuICAgIFBJRV9HUkFQSF9ERUZBVUxUX1JBVEU6IDAuOCxcbiAgICAvKiogc21hbGwgcmF0ZSBvZiBwaWUgZ3JhcGggKi9cbiAgICBQSUVfR1JBUEhfU01BTExfUkFURTogMC42NSxcbiAgICAvKiogdGljayBjb3VudCBmb3IgbWFwIGNoYXJ0IGxlZ2VuZCAqL1xuICAgIE1BUF9DSEFSVF9MRUdFTkRfVElDS19DT1VOVDogNCxcbiAgICAvKiogZGVmYXVsdCBwb3NpdGlvbiByYXRpbyBvZiBtYXAgY2hhcnQgbGFiZWxcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIE1BUF9DSEFSVF9MQUJFTF9ERUZBVUxUX1BPU0lUSU9OX1JBVElPOiB7XG4gICAgICAgIHg6IDAuNSxcbiAgICAgICAgeTogMC41XG4gICAgfSxcbiAgICAvKiogZG90IHJhZGl1cyAqL1xuICAgIERPVF9SQURJVVM6IDQsXG4gICAgLyoqIHlBeGlzIHByb3BlcnRpZXNcbiAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgWUFYSVNfUFJPUFM6IFsndGlja0NvbG9yJywgJ3RpdGxlJywgJ2xhYmVsJ10sIC8vIHlheGlzIHRoZW1l7J2YIOyGjeyEsSAtIGNoYXJ0IHR5cGUgZmlsdGVyaW5n7ZWgIOuVjCDsgqzsmqnrkKhcbiAgICAvKiogc2VyaWVzIHByb3BlcnRpZXNcbiAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgU0VSSUVTX1BST1BTOiBbJ2xhYmVsJywgJ2NvbG9ycycsICdib3JkZXJDb2xvcicsICdzaW5nbGVDb2xvcnMnLFxuICAgICAgICAnc2VsZWN0aW9uQ29sb3InLCAnc3RhcnRDb2xvcicsICdlbmRDb2xvcicsICdvdmVyQ29sb3InXSwgLy8gc2VyaWVzIHRoZW1l7J2YIOyGjeyEsSAtIGNoYXJ0IHR5cGUgZmlsdGVyaW5n7ZWgIOuVjCDsgqzsmqnrkKhcbiAgICAvKiogdGl0bGUgYXJlYSB3aWR0aCBwYWRkaW5nICovXG4gICAgVElUTEVfQVJFQV9XSURUSF9QQURESU5HOiAyMCxcbiAgICAvKiogdG9wIG1hcmdpbiBvZiB4IGF4aXMgbGFiZWwgKi9cbiAgICBYQVhJU19MQUJFTF9UT1BfTUFSR0lOOiAxMCxcbiAgICAvKiogcmlnaHQgcGFkZGluZyBvZiB2ZXJ0aWNhbCBsYWJlbCAqL1xuICAgIFZfTEFCRUxfUklHSFRfUEFERElORzogMTAsXG4gICAgLyoqIHRvb2x0aXAgcHJlZml4XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBUT09MVElQX1BSRUZJWDogJ3R1aS1jaGFydC10b29sdGlwJyxcbiAgICAvKiogdG9vbHRpcCB6LWluZGV4ICoqL1xuICAgIFRPT0xUSVBfWklOREVYOiA1MDAsXG4gICAgLyoqIHRvb2x0aXAgYW5pbWF0aW9uIHRpbWUgKi9cbiAgICBUT09MVElQX0FOSU1BVElPTl9USU1FOiAxMDAsXG4gICAgLyoqIHRvb2x0aXAgYW5pbWF0aW9uIHRpbWUgZm9yIHBpZSBjaGFydCAqL1xuICAgIFRPT0xUSVBfUElFX0FOSU1BVElPTl9USU1FOiA1MCxcbiAgICAvKiogbWluaW11bSBwaXhlbCB0eXBlIHN0ZXAgc2l6ZSAqL1xuICAgIE1JTl9QSVhFTF9UWVBFX1NURVBfU0laRTogNDAsXG4gICAgLyoqIG1heGltdW0gcGl4ZWwgdHlwZSBzdGVwIHNpemUgKi9cbiAgICBNQVhfUElYRUxfVFlQRV9TVEVQX1NJWkU6IDYwLFxuICAgIC8qKiBheGlzIHNjYWxlIG9mIHBlcmNlbnQgc3RhY2tlZCBvcHRpb25cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIFBFUkNFTlRfU1RBQ0tFRF9BWElTX1NDQUxFOiB7XG4gICAgICAgIGxpbWl0OiB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDEwMFxuICAgICAgICB9LFxuICAgICAgICBzdGVwOiAyNSxcbiAgICAgICAgbGFiZWxzOiBbMCwgMjUsIDUwLCA3NSwgMTAwXVxuICAgIH0sXG4gICAgLyoqIGF4aXMgc2NhbGUgb2YgbWludXMgcGVyY2VudCBzdGFja2VkIG9wdGlvblxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgTUlOVVNfUEVSQ0VOVF9TVEFDS0VEX0FYSVNfU0NBTEU6IHtcbiAgICAgICAgbGltaXQ6IHtcbiAgICAgICAgICAgIG1pbjogLTEwMCxcbiAgICAgICAgICAgIG1heDogMFxuICAgICAgICB9LFxuICAgICAgICBzdGVwOiAyNSxcbiAgICAgICAgbGFiZWxzOiBbMCwgLTI1LCAtNTAsIC03NSwgLTEwMF1cbiAgICB9LFxuICAgIC8qKiBheGlzIHNjYWxlIG9mIGR1YWwgcGVyY2VudCBzdGFja2VkIG9wdGlvblxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgRFVBTF9QRVJDRU5UX1NUQUNLRURfQVhJU19TQ0FMRToge1xuICAgICAgICBsaW1pdDoge1xuICAgICAgICAgICAgbWluOiAtMTAwLFxuICAgICAgICAgICAgbWF4OiAxMDBcbiAgICAgICAgfSxcbiAgICAgICAgc3RlcDogMjUsXG4gICAgICAgIGxhYmVsczogWy0xMDAsIC03NSwgLTUwLCAtMjUsIDAsIDI1LCA1MCwgNzUsIDEwMF1cbiAgICB9LFxuICAgIC8qKiBheGlzIHNjYWxlIG9mIGRpdmVyZ2luZyBwZXJjZW50IHN0YWNrZWQgb3B0aW9uXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICBESVZFUkdJTkdfUEVSQ0VOVF9TVEFDS0VEX0FYSVNfU0NBTEU6IHtcbiAgICAgICAgbGltaXQ6IHtcbiAgICAgICAgICAgIG1pbjogLTEwMCxcbiAgICAgICAgICAgIG1heDogMTAwXG4gICAgICAgIH0sXG4gICAgICAgIHN0ZXA6IDI1LFxuICAgICAgICBsYWJlbHM6IFsxMDAsIDc1LCA1MCwgMjUsIDAsIDI1LCA1MCwgNzUsIDEwMF1cbiAgICB9LFxuICAgIC8qKiB0aXRsZSBhZGQgcGFkZGluZyAqL1xuICAgIFRJVExFX1BBRERJTkc6IDEwLFxuICAgIC8qKiBsZWdlbmQgYXJlYSBwYWRkaW5nICovXG4gICAgTEVHRU5EX0FSRUFfUEFERElORzogMTAsXG4gICAgLyoqIGxlZ2VuZCBjaGVja2JveCB3aWR0aCAqL1xuICAgIExFR0VORF9DSEVDS0JPWF9XSURUSDogMjAsXG4gICAgLyoqIGxlZ2VuZCByZWN0IHdpZHRoICovXG4gICAgTEVHRU5EX1JFQ1RfV0lEVEg6IDEyLFxuICAgIC8qKiBsZ2VuZCBsYWJlbCBsZWZ0IHBhZGRpbmcgKi9cbiAgICBMRUdFTkRfTEFCRUxfTEVGVF9QQURESU5HOiA1LFxuICAgIC8qKiBtYXAgbGVnZW5kIGhlaWdodCAqL1xuICAgIE1BUF9MRUdFTkRfU0laRTogMjAwLFxuICAgIC8qKiBtYXAgbGVnZW5kIGdyYXBoIHNpemUgKi9cbiAgICBNQVBfTEVHRU5EX0dSQVBIX1NJWkU6IDI1LFxuICAgIC8qKiBtYXAgbGVnZW5kIGxhYmVsIHBhZGRpbmcgKi9cbiAgICBNQVBfTEVHRU5EX0xBQkVMX1BBRERJTkc6IDUsXG4gICAgQ0lSQ0xFX0xFR0VORF9MQUJFTF9GT05UX1NJWkU6IDksXG4gICAgQ0lSQ0xFX0xFR0VORF9QQURESU5HOiAyMCxcbiAgICBIQUxGX1JBVElPOiAwLjUsXG4gICAgLyoqIEFYSVMgTEFCRUwgUEFERElORyAqL1xuICAgIEFYSVNfTEFCRUxfUEFERElORzogNyxcbiAgICAvKiogcm90YXRpb25zIGRlZ3JlZSBjYW5kaWRhdGVzICovXG4gICAgREVHUkVFX0NBTkRJREFURVM6IFsyNSwgNDUsIDY1LCA4NV0sXG4gICAgLyoqIHlBeGlzIGFsaWduIG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgWUFYSVNfQUxJR05fQ0VOVEVSOiAnY2VudGVyJyxcbiAgICAvKiogeEF4aXMgbGFiZWwgY29tcGFyZSBtYXJnaW4gKi9cbiAgICBYQVhJU19MQUJFTF9DT01QQVJFX01BUkdJTjogMjAsXG4gICAgLyoqIHhBeGlzIGxhYmVsIGd1dHRlciAqL1xuICAgIFhBWElTX0xBQkVMX0dVVFRFUjogMixcbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBtdWx0aXBsZSBudW1zIG9mIGF4aXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgQVhJU19TVEFOREFSRF9NVUxUSVBMRV9OVU1TOiBbMSwgMiwgNSwgMTAsIDIwLCA1MCwgMTAwXSxcbiAgICAvKipcbiAgICAgKiBMYXN0IHN0YW5kYXJkIG11bHRpcGxlIG51bSBvZiBheGlzXG4gICAgICovXG4gICAgQVhJU19MQVNUX1NUQU5EQVJEX01VTFRJUExFX05VTTogMTAwLFxuICAgIC8qKiBsYWJlbCBwYWRkaW5nIHRvcCAqL1xuICAgIExBQkVMX1BBRERJTkdfVE9QOiAyLFxuICAgIC8qKiBsaW5lIG1hcmdpbiB0b3AgKi9cbiAgICBMSU5FX01BUkdJTl9UT1A6IDUsXG4gICAgLyoqIHRvb2x0aXAgZ2FwICovXG4gICAgVE9PTFRJUF9HQVA6IDUsXG4gICAgLyoqIHRvb2x0aXAgZGlyZWN0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBUT09MVElQX0RJUkVDVElPTl9GT1JXQVJEOiAnZm9yd29yZCcsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgVE9PTFRJUF9ESVJFQ1RJT05fQ0VOVEVSOiAnY2VudGVyJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBUT09MVElQX0RJUkVDVElPTl9CQUNLV0FSRDogJ2JhY2t3b3JkJyxcbiAgICAvKiogdG9vbHRpcCBhbGlnbiBvcHRpb25zXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBUT09MVElQX0RFRkFVTFRfQUxJR05fT1BUSU9OOiAnY2VudGVyIHRvcCcsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgVE9PTFRJUF9ERUZBVUxUX0hPUklaT05UQUxfQUxJR05fT1BUSU9OOiAncmlnaHQgbWlkZGxlJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBUT09MVElQX0RFRkFVTFRfR1JPVVBfQUxJR05fT1BUSU9OOiAncmlnaHQgbWlkZGxlJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBUT09MVElQX0RFRkFVTFRfR1JPVVBfSE9SSVpPTlRBTF9BTElHTl9PUFRJT046ICdjZW50ZXIgYm90dG9tJyxcbiAgICAvKiogaGlkZSBkZWxheSAqL1xuICAgIEhJREVfREVMQVk6IDIwMCxcbiAgICBPTERfQlJPV1NFUl9PUEFDSVRZXzEwMDogMTAwLFxuICAgIFNFUklFU19MQUJFTF9PUEFDSVRZOiAwLjMsXG4gICAgV0hFRUxfVElDSzogMTIwLFxuICAgIE1BWF9aT09NX01BR046IDMyLFxuICAgIEZGX1dIRUVMREVMVEFfQURKVVNUSU5HX1ZBTFVFOiAtNDAsXG4gICAgSUU3X1JPVEFUSU9OX0ZJTFRFUl9TVFlMRV9NQVA6IHtcbiAgICAgICAgMjU6ICcgc3R5bGU9XCJmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoU2l6aW5nTWV0aG9kPVxcJ2F1dG8gZXhwYW5kXFwnLCcgK1xuICAgICAgICAgICAgICAgICcgTTExPTAuOTA2MzA3Nzg3MDM2NjQ5OSwgTTEyPTAuNDIyNjE4MjYxNzQwNjk5NDQsIE0yMT0tMC40MjI2MTgyNjE3NDA2OTk0NCwgTTIyPTAuOTA2MzA3Nzg3MDM2NjQ5OSlcIicsXG4gICAgICAgIDQ1OiAnIHN0eWxlPVwiZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KFNpemluZ01ldGhvZD1cXCdhdXRvIGV4cGFuZFxcJywnICtcbiAgICAgICAgICAgICAgICAnIE0xMT0wLjcwNzEwNjc4MTE4NjU0NzYsIE0xMj0wLjcwNzEwNjc4MTE4NjU0NzUsIE0yMT0tMC43MDcxMDY3ODExODY1NDc1LCBNMjI9MC43MDcxMDY3ODExODY1NDc2KVwiJyxcbiAgICAgICAgNjU6ICcgc3R5bGU9XCJmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoU2l6aW5nTWV0aG9kPVxcJ2F1dG8gZXhwYW5kXFwnLCcgK1xuICAgICAgICAgICAgICAgICcgTTExPTAuNDIyNjE4MjYxNzQwNjk5NDQsIE0xMj0wLjkwNjMwNzc4NzAzNjY0OTksIE0yMT0tMC45MDYzMDc3ODcwMzY2NDk5LCBNMjI9MC40MjI2MTgyNjE3NDA2OTk0NClcIicsXG4gICAgICAgIDg1OiAnIHN0eWxlPVwiZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KFNpemluZ01ldGhvZD1cXCdhdXRvIGV4cGFuZFxcJywnICtcbiAgICAgICAgICAgICAgICAnIE0xMT0wLjA4NzE1NTc0Mjc0NzY1ODE0LCBNMTI9MC45OTYxOTQ2OTgwOTE3NDU1LCBNMjE9LTAuOTk2MTk0Njk4MDkxNzQ1NSwgTTIyPTAuMDg3MTU1NzQyNzQ3NjU4MTQpXCInXG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gY2hhcnRDb25zdDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBBcmVhVHlwZUN1c3RvbUV2ZW50IGlzIGV2ZW50IGhhbmRsZSBsYXllciBmb3IgbGluZSB0eXBlIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ3VzdG9tRXZlbnRCYXNlID0gcmVxdWlyZSgnLi9jdXN0b21FdmVudEJhc2UnKSxcbiAgICBBcmVhVHlwZURhdGFNb2RlbCA9IHJlcXVpcmUoJy4vYXJlYVR5cGVEYXRhTW9kZWwnKSxcbiAgICBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxudmFyIEFyZWFUeXBlQ3VzdG9tRXZlbnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDdXN0b21FdmVudEJhc2UsIC8qKiBAbGVuZHMgQXJlYVR5cGVDdXN0b21FdmVudC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEFyZWFUeXBlQ3VzdG9tRXZlbnQgaXMgY3VzdG9tIGV2ZW50IGZvciBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogQGNvbnN0cnVjdHMgQXJlYVR5cGVDdXN0b21FdmVudFxuICAgICAqIEBleHRlbmRzIEN1c3RvbUV2ZW50QmFzZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBDdXN0b21FdmVudEJhc2UuY2FsbCh0aGlzLCBwYXJhbXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmV2aW91cyBmb3VuZCBkYXRhXG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwgb2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2Rm91bmREYXRhID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBkYXRhIG9mIGN1c3RvbSBldmVudFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHNlcmllc0luZm9zIHNlcmllcyBpbmZvc1xuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGluaXRDdXN0b21FdmVudERhdGE6IGZ1bmN0aW9uKHNlcmllc0luZm9zKSB7XG4gICAgICAgIHZhciBzZXJpZXNJbmZvID0gc2VyaWVzSW5mb3NbMF07XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsID0gbmV3IEFyZWFUeXBlRGF0YU1vZGVsKHNlcmllc0luZm8pO1xuICAgICAgICBDdXN0b21FdmVudEJhc2UucHJvdG90eXBlLmluaXRDdXN0b21FdmVudERhdGEuY2FsbCh0aGlzLCBzZXJpZXNJbmZvcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlbW92ZS5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2Vtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXG4gICAgICAgICAgICBib3VuZCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGxheWVyWCA9IGUuY2xpZW50WCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFIC0gYm91bmQubGVmdCxcbiAgICAgICAgICAgIGxheWVyWSA9IGUuY2xpZW50WSAtIGJvdW5kLnRvcCxcbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSB0aGlzLnRpY2tCYXNlQ29vcmRpbmF0ZU1vZGVsLmZpbmRJbmRleChsYXllclgpLFxuICAgICAgICAgICAgZm91bmREYXRhID0gdGhpcy5kYXRhTW9kZWwuZmluZERhdGEoZ3JvdXBJbmRleCwgbGF5ZXJZKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzQ2hhbmdlZFNlbGVjdERhdGEodGhpcy5wcmV2Rm91bmREYXRhLCBmb3VuZERhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91bmREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3Nob3dUb29sdGlwJywgZm91bmREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXZGb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVRvb2x0aXAnLCB0aGlzLnByZXZGb3VuZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldkZvdW5kRGF0YSA9IGZvdW5kRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2VvdXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXZGb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVRvb2x0aXAnLCB0aGlzLnByZXZGb3VuZERhdGEpO1xuICAgICAgICAgICAgdGhpcy5wcmV2Rm91bmREYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWFUeXBlQ3VzdG9tRXZlbnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQXJlYVR5cGVEYXRhTW9kZWwgaXMgZGF0YSBtb2RlbCBmb3IgY3VzdG9tIGV2ZW50IG9mIGFyZWEgdHlwZS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEFyZWFUeXBlRGF0YU1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBBcmVhVHlwZURhdGFNb2RlbC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEFyZWFUeXBlRGF0YU1vZGVsIGlzIGRhdGEgbW9kZSBmb3IgY3VzdG9tIGV2ZW50IG9mIGFyZWEgdHlwZS5cbiAgICAgKiBAY29uc3RydWN0cyBBcmVhVHlwZURhdGFNb2RlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNJbmZvIHNlcmllcyBpbmZvXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oc2VyaWVzSW5mbykge1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLl9tYWtlRGF0YShzZXJpZXNJbmZvLmRhdGEuZ3JvdXBQb3NpdGlvbnMsIHNlcmllc0luZm8uY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBhcmVhIHR5cGUgZGF0YSBmb3IgY3VzdG9tIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gZ3JvdXBQb3NpdGlvbnMgLSBncm91cCBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlRGF0YTogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMsIGNoYXJ0VHlwZSkge1xuICAgICAgICBncm91cFBvc2l0aW9ucyA9IHR1aS51dGlsLnBpdm90KGdyb3VwUG9zaXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb25zLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmQ6IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBEYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IC0gZ3JvdXAgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXJZIC0gbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGZpbmREYXRhOiBmdW5jdGlvbihncm91cEluZGV4LCBsYXllclkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsXG4gICAgICAgICAgICBtaW4gPSAxMDAwMDtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh0aGlzLmRhdGFbZ3JvdXBJbmRleF0sIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMobGF5ZXJZIC0gZGF0YS5ib3VuZC50b3ApO1xuICAgICAgICAgICAgaWYgKG1pbiA+IGRpZmYpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBkaWZmO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWFUeXBlRGF0YU1vZGVsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEJvdW5kc0Jhc2VDb29yZGluYXRlTW9kZWwgaXMgZGF0YSBtb2RlIGZvciBjdXN0b20gZXZlbnQgb2YgcG9pbnQgdHlwZS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBwb3NpdGlvblxuICogQHR5cGVkZWYge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb25cbiAqL1xuXG4vKipcbiAqIGJvdW5kXG4gKiBAdHlwZWRlZiB7e1xuICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gKiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICp9fSBib3VuZFxuICovXG5cbi8qKlxuICogZ3JvdXAgYm91bmRcbiAqICBAdHlwZWRlZiB7QXJyYXkuPEFycmF5Ljxib3VuZD4+fSBncm91cEJvdW5kXG4gKi9cblxuLyoqXG4gKiBncm91cCBwb3NpdGlvblxuICogIEB0eXBlZGVmIHtBcnJheS48QXJyYXkuPHBvc2l0aW9uPj59IGdyb3VwUG9zaXRpb25cbiAqL1xuXG4vKipcbiAqIHNlcmllcyBpbmZvXG4gKiBAdHlwZWRlZiB7e1xuICogICAgICBjaGFydFR5cGU6IHtzdHJpbmd9LFxuICogICAgICBkYXRhOiB7XG4gKiAgICAgICAgICBncm91cEJvdW5kczogP2dyb3VwQm91bmQsXG4gKiAgICAgICAgICBncm91cFZhbHVlczogP0FycmF5LjxBcnJheS48bnVtYmVyPj4sXG4gKiAgICAgICAgICBncm91cFBvc2l0aW9uczogP2dyb3VwUG9zaXRpb25cbiAqICAgICAgfVxuICp9fSBzZXJpZXNJbmZvXG4gKi9cblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG5cbnZhciBCb3VuZHNCYXNlQ29vcmRpbmF0ZU1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBCb3VuZHNCYXNlQ29vcmRpbmF0ZU1vZGVsLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQm91bmRzQmFzZUNvb3JkaW5hdGVNb2RlbCBpcyBkYXRhIG1vZGUgZm9yIGN1c3RvbSBldmVudCBvZiBwb2ludCB0eXBlLlxuICAgICAqIEBjb25zdHJ1Y3RzIEJvdW5kc0Jhc2VDb29yZGluYXRlTW9kZWxcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzZXJpZXNJbmZvPn0gc2VyaWVzSW5mb3Mgc2VyaWVzIGluZm9zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oc2VyaWVzSW5mb3MpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5fbWFrZURhdGEoc2VyaWVzSW5mb3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNvb3JkaW5hdGUgZGF0YSBhYm91dCBiYXIgdHlwZSBncmFwaFxuICAgICAqIEBwYXJhbSB7Z3JvdXBCb3VuZH0gZ3JvdXBCb3VuZHMgZ3JvdXAgYm91bmRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge0FycmF5fSBjb29yZGluYXRlIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUmVjdFR5cGVDb29yZGluYXRlRGF0YTogZnVuY3Rpb24oZ3JvdXBCb3VuZHMsIGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGdyb3VwQm91bmRzLCBmdW5jdGlvbihib3VuZHMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoYm91bmRzLCBmdW5jdGlvbihfYm91bmQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kO1xuICAgICAgICAgICAgICAgIGlmICghX2JvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJvdW5kID0gX2JvdW5kLmVuZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmREYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93TmVnYXRpdmVUb29sdGlwOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQ6IGJvdW5kXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBib3VuZC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogYm91bmQubGVmdCArIGJvdW5kLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBib3VuZC50b3AgKyBib3VuZC5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY29vcmRpbmF0ZSBkYXRhIGFib3V0IGRvdCB0eXBlIGdyYXBoXG4gICAgICogQHBhcmFtIHtncm91cFBvc2l0aW9uc30gZ3JvdXBQb3NpdGlvbnMgZ3JvdXAgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGNvb3JkaW5hdGUgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VEb3RUeXBlQ29vcmRpbmF0ZURhdGE6IGZ1bmN0aW9uKGdyb3VwUG9zaXRpb25zLCBjaGFydFR5cGUpIHtcbiAgICAgICAgaWYgKCFncm91cFBvc2l0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0dWkudXRpbC5waXZvdChncm91cFBvc2l0aW9ucyksIGZ1bmN0aW9uKHBvc2l0aW9ucywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmREYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib3VuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGNoYXJ0Q29uc3QuRE9UX1JBRElVUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wIC0gY2hhcnRDb25zdC5ET1RfUkFESVVTLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHBvc2l0aW9uLmxlZnQgKyBjaGFydENvbnN0LkRPVF9SQURJVVMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHBvc2l0aW9uLnRvcCArIGNoYXJ0Q29uc3QuRE9UX1JBRElVU1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSm9pbiBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxBcnJheS48b2JqZWN0Pj4+fSBncm91cERhdGEgZ3JvdXAgZGF0YVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBqb2luZWQgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2pvaW5EYXRhOiBmdW5jdGlvbihncm91cERhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGdyb3VwRGF0YSwgZnVuY3Rpb24oY29vcmREYXRhKSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY29vcmREYXRhLCBmdW5jdGlvbihkYXRhLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0c1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHRzW2luZGV4XS5jb25jYXQoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY29vcmRpbmF0ZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHNlcmllc0luZm8+fSBzZXJpZXNJbmZvcyBzZXJpZXMgaW5mb3NcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gY29vcmRpbmF0ZSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZURhdGE6IGZ1bmN0aW9uKHNlcmllc0luZm9zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVEYXRhO1xuXG4gICAgICAgIHNlcmllc0luZm9zLnJldmVyc2UoKTtcbiAgICAgICAgY29vcmRpbmF0ZURhdGEgPSB0dWkudXRpbC5tYXAoc2VyaWVzSW5mb3MsIGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLmlzTGluZVR5cGVDaGFydChpbmZvLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLl9tYWtlRG90VHlwZUNvb3JkaW5hdGVEYXRhKGluZm8uZGF0YS5ncm91cFBvc2l0aW9ucywgaW5mby5jaGFydFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLl9tYWtlUmVjdFR5cGVDb29yZGluYXRlRGF0YShpbmZvLmRhdGEuZ3JvdXBCb3VuZHMsIGluZm8uY2hhcnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fam9pbkRhdGEoY29vcmRpbmF0ZURhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGNhbmRpZGF0ZXMuXG4gICAgICogQHBhcmFtIHt7Ym91bmQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlcn19fSBkYXRhIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXJYIGxheWVyWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllclkgbGF5ZXJZXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7c2VuZERhdGE6IG9iamVjdH0+fSBjYW5kaWRhdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZENhbmRpZGF0ZXM6IGZ1bmN0aW9uKGRhdGEsIGxheWVyWCwgbGF5ZXJZKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5maWx0ZXIoZGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgIHZhciBib3VuZCA9IGRhdHVtICYmIGRhdHVtLmJvdW5kLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaW5jbHVkZWRYLCBpbmNsdWRlZFk7XG5cbiAgICAgICAgICAgIGlmIChib3VuZCkge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVkWCA9IGJvdW5kLmxlZnQgPD0gbGF5ZXJYICYmIGJvdW5kLnJpZ2h0ID49IGxheWVyWDtcbiAgICAgICAgICAgICAgICBpbmNsdWRlZFkgPSBib3VuZC50b3AgPD0gbGF5ZXJZICYmIGJvdW5kLmJvdHRvbSA+PSBsYXllclk7XG4gICAgICAgICAgICAgICAgaW5jbHVkZWQgPSBpbmNsdWRlZFggJiYgaW5jbHVkZWRZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW5jbHVkZWQ7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRvb2x0aXAgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJbmRleCBncm91cCBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllclggbW91c2UgcG9zaXRpb24geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllclkgbW91c2UgcG9zaXRpb24geVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRvb2x0aXAgZGF0YVxuICAgICAqL1xuICAgIGZpbmREYXRhOiBmdW5jdGlvbihncm91cEluZGV4LCBsYXllclgsIGxheWVyWSkge1xuICAgICAgICB2YXIgbWluID0gMTAwMDAsXG4gICAgICAgICAgICByZXN1bHQgPSBudWxsLFxuICAgICAgICAgICAgY2FuZGlkYXRlcztcblxuICAgICAgICBpZiAoZ3JvdXBJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBsYXllclgsIGxheWVyWeulvCDtj6ztlajtlZjripQgZGF0YSDstpTstpxcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLl9maW5kQ2FuZGlkYXRlcyh0aGlzLmRhdGFbZ3JvdXBJbmRleF0sIGxheWVyWCwgbGF5ZXJZKTtcblxuICAgICAgICAgICAgLy8g7LaU7Lac65CcIGRhdGEg7KSRIHRvcOydtCBsYXllclnsmYAg6rCA7J6lIOqwgOq5jOyatCBkYXRhIOywvuyVhOuCtOq4sFxuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNhbmRpZGF0ZXMsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGxheWVyWSAtIGRhdGEuc2VuZERhdGEuYm91bmQudG9wKTtcbiAgICAgICAgICAgICAgICBpZiAobWluID4gZGlmZikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBkaWZmO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRhLnNlbmREYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZHNCYXNlQ29vcmRpbmF0ZU1vZGVsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEJvdW5kc1R5cGVDdXN0b21FdmVudCBpcyBldmVudCBoYW5kbGUgbGF5ZXIgZm9yIGJvdW5kcy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIEN1c3RvbUV2ZW50QmFzZSA9IHJlcXVpcmUoJy4vY3VzdG9tRXZlbnRCYXNlJyk7XG5cbnZhciBCb3VuZHNUeXBlQ3VzdG9tRXZlbnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDdXN0b21FdmVudEJhc2UsIC8qKiBAbGVuZHMgQm91bmRzVHlwZUN1c3RvbUV2ZW50LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQm91bmRzVHlwZUN1c3RvbUV2ZW50IGlzIGV2ZW50IGhhbmRsZSBsYXllciBmb3IgbGluZSB0eXBlIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIEJvdW5kc1R5cGVDdXN0b21FdmVudFxuICAgICAqIEBleHRlbmRzIEN1c3RvbUV2ZW50QmFzZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBDdXN0b21FdmVudEJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJldmlvdXMgZm91bmQgZGF0YVxuICAgICAgICAgKiBAdHlwZSB7bnVsbCB8IG9iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldkZvdW5kRGF0YSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlbW92ZS5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2Vtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXG4gICAgICAgICAgICBjbGllbnRYID0gZS5jbGllbnRYIC0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICBmb3VuZERhdGEgPSB0aGlzLl9maW5kRGF0YUZyb21Cb3VuZHNDb29yZGluYXRlTW9kZWwodGFyZ2V0LCBjbGllbnRYLCBlLmNsaWVudFkpO1xuXG4gICAgICAgIGlmICghdGhpcy5faXNDaGFuZ2VkU2VsZWN0RGF0YSh0aGlzLnByZXZGb3VuZERhdGEsIGZvdW5kRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByZXZGb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVRvb2x0aXAnLCB0aGlzLnByZXZGb3VuZERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvdW5kRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdzaG93VG9vbHRpcCcsIGZvdW5kRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXZGb3VuZERhdGEgPSBmb3VuZERhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlb3V0LlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9vbk1vdXNlb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJldkZvdW5kRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcsIHRoaXMucHJldkZvdW5kRGF0YSk7XG4gICAgICAgICAgICB0aGlzLnByZXZGb3VuZERhdGEgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQm91bmRzVHlwZUN1c3RvbUV2ZW50O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEN1c3RvbUV2ZW50QmFzZSBpcyBiYXNlIGNsYXNzIGZvciBldmVudCBoYW5kbGUgbGF5ZXJzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZXZlbnRMaXN0ZW5lcicpLFxuICAgIFRpY2tCYXNlQ29vcmRpbmF0ZU1vZGVsID0gcmVxdWlyZSgnLi90aWNrQmFzZUNvb3JkaW5hdGVNb2RlbCcpLFxuICAgIEJvdW5kc0Jhc2VDb29yZGluYXRlTW9kZWwgPSByZXF1aXJlKCcuL2JvdW5kc0Jhc2VDb29yZGluYXRlTW9kZWwnKSxcbiAgICBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbnZhciBDdXN0b21FdmVudEJhc2UgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIEN1c3RvbUV2ZW50QmFzZS5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEN1c3RvbUV2ZW50QmFzZSBpcyBiYXNlIGNsYXNzIGZvciBjdXN0b20gZXZlbnQgY29tcG9uZW50cy5cbiAgICAgKiBAY29uc3RydWN0cyBDdXN0b21FdmVudEJhc2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e1xuICAgICAqICAgICAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogICAgICB9fSBwYXJhbXMuYm91bmQgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuICAgICAgICB0aGlzLmlzVmVydGljYWwgPSBwYXJhbXMuaXNWZXJ0aWNhbDtcbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gcGFyYW1zLmRhdGFQcm9jZXNzb3I7XG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBwYXJhbXMuYm91bmRzTWFrZXI7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGV2ZW50IGhhbmRsZSBsYXllciBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGN1c3RvbUV2ZW50Q29udGFpbmVyIC0gY29udGFpbmVyIGVsZW1lbnQgZm9yIGN1c3RvbSBldmVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ3VzdG9tRXZlbnRBcmVhOiBmdW5jdGlvbihjdXN0b21FdmVudENvbnRhaW5lciwgZGF0YSkge1xuICAgICAgICB2YXIgZXhwYW5kZWRCb3VuZCwgdGJjbTtcblxuICAgICAgICB0aGlzLmRpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdjdXN0b21FdmVudCcpO1xuICAgICAgICB0YmNtID0gbmV3IFRpY2tCYXNlQ29vcmRpbmF0ZU1vZGVsKHRoaXMuZGltZW5zaW9uLCBkYXRhLnRpY2tDb3VudCwgdGhpcy5jaGFydFR5cGUsIHRoaXMuaXNWZXJ0aWNhbCk7XG4gICAgICAgIHRoaXMudGlja0Jhc2VDb29yZGluYXRlTW9kZWwgPSB0YmNtO1xuICAgICAgICBleHBhbmRlZEJvdW5kID0gcmVuZGVyVXRpbC5leHBhbmRCb3VuZCh0aGlzLmJvdW5kc01ha2VyLmdldEJvdW5kKCdjdXN0b21FdmVudCcpKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oY3VzdG9tRXZlbnRDb250YWluZXIsIGV4cGFuZGVkQm91bmQuZGltZW5zaW9uKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihjdXN0b21FdmVudENvbnRhaW5lciwgZXhwYW5kZWRCb3VuZC5wb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBmb3IgY3VzdG9tRXZlbnQgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBjb250YWluZXIgZm9yIGN1c3RvbSBldmVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1zZXJpZXMtY3VzdG9tLWV2ZW50LWFyZWEnKTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJDdXN0b21FdmVudEFyZWEoY29udGFpbmVyLCBkYXRhKTtcbiAgICAgICAgdGhpcy5hdHRhY2hFdmVudChjb250YWluZXIpO1xuICAgICAgICB0aGlzLmN1c3RvbUV2ZW50Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgQm91bmRzQmFzZUNvb3JkaW5hdGVNb2RlbCBmcm9tIHNlcmllc0JvdW5kcyBmb3IgY3VzdG9tIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHNlcmllc0JvdW5kcyAtIHNlcmllcyBib3VuZHNcbiAgICAgKi9cbiAgICBpbml0Q3VzdG9tRXZlbnREYXRhOiBmdW5jdGlvbihzZXJpZXNCb3VuZHMpIHtcbiAgICAgICAgdGhpcy5ib3VuZHNCYXNlQ29vcmRpbmF0ZU1vZGVsID0gbmV3IEJvdW5kc0Jhc2VDb29yZGluYXRlTW9kZWwoc2VyaWVzQm91bmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVyZW5kZXIgZm9yIGN1c3RvbUV2ZW50IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3t0aWNrQ291bnQ6IG51bWJlcn19IGRhdGEgLSBkYXRhIGZvciByZXJlbmRlcmluZ1xuICAgICAqL1xuICAgIHJlcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckN1c3RvbUV2ZW50QXJlYSh0aGlzLmN1c3RvbUV2ZW50Q29udGFpbmVyLCBkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIGZvciBjdXN0b21FdmVudCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7dGlja0NvdW50OiBudW1iZXJ9fSBkYXRhIC0gZGF0YSBmb3IgcmVzaXppbmdcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXJlbmRlcihkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjaGFuZ2VkIHNlbGVjdCBkYXRhIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJldiAtIHByZXZpb3VzIGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY3VyIC0gY3VycmVudCBkYXRhXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNDaGFuZ2VkU2VsZWN0RGF0YTogZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICAgIHJldHVybiAhcHJldiB8fCAhY3VyIHx8IHByZXYuY2hhcnRUeXBlICE9PSBjdXIuY2hhcnRUeXBlIHx8XG4gICAgICAgICAgICBwcmV2LmluZGV4ZXMuZ3JvdXBJbmRleCAhPT0gY3VyLmluZGV4ZXMuZ3JvdXBJbmRleCB8fCBwcmV2LmluZGV4ZXMuaW5kZXggIT09IGN1ci5pbmRleGVzLmluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGNvb3JkaW5hdGUgZGF0YSBmcm9tIGJvdW5kc0Nvb3JkaW5hdGVNb2RlbC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRYIG1vdXNlIC0gcG9zaXRpb24geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRZIG1vdXNlIC0gcG9zaXRpb24geVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZERhdGFGcm9tQm91bmRzQ29vcmRpbmF0ZU1vZGVsOiBmdW5jdGlvbih0YXJnZXQsIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgbGF5ZXJYID0gY2xpZW50WCAtIGJvdW5kLmxlZnQsXG4gICAgICAgICAgICBsYXllclkgPSBjbGllbnRZIC0gYm91bmQudG9wLFxuICAgICAgICAgICAgZ3JvdXBJbmRleCA9IHRoaXMudGlja0Jhc2VDb29yZGluYXRlTW9kZWwuZmluZEluZGV4KHRoaXMuaXNWZXJ0aWNhbCA/IGxheWVyWCA6IGxheWVyWSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kc0Jhc2VDb29yZGluYXRlTW9kZWwuZmluZERhdGEoZ3JvdXBJbmRleCwgbGF5ZXJYICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsIGxheWVyWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuc2VsZWN0IHNlbGVjdGVkIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5zZWxlY3RTZWxlY3RlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gcmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCd1bnNlbGVjdCcsIHRoaXMuc2VsZWN0ZWREYXRhLmNoYXJ0VHlwZSwgJ3NlcmllcycpO1xuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB0aGlzLnNlbGVjdGVkRGF0YSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2UgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIGN1c3RvbSBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIC0gbW91c2UgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk1vdXNlRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gcmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKGV2ZW50VHlwZSwgdGhpcy5jaGFydFR5cGUsICdzZXJpZXMnKTtcblxuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5jdXN0b21FdmVudENvbnRhaW5lciwgJ2hpZGUnKTtcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgICAgbGVmdDogZS5jbGllbnRYLFxuICAgICAgICAgICAgdG9wOiBlLmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyh0aGlzLmN1c3RvbUV2ZW50Q29udGFpbmVyLCAnaGlkZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGlja1xuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxuICAgICAgICAgICAgY2xpZW50WCA9IGUuY2xpZW50WCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgZm91bmREYXRhID0gdGhpcy5fZmluZERhdGFGcm9tQm91bmRzQ29vcmRpbmF0ZU1vZGVsKHRhcmdldCwgY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NoYW5nZWRTZWxlY3REYXRhKHRoaXMuc2VsZWN0ZWREYXRhLCBmb3VuZERhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLl91bnNlbGVjdFNlbGVjdGVkRGF0YSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvdW5kRGF0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5zZWxlY3RTZWxlY3RlZERhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlyZShyZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ3NlbGVjdCcsIGZvdW5kRGF0YS5jaGFydFR5cGUsICdzZXJpZXMnKSwgZm91bmREYXRhKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhID0gZm91bmREYXRhO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIGRvd25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9vbk1vdXNlZG93bjogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfb25Nb3VzZXVwOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2UgbW92ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX29uTW91c2Vtb3ZlOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2Ugb3V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfb25Nb3VzZW91dDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBldmVudFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIHRhcmdldCBlbGVtZW50XG4gICAgICovXG4gICAgYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBldmVudExpc3RlbmVyLmJpbmRFdmVudCgnY2xpY2snLCB0YXJnZXQsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuICAgICAgICBldmVudExpc3RlbmVyLmJpbmRFdmVudCgnbW91c2Vkb3duJywgdGFyZ2V0LCB0aGlzLl9vbk1vdXNlZG93biwgdGhpcyk7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdtb3VzZXVwJywgdGFyZ2V0LCB0aGlzLl9vbk1vdXNldXAsIHRoaXMpO1xuICAgICAgICBldmVudExpc3RlbmVyLmJpbmRFdmVudCgnbW91c2Vtb3ZlJywgdGFyZ2V0LCB0aGlzLl9vbk1vdXNlbW92ZSwgdGhpcyk7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdtb3VzZW91dCcsIHRhcmdldCwgdGhpcy5fb25Nb3VzZW91dCwgdGhpcyk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihDdXN0b21FdmVudEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1c3RvbUV2ZW50QmFzZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBHcm91cFR5cGVDdXN0b21FdmVudCBpcyBldmVudCBoYW5kbGUgbGF5ZXIgZm9yIGdyb3VwZWQgdG9vbHRpcCBvcHRpb24uXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDdXN0b21FdmVudEJhc2UgPSByZXF1aXJlKCcuL2N1c3RvbUV2ZW50QmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgR3JvdXBUeXBlQ3VzdG9tRXZlbnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDdXN0b21FdmVudEJhc2UsIC8qKiBAbGVuZHMgR3JvdXBUeXBlQ3VzdG9tRXZlbnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBHcm91cFR5cGVDdXN0b21FdmVudCBpcyBldmVudCBoYW5kbGUgbGF5ZXIgZm9yIGdyb3VwZWQgdG9vbHRpcCBvcHRpb24uXG4gICAgICogQGNvbnN0cnVjdHMgR3JvdXBUeXBlQ3VzdG9tRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBDdXN0b21FdmVudEJhc2VcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgQ3VzdG9tRXZlbnRCYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3V0IHBvc2l0aW9uIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXJYIGxheWVyWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllclkgbGF5ZXJZXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNPdXRQb3NpdGlvbjogZnVuY3Rpb24obGF5ZXJYLCBsYXllclkpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuZGltZW5zaW9uO1xuICAgICAgICByZXR1cm4gbGF5ZXJYIDwgMCB8fCBsYXllclggPiBkaW1lbnNpb24ud2lkdGggfHwgbGF5ZXJZIDwgMCB8fCBsYXllclkgPiBkaW1lbnNpb24uaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZW1vdmUuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIG1vdXNlIGV2ZW50IG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2Vtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBlbFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcbiAgICAgICAgICAgIGJvdW5kID0gZWxUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBsYXllclggPSBlLmNsaWVudFggLSBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSAtIGJvdW5kLmxlZnQsXG4gICAgICAgICAgICBsYXllclkgPSBlLmNsaWVudFkgLSBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSAtIGJvdW5kLnRvcCxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBwb2ludFZhbHVlLCBzaXplVHlwZTtcblxuICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICBwb2ludFZhbHVlID0gbGF5ZXJYO1xuICAgICAgICAgICAgc2l6ZVR5cGUgPSAnaGVpZ2h0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50VmFsdWUgPSBsYXllclk7XG4gICAgICAgICAgICBzaXplVHlwZSA9ICd3aWR0aCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2lzT3V0UG9zaXRpb24obGF5ZXJYLCBsYXllclkpKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMudGlja0Jhc2VDb29yZGluYXRlTW9kZWwuZmluZEluZGV4KHBvaW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZW91dCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldkluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnc2hvd0dyb3VwVG9vbHRpcCcsIHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHRoaXMudGlja0Jhc2VDb29yZGluYXRlTW9kZWwubWFrZVJhbmdlKGluZGV4LCB0aGlzLmNoYXJ0VHlwZSksXG4gICAgICAgICAgICAgICAgc2l6ZTogdGhpcy5kaW1lbnNpb25bc2l6ZVR5cGVdLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWw6IHRoaXMuaXNWZXJ0aWNhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2VvdXQuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2VvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKHRoaXMucHJldkluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlR3JvdXBUb29sdGlwJywgdGhpcy5wcmV2SW5kZXgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucHJldkluZGV4O1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBUeXBlQ3VzdG9tRXZlbnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFwQ2hhcnRDdXN0b21FdmVudCBpcyBldmVudCBoYW5kbGUgbGF5ZXIgZm9yIG1hcCBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEN1c3RvbUV2ZW50QmFzZSA9IHJlcXVpcmUoJy4vY3VzdG9tRXZlbnRCYXNlJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgZXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZXZlbnRMaXN0ZW5lcicpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcblxudmFyIE1hcENoYXJ0Q3VzdG9tRXZlbnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDdXN0b21FdmVudEJhc2UsIC8qKiBAbGVuZHMgTWFwQ2hhcnRDdXN0b21FdmVudC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIE1hcENoYXJ0Q3VzdG9tRXZlbnQgaXMgZXZlbnQgaGFuZGxlIGxheWVyIGZvciBtYXAgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0JvdW5kc01ha2VyfSBwYXJhbXMuYm91bmRzTWFrZXIgYm91bmRzTWFrZXIgaW5zdGFuY2VcbiAgICAgKiBAY29uc3RydWN0cyBNYXBDaGFydEN1c3RvbUV2ZW50XG4gICAgICogQGV4dGVuZHMgQ3VzdG9tRXZlbnRCYXNlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBwYXJhbXMuYm91bmRzTWFrZXI7XG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gcGFyYW1zLmNoYXJ0VHlwZTtcbiAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlbmRlciBldmVudCBoYW5kbGUgbGF5ZXIgYXJlYVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGN1c3RvbUV2ZW50Q29udGFpbmVyIGN1c3RvbSBldmVudCBjb250YWluZXIgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckN1c3RvbUV2ZW50QXJlYTogZnVuY3Rpb24oY3VzdG9tRXZlbnRDb250YWluZXIpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gdGhpcy5ib3VuZHNNYWtlci5nZXRCb3VuZCgnY3VzdG9tRXZlbnQnKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oY3VzdG9tRXZlbnRDb250YWluZXIsIGJvdW5kLmRpbWVuc2lvbik7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24oY3VzdG9tRXZlbnRDb250YWluZXIsIGJvdW5kLnBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBkYXRhIG9mIGN1c3RvbSBldmVudFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGluaXRDdXN0b21FdmVudERhdGE6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGljay5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9vbkNsaWNrOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2UgZG93blxuICAgICAqIEBwYXJhbSB7bW91c2VldmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuaXNEb3duID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maXJlKCdkcmFnU3RhcnRNYXBTZXJpZXMnLCB7XG4gICAgICAgICAgICBsZWZ0OiBlLmNsaWVudFgsXG4gICAgICAgICAgICB0b3A6IGUuY2xpZW50WVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhZyBlbmQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZHJhZ0VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaXNEcmFnID0gZmFsc2U7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyh0aGlzLmN1c3RvbUV2ZW50Q29udGFpbmVyLCAnZHJhZycpO1xuICAgICAgICB0aGlzLmZpcmUoJ2RyYWdFbmRNYXBTZXJpZXMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2UgdXBcbiAgICAgKiBAcGFyYW0ge21vdXNlZXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9vbk1vdXNldXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmFnRW5kKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNNb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlRXZlbnQoJ2NsaWNrJywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc01vdmUgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2UgbW92ZS5cbiAgICAgKiBAcGFyYW0ge21vdXNlZXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9vbk1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5pc0Rvd24pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWcpIHtcbiAgICAgICAgICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5jdXN0b21FdmVudENvbnRhaW5lciwgJ2RyYWcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNEcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZHJhZ01hcFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBlLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgdG9wOiBlLmNsaWVudFlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc01vdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZUV2ZW50KCdtb3ZlJywgZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2Ugb3V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW91dDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWcpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdFbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29uTW91c2VFdmVudCgnbW92ZScsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIHdoZWVsLlxuICAgICAqIEBwYXJhbSB7bW91c2VldmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEByZXR1cm5zIHs/Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk1vdXNld2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHdoZWVsRGVsdGEgPSBlLndoZWVsRGVsdGEgfHwgZS5kZXRhaWwgKiBjaGFydENvbnN0LkZGX1dIRUVMREVMVEFfQURKVVNUSU5HX1ZBTFVFO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnd2hlZWwnLCB3aGVlbERlbHRhLCB7XG4gICAgICAgICAgICBsZWZ0OiBlLmNsaWVudFgsXG4gICAgICAgICAgICB0b3A6IGUuY2xpZW50WVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggZXZlbnRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBhdHRhY2hFdmVudDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIEN1c3RvbUV2ZW50QmFzZS5wcm90b3R5cGUuYXR0YWNoRXZlbnQuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXG4gICAgICAgIGlmICh0dWkudXRpbC5icm93c2VyLmZpcmVmb3gpIHtcbiAgICAgICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdET01Nb3VzZVNjcm9sbCcsIHRhcmdldCwgdGhpcy5fb25Nb3VzZXdoZWVsLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdtb3VzZXdoZWVsJywgdGFyZ2V0LCB0aGlzLl9vbk1vdXNld2hlZWwsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihNYXBDaGFydEN1c3RvbUV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDaGFydEN1c3RvbUV2ZW50O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNpbXBsZUN1c3RvbUV2ZW50IGlzIGV2ZW50IGhhbmRsZSBsYXllciBmb3Igc2ltcGx5IHNlbmRpbmcgY2xpZW50WCwgY2xpZW50WS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEN1c3RvbUV2ZW50QmFzZSA9IHJlcXVpcmUoJy4vY3VzdG9tRXZlbnRCYXNlJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgU2ltcGxlQ3VzdG9tRXZlbnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDdXN0b21FdmVudEJhc2UsIC8qKiBAbGVuZHMgU2ltcGxlQ3VzdG9tRXZlbnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBTaW1wbGVDdXN0b21FdmVudCBpcyBldmVudCBoYW5kbGUgbGF5ZXIgZm9yIHNpbXBseSBzZW5kaW5nIGNsaWVudFgsIGNsaWVudFkuXG4gICAgICogQGNvbnN0cnVjdHMgU2ltcGxlQ3VzdG9tRXZlbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7Qm91bmRzTWFrZXJ9IHBhcmFtcy5ib3VuZHNNYWtlciAtIGJvdW5kcyBtYWtlciBpbnN0YW5jZVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFydFR5cGUgLSBjaGFydCB0eXBlXG4gICAgICogQGV4dGVuZHMgQ3VzdG9tRXZlbnRCYXNlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBwYXJhbXMuYm91bmRzTWFrZXI7XG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gcGFyYW1zLmNoYXJ0VHlwZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGV2ZW50IGhhbmRsZSBsYXllciBhcmVhXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY3VzdG9tRXZlbnRDb250YWluZXIgLSBjb250YWluZXIgZWxlbWVudCBmb3IgY3VzdG9tIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ3VzdG9tRXZlbnRBcmVhOiBmdW5jdGlvbihjdXN0b21FdmVudENvbnRhaW5lcikge1xuICAgICAgICB2YXIgYm91bmQgPSB0aGlzLmJvdW5kc01ha2VyLmdldEJvdW5kKCdjdXN0b21FdmVudCcpO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckRpbWVuc2lvbihjdXN0b21FdmVudENvbnRhaW5lciwgYm91bmQuZGltZW5zaW9uKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihjdXN0b21FdmVudENvbnRhaW5lciwgYm91bmQucG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGRhdGEgb2YgY3VzdG9tIGV2ZW50XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgaW5pdEN1c3RvbUV2ZW50RGF0YTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIE9uIGNsaWNrLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLl9vbk1vdXNlRXZlbnQoJ2NsaWNrJywgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIG1vdmUuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIC0gbW91c2UgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9vbk1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLl9vbk1vdXNlRXZlbnQoJ21vdmUnLCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2Ugb3V0LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW91dDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLl9vbk1vdXNlRXZlbnQoJ21vdmUnLCBlKTtcbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFNpbXBsZUN1c3RvbUV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVDdXN0b21FdmVudDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaWNrQmFzZURhdGFNb2RlbCBpcyB0aWNrIGJhc2UgZGF0YSBtb2RlbC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG5cbnZhciBUaWNrQmFzZURhdGFNb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgVGlja0Jhc2VEYXRhTW9kZWwucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBUaWNrQmFzZURhdGFNb2RlbCBpcyB0aWNrIGJhc2UgZGF0YSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlja0NvdW50IHRpY2sgY291bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xhbn0gaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEBjb25zdHJ1Y3RzIFRpY2tCYXNlRGF0YU1vZGVsXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oZGltZW5zaW9uLCB0aWNrQ291bnQsIGNoYXJ0VHlwZSwgaXNWZXJ0aWNhbCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLl9tYWtlRGF0YShkaW1lbnNpb24sIHRpY2tDb3VudCwgY2hhcnRUeXBlLCBpc1ZlcnRpY2FsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aWNrIGJhc2UgZGF0YSBhYm91dCBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCB0aWNrIGNvdW50XG4gICAgICogQHJldHVybnMge0FycmF5fSB0aWNrIGJhc2UgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMaW5lVHlwZURhdGE6IGZ1bmN0aW9uKHdpZHRoLCB0aWNrQ291bnQpIHtcbiAgICAgICAgdmFyIHRpY2tJbnRlcnZhbCA9ICh3aWR0aCArIDEpIC8gKHRpY2tDb3VudCAtIDEpLFxuICAgICAgICAgICAgaGFsZkludGVydmFsID0gdGlja0ludGVydmFsIC8gMixcbiAgICAgICAgICAgIHJhbmdlcyA9IHR1aS51dGlsLm1hcCh0dWkudXRpbC5yYW5nZSgwLCB0aWNrQ291bnQpLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbjogaW5kZXggKiB0aWNrSW50ZXJ2YWwgLSBoYWxmSW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICAgIG1heDogaW5kZXggKiB0aWNrSW50ZXJ2YWwgKyBoYWxmSW50ZXJ2YWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJhbmdlc1t0aWNrQ291bnQgLSAxXS5tYXggLT0gMTtcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aWNrIGJhc2UgZGF0YSBhYm91dCBub24gbGluZSB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHdpZHRoIG9yIGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gdGljayBiYXNlIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTm9ybWFsRGF0YTogZnVuY3Rpb24oc2l6ZSwgdGlja0NvdW50KSB7XG4gICAgICAgIHZhciBsZW4gPSB0aWNrQ291bnQgLSAxLFxuICAgICAgICAgICAgdGlja0ludGVydmFsID0gc2l6ZSAvIGxlbixcbiAgICAgICAgICAgIHByZXYgPSAwO1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHR1aS51dGlsLnJhbmdlKDAsIGxlbiksIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gdHVpLnV0aWwubWluKFtzaXplLCAoaW5kZXggKyAxKSAqIHRpY2tJbnRlcnZhbF0pLFxuICAgICAgICAgICAgICAgIGxpbWl0ID0ge1xuICAgICAgICAgICAgICAgICAgICBtaW46IHByZXYsXG4gICAgICAgICAgICAgICAgICAgIG1heDogbWF4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXYgPSBtYXg7XG4gICAgICAgICAgICByZXR1cm4gbGltaXQ7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRpY2sgYmFzZSBkYXRhIGZvciBjdXN0b20gZXZlbnQuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtib29sYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59IHRpY2sgYmFzZSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZURhdGE6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgdGlja0NvdW50LCBjaGFydFR5cGUsIGlzVmVydGljYWwpIHtcbiAgICAgICAgdmFyIHNpemVUeXBlID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JyxcbiAgICAgICAgICAgIGRhdGE7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNMaW5lVHlwZUNoYXJ0KGNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9tYWtlTGluZVR5cGVEYXRhKGRpbWVuc2lvbltzaXplVHlwZV0sIHRpY2tDb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fbWFrZU5vcm1hbERhdGEoZGltZW5zaW9uW3NpemVUeXBlXSwgdGlja0NvdW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludFZhbHVlIG1vdXNlIHBvc2l0aW9uIHBvaW50IHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn0gZ3JvdXAgaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uKHBvaW50VmFsdWUpIHtcbiAgICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuZGF0YSwgZnVuY3Rpb24obGltaXQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAobGltaXQubWluIDwgcG9pbnRWYWx1ZSAmJiBsaW1pdC5tYXggPj0gcG9pbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZvdW5kSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm91bmRJbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRpY2sgYmFzZSBkYXRhIGxlbmd0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKi9cbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSByYW5nZSBvZiB0b29sdGlwIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSB0eXBlIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtYWtlUmFuZ2U6IGZ1bmN0aW9uKGluZGV4LCBjaGFydFR5cGUpIHtcbiAgICAgICAgdmFyIGxpbWl0ID0gdGhpcy5kYXRhW2luZGV4XSxcbiAgICAgICAgICAgIHJhbmdlLCBjZW50ZXI7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNMaW5lVHlwZUNoYXJ0KGNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIGNlbnRlciA9IHBhcnNlSW50KGxpbWl0Lm1heCAtIChsaW1pdC5tYXggLSBsaW1pdC5taW4pIC8gMiwgMTApO1xuICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGNlbnRlcixcbiAgICAgICAgICAgICAgICBlbmQ6IGNlbnRlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBsaW1pdC5taW4sXG4gICAgICAgICAgICAgICAgZW5kOiBsaW1pdC5tYXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGlja0Jhc2VEYXRhTW9kZWw7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YVByb2Nlc3NvciBwcm9jZXNzIHJhd0RhdGEuXG4gKiByYXdEYXRhLmNhdGVnb3JpZXMgLS0+IGNhdGVnb3JpZXNcbiAqIHJhd0RhdGEuc2VyaWVzIC0tPiBTZXJpZXNEYXRhTW9kZWwsIGxlZ2VuZExhYmVscywgbGVnZW5kRGF0YVxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgU2VyaWVzRGF0YU1vZGVsID0gcmVxdWlyZSgnLi4vZGF0YU1vZGVscy9zZXJpZXNEYXRhTW9kZWwnKSxcbiAgICBTZXJpZXNHcm91cCA9IHJlcXVpcmUoJy4vc2VyaWVzR3JvdXAnKSxcbiAgICBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpLFxuICAgIHJhd0RhdGFIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGVscGVycy9yYXdEYXRhSGFuZGxlcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcblxudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG5cbi8qKlxuICogUmF3IHNlcmllcyBkYXR1bS5cbiAqIEB0eXBlZGVmIHt7bmFtZTogP3N0cmluZywgZGF0YTogQXJyYXkuPG51bWJlcj4sIHN0YWNrOiA/c3RyaW5nfX0gcmF3U2VyaWVzRGF0dW1cbiAqL1xuXG4vKipcbiAqIFJhdyBzZXJpZXMgZGF0YS5cbiAqIEB0eXBlZGVmIHtBcnJheS48cmF3U2VyaWVzRGF0dW0+fSByYXdTZXJpZXNEYXRhXG4gKi9cblxuLyoqXG4gKiBSYXcgZGF0YSBieSB1c2VyLlxuICogQHR5cGVkZWYge3tcbiAqICAgICAgY2F0ZWdvcmllczogP0FycmF5LjxzdHJpbmc+LFxuICogICAgICBzZXJpZXM6IChyYXdTZXJpZXNEYXRhfHtsaW5lOiA/cmF3U2VyaWVzRGF0YSwgY29sdW1uOiA/cmF3U2VyaWVzRGF0YX0pXG4gKiB9fSByYXdEYXRhXG4gKi9cblxuLyoqXG4gKiBTZXJpZXNEYXRhTW9kZWwgaXMgYmFzZSBtb2RlbCBmb3IgZHJhd2luZyBncmFwaCBvZiBjaGFydCBzZXJpZXMgYXJlYSxcbiAqICAgICAgYW5kIGNyZWF0ZSBmcm9tIHJhd1Nlcmllc0RhdGEgYnkgdXNlcixcbiAqIFNlcmllc0RhdGFNb2RlbC5ncm91cHMgaGFzIFNlcmllc0dyb3Vwcy5cbiAqL1xuXG4vKipcbiAqIFNlcmllc0dyb3VwIGlzIGEgZWxlbWVudCBvZiBTZXJpZXNEYXRhTW9kZWwuZ3JvdXBzLlxuICogU2VyaWVzR3JvdXAuaXRlbXMgaGFzIFNlcmllc0l0ZW0uXG4gKi9cblxudmFyIERhdGFQcm9jZXNzb3IgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIERhdGFQcm9jZXNzb3IucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIERhdGEgcHJvY2Vzc29yLlxuICAgICAqIEBjb25zdHJ1Y3RzIERhdGFQcm9jZXNzb3JcbiAgICAgKiBAcGFyYW0ge3Jhd0RhdGF9IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc2VyaWVzQ2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd0RhdGEsIGNoYXJ0VHlwZSwgb3B0aW9ucywgc2VyaWVzQ2hhcnRUeXBlcykge1xuICAgICAgICB2YXIgc2VyaWVzT3B0aW9uID0gb3B0aW9ucy5zZXJpZXMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9yaWdpbmFsIHJhdyBkYXRhLlxuICAgICAgICAgKiBAdHlwZSB7e2NhdGVnb3JpZXM6ID9BcnJheS48c3RyaW5nPiwgc2VyaWVzOiBBcnJheS48b2JqZWN0Pn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWdpbmFsUmF3RGF0YSA9IHJhd0RhdGE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCBvcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXJpZXNDaGFydFR5cGVzIGlzIHNvcnRlZCBjaGFydCB0eXBlcyBmb3IgcmVuZGVyaW5nIHNlcmllcyBhcmVhIG9mIGNvbWJvIGNoYXJ0LlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcmllc0NoYXJ0VHlwZXMgPSBzZXJpZXNDaGFydFR5cGVzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkaXZlcmdpbmcgb3B0aW9uXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXZlcmdpbmdPcHRpb24gPSBwcmVkaWNhdGUuaXNCYXJUeXBlQ2hhcnQob3B0aW9ucy5jaGFydFR5cGUpICYmIHNlcmllc09wdGlvbi5kaXZlcmdpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxlZ2VuZCBkYXRhIGZvciByZW5kZXJpbmcgbGVnZW5kIG9mIGdyb3VwIHRvb2x0aXBcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljx7Y2hhcnRUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmd9Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZ2luYWxMZWdlbmREYXRhID0gbnVsbDtcblxuICAgICAgICB0aGlzLmluaXREYXRhKHJhd0RhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgb3JpZ2luYWwgcmF3IGRhdGEuXG4gICAgICogQHJldHVybnMge3Jhd0RhdGF9IHJhdyBkYXRhXG4gICAgICovXG4gICAgZ2V0T3JpZ2luYWxSYXdEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxSYXdEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGRhdGEuXG4gICAgICogQHBhcmFtIHtyYXdEYXRhfSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICovXG4gICAgaW5pdERhdGE6IGZ1bmN0aW9uKHJhd0RhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJhdyBkYXRhXG4gICAgICAgICAqIEB0eXBlIHtyYXdEYXRhfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYXdEYXRhID0gcmF3RGF0YTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2F0ZWdvcmllc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhdGVnb3JpZXMgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdGFja3NcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFja3MgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXJpZXNEYXRhTW9kZWwgbWFwXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3QuPHN0cmluZywgU2VyaWVzRGF0YU1vZGVsPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VyaWVzRGF0YU1vZGVsTWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlcmllc0dyb3Vwc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPFNlcmllc0dyb3VwPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VyaWVzR3JvdXBzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWFwIG9mIHZhbHVlcyBvZiBTZXJpZXNJdGVtc1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIEFycmF5LjxudW1iZXI+Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVzTWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxlZ2VuZCBsYWJlbHMgZm9yIHJlbmRlcmluZyBsZWdlbmQgYXJlYVxuICAgICAgICAgKiBAdHlwZSB7e2NvbHVtbjogQXJyYXkuPHN0cmluZz4sIGxpbmU6IEFycmF5LjxzdHJpbmc+IHwgQXJyYXkuPHN0cmluZz59fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZWdlbmRMYWJlbHMgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsZWdlbmQgZGF0YSBmb3IgcmVuZGVyaW5nIGxlZ2VuZFxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHtjaGFydFR5cGU6IHN0cmluZywgbGFiZWw6IHN0cmluZ30+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZWdlbmREYXRhID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZnVuY3Rpb25zIGZvciBmb3JtYXR0aW5nXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48ZnVuY3Rpb24+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXRGdW5jdGlvbnMgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtdWx0aWxpbmUgY2F0ZWdvcmllc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm11bHRpbGluZUNhdGVnb3JpZXMgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGNhdGVnb3JpZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IHByb2Nlc3NlZCBjYXRlZ29yaWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcHJvY2Vzc0NhdGVnb3JpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHRoaXMucmF3RGF0YS5jYXRlZ29yaWVzLCB0dWkudXRpbC5lbmNvZGVIVE1MRW50aXR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IENhdGVnb3JpZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59fVxuICAgICAqL1xuICAgIGdldENhdGVnb3JpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2F0ZWdvcmllcykge1xuICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWVzID0gdGhpcy5fcHJvY2Vzc0NhdGVnb3JpZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNhdGVnb3JpZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaGFzIGNhdGVnb3JpZXMgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0NhdGVnb3JpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldENhdGVnb3JpZXMoKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjYXRlZ29yeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjYXRlZ29yeVxuICAgICAqL1xuICAgIGdldENhdGVnb3J5OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYXRlZ29yaWVzKClbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3RhY2tzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBnZXRTdGFja3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrcyA9IHJhd0RhdGFIYW5kbGVyLnBpY2tTdGFja3ModGhpcy5yYXdEYXRhLnNlcmllcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzdGFjayBjb3VudC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFN0YWNrQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFja3MoKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgc3RhY2sgaW5kZXguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWNrIHN0YWNrXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmaW5kU3RhY2tJbmRleDogZnVuY3Rpb24oc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmluQXJyYXkoc3RhY2ssIHRoaXMuZ2V0U3RhY2tzKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgU2VyaWVzRGF0YU1vZGVsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge1Nlcmllc0RhdGFNb2RlbH1cbiAgICAgKi9cbiAgICBnZXRTZXJpZXNEYXRhTW9kZWw6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgcmF3U2VyaWVzRGF0YTtcblxuICAgICAgICBpZiAoIXRoaXMuc2VyaWVzRGF0YU1vZGVsTWFwW2NoYXJ0VHlwZV0pIHtcbiAgICAgICAgICAgIHJhd1Nlcmllc0RhdGEgPSB0aGlzLnJhd0RhdGEuc2VyaWVzW2NoYXJ0VHlwZV0gfHwgdGhpcy5yYXdEYXRhLnNlcmllcztcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzRGF0YU1vZGVsTWFwW2NoYXJ0VHlwZV0gPSBuZXcgU2VyaWVzRGF0YU1vZGVsKHJhd1Nlcmllc0RhdGEsIGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMsIHRoaXMuZ2V0Rm9ybWF0RnVuY3Rpb25zKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzRGF0YU1vZGVsTWFwW2NoYXJ0VHlwZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBncm91cCBjb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldEdyb3VwQ291bnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXJpZXNEYXRhTW9kZWwoY2hhcnRUeXBlKS5nZXRHcm91cENvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIGFsbCBTZXJpZXNEYXRhTW9kZWwgYnkgc2VyaWVzQ2hhcnRUeXBlcywgYW5kIGV4ZWN1dGVzIGl0ZXJhdGVlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZWFjaEJ5QWxsU2VyaWVzRGF0YU1vZGVsOiBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZXJpZXNDaGFydFR5cGVzID0gdGhpcy5zZXJpZXNDaGFydFR5cGVzIHx8IFt0aGlzLmNoYXJ0VHlwZV07XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHNlcmllc0NoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHNlbGYuZ2V0U2VyaWVzRGF0YU1vZGVsKGNoYXJ0VHlwZSksIGNoYXJ0VHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHZhbGlkIGFsbCBTZXJpZXNEYXRhTW9kZWwgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVmFsaWRBbGxTZXJpZXNEYXRhTW9kZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXNWYWxpZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fZWFjaEJ5QWxsU2VyaWVzRGF0YU1vZGVsKGZ1bmN0aW9uKHNlcmllc0RhdGFNb2RlbCkge1xuICAgICAgICAgICAgaXNWYWxpZCA9ICEhc2VyaWVzRGF0YU1vZGVsLmdldEdyb3VwQ291bnQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIFNlcmllc0dyb3Vwcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFNlcmllc0dyb3VwPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzR3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGpvaW5lZEdyb3VwcyA9IFtdLFxuICAgICAgICAgICAgc2VyaWVzR3JvdXBzO1xuXG4gICAgICAgIHRoaXMuX2VhY2hCeUFsbFNlcmllc0RhdGFNb2RlbChmdW5jdGlvbihzZXJpZXNEYXRhTW9kZWwpIHtcbiAgICAgICAgICAgIHNlcmllc0RhdGFNb2RlbC5lYWNoKGZ1bmN0aW9uKHNlcmllc0dyb3VwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICgham9pbmVkR3JvdXBzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICBqb2luZWRHcm91cHNbaW5kZXhdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpvaW5lZEdyb3Vwc1tpbmRleF0gPSBqb2luZWRHcm91cHNbaW5kZXhdLmNvbmNhdChzZXJpZXNHcm91cC5pdGVtcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2VyaWVzR3JvdXBzID0gdHVpLnV0aWwubWFwKGpvaW5lZEdyb3VwcywgZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VyaWVzR3JvdXAoaXRlbXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgU2VyaWVzR3JvdXBzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48U2VyaWVzR3JvdXA+fVxuICAgICAqL1xuICAgIGdldFNlcmllc0dyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXJpZXNHcm91cHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzR3JvdXBzID0gdGhpcy5fbWFrZVNlcmllc0dyb3VwcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllc0dyb3VwcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGluZGV4LCBjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VyaWVzRGF0YU1vZGVsKGNoYXJ0VHlwZSkuZ2V0VmFsdWUoZ3JvdXBJbmRleCwgaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdmFsdWVzIHRoYXQgcGlja2VkIHZhbHVlIGZyb20gU2VyaWVzSXRlbXMgb2Ygc3BlY2lmaWMgU2VyaWVzRGF0YU1vZGVsLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVUeXBlIC0gdHlwZSBvZiB2YWx1ZSBsaWtlIHZhbHVlLCB4LCB5LCByLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVWYWx1ZXM6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgdmFsdWVUeXBlKSB7XG4gICAgICAgIHZhciB2YWx1ZXM7XG5cbiAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gY2hhcnRDb25zdC5EVU1NWV9LRVkpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZWFjaEJ5QWxsU2VyaWVzRGF0YU1vZGVsKGZ1bmN0aW9uKHNlcmllc0RhdGFNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoc2VyaWVzRGF0YU1vZGVsLmdldFZhbHVlcyh2YWx1ZVR5cGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzID0gdGhpcy5nZXRTZXJpZXNEYXRhTW9kZWwoY2hhcnRUeXBlKS5nZXRWYWx1ZXModmFsdWVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWVzIGZyb20gdmFsdWVzTWFwLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVUeXBlIC0gdHlwZSBvZiB2YWx1ZSBsaWtlIHZhbHVlLCB4LCB5LCByLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgdmFsdWVUeXBlKSB7XG4gICAgICAgIHZhciBtYXBLZXk7XG5cbiAgICAgICAgY2hhcnRUeXBlID0gY2hhcnRUeXBlIHx8IGNoYXJ0Q29uc3QuRFVNTVlfS0VZO1xuXG4gICAgICAgIG1hcEtleSA9IGNoYXJ0VHlwZSArIHZhbHVlVHlwZTtcblxuICAgICAgICBpZiAoIXRoaXMudmFsdWVzTWFwW21hcEtleV0pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzTWFwW21hcEtleV0gPSB0aGlzLl9jcmVhdGVWYWx1ZXMoY2hhcnRUeXBlLCB2YWx1ZVR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzTWFwW21hcEtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBtYXggdmFsdWUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBjaGFydFR5cGUgLSB0eXBlIG9mIGNoYXJ0XG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZVR5cGUgLSB0eXBlIG9mIHZhbHVlIGxpa2UgdmFsdWUsIHgsIHksIHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldE1heFZhbHVlOiBmdW5jdGlvbihjaGFydFR5cGUsIHZhbHVlVHlwZSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWF4KHRoaXMuZ2V0VmFsdWVzKGNoYXJ0VHlwZSwgdmFsdWVUeXBlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmb3JtYXR0ZWQgbWF4IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gYXJlYVR5cGUgLSB0eXBlIG9mIGFyZWEgbGlrZSBjaXJjbGVMZWdlbmRcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlVHlwZSAtIHR5cGUgb2YgdmFsdWUgbGlrZSB2YWx1ZSwgeCwgeSwgclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCBudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Rm9ybWF0dGVkTWF4VmFsdWU6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgYXJlYVR5cGUsIHZhbHVlVHlwZSkge1xuICAgICAgICB2YXIgbWF4VmFsdWUgPSB0aGlzLmdldE1heFZhbHVlKGNoYXJ0VHlwZSwgdmFsdWVUeXBlKTtcbiAgICAgICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHRoaXMuZ2V0Rm9ybWF0RnVuY3Rpb25zKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlclV0aWwuZm9ybWF0VmFsdWUobWF4VmFsdWUsIGZvcm1hdEZ1bmN0aW9ucywgYXJlYVR5cGUsIHZhbHVlVHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIFNlcmllc0dyb3VwIG9mIGFsbCBTZXJpZXNEYXRhTW9kZWwsIGFuZCBleGVjdXRlcyBpdGVyYXRlZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGVhY2hCeVNlcmllc0dyb3VwOiBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB0aGlzLl9lYWNoQnlBbGxTZXJpZXNEYXRhTW9kZWwoZnVuY3Rpb24oc2VyaWVzRGF0YU1vZGVsLCBjaGFydFR5cGUpIHtcbiAgICAgICAgICAgIHNlcmllc0RhdGFNb2RlbC5lYWNoKGZ1bmN0aW9uKHNlcmllc0dyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZWUoc2VyaWVzR3JvdXAsIGdyb3VwSW5kZXgsIGNoYXJ0VHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgbGVnZW5kIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBsYWJlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BpY2tMZWdlbmRMYWJlbDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwuZW5jb2RlSFRNTEVudGl0eShpdGVtLm5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIGxlZ2VuZCBsYWJlbHMgZnJvbSByYXcgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IGxhYmVsc1xuICAgICAqL1xuICAgIF9waWNrTGVnZW5kTGFiZWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VyaWVzRGF0YSA9IHRoaXMucmF3RGF0YS5zZXJpZXMsXG4gICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgIGlmICh0dWkudXRpbC5pc0FycmF5KHNlcmllc0RhdGEpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0dWkudXRpbC5tYXAoc2VyaWVzRGF0YSwgdGhpcy5fcGlja0xlZ2VuZExhYmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNEYXRhLCBmdW5jdGlvbihzZXJpZXNEYXR1bSwgdHlwZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFt0eXBlXSA9IHR1aS51dGlsLm1hcChzZXJpZXNEYXR1bSwgc2VsZi5fcGlja0xlZ2VuZExhYmVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxlZ2VuZCBsYWJlbHMuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPiB8IHtjb2x1bW46ID9BcnJheS48c3RyaW5nPiwgbGluZTogP0FycmF5LjxzdHJpbmc+fX0gbGVnZW5kIGxhYmVsc1xuICAgICAqL1xuICAgIGdldExlZ2VuZExhYmVsczogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIGlmICghdGhpcy5sZWdlbmRMYWJlbHMpIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kTGFiZWxzID0gdGhpcy5fcGlja0xlZ2VuZExhYmVscygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZExhYmVsc1tjaGFydFR5cGVdIHx8IHRoaXMubGVnZW5kTGFiZWxzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxlZ2VuZCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gbGFiZWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxlZ2VuZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGVnZW5kTGFiZWxzID0gdGhpcy5nZXRMZWdlbmRMYWJlbHMoKSxcbiAgICAgICAgICAgIHNlcmllc0NoYXJ0VHlwZXMgPSB0aGlzLnNlcmllc0NoYXJ0VHlwZXMgfHwgW3RoaXMuY2hhcnRUeXBlXSxcbiAgICAgICAgICAgIGxlZ2VuZExhYmVsc01hcCwgbGVnZW5kRGF0YTtcblxuICAgICAgICBpZiAodHVpLnV0aWwuaXNBcnJheShsZWdlbmRMYWJlbHMpKSB7XG4gICAgICAgICAgICBsZWdlbmRMYWJlbHNNYXAgPSBbdGhpcy5jaGFydFR5cGVdO1xuICAgICAgICAgICAgbGVnZW5kTGFiZWxzTWFwW3RoaXMuY2hhcnRUeXBlXSA9IGxlZ2VuZExhYmVscztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcmllc0NoYXJ0VHlwZXMgPSB0aGlzLnNlcmllc0NoYXJ0VHlwZXM7XG4gICAgICAgICAgICBsZWdlbmRMYWJlbHNNYXAgPSBsZWdlbmRMYWJlbHM7XG4gICAgICAgIH1cblxuICAgICAgICBsZWdlbmREYXRhID0gdHVpLnV0aWwubWFwKHNlcmllc0NoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChsZWdlbmRMYWJlbHNNYXBbY2hhcnRUeXBlXSwgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29uY2F0LmFwcGx5KFtdLCBsZWdlbmREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxlZ2VuZCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e2NoYXJ0VHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nfT59IGxlZ2VuZCBkYXRhXG4gICAgICovXG4gICAgZ2V0TGVnZW5kRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5sZWdlbmREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmxlZ2VuZERhdGEgPSB0aGlzLl9tYWtlTGVnZW5kRGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm9yaWdpbmFsTGVnZW5kRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbExlZ2VuZERhdGEgPSB0aGlzLmxlZ2VuZERhdGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sZWdlbmREYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgb3JpZ2luYWwgbGVnZW5kIGRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7Y2hhcnRUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmd9Pn1cbiAgICAgKi9cbiAgICBnZXRPcmlnaW5hbExlZ2VuZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbExlZ2VuZERhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBsZWdlbmQgaXRlbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e2NoYXJ0VHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nfX0gbGVnZW5kIGRhdGFcbiAgICAgKi9cbiAgICBnZXRMZWdlbmRJdGVtOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMZWdlbmREYXRhKClbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZm9ybWF0IGZ1bmN0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPGZ1bmN0aW9uPn0gZnVuY3Rpb25zXG4gICAgICovXG4gICAgZ2V0Rm9ybWF0RnVuY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZvcm1hdEZ1bmN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXRGdW5jdGlvbnMgPSB0aGlzLl9maW5kRm9ybWF0RnVuY3Rpb25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRGdW5jdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmaXJzdCBsYWJlbCBvZiBTZXJpZXNJdGVtLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0VHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqL1xuICAgIGdldEZpcnN0SXRlbUxhYmVsOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VyaWVzRGF0YU1vZGVsKGNoYXJ0VHlwZSkuZ2V0Rmlyc3RJdGVtTGFiZWwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGljayBtYXggbGVuZ3RoIHVuZGVyIHBvaW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHZhbHVlcyBjaGFydCB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBtYXggbGVuZ3RoIHVuZGVyIHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGlja01heExlblVuZGVyUG9pbnQ6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICB2YXIgbWF4ID0gMDtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHR1aS51dGlsLmdldERlY2ltYWxMZW5ndGgodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGxlbiA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB6ZXJvIGZpbGwgZm9ybWF0IG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IGZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzWmVyb0ZpbGw6IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0Lmxlbmd0aCA+IDIgJiYgZm9ybWF0LmNoYXJBdCgwKSA9PT0gJzAnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGRlY2ltYWwgZm9ybWF0IG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IGZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzRGVjaW1hbDogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBpbmRleE9mID0gZm9ybWF0LmluZGV4T2YoJy4nKTtcblxuICAgICAgICByZXR1cm4gaW5kZXhPZiA+IC0xICYmIGluZGV4T2YgPCBmb3JtYXQubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjb21tYSBmb3JtYXQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgZm9ybWF0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNDb21tYTogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQuaW5kZXhPZignLCcpID4gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB0byB6ZXJvIGZpbGwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbiBsZW5ndGggb2YgcmVzdWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRhcmdldCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Zvcm1hdFRvWmVyb0ZpbGw6IGZ1bmN0aW9uKGxlbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGlzTWludXMgPSB2YWx1ZSA8IDA7XG5cbiAgICAgICAgdmFsdWUgPSByZW5kZXJVdGlsLmZvcm1hdFRvWmVyb0ZpbGwoTWF0aC5hYnModmFsdWUpLCBsZW4pO1xuXG4gICAgICAgIHJldHVybiAoaXNNaW51cyA/ICctJyA6ICcnKSArIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdG8gRGVjaW1hbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuIGxlbmd0aCBvZiB1bmRlciBkZWNpbWFsIHBvaW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRhcmdldCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Zvcm1hdFRvRGVjaW1hbDogZnVuY3Rpb24obGVuLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVuZGVyVXRpbC5mb3JtYXRUb0RlY2ltYWwodmFsdWUsIGxlbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgc2ltcGxlIHR5cGUgZm9ybWF0IGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gc2ltcGxlIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48ZnVuY3Rpb24+fVxuICAgICAqL1xuICAgIF9maW5kU2ltcGxlVHlwZUZvcm1hdEZ1bmN0aW9uczogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBmdW5jcyA9IFtdO1xuICAgICAgICB2YXIgbGVuO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc0RlY2ltYWwoZm9ybWF0KSkge1xuICAgICAgICAgICAgbGVuID0gdGhpcy5fcGlja01heExlblVuZGVyUG9pbnQoW2Zvcm1hdF0pO1xuICAgICAgICAgICAgZnVuY3MgPSBbdHVpLnV0aWwuYmluZCh0aGlzLl9mb3JtYXRUb0RlY2ltYWwsIHRoaXMsIGxlbildO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzWmVyb0ZpbGwoZm9ybWF0KSkge1xuICAgICAgICAgICAgbGVuID0gZm9ybWF0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZ1bmNzID0gW3R1aS51dGlsLmJpbmQodGhpcy5fZm9ybWF0VG9aZXJvRmlsbCwgdGhpcywgbGVuKV07XG4gICAgICAgICAgICByZXR1cm4gZnVuY3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faXNDb21tYShmb3JtYXQpKSB7XG4gICAgICAgICAgICBmdW5jcy5wdXNoKHJlbmRlclV0aWwuZm9ybWF0VG9Db21tYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgZm9ybWF0IGZ1bmN0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb25bXX0gZnVuY3Rpb25zXG4gICAgICovXG4gICAgX2ZpbmRGb3JtYXRGdW5jdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdHVpLnV0aWwucGljayh0aGlzLm9wdGlvbnMsICdjaGFydCcsICdmb3JtYXQnKTtcbiAgICAgICAgdmFyIGZ1bmNzID0gW107XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzRnVuY3Rpb24oZm9ybWF0KSkge1xuICAgICAgICAgICAgZnVuY3MgPSBbZm9ybWF0XTtcbiAgICAgICAgfSBlbHNlIGlmICh0dWkudXRpbC5pc1N0cmluZyhmb3JtYXQpKSB7XG4gICAgICAgICAgICBmdW5jcyA9IHRoaXMuX2ZpbmRTaW1wbGVUeXBlRm9ybWF0RnVuY3Rpb25zKGZvcm1hdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbXVsdGlsaW5lIGNhdGVnb3J5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSBjYXRlZ29yeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFdpZHRoIGxpbWl0IHdpZHRoXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbXVsdGlsaW5lIGNhdGVnb3J5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU11bHRpbGluZUNhdGVnb3J5OiBmdW5jdGlvbihjYXRlZ29yeSwgbGltaXRXaWR0aCwgdGhlbWUpIHtcbiAgICAgICAgdmFyIHdvcmRzID0gU3RyaW5nKGNhdGVnb3J5KS5zcGxpdCgvXFxzKy8pLFxuICAgICAgICAgICAgbGluZVdvcmRzID0gd29yZHNbMF0sXG4gICAgICAgICAgICBsaW5lcyA9IFtdO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh3b3Jkcy5zbGljZSgxKSwgZnVuY3Rpb24od29yZCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGluZVdvcmRzICsgJyAnICsgd29yZCwgdGhlbWUpO1xuXG4gICAgICAgICAgICBpZiAod2lkdGggPiBsaW1pdFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChsaW5lV29yZHMpO1xuICAgICAgICAgICAgICAgIGxpbmVXb3JkcyA9IHdvcmQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmVXb3JkcyArPSAnICcgKyB3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobGluZVdvcmRzKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmVXb3Jkcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZXMuam9pbignPGJyPicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbXVsdGlsaW5lIGNhdGVnb3JpZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0V2lkdGggbGltaXQgd2lkdGhcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjwobnVtYmVyIHwgc3RyaW5nKT59IHhBeGlzTGFiZWxzIGxhYmVscyBvZiB4QXhpc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gbXVsdGlsaW5lIGNhdGVnb3JpZXNcbiAgICAgKi9cbiAgICBnZXRNdWx0aWxpbmVDYXRlZ29yaWVzOiBmdW5jdGlvbihsaW1pdFdpZHRoLCB0aGVtZSwgeEF4aXNMYWJlbHMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5tdWx0aWxpbmVDYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICB0aGlzLm11bHRpbGluZUNhdGVnb3JpZXMgPSB0dWkudXRpbC5tYXAoeEF4aXNMYWJlbHMsIGZ1bmN0aW9uKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX21ha2VNdWx0aWxpbmVDYXRlZ29yeShjYXRlZ29yeSwgbGltaXRXaWR0aCwgdGhlbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aWxpbmVDYXRlZ29yaWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSByYXRpb3Mgb2YgcGllIGNoYXJ0LlxuICAgICAqL1xuICAgIGFkZERhdGFSYXRpb3NPZlBpZUNoYXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRTZXJpZXNEYXRhTW9kZWwoY2hhcnRDb25zdC5DSEFSVF9UWVBFX1BJRSkuYWRkRGF0YVJhdGlvc09mUGllQ2hhcnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zIGZvciBjaGFydCBvZiBjb29yZGluYXRlIHR5cGUuXG4gICAgICogQHBhcmFtIHt7eDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHk6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fX0gbGltaXRNYXAgLSBsaW1pdCBtYXBcbiAgICAgKi9cbiAgICBhZGREYXRhUmF0aW9zRm9yQ29vcmRpbmF0ZVR5cGU6IGZ1bmN0aW9uKGxpbWl0TWFwKSB7XG4gICAgICAgIHRoaXMuZ2V0U2VyaWVzRGF0YU1vZGVsKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9CVUJCTEUpLmFkZERhdGFSYXRpb3NGb3JDb29yZGluYXRlVHlwZShsaW1pdE1hcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBzdGFydCB2YWx1ZSB0byBhbGwgc2VyaWVzIGl0ZW0uXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgLSBsaW1pdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSBjaGFydCB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkU3RhcnRWYWx1ZVRvQWxsU2VyaWVzSXRlbTogZnVuY3Rpb24obGltaXQsIGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgICAgIGlmIChsaW1pdC5taW4gPj0gMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBsaW1pdC5taW47XG4gICAgICAgIH0gZWxzZSBpZiAobGltaXQubWF4IDw9IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gbGltaXQubWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZXRTZXJpZXNEYXRhTW9kZWwoY2hhcnRUeXBlKS5hZGRTdGFydFZhbHVlVG9BbGxTZXJpZXNJdGVtKHN0YXJ0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgcGVyY2VudCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgYXhpcyBsaW1pdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja2VkIHN0YWNrZWQgb3B0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGREYXRhUmF0aW9zOiBmdW5jdGlvbihsaW1pdCwgc3RhY2tlZCwgY2hhcnRUeXBlKSB7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLmdldFNlcmllc0RhdGFNb2RlbChjaGFydFR5cGUpO1xuXG4gICAgICAgIHRoaXMuX2FkZFN0YXJ0VmFsdWVUb0FsbFNlcmllc0l0ZW0obGltaXQsIGNoYXJ0VHlwZSk7XG4gICAgICAgIHNlcmllc0RhdGFNb2RlbC5hZGREYXRhUmF0aW9zKGxpbWl0LCBzdGFja2VkKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhUHJvY2Vzc29yO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERhdGEgcHJvY2Vzc29yIGZvciBtYXAgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhUHJvY2Vzc29yID0gcmVxdWlyZSgnLi9kYXRhUHJvY2Vzc29yJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG4vKipcbiAqIFJhdyBzZXJpZXMgZGF0YS5cbiAqIEB0eXBlZGVmIHtBcnJheS48e2NvZGU6IHN0cmluZywgbmFtZTogP3N0cmluZywgZGF0YTogbnVtYmVyfT59IHJhd1Nlcmllc0RhdGFcbiAqL1xuXG4vKipcbiAqIFZhbHVlIG1hcC5cbiAqIEB0eXBlZGVmIHt7dmFsdWU6IG51bWJlciwgbGFiZWw6IHN0cmluZywgbmFtZTogP3N0cmluZ319IHZhbHVlTWFwXG4gKi9cblxudmFyIE1hcENoYXJ0RGF0YVByb2Nlc3NvciA9IHR1aS51dGlsLmRlZmluZUNsYXNzKERhdGFQcm9jZXNzb3IsIC8qKiBAbGVuZHMgTWFwQ2hhcnREYXRhUHJvY2Vzc29yLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBEYXRhIHByb2Nlc3NvciBmb3IgbWFwIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIE1hcENoYXJ0RGF0YVByb2Nlc3NvclxuICAgICAqIEBleHRlbmRzIERhdGFQcm9jZXNzb3JcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgRGF0YVByb2Nlc3Nvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcmF3IGRhdGEuXG4gICAgICogQHBhcmFtIHt7c2VyaWVzOiByYXdTZXJpZXNEYXRhfX0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqL1xuICAgIGluaXREYXRhOiBmdW5jdGlvbihyYXdEYXRhKSB7XG4gICAgICAgIHRoaXMucmF3RGF0YSA9IHJhd0RhdGE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhbHVlIG1hcFxuICAgICAgICAgKiBAdHlwZSB7dmFsdWVNYXB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlTWFwID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB2YWx1ZSBtYXAuXG4gICAgICogQHJldHVybnMge3ZhbHVlTWFwfSB2YWx1ZSBtYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmFsdWVNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmF3U2VyaWVzRGF0YSA9IHRoaXMucmF3RGF0YS5zZXJpZXMsXG4gICAgICAgICAgICB2YWx1ZU1hcCA9IHt9LFxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5fZmluZEZvcm1hdEZ1bmN0aW9ucygpO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShyYXdTZXJpZXNEYXRhLCBmdW5jdGlvbihkYXR1bSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0dW0uZGF0YSxcbiAgICAgICAgICAgICAgICBsYWJlbDogcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZShkYXR1bS5kYXRhLCBmb3JtYXRGdW5jdGlvbnMsICdzZXJpZXMnKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGRhdHVtLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubmFtZSA9IGRhdHVtLm5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXR1bS5sYWJlbENvb3JkaW5hdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubGFiZWxDb29yZGluYXRlID0gZGF0dW0ubGFiZWxDb29yZGluYXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZU1hcFtkYXR1bS5jb2RlXSA9IHJlc3VsdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWUgbWFwLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG4gICAgZ2V0VmFsdWVNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWVNYXApIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVNYXAgPSB0aGlzLl9tYWtlVmFsdWVNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IHBpY2tlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0VmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLnBsdWNrKHRoaXMuZ2V0VmFsdWVNYXAoKSwgJ3ZhbHVlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB2YWx1ZU1hcCBkYXR1bS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSBtYXAgY29kZVxuICAgICAqIEByZXR1cm5zIHt7Y29kZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGxhYmVsOiBudW1iZXIsXG4gICAgICogICAgICAgICAgICAgIGxhYmVsQ29vcmRpbmF0ZToge3g6IG51bWJlciwgeTogbnVtYmVyfX19IHZhbHVlTWFwIGRhdHVtXG4gICAgICovXG4gICAgZ2V0VmFsdWVNYXBEYXR1bTogZnVuY3Rpb24oY29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZU1hcCgpW2NvZGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSByYXRpb3Mgb2YgbWFwIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGxpbWl0IGF4aXMgbGltaXRcbiAgICAgKi9cbiAgICBhZGREYXRhUmF0aW9zOiBmdW5jdGlvbihsaW1pdCkge1xuICAgICAgICB2YXIgbWluID0gbGltaXQubWluLFxuICAgICAgICAgICAgbWF4ID0gbGltaXQubWF4IC0gbWluO1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHRoaXMuZ2V0VmFsdWVNYXAoKSwgZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBtYXAucmF0aW8gPSAobWFwLnZhbHVlIC0gbWluKSAvIG1heDtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2hhcnREYXRhUHJvY2Vzc29yO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlcmllc0RhdGFNb2RlbCBpcyBiYXNlIG1vZGVsIGZvciBkcmF3aW5nIGdyYXBoIG9mIGNoYXJ0IHNlcmllcyBhcmVhLFxuICogICAgICAgICAgICAgICAgICBhbmQgY3JlYXRlIGZyb20gcmF3U2VyaWVzRGF0YSBieSB1c2VyLFxuICogU2VyaWVzRGF0YU1vZGVsLmdyb3VwcyBoYXMgU2VyaWVzR3JvdXBzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJhdyBzZXJpZXMgZGF0dW0uXG4gKiBAdHlwZWRlZiB7e25hbWU6ID9zdHJpbmcsIGRhdGE6IEFycmF5LjxudW1iZXI+LCBzdGFjazogP3N0cmluZ319IHJhd1Nlcmllc0RhdHVtXG4gKi9cblxuLyoqXG4gKiBSYXcgc2VyaWVzIGRhdGEuXG4gKiBAdHlwZWRlZiB7QXJyYXkuPHJhd1Nlcmllc0RhdHVtPn0gcmF3U2VyaWVzRGF0YVxuICovXG5cbi8qKlxuICogR3JvdXBzLlxuICogQHR5cGVkZWYge0FycmF5LjxTZXJpZXNHcm91cD59IGdyb3Vwc1xuICovXG5cbi8qKlxuICogU2VyaWVzR3JvdXAgaXMgYSBlbGVtZW50IG9mIFNlcmllc0RhdGFNb2RlbC5ncm91cHMuXG4gKiBTZXJpZXNHcm91cC5pdGVtcyBoYXMgU2VyaWVzSXRlbS5cbiAqL1xuXG4vKipcbiAqIFNlcmllc0l0ZW0gaXMgYSBlbGVtZW50IG9mIFNlcmllc0dyb3VwLml0ZW1zLlxuICogU2VyaWVzSXRlbSBoYXMgcHJvY2Vzc2VkIHRlcm1pbmFsIGRhdGEgbGlrZSB2YWx1ZSwgcmF0aW8sIGV0Yy5cbiAqL1xuXG52YXIgU2VyaWVzR3JvdXAgPSByZXF1aXJlKCcuL3Nlcmllc0dyb3VwJyksXG4gICAgU2VyaWVzSXRlbSA9IHJlcXVpcmUoJy4vc2VyaWVzSXRlbScpLFxuICAgIFNlcmllc0l0ZW1Gb3JDb29yZGluYXRlVHlwZSA9IHJlcXVpcmUoJy4vc2VyaWVzSXRlbUZvckNvb3JkaW5hdGVUeXBlJyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxjdWxhdG9yJyk7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG52YXIgU2VyaWVzRGF0YU1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBTZXJpZXNEYXRhTW9kZWwucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIFNlcmllc0RhdGFNb2RlbCBpcyBiYXNlIG1vZGVsIGZvciBkcmF3aW5nIGdyYXBoIG9mIGNoYXJ0IHNlcmllcyBhcmVhLFxuICAgICAqICAgICAgYW5kIGNyZWF0ZSBmcm9tIHJhd1Nlcmllc0RhdGEgYnkgdXNlci5cbiAgICAgKiBTZXJpZXNEYXRhTW9kZWwuZ3JvdXBzIGhhcyBTZXJpZXNHcm91cHMuXG4gICAgICogQGNvbnN0cnVjdHMgU2VyaWVzRGF0YU1vZGVsXG4gICAgICogQHBhcmFtIHtyYXdTZXJpZXNEYXRhfSByYXdTZXJpZXNEYXRhIHJhdyBzZXJpZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxmdW5jdGlvbj59IGZvcm1hdEZ1bmN0aW9ucyBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3U2VyaWVzRGF0YSwgY2hhcnRUeXBlLCBvcHRpb25zLCBmb3JtYXRGdW5jdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCBvcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmdW5jdGlvbnMgZm9yIGZvcm1hdHRpbmdcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxmdW5jdGlvbj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvcm1hdEZ1bmN0aW9ucyA9IGZvcm1hdEZ1bmN0aW9ucztcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmF3RGF0YS5zZXJpZXNcbiAgICAgICAgICogQHR5cGUge3Jhd1Nlcmllc0RhdGF9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhd1Nlcmllc0RhdGEgPSByYXdTZXJpZXNEYXRhIHx8IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiYXNlR3JvdXBzIGlzIGJhc2UgZGF0YSBmb3IgbWFraW5nIFNlcmllc0dyb3Vwcy5cbiAgICAgICAgICogU2VyaWVzR3JvdXBzIGlzIG1hZGUgYnkgcGl2b3RlZCBiYXNlR3JvdXBzLCBsZiBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS5BcnJheTxTZXJpZXNJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmFzZUdyb3VwcyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdyb3VwcyBoYXMgU2VyaWVzR3JvdXBzLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPFNlcmllc0dyb3VwPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWFwIG9mIHZhbHVlcyBieSB2YWx1ZSB0eXBlIGxpa2UgdmFsdWUsIHgsIHksIHIuXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3QuPHN0cmluZywgQXJyYXkuPG51bWJlcj4+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZXNNYXAgPSB7fTtcblxuICAgICAgICB0aGlzLl9yZW1vdmVSYW5nZVZhbHVlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSByYW5nZSB2YWx1ZSBvZiBpdGVtLCBpZiBoYXMgc3RhY2tlZCBvcHRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlUmFuZ2VWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNPcHRpb24gPSB0dWkudXRpbC5waWNrKHRoaXMub3B0aW9ucywgJ3NlcmllcycpIHx8IHt9O1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNBbGxvd1JhbmdlRGF0YSh0aGlzLmNoYXJ0VHlwZSkgJiZcbiAgICAgICAgICAgICFwcmVkaWNhdGUuaXNWYWxpZFN0YWNrZWRPcHRpb24oc2VyaWVzT3B0aW9uLnN0YWNrZWQpICYmICFzZXJpZXNPcHRpb24uc3BsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5yYXdTZXJpZXNEYXRhLCBmdW5jdGlvbihyYXdJdGVtKSB7XG4gICAgICAgICAgICBpZiAoIXR1aS51dGlsLmlzQXJyYXkocmF3SXRlbS5kYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShyYXdJdGVtLmRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJhd0l0ZW0uZGF0YVtpbmRleF0gPSBjb25jYXQuYXBwbHkodmFsdWUpWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYmFzZSBncm91cHMuXG4gICAgICogQmFzZSBncm91cHMgaXMgdHdvLWRpbWVuc2lvbmFsIGFycmF5IGJ5IHNlcmllc0l0ZW1zLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPChTZXJpZXNJdGVtIHwgU2VyaWVzSXRlbUZvckNvb3JkaW5hdGVUeXBlKT4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUJhc2VHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBTZXJpZXNJdGVtQ2xhc3M7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0J1YmJsZUNoYXJ0KHRoaXMuY2hhcnRUeXBlKSkge1xuICAgICAgICAgICAgU2VyaWVzSXRlbUNsYXNzID0gU2VyaWVzSXRlbUZvckNvb3JkaW5hdGVUeXBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgU2VyaWVzSXRlbUNsYXNzID0gU2VyaWVzSXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodGhpcy5yYXdTZXJpZXNEYXRhLCBmdW5jdGlvbihyYXdEYXR1bSkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChjb25jYXQuYXBwbHkocmF3RGF0dW0uZGF0YSksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXJpZXNJdGVtQ2xhc3ModmFsdWUsIHJhd0RhdHVtLnN0YWNrLCBzZWxmLmZvcm1hdEZ1bmN0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBiYXNlIGdyb3Vwcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuQXJyYXkuPFNlcmllc0l0ZW0+fVxuICAgICAqL1xuICAgIGdldEJhc2VHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuYmFzZUdyb3Vwcykge1xuICAgICAgICAgICAgdGhpcy5iYXNlR3JvdXBzID0gdGhpcy5fY3JlYXRlQmFzZUdyb3VwcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUdyb3VwcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFNlcmllc0dyb3VwcyBmcm9tIHJhd0RhdGEuc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQaXZvdCAtIHdoZXRoZXIgcGl2b3Qgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48U2VyaWVzR3JvdXA+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVNlcmllc0dyb3Vwc0Zyb21SYXdEYXRhOiBmdW5jdGlvbihpc1Bpdm90KSB7XG4gICAgICAgIHZhciBiYXNlR3JvdXBzID0gdGhpcy5nZXRCYXNlR3JvdXBzKCk7XG5cbiAgICAgICAgaWYgKGlzUGl2b3QpIHtcbiAgICAgICAgICAgIGJhc2VHcm91cHMgPSB0dWkudXRpbC5waXZvdChiYXNlR3JvdXBzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoYmFzZUdyb3VwcywgZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VyaWVzR3JvdXAoaXRlbXMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IFNlcmllc0dyb3Vwcy5cbiAgICAgKiBAcmV0dXJucyB7KEFycmF5LjxTZXJpZXNHcm91cD58b2JqZWN0KX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTZXJpZXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JvdXBzKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwcyA9IHRoaXMuX2NyZWF0ZVNlcmllc0dyb3Vwc0Zyb21SYXdEYXRhKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZ3JvdXAgY291bnQuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRHcm91cENvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNlcmllc0dyb3VwcygpLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHBpdm90IGdyb3Vwcy5cbiAgICAgKiBAcmV0dXJucyB7KEFycmF5LjxTZXJpZXNHcm91cD58b2JqZWN0KX1cbiAgICAgKi9cbiAgICBfZ2V0UGl2b3RHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucGl2b3RHcm91cHMpIHtcbiAgICAgICAgICAgIHRoaXMucGl2b3RHcm91cHMgPSB0aGlzLl9jcmVhdGVTZXJpZXNHcm91cHNGcm9tUmF3RGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGl2b3RHcm91cHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBTZXJpZXNHcm91cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtTZXJpZXNHcm91cH1cbiAgICAgKi9cbiAgICBnZXRTZXJpZXNHcm91cDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNlcmllc0dyb3VwcygpW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGZpcnN0IFNlcmllc0dyb3VwLlxuICAgICAqIEByZXR1cm5zIHtTZXJpZXNHcm91cH1cbiAgICAgKi9cbiAgICBnZXRGaXJzdFNlcmllc0dyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VyaWVzR3JvdXAoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmaXJzdCBsYWJlbCBvZiBTZXJpZXNJdGVtLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqL1xuICAgIGdldEZpcnN0SXRlbUxhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rmlyc3RTZXJpZXNHcm91cCgpLmdldEZpcnN0U2VyaWVzSXRlbSgpLmxhYmVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VyaWVzIGl0ZW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggLSBpbmRleCBvZiBzZXJpZXMgZ3JvdXBzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygc2VyaWVzIGl0ZW1zXG4gICAgICogQHJldHVybnMge1Nlcmllc0l0ZW19XG4gICAgICovXG4gICAgZ2V0U2VyaWVzSXRlbTogZnVuY3Rpb24oZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VyaWVzR3JvdXAoZ3JvdXBJbmRleCkuZ2V0U2VyaWVzSXRlbShpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmaXJzdCBzZXJpZXMgaXRlbS5cbiAgICAgKiBAcmV0dXJucyB7U2VyaWVzSXRlbX1cbiAgICAgKi9cbiAgICBnZXRGaXJzdFNlcmllc0l0ZW06IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXJpZXNJdGVtKDAsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggLSBpbmRleCBvZiBzZXJpZXMgZ3JvdXBzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygc2VyaWVzIGl0ZW1zXG4gICAgICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VyaWVzSXRlbShncm91cEluZGV4LCBpbmRleCkudmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVR5cGUgLSB2YWx1ZSB0eXBlIGxpa2UgdmFsdWUsIHgsIHksIHIuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRNaW5WYWx1ZTogZnVuY3Rpb24odmFsdWVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5taW4odGhpcy5nZXRWYWx1ZXModmFsdWVUeXBlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVR5cGUgLSB2YWx1ZSB0eXBlIGxpa2UgdmFsdWUsIHgsIHksIHIuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRNYXhWYWx1ZTogZnVuY3Rpb24odmFsdWVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXgodGhpcy5nZXRWYWx1ZXModmFsdWVUeXBlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIHNlcmllc0dyb3VwcywgYW5kIHJldHVybnMgdG8gZm91bmQgU2VyaWVzSXRlbSBieSByZXN1bHQgb2YgZXhlY3V0aW9uIHNlcmllc0dyb3VwLmZpbmQgd2l0aCBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZGl0aW9uIC0gY29uZGl0aW9uIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1Nlcmllc0l0ZW19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZFNlcmllc0l0ZW06IGZ1bmN0aW9uKGNvbmRpdGlvbikge1xuICAgICAgICB2YXIgZm91bmRJdGVtO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihzZXJpZXNHcm91cCkge1xuICAgICAgICAgICAgZm91bmRJdGVtID0gc2VyaWVzR3JvdXAuZmluZChjb25kaXRpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gIWZvdW5kSXRlbTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kSXRlbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBTZXJpZXNJdGVtIGJ5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVR5cGUgLSB2YWx1ZSB0eXBlIGxpa2UgdmFsdWUsIHgsIHksIHIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gY29tcGFyaW5nIHZhbHVlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZGl0aW9uIC0gY29uZGl0aW9uIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1Nlcmllc0l0ZW19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZFNlcmllc0l0ZW1CeVZhbHVlOiBmdW5jdGlvbih2YWx1ZVR5cGUsIHZhbHVlLCBjb25kaXRpb24pIHtcbiAgICAgICAgY29uZGl0aW9uID0gY29uZGl0aW9uIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kU2VyaWVzSXRlbShmdW5jdGlvbihzZXJpZXNJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzSXRlbSAmJiAoc2VyaWVzSXRlbVt2YWx1ZVR5cGVdID09PSB2YWx1ZSkgJiYgY29uZGl0aW9uKHNlcmllc0l0ZW0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBtaW5pbXVtIFNlcmllc0l0ZW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlVHlwZSAtIHZhbHVlIHR5cGUgbGlrZSB2YWx1ZSwgeCwgeSwgci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gLSBjb25kaXRpb24gZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7U2VyaWVzSXRlbX1cbiAgICAgKi9cbiAgICBmaW5kTWluU2VyaWVzSXRlbTogZnVuY3Rpb24odmFsdWVUeXBlLCBjb25kaXRpb24pIHtcbiAgICAgICAgdmFyIG1pblZhbHVlID0gdGhpcy5nZXRNaW5WYWx1ZSh2YWx1ZVR5cGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kU2VyaWVzSXRlbUJ5VmFsdWUodmFsdWVUeXBlLCBtaW5WYWx1ZSwgY29uZGl0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBtYXhpbXVtIFNlcmllc0l0ZW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlVHlwZSAtIHZhbHVlIHR5cGUgbGlrZSB2YWx1ZSwgeCwgeSwgci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gLSBjb25kaXRpb24gZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7KnxTZXJpZXNJdGVtfVxuICAgICAqL1xuICAgIGZpbmRNYXhTZXJpZXNJdGVtOiBmdW5jdGlvbih2YWx1ZVR5cGUsIGNvbmRpdGlvbikge1xuICAgICAgICB2YXIgbWF4VmFsdWUgPSB0aGlzLmdldE1heFZhbHVlKHZhbHVlVHlwZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRTZXJpZXNJdGVtQnlWYWx1ZSh2YWx1ZVR5cGUsIG1heFZhbHVlLCBjb25kaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdmFsdWVzIHRoYXQgcGlja2VkIHZhbHVlIGZyb20gU2VyaWVzSXRlbXMgb2YgU2VyaWVzR3JvdXBzLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVUeXBlIC0gdHlwZSBvZiB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVWYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlVHlwZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5tYXAoZnVuY3Rpb24oc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNHcm91cC5nZXRWYWx1ZXModmFsdWVUeXBlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgdmFsdWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlcyBmb3JtIHZhbHVlc01hcC5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlVHlwZSAtIHR5cGUgb2YgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgZ2V0VmFsdWVzOiBmdW5jdGlvbih2YWx1ZVR5cGUpIHtcbiAgICAgICAgdmFsdWVUeXBlID0gdmFsdWVUeXBlIHx8ICd2YWx1ZSc7XG5cbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlc01hcFt2YWx1ZVR5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlc01hcFt2YWx1ZVR5cGVdID0gdGhpcy5fY3JlYXRlVmFsdWVzKHZhbHVlVHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNNYXBbdmFsdWVUeXBlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjb3VudCBvZiB4IHZhbHVlcyBncmVhdGVyIHRoYW4gY291bnQgb2YgeSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNYQ291bnRHcmVhdGVyVGhhbllDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygneCcpLmxlbmd0aCA+IHRoaXMuZ2V0VmFsdWVzKCd5JykubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgcmF0aW9zLCB3aGVuIGhhcyBub3JtYWwgc3RhY2tlZCBvcHRpb24uXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgLSBheGlzIGxpbWl0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkUmF0aW9zV2hlbk5vcm1hbFN0YWNrZWQ6IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKGxpbWl0Lm1heCAtIGxpbWl0Lm1pbik7XG5cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKHNlcmllc0dyb3VwKSB7XG4gICAgICAgICAgICBzZXJpZXNHcm91cC5hZGRSYXRpb3MoZGlzdGFuY2UpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGJhc2UgcmF0aW8gZm9yIGNhbGN1bGF0aW5nIHJhdGlvIG9mIGl0ZW0uXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVCYXNlUmF0aW86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoKSxcbiAgICAgICAgICAgIHBsdXNTdW0gPSBjYWxjdWxhdG9yLnN1bVBsdXNWYWx1ZXModmFsdWVzKSxcbiAgICAgICAgICAgIG1pbnVzU3VtID0gTWF0aC5hYnMoY2FsY3VsYXRvci5zdW1NaW51c1ZhbHVlcyh2YWx1ZXMpKSxcbiAgICAgICAgICAgIHJhdGlvID0gKHBsdXNTdW0gPiAwICYmIG1pbnVzU3VtID4gMCkgPyAwLjUgOiAxO1xuXG4gICAgICAgIHJldHVybiByYXRpbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHJhdGlvcywgd2hlbiBoYXMgcGVyY2VudCBzdGFja2VkIG9wdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRSYXRpb3NXaGVuUGVyY2VudFN0YWNrZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmFzZVJhdGlvID0gdGhpcy5fY2FsY3VsYXRlQmFzZVJhdGlvKCk7XG5cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKHNlcmllc0dyb3VwKSB7XG4gICAgICAgICAgICBzZXJpZXNHcm91cC5hZGRSYXRpb3NXaGVuUGVyY2VudFN0YWNrZWQoYmFzZVJhdGlvKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCByYXRpb3MsIHdoZW4gaGFzIGRpdmVyZ2luZyBzdGFja2VkIG9wdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRSYXRpb3NXaGVuRGl2ZXJnaW5nU3RhY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihzZXJpZXNHcm91cCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHNlcmllc0dyb3VwLnBsdWNrKCd2YWx1ZScpLFxuICAgICAgICAgICAgICAgIHBsdXNTdW0gPSBjYWxjdWxhdG9yLnN1bVBsdXNWYWx1ZXModmFsdWVzKSxcbiAgICAgICAgICAgICAgICBtaW51c1N1bSA9IE1hdGguYWJzKGNhbGN1bGF0b3Iuc3VtTWludXNWYWx1ZXModmFsdWVzKSk7XG5cbiAgICAgICAgICAgIHNlcmllc0dyb3VwLmFkZFJhdGlvc1doZW5EaXZlcmdpbmdTdGFja2VkKHBsdXNTdW0sIG1pbnVzU3VtKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VidHJhY3Rpb24gdmFsdWUgZm9yIG1ha2luZyByYXRpbyBvZiBubyBvcHRpb24gY2hhcnQuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgLSBsaW1pdFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVN1YnRyYWN0aW9uVmFsdWU6IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHZhciBhbGxvd01pbnVzUG9pbnRSZW5kZXIgPSBwcmVkaWNhdGUuYWxsb3dNaW51c1BvaW50UmVuZGVyKHRoaXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIHN1YlZhbHVlID0gMDtcblxuICAgICAgICBpZiAoIWFsbG93TWludXNQb2ludFJlbmRlciAmJiBwcmVkaWNhdGUuaXNNaW51c0xpbWl0KGxpbWl0KSkge1xuICAgICAgICAgICAgc3ViVmFsdWUgPSBsaW1pdC5tYXg7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsb3dNaW51c1BvaW50UmVuZGVyIHx8IGxpbWl0Lm1pbiA+PSAwKSB7XG4gICAgICAgICAgICBzdWJWYWx1ZSA9IGxpbWl0Lm1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHJhdGlvcywgd2hlbiBoYXMgbm90IG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCAtIGF4aXMgbGltaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRSYXRpb3M6IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKGxpbWl0Lm1heCAtIGxpbWl0Lm1pbiksXG4gICAgICAgICAgICBzdWJWYWx1ZSA9IHRoaXMuX21ha2VTdWJ0cmFjdGlvblZhbHVlKGxpbWl0KTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICAgIHNlcmllc0dyb3VwLmFkZFJhdGlvcyhkaXN0YW5jZSwgc3ViVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zLlxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGxpbWl0IC0gYXhpcyBsaW1pdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja2VkIC0gc3RhY2tlZCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFkZERhdGFSYXRpb3M6IGZ1bmN0aW9uKGxpbWl0LCBzdGFja2VkKSB7XG4gICAgICAgIHZhciBpc0FsbG93ZWRTdGFja2VkT3B0aW9uID0gcHJlZGljYXRlLmlzQWxsb3dlZFN0YWNrZWRPcHRpb24odGhpcy5jaGFydFR5cGUpO1xuXG4gICAgICAgIGlmIChpc0FsbG93ZWRTdGFja2VkT3B0aW9uICYmIHByZWRpY2F0ZS5pc05vcm1hbFN0YWNrZWQoc3RhY2tlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFJhdGlvc1doZW5Ob3JtYWxTdGFja2VkKGxpbWl0KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FsbG93ZWRTdGFja2VkT3B0aW9uICYmIHByZWRpY2F0ZS5pc1BlcmNlbnRTdGFja2VkKHN0YWNrZWQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXZlcmdpbmdPcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRSYXRpb3NXaGVuRGl2ZXJnaW5nU3RhY2tlZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRSYXRpb3NXaGVuUGVyY2VudFN0YWNrZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFJhdGlvcyhsaW1pdCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zIG9mIHBpZSBjaGFydC5cbiAgICAgKi9cbiAgICBhZGREYXRhUmF0aW9zT2ZQaWVDaGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihzZXJpZXNHcm91cCkge1xuICAgICAgICAgICAgdmFyIHN1bSA9IHR1aS51dGlsLnN1bShzZXJpZXNHcm91cC5wbHVjaygndmFsdWUnKSk7XG5cbiAgICAgICAgICAgIHNlcmllc0dyb3VwLmFkZFJhdGlvcyhzdW0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHJhdGlvcyBvZiBkYXRhIGZvciBjaGFydCBvZiBjb29yZGluYXRlIHR5cGUuXG4gICAgICogQHBhcmFtIHt7eDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHk6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fX0gbGltaXRNYXAgLSBsaW1pdCBtYXBcbiAgICAgKi9cbiAgICBhZGREYXRhUmF0aW9zRm9yQ29vcmRpbmF0ZVR5cGU6IGZ1bmN0aW9uKGxpbWl0TWFwKSB7XG4gICAgICAgIHZhciB4TGltaXQgPSBsaW1pdE1hcC54O1xuICAgICAgICB2YXIgeUxpbWl0ID0gbGltaXRNYXAueTtcbiAgICAgICAgdmFyIG1heFJhZGl1cyA9IHR1aS51dGlsLm1heCh0aGlzLmdldFZhbHVlcygncicpKTtcbiAgICAgICAgdmFyIHhEaXN0YW5jZSwgeFN1YlZhbHVlLCB5RGlzdGFuY2UsIHlTdWJWYWx1ZTtcblxuICAgICAgICBpZiAoeExpbWl0KSB7XG4gICAgICAgICAgICB4RGlzdGFuY2UgPSBNYXRoLmFicyh4TGltaXQubWF4IC0geExpbWl0Lm1pbik7XG4gICAgICAgICAgICB4U3ViVmFsdWUgPSB0aGlzLl9tYWtlU3VidHJhY3Rpb25WYWx1ZSh4TGltaXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHlMaW1pdCkge1xuICAgICAgICAgICAgeURpc3RhbmNlID0gTWF0aC5hYnMoeUxpbWl0Lm1heCAtIHlMaW1pdC5taW4pO1xuICAgICAgICAgICAgeVN1YlZhbHVlID0gdGhpcy5fbWFrZVN1YnRyYWN0aW9uVmFsdWUoeUxpbWl0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihzZXJpZXNHcm91cCkge1xuICAgICAgICAgICAgc2VyaWVzR3JvdXAuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS5hZGRSYXRpbygneCcsIHhEaXN0YW5jZSwgeFN1YlZhbHVlKTtcbiAgICAgICAgICAgICAgICBpdGVtLmFkZFJhdGlvKCd5JywgeURpc3RhbmNlLCB5U3ViVmFsdWUpO1xuICAgICAgICAgICAgICAgIGl0ZW0uYWRkUmF0aW8oJ3InLCBtYXhSYWRpdXMsIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgc3RhcnQgdG8gYWxsIHNlcmllcyBpdGVtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IHZhbHVlXG4gICAgICovXG4gICAgYWRkU3RhcnRWYWx1ZVRvQWxsU2VyaWVzSXRlbTogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKHNlcmllc0dyb3VwKSB7XG4gICAgICAgICAgICBzZXJpZXNHcm91cC5hZGRTdGFydFZhbHVlVG9BbGxTZXJpZXNJdGVtKHN0YXJ0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaGFzIHJhbmdlIGRhdGEgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1JhbmdlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYXNSYW5nZURhdGEgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICAgIGhhc1JhbmdlRGF0YSA9IHNlcmllc0dyb3VwLmhhc1JhbmdlRGF0YSgpO1xuICAgICAgICAgICAgcmV0dXJuICFoYXNSYW5nZURhdGE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBoYXNSYW5nZURhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIGdyb3VwcywgYW5kIGV4ZWN1dGVzIGl0ZXJhdGVlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gaXRlcmF0ZWUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUGl2b3QgLSB3aGV0aGVyIHBpdm90IG9yIG5vdFxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uKGl0ZXJhdGVlLCBpc1Bpdm90KSB7XG4gICAgICAgIHZhciBncm91cHMgPSBpc1Bpdm90ID8gdGhpcy5fZ2V0UGl2b3RHcm91cHMoKSA6IHRoaXMuX2dldFNlcmllc0dyb3VwcygpO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShncm91cHMsIGZ1bmN0aW9uKHNlcmllc0dyb3VwLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHNlcmllc0dyb3VwLCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZSBncm91cHMsIGFuZCByZXR1cm5zIHRvIHJlc3VsdCBvZiBleGVjdXRpb24gYWJvdXQgaXRlcmF0ZWUgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQaXZvdCAtIHdoZXRoZXIgcGl2b3Qgb3Igbm90XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIG1hcDogZnVuY3Rpb24oaXRlcmF0ZWUsIGlzUGl2b3QpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oc2VyaWVzR3JvdXAsIGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0ZWUoc2VyaWVzR3JvdXAsIGluZGV4KSk7XG4gICAgICAgIH0sIGlzUGl2b3QpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcmllc0RhdGFNb2RlbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBTZXJpZXNHcm91cCBpcyBhIGVsZW1lbnQgb2YgU2VyaWVzRGF0YU1vZGVsLmdyb3Vwcy5cbiAqIFNlcmllc0dyb3VwLml0ZW1zIGhhcyBTZXJpZXNJdGVtLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNlcmllc0l0ZW0gaXMgYSBlbGVtZW50IG9mIFNlcmllc0dyb3VwLml0ZW1zLlxuICogU2VyaWVzSXRlbSBoYXMgcHJvY2Vzc2VkIHRlcm1pbmFsIGRhdGEgbGlrZSB2YWx1ZSwgcmF0aW8sIGV0Yy5cbiAqL1xuXG52YXIgU2VyaWVzR3JvdXAgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFNlcmllc0dyb3VwLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBTZXJpZXNHcm91cCBpcyBhIGVsZW1lbnQgb2YgU2VyaWVzRGF0YU1vZGVsLmdyb3Vwcy5cbiAgICAgKiBTZXJpZXNHcm91cC5pdGVtcyBoYXMgU2VyaWVzSXRlbS5cbiAgICAgKiBAY29uc3RydWN0cyBTZXJpZXNHcm91cFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFNlcmllc0l0ZW0+fSBzZXJpZXNJdGVtcyAtIHNlcmllcyBpdGVtc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHNlcmllc0l0ZW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpdGVtcyBoYXMgU2VyaWVzSXRlbVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPFNlcmllc0l0ZW0+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pdGVtcyA9IHNlcmllc0l0ZW1zO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXAgb2YgdmFsdWVzIGJ5IHZhbHVlIHR5cGUgbGlrZSB2YWx1ZSwgeCwgeSwgci5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZXNNYXAgPSB7fTtcblxuICAgICAgICB0aGlzLnZhbHVlc01hcFBlclN0YWNrID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlcmllcyBpdGVtIGNvdW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0U2VyaWVzSXRlbUNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VyaWVzIGl0ZW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2YgaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7U2VyaWVzSXRlbX1cbiAgICAgKi9cbiAgICBnZXRTZXJpZXNJdGVtOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmaXJzdCBTZXJpZXNJdGVtLlxuICAgICAqIEByZXR1cm5zIHtTZXJpZXNJdGVtfVxuICAgICAqL1xuICAgIGdldEZpcnN0U2VyaWVzSXRlbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlcmllc0l0ZW0oMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB2YWx1ZXMgdGhhdCBwaWNrZWQgdmFsdWUgZnJvbSBTZXJpZXNJdGVtcy5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlVHlwZSAtIHR5cGUgb2YgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlVmFsdWVzOiBmdW5jdGlvbih2YWx1ZVR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0dWkudXRpbC5pc0V4aXN0eShpdGVtW3ZhbHVlVHlwZV0pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goaXRlbVt2YWx1ZVR5cGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0dWkudXRpbC5pc0V4aXN0eShpdGVtLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGl0ZW0uc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWVzIGZyb20gdmFsdWVzTWFwLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVUeXBlIC0gdHlwZSBvZiB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlVHlwZSkge1xuICAgICAgICB2YWx1ZVR5cGUgPSB2YWx1ZVR5cGUgfHwgJ3ZhbHVlJztcblxuICAgICAgICBpZiAoIXRoaXMudmFsdWVzTWFwW3ZhbHVlVHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzTWFwW3ZhbHVlVHlwZV0gPSB0aGlzLl9jcmVhdGVWYWx1ZXModmFsdWVUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc01hcFt2YWx1ZVR5cGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHZhbHVlcyBtYXAgcGVyIHN0YWNrLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZhbHVlc01hcFBlclN0YWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlc01hcCA9IHt9O1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlc01hcFtpdGVtLnN0YWNrXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlc01hcFtpdGVtLnN0YWNrXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzTWFwW2l0ZW0uc3RhY2tdLnB1c2goaXRlbS52YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZXNNYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB2YWx1ZXMgbWFwIHBlciBzdGFjay5cbiAgICAgKiBAcmV0dXJucyB7KnxPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VmFsdWVzTWFwUGVyU3RhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWVzTWFwUGVyU3RhY2spIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzTWFwUGVyU3RhY2sgPSB0aGlzLl9tYWtlVmFsdWVzTWFwUGVyU3RhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc01hcFBlclN0YWNrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1bSBtYXAgcGVyIHN0YWNrLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHN1bSBtYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3VtTWFwUGVyU3RhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzTWFwID0gdGhpcy5nZXRWYWx1ZXNNYXBQZXJTdGFjaygpLFxuICAgICAgICAgICAgc3VtTWFwID0ge307XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh2YWx1ZXNNYXAsIGZ1bmN0aW9uKHZhbHVlcywga2V5KSB7XG4gICAgICAgICAgICBzdW1NYXBba2V5XSA9IHR1aS51dGlsLnN1bSh0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdW1NYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBzdGFydCB2YWx1ZSB0byBhbGwgc2VyaWVzIGl0ZW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHN0YXJ0IHZhbHVlXG4gICAgICovXG4gICAgYWRkU3RhcnRWYWx1ZVRvQWxsU2VyaWVzSXRlbTogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0uYWRkU3RhcnQoc3RhcnQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHJhdGlvcyB3aGVuIHBlcmNlbnQgc3RhY2tlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZVJhdGlvIC0gYmFzZSByYXRpb1xuICAgICAqL1xuICAgIGFkZFJhdGlvc1doZW5QZXJjZW50U3RhY2tlZDogZnVuY3Rpb24oYmFzZVJhdGlvKSB7XG4gICAgICAgIHZhciBzdW1NYXAgPSB0aGlzLl9tYWtlU3VtTWFwUGVyU3RhY2soKTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIGRpdmlkaW5nTnVtYmVyID0gc3VtTWFwW2l0ZW0uc3RhY2tdO1xuXG4gICAgICAgICAgICBpdGVtLmFkZFJhdGlvKGRpdmlkaW5nTnVtYmVyLCAwLCBiYXNlUmF0aW8pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHJhdGlvcyB3aGVuIGRpdmVyZ2luZyBzdGFja2VkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwbHVzU3VtIC0gc3VtIG9mIHBsdXMgbnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnVzU3VtIC0gc3VtIG9mIG1pbnVzIG51bWJlclxuICAgICAqL1xuICAgIGFkZFJhdGlvc1doZW5EaXZlcmdpbmdTdGFja2VkOiBmdW5jdGlvbihwbHVzU3VtLCBtaW51c1N1bSkge1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIGRpdmlkaW5nTnVtYmVyID0gKGl0ZW0udmFsdWUgPj0gMCkgPyBwbHVzU3VtIDogbWludXNTdW07XG5cbiAgICAgICAgICAgIGl0ZW0uYWRkUmF0aW8oZGl2aWRpbmdOdW1iZXIsIDAsIDAuNSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgcmF0aW9zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZOdW1iZXIgZGl2aWRpbmcgbnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1YlZhbHVlIHN1YnRyYWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgYWRkUmF0aW9zOiBmdW5jdGlvbihkaXZOdW1iZXIsIHN1YlZhbHVlKSB7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmFkZFJhdGlvKGRpdk51bWJlciwgc3ViVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBoYXMgcmFuZ2UgZGF0YSBvciBub3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUmFuZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhhc1JhbmdlRGF0YSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihzZXJpZXNJdGVtKSB7XG4gICAgICAgICAgICBoYXNSYW5nZURhdGEgPSBzZXJpZXNJdGVtLmlzUmFuZ2U7XG4gICAgICAgICAgICByZXR1cm4gIWhhc1JhbmdlRGF0YTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhhc1JhbmdlRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhdmVyc2UgaXRlbXMsIGFuZCBleGVjdXRlcyBpdGVyYXRlZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZWFjaDogZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuaXRlbXMsIGl0ZXJhdGVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhdmVyc2UgaXRlbXMsIGFuZCByZXR1cm5zIHRvIHJlc3VsdHMgb2YgZXhlY3V0aW9uIGFib3V0IGl0ZXJhdGVlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gaXRlcmF0ZWUgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgbWFwOiBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHRoaXMuaXRlbXMsIGl0ZXJhdGVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhdmVyc2UgaXRlbXMgYW5kIHJldHVybnMgdG8gcGlja2VkIHJlc3VsdCBhdCBpdGVtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkga2V5IGZvciBwaWNrXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHBsdWNrOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLnBsdWNrKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIGl0ZW1zLCBhbmQgcmV0dXJucyB0byBmb3VuZCBTZXJpZXNJdGVtIGJ5IGNvbmRpdGlvbiBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gLSBjb25kaXRpb24gZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7U2VyaWVzSXRlbXxudWxsfVxuICAgICAqL1xuICAgIGZpbmQ6IGZ1bmN0aW9uKGNvbmRpdGlvbikge1xuICAgICAgICB2YXIgZm91bmRJdGVtO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihzZXJpZXNJdGVtKSB7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uKHNlcmllc0l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgZm91bmRJdGVtID0gc2VyaWVzSXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhZm91bmRJdGVtO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm91bmRJdGVtIHx8IG51bGw7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VyaWVzR3JvdXA7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2VyaWVzSXRlbSBpcyBhIGVsZW1lbnQgb2YgU2VyaWVzR3JvdXAuaXRlbXMuXG4gKiBTZXJpZXNJdGVtIGhhcyBwcm9jZXNzZWQgdGVybWluYWwgZGF0YSBsaWtlIHZhbHVlLCByYXRpbywgZXRjLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgU2VyaWVzSXRlbSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgU2VyaWVzSXRlbS5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogU2VyaWVzSXRlbSBpcyBhIGVsZW1lbnQgb2YgU2VyaWVzR3JvdXAuaXRlbXMuXG4gICAgICogU2VyaWVzSXRlbSBoYXMgcHJvY2Vzc2VkIHRlcm1pbmFsIGRhdGEgbGlrZSB2YWx1ZSwgcmF0aW8sIGV0Yy5cbiAgICAgKiBAY29uc3RydWN0cyBTZXJpZXNJdGVtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdmFsdWVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHN0YWNrIC0gc3RhY2tcbiAgICAgKiBAcGFyYW0gez9BcnJheS48ZnVuY3Rpb24+fSBmb3JtYXRGdW5jdGlvbnMgLSBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24odmFsdWUsIHN0YWNrLCBmb3JtYXRGdW5jdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZvciBncm91cCBzdGFjayBvcHRpb24uXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2sgfHwgY2hhcnRDb25zdC5ERUZBVUxUX1NUQUNLO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48ZnVuY3Rpb24+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXRGdW5jdGlvbnMgPSBmb3JtYXRGdW5jdGlvbnM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgcmFuZ2UgaXRlbSBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzUmFuZ2UgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWUgb2YgaXRlbVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxhYmVsXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhYmVsID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmF0aW8gb2YgdmFsdWUgYWJvdXQgZGlzdGFuY2Ugb2YgbGltaXRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmF0aW8gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBlbmQgdmFsdWUgb2YgaXRlbS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5kID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZW5kIGxhYmVsXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuZExhYmVsID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmF0aW8gb2YgZW5kIHZhbHVlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuZFJhdGlvID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3RhcnQgdmFsdWUgb2YgaXRlbS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdGFydCBsYWJlbFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydExhYmVsID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmF0aW8gb2Ygc3RhcnQgdmFsdWVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRSYXRpbyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRpc3RhbmNlIG9mIHN0YXJ0IHJhdGlvIGFuZCBlbmQgcmF0aW9cbiAgICAgICAgICogQHR5cGUge251bGx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhdGlvRGlzdGFuY2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2luaXRWYWx1ZXModmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHZhbHVlcyBvZiBpdGVtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFZhbHVlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuX2NyZWF0ZVZhbHVlcyh2YWx1ZSksXG4gICAgICAgICAgICBoYXNTdGFydCA9IHZhbHVlcy5sZW5ndGggPiAxO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmVuZCA9IHZhbHVlc1swXTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHRoaXMuZW5kTGFiZWwgPSByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKHRoaXMudmFsdWUsIHRoaXMuZm9ybWF0RnVuY3Rpb25zLCAnc2VyaWVzJyk7XG5cbiAgICAgICAgaWYgKGhhc1N0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZFN0YXJ0KHZhbHVlc1sxXSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVGb3JtYXR0ZWRWYWx1ZWZvclJhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLmlzUmFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZXRlIHNvcnRlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPnxudW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVZhbHVlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHR1aS51dGlsLm1hcChbXS5jb25jYXQodmFsdWUpLCBwYXJzZUZsb2F0KTtcblxuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYSA8IDAgJiYgYiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBiIC0gYTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHN0YXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGRTdGFydDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc051bGwodGhpcy5zdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhcnQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydExhYmVsID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZSh2YWx1ZSwgdGhpcy5mb3JtYXRGdW5jdGlvbnMsICdzZXJpZXMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGZvcm1hdHRlZCB2YWx1ZSBmb3IgcmFuZ2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlRm9ybWF0dGVkVmFsdWVmb3JSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLnN0YXJ0TGFiZWwgKyAnIH4gJyArIHRoaXMuZW5kTGFiZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSByYXRpbyBmb3IgbWFraW5nIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdk51bWJlciAtIG51bWJlciBmb3IgZGl2aXNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3ViTnVtYmVyIC0gbnVtYmVyIGZvciBzdWJ0cmFjdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlUmF0aW8gLSBiYXNlIHJhdGlvXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVSYXRpbzogZnVuY3Rpb24odmFsdWUsIGRpdk51bWJlciwgc3ViTnVtYmVyLCBiYXNlUmF0aW8pIHtcbiAgICAgICAgcmV0dXJuICgodmFsdWUgLSBzdWJOdW1iZXIpIC8gZGl2TnVtYmVyKSAqIGJhc2VSYXRpbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHJhdGlvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZOdW1iZXIgLSBudW1iZXIgZm9yIGRpdmlzaW9uXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBzdWJOdW1iZXIgLSBudW1iZXIgZm9yIHN1YnRyYWN0aW9uXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBiYXNlUmF0aW8gLSBiYXNlIHJhdGlvXG4gICAgICovXG4gICAgYWRkUmF0aW86IGZ1bmN0aW9uKGRpdk51bWJlciwgc3ViTnVtYmVyLCBiYXNlUmF0aW8pIHtcbiAgICAgICAgZGl2TnVtYmVyID0gZGl2TnVtYmVyIHx8IDE7XG4gICAgICAgIGJhc2VSYXRpbyA9IGJhc2VSYXRpbyB8fCAxO1xuICAgICAgICBzdWJOdW1iZXIgPSBzdWJOdW1iZXIgfHwgMDtcblxuICAgICAgICB0aGlzLnJhdGlvID0gdGhpcy5lbmRSYXRpbyA9IHRoaXMuX2NhbGN1bGF0ZVJhdGlvKHRoaXMudmFsdWUsIGRpdk51bWJlciwgc3ViTnVtYmVyLCBiYXNlUmF0aW8pO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNOdWxsKHRoaXMuc3RhcnQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmF0aW8gPSB0aGlzLl9jYWxjdWxhdGVSYXRpbyh0aGlzLnN0YXJ0LCBkaXZOdW1iZXIsIHN1Yk51bWJlciwgYmFzZVJhdGlvKTtcbiAgICAgICAgICAgIHRoaXMucmF0aW9EaXN0YW5jZSA9IE1hdGguYWJzKHRoaXMuZW5kUmF0aW8gLSB0aGlzLnN0YXJ0UmF0aW8pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgdmFsdWUgbWFwLlxuICAgICAqIEByZXR1cm5zIHt7dmFsdWU6IG51bWJlciwgc3RhcnQ6ID9udW1iZXIsIGVuZDogP251bWJlcn19XG4gICAgICovXG4gICAgcGlja1ZhbHVlTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHRoaXMuZW5kXG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VyaWVzSXRlbTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBTZXJpZXNJdGVtRm9yQ29vcmRpbmF0ZVR5cGUgaXMgYSBlbGVtZW50IG9mIFNlcmllc0dyb3VwLml0ZW1zLlxuICogU2VyaWVzSXRlbUZvckNvb3JkaW5hdGVUeXBlIGhhcyBwcm9jZXNzZWQgdGVybWluYWwgZGF0YSBsaWtlIHgsIHksIHIsIHhSYXRpbywgeVJhdGlvLCByUmF0aW8uXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXNJdGVtRm9yQ29vcmRpbmF0ZVR5cGUgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFNlcmllc0l0ZW1Gb3JDb29yZGluYXRlVHlwZS5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogU2VyaWVzSXRlbUZvckNvb3JkaW5hdGVUeXBlIGlzIGEgZWxlbWVudCBvZiBTZXJpZXNHcm91cC5pdGVtcy5cbiAgICAgKiBTZXJpZXNJdGVtRm9yQ29vcmRpbmF0ZVR5cGUgaGFzIHByb2Nlc3NlZCB0ZXJtaW5hbCBkYXRhIGxpa2UgeCwgeSwgciwgeFJhdGlvLCB5UmF0aW8sIHJSYXRpby5cbiAgICAgKiBAY29uc3RydWN0cyBTZXJpZXNJdGVtRm9yQ29vcmRpbmF0ZVR5cGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmF3U2VyaWVzRGF0dW0gLSB2YWx1ZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd1Nlcmllc0RhdHVtKSB7XG4gICAgICAgIHRoaXMuX2luaXREYXRhKHJhd1Nlcmllc0RhdHVtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBkYXRhIG9mIGl0ZW0uXG4gICAgICogQHBhcmFtIHt7eDogP251bWJlciwgeTogP251bWJlciwgcjogP251bWJlciwgbGFiZWw6ID9zdHJpbmd9fSByYXdTZXJpZXNEYXR1bSAtIHJhd1Nlcmllc0RhdHVtIGZvciBidWJibGUgY2hhcnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0RGF0YTogZnVuY3Rpb24ocmF3U2VyaWVzRGF0dW0pIHtcbiAgICAgICAgdGhpcy54ID0gcmF3U2VyaWVzRGF0dW0ueDtcbiAgICAgICAgdGhpcy55ID0gcmF3U2VyaWVzRGF0dW0ueTtcbiAgICAgICAgdGhpcy5yID0gcmF3U2VyaWVzRGF0dW0ucjtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHJhd1Nlcmllc0RhdHVtLmxhYmVsIHx8ICcnO1xuXG4gICAgICAgIHRoaXMucmF0aW9NYXAgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHJhdGlvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVR5cGUgLSB0eXBlIG9mIHZhbHVlIGxpa2UgeCwgeSwgclxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gZGl2TnVtYmVyIC0gbnVtYmVyIGZvciBkaXZpc2lvblxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gc3ViTnVtYmVyIC0gbnVtYmVyIGZvciBzdWJ0cmFjdGlvblxuICAgICAqL1xuICAgIGFkZFJhdGlvOiBmdW5jdGlvbih2YWx1ZVR5cGUsIGRpdk51bWJlciwgc3ViTnVtYmVyKSB7XG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNFeGlzdHkodGhpcy5yYXRpb01hcFt2YWx1ZVR5cGVdKSAmJiBkaXZOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmF0aW9NYXBbdmFsdWVUeXBlXSA9ICh0aGlzW3ZhbHVlVHlwZV0gLSBzdWJOdW1iZXIpIC8gZGl2TnVtYmVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgdmFsdWUgbWFwLlxuICAgICAqIEByZXR1cm5zIHt7eDogKG51bWJlciB8IG51bGwpLCB5OiAobnVtYmVyIHwgbnVsbCksIHI6IChudW1iZXIgfCBudWxsKX19XG4gICAgICovXG4gICAgcGlja1ZhbHVlTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMucmF0aW9NYXAueCA/IHRoaXMueCA6IG51bGwsXG4gICAgICAgICAgICB5OiB0aGlzLnJhdGlvTWFwLnkgPyB0aGlzLnkgOiBudWxsLFxuICAgICAgICAgICAgcjogdGhpcy5yYXRpb01hcC5yID8gdGhpcy5yIDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcmllc0l0ZW1Gb3JDb29yZGluYXRlVHlwZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgQ2hhcnQgZmFjdG9yeSBwbGF5IHJvbGUgcmVnaXN0ZXIgY2hhcnQuXG4gKiAgICAgICAgICAgICAgICBBbHNvLCB5b3UgY2FuIGdldCBjaGFydCBmcm9tIHRoaXMgZmFjdG9yeS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0cyA9IHt9LFxuICAgIGZhY3RvcnkgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY2hhcnQgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBjaGFydCBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gY2hhcnQgaW5zdGFuY2U7XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgZGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBDaGFydCA9IGNoYXJ0c1tjaGFydFR5cGVdLFxuICAgICAgICAgICAgICAgIGNoYXJ0O1xuXG4gICAgICAgICAgICBpZiAoIUNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZXhpc3QgJyArIGNoYXJ0VHlwZSArICcgY2hhcnQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoYXJ0ID0gbmV3IENoYXJ0KGRhdGEsIHRoZW1lLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBjaGFydC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFyIHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtjbGFzc30gQ2hhcnRDbGFzcyBjaGFydCBjbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgQ2hhcnRDbGFzcykge1xuICAgICAgICAgICAgY2hhcnRzW2NoYXJ0VHlwZV0gPSBDaGFydENsYXNzO1xuICAgICAgICB9XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBNYXAgZmFjdG9yeS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hcHMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogR2V0IG1hcCBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lIG1hcCBuYW1lXG4gICAgICogQHJldHVybnMge0FycmF5fSBtYXAgZGF0YVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24obWFwTmFtZSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hcHNbbWFwTmFtZV07XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBleGlzdCAnICsgbWFwTmFtZSArICcgbWFwLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIE1hcC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFwTmFtZSBtYXAgbmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgbWFwIGRhdGFcbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24obWFwTmFtZSwgZGF0YSkge1xuICAgICAgICBtYXBzW21hcE5hbWVdID0gZGF0YTtcbiAgICB9XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBQbHVnaW4gZmFjdG9yeSBwbGF5IHJvbGUgcmVnaXN0ZXIgcmVuZGVyaW5nIHBsdWdpbi5cbiAqICAgICAgICAgICAgICAgIEFsc28sIHlvdSBjYW4gZ2V0IHBsdWdpbiBmcm9tIHRoaXMgZmFjdG9yeS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBsdWdpbnMgPSB7fSxcbiAgICBmYWN0b3J5ID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGdyYXBoIHJlbmRlcmVyLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGliVHlwZSB0eXBlIG9mIGdyYXBoIGxpYnJhcnlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJlbmRlcmVyIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGxpYlR5cGUsIGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbbGliVHlwZV0sXG4gICAgICAgICAgICAgICAgUmVuZGVyZXIsIHJlbmRlcmVyO1xuXG4gICAgICAgICAgICBpZiAoIXBsdWdpbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGV4aXN0ICcgKyBsaWJUeXBlICsgJyBwbHVnaW4uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlbmRlcmVyID0gcGx1Z2luW2NoYXJ0VHlwZV07XG4gICAgICAgICAgICBpZiAoIVJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZXhpc3QgJyArIGNoYXJ0VHlwZSArICcgY2hhcnQgcmVuZGVyZXIuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsdWdpbiByZWdpc3Rlci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxpYlR5cGUgdHlwZSBvZiBncmFwaCBsaWJyYXJ5XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwbHVnaW4gcGx1Z2luIHRvIGNvbnRyb2wgbGlicmFyeVxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKGxpYlR5cGUsIHBsdWdpbikge1xuICAgICAgICAgICAgcGx1Z2luc1tsaWJUeXBlXSA9IHBsdWdpbjtcbiAgICAgICAgfVxuICAgIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgVGhlbWUgZmFjdG9yeSBwbGF5IHJvbGUgcmVnaXN0ZXIgdGhlbWUuXG4gKiAgICAgICAgICAgICAgICBBbHNvLCB5b3UgY2FuIGdldCB0aGVtZSBmcm9tIHRoaXMgZmFjdG9yeS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRlZmF1bHRUaGVtZSA9IHJlcXVpcmUoJy4uL3RoZW1lcy9kZWZhdWx0VGhlbWUnKTtcblxudmFyIHRoZW1lcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRoZW1lTmFtZSB0aGVtZSBuYW1lXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlbWUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbih0aGVtZU5hbWUpIHtcbiAgICAgICAgdmFyIHRoZW1lID0gdGhlbWVzW3RoZW1lTmFtZV07XG5cbiAgICAgICAgaWYgKCF0aGVtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZXhpc3QgJyArIHRoZW1lTmFtZSArICcgdGhlbWUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhlbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZW1lIHJlZ2lzdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aGVtZU5hbWUgdGhlbWUgbmFtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbih0aGVtZU5hbWUsIHRoZW1lKSB7XG4gICAgICAgIHZhciB0YXJnZXRJdGVtcztcbiAgICAgICAgdGhlbWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoZW1lKSk7XG5cbiAgICAgICAgaWYgKHRoZW1lTmFtZSAhPT0gY2hhcnRDb25zdC5ERUZBVUxUX1RIRU1FX05BTUUpIHtcbiAgICAgICAgICAgIHRoZW1lID0gdGhpcy5faW5pdFRoZW1lKHRoZW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldEl0ZW1zID0gdGhpcy5fZ2V0SW5oZXJpdFRhcmdldFRoZW1lSXRlbXModGhlbWUpO1xuXG4gICAgICAgIHRoaXMuX2luaGVyaXRUaGVtZUZvbnQodGhlbWUsIHRhcmdldEl0ZW1zKTtcbiAgICAgICAgdGhpcy5fY29weUNvbG9ySW5mbyh0aGVtZSk7XG4gICAgICAgIHRoZW1lc1t0aGVtZU5hbWVdID0gdGhlbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXQgdGhlbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRoZW1lXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBfaW5pdFRoZW1lOiBmdW5jdGlvbih0aGVtZSkge1xuICAgICAgICB2YXIgY2xvbmVUaGVtZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGVmYXVsdFRoZW1lKSksXG4gICAgICAgICAgICBuZXdUaGVtZTtcblxuICAgICAgICB0aGlzLl9jb25jYXREZWZhdWx0Q29sb3JzKHRoZW1lLCBjbG9uZVRoZW1lLnNlcmllcy5jb2xvcnMpO1xuICAgICAgICBuZXdUaGVtZSA9IHRoaXMuX292ZXJ3cml0ZVRoZW1lKHRoZW1lLCBjbG9uZVRoZW1lKTtcblxuICAgICAgICBuZXdUaGVtZSA9IHRoaXMuX2NvcHlQcm9wZXJ0eSh7XG4gICAgICAgICAgICBwcm9wTmFtZTogJ3lBeGlzJyxcbiAgICAgICAgICAgIGZyb21UaGVtZTogdGhlbWUsXG4gICAgICAgICAgICB0b1RoZW1lOiBuZXdUaGVtZSxcbiAgICAgICAgICAgIHJlamVjdGlvblByb3BzOiBjaGFydENvbnN0LllBWElTX1BST1BTXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ld1RoZW1lID0gdGhpcy5fY29weVByb3BlcnR5KHtcbiAgICAgICAgICAgIHByb3BOYW1lOiAnc2VyaWVzJyxcbiAgICAgICAgICAgIGZyb21UaGVtZTogdGhlbWUsXG4gICAgICAgICAgICB0b1RoZW1lOiBuZXdUaGVtZSxcbiAgICAgICAgICAgIHJlamVjdGlvblByb3BzOiBjaGFydENvbnN0LlNFUklFU19QUk9QU1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3VGhlbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBjaGFydCB0eXBlcy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IHRhcmdldCBjaGFydHNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSByZWplY3Rpb25Qcm9wcyByZWplY3QgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBmaWx0ZXJlZCBjaGFydHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlsdGVyQ2hhcnRUeXBlczogZnVuY3Rpb24odGFyZ2V0LCByZWplY3Rpb25Qcm9wcykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdHVpLnV0aWwuZmlsdGVyKHRhcmdldCwgZnVuY3Rpb24oaXRlbSwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLmluQXJyYXkobmFtZSwgcmVqZWN0aW9uUHJvcHMpID09PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbmNhdCBjb2xvcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRoZW1lXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc2VyaWVzQ29sb3JzIHNlcmllcyBjb2xvcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb25jYXRDb2xvcnM6IGZ1bmN0aW9uKHRoZW1lLCBzZXJpZXNDb2xvcnMpIHtcbiAgICAgICAgaWYgKHRoZW1lLmNvbG9ycykge1xuICAgICAgICAgICAgdGhlbWUuY29sb3JzID0gdGhlbWUuY29sb3JzLmNvbmNhdChzZXJpZXNDb2xvcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoZW1lLnNpbmdsZUNvbG9ycykge1xuICAgICAgICAgICAgdGhlbWUuc2luZ2xlQ29sb3JzID0gdGhlbWUuc2luZ2xlQ29sb3JzLmNvbmNhdChzZXJpZXNDb2xvcnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbmNhdCBkZWZhdWx0IGNvbG9ycy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgdGhlbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzZXJpZXNDb2xvcnMgc2VyaWVzIGNvbG9yc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NvbmNhdERlZmF1bHRDb2xvcnM6IGZ1bmN0aW9uKHRoZW1lLCBzZXJpZXNDb2xvcnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgY2hhcnRUeXBlcztcblxuICAgICAgICBpZiAoIXRoZW1lLnNlcmllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnRUeXBlcyA9IHRoaXMuX2ZpbHRlckNoYXJ0VHlwZXModGhlbWUuc2VyaWVzLCBjaGFydENvbnN0LlNFUklFU19QUk9QUyk7XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5rZXlzKGNoYXJ0VHlwZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fY29uY2F0Q29sb3JzKHRoZW1lLnNlcmllcywgc2VyaWVzQ29sb3JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goY2hhcnRUeXBlcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2NvbmNhdENvbG9ycyhpdGVtLCBzZXJpZXNDb2xvcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRlIHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZyb20gZnJvbSB0aGVtZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0byB0byB0aGVtZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJlc3VsdCBwcm9wZXJ0eVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX292ZXJ3cml0ZVRoZW1lOiBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh0bywgZnVuY3Rpb24oaXRlbSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgZnJvbUl0ZW0gPSBmcm9tW2tleV07XG4gICAgICAgICAgICBpZiAoIWZyb21JdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHVpLnV0aWwuaXNBcnJheShmcm9tSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0b1trZXldID0gZnJvbUl0ZW0uc2xpY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHVpLnV0aWwuaXNPYmplY3QoZnJvbUl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fb3ZlcndyaXRlVGhlbWUoZnJvbUl0ZW0sIGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b1trZXldID0gZnJvbUl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29weSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucHJvcE5hbWUgcHJvcGVydHkgbmFtZVxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5mcm9tVGhlbWUgZnJvbSBwcm9wZXJ0eVxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50b1RoZW1lIHRwIHByb3BlcnR5XG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXJhbXMucmVqZWN0aW9uUHJvcHMgcmVqZWN0IHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBjb3BpZWQgcHJvcGVydHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb3B5UHJvcGVydHk6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBjaGFydFR5cGVzO1xuXG4gICAgICAgIGlmICghcGFyYW1zLnRvVGhlbWVbcGFyYW1zLnByb3BOYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy50b1RoZW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnRUeXBlcyA9IHRoaXMuX2ZpbHRlckNoYXJ0VHlwZXMocGFyYW1zLmZyb21UaGVtZVtwYXJhbXMucHJvcE5hbWVdLCBwYXJhbXMucmVqZWN0aW9uUHJvcHMpO1xuICAgICAgICBpZiAodHVpLnV0aWwua2V5cyhjaGFydFR5cGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goY2hhcnRUeXBlcywgZnVuY3Rpb24oaXRlbSwga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lVGhlbWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZmF1bHRUaGVtZVtwYXJhbXMucHJvcE5hbWVdKSk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZyb21UaGVtZVtwYXJhbXMucHJvcE5hbWVdW2tleV0gPSBzZWxmLl9vdmVyd3JpdGVUaGVtZShpdGVtLCBjbG9uZVRoZW1lKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwYXJhbXMudG9UaGVtZVtwYXJhbXMucHJvcE5hbWVdID0gcGFyYW1zLmZyb21UaGVtZVtwYXJhbXMucHJvcE5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcy50b1RoZW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGNvbG9yIGluZm8gdG8gbGVnZW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc1RoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsZWdlbmRUaGVtZSBsZWdlbmQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgY29sb3JzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29weUNvbG9ySW5mb1RvT3RoZXI6IGZ1bmN0aW9uKHNlcmllc1RoZW1lLCBsZWdlbmRUaGVtZSwgY29sb3JzKSB7XG4gICAgICAgIGxlZ2VuZFRoZW1lLmNvbG9ycyA9IGNvbG9ycyB8fCBzZXJpZXNUaGVtZS5jb2xvcnM7XG4gICAgICAgIGlmIChzZXJpZXNUaGVtZS5zaW5nbGVDb2xvcnMpIHtcbiAgICAgICAgICAgIGxlZ2VuZFRoZW1lLnNpbmdsZUNvbG9ycyA9IHNlcmllc1RoZW1lLnNpbmdsZUNvbG9ycztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VyaWVzVGhlbWUuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIGxlZ2VuZFRoZW1lLmJvcmRlckNvbG9yID0gc2VyaWVzVGhlbWUuYm9yZGVyQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcmllc1RoZW1lLnNlbGVjdGlvbkNvbG9yKSB7XG4gICAgICAgICAgICBsZWdlbmRUaGVtZS5zZWxlY3Rpb25Db2xvciA9IHNlcmllc1RoZW1lLnNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0YXJnZXQgaXRlbXMgYWJvdXQgZm9udCBpbmhlcml0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gdGFyZ2V0IGl0ZW1zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0SW5oZXJpdFRhcmdldFRoZW1lSXRlbXM6IGZ1bmN0aW9uKHRoZW1lKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IFtcbiAgICAgICAgICAgICAgICB0aGVtZS50aXRsZSxcbiAgICAgICAgICAgICAgICB0aGVtZS54QXhpcy50aXRsZSxcbiAgICAgICAgICAgICAgICB0aGVtZS54QXhpcy5sYWJlbCxcbiAgICAgICAgICAgICAgICB0aGVtZS5sZWdlbmQubGFiZWxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB5QXhpc0NoYXJ0VHlwZVRoZW1zID0gdGhpcy5fZmlsdGVyQ2hhcnRUeXBlcyh0aGVtZS55QXhpcywgY2hhcnRDb25zdC5ZQVhJU19QUk9QUyksXG4gICAgICAgICAgICBzZXJpZXNDaGFydFR5cGVUaGVtZXMgPSB0aGlzLl9maWx0ZXJDaGFydFR5cGVzKHRoZW1lLnNlcmllcywgY2hhcnRDb25zdC5TRVJJRVNfUFJPUFMpO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwua2V5cyh5QXhpc0NoYXJ0VHlwZVRoZW1zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2godGhlbWUueUF4aXMudGl0bGUpO1xuICAgICAgICAgICAgaXRlbXMucHVzaCh0aGVtZS55QXhpcy5sYWJlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHlBeGlzQ2hhcnRUeXBlVGhlbXMsIGZ1bmN0aW9uKGNoYXRUeXBlVGhlbWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNoYXRUeXBlVGhlbWUudGl0bGUpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goY2hhdFR5cGVUaGVtZS5sYWJlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHVpLnV0aWwua2V5cyhzZXJpZXNDaGFydFR5cGVUaGVtZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh0aGVtZS5zZXJpZXMubGFiZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNDaGFydFR5cGVUaGVtZXMsIGZ1bmN0aW9uKGNoYXRUeXBlVGhlbWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNoYXRUeXBlVGhlbWUubGFiZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmhlcml0IHRoZW1lIGZvbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRoZW1lXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gdGFyZ2V0SXRlbXMgdGFyZ2V0IHRoZW1lIGl0ZW1zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5oZXJpdFRoZW1lRm9udDogZnVuY3Rpb24odGhlbWUsIHRhcmdldEl0ZW1zKSB7XG4gICAgICAgIHZhciBiYXNlRm9udCA9IHRoZW1lLmNoYXJ0LmZvbnRGYW1pbHk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRhcmdldEl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uZm9udEZhbWlseSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZm9udEZhbWlseSA9IGJhc2VGb250O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29weSBjb2xvciBpbmZvLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIF9jb3B5Q29sb3JJbmZvOiBmdW5jdGlvbih0aGVtZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZXJpZXNDaGFydFR5cGVzID0gdGhpcy5fZmlsdGVyQ2hhcnRUeXBlcyh0aGVtZS5zZXJpZXMsIGNoYXJ0Q29uc3QuU0VSSUVTX1BST1BTKTtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmtleXMoc2VyaWVzQ2hhcnRUeXBlcykubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3B5Q29sb3JJbmZvVG9PdGhlcih0aGVtZS5zZXJpZXMsIHRoZW1lLmxlZ2VuZCk7XG4gICAgICAgICAgICB0aGlzLl9jb3B5Q29sb3JJbmZvVG9PdGhlcih0aGVtZS5zZXJpZXMsIHRoZW1lLnRvb2x0aXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNDaGFydFR5cGVzLCBmdW5jdGlvbihpdGVtLCBjaGFydFR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGVtZS5sZWdlbmRbY2hhcnRUeXBlXSA9IHt9O1xuICAgICAgICAgICAgICAgIHRoZW1lLnRvb2x0aXBbY2hhcnRUeXBlXSA9IHt9O1xuICAgICAgICAgICAgICAgIHNlbGYuX2NvcHlDb2xvckluZm9Ub090aGVyKGl0ZW0sIHRoZW1lLmxlZ2VuZFtjaGFydFR5cGVdLCBpdGVtLmNvbG9ycyB8fCB0aGVtZS5sZWdlbmQuY29sb3JzKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9jb3B5Q29sb3JJbmZvVG9PdGhlcihpdGVtLCB0aGVtZS50b29sdGlwW2NoYXJ0VHlwZV0sIGl0ZW0uY29sb3JzIHx8IHRoZW1lLnRvb2x0aXAuY29sb3JzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhlbWUubGVnZW5kLmNvbG9ycztcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhlbWUudG9vbHRpcC5jb2xvcnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQXhpcyBEYXRhIE1ha2VyXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxuLyoqXG4gKiBBeGlzIGRhdGEgbWFrZXIuXG4gKiBAbW9kdWxlIGF4aXNEYXRhTWFrZXJcbiAqL1xudmFyIGF4aXNEYXRhTWFrZXIgPSB7XG4gICAgLyoqXG4gICAgICogTWFrZSBsYWJlbHMuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEludGVydmFsIGxhYmVsIGludGVydmFsXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSBsYWJlbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxzOiBmdW5jdGlvbihsYWJlbHMsIGxhYmVsSW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIGxhc3RJbmRleDtcbiAgICAgICAgaWYgKCFsYWJlbEludGVydmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdEluZGV4ID0gbGFiZWxzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAobGFiZWxzLCBmdW5jdGlvbihsYWJlbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgaW5kZXggPCBsYXN0SW5kZXggJiYgKGluZGV4ICUgbGFiZWxJbnRlcnZhbCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBjaGFydENvbnN0LkVNUFRZX0FYSVNfTEFCRUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRhdGEgYWJvdXQgbGFiZWwgYXhpcy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHBhcmFtcy5sYWJlbHMgY2hhcnQgbGFiZWxzXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5hbGlnbmVkIHdoZXRoZXIgYWxpZ24gb3Igbm90XG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGxhYmVsczogQXJyYXkuPHN0cmluZz4sXG4gICAgICogICAgICB0aWNrQ291bnQ6IG51bWJlcixcbiAgICAgKiAgICAgIHZhbGlkVGlja0NvdW50OiBudW1iZXIsXG4gICAgICogICAgICBpc0xhYmVsQXhpczogYm9vbGVhbixcbiAgICAgKiAgICAgIGlzVmVydGljYWw6IGJvb2xlYW5cbiAgICAgKiB9fSBheGlzIGRhdGFcbiAgICAgKi9cbiAgICBtYWtlTGFiZWxBeGlzRGF0YTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB0aWNrQ291bnQgPSBwYXJhbXMubGFiZWxzLmxlbmd0aCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICAgIGxhYmVscyA9IHRoaXMuX21ha2VMYWJlbHMocGFyYW1zLmxhYmVscywgb3B0aW9ucy5sYWJlbEludGVydmFsKTtcblxuICAgICAgICBpZiAoIXBhcmFtcy5hbGlnbmVkKSB7XG4gICAgICAgICAgICB0aWNrQ291bnQgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgICAgICAgIHRpY2tDb3VudDogdGlja0NvdW50LFxuICAgICAgICAgICAgdmFsaWRUaWNrQ291bnQ6IDAsXG4gICAgICAgICAgICBpc0xhYmVsQXhpczogdHJ1ZSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6ICEhcGFyYW1zLmlzVmVydGljYWwsXG4gICAgICAgICAgICBhbGlnbmVkOiAhIXBhcmFtcy5hbGlnbmVkXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZGF0YSBhYm91dCB2YWx1ZSBheGlzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtBeGlzU2NhbGVNYWtlcn0gcGFyYW1zLmF4aXNTY2FsZU1ha2VyIGNoYXJ0IHZhbHVlc1xuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBsYWJlbHM6IEFycmF5LjxzdHJpbmc+LFxuICAgICAqICAgICAgdGlja0NvdW50OiBudW1iZXIsXG4gICAgICogICAgICB2YWxpZFRpY2tDb3VudDogbnVtYmVyLFxuICAgICAqICAgICAgaXNMYWJlbEF4aXM6IGJvb2xlYW4sXG4gICAgICogICAgICBsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sXG4gICAgICogICAgICBpc1ZlcnRpY2FsOiBib29sZWFuXG4gICAgICogfX0gYXhpcyBkYXRhXG4gICAgICovXG4gICAgbWFrZVZhbHVlQXhpc0RhdGE6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgYXhpc1NjYWxlTWFrZXIgPSBwYXJhbXMuYXhpc1NjYWxlTWFrZXIsXG4gICAgICAgICAgICByYW5nZVZhbHVlcyA9IGF4aXNTY2FsZU1ha2VyLmdldEZvcm1hdHRlZFNjYWxlVmFsdWVzKCksXG4gICAgICAgICAgICB0aWNrQ291bnQgPSByYW5nZVZhbHVlcy5sZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsczogcmFuZ2VWYWx1ZXMsXG4gICAgICAgICAgICB0aWNrQ291bnQ6IHRpY2tDb3VudCxcbiAgICAgICAgICAgIHZhbGlkVGlja0NvdW50OiB0aWNrQ291bnQsXG4gICAgICAgICAgICBsaW1pdDogYXhpc1NjYWxlTWFrZXIuZ2V0TGltaXQoKSxcbiAgICAgICAgICAgIHN0ZXA6IGF4aXNTY2FsZU1ha2VyLmdldFN0ZXAoKSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6ICEhcGFyYW1zLmlzVmVydGljYWwsXG4gICAgICAgICAgICBpc1Bvc2l0aW9uUmlnaHQ6ICEhcGFyYW1zLmlzUG9zaXRpb25SaWdodCxcbiAgICAgICAgICAgIGFsaWduZWQ6ICEhcGFyYW1zLmFsaWduZWRcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aXNEYXRhTWFrZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQXhpcyBzY2FsZSBtYWtlci5cbiAqIEBhdXRoIE5ITiBFbnQuXG4gKiAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi9wcmVkaWNhdGUnKSxcbiAgICBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi9jYWxjdWxhdG9yJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmVuZGVyVXRpbCcpO1xuXG52YXIgYWJzID0gTWF0aC5hYnM7XG5cbnZhciBBeGlzU2NhbGVNYWtlciA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgQXhpc1NjYWxlTWFrZXIucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIEF4aXMgc2NhbGUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogQGNvbnN0cnVjdHMgQXhpc1NjYWxlTWFrZXJcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgcHJvY2Vzc29yXG4gICAgICAgICAqIEB0eXBlIHtEYXRhUHJvY2Vzc29yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gcGFyYW1zLmRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhcnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0eXBlIG9mIHZhbHVlIGxpa2UgdmFsdWUsIHgsIHksIHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVUeXBlID0gcGFyYW1zLnZhbHVlVHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdHlwZSBvZiBhcmVhIGxpa2UgeUF4aXMsIHhBeGlzXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFyZWFUeXBlID0gcGFyYW1zLmFyZWFUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHZlcnRpY2FsIHR5cGUgb3Igbm90LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNWZXJ0aWNhbCA9ICEhcGFyYW1zLmlzVmVydGljYWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgc2luZ2xlIHlBeGlzIG9yIG5vdC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzU2luZ2xlWUF4aXMgPSAhIXBhcmFtcy5pc1NpbmdsZVlBeGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ291bnQgb2Ygc2NhbGUgdmFsdWVzLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNvdW50cyA9IHBhcmFtcy52YWx1ZUNvdW50ID8gW3BhcmFtcy52YWx1ZUNvdW50XSA6IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgc2NhbGVcbiAgICAgICAgICogQHR5cGUge3tsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHN0ZXA6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjYWxlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybWF0dGVkIHNjYWxlIHZhbHVlcy5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmcgfCBudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXR0ZWRWYWx1ZXMgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2NhbGUuXG4gICAgICogQHJldHVybnMge3tsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHN0ZXA6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSB0aGlzLl9tYWtlU2NhbGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGltaXQuXG4gICAgICogQHJldHVybnMge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fVxuICAgICAqL1xuICAgIGdldExpbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNjYWxlKCkubGltaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzdGVwLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0U3RlcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTY2FsZSgpLnN0ZXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcGVyY2VudCBzdGFja2VkIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1BlcmNlbnRTdGFja2VkQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXNBbGxvd2VkU3RhY2tlZE9wdGlvbiA9IHByZWRpY2F0ZS5pc0FsbG93ZWRTdGFja2VkT3B0aW9uKHRoaXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIGlzUGVyY2VudFN0YWNrZWQgPSBwcmVkaWNhdGUuaXNQZXJjZW50U3RhY2tlZCh0aGlzLm9wdGlvbnMuc3RhY2tlZCk7XG5cbiAgICAgICAgcmV0dXJuIGlzQWxsb3dlZFN0YWNrZWRPcHRpb24gJiYgaXNQZXJjZW50U3RhY2tlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBub3JtYWwgc3RhY2tlZCBjaGFydCBvciBub3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNOb3JtYWxTdGFja2VkQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXNBbGxvd2VkU3RhY2tlZE9wdGlvbiA9IHByZWRpY2F0ZS5pc0FsbG93ZWRTdGFja2VkT3B0aW9uKHRoaXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIGlzTm9ybWFsU3RhY2tlZCA9IHByZWRpY2F0ZS5pc05vcm1hbFN0YWNrZWQodGhpcy5vcHRpb25zLnN0YWNrZWQpO1xuXG4gICAgICAgIHJldHVybiBpc0FsbG93ZWRTdGFja2VkT3B0aW9uICYmIGlzTm9ybWFsU3RhY2tlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBkaXZlcmdpbmcgY2hhcnQgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufCp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNEaXZlcmdpbmdDaGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGl2ZXJnaW5nICYmIHByZWRpY2F0ZS5pc0JhclR5cGVDaGFydCh0aGlzLmNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmdW5jdGlvbnMgZm9yIGZvcm1hdHRpbmcgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5LjxmdW5jdGlvbj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Rm9ybWF0RnVuY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZvcm1hdEZ1bmN0aW9ucztcblxuICAgICAgICBpZiAodGhpcy5faXNQZXJjZW50U3RhY2tlZENoYXJ0KCkpIHtcbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9ucyA9IFtmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSArICclJztcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNjYWxlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U2NhbGVWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLl9nZXRTY2FsZSgpLFxuICAgICAgICAgICAgdmFsdWVzID0gY2FsY3VsYXRvci5tYWtlTGFiZWxzRnJvbUxpbWl0KHNjYWxlLmxpbWl0LCBzY2FsZS5zdGVwKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXZlcmdpbmdDaGFydCgpID8gdHVpLnV0aWwubWFwKHZhbHVlcywgYWJzKSA6IHZhbHVlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGZvcm1hdHRlZCBzY2FsZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmd8bnVtYmVyPnwqfVxuICAgICAqL1xuICAgIGdldEZvcm1hdHRlZFNjYWxlVmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlcywgZm9ybWF0RnVuY3Rpb25zO1xuXG4gICAgICAgIGlmICghdGhpcy5mb3JtYXR0ZWRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuX2dldFNjYWxlVmFsdWVzKCk7XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB0aGlzLl9nZXRGb3JtYXRGdW5jdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkVmFsdWVzID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZXModmFsdWVzLCBmb3JtYXRGdW5jdGlvbnMsIHRoaXMuYXJlYVR5cGUsIHRoaXMudmFsdWVUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlZFZhbHVlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBiYXNlIHZhbHVlcyBvZiBub3JtYWwgc3RhY2tlZCBjaGFydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhc2VWYWx1ZXNGb3JOb3JtYWxTdGFja2VkQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFNlcmllc0RhdGFNb2RlbCh0aGlzLmNoYXJ0VHlwZSksXG4gICAgICAgICAgICBiYXNlVmFsdWVzID0gW107XG5cbiAgICAgICAgc2VyaWVzRGF0YU1vZGVsLmVhY2goZnVuY3Rpb24oc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXNNYXAgPSBzZXJpZXNHcm91cC5fbWFrZVZhbHVlc01hcFBlclN0YWNrKCk7XG5cbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2godmFsdWVzTWFwLCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGx1c1N1bSA9IGNhbGN1bGF0b3Iuc3VtUGx1c1ZhbHVlcyh2YWx1ZXMpLFxuICAgICAgICAgICAgICAgICAgICBtaW51c1N1bSA9IGNhbGN1bGF0b3Iuc3VtTWludXNWYWx1ZXModmFsdWVzKTtcbiAgICAgICAgICAgICAgICBiYXNlVmFsdWVzID0gYmFzZVZhbHVlcy5jb25jYXQoW3BsdXNTdW0sIG1pbnVzU3VtXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGJhc2VWYWx1ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYmFzZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSBiYXNlIHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXNlVmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJhc2VWYWx1ZXM7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc01hcENoYXJ0KHRoaXMuY2hhcnRUeXBlKSkge1xuICAgICAgICAgICAgYmFzZVZhbHVlcyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZXMoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU2luZ2xlWUF4aXMpIHtcbiAgICAgICAgICAgIGJhc2VWYWx1ZXMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0VmFsdWVzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNOb3JtYWxTdGFja2VkQ2hhcnQoKSkge1xuICAgICAgICAgICAgYmFzZVZhbHVlcyA9IHRoaXMuX21ha2VCYXNlVmFsdWVzRm9yTm9ybWFsU3RhY2tlZENoYXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVmFsdWVzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFZhbHVlcyh0aGlzLmNoYXJ0VHlwZSwgdGhpcy52YWx1ZVR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2VWYWx1ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBiYXNlIHNpemUgZm9yIGNhbGN1bGF0aW9uIGNhbmRpZGF0ZSB2YWx1ZSBjb3VudHMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gYmFzZSBzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QmFzZVNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmFzZVNpemU7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgYmFzZVNpemUgPSB0aGlzLmJvdW5kc01ha2VyLm1ha2VTZXJpZXNIZWlnaHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VTaXplID0gdGhpcy5ib3VuZHNNYWtlci5tYWtlU2VyaWVzV2lkdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlU2l6ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNhbmRpZGF0ZSBjb3VudHMgb2YgdmFsdWUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSB2YWx1ZSBjb3VudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDYW5kaWRhdGVDb3VudHNPZlZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1pblN0YXJ0ID0gMyxcbiAgICAgICAgICAgIHZhbHVlQ291bnRzLCBiYXNlU2l6ZSwgc3RhcnQsIGVuZDtcblxuICAgICAgICBiYXNlU2l6ZSA9IHRoaXMuX2dldEJhc2VTaXplKCk7XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgobWluU3RhcnQsIHBhcnNlSW50KGJhc2VTaXplIC8gY2hhcnRDb25zdC5NQVhfUElYRUxfVFlQRV9TVEVQX1NJWkUsIDEwKSk7XG4gICAgICAgIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBwYXJzZUludChiYXNlU2l6ZSAvIGNoYXJ0Q29uc3QuTUlOX1BJWEVMX1RZUEVfU1RFUF9TSVpFLCAxMCkpICsgMTtcbiAgICAgICAgdmFsdWVDb3VudHMgPSB0dWkudXRpbC5yYW5nZShzdGFydCwgZW5kKTtcblxuICAgICAgICByZXR1cm4gdmFsdWVDb3VudHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGltaXQgZm9yIGRpdmVyZ2luZyBvcHRpb24uXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgbGltaXRcbiAgICAgKiBAcmV0dXJucyB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGNoYW5nZWQgbGltaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGltaXRGb3JEaXZlcmdpbmdPcHRpb246IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHZhciBuZXdNYXggPSBNYXRoLm1heChhYnMobGltaXQubWluKSwgYWJzKGxpbWl0Lm1heCkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IC1uZXdNYXgsXG4gICAgICAgICAgICBtYXg6IG5ld01heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGludGVnZXIgdHlwZSBzY2FsZS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBsaW1pdFxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sXG4gICAgICogICAgICBvcHRpb25zOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGRpdmlkZU51bTogbnVtYmVyXG4gICAgICogfX0gaW50ZWdlciB0eXBlIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSW50ZWdlclR5cGVTY2FsZTogZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMubGltaXQgfHwge30sXG4gICAgICAgICAgICBtaW4gPSBsaW1pdC5taW4sXG4gICAgICAgICAgICBtYXggPSBsaW1pdC5tYXgsXG4gICAgICAgICAgICBtdWx0aXBsZU51bSwgY2hhbmdlZE9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGFicyhtaW4pID49IDEgfHwgYWJzKG1heCkgPj0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBkaXZpZGVOdW06IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBtdWx0aXBsZU51bSA9IHR1aS51dGlsLmZpbmRNdWx0aXBsZU51bShtaW4sIG1heCk7XG4gICAgICAgIGNoYW5nZWRPcHRpb25zID0ge307XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc1VuZGVmaW5lZChvcHRpb25zLm1pbikpIHtcbiAgICAgICAgICAgIGNoYW5nZWRPcHRpb25zLm1pbiA9IG9wdGlvbnMubWluICogbXVsdGlwbGVOdW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubWF4KSkge1xuICAgICAgICAgICAgY2hhbmdlZE9wdGlvbnMubWF4ID0gb3B0aW9ucy5tYXggKiBtdWx0aXBsZU51bTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW1pdDoge1xuICAgICAgICAgICAgICAgIG1pbjogbWluICogbXVsdGlwbGVOdW0sXG4gICAgICAgICAgICAgICAgbWF4OiBtYXggKiBtdWx0aXBsZU51bVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGNoYW5nZWRPcHRpb25zLFxuICAgICAgICAgICAgZGl2aWRlTnVtOiBtdWx0aXBsZU51bVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxpbWl0IGlmIGVxdWFsIG1pbiBhbmQgbWF4LlxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGxpbWl0IGxpbWl0XG4gICAgICogQHJldHVybnMge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBjaGFuZ2VkIGxpbWl0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxpbWl0SWZFcXVhbE1pbk1heDogZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgdmFyIG1pbiA9IGxpbWl0Lm1pbixcbiAgICAgICAgICAgIG1heCA9IGxpbWl0Lm1heDtcblxuICAgICAgICBpZiAobWluID4gMCkge1xuICAgICAgICAgICAgbWluID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChtaW4gPCAwKSB7XG4gICAgICAgICAgICBtYXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogbWluLFxuICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBiYXNlIGxpbWl0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gZGF0YUxpbWl0IHVzZXIgbGltaXRcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBvcHRpb25zIGF4aXMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gYmFzZSBsaW1pdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXNlTGltaXQ6IGZ1bmN0aW9uKGRhdGFMaW1pdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaXNNaW51c0xpbWl0ID0gcHJlZGljYXRlLmlzTWludXNMaW1pdChkYXRhTGltaXQpLFxuICAgICAgICAgICAgbWluID0gZGF0YUxpbWl0Lm1pbixcbiAgICAgICAgICAgIG1heCA9IGRhdGFMaW1pdC5tYXgsXG4gICAgICAgICAgICBiYXNlTGltaXQsIHRtcE1pbjtcblxuICAgICAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgICAgICAgIGJhc2VMaW1pdCA9IHRoaXMuX21ha2VMaW1pdElmRXF1YWxNaW5NYXgoZGF0YUxpbWl0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc01pbnVzTGltaXQpIHtcbiAgICAgICAgICAgICAgICB0bXBNaW4gPSBtaW47XG4gICAgICAgICAgICAgICAgbWluID0gLW1heDtcbiAgICAgICAgICAgICAgICBtYXggPSAtdG1wTWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXNlTGltaXQgPSBjYWxjdWxhdG9yLmNhbGN1bGF0ZUxpbWl0KG1pbiwgbWF4KTtcblxuICAgICAgICAgICAgaWYgKGlzTWludXNMaW1pdCkge1xuICAgICAgICAgICAgICAgIHRtcE1pbiA9IGJhc2VMaW1pdC5taW47XG4gICAgICAgICAgICAgICAgYmFzZUxpbWl0Lm1pbiA9IC1iYXNlTGltaXQubWF4O1xuICAgICAgICAgICAgICAgIGJhc2VMaW1pdC5tYXggPSAtdG1wTWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXNlTGltaXQubWluID0gdHVpLnV0aWwuaXNVbmRlZmluZWQob3B0aW9ucy5taW4pID8gYmFzZUxpbWl0Lm1pbiA6IG9wdGlvbnMubWluO1xuICAgICAgICAgICAgYmFzZUxpbWl0Lm1heCA9IHR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubWF4KSA/IGJhc2VMaW1pdC5tYXggOiBvcHRpb25zLm1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlTGltaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBtaW4uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBvcmlnaW5hbCBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBzY2FsZSBzdGVwXG4gICAgICogQHJldHVybnMge251bWJlcn0gbm9ybWFsaXplZCBtaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVNaW46IGZ1bmN0aW9uKG1pbiwgc3RlcCkge1xuICAgICAgICB2YXIgbW9kID0gdHVpLnV0aWwubW9kKG1pbiwgc3RlcCksXG4gICAgICAgICAgICBub3JtYWxpemVkO1xuXG4gICAgICAgIGlmIChtb2QgPT09IDApIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBtaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdHVpLnV0aWwuc3VidHJhY3Rpb24obWluLCAobWluID49IDAgPyBtb2QgOiBzdGVwICsgbW9kKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugbm9ybWFsaXplZCBtYXguXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgbGltaXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBzY2FsZSBzdGVwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlQ291bnQgdmFsdWUgY291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBub3JtYWxpemVkIG1heFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VOb3JtYWxpemVkTWF4OiBmdW5jdGlvbihsaW1pdCwgc3RlcCwgdmFsdWVDb3VudCkge1xuICAgICAgICB2YXIgbWluTWF4RGlmZiA9IHR1aS51dGlsLm11bHRpcGxpY2F0aW9uKHN0ZXAsIHZhbHVlQ291bnQgLSAxKSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXggPSB0dWkudXRpbC5hZGRpdGlvbihsaW1pdC5taW4sIG1pbk1heERpZmYpLFxuICAgICAgICAgICAgbWF4RGlmZiA9IGxpbWl0Lm1heCAtIG5vcm1hbGl6ZWRNYXgsXG4gICAgICAgICAgICBtb2REaWZmLCBkaXZpZGVEaWZmO1xuICAgICAgICAvLyBub3JtYWxpemXrkJwgbWF46rCS7J20IOybkOuemOydmCBtYXjqsJIg67O064ukIOyekeydhCDqsr3smrAgc3RlcOydhCDspp3qsIDsi5zsvJwg7YGwIOqwkuycvOuhnCDrp4zrk6TquLBcbiAgICAgICAgaWYgKG1heERpZmYgPiAwKSB7XG4gICAgICAgICAgICBtb2REaWZmID0gbWF4RGlmZiAlIHN0ZXA7XG4gICAgICAgICAgICBkaXZpZGVEaWZmID0gTWF0aC5mbG9vcihtYXhEaWZmIC8gc3RlcCk7XG4gICAgICAgICAgICBub3JtYWxpemVkTWF4ICs9IHN0ZXAgKiAobW9kRGlmZiA+IDAgPyBkaXZpZGVEaWZmICsgMSA6IGRpdmlkZURpZmYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkTWF4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgbGltaXQuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgYmFzZSBsaW1pdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIHNjYWxlIHN0ZXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVDb3VudCB2YWx1ZSBjb3VudFxuICAgICAqIEByZXR1cm5zIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbm9ybWFsaXplZCBsaW1pdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25vcm1hbGl6ZUxpbWl0OiBmdW5jdGlvbihsaW1pdCwgc3RlcCwgdmFsdWVDb3VudCkge1xuICAgICAgICBsaW1pdC5taW4gPSB0aGlzLl9ub3JtYWxpemVNaW4obGltaXQubWluLCBzdGVwKTtcbiAgICAgICAgbGltaXQubWF4ID0gdGhpcy5fbWFrZU5vcm1hbGl6ZWRNYXgobGltaXQsIHN0ZXAsIHZhbHVlQ291bnQpO1xuICAgICAgICByZXR1cm4gbGltaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY3JlYXNlIG1pbmltdW0gdmFsdWUgYnkgc3RlcCB2YWx1ZSxcbiAgICAgKiAgd2hlbiBjaGFydCB0eXBlIGlzIGxpbmUgb3IgZGF0YU1pbiBpcyBtaW51cywgb3B0aW9ucyBpcyB1bmRlZmluZWQsIG1pbmltdW0gdmFsdWVzKG1pbiwgZGF0YU1pbikgYXJlIHNhbWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBiYXNlIG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhTWluIG1pbmltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgc2NhbGUgc3RlcFxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gb3B0aW9uTWluIG1pbiBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBjaGFuZ2VkIG1pblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlY3JlYXNlTWluQnlTdGVwOiBmdW5jdGlvbihtaW4sIGRhdGFNaW4sIHN0ZXAsIG9wdGlvbk1pbikge1xuICAgICAgICB2YXIgaXNMaW5lQ2hhcnQgPSBwcmVkaWNhdGUuaXNMaW5lQ2hhcnQodGhpcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgaXNNaW51c0RhdGFNaW4gPSBkYXRhTWluIDwgMCxcbiAgICAgICAgICAgIGlzVW5kZWZpbmVkTWluT3B0aW9uID0gdHVpLnV0aWwuaXNVbmRlZmluZWQob3B0aW9uTWluKSxcbiAgICAgICAgICAgIGlzU2FtZSA9IChtaW4gPT09IGRhdGFNaW4pO1xuXG4gICAgICAgIGlmICgoaXNMaW5lQ2hhcnQgfHwgaXNNaW51c0RhdGFNaW4pICYmIGlzVW5kZWZpbmVkTWluT3B0aW9uICYmIGlzU2FtZSkge1xuICAgICAgICAgICAgbWluIC09IHN0ZXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmNyZWFzZSBtYXhpbXVtIHZhbHVlIGJ5IHN0ZXAgdmFsdWUsXG4gICAgICogIHdoZW4gY2hhcnQgdHlwZSBpcyBsaW5lIG9yIGRhdGFNaW4gaXMgcGx1cywgb3B0aW9ucyBpcyB1bmRlZmluZWQsIG1heGltdW0gdmFsdWVzKG1heCwgZGF0YU1heCkgYXJlIHNhbWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBiYXNlIG1heFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhTWF4IG1heGltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgc2NhbGUgc3RlcFxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gb3B0aW9uTWF4IG1heCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBjaGFuZ2VkIG1heFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luY3JlYXNlTWF4QnlTdGVwOiBmdW5jdGlvbihtYXgsIGRhdGFNYXgsIHN0ZXAsIG9wdGlvbk1heCkge1xuICAgICAgICB2YXIgaXNMaW5lQ2hhcnQgPSBwcmVkaWNhdGUuaXNMaW5lQ2hhcnQodGhpcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgaXNQbHVzRGF0YU1heCA9IGRhdGFNYXggPiAwLFxuICAgICAgICAgICAgaXNVbmRlZmluZWRNYXhPcHRpb24gPSB0dWkudXRpbC5pc1VuZGVmaW5lZChvcHRpb25NYXgpLFxuICAgICAgICAgICAgaXNTYW1lID0gKG1heCA9PT0gZGF0YU1heCk7XG5cbiAgICAgICAgaWYgKChpc0xpbmVDaGFydCB8fCBpc1BsdXNEYXRhTWF4KSAmJiBpc1VuZGVmaW5lZE1heE9wdGlvbiAmJiBpc1NhbWUpIHtcbiAgICAgICAgICAgIG1heCArPSBzdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlIHNjYWxlIHN0ZXAuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgbGltaXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBzdGVwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNhbmRpZGF0ZVZhbHVlQ291bnQgY2FuZGlkYXRlIHZhbHVlQ291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzY2FsZSBzdGVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGl2aWRlU2NhbGVTdGVwOiBmdW5jdGlvbihsaW1pdCwgc3RlcCwgY2FuZGlkYXRlVmFsdWVDb3VudCkge1xuICAgICAgICB2YXIgaXNFdmVuU3RlcCA9ICgoc3RlcCAlIDIpID09PSAwKSxcbiAgICAgICAgICAgIHZhbHVlQ291bnQgPSBjYWxjdWxhdG9yLm1ha2VMYWJlbHNGcm9tTGltaXQobGltaXQsIHN0ZXApLmxlbmd0aCxcbiAgICAgICAgICAgIHR3aWNlVmFsdWVDb3VudCA9ICh2YWx1ZUNvdW50ICogMikgLSAxLFxuICAgICAgICAgICAgZGlmZk9yZyA9IGFicyhjYW5kaWRhdGVWYWx1ZUNvdW50IC0gdmFsdWVDb3VudCksXG4gICAgICAgICAgICBkaWZmVHdpY2UgPSBhYnMoY2FuZGlkYXRlVmFsdWVDb3VudCAtIHR3aWNlVmFsdWVDb3VudCk7XG5cbiAgICAgICAgLy8gc3RlcOydhCDrsJjsnLzroZwg64KY64iE7JeI7J2EIOuVjOydmCB2YWx1ZUNvdW506rCAIO2bhOuztOuhnCDqs4TsgrDrkJwgY2FuZGlkYXRlVmFsdWVDb3VudOyZgCDsnbjsoJHtlZjrqbQgc3RlcOydhCDrsJjsnLzroZwg64KY64iE7Ja0IOuwmO2ZmO2VqeuLiOuLpC5cbiAgICAgICAgaWYgKGlzRXZlblN0ZXAgJiYgZGlmZlR3aWNlIDw9IGRpZmZPcmcpIHtcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwIC8gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWluaW1pemUgc2NhbGUgbGltaXQuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgYmFzZSBsaW1pdFxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGRhdGFMaW1pdCBsaW1pdCBvZiB1c2VyIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBzY2FsZSBzdGVwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlQ291bnQgdmFsdWUgY291bnRcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4Om51bWJlcn19IG9wdGlvbnMgbGltaXQgb3B0aW9ucyBvZiBheGlzXG4gICAgICogQHJldHVybnMge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBtaW5pbWl6ZWQgbGltaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9taW5pbWl6ZVNjYWxlTGltaXQ6IGZ1bmN0aW9uKGxpbWl0LCBkYXRhTGltaXQsIHN0ZXAsIHZhbHVlQ291bnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1pbiA9IGxpbWl0Lm1heCxcbiAgICAgICAgICAgIG1heCA9IGxpbWl0Lm1pbixcbiAgICAgICAgICAgIGNvbXBhcmlzb25NaW4gPSB0dWkudXRpbC5pc1VuZGVmaW5lZChvcHRpb25zLm1pbikgPyBkYXRhTGltaXQubWluIC0gMSA6IG9wdGlvbnMubWluLFxuICAgICAgICAgICAgY29tcGFyaXNvbk1heCA9IHR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubWF4KSA/IGRhdGFMaW1pdC5tYXggKyAxIDogb3B0aW9ucy5tYXg7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHR1aS51dGlsLnJhbmdlKDEsIHZhbHVlQ291bnQpLCBmdW5jdGlvbih2YWx1ZUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdpbmdTdGVwID0gKHN0ZXAgKiB2YWx1ZUluZGV4KSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VkTWluID0gbWF4ICsgY2hhbmdpbmdTdGVwLFxuICAgICAgICAgICAgICAgIGNoYW5nZWRNYXggPSBtaW4gLSBjaGFuZ2luZ1N0ZXA7XG5cbiAgICAgICAgICAgIC8vIGxpbWl07J20IGRhdGFMaW1pdCDrspTsnITrpbwg64SY7Ja06rCIIOqyg+ycvOuhnCDsmIjsg4HrkJjripQg6rK97Jqw7JeQIOuzgOqyveydhCDspJHri6jtlahcbiAgICAgICAgICAgIGlmIChkYXRhTGltaXQubWluIDw9IGNoYW5nZWRNaW4gJiYgZGF0YUxpbWl0Lm1heCA+PSBjaGFuZ2VkTWF4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcGFyaXNvbk1pbiA+PSBjaGFuZ2VkTWluKSB7XG4gICAgICAgICAgICAgICAgbGltaXQubWluID0gY2hhbmdlZE1pbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbXBhcmlzb25NYXggPD0gY2hhbmdlZE1heCkge1xuICAgICAgICAgICAgICAgIGxpbWl0Lm1heCA9IGNoYW5nZWRNYXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbGltaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBsaW1pdCBmb3IgYnViYmxlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGxpbWl0IC0gbGltaXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCAtIHN0ZXA7XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRqdXN0TGltaXRGb3JCdWJibGVDaGFydDogZnVuY3Rpb24obGltaXQsIHN0ZXApIHtcbiAgICAgICAgdmFyIHZhbHVlVHlwZSA9IHRoaXMudmFsdWVUeXBlO1xuICAgICAgICB2YXIgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFNlcmllc0RhdGFNb2RlbCh0aGlzLmNoYXJ0VHlwZSk7XG4gICAgICAgIHZhciBtYXhSYWRpdXNWYWx1ZSA9IHNlcmllc0RhdGFNb2RlbC5nZXRNYXhWYWx1ZSgncicpO1xuICAgICAgICB2YXIgaXNCaWdnZXJSYXRpb1RoYW5IYWxmUmF0aW8gPSBmdW5jdGlvbihzZXJpZXNJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gKHNlcmllc0l0ZW0uciAvIG1heFJhZGl1c1ZhbHVlKSA+IGNoYXJ0Q29uc3QuSEFMRl9SQVRJTztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZvdW5kTWluSXRlbSA9IHNlcmllc0RhdGFNb2RlbC5maW5kTWluU2VyaWVzSXRlbSh2YWx1ZVR5cGUsIGlzQmlnZ2VyUmF0aW9UaGFuSGFsZlJhdGlvKTtcbiAgICAgICAgdmFyIGZvdW5kTWF4SXRlbSA9IHNlcmllc0RhdGFNb2RlbC5maW5kTWF4U2VyaWVzSXRlbSh2YWx1ZVR5cGUsIGlzQmlnZ2VyUmF0aW9UaGFuSGFsZlJhdGlvKTtcblxuICAgICAgICBpZiAoZm91bmRNaW5JdGVtKSB7XG4gICAgICAgICAgICBsaW1pdC5taW4gLT0gc3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3VuZE1heEl0ZW0pIHtcbiAgICAgICAgICAgIGxpbWl0Lm1heCArPSBzdGVwO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY2FuZGlkYXRlIGF4aXMgc2NhbGUuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gYmFzZUxpbWl0IGJhc2UgbGltaXRcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBkYXRhTGltaXQgbGltaXQgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlQ291bnQgdmFsdWUgY291bnRcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4Om51bWJlcn19IG9wdGlvbnMgbGltaXQgb3B0aW9ucyBvZiBheGlzXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGxpbWl0OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHN0ZXA6IG51bWJlclxuICAgICAqIH19IHNjYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNhbmRpZGF0ZVNjYWxlOiBmdW5jdGlvbihiYXNlTGltaXQsIGRhdGFMaW1pdCwgdmFsdWVDb3VudCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGltaXQgPSB0dWkudXRpbC5leHRlbmQoe30sIGJhc2VMaW1pdCksXG4gICAgICAgICAgICBzdGVwO1xuXG4gICAgICAgIC8vIDAxLiDquLDrs7ggbGltaXQg7KCV67O066GcIHN0ZXAg7Ja76riwXG4gICAgICAgIHN0ZXAgPSBjYWxjdWxhdG9yLmNhbGN1bGF0ZVN0ZXBGcm9tTGltaXQobGltaXQsIHZhbHVlQ291bnQpO1xuXG4gICAgICAgIC8vIDAyLiBzdGVwIOygleq3nO2ZlCDsi5ztgqTquLAgKGV4OiAwLjMgLS0+IDAuNSwgNyAtLT4gMTApXG4gICAgICAgIHN0ZXAgPSBjYWxjdWxhdG9yLm5vcm1hbGl6ZUF4aXNOdW1iZXIoc3RlcCk7XG5cbiAgICAgICAgLy8gMDMuIGxpbWl0IOygleq3nO2ZlCDsi5ztgqTquLBcbiAgICAgICAgbGltaXQgPSB0aGlzLl9ub3JtYWxpemVMaW1pdChsaW1pdCwgc3RlcCwgdmFsdWVDb3VudCk7XG5cbiAgICAgICAgLy8gMDQuIGxpbmXssKjtirjsnZgg6rK97JqwIOyCrOyaqeyekOydmCBtaW7qsJLsnbQgbGltaXTsnZggbWlu6rCS6rO8IOqwmeydhCDqsr3smrAsIG1pbuqwkuydhCAxIHN0ZXAg6rCQ7IaMIOyLnO2CtFxuICAgICAgICBsaW1pdC5taW4gPSB0aGlzLl9kZWNyZWFzZU1pbkJ5U3RlcChsaW1pdC5taW4sIGRhdGFMaW1pdC5taW4sIHN0ZXAsIG9wdGlvbnMubWluKTtcblxuICAgICAgICAvLyAwNC4g7IKs7Jqp7J6Q7J2YIG1heOqwkuydtCBzY2FsZSBtYXjsmYAg6rCZ7J2EIOqyveyasCwgbWF46rCS7J2EIDEgc3RlcCDspp3qsIAg7Iuc7YK0XG4gICAgICAgIGxpbWl0Lm1heCA9IHRoaXMuX2luY3JlYXNlTWF4QnlTdGVwKGxpbWl0Lm1heCwgZGF0YUxpbWl0Lm1heCwgc3RlcCwgb3B0aW9ucy5tYXgpO1xuXG4gICAgICAgIC8vIDA1LiBheGlzIGxpbWl07J20IOyCrOyaqeyekCBtaW4sIG1heOyZgCDqsbDrpqzqsIAg66mAIOqyveyasCDsobDsoIhcbiAgICAgICAgbGltaXQgPSB0aGlzLl9taW5pbWl6ZVNjYWxlTGltaXQobGltaXQsIGRhdGFMaW1pdCwgc3RlcCwgdmFsdWVDb3VudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gMDYuIOyhsOqxtOyXkCDrlLDrnbwgc3RlcOqwkuydhCDrsJjsnLzroZwg64KY64iUXG4gICAgICAgIHN0ZXAgPSB0aGlzLl9kaXZpZGVTY2FsZVN0ZXAobGltaXQsIHN0ZXAsIHZhbHVlQ291bnQpO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNCdWJibGVDaGFydCh0aGlzLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkanVzdExpbWl0Rm9yQnViYmxlQ2hhcnQobGltaXQsIHN0ZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICB2YWx1ZUNvdW50OiBhYnMobGltaXQubWF4IC0gbGltaXQubWluKSAvIHN0ZXBcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjYW5kaWRhdGVzIGFib3V0IGF4aXMgc2NhbGUuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sXG4gICAgICogICAgICBvcHRpb25zOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGRpdmlkZU51bTogbnVtYmVyXG4gICAgICogfX0gaW50ZWdlclR5cGVTY2FsZSAtIGludGVnZXIgdHlwZSBheGlzIHNjYWxlXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVDb3VudHMgLSBjYW5kaWRhdGUgY291bnRzIG9mIHZhbHVlXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7bGltaXQ6e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHN0cGU6IG51bWJlcn0+fSAtIGNhbmRpZGF0ZXMgc2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ2FuZGlkYXRlU2NhbGVzOiBmdW5jdGlvbihpbnRlZ2VyVHlwZVNjYWxlLCB2YWx1ZUNvdW50cykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBkYXRhTGltaXQgPSBpbnRlZ2VyVHlwZVNjYWxlLmxpbWl0LFxuICAgICAgICAgICAgb3B0aW9ucyA9IGludGVnZXJUeXBlU2NhbGUub3B0aW9ucyxcbiAgICAgICAgICAgIGJhc2VMaW1pdCA9IHRoaXMuX21ha2VCYXNlTGltaXQoZGF0YUxpbWl0LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHZhbHVlQ291bnRzLCBmdW5jdGlvbih2YWx1ZUNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fbWFrZUNhbmRpZGF0ZVNjYWxlKGJhc2VMaW1pdCwgZGF0YUxpbWl0LCB2YWx1ZUNvdW50LCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb21wYXJpbmcgdmFsdWUgZm9yIHNlbGVjdGluZyBheGlzIHNjYWxlLlxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGJhc2VMaW1pdCAtIGxpbWl0XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVDb3VudHMgLSBjYW5kaWRhdGUgY291bnRzIG9mIHZhbHVlXG4gICAgICogQHBhcmFtIHt7bGltaXQ6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9LCBzdGVwOiBudW1iZXJ9fSBjYW5kaWRhdGVTY2FsZSAtIHNjYWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBjb21wYXJpbmcgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDb21wYXJpbmdWYWx1ZTogZnVuY3Rpb24oYmFzZUxpbWl0LCB2YWx1ZUNvdW50cywgY2FuZGlkYXRlU2NhbGUsIGluZGV4KSB7XG4gICAgICAgIHZhciBkaWZmTWF4ID0gYWJzKGNhbmRpZGF0ZVNjYWxlLmxpbWl0Lm1heCAtIGJhc2VMaW1pdC5tYXgpO1xuICAgICAgICB2YXIgZGlmZk1pbiA9IGFicyhiYXNlTGltaXQubWluIC0gY2FuZGlkYXRlU2NhbGUubGltaXQubWluKTtcbiAgICAgICAgLy8g7JiI7IOBIGxhYmVsIGNvdW507JmAIOywqOydtOqwgCDrp47snYQg7IiY66GdIO2bhOuztCDsoJzsmbgg6rCA64ql7ISx7J20IOuGkuydjFxuICAgICAgICB2YXIgZGlmZkNvdW50ID0gTWF0aC5tYXgoYWJzKHZhbHVlQ291bnRzW2luZGV4XSAtIGNhbmRpZGF0ZVNjYWxlLnZhbHVlQ291bnQpLCAxKTtcbiAgICAgICAgLy8g7IaM7IiY7KCQIOydtO2VmCDquLjsnbTqsIAg6ri4IOyImOuhnSDtm4Trs7Tsl5DshJwg7KCc7Jm465CgIOqwgOuKpeyEseydtCDrhpLsnYxcbiAgICAgICAgdmFyIHdlaWdodCA9IE1hdGgucG93KDEwLCB0dWkudXRpbC5nZXREZWNpbWFsTGVuZ3RoKGNhbmRpZGF0ZVNjYWxlLnN0ZXApKTtcblxuICAgICAgICByZXR1cm4gKGRpZmZNYXggKyBkaWZmTWluKSAqIGRpZmZDb3VudCAqIHdlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGF4aXMgc2NhbGUuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gYmFzZUxpbWl0IGxpbWl0XG4gICAgICogQHBhcmFtIHtBcnJheS48e2xpbWl0OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgc3RlcDogbnVtYmVyfT59IGNhbmRpZGF0ZXMgc2NhbGUgY2FuZGlkYXRlc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlQ291bnRzIC0gbGFiZWwgY291bnRzXG4gICAgICogQHJldHVybnMge3tsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHN0ZXA6IG51bWJlcn19IHNlbGVjdGVkIHNjYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VsZWN0QXhpc1NjYWxlOiBmdW5jdGlvbihiYXNlTGltaXQsIGNhbmRpZGF0ZXMsIHZhbHVlQ291bnRzKSB7XG4gICAgICAgIHZhciBnZXRDb21wYXJpbmdWYWx1ZSA9IHR1aS51dGlsLmJpbmQodGhpcy5fZ2V0Q29tcGFyaW5nVmFsdWUsIHRoaXMsIGJhc2VMaW1pdCwgdmFsdWVDb3VudHMpO1xuICAgICAgICB2YXIgYXhpc1NjYWxlID0gdHVpLnV0aWwubWluKGNhbmRpZGF0ZXMsIGdldENvbXBhcmluZ1ZhbHVlKTtcblxuICAgICAgICByZXR1cm4gYXhpc1NjYWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIG51bWJlciBzdGF0ZSBvZiBzY2FsZS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge3tsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHN0ZXA6IG51bWJlcn19IHNjYWxlIHNjYWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlkZU51bSBkaXZpZGUgbnVtXG4gICAgICogQHJldHVybnMge3tsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHN0ZXA6IG51bWJlcn19IHJlc3RvcmVkIHNjYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzdG9yZU51bWJlclN0YXRlOiBmdW5jdGlvbihzY2FsZSwgZGl2aWRlTnVtKSB7XG4gICAgICAgIGlmIChkaXZpZGVOdW0gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjYWxlLnN0ZXAgPSB0dWkudXRpbC5kaXZpc2lvbihzY2FsZS5zdGVwLCBkaXZpZGVOdW0pO1xuICAgICAgICBzY2FsZS5saW1pdC5taW4gPSB0dWkudXRpbC5kaXZpc2lvbihzY2FsZS5saW1pdC5taW4sIGRpdmlkZU51bSk7XG4gICAgICAgIHNjYWxlLmxpbWl0Lm1heCA9IHR1aS51dGlsLmRpdmlzaW9uKHNjYWxlLmxpbWl0Lm1heCwgZGl2aWRlTnVtKTtcblxuICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBzY2FsZS5cbiAgICAgKiBAcmV0dXJucyB7e2xpbWl0OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgc3RlcDogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVTY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiYXNlVmFsdWVzID0gdGhpcy5fbWFrZUJhc2VWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGRhdGFMaW1pdCA9IHtcbiAgICAgICAgICAgIG1pbjogdHVpLnV0aWwubWluKGJhc2VWYWx1ZXMpLFxuICAgICAgICAgICAgbWF4OiB0dWkudXRpbC5tYXgoYmFzZVZhbHVlcylcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGludGVnZXJUeXBlU2NhbGUsIHZhbHVlQ291bnRzLCBjYW5kaWRhdGVzLCBzY2FsZTtcblxuICAgICAgICBpZiAoZGF0YUxpbWl0Lm1pbiA9PT0gMCAmJiBkYXRhTGltaXQubWF4ID09PSAwKSB7XG4gICAgICAgICAgICBkYXRhTGltaXQubWF4ID0gNTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pc0RpdmVyZ2luZ0NoYXJ0KCkpIHtcbiAgICAgICAgICAgIGRhdGFMaW1pdCA9IHRoaXMuX21ha2VMaW1pdEZvckRpdmVyZ2luZ09wdGlvbihkYXRhTGltaXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMDEuIGxpbWl0LCBvcHRpb25zIOygleuztOulvCDsoJXsiJjtmJXsnLzroZwg67OA6rK9XG4gICAgICAgIGludGVnZXJUeXBlU2NhbGUgPSB0aGlzLl9tYWtlSW50ZWdlclR5cGVTY2FsZShkYXRhTGltaXQpO1xuXG4gICAgICAgIC8vIDAyLiB2YWx1ZSBjb3VudCDtm4Trs7TqtbAg7Ja76riwXG4gICAgICAgIHZhbHVlQ291bnRzID0gdGhpcy52YWx1ZUNvdW50cyB8fCB0aGlzLl9nZXRDYW5kaWRhdGVDb3VudHNPZlZhbHVlKCk7XG5cbiAgICAgICAgLy8gMDMuIGF4aXMgc2NhbGUg7ZuE67O06rWwIOyWu+q4sFxuICAgICAgICBjYW5kaWRhdGVzID0gdGhpcy5fbWFrZUNhbmRpZGF0ZVNjYWxlcyhpbnRlZ2VyVHlwZVNjYWxlLCB2YWx1ZUNvdW50cyk7XG5cbiAgICAgICAgLy8gMDQuIGF4aXMgc2NhbGUg7ZuE67O06rWwIOykkSDtlZjrgpgg7ISg7YOdXG4gICAgICAgIHNjYWxlID0gdGhpcy5fc2VsZWN0QXhpc1NjYWxlKGludGVnZXJUeXBlU2NhbGUubGltaXQsIGNhbmRpZGF0ZXMsIHZhbHVlQ291bnRzKTtcblxuICAgICAgICAvLyAwNS4g7KCV7IiY7ZiV7Jy866GcIOuzgOqyve2WiOuNmCBzY2FsZeulvCDsm5Drnpgg7ZiV7YOc66GcIOuzgOqyvVxuICAgICAgICBzY2FsZSA9IHRoaXMuX3Jlc3RvcmVOdW1iZXJTdGF0ZShzY2FsZSwgaW50ZWdlclR5cGVTY2FsZS5kaXZpZGVOdW0pO1xuXG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlcyBmb3Igc3VtLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRWYWx1ZXNGb3JTdW06IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzO1xuXG4gICAgICAgIGlmICh0aGlzLmlzU2luZ2xlWUF4aXMpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZXModGhpcy5jaGFydFR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIG1pbnVzIHN1bSBhYm91dCBncm91cCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVNaW51c1N1bTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLl9nZXRWYWx1ZXNGb3JTdW0oKTtcblxuICAgICAgICByZXR1cm4gY2FsY3VsYXRvci5zdW1NaW51c1ZhbHVlcyh2YWx1ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgcGx1cyBzdW0gYWJvdXQgZ3JvdXAgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlUGx1c1N1bTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLl9nZXRWYWx1ZXNGb3JTdW0oKTtcblxuICAgICAgICByZXR1cm4gY2FsY3VsYXRvci5zdW1QbHVzVmFsdWVzKHZhbHVlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBwZXJjZW50IHN0YWNrZWQgc2NhbGUuXG4gICAgICogQHJldHVybnMge3tsaW1pdDoge21pbjpudW1iZXIsIG1heDpudW1iZXJ9LCBzdGVwOiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFBlcmNlbnRTdGFja2VkU2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2NhbGU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2NhbGN1bGF0ZU1pbnVzU3VtKCkgPT09IDApIHtcbiAgICAgICAgICAgIHNjYWxlID0gY2hhcnRDb25zdC5QRVJDRU5UX1NUQUNLRURfQVhJU19TQ0FMRTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jYWxjdWxhdGVQbHVzU3VtKCkgPT09IDApIHtcbiAgICAgICAgICAgIHNjYWxlID0gY2hhcnRDb25zdC5NSU5VU19QRVJDRU5UX1NUQUNLRURfQVhJU19TQ0FMRTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0RpdmVyZ2luZ0NoYXJ0KCkpIHtcbiAgICAgICAgICAgIHNjYWxlID0gY2hhcnRDb25zdC5ESVZFUkdJTkdfUEVSQ0VOVF9TVEFDS0VEX0FYSVNfU0NBTEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FsZSA9IGNoYXJ0Q29uc3QuRFVBTF9QRVJDRU5UX1NUQUNLRURfQVhJU19TQ0FMRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzY2FsZS5cbiAgICAgKiBAcmV0dXJucyB7e2xpbWl0OiB7bWluOm51bWJlciwgbWF4Om51bWJlcn0sIHN0ZXA6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNjYWxlO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1BlcmNlbnRTdGFja2VkQ2hhcnQoKSkge1xuICAgICAgICAgICAgc2NhbGUgPSB0aGlzLl9nZXRQZXJjZW50U3RhY2tlZFNjYWxlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FsZSA9IHRoaXMuX2NhbGN1bGF0ZVNjYWxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpc1NjYWxlTWFrZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQm91bmRzIG1ha2VyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgY2FsY3VsYXRvciA9IHJlcXVpcmUoJy4vY2FsY3VsYXRvcicpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4vcHJlZGljYXRlJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmVuZGVyVXRpbCcpO1xuXG4vKipcbiAqIERpbWVuc2lvbi5cbiAqIEB0eXBlZGVmIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IGRpbWVuc2lvblxuICovXG5cbi8qKlxuICogUG9zaXRpb24uXG4gKiBAdHlwZWRlZiB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlcn19IHBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBCb3VuZC5cbiAqIEB0eXBlZGVmIHt7ZGltZW5zaW9uOiBkaW1lbnNpb24sIHBvc2l0aW9uOnBvc2l0aW9ufX0gYm91bmRcbiAqL1xuXG52YXIgQm91bmRzTWFrZXIgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIEJvdW5kc01ha2VyLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBCb3VuZHMgbWFrZXIuXG4gICAgICogQGNvbnN0cnVjdHMgQm91bmRzTWFrZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVnZW5kID0gdGhpcy5vcHRpb25zLmxlZ2VuZCB8fCB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnlBeGlzID0gdGhpcy5vcHRpb25zLnlBeGlzIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGVtZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IHBhcmFtcy50aGVtZSB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciBjaGFydCBoYXMgYXhlcyBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0F4ZXMgPSBwYXJhbXMuaGFzQXhlcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhcnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkYXRhIHByb2Nlc3NvclxuICAgICAgICAgKiBAdHlwZSB7RGF0YVByb2Nlc3Nvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IHBhcmFtcy5kYXRhUHJvY2Vzc29yO1xuXG4gICAgICAgIHRoaXMuaW5pdEJvdW5kc0RhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBib3VuZHMgZGF0YS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2hhcnRPcHRpb24gY2hhcnQgb3B0aW9uXG4gICAgICovXG4gICAgaW5pdEJvdW5kc0RhdGE6IGZ1bmN0aW9uKGNoYXJ0T3B0aW9uKSB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeUF4aXM6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJpZ2h0WUF4aXM6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHhBeGlzOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2lyY2xlTGVnZW5kOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxjdWxhdGlvbkxlZ2VuZDoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSB7fTtcblxuICAgICAgICB0aGlzLmF4ZXNEYXRhID0ge307XG5cbiAgICAgICAgdGhpcy54QXhpc0RlZ3JlZSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IGxlZnQgcGFkZGluZ1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydExlZnRQYWRkaW5nID0gY2hhcnRDb25zdC5DSEFSVF9QQURESU5HO1xuXG4gICAgICAgIGlmIChjaGFydE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNoYXJ0ID0gY2hhcnRPcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWdpc3RlckNoYXJ0RGltZW5zaW9uKCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyVGl0bGVEaW1lbnNpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtkaW1lbnNpb259IGRpbWVuc2lvbiBjb21wb25lbnQgZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJEaW1lbnNpb246IGZ1bmN0aW9uKG5hbWUsIGRpbWVuc2lvbikge1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnNbbmFtZV0gPSB0dWkudXRpbC5leHRlbmQodGhpcy5kaW1lbnNpb25zW25hbWVdIHx8IHt9LCBkaW1lbnNpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBiYXNlIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb21wb25lbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7ZGltZW5zaW9ufSBkaW1lbnNpb24gY29tcG9uZW50IGRpbWVuc2lvblxuICAgICAqL1xuICAgIHJlZ2lzdGVyQmFzZURpbWVuc2lvbjogZnVuY3Rpb24obmFtZSwgZGltZW5zaW9uKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKG5hbWUsIGRpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGF4ZXMgZGF0YS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXhlc0RhdGEgYXhlcyBkYXRhXG4gICAgICovXG4gICAgcmVnaXN0ZXJBeGVzRGF0YTogZnVuY3Rpb24oYXhlc0RhdGEpIHtcbiAgICAgICAgdGhpcy5heGVzRGF0YSA9IGF4ZXNEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBeGVzIGRhdGEuXG4gICAgICogQHJldHVybnMge3t4QXhpczogb2JqZWN0LCB5QXhpczogb2JqZWN0LCByaWdodFlBeGlzOiBvYmplY3R9fVxuICAgICAqL1xuICAgIGdldEF4ZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXhlc0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBzdGVwIG9mIHBpeGVsIHVuaXQuXG4gICAgICogQHBhcmFtIHt7dGlja0NvdW50OiBudW1iZXIsIGlzTGFiZWw6IGJvb2xlYW59fSBheGlzRGF0YSAtIGRhdGEgZm9yIHJlbmRlcmluZyBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSB3aWR0aCBvciBoZWlnaHQgb2Ygc2VyaXNlIGFyZWFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVBpeGVsU3RlcDogZnVuY3Rpb24oYXhpc0RhdGEsIHNpemUpIHtcbiAgICAgICAgdmFyIHRpY2tDb3VudCA9IGF4aXNEYXRhLnRpY2tDb3VudDtcbiAgICAgICAgdmFyIHBpeGVsU3RlcDtcblxuICAgICAgICBpZiAoYXhpc0RhdGEuaXNMYWJlbCkge1xuICAgICAgICAgICAgcGl4ZWxTdGVwID0gc2l6ZSAvIHRpY2tDb3VudCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwaXhlbFN0ZXAgPSBzaXplIC8gKHRpY2tDb3VudCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBpeGVsU3RlcCwgMTApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWluaW11bSBzdGVwIG9mIHBpeGVsIHVuaXQgZm9yIGF4aXMuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRNaW5pbXVtUGl4ZWxTdGVwRm9yQXhpczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbignc2VyaWVzJyk7XG4gICAgICAgIHZhciB5UGl4ZWxTdGVwID0gdGhpcy5fY2FsY3VsYXRlUGl4ZWxTdGVwKHRoaXMuYXhlc0RhdGEueUF4aXMsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICB2YXIgeFBpeGVsU3RlcCA9IHRoaXMuX2NhbGN1bGF0ZVBpeGVsU3RlcCh0aGlzLmF4ZXNEYXRhLnhBeGlzLCBkaW1lbnNpb24ud2lkdGgpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1pbih5UGl4ZWxTdGVwLCB4UGl4ZWxTdGVwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvdW5kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHJldHVybnMge2JvdW5kfSBjb21wb25lbnQgYm91bmRcbiAgICAgKi9cbiAgICBnZXRCb3VuZDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGltZW5zaW9uOiB0aGlzLmRpbWVuc2lvbnNbbmFtZV0gfHwge30sXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbnNbbmFtZV0gfHwge31cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGJvdW5kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtib3VuZH0gYm91bmQgY29tcG9uZW50IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0Qm91bmQ6IGZ1bmN0aW9uKG5hbWUsIGJvdW5kKSB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uc1tuYW1lXSA9IGJvdW5kLmRpbWVuc2lvbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnNbbmFtZV0gPSBib3VuZC5wb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb21wb25lbnQgbmFtZVxuICAgICAqIEByZXR1cm5zIHtkaW1lbnNpb259IGNvbXBvbmVudCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBnZXREaW1lbnNpb246IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uc1tuYW1lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHJldHVybnMge3Bvc2l0aW9ufSBjb21wb25lbnQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnNbbmFtZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ2lzdGVyQ2hhcnREaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhcnRPcHRpb25zID0gdGhpcy5vcHRpb25zLmNoYXJ0IHx8IHt9LFxuICAgICAgICAgICAgZGltZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBjaGFydE9wdGlvbnMud2lkdGggfHwgY2hhcnRDb25zdC5DSEFSVF9ERUZBVUxUX1dJRFRILFxuICAgICAgICAgICAgICAgIGhlaWdodDogY2hhcnRPcHRpb25zLmhlaWdodCB8fCBjaGFydENvbnN0LkNIQVJUX0RFRkFVTFRfSEVJR0hUXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKCdjaGFydCcsIGRpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHRpdGxlIGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ2lzdGVyVGl0bGVEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhcnRPcHRpb25zID0gdGhpcy5vcHRpb25zLmNoYXJ0IHx8IHt9LFxuICAgICAgICAgICAgdGl0bGVIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQoY2hhcnRPcHRpb25zLnRpdGxlLCB0aGlzLnRoZW1lLnRpdGxlKSxcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRpdGxlSGVpZ2h0ICsgY2hhcnRDb25zdC5USVRMRV9QQURESU5HXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKCd0aXRsZScsIGRpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBsaW1pdCB3aWR0aCBvZiB4IGF4aXMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gbGltaXQgd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVYQXhpc0xhYmVsTGltaXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNXaWR0aCA9IHRoaXMuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKS53aWR0aCxcbiAgICAgICAgICAgIGxhYmVsQ291bnQgPSB0aGlzLmF4ZXNEYXRhLnhBeGlzLmxhYmVscy5sZW5ndGgsXG4gICAgICAgICAgICBpc0FsaWduID0gcHJlZGljYXRlLmlzTGluZVR5cGVDaGFydCh0aGlzLmNoYXJ0VHlwZSk7XG4gICAgICAgIHJldHVybiBzZXJpZXNXaWR0aCAvIChpc0FsaWduID8gbGFiZWxDb3VudCAtIDEgOiBsYWJlbENvdW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCByb3RhdGlvbiBkZWdyZWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0V2lkdGggbGltaXQgd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxXaWR0aCBsYWJlbCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggY2FuZGlkYXRlcyBpbmRleFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHJvdGF0aW9uIGRlZ3JlZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRSb3RhdGlvbkRlZ3JlZTogZnVuY3Rpb24obGltaXRXaWR0aCwgbGFiZWxXaWR0aCwgbGFiZWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIGZvdW5kRGVncmVlLFxuICAgICAgICAgICAgaGFsZldpZHRoID0gbGFiZWxXaWR0aCAvIDIsXG4gICAgICAgICAgICBoYWxmSGVpZ2h0ID0gbGFiZWxIZWlnaHQgLyAyO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjaGFydENvbnN0LkRFR1JFRV9DQU5ESURBVEVTLCBmdW5jdGlvbihkZWdyZWUpIHtcbiAgICAgICAgICAgIHZhciBjb21wYXJlV2lkdGggPSAoY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudChkZWdyZWUsIGhhbGZXaWR0aCkgK1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0b3IuY2FsY3VsYXRlQWRqYWNlbnQoY2hhcnRDb25zdC5BTkdMRV85MCAtIGRlZ3JlZSwgaGFsZkhlaWdodCkpICogMjtcblxuICAgICAgICAgICAgZm91bmREZWdyZWUgPSBkZWdyZWU7XG4gICAgICAgICAgICBpZiAoY29tcGFyZVdpZHRoIDw9IGxpbWl0V2lkdGggKyBjaGFydENvbnN0LlhBWElTX0xBQkVMX0NPTVBBUkVfTUFSR0lOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kRGVncmVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJvdGF0aW9uIGluZm8gYWJvdXQgaG9yaXpvbnRhbCBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXRXaWR0aCBsaW1pdCB3aWR0aFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVscyBheGlzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBheGlzIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMgez9vYmplY3R9IHJvdGF0aW9uIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbExhYmVsUm90YXRpb25JbmZvOiBmdW5jdGlvbihsaW1pdFdpZHRoKSB7XG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmF4ZXNEYXRhLnhBeGlzLmxhYmVscyxcbiAgICAgICAgICAgIHRoZW1lID0gdGhpcy50aGVtZS54QXhpcy5sYWJlbCxcbiAgICAgICAgICAgIG1heExhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxzTWF4V2lkdGgobGFiZWxzLCB0aGVtZSksXG4gICAgICAgICAgICBkZWdyZWUsIGxhYmVsSGVpZ2h0O1xuXG4gICAgICAgIGlmIChtYXhMYWJlbFdpZHRoIDw9IGxpbWl0V2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxzTWF4SGVpZ2h0KGxhYmVscywgdGhlbWUpO1xuICAgICAgICBkZWdyZWUgPSB0aGlzLl9maW5kUm90YXRpb25EZWdyZWUobGltaXRXaWR0aCwgbWF4TGFiZWxXaWR0aCwgbGFiZWxIZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXhMYWJlbFdpZHRoOiBtYXhMYWJlbFdpZHRoLFxuICAgICAgICAgICAgbGFiZWxIZWlnaHQ6IGxhYmVsSGVpZ2h0LFxuICAgICAgICAgICAgZGVncmVlOiBkZWdyZWVcbiAgICAgICAgfTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgb3ZlcmZsb3cgcG9zaXRpb24gbGVmdC5cbiAgICAgKiBAcGFyYW0ge3tkZWdyZWU6IG51bWJlciwgbGFiZWxIZWlnaHQ6IG51bWJlcn19IHJvdGF0aW9uSW5mbyByb3RhdGlvbiBpbmZvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpcnN0TGFiZWwgZmlyc3RMYWJlbFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG92ZXJmbG93IHBvc2l0aW9uIGxlZnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVPdmVyZmxvd0xlZnQ6IGZ1bmN0aW9uKHJvdGF0aW9uSW5mbywgZmlyc3RMYWJlbCkge1xuICAgICAgICB2YXIgZGVncmVlID0gcm90YXRpb25JbmZvLmRlZ3JlZSxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcm90YXRpb25JbmZvLmxhYmVsSGVpZ2h0LFxuICAgICAgICAgICAgZmlyc3RMYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgoZmlyc3RMYWJlbCwgdGhpcy50aGVtZS54QXhpcy5sYWJlbCksXG4gICAgICAgICAgICBuZXdMYWJlbFdpZHRoID0gKGNhbGN1bGF0b3IuY2FsY3VsYXRlQWRqYWNlbnQoZGVncmVlLCBmaXJzdExhYmVsV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICsgY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudChjaGFydENvbnN0LkFOR0xFXzkwIC0gZGVncmVlLCBsYWJlbEhlaWdodCAvIDIpKSAqIDIsXG4gICAgICAgICAgICB5QXhpc1dpZHRoID0gdGhpcy5vcHRpb25zLnlBeGlzLmlzQ2VudGVyID8gMCA6IHRoaXMuZ2V0RGltZW5zaW9uKCd5QXhpcycpLndpZHRoLFxuICAgICAgICAgICAgZGlmZkxlZnQgPSBuZXdMYWJlbFdpZHRoIC0geUF4aXNXaWR0aDtcbiAgICAgICAgcmV0dXJuIGRpZmZMZWZ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgd2lkdGggb2YgZGltZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ZlcmZsb3dMZWZ0IG92ZXJmbG93IGxlZnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVEaW1lbnNpb25zV2lkdGg6IGZ1bmN0aW9uKG92ZXJmbG93TGVmdCkge1xuICAgICAgICBpZiAob3ZlcmZsb3dMZWZ0ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFydExlZnRQYWRkaW5nICs9IG92ZXJmbG93TGVmdDtcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucy5wbG90LndpZHRoIC09IG92ZXJmbG93TGVmdDtcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucy5zZXJpZXMud2lkdGggLT0gb3ZlcmZsb3dMZWZ0O1xuICAgICAgICAgICAgdGhpcy5kaW1lbnNpb25zLmN1c3RvbUV2ZW50LndpZHRoIC09IG92ZXJmbG93TGVmdDtcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucy54QXhpcy53aWR0aCAtPSBvdmVyZmxvd0xlZnQ7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5zZXJpZXMubGVmdCArPSBvdmVyZmxvd0xlZnQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGRlZ3JlZSBvZiByb3RhdGlvbkluZm8uXG4gICAgICogQHBhcmFtIHt7ZGVncmVlOiBudW1iZXIsIG1heExhYmVsV2lkdGg6IG51bWJlciwgbGFiZWxIZWlnaHQ6IG51bWJlcn19IHJvdGF0aW9uSW5mbyByb3RhdGlvbiBpbmZvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsTGVuZ3RoIGxhYmVsTGVuZ3RoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG92ZXJmbG93TGVmdCBvdmVyZmxvdyBsZWZ0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlRGVncmVlOiBmdW5jdGlvbihyb3RhdGlvbkluZm8sIGxhYmVsTGVuZ3RoLCBvdmVyZmxvd0xlZnQpIHtcbiAgICAgICAgdmFyIGxpbWl0V2lkdGgsIG5ld0RlZ3JlZTtcbiAgICAgICAgaWYgKG92ZXJmbG93TGVmdCA+IDApIHtcbiAgICAgICAgICAgIGxpbWl0V2lkdGggPSB0aGlzLmdldERpbWVuc2lvbignc2VyaWVzJykud2lkdGggLyBsYWJlbExlbmd0aCArIGNoYXJ0Q29uc3QuWEFYSVNfTEFCRUxfR1VUVEVSO1xuICAgICAgICAgICAgbmV3RGVncmVlID0gdGhpcy5fZmluZFJvdGF0aW9uRGVncmVlKGxpbWl0V2lkdGgsIHJvdGF0aW9uSW5mby5tYXhMYWJlbFdpZHRoLCByb3RhdGlvbkluZm8ubGFiZWxIZWlnaHQpO1xuICAgICAgICAgICAgcm90YXRpb25JbmZvLmRlZ3JlZSA9IG5ld0RlZ3JlZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgcm90YXRlZCBoZWlnaHQgb2YgeEF4aXMuXG4gICAgICogQHBhcmFtIHt7ZGVncmVlOiBudW1iZXIsIG1heExhYmVsV2lkdGg6IG51bWJlciwgbGFiZWxIZWlnaHQ6IG51bWJlcn19IHJvdGF0aW9uSW5mbyByb3RhdGlvbiBpbmZvXG4gICAgICogQHJldHVybnMge251bWJlcn0geEF4aXMgaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlWEF4aXNSb3RhdGVkSGVpZ2h0OiBmdW5jdGlvbihyb3RhdGlvbkluZm8pIHtcbiAgICAgICAgdmFyIGRlZ3JlZSA9IHJvdGF0aW9uSW5mby5kZWdyZWUsXG4gICAgICAgICAgICBtYXhMYWJlbFdpZHRoID0gcm90YXRpb25JbmZvLm1heExhYmVsV2lkdGgsXG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IHJvdGF0aW9uSW5mby5sYWJlbEhlaWdodCxcbiAgICAgICAgICAgIGF4aXNIZWlnaHQgPSAoY2FsY3VsYXRvci5jYWxjdWxhdGVPcHBvc2l0ZShkZWdyZWUsIG1heExhYmVsV2lkdGggLyAyKSArXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRvci5jYWxjdWxhdGVPcHBvc2l0ZShjaGFydENvbnN0LkFOR0xFXzkwIC0gZGVncmVlLCBsYWJlbEhlaWdodCAvIDIpKSAqIDI7XG5cbiAgICAgICAgcmV0dXJuIGF4aXNIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBoZWlnaHQgZGlmZmVyZW5jZSBiZXR3ZWVuIG9yaWdpbiBjYXRlZ29yeSBhbmQgcm90YXRpb24gY2F0ZWdvcnkuXG4gICAgICogQHBhcmFtIHt7ZGVncmVlOiBudW1iZXIsIG1heExhYmVsV2lkdGg6IG51bWJlciwgbGFiZWxIZWlnaHQ6IG51bWJlcn19IHJvdGF0aW9uSW5mbyByb3RhdGlvbiBpbmZvXG4gICAgICogQHJldHVybnMge251bWJlcn0gaGVpZ2h0IGRpZmZlcmVuY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVEaWZmV2l0aFJvdGF0ZWRIZWlnaHQ6IGZ1bmN0aW9uKHJvdGF0aW9uSW5mbykge1xuICAgICAgICB2YXIgcm90YXRlZEhlaWdodCA9IHRoaXMuX2NhbGN1bGF0ZVhBeGlzUm90YXRlZEhlaWdodChyb3RhdGlvbkluZm8pO1xuICAgICAgICByZXR1cm4gcm90YXRlZEhlaWdodCAtIHJvdGF0aW9uSW5mby5sYWJlbEhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGhlaWdodCBkaWZmZXJlbmNlIGJldHdlZW4gb3JpZ2luIGNhdGVnb3J5IGFuZCBtdWx0aWxpbmUgY2F0ZWdvcnkuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFdpZHRoIGxpbWl0IHdpZHRoXG4gICAgICogQHJldHVybnMge251bWJlcn0gY2FsY3VsYXRlZCBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVEaWZmV2l0aE11bHRpbGluZUhlaWdodDogZnVuY3Rpb24obGFiZWxzLCBsaW1pdFdpZHRoKSB7XG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudGhlbWUueEF4aXMubGFiZWwsXG4gICAgICAgICAgICBtdWx0aWxpbmVMYWJlbHMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0TXVsdGlsaW5lQ2F0ZWdvcmllcyhsaW1pdFdpZHRoLCB0aGVtZSwgdGhpcy5heGVzRGF0YS54QXhpcy5sYWJlbHMpLFxuICAgICAgICAgICAgbm9ybWFsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsc01heEhlaWdodChsYWJlbHMsIHRoZW1lKSxcbiAgICAgICAgICAgIG11bHRpbGluZUhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhIZWlnaHQobXVsdGlsaW5lTGFiZWxzLCB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGNzc1RleHQ6ICdsaW5lLWhlaWdodDoxLjI7d2lkdGg6JyArIGxpbWl0V2lkdGggKyAncHgnXG4gICAgICAgICAgICB9LCB0aGVtZSkpO1xuXG4gICAgICAgIHJldHVybiBtdWx0aWxpbmVIZWlnaHQgLSBub3JtYWxIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBoZWlnaHQgb2YgZGltZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlmZkhlaWdodCBkaWZmIGhlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZURpbWVuc2lvbnNIZWlnaHQ6IGZ1bmN0aW9uKGRpZmZIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLnBsb3QuaGVpZ2h0IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5zZXJpZXMuaGVpZ2h0IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5jdXN0b21FdmVudC5oZWlnaHQgLT0gZGlmZkhlaWdodDtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLnRvb2x0aXAuaGVpZ2h0IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy55QXhpcy5oZWlnaHQgLT0gZGlmZkhlaWdodDtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLnJpZ2h0WUF4aXMuaGVpZ2h0IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy54QXhpcy5oZWlnaHQgKz0gZGlmZkhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGRpbWVuc2lvbnMgYW5kIGRlZ3JlZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVEaW1lbnNpb25zQW5kRGVncmVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHhBeGlzT3B0aW9ucyA9IHRoaXMub3B0aW9ucy54QXhpcyB8fCB7fSxcbiAgICAgICAgICAgIGxpbWl0V2lkdGggPSB0aGlzLl9jYWxjdWxhdGVYQXhpc0xhYmVsTGltaXRXaWR0aCgpLFxuICAgICAgICAgICAgbGFiZWxzID0gdGhpcy5heGVzRGF0YS54QXhpcy5sYWJlbHMsXG4gICAgICAgICAgICByb3RhdGlvbkluZm8sIG92ZXJmbG93TGVmdCwgZGlmZkhlaWdodDtcblxuICAgICAgICBpZiAoeEF4aXNPcHRpb25zLnJvdGF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcm90YXRpb25JbmZvID0gdGhpcy5fbWFrZUhvcml6b250YWxMYWJlbFJvdGF0aW9uSW5mbyhsaW1pdFdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3RhdGlvbkluZm8pIHtcbiAgICAgICAgICAgIG92ZXJmbG93TGVmdCA9IHRoaXMuX2NhbGN1bGF0ZU92ZXJmbG93TGVmdChyb3RhdGlvbkluZm8sIGxhYmVsc1swXSk7XG4gICAgICAgICAgICB0aGlzLnhBeGlzRGVncmVlID0gcm90YXRpb25JbmZvLmRlZ3JlZTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnNXaWR0aChvdmVyZmxvd0xlZnQpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGVncmVlKHJvdGF0aW9uSW5mbywgbGFiZWxzLmxlbmd0aCwgb3ZlcmZsb3dMZWZ0KTtcbiAgICAgICAgICAgIGRpZmZIZWlnaHQgPSB0aGlzLl9jYWxjdWxhdGVEaWZmV2l0aFJvdGF0ZWRIZWlnaHQocm90YXRpb25JbmZvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZmZIZWlnaHQgPSB0aGlzLl9jYWxjdWxhdGVEaWZmV2l0aE11bHRpbGluZUhlaWdodChsYWJlbHMsIGxpbWl0V2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uc0hlaWdodChkaWZmSGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwbG90IGRpbWVudGlvblxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwbG90IGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQbG90RGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc0RpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBzZXJpZXNEaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNlcmllc0RpbWVuc2lvbi5oZWlnaHQgKyBjaGFydENvbnN0Lk9WRVJMQVBQSU5HX1dJRFRIXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGF4aXMgY29tcG9uZW50cyBkaW1lbnNpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJBeGlzQ29tcG9uZW50c0RpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwbG90RGltZW5zaW9uID0gdGhpcy5fbWFrZVBsb3REaW1lbnNpb24oKTtcblxuICAgICAgICB0aGlzLl9yZWdpc3RlckRpbWVuc2lvbigncGxvdCcsIHBsb3REaW1lbnNpb24pO1xuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKCd4QXhpcycsIHtcbiAgICAgICAgICAgIHdpZHRoOiBwbG90RGltZW5zaW9uLndpZHRoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKCd5QXhpcycsIHtcbiAgICAgICAgICAgIGhlaWdodDogcGxvdERpbWVuc2lvbi5oZWlnaHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEaW1lbnNpb24oJ3JpZ2h0WUF4aXMnLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IHBsb3REaW1lbnNpb24uaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllcyB3aWR0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzZXJpZXMgd2lkdGhcbiAgICAgKi9cbiAgICBtYWtlU2VyaWVzV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhcnRXaWR0aCA9IHRoaXMuZ2V0RGltZW5zaW9uKCdjaGFydCcpLndpZHRoO1xuICAgICAgICB2YXIgeUF4aXNXaWR0aCA9IHRoaXMuZ2V0RGltZW5zaW9uKCd5QXhpcycpLndpZHRoO1xuICAgICAgICB2YXIgbGVnZW5kRGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb24oJ2NhbGN1bGF0aW9uTGVnZW5kJyk7XG4gICAgICAgIHZhciBsZWdlbmRXaWR0aCwgcmlnaHRBcmVhV2lkdGg7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0hvcml6b250YWxMZWdlbmQodGhpcy5vcHRpb25zLmxlZ2VuZC5hbGlnbikpIHtcbiAgICAgICAgICAgIGxlZ2VuZFdpZHRoID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZ2VuZFdpZHRoID0gbGVnZW5kRGltZW5zaW9uID8gbGVnZW5kRGltZW5zaW9uLndpZHRoIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJpZ2h0QXJlYVdpZHRoID0gbGVnZW5kV2lkdGggKyB0aGlzLmdldERpbWVuc2lvbigncmlnaHRZQXhpcycpLndpZHRoO1xuXG4gICAgICAgIHJldHVybiBjaGFydFdpZHRoIC0gKGNoYXJ0Q29uc3QuQ0hBUlRfUEFERElORyAqIDIpIC0geUF4aXNXaWR0aCAtIHJpZ2h0QXJlYVdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllcyBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzZXJpZXMgaGVpZ2h0XG4gICAgICovXG4gICAgbWFrZVNlcmllc0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFydEhlaWdodCA9IHRoaXMuZ2V0RGltZW5zaW9uKCdjaGFydCcpLmhlaWdodCxcbiAgICAgICAgICAgIHRpdGxlSGVpZ2h0ID0gdGhpcy5nZXREaW1lbnNpb24oJ3RpdGxlJykuaGVpZ2h0LFxuICAgICAgICAgICAgbGVnZW5kSGVpZ2h0LCBib3R0b21BcmVhV2lkdGg7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0hvcml6b250YWxMZWdlbmQodGhpcy5vcHRpb25zLmxlZ2VuZC5hbGlnbikpIHtcbiAgICAgICAgICAgIGxlZ2VuZEhlaWdodCA9IHRoaXMuZ2V0RGltZW5zaW9uKCdsZWdlbmQnKS5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWdlbmRIZWlnaHQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgYm90dG9tQXJlYVdpZHRoID0gbGVnZW5kSGVpZ2h0ICsgdGhpcy5kaW1lbnNpb25zLnhBeGlzLmhlaWdodDtcblxuICAgICAgICByZXR1cm4gY2hhcnRIZWlnaHQgLSAoY2hhcnRDb25zdC5DSEFSVF9QQURESU5HICogMikgLSB0aXRsZUhlaWdodCAtIGJvdHRvbUFyZWFXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGltZW5zaW9uLlxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBzZXJpZXMgZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc0RpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5tYWtlU2VyaWVzV2lkdGgoKSxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5tYWtlU2VyaWVzSGVpZ2h0KClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgY2VudGVyIGNvbXBvbmV0cyBkaW1lbnNpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJDZW50ZXJDb21wb25lbnRzRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc0RpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKTtcblxuICAgICAgICB0aGlzLl9yZWdpc3RlckRpbWVuc2lvbigndG9vbHRpcCcsIHNlcmllc0RpbWVuc2lvbik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKCdjdXN0b21FdmVudCcsIHNlcmllc0RpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGF4ZXMgdHlwZSBjb21wb25lbnQgcG9zaXRpb25zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0TGVnZW5kV2lkdGggbGVnZW5kIHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJBeGlzQ29tcG9uZW50c1Bvc2l0aW9uOiBmdW5jdGlvbihsZWZ0TGVnZW5kV2lkdGgpIHtcbiAgICAgICAgdmFyIHNlcmllc1Bvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbignc2VyaWVzJyksXG4gICAgICAgICAgICBzZXJpZXNEaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbignc2VyaWVzJyksXG4gICAgICAgICAgICB5QXhpc1dpZHRoID0gdGhpcy5nZXREaW1lbnNpb24oJ3lBeGlzJykud2lkdGgsXG4gICAgICAgICAgICBsZWZ0QXJlYVdpZHRoID0geUF4aXNXaWR0aCArIHNlcmllc0RpbWVuc2lvbi53aWR0aCArIGxlZnRMZWdlbmRXaWR0aDtcblxuICAgICAgICB0aGlzLnBvc2l0aW9ucy5wbG90ID0ge1xuICAgICAgICAgICAgdG9wOiBzZXJpZXNQb3NpdGlvbi50b3AsXG4gICAgICAgICAgICBsZWZ0OiBzZXJpZXNQb3NpdGlvbi5sZWZ0XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMueUF4aXMgPSB7XG4gICAgICAgICAgICB0b3A6IHNlcmllc1Bvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMuY2hhcnRMZWZ0UGFkZGluZyArIGxlZnRMZWdlbmRXaWR0aFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25zLnhBeGlzID0ge1xuICAgICAgICAgICAgdG9wOiBzZXJpZXNQb3NpdGlvbi50b3AgKyBzZXJpZXNEaW1lbnNpb24uaGVpZ2h0LFxuICAgICAgICAgICAgbGVmdDogc2VyaWVzUG9zaXRpb24ubGVmdFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25zLnJpZ2h0WUF4aXMgPSB7XG4gICAgICAgICAgICB0b3A6IHNlcmllc1Bvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMuY2hhcnRMZWZ0UGFkZGluZyArIGxlZnRBcmVhV2lkdGggLSBjaGFydENvbnN0Lk9WRVJMQVBQSU5HX1dJRFRIXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGVnZW5kIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fX0gbGVnZW5kIGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxlZ2VuZFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnMsXG4gICAgICAgICAgICBzZXJpZXNEaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbignc2VyaWVzJyksXG4gICAgICAgICAgICBsZWdlbmRPcHRpb24gPSB0aGlzLm9wdGlvbnMubGVnZW5kLFxuICAgICAgICAgICAgdG9wID0gZGltZW5zaW9ucy50aXRsZS5oZWlnaHQsXG4gICAgICAgICAgICB5QXhpc0FyZWFXaWR0aCwgbGVmdDtcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzTGVnZW5kQWxpZ25Cb3R0b20obGVnZW5kT3B0aW9uLmFsaWduKSkge1xuICAgICAgICAgICAgdG9wICs9IHNlcmllc0RpbWVuc2lvbi5oZWlnaHQgKyB0aGlzLmdldERpbWVuc2lvbigneEF4aXMnKS5oZWlnaHQgKyBjaGFydENvbnN0LkxFR0VORF9BUkVBX1BBRERJTkc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzSG9yaXpvbnRhbExlZ2VuZChsZWdlbmRPcHRpb24uYWxpZ24pKSB7XG4gICAgICAgICAgICBsZWZ0ID0gKCh0aGlzLmdldERpbWVuc2lvbignY2hhcnQnKS53aWR0aCAtIHRoaXMuZ2V0RGltZW5zaW9uKCdsZWdlbmQnKS53aWR0aCkgLyAyKVxuICAgICAgICAgICAgICAgIC0gY2hhcnRDb25zdC5MRUdFTkRfQVJFQV9QQURESU5HO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWRpY2F0ZS5pc0xlZ2VuZEFsaWduTGVmdChsZWdlbmRPcHRpb24uYWxpZ24pKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlBeGlzQXJlYVdpZHRoID0gdGhpcy5nZXREaW1lbnNpb24oJ3lBeGlzJykud2lkdGggKyB0aGlzLmdldERpbWVuc2lvbigncmlnaHRZQXhpcycpLndpZHRoO1xuICAgICAgICAgICAgbGVmdCA9IHNlcmllc0RpbWVuc2lvbi53aWR0aCArIHlBeGlzQXJlYVdpZHRoICsgdGhpcy5jaGFydExlZnRQYWRkaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIENpcmNsZUxlZ2VuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDaXJjbGVMZWdlbmRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24oJ3NlcmllcycpO1xuICAgICAgICB2YXIgc2VyaWVzRGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuICAgICAgICB2YXIgY2lyY2xlRGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb24oJ2NpcmNsZUxlZ2VuZCcpO1xuICAgICAgICB2YXIgbGVmdDtcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzTGVnZW5kQWxpZ25MZWZ0KHRoaXMub3B0aW9ucy5sZWdlbmQuYWxpZ24pKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBzZXJpZXNQb3NpdGlvbi5sZWZ0ICsgc2VyaWVzRGltZW5zaW9uLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogc2VyaWVzUG9zaXRpb24udG9wICsgc2VyaWVzRGltZW5zaW9uLmhlaWdodCAtIGNpcmNsZURpbWVuc2lvbi5oZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGVzc2VudGlhbCBjb21wb25lbnRzIHBvc2l0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlckVzc2VudGlhbENvbXBvbmVudHNQb3NpdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzUG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uKCdzZXJpZXMnKSxcbiAgICAgICAgICAgIHRvb2x0aXBQb3NpdGlvbjtcblxuICAgICAgICB0aGlzLnBvc2l0aW9ucy5jdXN0b21FdmVudCA9IHR1aS51dGlsLmV4dGVuZCh7fSwgc2VyaWVzUG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucy5sZWdlbmQgPSB0aGlzLl9tYWtlTGVnZW5kUG9zaXRpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5nZXREaW1lbnNpb24oJ2NpcmNsZUxlZ2VuZCcpLndpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5jaXJjbGVMZWdlbmQgPSB0aGlzLl9tYWtlQ2lyY2xlTGVnZW5kUG9zaXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJlZGljYXRlLmlzTW91c2VQb3NpdGlvbkNoYXJ0KHRoaXMuY2hhcnRUeXBlKSkge1xuICAgICAgICAgICAgdG9vbHRpcFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHRvcDogc2VyaWVzUG9zaXRpb24udG9wIC0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICAgICAgbGVmdDogc2VyaWVzUG9zaXRpb24ubGVmdCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9vbHRpcFBvc2l0aW9uID0gc2VyaWVzUG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvc2l0aW9ucy50b29sdGlwID0gdG9vbHRpcFBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBwb3NpdGlvbnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJQb3NpdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWxpZ25PcHRpb24gPSB0aGlzLm9wdGlvbnMubGVnZW5kLmFsaWduLFxuICAgICAgICAgICAgbGVnZW5kRGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb24oJ2xlZ2VuZCcpLFxuICAgICAgICAgICAgdG9wTGVnZW5kSGVpZ2h0ID0gcHJlZGljYXRlLmlzTGVnZW5kQWxpZ25Ub3AoYWxpZ25PcHRpb24pID8gbGVnZW5kRGltZW5zaW9uLmhlaWdodCA6IDAsXG4gICAgICAgICAgICBsZWZ0TGVnZW5kV2lkdGggPSBwcmVkaWNhdGUuaXNMZWdlbmRBbGlnbkxlZnQoYWxpZ25PcHRpb24pID8gbGVnZW5kRGltZW5zaW9uLndpZHRoIDogMCxcbiAgICAgICAgICAgIHNlcmllc1Bvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5nZXREaW1lbnNpb24oJ3RpdGxlJykuaGVpZ2h0ICsgY2hhcnRDb25zdC5DSEFSVF9QQURESU5HICsgdG9wTGVnZW5kSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuY2hhcnRMZWZ0UGFkZGluZyArIGxlZnRMZWdlbmRXaWR0aCArIHRoaXMuZ2V0RGltZW5zaW9uKCd5QXhpcycpLndpZHRoXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25zLnNlcmllcyA9IHNlcmllc1Bvc2l0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0F4ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnNBbmREZWdyZWUoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQXhpc0NvbXBvbmVudHNQb3NpdGlvbihsZWZ0TGVnZW5kV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJFc3NlbnRpYWxDb21wb25lbnRzUG9zaXRpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGJvdW5kIG9mIGV4dGVuZGVkIHNlcmllcyBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ2lzdGVyRXh0ZW5kZWRTZXJpZXNCb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IHRoaXMuZ2V0Qm91bmQoJ3NlcmllcycpO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZS5pc01vdXNlUG9zaXRpb25DaGFydCh0aGlzLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIHNlcmllc0JvdW5kID0gcmVuZGVyVXRpbC5leHBhbmRCb3VuZChzZXJpZXNCb3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRCb3VuZCgnZXh0ZW5kZWRTZXJpZXMnLCBzZXJpZXNCb3VuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBib3VuZHMocG9zaXRpb25zLCBkaW1lbnNpb25zKSBvZiBjb21wb25lbnRzIGZvciBjZW50ZXIgb3B0aW9uIG9mIHlBeGlzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUJvdW5kc0ZvcllBeGlzQ2VudGVyT3B0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHlBeGlzV2lkdGggPSB0aGlzLmdldERpbWVuc2lvbigneUF4aXMnKS53aWR0aCxcbiAgICAgICAgICAgIHlBeGlzRXh0ZW5zaWJsZUxlZnQgPSBNYXRoLmZsb29yKCh0aGlzLmdldERpbWVuc2lvbignc2VyaWVzJykud2lkdGggLyAyKSkgKyBjaGFydENvbnN0Lk9WRVJMQVBQSU5HX1dJRFRILFxuICAgICAgICAgICAgeEF4aXNEZWNyZWFzaW5nTGVmdCA9IHlBeGlzV2lkdGggLSBjaGFydENvbnN0Lk9WRVJMQVBQSU5HX1dJRFRILFxuICAgICAgICAgICAgYWRkaXRpb25hbExlZnQgPSByZW5kZXJVdGlsLmlzT2xkQnJvd3NlcigpID8gMSA6IDA7XG5cbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLmV4dGVuZGVkU2VyaWVzLndpZHRoICs9IHlBeGlzV2lkdGg7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy54QXhpcy53aWR0aCArPSBjaGFydENvbnN0Lk9WRVJMQVBQSU5HX1dJRFRIO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMucGxvdC53aWR0aCArPSB5QXhpc1dpZHRoICsgY2hhcnRDb25zdC5PVkVSTEFQUElOR19XSURUSDtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLmN1c3RvbUV2ZW50LndpZHRoICs9IHlBeGlzV2lkdGg7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy50b29sdGlwLndpZHRoICs9IHlBeGlzV2lkdGg7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMuc2VyaWVzLmxlZnQgLT0gKHlBeGlzV2lkdGggLSBhZGRpdGlvbmFsTGVmdCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25zLmV4dGVuZGVkU2VyaWVzLmxlZnQgLT0gKHhBeGlzRGVjcmVhc2luZ0xlZnQgLSBhZGRpdGlvbmFsTGVmdCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25zLnBsb3QubGVmdCAtPSB4QXhpc0RlY3JlYXNpbmdMZWZ0O1xuICAgICAgICB0aGlzLnBvc2l0aW9ucy55QXhpcy5sZWZ0ICs9IHlBeGlzRXh0ZW5zaWJsZUxlZnQ7XG4gICAgICAgIHRoaXMucG9zaXRpb25zLnhBeGlzLmxlZnQgLT0geEF4aXNEZWNyZWFzaW5nTGVmdDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMuY3VzdG9tRXZlbnQubGVmdCAtPSB4QXhpc0RlY3JlYXNpbmdMZWZ0O1xuICAgICAgICB0aGlzLnBvc2l0aW9ucy50b29sdGlwLmxlZnQgLT0geEF4aXNEZWNyZWFzaW5nTGVmdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgc2VyaWVzIGRpbWVuc2lvbi5cbiAgICAgKi9cbiAgICByZWdpc3RlclNlcmllc0RpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNEaW1lbnNpb24gPSB0aGlzLl9tYWtlU2VyaWVzRGltZW5zaW9uKCk7XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEaW1lbnNpb24oJ3NlcmllcycsIHNlcmllc0RpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGJvdW5kcyBkYXRhLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyQm91bmRzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQ2VudGVyQ29tcG9uZW50c0RpbWVuc2lvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0F4ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQXhpc0NvbXBvbmVudHNEaW1lbnNpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyUG9zaXRpb25zKCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRXh0ZW5kZWRTZXJpZXNCb3VuZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMueUF4aXMuaXNDZW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kc0ZvcllBeGlzQ2VudGVyT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZHNNYWtlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBjYWxjdWxhdG9yLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBuby1tYWdpYy1udW1iZXJzOiBbMSwge2lnbm9yZTogWy0xLCAwLCAxLCAyLCAxMCwgMjAsIDYsIDAuMV19XSovXG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxuLyoqXG4gKiBDYWxjdWxhdG9yLlxuICogQG1vZHVsZSBjYWxjdWxhdG9yXG4gKi9cbnZhciBjYWxjdWxhdG9yID0ge1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBsaW1pdCBmcm9tIGNoYXJ0IG1pbiwgbWF4IGRhdGEuXG4gICAgICogIC0gaHR0cDovL3BlbHRpZXJ0ZWNoLmNvbS9ob3ctZXhjZWwtY2FsY3VsYXRlcy1hdXRvbWF0aWMtY2hhcnQtYXhpcy1saW1pdHMvXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpjYWxjdWxhdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBtaW4gbWluaW11bSB2YWx1ZSBvZiB1c2VyIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IG1heCBtYXhpbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqIEByZXR1cm5zIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgYXhpcyBsaW1pdFxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUxpbWl0OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgICB2YXIgc2F2ZU1pbiA9IDAsXG4gICAgICAgICAgICBsaW1pdCA9IHt9LFxuICAgICAgICAgICAgaW9kVmFsdWU7IC8vIGluY3JlYXNlIG9yIGRlY3JlYXNlIHZhbHVlO1xuXG4gICAgICAgIGlmIChtaW4gPCAwKSB7XG4gICAgICAgICAgICBzYXZlTWluID0gbWluO1xuICAgICAgICAgICAgbWF4IC09IG1pbjtcbiAgICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpb2RWYWx1ZSA9IChtYXggLSBtaW4pIC8gMjA7XG4gICAgICAgIGxpbWl0Lm1heCA9IG1heCArIGlvZFZhbHVlICsgc2F2ZU1pbjtcblxuICAgICAgICBpZiAobWF4IC8gNiA+IG1pbikge1xuICAgICAgICAgICAgbGltaXQubWluID0gMCArIHNhdmVNaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW1pdC5taW4gPSBtaW4gLSBpb2RWYWx1ZSArIHNhdmVNaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbWl0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgbnVtYmVyLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Y2FsY3VsYXRvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBub3JtYWxpemVkIG51bWJlclxuICAgICAqL1xuICAgIG5vcm1hbGl6ZUF4aXNOdW1iZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzdGFuZGFyZCA9IDAsXG4gICAgICAgICAgICBmbGFnID0gMSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQsIG1vZDtcblxuICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIGZsYWcgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlICo9IGZsYWc7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0Q29uc3QuQVhJU19TVEFOREFSRF9NVUxUSVBMRV9OVU1TLCBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IG51bSkge1xuICAgICAgICAgICAgICAgIGlmIChudW0gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYXJkID0gbnVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gY2hhcnRDb25zdC5BWElTX0xBU1RfU1RBTkRBUkRfTVVMVElQTEVfTlVNKSB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmQgPSBudW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3RhbmRhcmQgPCAxKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemVBeGlzTnVtYmVyKHZhbHVlICogMTApICogMC4xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kID0gdHVpLnV0aWwubW9kKHZhbHVlLCBzdGFuZGFyZCk7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdHVpLnV0aWwuYWRkaXRpb24odmFsdWUsIChtb2QgPiAwID8gc3RhbmRhcmQgLSBtb2QgOiAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkICo9IGZsYWc7XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdGljayBwb3NpdGlvbnMgb2YgcGl4ZWwgdHlwZS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmNhbGN1bGF0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBhcmVhIHdpZHRoIG9yIGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBhZGRpdGlvbmFsUG9zaXRpb24gYWRkaXRpb25hbCBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gcG9zaXRpb25zXG4gICAgICovXG4gICAgbWFrZVRpY2tQaXhlbFBvc2l0aW9uczogZnVuY3Rpb24oc2l6ZSwgY291bnQsIGFkZGl0aW9uYWxQb3NpdGlvbikge1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gW10sXG4gICAgICAgICAgICBweExpbWl0LCBweFN0ZXA7XG5cbiAgICAgICAgYWRkaXRpb25hbFBvc2l0aW9uID0gYWRkaXRpb25hbFBvc2l0aW9uIHx8IDA7XG5cbiAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgcHhMaW1pdCA9IHttaW46IDAsIG1heDogc2l6ZSAtIDF9O1xuICAgICAgICAgICAgcHhTdGVwID0gdGhpcy5jYWxjdWxhdGVTdGVwRnJvbUxpbWl0KHB4TGltaXQsIGNvdW50KTtcbiAgICAgICAgICAgIHBvc2l0aW9ucyA9IHR1aS51dGlsLm1hcCh0dWkudXRpbC5yYW5nZSgwLCBzaXplLCBweFN0ZXApLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBvc2l0aW9uICsgYWRkaXRpb25hbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSA9IE1hdGgucm91bmQoc2l6ZSAtIDEgKyBhZGRpdGlvbmFsUG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsYWJlbHMgZnJvbSBsaW1pdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmNhbGN1bGF0b3JcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBheGlzIGxpbWl0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgc3RlcCBiZXR3ZWVuIG1heCBhbmQgbWluXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBsYWJlbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1ha2VMYWJlbHNGcm9tTGltaXQ6IGZ1bmN0aW9uKGxpbWl0LCBzdGVwKSB7XG4gICAgICAgIHZhciBtdWx0aXBsZU51bSA9IHR1aS51dGlsLmZpbmRNdWx0aXBsZU51bShzdGVwKSxcbiAgICAgICAgICAgIG1pbiA9IGxpbWl0Lm1pbiAqIG11bHRpcGxlTnVtLFxuICAgICAgICAgICAgbWF4ID0gbGltaXQubWF4ICogbXVsdGlwbGVOdW0sXG4gICAgICAgICAgICBsYWJlbHMgPSB0dWkudXRpbC5yYW5nZShtaW4sIG1heCArIDEsIHN0ZXAgKiBtdWx0aXBsZU51bSk7XG4gICAgICAgIGxhYmVscyA9IHR1aS51dGlsLm1hcChsYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWwgLyBtdWx0aXBsZU51bTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBzdGVwIGZyb20gbGltaXQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpjYWxjdWxhdG9yXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgYXhpcyBsaW1pdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCB2YWx1ZSBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHN0ZXBcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVTdGVwRnJvbUxpbWl0OiBmdW5jdGlvbihsaW1pdCwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIChsaW1pdC5tYXggLSBsaW1pdC5taW4pIC8gKGNvdW50IC0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhZGphY2VudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlIGRlZ3JlZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoeXBvdGVudXNlIGh5cG90ZW51c2VcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBhZGphY2VudFxuICAgICAqXG4gICAgICogICBIIDogSHlwb3RlbnVzZVxuICAgICAqICAgQSA6IEFkamFjZW50XG4gICAgICogICBPIDogT3Bwb3NpdGVcbiAgICAgKiAgIEQgOiBEZWdyZWVcbiAgICAgKlxuICAgICAqICAgICAgICAvfFxuICAgICAqICAgICAgIC8gfFxuICAgICAqICAgIEggLyAgfCBPXG4gICAgICogICAgIC8gICB8XG4gICAgICogICAgL1xcIEQgfFxuICAgICAqICAgIC0tLS0tXG4gICAgICogICAgICAgQVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUFkamFjZW50OiBmdW5jdGlvbihkZWdyZWUsIGh5cG90ZW51c2UpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY29zKGRlZ3JlZSAqIGNoYXJ0Q29uc3QuUkFEKSAqIGh5cG90ZW51c2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBvcHBvc2l0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlIGRlZ3JlZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoeXBvdGVudXNlIGh5cG90ZW51c2VcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBvcHBvc2l0ZVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZU9wcG9zaXRlOiBmdW5jdGlvbihkZWdyZWUsIGh5cG90ZW51c2UpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKGRlZ3JlZSAqIGNoYXJ0Q29uc3QuUkFEKSAqIGh5cG90ZW51c2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1bSBwbHVzIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgdmFsdWVzXG4gICAgICogQHJldHVybnMge251bWJlcn0gc3VtXG4gICAgICovXG4gICAgc3VtUGx1c1ZhbHVlczogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIHZhciBwbHVzVmFsdWVzID0gdHVpLnV0aWwuZmlsdGVyKHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IDA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwuc3VtKHBsdXNWYWx1ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdW0gbWludXMgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlcyB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzdW1cbiAgICAgKi9cbiAgICBzdW1NaW51c1ZhbHVlczogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIHZhciBtaW51c1ZhbHVlcyA9IHR1aS51dGlsLmZpbHRlcih2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLnN1bShtaW51c1ZhbHVlcyk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjYWxjdWxhdG9yO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxpdHkgbWV0aG9kcyB0byBtYW5pcHVsYXRlIGNvbG9yc1xuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogWzEsIHtpZ25vcmU6IFstMSwgMCwgMSwgMiwgNCwgMTZdfV0qL1xuXG52YXIgaGV4UlggPSAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2k7XG5cbi8qKlxuICogQ29sb3IgbWFwLlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTczMDUzL2phdmFzY3JpcHQtZnVuY3Rpb24tdG8tY29udmVydC1jb2xvci1uYW1lcy10by1oZXgtY29kZXNcbiAqIGh0dHA6Ly93d3cudzNzY2hvb2xzLmNvbS9IVE1ML2h0bWxfY29sb3JuYW1lcy5hc3BcbiAqIEB0eXBlIHtvYmplY3R9XG4gKi9cbnZhciBjb2xvck1hcCA9IHtcbiAgICAnYWxpY2VibHVlJzogJyNmMGY4ZmYnLFxuICAgICdhbnRpcXVld2hpdGUnOiAnI2ZhZWJkNycsXG4gICAgJ2FxdWEnOiAnIzAwZmZmZicsXG4gICAgJ2FxdWFtYXJpbmUnOiAnIzdmZmZkNCcsXG4gICAgJ2F6dXJlJzogJyNmMGZmZmYnLFxuICAgICdiZWlnZSc6ICcjZjVmNWRjJyxcbiAgICAnYmlzcXVlJzogJyNmZmU0YzQnLFxuICAgICdibGFjayc6ICcjMDAwMDAwJyxcbiAgICAnYmxhbmNoZWRhbG1vbmQnOiAnI2ZmZWJjZCcsXG4gICAgJ2JsdWUnOiAnIzAwMDBmZicsXG4gICAgJ2JsdWV2aW9sZXQnOiAnIzhhMmJlMicsXG4gICAgJ2Jyb3duJzogJyNhNTJhMmEnLFxuICAgICdidXJseXdvb2QnOiAnI2RlYjg4NycsXG4gICAgJ2NhZGV0Ymx1ZSc6ICcjNWY5ZWEwJyxcbiAgICAnY2hhcnRyZXVzZSc6ICcjN2ZmZjAwJyxcbiAgICAnY2hvY29sYXRlJzogJyNkMjY5MWUnLFxuICAgICdjb3JhbCc6ICcjZmY3ZjUwJyxcbiAgICAnY29ybmZsb3dlcmJsdWUnOiAnIzY0OTVlZCcsXG4gICAgJ2Nvcm5zaWxrJzogJyNmZmY4ZGMnLFxuICAgICdjcmltc29uJzogJyNkYzE0M2MnLFxuICAgICdjeWFuJzogJyMwMGZmZmYnLFxuICAgICdkYXJrYmx1ZSc6ICcjMDAwMDhiJyxcbiAgICAnZGFya2N5YW4nOiAnIzAwOGI4YicsXG4gICAgJ2Rhcmtnb2xkZW5yb2QnOiAnI2I4ODYwYicsXG4gICAgJ2RhcmtncmF5JzogJyNhOWE5YTknLFxuICAgICdkYXJrZ3JlZW4nOiAnIzAwNjQwMCcsXG4gICAgJ2RhcmtraGFraSc6ICcjYmRiNzZiJyxcbiAgICAnZGFya21hZ2VudGEnOiAnIzhiMDA4YicsXG4gICAgJ2RhcmtvbGl2ZWdyZWVuJzogJyM1NTZiMmYnLFxuICAgICdkYXJrb3JhbmdlJzogJyNmZjhjMDAnLFxuICAgICdkYXJrb3JjaGlkJzogJyM5OTMyY2MnLFxuICAgICdkYXJrcmVkJzogJyM4YjAwMDAnLFxuICAgICdkYXJrc2FsbW9uJzogJyNlOTk2N2EnLFxuICAgICdkYXJrc2VhZ3JlZW4nOiAnIzhmYmM4ZicsXG4gICAgJ2RhcmtzbGF0ZWJsdWUnOiAnIzQ4M2Q4YicsXG4gICAgJ2RhcmtzbGF0ZWdyYXknOiAnIzJmNGY0ZicsXG4gICAgJ2Rhcmt0dXJxdW9pc2UnOiAnIzAwY2VkMScsXG4gICAgJ2Rhcmt2aW9sZXQnOiAnIzk0MDBkMycsXG4gICAgJ2RlZXBwaW5rJzogJyNmZjE0OTMnLFxuICAgICdkZWVwc2t5Ymx1ZSc6ICcjMDBiZmZmJyxcbiAgICAnZGltZ3JheSc6ICcjNjk2OTY5JyxcbiAgICAnZG9kZ2VyYmx1ZSc6ICcjMWU5MGZmJyxcbiAgICAnZmlyZWJyaWNrJzogJyNiMjIyMjInLFxuICAgICdmbG9yYWx3aGl0ZSc6ICcjZmZmYWYwJyxcbiAgICAnZm9yZXN0Z3JlZW4nOiAnIzIyOGIyMicsXG4gICAgJ2Z1Y2hzaWEnOiAnI2ZmMDBmZicsXG4gICAgJ2dhaW5zYm9ybyc6ICcjZGNkY2RjJyxcbiAgICAnZ2hvc3R3aGl0ZSc6ICcjZjhmOGZmJyxcbiAgICAnZ29sZCc6ICcjZmZkNzAwJyxcbiAgICAnZ29sZGVucm9kJzogJyNkYWE1MjAnLFxuICAgICdncmF5JzogJyM4MDgwODAnLFxuICAgICdncmVlbic6ICcjMDA4MDAwJyxcbiAgICAnZ3JlZW55ZWxsb3cnOiAnI2FkZmYyZicsXG4gICAgJ2hvbmV5ZGV3JzogJyNmMGZmZjAnLFxuICAgICdob3RwaW5rJzogJyNmZjY5YjQnLFxuICAgICdpbmRpYW5yZWQgJzogJyNjZDVjNWMnLFxuICAgICdpbmRpZ28nOiAnIzRiMDA4MicsXG4gICAgJ2l2b3J5JzogJyNmZmZmZjAnLFxuICAgICdraGFraSc6ICcjZjBlNjhjJyxcbiAgICAnbGF2ZW5kZXInOiAnI2U2ZTZmYScsXG4gICAgJ2xhdmVuZGVyYmx1c2gnOiAnI2ZmZjBmNScsXG4gICAgJ2xhd25ncmVlbic6ICcjN2NmYzAwJyxcbiAgICAnbGVtb25jaGlmZm9uJzogJyNmZmZhY2QnLFxuICAgICdsaWdodGJsdWUnOiAnI2FkZDhlNicsXG4gICAgJ2xpZ2h0Y29yYWwnOiAnI2YwODA4MCcsXG4gICAgJ2xpZ2h0Y3lhbic6ICcjZTBmZmZmJyxcbiAgICAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAnI2ZhZmFkMicsXG4gICAgJ2xpZ2h0Z3JleSc6ICcjZDNkM2QzJyxcbiAgICAnbGlnaHRncmVlbic6ICcjOTBlZTkwJyxcbiAgICAnbGlnaHRwaW5rJzogJyNmZmI2YzEnLFxuICAgICdsaWdodHNhbG1vbic6ICcjZmZhMDdhJyxcbiAgICAnbGlnaHRzZWFncmVlbic6ICcjMjBiMmFhJyxcbiAgICAnbGlnaHRza3libHVlJzogJyM4N2NlZmEnLFxuICAgICdsaWdodHNsYXRlZ3JheSc6ICcjNzc4ODk5JyxcbiAgICAnbGlnaHRzdGVlbGJsdWUnOiAnI2IwYzRkZScsXG4gICAgJ2xpZ2h0eWVsbG93JzogJyNmZmZmZTAnLFxuICAgICdsaW1lJzogJyMwMGZmMDAnLFxuICAgICdsaW1lZ3JlZW4nOiAnIzMyY2QzMicsXG4gICAgJ2xpbmVuJzogJyNmYWYwZTYnLFxuICAgICdtYWdlbnRhJzogJyNmZjAwZmYnLFxuICAgICdtYXJvb24nOiAnIzgwMDAwMCcsXG4gICAgJ21lZGl1bWFxdWFtYXJpbmUnOiAnIzY2Y2RhYScsXG4gICAgJ21lZGl1bWJsdWUnOiAnIzAwMDBjZCcsXG4gICAgJ21lZGl1bW9yY2hpZCc6ICcjYmE1NWQzJyxcbiAgICAnbWVkaXVtcHVycGxlJzogJyM5MzcwZDgnLFxuICAgICdtZWRpdW1zZWFncmVlbic6ICcjM2NiMzcxJyxcbiAgICAnbWVkaXVtc2xhdGVibHVlJzogJyM3YjY4ZWUnLFxuICAgICdtZWRpdW1zcHJpbmdncmVlbic6ICcjMDBmYTlhJyxcbiAgICAnbWVkaXVtdHVycXVvaXNlJzogJyM0OGQxY2MnLFxuICAgICdtZWRpdW12aW9sZXRyZWQnOiAnI2M3MTU4NScsXG4gICAgJ21pZG5pZ2h0Ymx1ZSc6ICcjMTkxOTcwJyxcbiAgICAnbWludGNyZWFtJzogJyNmNWZmZmEnLFxuICAgICdtaXN0eXJvc2UnOiAnI2ZmZTRlMScsXG4gICAgJ21vY2Nhc2luJzogJyNmZmU0YjUnLFxuICAgICduYXZham93aGl0ZSc6ICcjZmZkZWFkJyxcbiAgICAnbmF2eSc6ICcjMDAwMDgwJyxcbiAgICAnb2xkbGFjZSc6ICcjZmRmNWU2JyxcbiAgICAnb2xpdmUnOiAnIzgwODAwMCcsXG4gICAgJ29saXZlZHJhYic6ICcjNmI4ZTIzJyxcbiAgICAnb3JhbmdlJzogJyNmZmE1MDAnLFxuICAgICdvcmFuZ2VyZWQnOiAnI2ZmNDUwMCcsXG4gICAgJ29yY2hpZCc6ICcjZGE3MGQ2JyxcbiAgICAncGFsZWdvbGRlbnJvZCc6ICcjZWVlOGFhJyxcbiAgICAncGFsZWdyZWVuJzogJyM5OGZiOTgnLFxuICAgICdwYWxldHVycXVvaXNlJzogJyNhZmVlZWUnLFxuICAgICdwYWxldmlvbGV0cmVkJzogJyNkODcwOTMnLFxuICAgICdwYXBheWF3aGlwJzogJyNmZmVmZDUnLFxuICAgICdwZWFjaHB1ZmYnOiAnI2ZmZGFiOScsXG4gICAgJ3BlcnUnOiAnI2NkODUzZicsXG4gICAgJ3BpbmsnOiAnI2ZmYzBjYicsXG4gICAgJ3BsdW0nOiAnI2RkYTBkZCcsXG4gICAgJ3Bvd2RlcmJsdWUnOiAnI2IwZTBlNicsXG4gICAgJ3B1cnBsZSc6ICcjODAwMDgwJyxcbiAgICAncmVkJzogJyNmZjAwMDAnLFxuICAgICdyb3N5YnJvd24nOiAnI2JjOGY4ZicsXG4gICAgJ3JveWFsYmx1ZSc6ICcjNDE2OWUxJyxcbiAgICAnc2FkZGxlYnJvd24nOiAnIzhiNDUxMycsXG4gICAgJ3NhbG1vbic6ICcjZmE4MDcyJyxcbiAgICAnc2FuZHlicm93bic6ICcjZjRhNDYwJyxcbiAgICAnc2VhZ3JlZW4nOiAnIzJlOGI1NycsXG4gICAgJ3NlYXNoZWxsJzogJyNmZmY1ZWUnLFxuICAgICdzaWVubmEnOiAnI2EwNTIyZCcsXG4gICAgJ3NpbHZlcic6ICcjYzBjMGMwJyxcbiAgICAnc2t5Ymx1ZSc6ICcjODdjZWViJyxcbiAgICAnc2xhdGVibHVlJzogJyM2YTVhY2QnLFxuICAgICdzbGF0ZWdyYXknOiAnIzcwODA5MCcsXG4gICAgJ3Nub3cnOiAnI2ZmZmFmYScsXG4gICAgJ3NwcmluZ2dyZWVuJzogJyMwMGZmN2YnLFxuICAgICdzdGVlbGJsdWUnOiAnIzQ2ODJiNCcsXG4gICAgJ3Rhbic6ICcjZDJiNDhjJyxcbiAgICAndGVhbCc6ICcjMDA4MDgwJyxcbiAgICAndGhpc3RsZSc6ICcjZDhiZmQ4JyxcbiAgICAndG9tYXRvJzogJyNmZjYzNDcnLFxuICAgICd0dXJxdW9pc2UnOiAnIzQwZTBkMCcsXG4gICAgJ3Zpb2xldCc6ICcjZWU4MmVlJyxcbiAgICAnd2hlYXQnOiAnI2Y1ZGViMycsXG4gICAgJ3doaXRlJzogJyNmZmZmZmYnLFxuICAgICd3aGl0ZXNtb2tlJzogJyNmNWY1ZjUnLFxuICAgICd5ZWxsb3cnOiAnI2ZmZmYwMCcsXG4gICAgJ3llbGxvd2dyZWVuJzogJyM5YWNkMzInXG59O1xuXG52YXIgY29sb3J1dGlsID0ge1xuICAgIC8qKlxuICAgICAqIHBhZCBsZWZ0IHplcm8gY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIG51bWJlciB2YWx1ZSB0byBwYWQgemVyby5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIHBhZCBsZW5ndGggdG8gd2FudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwYWRkZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGxlYWRpbmdaZXJvOiBmdW5jdGlvbihudW1iZXIsIGxlbmd0aCkge1xuICAgICAgICB2YXIgemVybyA9ICcnLFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgaWYgKFN0cmluZyhudW1iZXIpLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhudW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCAobGVuZ3RoIC0gMSk7IGkgKz0gMSkge1xuICAgICAgICAgICAgemVybyArPSAnMCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHplcm8gKyBudW1iZXIpLnNsaWNlKGxlbmd0aCAqIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdmFsaWRhdGUgb2YgaGV4IHN0cmluZyB2YWx1ZSBpcyBSR0JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gcmdiIGhleCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgd2hlbiBzdXBwbGllZCBzdHIgaXMgdmFsaWQgUkdCIGhleCBzdHJpbmdcbiAgICAgKi9cbiAgICBpc1ZhbGlkUkdCOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIGhleFJYLnRlc3Qoc3RyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBjb2xvciBoZXggc3RyaW5nIHRvIHJnYiBudW1iZXIgYXJyYXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyIC0gaGV4IHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gcmdiIG51bWJlcnNcbiAgICAgKi9cbiAgICBoZXhUb1JHQjogZnVuY3Rpb24oaGV4U3RyKSB7XG4gICAgICAgIHZhciByLCBnLCBiO1xuXG4gICAgICAgIGlmICghY29sb3J1dGlsLmlzVmFsaWRSR0IoaGV4U3RyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaGV4U3RyID0gaGV4U3RyLnN1YnN0cmluZygxKTtcblxuICAgICAgICByID0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cigwLCAyKSwgMTYpO1xuICAgICAgICBnID0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cigyLCAyKSwgMTYpO1xuICAgICAgICBiID0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cig0LCAyKSwgMTYpO1xuXG4gICAgICAgIHJldHVybiBbciwgZywgYl07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcmdiIG51bWJlciB0byBoZXggc3RyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHIgLSByZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZyAtIGdyZWVuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBibHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ3xib29sZWFufSByZXR1cm4gZmFsc2Ugd2hlbiBzdXBwbGllZCByZ2IgbnVtYmVyIGlzIG5vdCB2YWxpZC4gb3RoZXJ3aXNlLCBjb252ZXJ0ZWQgaGV4IHN0cmluZ1xuICAgICAqL1xuICAgIHJnYlRvSEVYOiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICAgIHZhciBoZXhTdHIgPSAnIycgK1xuICAgICAgICAgICAgY29sb3J1dGlsLmxlYWRpbmdaZXJvKHIudG9TdHJpbmcoMTYpLCAyKSArXG4gICAgICAgICAgICBjb2xvcnV0aWwubGVhZGluZ1plcm8oZy50b1N0cmluZygxNiksIDIpICtcbiAgICAgICAgICAgIGNvbG9ydXRpbC5sZWFkaW5nWmVybyhiLnRvU3RyaW5nKDE2KSwgMik7XG5cbiAgICAgICAgaWYgKGNvbG9ydXRpbC5pc1ZhbGlkUkdCKGhleFN0cikpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhTdHI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG5hbWUgdG8gaGV4LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvck5hbWUgY29sb3IgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGhleFxuICAgICAqL1xuICAgIGNvbG9yTmFtZVRvSGV4OiBmdW5jdGlvbihjb2xvck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yTWFwW2NvbG9yTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBjb2xvck5hbWU7XG4gICAgfVxufTtcblxudHVpLnV0aWwuZGVmaW5lTmFtZXNwYWNlKCd0dWkuY2hhcnQnKTtcbnR1aS5jaGFydC5jb2xvcnV0aWwgPSBjb2xvcnV0aWw7XG5cbm1vZHVsZS5leHBvcnRzID0gY29sb3J1dGlsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERPTSBIYW5kbGVyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIERPTSBIYW5kbGVyLlxuICogQG1vZHVsZSBkb21IYW5kbGVyXG4gKi9cbnZhciBkb21IYW5kbGVyID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBlbGVtZW50LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgaHRtbCB0YWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q2xhc3MgY2xhc3MgbmFtZVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gY3JlYXRlZCBlbGVtZW50XG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbih0YWcsIG5ld0NsYXNzKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcblxuICAgICAgICBpZiAobmV3Q2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoZWwsIG5ld0NsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNsYXNzIG5hbWVzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHJldHVybnMge0FycmF5fSBuYW1lc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENsYXNzTmFtZXM6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUsIGNsYXNzTmFtZXM7XG5cbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcyA9IGFwcy5jYWxsKGVsLmNsYXNzTGlzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBlbC5jbGFzc05hbWUgfHwgJyc7XG4gICAgICAgICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lICYmIHR1aS51dGlsLmlzU3RyaW5nKGNsYXNzTmFtZSkgPyBjbGFzc05hbWUuc3BsaXQoJyAnKSA6IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjc3MgY2xhc3MgdG8gdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkb21IYW5kbGVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q2xhc3MgYWRkIGNsYXNzIG5hbWVcbiAgICAgKi9cbiAgICBhZGRDbGFzczogZnVuY3Rpb24oZWwsIG5ld0NsYXNzKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWVzLCBpbmRleDtcblxuICAgICAgICBpZiAoIWVsIHx8ICFuZXdDbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xhc3NOYW1lcyA9IHRoaXMuX2dldENsYXNzTmFtZXMoZWwpO1xuICAgICAgICBpbmRleCA9IHR1aS51dGlsLmluQXJyYXkobmV3Q2xhc3MsIGNsYXNzTmFtZXMpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzLnB1c2gobmV3Q2xhc3MpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNzcyBjbGFzcyBmcm9tIHRhcmdldCBlbGVtZW50LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJtQ2xhc3MgcmVtb3ZlIGNsYXNzIG5hbWVcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWwsIHJtQ2xhc3MpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSB0aGlzLl9nZXRDbGFzc05hbWVzKGVsKSxcbiAgICAgICAgICAgIGluZGV4ID0gdHVpLnV0aWwuaW5BcnJheShybUNsYXNzLCBjbGFzc05hbWVzKTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNsYXNzIGV4aXN0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRvbUhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaW5kQ2xhc3MgdGFyZ2V0IGNzcyBjbGFzc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBoYXMgY2xhc3NcbiAgICAgKi9cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oZWwsIGZpbmRDbGFzcykge1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IHRoaXMuX2dldENsYXNzTmFtZXMoZWwpLFxuICAgICAgICAgICAgaW5kZXggPSB0dWkudXRpbC5pbkFycmF5KGZpbmRDbGFzcywgY2xhc3NOYW1lcyk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHBhcmVudCBieSBjbGFzcyBuYW1lLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0YXJnZXQgY3NzIGNsYXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhc3RDbGFzcyBsYXN0IGNzcyBjbGFzc1xuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gcmVzdWx0IGVsZW1lbnRcbiAgICAgKi9cbiAgICBmaW5kUGFyZW50QnlDbGFzczogZnVuY3Rpb24oZWwsIGNsYXNzTmFtZSwgbGFzdENsYXNzKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzQ2xhc3MocGFyZW50LCBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWScgfHwgdGhpcy5oYXNDbGFzcyhwYXJlbnQsIGxhc3RDbGFzcykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbmRQYXJlbnRCeUNsYXNzKHBhcmVudCwgY2xhc3NOYW1lLCBsYXN0Q2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGNoaWxkIGVsZW1lbnQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkb21IYW5kbGVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2hpbGRyZW4gY2hpbGQgZWxlbWVudFxuICAgICAqL1xuICAgIGFwcGVuZDogZnVuY3Rpb24oY29udGFpbmVyLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IHR1aS51dGlsLmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbUhhbmRsZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXZlbnQgbGlzdGVuZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXZlbnQgbGlzdGVuZXIuXG4gKiBAbW9kdWxlIGV2ZW50TGlzdGVuZXJcbiAqL1xudmFyIGV2ZW50TGlzdGVuZXIgPSB7XG4gICAgLyoqXG4gICAgICogRXZlbnQgbGlzdGVuZXIgZm9yIElFLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgY29udGV4dCBmb3IgY2FsbGJhY2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnROYW1lLCBlbCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdHVpLnV0aWwuYmluZChjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBsaXN0ZW5lciBmb3Igb3RoZXIgYnJvd3NlcnMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpldmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCBjb250ZXh0IGZvciBjYWxsYmFja1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZWwsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHR1aS51dGlsLmJpbmQoY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJpbmQgZXZlbnQgZnVuY3Rpb24uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpldmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgY29udGV4dCBmb3IgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBiaW5kRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgdGFyZ2V0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgYmluZEV2ZW50O1xuICAgICAgICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRhcmdldCkge1xuICAgICAgICAgICAgYmluZEV2ZW50ID0gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgfSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIHRhcmdldCkge1xuICAgICAgICAgICAgYmluZEV2ZW50ID0gdGhpcy5fYXR0YWNoRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kRXZlbnQgPSBiaW5kRXZlbnQ7XG5cbiAgICAgICAgYmluZEV2ZW50KGV2ZW50TmFtZSwgdGFyZ2V0LCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBldmVudExpc3RlbmVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFByZWRpY2F0ZS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG4vKipcbiAqIHByZWRpY2F0ZS5cbiAqIEBtb2R1bGUgcHJlZGljYXRlXG4gKi9cbnZhciBwcmVkaWNhdGUgPSB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBiYXIgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNCYXJDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9CQVI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY29sdW1uIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqL1xuICAgIGlzQ29sdW1uQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gY2hhcnRUeXBlID09PSBjaGFydENvbnN0LkNIQVJUX1RZUEVfQ09MVU1OO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGJhciB0eXBlIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqL1xuICAgIGlzQmFyVHlwZUNoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNCYXJDaGFydChjaGFydFR5cGUpIHx8IHRoaXMuaXNDb2x1bW5DaGFydChjaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNvbWJvIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqL1xuICAgIGlzQ29tYm9DaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9DT01CTztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBsaW5lIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqL1xuICAgIGlzTGluZUNoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJ0VHlwZSA9PT0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0xJTkU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYXJlYSBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0FyZWFDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9BUkVBO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGxpbmUgdHlwZSBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0xpbmVUeXBlQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0xpbmVDaGFydChjaGFydFR5cGUpIHx8IHRoaXMuaXNBcmVhQ2hhcnQoY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBidWJibGUgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNCdWJibGVDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9CVUJCTEU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcGllIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqL1xuICAgIGlzUGllQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gY2hhcnRUeXBlID09PSBjaGFydENvbnN0LkNIQVJUX1RZUEVfUElFO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG1hcCBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc01hcENoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJ0VHlwZSA9PT0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX01BUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhbGxvdyByZW5kZXJpbmcgZm9yIG1pbnVzIHBvaW50IGluIGFyZWEgb2Ygc2VyaWVzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBhbGxvd01pbnVzUG9pbnRSZW5kZXI6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0xpbmVUeXBlQ2hhcnQoY2hhcnRUeXBlKSB8fCB0aGlzLmlzQnViYmxlQ2hhcnQoY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBtb3VzZSBwb3NpdGlvbiBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc01vdXNlUG9zaXRpb25DaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzUGllQ2hhcnQoY2hhcnRUeXBlKSB8fCB0aGlzLmlzTWFwQ2hhcnQoY2hhcnRUeXBlKSB8fCB0aGlzLmlzQnViYmxlQ2hhcnQoY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhbGlnbiBvZiBsZWdlbmQgaXMgb3V0ZXIgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWduIGxlZ2VuZCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNMZWdlbmRBbGlnbk91dGVyOiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICByZXR1cm4gYWxpZ24gPT09IGNoYXJ0Q29uc3QuTEVHRU5EX0FMSUdOX09VVEVSO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFsaWduIG9mIGxlZ2VuZCBpcyBjZW50ZXIgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWduIGxlZ2VuZCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNMZWdlbmRBbGlnbkNlbnRlcjogZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgICAgcmV0dXJuIGFsaWduID09PSBjaGFydENvbnN0LkxFR0VORF9BTElHTl9DRU5URVI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYWxpZ24gb2YgbGVnZW5kIGlzIGxlZnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWduIGxlZ2VuZCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNMZWdlbmRBbGlnbkxlZnQ6IGZ1bmN0aW9uKGFsaWduKSB7XG4gICAgICAgIHJldHVybiBhbGlnbiA9PT0gY2hhcnRDb25zdC5MRUdFTkRfQUxJR05fTEVGVDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhbGlnbiBvZiBsZWdlbmQgaXMgdG9wIG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbiBsZWdlbmQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqL1xuICAgIGlzTGVnZW5kQWxpZ25Ub3A6IGZ1bmN0aW9uKGFsaWduKSB7XG4gICAgICAgIHJldHVybiBhbGlnbiA9PT0gY2hhcnRDb25zdC5MRUdFTkRfQUxJR05fVE9QO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFsaWduIG9mIGxlZ2VuZCBpcyBib3R0b20gb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWduIGxlZ2VuZCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNMZWdlbmRBbGlnbkJvdHRvbTogZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgICAgcmV0dXJuIGFsaWduID09PSBjaGFydENvbnN0LkxFR0VORF9BTElHTl9CT1RUT007XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaG9yaXpvbnRhbCBsZWdlbmQgYWxpZ24gb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWduIGFsaWduXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNIb3Jpem9udGFsTGVnZW5kOiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0xlZ2VuZEFsaWduVG9wKGFsaWduKSB8fCB0aGlzLmlzTGVnZW5kQWxpZ25Cb3R0b20oYWxpZ24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGxlZ2VuZCBhbGlnbiBvZiBwaWUgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBhbGlnbiBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNQaWVMZWdlbmRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaXNMZWdlbmRBbGlnbk91dGVyKGFsaWduKSB8fCB0aGlzLmlzTGVnZW5kQWxpZ25DZW50ZXIoYWxpZ24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYWxsb3dlZCBzdGFja2VkIG9wdGlvbiBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0FsbG93ZWRTdGFja2VkT3B0aW9uOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNCYXJDaGFydChjaGFydFR5cGUpIHx8IHRoaXMuaXNDb2x1bW5DaGFydChjaGFydFR5cGUpIHx8IHRoaXMuaXNBcmVhQ2hhcnQoY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBub3JtYWwgc3RhY2tlZCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrZWQgc3RhY2tlZCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc05vcm1hbFN0YWNrZWQ6IGZ1bmN0aW9uKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT09IGNoYXJ0Q29uc3QuU1RBQ0tFRF9OT1JNQUxfVFlQRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBwZXJjZW50IHN0YWNrZWQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja2VkIHN0YWNrZWQgb3B0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNQZXJjZW50U3RhY2tlZDogZnVuY3Rpb24oc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PT0gY2hhcnRDb25zdC5TVEFDS0VEX1BFUkNFTlRfVFlQRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB2YWxpZCBzdGFja2VkIG9wdGlvbiBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrZWQgc3RhY2tlZCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc1ZhbGlkU3RhY2tlZE9wdGlvbjogZnVuY3Rpb24oc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCAmJiAodGhpcy5pc05vcm1hbFN0YWNrZWQoc3RhY2tlZCkgfHwgdGhpcy5pc1BlcmNlbnRTdGFja2VkKHN0YWNrZWQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhbGxvdyByYW5nZSBkYXRhIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQWxsb3dSYW5nZURhdGE6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0JhclR5cGVDaGFydChjaGFydFR5cGUpIHx8IHRoaXMuaXNBcmVhQ2hhcnQoY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhbGlnbiBvZiB5QXhpcyBpcyBjZW50ZXIgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBoYXNSaWdodFlBeGlzIHdoZXRoZXIgaGFzIHJpZ2h0IHlBeGlzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbk9wdGlvbiBhbGlnbiBvcHRpb24gb2YgeUF4aXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgYWxpZ24gY2VudGVyIG9yIG5vdC5cbiAgICAgKi9cbiAgICBpc1lBeGlzQWxpZ25DZW50ZXI6IGZ1bmN0aW9uKGhhc1JpZ2h0WUF4aXMsIGFsaWduT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiAhaGFzUmlnaHRZQXhpcyAmJiAoYWxpZ25PcHRpb24gPT09IGNoYXJ0Q29uc3QuWUFYSVNfQUxJR05fQ0VOVEVSKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBtaW51cyBsaW1pdCBvciBub3QuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgbGltaXRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc01pbnVzTGltaXQ6IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHJldHVybiBsaW1pdC5taW4gPD0gMCAmJiBsaW1pdC5tYXggPD0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvcHRpb25zLmhpZGRlbiBpcyB0cnVlIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzSGlkZGVuOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAhIXR1aS51dGlsLnBpY2sob3B0aW9ucywgJ2hpZGRlbicpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlZGljYXRlO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhdyBkYXRhIGhhbmRsZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxuLyoqXG4gKiBSYXcgZGF0YSBIYW5kbGVyLlxuICogQG1vZHVsZSByYXdEYXRhSGFuZGxlclxuICovXG52YXIgcmF3RGF0YUhhbmRsZXIgPSB7XG4gICAgLyoqXG4gICAgICogUGljayBzdGFja3MuXG4gICAgICogQHBhcmFtIHtBcnJheS48e3N0YWNrOiBzdHJpbmd9Pn0gc2VyaWVzRGF0YSByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IHN0YWNrc1xuICAgICAqL1xuICAgIHBpY2tTdGFja3M6IGZ1bmN0aW9uKHNlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIHN0YWNrcywgdW5pcVN0YWNrcywgZmlsdGVyZWRTdGFjaztcblxuICAgICAgICBzdGFja3MgPSB0dWkudXRpbC5tYXAoc2VyaWVzRGF0YSwgZnVuY3Rpb24oc2VyaWVzRGF0dW0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNEYXR1bS5zdGFjaztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdW5pcVN0YWNrcyA9IHR1aS51dGlsLnVuaXF1ZShzdGFja3MpLnNsaWNlKDAsIDIpO1xuXG4gICAgICAgIGZpbHRlcmVkU3RhY2sgPSB0dWkudXRpbC5maWx0ZXIodW5pcVN0YWNrcywgZnVuY3Rpb24oc3RhY2spIHtcbiAgICAgICAgICAgIHJldHVybiAhIXN0YWNrO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZmlsdGVyZWRTdGFjay5sZW5ndGggPCB1bmlxU3RhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgZmlsdGVyZWRTdGFjay5wdXNoKGNoYXJ0Q29uc3QuREVGQVVMVF9TVEFDSyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVyZWRTdGFjaztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU29ydCBzZXJpZXMgZGF0YSBmcm9tIHN0YWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7c3RhY2s6ID9zdHJpbmd9Pn0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHN0YWNrcyBzdGFja3NcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc29ydFNlcmllc0RhdGE6IGZ1bmN0aW9uKHNlcmllc0RhdGEsIHN0YWNrcykge1xuICAgICAgICB2YXIgbmV3U2VyaWVzRGF0YSA9IFtdO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzdGFja3MsIGZ1bmN0aW9uKHN0YWNrKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSB0dWkudXRpbC5maWx0ZXIoc2VyaWVzRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRhdHVtLnN0YWNrIHx8IGNoYXJ0Q29uc3QuREVGQVVMVF9TVEFDSykgPT09IHN0YWNrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdTZXJpZXNEYXRhID0gbmV3U2VyaWVzRGF0YS5jb25jYXQoZmlsdGVyZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3U2VyaWVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHN0YWNrIG9mIHNlcmllcyBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHtzdGFjazogP3N0cmluZ30+fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhXG4gICAgICovXG4gICAgcmVtb3ZlU2VyaWVzU3RhY2s6IGZ1bmN0aW9uKHNlcmllc0RhdGEpIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHNlcmllc0RhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICBkZWxldGUgZGF0dW0uc3RhY2s7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmF3RGF0YUhhbmRsZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbCBmb3IgcmVuZGVyaW5nLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBuby1tYWdpYy1udW1iZXJzOiBbMSwge2lnbm9yZTogWy0xLCAwLCAxLCAyLCA3LCA4XX1dKi9cblxudmFyIGRvbSA9IHJlcXVpcmUoJy4vZG9tSGFuZGxlcicpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLy4uL2NvbnN0Jyk7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG52YXIgYnJvd3NlciA9IHR1aS51dGlsLmJyb3dzZXIsXG4gICAgaXNJRTcgPSBicm93c2VyLm1zaWUgJiYgYnJvd3Nlci52ZXJzaW9uID09PSA3LFxuICAgIGlzT2xkQnJvd3NlciA9IGJyb3dzZXIubXNpZSAmJiBicm93c2VyLnZlcnNpb24gPD0gODtcblxuLyoqXG4gKiBVdGlsIGZvciByZW5kZXJpbmcuXG4gKiBAbW9kdWxlIHJlbmRlclV0aWxcbiAqL1xudmFyIHJlbmRlclV0aWwgPSB7XG4gICAgLyoqXG4gICAgICogQ29uY2F0IHN0cmluZy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW1zIHsuLi5zdHJpbmd9IHRhcmdldCBzdHJpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY29uY2F0IHN0cmluZ1xuICAgICAqL1xuICAgIGNvbmNhdFN0cjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmNvbmNhdC5hcHBseSgnJywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjc3NUZXh0IGZvciBmb250LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGZvbnQgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjc3NUZXh0XG4gICAgICovXG4gICAgbWFrZUZvbnRDc3NUZXh0OiBmdW5jdGlvbih0aGVtZSkge1xuICAgICAgICB2YXIgY3NzVGV4dHMgPSBbXTtcblxuICAgICAgICBpZiAoIXRoZW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhlbWUuZm9udFNpemUpIHtcbiAgICAgICAgICAgIGNzc1RleHRzLnB1c2godGhpcy5jb25jYXRTdHIoJ2ZvbnQtc2l6ZTonLCB0aGVtZS5mb250U2l6ZSwgJ3B4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoZW1lLmZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgIGNzc1RleHRzLnB1c2godGhpcy5jb25jYXRTdHIoJ2ZvbnQtZmFtaWx5OicsIHRoZW1lLmZvbnRGYW1pbHkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGVtZS5jb2xvcikge1xuICAgICAgICAgICAgY3NzVGV4dHMucHVzaCh0aGlzLmNvbmNhdFN0cignY29sb3I6JywgdGhlbWUuY29sb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjc3NUZXh0cy5qb2luKCc7Jyk7XG4gICAgfSxcblxuICAgIGNoZWNrRWw6IG51bGwsXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVsZW1lbnQgZm9yIHNpemUgY2hlY2suXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlU2l6ZUNoZWNrRWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGl2LCBzcGFuO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tFbCkge1xuICAgICAgICAgICAgZGl2ID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1zaXplLWNoZWNrLWVsZW1lbnQnKTtcbiAgICAgICAgICAgIHNwYW4gPSBkb20uY3JlYXRlKCdTUEFOJyk7XG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRWwgPSBkaXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRWwuc3R5bGUuY3NzVGV4dCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjYWNoaW5nIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgbGFiZWtcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmd9fSB0aGVtZSB0aGVtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvZmZzZXRUeXBlIG9mZnNldCB0eXBlIChvZmZzZXRXaWR0aCBvciBvZmZzZXRIZWlnaHQpXG4gICAgICogQHJldHVybnMge3N0cmluZ30ga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNhY2hpbmdLZXk6IGZ1bmN0aW9uKGxhYmVsLCB0aGVtZSwgb2Zmc2V0VHlwZSkge1xuICAgICAgICB2YXIga2V5cyA9IFtsYWJlbCwgb2Zmc2V0VHlwZV07XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh0aGVtZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSArIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGtleXMuam9pbignLScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaXplIGNhY2hlLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgc2l6ZUNhY2hlOiB7fSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjc3Mgc3R5bGUuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGl2IGRpdiBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogc3RyaW5nLCBjc3NUZXh0OiBzdHJpbmd9fSB0aGVtZSB0aGVtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENzc1N0eWxlOiBmdW5jdGlvbihkaXYsIHRoZW1lKSB7XG4gICAgICAgIGRpdi5zdHlsZS5mb250U2l6ZSA9ICh0aGVtZS5mb250U2l6ZSB8fCBjaGFydENvbnN0LkRFRkFVTFRfTEFCRUxfRk9OVF9TSVpFKSArICdweCc7XG5cbiAgICAgICAgaWYgKHRoZW1lLmZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5mb250RmFtaWx5ID0gdGhlbWUuZm9udEZhbWlseTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGVtZS5jc3NUZXh0KSB7XG4gICAgICAgICAgICBkaXYuc3R5bGUuY3NzVGV4dCArPSB0aGVtZS5jc3NUZXh0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZW5kZXJlZCBsYWJlbCBzaXplICh3aWR0aCBvciBoZWlnaHQpLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBsYWJlbCBsYWJlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvZmZzZXRUeXBlIG9mZnNldCB0eXBlIChvZmZzZXRXaWR0aCBvciBvZmZzZXRIZWlnaHQpXG4gICAgICogQHJldHVybnMge251bWJlcn0gc2l6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFJlbmRlcmVkTGFiZWxTaXplOiBmdW5jdGlvbihsYWJlbCwgdGhlbWUsIG9mZnNldFR5cGUpIHtcbiAgICAgICAgdmFyIGtleSwgZGl2LCBzcGFuLCBsYWJlbFNpemU7XG5cbiAgICAgICAgdGhlbWUgPSB0aGVtZSB8fCB7fTtcblxuICAgICAgICBsYWJlbCA9IHR1aS51dGlsLmlzRXhpc3R5KGxhYmVsKSA/IFN0cmluZyhsYWJlbCkgOiAnJztcblxuICAgICAgICBpZiAoIWxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IHRoaXMuX21ha2VDYWNoaW5nS2V5KGxhYmVsLCB0aGVtZSwgb2Zmc2V0VHlwZSk7XG4gICAgICAgIGxhYmVsU2l6ZSA9IHRoaXMuc2l6ZUNhY2hlW2tleV07XG5cbiAgICAgICAgaWYgKCFsYWJlbFNpemUpIHtcbiAgICAgICAgICAgIGRpdiA9IHRoaXMuX2NyZWF0ZVNpemVDaGVja0VsKCk7XG4gICAgICAgICAgICBzcGFuID0gZGl2LmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gbGFiZWw7XG5cbiAgICAgICAgICAgIHRoaXMuX2FkZENzc1N0eWxlKGRpdiwgdGhlbWUpO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICBsYWJlbFNpemUgPSBzcGFuW29mZnNldFR5cGVdO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuXG4gICAgICAgICAgICB0aGlzLnNpemVDYWNoZVtrZXldID0gbGFiZWxTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsU2l6ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlbmRlcmVkIGxhYmVsIHdpZHRoLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBsYWJlbFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gd2lkdGhcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZExhYmVsV2lkdGg6IGZ1bmN0aW9uKGxhYmVsLCB0aGVtZSkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHRoaXMuX2dldFJlbmRlcmVkTGFiZWxTaXplKGxhYmVsLCB0aGVtZSwgJ29mZnNldFdpZHRoJyk7XG4gICAgICAgIHJldHVybiBsYWJlbFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVuZGVyZWQgbGFiZWwgaGVpZ2h0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBsYWJlbFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRMYWJlbEhlaWdodDogZnVuY3Rpb24obGFiZWwsIHRoZW1lKSB7XG4gICAgICAgIHZhciBsYWJlbEhlaWdodCA9IHRoaXMuX2dldFJlbmRlcmVkTGFiZWxTaXplKGxhYmVsLCB0aGVtZSwgJ29mZnNldEhlaWdodCcpO1xuICAgICAgICByZXR1cm4gbGFiZWxIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBSZW5kZXJlZCBMYWJlbHMgTWF4IFNpemUod2lkdGggb3IgaGVpZ2h0KS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmJvdW5kc01ha2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgaXRlcmF0ZWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBtYXggc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFJlbmRlcmVkTGFiZWxzTWF4U2l6ZTogZnVuY3Rpb24obGFiZWxzLCB0aGVtZSwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIG1heFNpemUgPSAwLFxuICAgICAgICAgICAgc2l6ZXM7XG5cbiAgICAgICAgaWYgKGxhYmVscyAmJiBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzaXplcyA9IHR1aS51dGlsLm1hcChsYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGxhYmVsLCB0aGVtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1heFNpemUgPSB0dWkudXRpbC5tYXgoc2l6ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heFNpemU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZW5kZXJlZCBsYWJlbHMgbWF4IHdpZHRoLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Ym91bmRzTWFrZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBsYWJlbHMgbGFiZWxzXG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogc3RyaW5nLCBjb2xvcjogc3RyaW5nfX0gdGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBtYXggd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkTGFiZWxzTWF4V2lkdGg6IGZ1bmN0aW9uKGxhYmVscywgdGhlbWUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdGVlID0gdHVpLnV0aWwuYmluZCh0aGlzLmdldFJlbmRlcmVkTGFiZWxXaWR0aCwgdGhpcyksXG4gICAgICAgICAgICBtYXhXaWR0aCA9IHRoaXMuX2dldFJlbmRlcmVkTGFiZWxzTWF4U2l6ZShsYWJlbHMsIHRoZW1lLCBpdGVyYXRlZSk7XG4gICAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlbmRlcmVkIGxhYmVscyBtYXggaGVpZ2h0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Ym91bmRzTWFrZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBsYWJlbHMgbGFiZWxzXG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogc3RyaW5nLCBjb2xvcjogc3RyaW5nfX0gdGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBtYXggaGVpZ2h0XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRMYWJlbHNNYXhIZWlnaHQ6IGZ1bmN0aW9uKGxhYmVscywgdGhlbWUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdGVlID0gdHVpLnV0aWwuYmluZCh0aGlzLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQsIHRoaXMpLFxuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5fZ2V0UmVuZGVyZWRMYWJlbHNNYXhTaXplKGxhYmVscywgdGhlbWUsIGl0ZXJhdGVlKTtcbiAgICAgICAgcmV0dXJuIG1heEhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGRpbWVuc2lvbi5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqL1xuICAgIHJlbmRlckRpbWVuc2lvbjogZnVuY3Rpb24oZWwsIGRpbWVuc2lvbikge1xuICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gW1xuICAgICAgICAgICAgdGhpcy5jb25jYXRTdHIoJ3dpZHRoOicsIGRpbWVuc2lvbi53aWR0aCwgJ3B4JyksXG4gICAgICAgICAgICB0aGlzLmNvbmNhdFN0cignaGVpZ2h0OicsIGRpbWVuc2lvbi5oZWlnaHQsICdweCcpXG4gICAgICAgIF0uam9pbignOycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgcG9zaXRpb24odG9wLCByaWdodCkuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKi9cbiAgICByZW5kZXJQb3NpdGlvbjogZnVuY3Rpb24oZWwsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0dWkudXRpbC5pc1VuZGVmaW5lZChwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNVbmRlZmluZWQocG9zaXRpb24udG9wKSkge1xuICAgICAgICAgICAgZWwuc3R5bGUudG9wID0gcG9zaXRpb24udG9wICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNVbmRlZmluZWQocG9zaXRpb24ubGVmdCkpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmxlZnQgPSBwb3NpdGlvbi5sZWZ0ICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNVbmRlZmluZWQocG9zaXRpb24ucmlnaHQpKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5yaWdodCA9IHBvc2l0aW9uLnJpZ2h0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYmFja2dyb3VuZC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYWNrZ3JvdW5kIGJhY2tncm91bmQgb3B0aW9uXG4gICAgICovXG4gICAgcmVuZGVyQmFja2dyb3VuZDogZnVuY3Rpb24oZWwsIGJhY2tncm91bmQpIHtcbiAgICAgICAgaWYgKCFiYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGZvbnQgZmFtaWx5LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRGYW1pbHkgZm9udCBmYW1pbHkgb3B0aW9uXG4gICAgICovXG4gICAgcmVuZGVyRm9udEZhbWlseTogZnVuY3Rpb24oZWwsIGZvbnRGYW1pbHkpIHtcbiAgICAgICAgaWYgKCFmb250RmFtaWx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbC5zdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRpdGxlLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSB0aXRsZVxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGNvbG9yOiBzdHJpbmcsIGJhY2tncm91bmQ6IHN0cmluZ319IHRoZW1lIHRpdGxlIHRoZW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBjc3MgY2xhc3MgbmFtZVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdGl0bGUgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlclRpdGxlOiBmdW5jdGlvbih0aXRsZSwgdGhlbWUsIGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgZWxUaXRsZSwgY3NzVGV4dDtcblxuICAgICAgICBpZiAoIXRpdGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsVGl0bGUgPSBkb20uY3JlYXRlKCdESVYnLCBjbGFzc05hbWUpO1xuICAgICAgICBlbFRpdGxlLmlubmVySFRNTCA9IHRpdGxlO1xuXG4gICAgICAgIGNzc1RleHQgPSByZW5kZXJVdGlsLm1ha2VGb250Q3NzVGV4dCh0aGVtZSk7XG5cbiAgICAgICAgaWYgKHRoZW1lLmJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIGNzc1RleHQgKz0gJzsnICsgdGhpcy5jb25jYXRTdHIoJ2JhY2tncm91bmQ6JywgdGhlbWUuYmFja2dyb3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbFRpdGxlLnN0eWxlLmNzc1RleHQgPSBjc3NUZXh0O1xuXG4gICAgICAgIHJldHVybiBlbFRpdGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmQgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IGJvdW5kIHNlcmllcyBib3VuZFxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gZXhwZW5kZWQgYm91bmRcbiAgICAgKi9cbiAgICBleHBhbmRCb3VuZDogZnVuY3Rpb24oYm91bmQpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGJvdW5kLmRpbWVuc2lvbixcbiAgICAgICAgICAgIHBvc2l0aW9uID0gYm91bmQucG9zaXRpb247XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaW1lbnNpb246IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogZGltZW5zaW9uLndpZHRoICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUgKiAyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZGltZW5zaW9uLmhlaWdodCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFICogMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wIC0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjdXN0b20gZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHByZWZpeFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWZmaXggc3VmZml4XG4gICAgICogQHJldHVybnMge3N0cmluZ30gY3VzdG9tIGV2ZW50IG5hbWVcbiAgICAgKi9cbiAgICBtYWtlQ3VzdG9tRXZlbnROYW1lOiBmdW5jdGlvbihwcmVmaXgsIHZhbHVlLCBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHR1aS51dGlsLnByb3BlckNhc2UodmFsdWUpICsgdHVpLnV0aWwucHJvcGVyQ2FzZShzdWZmaXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheS48ZnVuY3Rpb24+fSBmb3JtYXRGdW5jdGlvbnMgLSBmdW5jdGlvbnMgZm9yIGZvcm1hdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmVhVHlwZSAtIHR5cGUgb2YgYXJlYSBsaWtlIHlBeGlzLCB4QXhpcywgc2VyaWVzLCBjaXJjbGVMZWdlbmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlVHlwZV0gLSB2YWx1ZSB0eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHZhbHVlXG4gICAgICovXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXRGdW5jdGlvbnMsIGFyZWFUeXBlLCB2YWx1ZVR5cGUpIHtcbiAgICAgICAgdmFyIGZucyA9IFt2YWx1ZV0uY29uY2F0KGZvcm1hdEZ1bmN0aW9ucyB8fCBbXSk7XG5cbiAgICAgICAgdmFsdWVUeXBlID0gdmFsdWVUeXBlIHx8ICd2YWx1ZSc7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLnJlZHVjZShmbnMsIGZ1bmN0aW9uKHN0b3JlZCwgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmbihzdG9yZWQsIGFyZWFUeXBlLCB2YWx1ZVR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgdmFsdWVzXG4gICAgICogQHBhcmFtIHtBcnJheS48ZnVuY3Rpb24+fSBmb3JtYXRGdW5jdGlvbnMgZnVuY3Rpb25zIGZvciBmb3JtYXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJlYVR5cGUgLSB0eXBlIG9mIGFyZWEgbGlrZSB5QXhpcywgeEF4aXMsIHNlcmllcywgY2lyY2xlTGVnZW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlVHlwZSAtIHZhbHVlIHR5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgZm9ybWF0VmFsdWVzOiBmdW5jdGlvbih2YWx1ZXMsIGZvcm1hdEZ1bmN0aW9ucywgYXJlYVR5cGUsIHZhbHVlVHlwZSkge1xuICAgICAgICB2YXIgZm9ybWF0ZWRWYWx1ZXM7XG4gICAgICAgIGlmICghZm9ybWF0RnVuY3Rpb25zIHx8ICFmb3JtYXRGdW5jdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdGVkVmFsdWVzID0gdHVpLnV0aWwubWFwKHZhbHVlcywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKGxhYmVsLCBmb3JtYXRGdW5jdGlvbnMsIGFyZWFUeXBlLCB2YWx1ZVR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdGVkVmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHt7aWQ6IG51bWJlcn19IGFuaW1hdGlvbiBhbmltYWlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBjYW5jZWxBbmltYXRpb246IGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuICAgICAgICBpZiAoYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5pZCkge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uLmlkKTtcbiAgICAgICAgICAgIGRlbGV0ZSBhbmltYXRpb24uaWQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmltYXRpb25UaW1lIGFuaW1hdGlvbiB0aW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25BbmltYXRpb24gYW5pbWF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge3tpZDogbnVtYmVyfX0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlkXG4gICAgICovXG4gICAgc3RhcnRBbmltYXRpb246IGZ1bmN0aW9uKGFuaW1hdGlvblRpbWUsIG9uQW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBhbmltYXRpb24gPSB7fSxcbiAgICAgICAgICAgIHN0YXJ0VGltZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW5pbWF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgICAgICAgICB2YXIgZGlmZlRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIHJhdGlvID0gTWF0aC5taW4oKGRpZmZUaW1lIC8gYW5pbWF0aW9uVGltZSksIDEpO1xuXG4gICAgICAgICAgICBvbkFuaW1hdGlvbihyYXRpbyk7XG5cbiAgICAgICAgICAgIGlmIChyYXRpbyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhbmltYXRpb24uaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgIGFuaW1hdGlvbi5pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcblxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIElFNyBvciBub3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNJRTc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNJRTc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb2xkQnJvd3NlciBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNPbGRCcm93c2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzT2xkQnJvd3NlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRvIHplcm8gZmlsbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdGFyZ2V0IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbiBsZW5ndGggb2YgcmVzdWx0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmb3JtYXRUb1plcm9GaWxsOiBmdW5jdGlvbih2YWx1ZSwgbGVuKSB7XG4gICAgICAgIHZhciB6ZXJvID0gJzAnO1xuXG4gICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IGxlbikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgICAgdmFsdWUgPSB6ZXJvICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB0byBEZWNpbWFsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuIGxlbmd0aCBvZiB1bmRlciBkZWNpbWFsIHBvaW50XG4gICAgICogQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHZhbHVlXG4gICAgICovXG4gICAgZm9ybWF0VG9EZWNpbWFsOiBmdW5jdGlvbih2YWx1ZSwgbGVuKSB7XG4gICAgICAgIHZhciBwb3c7XG5cbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG93ID0gTWF0aC5wb3coMTAsIGxlbik7XG4gICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIHBvdykgLyBwb3c7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkudG9GaXhlZChsZW4pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRvIENvbW1hLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZvcm1hdFRvQ29tbWE6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBjb21tYSA9ICcsJyxcbiAgICAgICAgICAgIHVuZGVyUG9pbnRWYWx1ZSA9ICcnLFxuICAgICAgICAgICAgYmV0d2VlbkxlbiA9IDMsXG4gICAgICAgICAgICBvcmdWYWx1ZSA9IHZhbHVlLFxuICAgICAgICAgICAgc2lnbiwgdmFsdWVzLCBsYXN0SW5kZXgsIGZvcm1hdHRlZFZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgc2lnbiA9IHZhbHVlLmluZGV4T2YoJy0nKSA+IC0xID8gJy0nIDogJyc7XG5cbiAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcoTWF0aC5hYnModmFsdWVzWzBdKSk7XG4gICAgICAgICAgICB1bmRlclBvaW50VmFsdWUgPSAnLicgKyB2YWx1ZXNbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyhNYXRoLmFicyh2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBiZXR3ZWVuTGVuKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IG9yZ1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzID0gKHZhbHVlKS5zcGxpdCgnJykucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YWx1ZXMgPSB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbihjaGFyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbY2hhcl07XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbGFzdEluZGV4ICYmIChpbmRleCArIDEpICUgYmV0d2VlbkxlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb21tYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gc2lnbiArIGNvbmNhdC5hcHBseShbXSwgdmFsdWVzKS5yZXZlcnNlKCkuam9pbignJykgKyB1bmRlclBvaW50VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkVmFsdWU7XG4gICAgfVxufTtcblxudHVpLnV0aWwuZGVmaW5lTmFtZXNwYWNlKCd0dWkuY2hhcnQnKTtcbnR1aS5jaGFydC5yZW5kZXJVdGlsID0gcmVuZGVyVXRpbDtcblxubW9kdWxlLmV4cG9ydHMgPSByZW5kZXJVdGlsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgaXMgdGVtcGxhdGUgbWFrZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGVtcGxhdGUgbWFrZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgaHRtbFxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gdGVtcGxhdGUgZnVuY3Rpb25cbiAgICAgKiBAZWF4bXBsZVxuICAgICAqXG4gICAgICogICB2YXIgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKCc8c3Bhbj57eyBuYW1lIH19PC9zcGFuPicpLFxuICAgICAqICAgICAgIHJlc3VsdCA9IHRlbXBsYXRlKHtuYW1lOiAnSm9obicpO1xuICAgICAqICAgY29uc29sZS5sb2cocmVzdWx0KTsgLy8gPHNwYW4+Sm9objwvc3Bhbj5cbiAgICAgKlxuICAgICAqL1xuICAgIHRlbXBsYXRlOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaHRtbDtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goZGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKCd7e1xcXFxzKicgKyBrZXkgKyAnXFxcXHMqfX0nLCAnZycpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKHJlZ0V4cCwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXNlckV2ZW50TGlzdGVuZXIgaXMgbGlzdGVuZXIgb2YgdXNlciBldmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVzZXJFdmVudExpc3RlbmVyID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBVc2VyRXZlbnRMaXN0ZW5lci5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHVzZXIgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBldmVudCBjYWxsYmFja1xuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihldmVudE5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5vbihldmVudE5hbWUsIGZ1bmMpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oVXNlckV2ZW50TGlzdGVuZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXJFdmVudExpc3RlbmVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBDaXJjbGUgbGVnZW5kIGNvbXBvbmVudCByZW5kZXIgYSBsZWdlbmQgaW4gdGhlIGZvcm0gb2Ygb3ZlcmxhcHBpbmcgY2lyY2xlc1xuICogICAgICAgICAgICAgICAgICBieSByZXByZXNlbnRhdGl2ZSByYWRpdXMgdmFsdWVzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xudmFyIHBsdWdpbkZhY3RvcnkgPSByZXF1aXJlKCcuLi9mYWN0b3JpZXMvcGx1Z2luRmFjdG9yeScpO1xudmFyIGxlZ2VuZFRlbXBsYXRlID0gcmVxdWlyZSgnLi8uLi9sZWdlbmRzL2xlZ2VuZFRlbXBsYXRlJyk7XG5cbnZhciBDaXJjbGVMZWdlbmQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIENpcmNsZUxlZ2VuZC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIGNzcyBjbGFzc05hbWUgb2YgY2lyY2xlIGxlZ2VuZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgY2xhc3NOYW1lOiAndHVpLWNoYXJ0LWNpcmNsZS1sZWdlbmQtYXJlYScsXG4gICAgLyoqXG4gICAgICogcmF0aW9zIGZvciByZW5kZXJpbmcgY2lyY2xlXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIGNpcmNsZVJhdGlvczogWzEsIDAuNSwgMC4yNV0sXG4gICAgLyoqXG4gICAgICogQ2lyY2xlIGxlZ2VuZCBjb21wb25lbnQgcmVuZGVyIGEgbGVnZW5kIGluIHRoZSBmb3JtIG9mIG92ZXJsYXBwaW5nIGNpcmNsZXMgYnkgcmVwcmVzZW50YXRpdmUgcmFkaXVzIHZhbHVlcy5cbiAgICAgKiBAY29uc3RydWN0cyBDaXJjbGVMZWdlbmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7P3N0cmluZ30gcGFyYW1zLmxpYlR5cGUgLSBsaWJyYXJ5IHR5cGUgZm9yIGdyYXBoIHJlbmRlcmluZ1xuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFydFR5cGUgLSBjaGFydCB0eXBlXG4gICAgICogICAgICBAcGFyYW0ge0RhdGFQcm9jZXNzb3J9IHBhcmFtcy5kYXRhUHJvY2Vzc29yIC0gRGF0YVByb2Nlc3NvclxuICAgICAqICAgICAgQHBhcmFtIHtCb3VuZHNNYWtlcn0gcGFyYW1zLmJvdW5kc01ha2VyIC0gQm91bmRzTWFrZXJcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYmFzZUZvbnRGYW1pbHkgLSBiYXNlIGZvbnRGYW1pbHkgb2YgY2hhcnRcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxpYlR5cGUgPSBwYXJhbXMubGliVHlwZSB8fCBjaGFydENvbnN0LkRFRkFVTFRfUExVR0lOO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IHBhcmFtcy5jaGFydFR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcHJvY2Vzc29yXG4gICAgICAgICAqIEB0eXBlIHtEYXRhUHJvY2Vzc29yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gcGFyYW1zLmRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGVtZSBmb3IgbGFiZWwgb2YgY2lyY2xlIGxlZ2VuZCBhcmVhXG4gICAgICAgICAqIEB0eXBlIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogKn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhYmVsVGhlbWUgPSB7XG4gICAgICAgICAgICBmb250U2l6ZTogY2hhcnRDb25zdC5DSVJDTEVfTEVHRU5EX0xBQkVMX0ZPTlRfU0laRSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHBhcmFtcy5iYXNlRm9udEZhbWlseVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaCByZW5kZXJlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyID0gcGx1Z2luRmFjdG9yeS5nZXQobGliVHlwZSwgJ2NpcmNsZUxlZ2VuZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgbGFiZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWwgLSBsYWJlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsTGVuZ3RoIC0gZGVjaW1hbCBsZW5ndGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Zvcm1hdExhYmVsOiBmdW5jdGlvbihsYWJlbCwgZGVjaW1hbExlbmd0aCkge1xuICAgICAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpO1xuXG4gICAgICAgIGlmIChkZWNpbWFsTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsYWJlbCA9IFN0cmluZyhwYXJzZUludChsYWJlbCwgMTApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsID0gU3RyaW5nKGxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsID0gcmVuZGVyVXRpbC5mb3JtYXRUb0RlY2ltYWwobGFiZWwsIGRlY2ltYWxMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlclV0aWwuZm9ybWF0VmFsdWUobGFiZWwsIGZvcm1hdEZ1bmN0aW9ucywgJ2NpcmNsZUxlZ2VuZCcsICdyJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGFiZWwgaHRtbC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMYWJlbEh0bWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBib3VuZHNNYWtlciA9IHRoaXMuYm91bmRzTWFrZXI7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2NpcmNsZUxlZ2VuZCcpO1xuICAgICAgICB2YXIgaGFsZldpZHRoID0gZGltZW5zaW9uLndpZHRoIC8gMjtcbiAgICAgICAgdmFyIG1heFBpeGVsUmFkaXVzID0gYm91bmRzTWFrZXIuZ2V0TWluaW11bVBpeGVsU3RlcEZvckF4aXMoKTtcbiAgICAgICAgdmFyIG1heFZhbHVlUmFkaXVzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldE1heFZhbHVlKHRoaXMuY2hhcnRUeXBlLCAncicpO1xuICAgICAgICB2YXIgZGVjaW1hbExlbmd0aCA9IHR1aS51dGlsLmdldERlY2ltYWxMZW5ndGgobWF4VmFsdWVSYWRpdXMpO1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQobWF4VmFsdWVSYWRpdXMsIHRoaXMubGFiZWxUaGVtZSk7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0aGlzLmNpcmNsZVJhdGlvcywgZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgICAgIHZhciBkaWFtZXRlciA9IG1heFBpeGVsUmFkaXVzICogcmF0aW8gKiAyO1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gc2VsZi5fZm9ybWF0TGFiZWwobWF4VmFsdWVSYWRpdXMgKiByYXRpbywgZGVjaW1hbExlbmd0aCk7XG4gICAgICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCBzZWxmLmxhYmVsVGhlbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGxlZ2VuZFRlbXBsYXRlLnRwbENpcmNsZUxlZ2VuZExhYmVsKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBoYWxmV2lkdGggLSAobGFiZWxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgIHRvcDogZGltZW5zaW9uLmhlaWdodCAtIGRpYW1ldGVyIC0gbGFiZWxIZWlnaHQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBsYWJlbCBhcmVhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckxhYmVsQXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYWJlbENvbnRhaW5lciA9IGRvbS5jcmVhdGUoJ0RJVicsICd0dWktY2hhcnQtY2lyY2xlLWxlZ2VuZC1sYWJlbC1hcmVhJyk7XG5cbiAgICAgICAgbGFiZWxDb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy5fbWFrZUxhYmVsSHRtbCgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbENvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBmb3IgY2lyY2xlIGxlZ2VuZCBhcmVhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaXJjbGVDb250YWluZXIgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LWNpcmNsZS1hcmVhJyk7XG4gICAgICAgIHZhciBtYXhSYWRpdXMgPSB0aGlzLmJvdW5kc01ha2VyLmdldE1pbmltdW1QaXhlbFN0ZXBGb3JBeGlzKCk7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignY2lyY2xlTGVnZW5kJyk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0UG9zaXRpb24oJ2NpcmNsZUxlZ2VuZCcpO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNpcmNsZUNvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlbmRlcihjaXJjbGVDb250YWluZXIsIGRpbWVuc2lvbiwgbWF4UmFkaXVzLCB0aGlzLmNpcmNsZVJhdGlvcyk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyTGFiZWxBcmVhKCk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24odGhpcy5jb250YWluZXIsIHBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyLlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVyZW5kZXIuXG4gICAgICovXG4gICAgcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplLlxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVyZW5kZXIoKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGVMZWdlbmQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgIExlZ2VuZCBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMZWdlbmRNb2RlbCA9IHJlcXVpcmUoJy4vbGVnZW5kTW9kZWwnKSxcbiAgICBMZWdlbmREaW1lbnNpb25Nb2RlbCA9IHJlcXVpcmUoJy4vbGVnZW5kRGltZW5zaW9uTW9kZWwnKSxcbiAgICBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpLFxuICAgIGV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2V2ZW50TGlzdGVuZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyksXG4gICAgbGVnZW5kVGVtcGxhdGUgPSByZXF1aXJlKCcuLy4uL2xlZ2VuZHMvbGVnZW5kVGVtcGxhdGUnKTtcblxudmFyIExlZ2VuZCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgTGVnZW5kLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTGVnZW5kIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBMZWdlbmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqICAgICAgQHBhcmFtIHs/QXJyYXkuPHN0cmluZz59IHBhcmFtcy5jaGFydFR5cGVzIGNoYXJ0IHR5cGVzXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0IHR5cGVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxlZ2VuZERhdGE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxlZ2VuZCB0aGVtZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IHBhcmFtcy50aGVtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogb3B0aW9uc1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gcGFyYW1zLm9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IHR5cGVzXG4gICAgICAgICAqIEB0eXBlIHs/QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZXMgPSBwYXJhbXMuY2hhcnRUeXBlcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhcnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1c2VyIGV2ZW50IG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VyRXZlbnQgPSBwYXJhbXMudXNlckV2ZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZWdlbmQgdmlldyBjbGFzc05hbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jaGFydC1sZWdlbmQtYXJlYSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrZWQgaW5kZXhlc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrZWRJbmRleGVzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIGxlZ2VuZERhdGEgPSBwYXJhbXMuZGF0YVByb2Nlc3Nvci5nZXRMZWdlbmREYXRhKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsZWdlbmQgbW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVnZW5kTW9kZWwgPSBuZXcgTGVnZW5kTW9kZWwoe1xuICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXG4gICAgICAgICAgICBsYWJlbHM6IHBhcmFtcy5kYXRhUHJvY2Vzc29yLmdldExlZ2VuZExhYmVscygpLFxuICAgICAgICAgICAgbGVnZW5kRGF0YTogbGVnZW5kRGF0YSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZXM6IHRoaXMuY2hhcnRUeXBlcyxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kaW1lbnNpb25Nb2RlbCA9IG5ldyBMZWdlbmREaW1lbnNpb25Nb2RlbCh7XG4gICAgICAgICAgICBsZWdlbmRMYWJlbHM6IHR1aS51dGlsLnBsdWNrKGxlZ2VuZERhdGEsICdsYWJlbCcpLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIHRoZW1lOiB0aGlzLnRoZW1lXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBsZWdlbmQgZGltZW5zaW9uLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYXJ0V2lkdGggPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignY2hhcnQnKS53aWR0aDtcbiAgICAgICAgdmFyIGxlZ2VuZERpbWVuc2lvbiA9IHRoaXMuZGltZW5zaW9uTW9kZWwubWFrZURpbWVuc2lvbihjaGFydFdpZHRoKTtcblxuICAgICAgICB0aGlzLmJvdW5kc01ha2VyLnJlZ2lzdGVyQmFzZURpbWVuc2lvbignbGVnZW5kJywgbGVnZW5kRGltZW5zaW9uKTtcblxuICAgICAgICBpZiAoIXByZWRpY2F0ZS5pc0hvcml6b250YWxMZWdlbmQodGhpcy5vcHRpb25zLmFsaWduKSAmJiB0aGlzLm9wdGlvbnMuaGlkZGVuICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kc01ha2VyLnJlZ2lzdGVyQmFzZURpbWVuc2lvbignY2FsY3VsYXRpb25MZWdlbmQnLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGxlZ2VuZERpbWVuc2lvbi53aWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxlZ2VuZCBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxlZ2VuZENvbnRhaW5lciBsZWdlbmQgY29udGFpbmVyXG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmQgbGVuZ2VuZCBib3VuZFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGJvb2xlYW4+fSBjaGVja2VkSW5kZXhlcyBjaGVja2VkIGluZGV4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJMZWdlbmRBcmVhOiBmdW5jdGlvbihsZWdlbmRDb250YWluZXIpIHtcbiAgICAgICAgbGVnZW5kQ29udGFpbmVyLmlubmVySFRNTCA9IHRoaXMuX21ha2VMZWdlbmRIdG1sKHRoaXMubGVnZW5kTW9kZWwuZ2V0RGF0YSgpKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihsZWdlbmRDb250YWluZXIsIHRoaXMuYm91bmRzTWFrZXIuZ2V0UG9zaXRpb24oJ2xlZ2VuZCcpKTtcbiAgICAgICAgbGVnZW5kQ29udGFpbmVyLnN0eWxlLmNzc1RleHQgKz0gJzsnICsgcmVuZGVyVXRpbC5tYWtlRm9udENzc1RleHQodGhpcy50aGVtZS5sYWJlbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBsZWdlbmQgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gbGVnZW5kIGVsZW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWwgPSBkb20uY3JlYXRlKCdESVYnLCB0aGlzLmNsYXNzTmFtZSk7XG5cbiAgICAgICAgdGhpcy5sZWdlbmRDb250YWluZXIgPSBlbDtcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzSG9yaXpvbnRhbExlZ2VuZCh0aGlzLm9wdGlvbnMuYWxpZ24pKSB7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3MoZWwsICdob3Jpem9udGFsJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZW5kZXJMZWdlbmRBcmVhKGVsKTtcbiAgICAgICAgdGhpcy5fYXR0YWNoRXZlbnQoZWwpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcmVuZGVyLlxuICAgICAqL1xuICAgIHJlcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kQXJlYSh0aGlzLmxlZ2VuZENvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBsZWdlbmQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckxlZ2VuZEFyZWEodGhpcy5sZWdlbmRDb250YWluZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNzc1RleHQgb2YgbGVnZW5kIHJlY3QuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBjaGFydFR5cGU6IHN0cmluZyxcbiAgICAgKiAgICAgIHRoZW1lOiB7Y29sb3I6IHN0cmluZywgYm9yZGVyQ29sb3I6ID9zdHJpbmcsIHNpbmdsZUNvbG9yOiA/c3RyaW5nfVxuICAgICAqIH19IGxlZ2VuZERhdHVtIGxlZ2VuZCBkYXR1bVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlTWFyZ2luVG9wIGJhc2UgbWFyZ2luLXRvcFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGNzc1RleHQgb2YgbGVnZW5kIHJlY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGVnZW5kUmVjdENzc1RleHQ6IGZ1bmN0aW9uKGxlZ2VuZERhdHVtLCBiYXNlTWFyZ2luVG9wKSB7XG4gICAgICAgIHZhciB0aGVtZSA9IGxlZ2VuZERhdHVtLnRoZW1lLFxuICAgICAgICAgICAgYm9yZGVyQ3NzVGV4dCA9IHRoZW1lLmJvcmRlckNvbG9yID8gcmVuZGVyVXRpbC5jb25jYXRTdHIoJztib3JkZXI6MXB4IHNvbGlkICcsIHRoZW1lLmJvcmRlckNvbG9yKSA6ICcnLFxuICAgICAgICAgICAgcmVjdE1hcmdpbiwgbWFyZ2luVG9wO1xuICAgICAgICBpZiAobGVnZW5kRGF0dW0uY2hhcnRUeXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgIG1hcmdpblRvcCA9IGJhc2VNYXJnaW5Ub3AgKyBjaGFydENvbnN0LkxJTkVfTUFSR0lOX1RPUDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmdpblRvcCA9IGJhc2VNYXJnaW5Ub3A7XG4gICAgICAgIH1cblxuICAgICAgICByZWN0TWFyZ2luID0gcmVuZGVyVXRpbC5jb25jYXRTdHIoJzttYXJnaW4tdG9wOicsIG1hcmdpblRvcCwgJ3B4Jyk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlclV0aWwuY29uY2F0U3RyKCdiYWNrZ3JvdW5kLWNvbG9yOicsIHRoZW1lLnNpbmdsZUNvbG9yIHx8IHRoZW1lLmNvbG9yLCBib3JkZXJDc3NUZXh0LCByZWN0TWFyZ2luKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxhYmVscyB3aWR0aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7Y2hhcnRUeXBlOiA/c3RyaW5nLCBsYWJlbDogc3RyaW5nfT59IGxlZ2VuZERhdGEgbGVnZW5kIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IGxhYmVscyB3aWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMYWJlbHNXaWR0aDogZnVuY3Rpb24obGVnZW5kRGF0YSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChsZWdlbmREYXRhLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGl0ZW0ubGFiZWwsIHNlbGYudGhlbWUubGFiZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsV2lkdGggKyBjaGFydENvbnN0LkxFR0VORF9BUkVBX1BBRERJTkc7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxlZ2VuZCBodG1sLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHtjaGFydFR5cGU6ID9zdHJpbmcsIGxhYmVsOiBzdHJpbmd9Pn0gbGVnZW5kRGF0YSBsZWdlbmQgZGF0YVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGxlZ2VuZCBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxlZ2VuZEh0bWw6IGZ1bmN0aW9uKGxlZ2VuZERhdGEpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgdGVtcGxhdGUgPSBsZWdlbmRUZW1wbGF0ZS50cGxMZWdlbmQsXG4gICAgICAgICAgICBjaGVja0JveFRlbXBsYXRlID0gbGVnZW5kVGVtcGxhdGUudHBsQ2hlY2tib3gsXG4gICAgICAgICAgICBsYWJlbHNXaWR0aCA9IHRoaXMuX21ha2VMYWJlbHNXaWR0aChsZWdlbmREYXRhKSxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGxlZ2VuZERhdGFbMF0ubGFiZWwsIGxlZ2VuZERhdGFbMF0udGhlbWUpLFxuICAgICAgICAgICAgaXNIb3Jpem9udGFsTGVnZW5kID0gcHJlZGljYXRlLmlzSG9yaXpvbnRhbExlZ2VuZCh0aGlzLm9wdGlvbnMuYWxpZ24pLFxuICAgICAgICAgICAgaGVpZ2h0ID0gbGFiZWxIZWlnaHQgKyAoY2hhcnRDb25zdC5MQUJFTF9QQURESU5HX1RPUCAqIDIpLFxuICAgICAgICAgICAgYmFzZU1hcmdpblRvcCA9IHBhcnNlSW50KChoZWlnaHQgLSBjaGFydENvbnN0LkxFR0VORF9SRUNUX1dJRFRIKSAvIDIsIDEwKSAtIDEsXG4gICAgICAgICAgICBodG1sID0gdHVpLnV0aWwubWFwKGxlZ2VuZERhdGEsIGZ1bmN0aW9uKGxlZ2VuZERhdHVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciByZWN0Q3NzVGV4dCA9IHNlbGYuX21ha2VMZWdlbmRSZWN0Q3NzVGV4dChsZWdlbmREYXR1bSwgYmFzZU1hcmdpblRvcCksXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrYm94ID0gc2VsZi5vcHRpb25zLmhhc0NoZWNrYm94ID09PSBmYWxzZSA/ICcnIDogY2hlY2tCb3hUZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBzZWxmLmxlZ2VuZE1vZGVsLmlzQ2hlY2tlZEluZGV4KGluZGV4KSA/ICcgY2hlY2tlZCcgOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTtcblxuICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3RDc3NUZXh0OiByZWN0Q3NzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsSGVpZ2h0OiBsYWJlbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3RlZDogc2VsZi5sZWdlbmRNb2RlbC5pc1Vuc2VsZWN0ZWRJbmRleChpbmRleCkgPyAnIHVuc2VsZWN0ZWQnIDogJycsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsV2lkdGg6IGlzSG9yaXpvbnRhbExlZ2VuZCA/ICc7d2lkdGg6JyArIGxhYmVsc1dpZHRoW2luZGV4XSArICdweCcgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgaWNvblR5cGU6IGxlZ2VuZERhdHVtLmNoYXJ0VHlwZSB8fCAncmVjdCcsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsZWdlbmREYXR1bS5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3g6IGNoZWNrYm94LFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZShkYXRhKTtcbiAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBsZWdlbmQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRhcmdldCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gbGVnZW5kIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTGVnZW5kTGFiZWxFbGVtZW50OiBmdW5jdGlvbihlbFRhcmdldCkge1xuICAgICAgICB2YXIgbGVnZW5kQ29udGFpbmVyO1xuXG4gICAgICAgIGlmIChkb20uaGFzQ2xhc3MoZWxUYXJnZXQsIGNoYXJ0Q29uc3QuQ0xBU1NfTkFNRV9MRUdFTkRfTEFCRUwpKSB7XG4gICAgICAgICAgICBsZWdlbmRDb250YWluZXIgPSBlbFRhcmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZ2VuZENvbnRhaW5lciA9IGRvbS5maW5kUGFyZW50QnlDbGFzcyhlbFRhcmdldCwgY2hhcnRDb25zdC5DTEFTU19OQU1FX0xFR0VORF9MQUJFTCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVnZW5kQ29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlIGxlZ2VuZCBjaGVja2JveCBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlTGVnZW5kQ2hlY2tib3hFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlQ2hlY2tlZExlZ2VuZHMnLCB0aGlzLmxlZ2VuZE1vZGVsLmdldENoZWNrZWRJbmRleGVzKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlIGxlZ2VuZCBldmVudC5cbiAgICAgKiBAcGFyYW0ge3tjaGFydFR5cGU6IHN0cmluZywgaW5kZXg6IG51bWJlcn19IGRhdGEgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVMZWdlbmRTZWxlY3Rpb25FdmVudDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBjaGFydFR5cGVzID0gdGhpcy5jaGFydFR5cGVzIHx8IFtkYXRhLmNoYXJ0VHlwZV0sXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMubGVnZW5kTW9kZWwuZ2V0U2VsZWN0ZWRJbmRleCgpLFxuICAgICAgICAgICAgbGVnZW5kSW5kZXggPSAhdHVpLnV0aWwuaXNOdWxsKGluZGV4KSA/IGRhdGEuc2VyaWVzSW5kZXggOiBpbmRleDtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICBzZWxmLmZpcmUocmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzZWxlY3QnLCBjaGFydFR5cGUsICdsZWdlbmQnKSwgZGF0YS5jaGFydFR5cGUsIGxlZ2VuZEluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmUgdXNlciBldmVudC5cbiAgICAgKiBAcGFyYW0ge3tsYWJlbDogc3RyaW5nLCBjaGFydFR5cGU6IHN0cmluZywgaW5kZXg6IG51bWJlcn19IGRhdGEgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVVc2VyRXZlbnQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnc2VsZWN0TGVnZW5kJywge1xuICAgICAgICAgICAgbGVnZW5kOiBkYXRhLmxhYmVsLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBkYXRhLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIGluZGV4OiBkYXRhLmluZGV4XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbGVjdExlZ2VuZDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmxlZ2VuZE1vZGVsLmdldERhdHVtKGluZGV4KTtcblxuICAgICAgICB0aGlzLmxlZ2VuZE1vZGVsLnRvZ2dsZVNlbGVjdGVkSW5kZXgoaW5kZXgpO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNOdWxsKHRoaXMubGVnZW5kTW9kZWwuZ2V0U2VsZWN0ZWRJbmRleCgpKSAmJiAhdGhpcy5sZWdlbmRNb2RlbC5pc0NoZWNrZWRTZWxlY3RlZEluZGV4KCkpIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kTW9kZWwuY2hlY2tTZWxlY3RlZEluZGV4KCk7XG4gICAgICAgICAgICB0aGlzLl9maXJlTGVnZW5kQ2hlY2tib3hFdmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kQXJlYSh0aGlzLmxlZ2VuZENvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5fZmlyZUxlZ2VuZFNlbGVjdGlvbkV2ZW50KGRhdGEpO1xuICAgICAgICB0aGlzLl9maXJlVXNlckV2ZW50KGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2hlY2tlZCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY2hlY2tlZCBpbmRleGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q2hlY2tlZEluZGV4ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hlY2tlZEluZGV4ZXMgPSBbXTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMubGVnZW5kQ29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpLCBmdW5jdGlvbihjaGVja2JveCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tlZEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hlY2tlZEluZGV4ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGxlZ2VuZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja0xlZ2VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGVja2VkSW5kZXhlcyA9IHRoaXMuX2dldENoZWNrZWRJbmRleGVzKCksXG4gICAgICAgICAgICBjaGVja2VkQ291bnQgPSBjaGVja2VkSW5kZXhlcy5sZW5ndGgsXG4gICAgICAgICAgICBkYXRhO1xuXG4gICAgICAgIGlmICgocHJlZGljYXRlLmlzUGllQ2hhcnQodGhpcy5jaGFydFR5cGUpICYmIGNoZWNrZWRDb3VudCA9PT0gMSkgfHwgY2hlY2tlZENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJMZWdlbmRBcmVhKHRoaXMubGVnZW5kQ29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kTW9kZWwudXBkYXRlQ2hlY2tlZERhdGEoY2hlY2tlZEluZGV4ZXMpO1xuXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5sZWdlbmRNb2RlbC5nZXRTZWxlY3RlZERhdHVtKCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5sZWdlbmRNb2RlbC5pc0NoZWNrZWRTZWxlY3RlZEluZGV4KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlZ2VuZE1vZGVsLnVwZGF0ZVNlbGVjdGVkSW5kZXgobnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckxlZ2VuZEFyZWEodGhpcy5sZWdlbmRDb250YWluZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9maXJlTGVnZW5kQ2hlY2tib3hFdmVudCgpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVMZWdlbmRTZWxlY3Rpb25FdmVudChkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGljayBldmVudCBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGVsVGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxuICAgICAgICAgICAgbGVnZW5kQ29udGFpbmVyLCBpbmRleDtcblxuICAgICAgICBpZiAoZG9tLmhhc0NsYXNzKGVsVGFyZ2V0LCBjaGFydENvbnN0LkNMQVNTX05BTUVfTEVHRU5EX0NIRUNLQk9YKSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tMZWdlbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlZ2VuZENvbnRhaW5lciA9IHRoaXMuX2ZpbmRMZWdlbmRMYWJlbEVsZW1lbnQoZWxUYXJnZXQpO1xuXG4gICAgICAgIGlmICghbGVnZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9IHBhcnNlSW50KGxlZ2VuZENvbnRhaW5lci5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKSwgMTApO1xuICAgICAgICB0aGlzLl9zZWxlY3RMZWdlbmQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYnJvd3NlciBldmVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdHRhY2hFdmVudDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdjbGljaycsIHRhcmdldCwgdGhpcy5fb25DbGljaywgdGhpcyk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihMZWdlbmQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExlZ2VuZDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBMZWdlbmREaW1lbnNpb25Nb2RlbCBpcyBsZWdlbmQgZGltZW5zaW9uIG1vZGVsLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbnZhciBMZWdlbmREaW1lbnNpb25Nb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgTGVnZW5kRGltZW5zaW9uTW9kZWwucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBMZWdlbmREaW1lbnNpb25Nb2RlbCBpcyBsZWdlbmQgZGltZW5zaW9uIG1vZGVsLlxuICAgICAqIEBjb25zdHJ1Y3RzIExlZ2VuZERpbWVuc2lvbk1vZGVsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgbGVnZW5kIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgbGVnZW5kIHRoZW1lXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmcgfCBudW1iZXI+fSBwYXJhbXMubGVnZW5kTGFiZWxzIGxlZ2VuZCBsYWJlbHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuXG4gICAgICAgIHRoaXMudGhlbWUgPSBwYXJhbXMudGhlbWU7XG5cbiAgICAgICAgdGhpcy5sZWdlbmRMYWJlbHMgPSBwYXJhbXMubGVnZW5kTGFiZWxzO1xuXG4gICAgICAgIHRoaXMubGVnZW5kQ2hlY2tib3hXaWR0aCA9IHRoaXMub3B0aW9ucy5oYXNDaGVja2JveCA9PT0gZmFsc2UgPyAwIDogY2hhcnRDb25zdC5MRUdFTkRfQ0hFQ0tCT1hfV0lEVEg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGVnZW5kIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbFdpZHRoIGxhYmVsIHdpZHRoXG4gICAgICogQHJldHVybnMge251bWJlcn0gbGVnZW5kIHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxlZ2VuZFdpZHRoOiBmdW5jdGlvbihsYWJlbFdpZHRoKSB7XG4gICAgICAgIHJldHVybiBsYWJlbFdpZHRoICsgdGhpcy5sZWdlbmRDaGVja2JveFdpZHRoICsgY2hhcnRDb25zdC5MRUdFTkRfUkVDVF9XSURUSCArXG4gICAgICAgICAgICBjaGFydENvbnN0LkxFR0VORF9MQUJFTF9MRUZUX1BBRERJTkcgKyBjaGFydENvbnN0LkxFR0VORF9BUkVBX1BBRERJTkc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBzdW0gb2YgbGVnZW5kcyB3aWR0aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBsYWJlbHMgbGVnZW5kIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IG51bWJlcn19IGxhYmVsVGhlbWUgbGVnZW5kIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gc3VtIG9mIHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlTGVnZW5kc1dpZHRoU3VtOiBmdW5jdGlvbihsYWJlbHMsIGxhYmVsVGhlbWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5zdW0odHVpLnV0aWwubWFwKGxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9tYWtlTGVnZW5kV2lkdGgocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGFiZWwsIGxhYmVsVGhlbWUpKTtcbiAgICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgbGVnZW5kIGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBsYWJlbHMgbGVnZW5kIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBkaXZpc2lvbiBjb3VudFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPHN0cmluZz4+fSBkaXZpZGVkIGxhYmVsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RpdmlkZUxlZ2VuZExhYmVsczogZnVuY3Rpb24obGFiZWxzLCBjb3VudCkge1xuICAgICAgICB2YXIgbGltaXRDb3VudCA9IE1hdGgucm91bmQobGFiZWxzLmxlbmd0aCAvIGNvdW50KSxcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgIHRlbXAgPSBbXTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkobGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgaWYgKHRlbXAubGVuZ3RoIDwgbGltaXRDb3VudCkge1xuICAgICAgICAgICAgICAgIHRlbXAucHVzaChsYWJlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgICAgICB0ZW1wID0gW2xhYmVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRlbXAubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGVtcCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IG1heCBsaW5lIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGRpdmlkZWRMYWJlbHMgZGl2aWRlZCBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge3tmb250RmFtaWx5OiA/c3RyaW5nLCBmb250U2l6ZTogP3N0cmluZ319IGxhYmVsVGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBtYXggbGluZSB3aWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE1heExpbmVXaWR0aDogZnVuY3Rpb24oZGl2aWRlZExhYmVscywgbGFiZWxUaGVtZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBsaW5lV2lkdGhzID0gdHVpLnV0aWwubWFwKGRpdmlkZWRMYWJlbHMsIGZ1bmN0aW9uKF9sYWJlbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fY2FsY3VsYXRlTGVnZW5kc1dpZHRoU3VtKF9sYWJlbHMsIGxhYmVsVGhlbWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1heChsaW5lV2lkdGhzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBkaXZpc2lvbiBsYWJlbHMgYW5kIG1heCBsaW5lIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVscyBsZWdlbmQgbGFiZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYXJ0V2lkdGggY2hhcnQgd2lkdGhcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBudW1iZXJ9fSBsYWJlbFRoZW1lIGxlZ2VuZCBsYWJlbCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHt7ZGl2aWRlZExhYmVsczogQXJyYXkuPEFycmF5LjxzdHJpbmc+PiwgbWF4TGluZVdpZHRoOiBudW1iZXJ9fSByZXN1bHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlRGl2aWRlZExhYmVsc0FuZE1heExpbmVXaWR0aDogZnVuY3Rpb24obGFiZWxzLCBjaGFydFdpZHRoLCBsYWJlbFRoZW1lKSB7XG4gICAgICAgIHZhciBkaXZpZGVDb3VudCA9IDEsXG4gICAgICAgICAgICBtYXhMaW5lV2lkdGggPSAwLFxuICAgICAgICAgICAgcHJldk1heFdpZHRoID0gMCxcbiAgICAgICAgICAgIGRpdmlkZWRMYWJlbHMsIHByZXZMYWJlbHM7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZGl2aWRlZExhYmVscyA9IHRoaXMuX2RpdmlkZUxlZ2VuZExhYmVscyhsYWJlbHMsIGRpdmlkZUNvdW50KTtcbiAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IHRoaXMuX2dldE1heExpbmVXaWR0aChkaXZpZGVkTGFiZWxzLCBsYWJlbFRoZW1lKTtcblxuICAgICAgICAgICAgaWYgKHByZXZNYXhXaWR0aCA9PT0gbWF4TGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgZGl2aWRlZExhYmVscyA9IHByZXZMYWJlbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZNYXhXaWR0aCA9IG1heExpbmVXaWR0aDtcbiAgICAgICAgICAgIHByZXZMYWJlbHMgPSBkaXZpZGVkTGFiZWxzO1xuICAgICAgICAgICAgZGl2aWRlQ291bnQgKz0gMTtcbiAgICAgICAgfSB3aGlsZSAobWF4TGluZVdpZHRoID49IGNoYXJ0V2lkdGgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXZpZGVkTGFiZWxzOiBkaXZpZGVkTGFiZWxzLFxuICAgICAgICAgICAgbWF4TGluZVdpZHRoOiBtYXhMaW5lV2lkdGhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGhlaWdodCBvZiBob3Jpem9udGFsIGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48c3RyaW5nPj59IGRpdmlkZWRMYWJlbHMgZGl2aWRlZCBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBudW1iZXJ9fSBsYWJlbFRoZW1lIGxlZ2VuZCBsYWJlbCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGxlZ2VuZCBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVIb3Jpem9udGFsTGVnZW5kSGVpZ2h0OiBmdW5jdGlvbihkaXZpZGVkTGFiZWxzLCBsYWJlbFRoZW1lKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5zdW0odHVpLnV0aWwubWFwKGRpdmlkZWRMYWJlbHMsIGZ1bmN0aW9uKGxhYmVscykge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhIZWlnaHQobGFiZWxzLCBsYWJlbFRoZW1lKTtcbiAgICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRpbWVuc2lvbiBvZiBob3Jpem9udGFsIGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhcnRXaWR0aCBjaGFydCB3aWR0aFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IG51bWJlcn19IGxhYmVsVGhlbWUgbGVnZW5kIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IChudW1iZXIpfX0gZGltZW5zaW9uIG9mIGhvcml6b250YWwgbGVnZW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUhvcml6b250YWxEaW1lbnNpb246IGZ1bmN0aW9uKGNoYXJ0V2lkdGgpIHtcbiAgICAgICAgdmFyIGxhYmVsVGhlbWUgPSB0aGlzLnRoZW1lLmxhYmVsLFxuICAgICAgICAgICAgbGFiZWxzQW5kTWF4V2lkdGggPSB0aGlzLl9tYWtlRGl2aWRlZExhYmVsc0FuZE1heExpbmVXaWR0aCh0aGlzLmxlZ2VuZExhYmVscywgY2hhcnRXaWR0aCwgbGFiZWxUaGVtZSksXG4gICAgICAgICAgICBob3Jpem9udGFsTGVnZW5kSGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlSG9yaXpvbnRhbExlZ2VuZEhlaWdodChsYWJlbHNBbmRNYXhXaWR0aC5kaXZpZGVkTGFiZWxzLCBsYWJlbFRoZW1lKSxcbiAgICAgICAgICAgIGxlZ2VuZEhlaWdodCA9IGhvcml6b250YWxMZWdlbmRIZWlnaHQgKyAoY2hhcnRDb25zdC5MRUdFTkRfQVJFQV9QQURESU5HICogMik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBsYWJlbHNBbmRNYXhXaWR0aC5tYXhMaW5lV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGxlZ2VuZEhlaWdodFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRpbWVuc2lvbiBvZiB2ZXJ0aWNhbCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogbnVtYmVyfX0gbGFiZWxUaGVtZSBsZWdlbmQgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiAobnVtYmVyKX19IGRpbWVuc2lvbiBvZiB2ZXJ0aWNhbCBsZWdlbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmVydGljYWxEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWF4TGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhXaWR0aCh0aGlzLmxlZ2VuZExhYmVscywgdGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBsZWdlbmRXaWR0aCA9IHRoaXMuX21ha2VMZWdlbmRXaWR0aChtYXhMYWJlbFdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBsZWdlbmRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHNraXBwZWQgbGVnZW5kIHNpemluZyBvciBub3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNTa2lwTGVnZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlzUGllQ2hhcnQgPSBwcmVkaWNhdGUuaXNQaWVDaGFydCh0aGlzLmNoYXJ0VHlwZSksXG4gICAgICAgICAgICBpc1BpZUxlZ2VuZEFsaWduID0gcHJlZGljYXRlLmlzUGllQ2hhcnQodGhpcy5jaGFydFR5cGUpICYmIHByZWRpY2F0ZS5pc1BpZUxlZ2VuZEFsaWduKHRoaXMub3B0aW9ucy5hbGlnbik7XG5cbiAgICAgICAgcmV0dXJuIChpc1BpZUNoYXJ0ICYmIGlzUGllTGVnZW5kQWxpZ24pIHx8IHRoaXMub3B0aW9ucy5oaWRkZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGVnZW5kIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhcnRXaWR0aCBjaGFydCB3aWR0aFxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBsZWdlbmQgZGltZW50aW9uXG4gICAgICovXG4gICAgbWFrZURpbWVuc2lvbjogZnVuY3Rpb24oY2hhcnRXaWR0aCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzU2tpcExlZ2VuZCgpKSB7XG4gICAgICAgICAgICBkaW1lbnNpb24ud2lkdGggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWRpY2F0ZS5pc0hvcml6b250YWxMZWdlbmQodGhpcy5vcHRpb25zLmFsaWduKSkge1xuICAgICAgICAgICAgZGltZW5zaW9uID0gdGhpcy5fbWFrZUhvcml6b250YWxEaW1lbnNpb24oY2hhcnRXaWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSB0aGlzLl9tYWtlVmVydGljYWxEaW1lbnNpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaW1lbnNpb247XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGVnZW5kRGltZW5zaW9uTW9kZWw7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTGVnZW5kTW9kZWwgaXMgbGVnZW5kIG1vZGVsLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdFRoZW1lID0gcmVxdWlyZSgnLi4vdGhlbWVzL2RlZmF1bHRUaGVtZScpO1xuXG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxudmFyIExlZ2VuZE1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBMZWdlbmRNb2RlbC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIExlZ2VuZE1vZGVsIGlzIGxlZ2VuZCBtb2RlbC5cbiAgICAgKiBAY29uc3RydWN0cyBMZWdlbmRNb2RlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbHMgbGVnZW5kIGxhYmVsc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5ib3VuZCBheGlzIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIGF4aXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxlZ2VuZCB0aGVtZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IHBhcmFtcy50aGVtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbGVnZW5kIGxhYmVsc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz4gfCB7Y29sdW1uOiA/QXJyYXkuPHN0cmluZz4sIGxpbmU6ID9BcnJheS48c3RyaW5nPn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhYmVscyA9IHBhcmFtcy5sYWJlbHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxhYmVsIGluZm9zXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48e2NoYXJ0VHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nLCBpbmRleDogbnVtYmVyfT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlZ2VuZERhdGEgPSBwYXJhbXMubGVnZW5kRGF0YTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhcnQgdHlwZXNcbiAgICAgICAgICogQHR5cGUgez9BcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlcyA9IHBhcmFtcy5jaGFydFR5cGVzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IHBhcmFtcy5jaGFydFR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExlZ2VuZCBkYXRhXG4gICAgICAgICAqIEB0eXBlIHs/QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3RlZCBsZWdlbmQgaW5kZXguXG4gICAgICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2VuZGluZyBkYXRhIHRvIHNlcmllc1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja2VkSW5kZXhlc01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVja2VkIGluZGV4ZXNcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja2VkV2hvbGVJbmRleGVzID0gW107XG5cbiAgICAgICAgdGhpcy5faW5pdENoZWNrZWRJbmRleGVzKCk7XG4gICAgICAgIHRoaXMuX3NldERhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBjaGVja2VkIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdENoZWNrZWRJbmRleGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoZWNrZWRXaG9sZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMubGVnZW5kRGF0YSwgZnVuY3Rpb24obGVnZW5kRGF0dW0sIGluZGV4KSB7XG4gICAgICAgICAgICBjaGVja2VkV2hvbGVJbmRleGVzW2luZGV4XSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoZWNrZWRXaG9sZUluZGV4ZXMgPSBjaGVja2VkV2hvbGVJbmRleGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxhYmVsIGluZm8gdGhhdCBhcHBsaWVkIHRoZW1lLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IGxlZ2VuZERhdGEgbGVnZW5kIGRhdGFcbiAgICAgKiBAcGFyYW0ge3tjb2xvcnM6IEFycmF5LjxudW1iZXI+LCBzaW5nbGVDb2xvcjogP3N0cmluZywgYm9yZGVyY29sb3I6ID9zdHJpbmd9fSB0aGVtZSBsZWdlbmQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljxib29sZWFuPn0gY2hlY2tlZEluZGV4ZXMgY2hlY2tlZCBpbmRleGVzXG4gICAgICogQHJldHVybnMge0FycmF5LjxvYmplY3Q+fSBsYWJlbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxJbmZvQXBwbGllZFRoZW1lOiBmdW5jdGlvbihsZWdlbmREYXRhLCB0aGVtZSwgY2hlY2tlZEluZGV4ZXMpIHtcbiAgICAgICAgdmFyIHNlcmllc0luZGV4ID0gMDtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGxlZ2VuZERhdGEsIGZ1bmN0aW9uKGRhdHVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1UaGVtZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhlbWUuY29sb3JzW2luZGV4XVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRoZW1lLnNpbmdsZUNvbG9ycyAmJiB0aGVtZS5zaW5nbGVDb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaXRlbVRoZW1lLnNpbmdsZUNvbG9yID0gdGhlbWUuc2luZ2xlQ29sb3JzW2luZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoZW1lLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgaXRlbVRoZW1lLmJvcmRlckNvbG9yID0gdGhlbWUuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdHVtLnRoZW1lID0gaXRlbVRoZW1lO1xuICAgICAgICAgICAgZGF0dW0uaW5kZXggPSBpbmRleDtcblxuICAgICAgICAgICAgaWYgKCFjaGVja2VkSW5kZXhlcyB8fCAhdHVpLnV0aWwuaXNVbmRlZmluZWQoY2hlY2tlZEluZGV4ZXNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGRhdHVtLnNlcmllc0luZGV4ID0gc2VyaWVzSW5kZXg7XG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXggKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0dW0uc2VyaWVzSW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdHVtO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGxlZ2VuZCBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBsZWdlbmREYXRhID0gdGhpcy5sZWdlbmREYXRhLFxuICAgICAgICAgICAgZGF0YSwgZGVmYXVsdExlZ2VuZFRoZW1lLCBzdGFydEluZGV4LCBzdGFydFRoZW1lSW5kZXg7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNoYXJ0VHlwZXMpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9tYWtlTGFiZWxJbmZvQXBwbGllZFRoZW1lKGxlZ2VuZERhdGEsIHRoaXMudGhlbWUsIHRoaXMuY2hlY2tlZEluZGV4ZXNNYXBbdGhpcy5jaGFydFR5cGVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAgICAgc3RhcnRUaGVtZUluZGV4ID0gMDtcbiAgICAgICAgICAgIGRlZmF1bHRMZWdlbmRUaGVtZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcnM6IGRlZmF1bHRUaGVtZS5zZXJpZXMuY29sb3JzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YSA9IGNvbmNhdC5hcHBseShbXSwgdHVpLnV0aWwubWFwKHRoaXMuY2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJ0VGhlbWUgPSBzZWxmLnRoZW1lW2NoYXJ0VHlwZV0sXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsTGVuID0gc2VsZi5sYWJlbHNbY2hhcnRUeXBlXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gc3RhcnRJbmRleCArIGxhYmVsTGVuLFxuICAgICAgICAgICAgICAgICAgICBzbGljZWRMZWdlbmREYXRhLCBjaGVja2VkSW5kZXhlcywgdGhlbWVFbmRJbmRleCwgZGF0dW07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNoYXJ0VGhlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhlbWVFbmRJbmRleCA9IHN0YXJ0VGhlbWVJbmRleCArIGxhYmVsTGVuO1xuICAgICAgICAgICAgICAgICAgICBjaGFydFRoZW1lID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkZWZhdWx0TGVnZW5kVGhlbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRUaGVtZS5jb2xvcnMgPSBjaGFydFRoZW1lLmNvbG9ycy5zbGljZShzdGFydFRoZW1lSW5kZXgsIHRoZW1lRW5kSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRoZW1lSW5kZXggPSB0aGVtZUVuZEluZGV4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNsaWNlZExlZ2VuZERhdGEgPSBsZWdlbmREYXRhLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgICAgICAgICAgICBjaGVja2VkSW5kZXhlcyA9IHNlbGYuY2hlY2tlZEluZGV4ZXNNYXBbY2hhcnRUeXBlXTtcbiAgICAgICAgICAgICAgICBkYXR1bSA9IHNlbGYuX21ha2VMYWJlbEluZm9BcHBsaWVkVGhlbWUoc2xpY2VkTGVnZW5kRGF0YSwgY2hhcnRUaGVtZSwgY2hlY2tlZEluZGV4ZXMpO1xuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGVnZW5kIGRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7Y2hhcnRUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcsIHRoZW1lOiBvYmplY3R9Pn0gbGVnZW5kIGRhdGFcbiAgICAgKi9cbiAgICBnZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxlZ2VuZCBkYXR1bSBieSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggbGVnZW5kIGluZGV4XG4gICAgICogQHJldHVybnMge3tjaGFydFR5cGU6IHN0cmluZywgbGFiZWw6IHN0cmluZywgdGhlbWU6IG9iamVjdH19IGxlZ2VuZCBkYXR1bVxuICAgICAqL1xuICAgIGdldERhdHVtOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlbGVjdGVkIGRhdHVtLlxuICAgICAqIEByZXR1cm5zIHt7Y2hhcnRUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcsIHRoZW1lOiBPYmplY3R9fSBsZWdlbmQgZGF0dW1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZERhdHVtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0dW0odGhpcy5zZWxlY3RlZEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHNlbGVjdGVkIGluZGV4LlxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gdmFsdWUgdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGVTZWxlY3RlZEluZGV4OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHNlbGVjdGVkIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKi9cbiAgICB0b2dnbGVTZWxlY3RlZEluZGV4OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleDtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkSW5kZXgoc2VsZWN0ZWRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzZWxlY3RlZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzZWxlY3RlZCBpbmRleFxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkSW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHVuc2VsZWN0ZWQgaW5kZXggb3Igbm90LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBzZWxlY3RlZFxuICAgICAqL1xuICAgIGlzVW5zZWxlY3RlZEluZGV4OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gIXR1aS51dGlsLmlzTnVsbCh0aGlzLnNlbGVjdGVkSW5kZXgpICYmICh0aGlzLnNlbGVjdGVkSW5kZXggIT09IGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjaGVja2VkIHNlbGVjdGVkIGluZGV4IG9yIG5vdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBjaGVja2VkXG4gICAgICovXG4gICAgaXNDaGVja2VkU2VsZWN0ZWRJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQ2hlY2tlZEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjaGVja2VkIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVDaGVja2VkSW5kZXg6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZFdob2xlSW5kZXhlc1tpbmRleF0gPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNoZWNrZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGxlZ2VuZCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGNoZWNrZWRcbiAgICAgKi9cbiAgICBpc0NoZWNrZWRJbmRleDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jaGVja2VkV2hvbGVJbmRleGVzW2luZGV4XTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBBZGQgc2VuZGluZyBkYXR1bS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggbGVnZW5kIGluZGV4XG4gICAgICovXG4gICAgX2FkZFNlbmRpbmdEYXR1bTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGxlZ2VuZERhdHVtID0gdGhpcy5nZXREYXR1bShpbmRleCk7XG4gICAgICAgIGlmICghdGhpcy5jaGVja2VkSW5kZXhlc01hcFtsZWdlbmREYXR1bS5jaGFydFR5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrZWRJbmRleGVzTWFwW2xlZ2VuZERhdHVtLmNoYXJ0VHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrZWRJbmRleGVzTWFwW2xlZ2VuZERhdHVtLmNoYXJ0VHlwZV1bbGVnZW5kRGF0dW0uaW5kZXhdID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgc2VsZWN0ZWQgaW5kZXg7XG4gICAgICovXG4gICAgY2hlY2tTZWxlY3RlZEluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2hlY2tlZEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleCk7XG4gICAgICAgIHRoaXMuX2FkZFNlbmRpbmdEYXR1bSh0aGlzLnNlbGVjdGVkSW5kZXgpO1xuICAgICAgICB0aGlzLl9zZXREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjaGVja2VkIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge3tjb2x1bW46ID9BcnJheS48Ym9vbGVhbj4sIGxpbmU6ID9BcnJheS48Ym9vbGVhbj59IHwgQXJyYXkuPGJvb2xlYW4+fSBzZW5kaW5nIGRhdGFcbiAgICAgKi9cbiAgICBnZXRDaGVja2VkSW5kZXhlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrZWRJbmRleGVzTWFwW3RoaXMuY2hhcnRUeXBlXSB8fCB0aGlzLmNoZWNrZWRJbmRleGVzTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCBjaGVja2VkIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXRDaGVja2VkRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZFdob2xlSW5kZXhlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoZWNrZWRJbmRleGVzTWFwID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjaGVja2VkIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW5kZXhlcyBpbmR4ZXNcbiAgICAgKi9cbiAgICB1cGRhdGVDaGVja2VkRGF0YTogZnVuY3Rpb24oaW5kZXhlcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fcmVzZXRDaGVja2VkRGF0YSgpO1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUNoZWNrZWRJbmRleChpbmRleCk7XG4gICAgICAgICAgICBzZWxmLl9hZGRTZW5kaW5nRGF0dW0oaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2V0RGF0YSgpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExlZ2VuZE1vZGVsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgaXMgdGVtcGxhdGVzIG9mIGxlZ2VuZCB2aWV3LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVtcGxhdGVNYWtlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdGVtcGxhdGVNYWtlcicpO1xuXG52YXIgaHRtbHMgPSB7XG4gICAgSFRNTF9DSEVDS0JPWDogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbGVnZW5kLWNoZWNrYm94LWFyZWFcIj48aW5wdXQgY2xhc3M9XCJ0dWktY2hhcnQtbGVnZW5kLWNoZWNrYm94XCInICtcbiAgICAgICAgJyB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cInt7IGluZGV4IH19XCJ7eyBjaGVja2VkIH19IC8+PC9kaXY+JyxcbiAgICBIVE1MX0xFR0VORDogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbGVnZW5ke3sgdW5zZWxlY3RlZCB9fVwiIHN0eWxlPVwiaGVpZ2h0Ont7IGhlaWdodCB9fXB4XCI+JyArXG4gICAgICAgICd7eyBjaGVja2JveCB9fTxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbGVnZW5kLXJlY3Qge3sgaWNvblR5cGUgfX1cIiBzdHlsZT1cInt7IHJlY3RDc3NUZXh0IH19XCI+PC9kaXY+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LWxlZ2VuZC1sYWJlbFwiIHN0eWxlPVwiaGVpZ2h0Ont7IGxhYmVsSGVpZ2h0IH19cHh7eyBsYWJlbFdpZHRoIH19XCInICtcbiAgICAgICAgICAgICcgZGF0YS1pbmRleD1cInt7IGluZGV4IH19XCI+e3sgbGFiZWwgfX08L2Rpdj48L2Rpdj4nLFxuICAgIEhUTUxfVElDSzogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbWFwLWxlZ2VuZC10aWNrXCIgc3R5bGU9XCJ7eyBwb3NpdGlvbiB9fVwiPjwvZGl2PicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1tYXAtbGVnZW5kLXRpY2stbGFiZWxcIiBzdHlsZT1cInt7IGxhYmVsUG9zaXRpb24gfX1cIj57eyBsYWJlbCB9fTwvZGl2PicsXG4gICAgSFRNTF9DSVJDTEVfTEVHRU5EX0xBQkVMOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1jaXJjbGUtbGVnZW5kLWxhYmVsXCInICtcbiAgICAgICAgICAgICcgc3R5bGU9XCJsZWZ0OiB7eyBsZWZ0IH19cHg7dG9wOiB7eyB0b3AgfX1weFwiPnt7IGxhYmVsIH19PC9kaXY+J1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdHBsQ2hlY2tib3g6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9DSEVDS0JPWCksXG4gICAgdHBsTGVnZW5kOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfTEVHRU5EKSxcbiAgICB0cGxUaWNrOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfVElDSyksXG4gICAgdHBsQ2lyY2xlTGVnZW5kTGFiZWw6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9DSVJDTEVfTEVHRU5EX0xBQkVMKVxufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgTGVnZW5kIGNvbXBvbmVudCBmb3IgbWFwIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyksXG4gICAgcGx1Z2luRmFjdG9yeSA9IHJlcXVpcmUoJy4uL2ZhY3Rvcmllcy9wbHVnaW5GYWN0b3J5JyksXG4gICAgbGVnZW5kVGVtcGxhdGUgPSByZXF1aXJlKCcuLy4uL2xlZ2VuZHMvbGVnZW5kVGVtcGxhdGUnKTtcblxudmFyIE1hcENoYXJ0TGVnZW5kID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBNYXBDaGFydExlZ2VuZC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIExlZ2VuZCBjb21wb25lbnQgZm9yIG1hcCBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBNYXBDaGFydExlZ2VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBheGlzIHRoZW1lXG4gICAgICogICAgICBAcGFyYW0gez9BcnJheS48c3RyaW5nPn0gcGFyYW1zLm9wdGlvbnMgbGVnZW5kIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7TWFwQ2hhcnREYXRhUHJvY2Vzc29yfSBwYXJhbXMuZGF0YVByb2Nlc3NvciBkYXRhIHByb2Nlc3NvclxuICAgICAqICAgICAgQHBhcmFtIHtCb3VuZHNNYWtlcn0gcGFyYW1zLmJvdW5kc01ha2VyIGJvdW5kcyBtYWtlclxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbGliVHlwZSA9IHBhcmFtcy5saWJUeXBlIHx8IGNoYXJ0Q29uc3QuREVGQVVMVF9QTFVHSU47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsYXNzIG5hbWUuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktY2hhcnQtbGVnZW5kLWFyZWEnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsZWdlbmQgdGhlbWVcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGhlbWUgPSBwYXJhbXMudGhlbWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkYXRhIHByb2Nlc3NvclxuICAgICAgICAgKiBAdHlwZSB7RGF0YVByb2Nlc3Nvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IHBhcmFtcy5kYXRhUHJvY2Vzc29yO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBib3VuZHMgbWFrZXJcbiAgICAgICAgICogQHR5cGUge0JvdW5kc01ha2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlciA9IHBhcmFtcy5ib3VuZHNNYWtlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGggcmVuZGVyZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlciA9IHBsdWdpbkZhY3RvcnkuZ2V0KGxpYlR5cGUsICdtYXBMZWdlbmQnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBob3Jpem9udGFsIGxlZ2VuZCBvciBub3QuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0hvcml6b250YWwgPSBwcmVkaWNhdGUuaXNIb3Jpem9udGFsTGVnZW5kKHRoaXMub3B0aW9ucy5hbGlnbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdmVydGljYWwgbGVnZW5kIGRpbWVuc2lvbi5cbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gdHVpLnV0aWwubWF4KHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZXMoKSksXG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0RnVuY3Rpb25zKCksXG4gICAgICAgICAgICB2YWx1ZVN0ciA9IHJlbmRlclV0aWwuZm9ybWF0VmFsdWUobWF4VmFsdWUsIGZvcm1hdEZ1bmN0aW9ucywgJ2xlZ2VuZCcpLFxuICAgICAgICAgICAgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKHZhbHVlU3RyLCB0aGlzLnRoZW1lLmxhYmVsKSxcbiAgICAgICAgICAgIHBhZGRpbmcgPSBjaGFydENvbnN0LkxFR0VORF9BUkVBX1BBRERJTkcgKyBjaGFydENvbnN0Lk1BUF9MRUdFTkRfTEFCRUxfUEFERElORztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IGNoYXJ0Q29uc3QuTUFQX0xFR0VORF9HUkFQSF9TSVpFICsgbGFiZWxXaWR0aCArIHBhZGRpbmcsXG4gICAgICAgICAgICBoZWlnaHQ6IGNoYXJ0Q29uc3QuTUFQX0xFR0VORF9TSVpFXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaG9yaXpvbnRhbCBsZWdlbmQgZGltZW5zaW9uXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VIb3Jpem9udGFsRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gdHVpLnV0aWwubWF4KHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZXMoKSksXG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChtYXhWYWx1ZSwgdGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBwYWRkaW5nID0gY2hhcnRDb25zdC5MRUdFTkRfQVJFQV9QQURESU5HICsgY2hhcnRDb25zdC5NQVBfTEVHRU5EX0xBQkVMX1BBRERJTkc7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBjaGFydENvbnN0Lk1BUF9MRUdFTkRfU0laRSxcbiAgICAgICAgICAgIGhlaWdodDogY2hhcnRDb25zdC5NQVBfTEVHRU5EX0dSQVBIX1NJWkUgKyBsYWJlbEhlaWdodCArIHBhZGRpbmdcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgZGltZW5zaW9uLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbjtcblxuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHRoaXMuX21ha2VIb3Jpem9udGFsRGltZW5zaW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSB0aGlzLl9tYWtlVmVydGljYWxEaW1lbnNpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCYXNlRGltZW5zaW9uKCdsZWdlbmQnLCBkaW1lbnNpb24pO1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyLnJlZ2lzdGVyQmFzZURpbWVuc2lvbignY2FsY3VsYXRpb25MZWdlbmQnLCBkaW1lbnNpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJhc2UgZGF0YSB0byBtYWtlIHRpY2sgaHRtbC5cbiAgICAgKiBAcmV0dXJucyB7e3N0YXJ0UG9zaXRpb25WYWx1ZTogbnVtYmVyLCBzdGVwOiBudW1iZXIsIHBvc2l0aW9uVHlwZTogc3RyaW5nLCBsYWJlbFNpemU6ID9udW1iZXJ9fSBiYXNlIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQmFzZURhdGFUb01ha2VUaWNrSHRtbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignbGVnZW5kJyksXG4gICAgICAgICAgICBzdGVwQ291bnQgPSB0aGlzLmF4ZXNEYXRhLnRpY2tDb3VudCAtIDEsXG4gICAgICAgICAgICBiYXNlRGF0YSA9IHt9LFxuICAgICAgICAgICAgZmlyc3RMYWJlbDtcblxuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIGJhc2VEYXRhLnN0YXJ0UG9zaXRpb25WYWx1ZSA9IDU7XG4gICAgICAgICAgICBiYXNlRGF0YS5zdGVwID0gZGltZW5zaW9uLndpZHRoIC8gc3RlcENvdW50O1xuICAgICAgICAgICAgYmFzZURhdGEucG9zaXRpb25UeXBlID0gJ2xlZnQ6JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VEYXRhLnN0YXJ0UG9zaXRpb25WYWx1ZSA9IDA7XG4gICAgICAgICAgICBiYXNlRGF0YS5zdGVwID0gZGltZW5zaW9uLmhlaWdodCAvIHN0ZXBDb3VudDtcbiAgICAgICAgICAgIGJhc2VEYXRhLnBvc2l0aW9uVHlwZSA9ICd0b3A6JztcbiAgICAgICAgICAgIGZpcnN0TGFiZWwgPSB0aGlzLmF4ZXNEYXRhLmxhYmVsc1swXTtcbiAgICAgICAgICAgIGJhc2VEYXRhLmxhYmVsU2l6ZSA9IHBhcnNlSW50KHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChmaXJzdExhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSAvIDIsIDEwKSAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmFzZURhdGE7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNYWtlIHRpY2sgaHRtbC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aWNrIGh0bWwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRpY2tIdG1sOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgYmFzZURhdGEgPSB0aGlzLl9tYWtlQmFzZURhdGFUb01ha2VUaWNrSHRtbCgpLFxuICAgICAgICAgICAgcG9zaXRpb25WYWx1ZSA9IGJhc2VEYXRhLnN0YXJ0UG9zaXRpb25WYWx1ZSxcbiAgICAgICAgICAgIGh0bWxzO1xuXG4gICAgICAgIGh0bWxzID0gdHVpLnV0aWwubWFwKHRoaXMuYXhlc0RhdGEubGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsU2l6ZSwgaHRtbDtcblxuICAgICAgICAgICAgaWYgKHNlbGYuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxTaXplID0gcGFyc2VJbnQocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGFiZWwsIHNlbGYudGhlbWUubGFiZWwpIC8gMiwgMTApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYWJlbFNpemUgPSBiYXNlRGF0YS5sYWJlbFNpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh0bWwgPSBsZWdlbmRUZW1wbGF0ZS50cGxUaWNrKHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogYmFzZURhdGEucG9zaXRpb25UeXBlICsgcG9zaXRpb25WYWx1ZSArICdweCcsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogYmFzZURhdGEucG9zaXRpb25UeXBlICsgKHBvc2l0aW9uVmFsdWUgLSBsYWJlbFNpemUpICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwb3NpdGlvblZhbHVlICs9IGJhc2VEYXRhLnN0ZXA7XG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGljayBhcmVhLlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdGljayBjb3VudGFpbmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyVGlja0FyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGlja0NvbnRhaW5lciA9IGRvbS5jcmVhdGUoJ2RpdicsICd0dWktY2hhcnQtbGVnZW5kLXRpY2stYXJlYScpO1xuXG4gICAgICAgIHRpY2tDb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy5fbWFrZVRpY2tIdG1sKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3ModGlja0NvbnRhaW5lciwgJ2hvcml6b250YWwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlja0NvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBncmFwaCBkaW1lbnNpb24gb2YgdmVydGljYWwgbGVnZW5kXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VWZXJ0aWNhbEdyYXBoRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBjaGFydENvbnN0Lk1BUF9MRUdFTkRfR1JBUEhfU0laRSxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2xlZ2VuZCcpLmhlaWdodFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGdyYXBoIGRpbWVuc2lvbiBvZiBob3Jpem9udGFsIGxlZ2VuZFxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbEdyYXBoRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignbGVnZW5kJykud2lkdGggKyAxMCxcbiAgICAgICAgICAgIGhlaWdodDogY2hhcnRDb25zdC5NQVBfTEVHRU5EX0dSQVBIX1NJWkVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckdyYXBoOiBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbjtcblxuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHRoaXMuX21ha2VIb3Jpem9udGFsR3JhcGhEaW1lbnNpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHRoaXMuX21ha2VWZXJ0aWNhbEdyYXBoRGltZW5zaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIucmVuZGVyKGNvbnRhaW5lciwgZGltZW5zaW9uLCB0aGlzLmNvbG9yTW9kZWwsIHRoaXMuaXNIb3Jpem9udGFsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxlZ2VuZCBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBsZWdlbmQgY29udGFpbmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTGVnZW5kQXJlYTogZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgIHZhciB0aWNrQ29udGFpbmVyO1xuXG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihjb250YWluZXIsIHRoaXMuYm91bmRzTWFrZXIuZ2V0UG9zaXRpb24oJ2xlZ2VuZCcpKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyR3JhcGgoY29udGFpbmVyKTtcbiAgICAgICAgdGlja0NvbnRhaW5lciA9IHRoaXMuX3JlbmRlclRpY2tBcmVhKCk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWNrQ29udGFpbmVyKTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgKz0gJzsnICsgcmVuZGVyVXRpbC5tYWtlRm9udENzc1RleHQodGhpcy50aGVtZS5sYWJlbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBsZWdlbmQgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7e2NvbG9yTW9kZWw6IE1hcENoYXJ0Q29sb3JNb2RlbCwgYXhlc0RhdGE6IG9iamVjdH19IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGxlZ2VuZCBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb20uY3JlYXRlKCdESVYnLCB0aGlzLmNsYXNzTmFtZSk7XG5cbiAgICAgICAgdGhpcy5sZWdlbmRDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuY29sb3JNb2RlbCA9IGRhdGEuY29sb3JNb2RlbDtcbiAgICAgICAgdGhpcy5heGVzRGF0YSA9IGRhdGEuYXhlc0RhdGE7XG4gICAgICAgIHRoaXMuX3JlbmRlckxlZ2VuZEFyZWEoY29udGFpbmVyKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgbGVnZW5kIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJMZWdlbmRBcmVhKHRoaXMubGVnZW5kQ29udGFpbmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gc2hvdyB3ZWRnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gcmF0aW9cbiAgICAgKi9cbiAgICBvblNob3dXZWRnZTogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnNob3dXZWRnZShjaGFydENvbnN0Lk1BUF9MRUdFTkRfU0laRSAqIHJhdGlvKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gaGlkZSB3ZWRnZS5cbiAgICAgKi9cbiAgICBvbkhpZGVXZWRnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5oaWRlV2VkZ2UoKTtcbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKE1hcENoYXJ0TGVnZW5kKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDaGFydExlZ2VuZDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBQbG90IGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIGNhbGN1bGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGN1bGF0b3InKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyksXG4gICAgcGxvdFRlbXBsYXRlID0gcmVxdWlyZSgnLi9wbG90VGVtcGxhdGUnKTtcblxudmFyIFBsb3QgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFBsb3QucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBQbG90IGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBQbG90XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZUaWNrQ291bnQgdmVydGljYWwgdGljayBjb3VudFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5oVGlja0NvdW50IGhvcml6b250YWwgdGljayBjb3VudFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBheGlzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbG90IHZpZXcgY2xhc3NOYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktY2hhcnQtcGxvdC1hcmVhJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmRzIG1ha2VyXG4gICAgICAgICAqIEB0eXBlIHtCb3VuZHNNYWtlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBwYXJhbXMuYm91bmRzTWFrZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVtZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IHBhcmFtcy50aGVtZSB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGxvdCBkYXRhLlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBwbG90IGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGxvdENvbnRhaW5lciBwbG90IGFyZWEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyUGxvdEFyZWE6IGZ1bmN0aW9uKHBsb3RDb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdwbG90Jyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24ocGxvdENvbnRhaW5lciwgZGltZW5zaW9uKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihwbG90Q29udGFpbmVyLCB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKCdwbG90JykpO1xuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmhpZGVMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJMaW5lcyhwbG90Q29udGFpbmVyLCBkaW1lbnNpb24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBwbG90IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gcGxvdCBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyUGxvdEFyZWEoZWwsIGRhdGEpO1xuICAgICAgICB0aGlzLnBsb3RDb250YWluZXIgPSBlbDtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXJlbmRlci5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSByZW5kZXJpbmdcbiAgICAgKi9cbiAgICByZXJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnBsb3RDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRoaXMuX3JlbmRlclBsb3RBcmVhKHRoaXMucGxvdENvbnRhaW5lciwgZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBwbG90IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnJlcmVuZGVyKGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgcGxvdCBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gcGxvdCBhcmVhIGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckxpbmVzOiBmdW5jdGlvbihlbCwgZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBoUG9zaXRpb25zID0gdGhpcy5fbWFrZUhvcml6b250YWxQaXhlbFBvc2l0aW9ucyhkaW1lbnNpb24ud2lkdGgpLFxuICAgICAgICAgICAgdlBvc2l0aW9ucyA9IHRoaXMuX21ha2VWZXJ0aWNhbFBpeGVsUG9zaXRpb25zKGRpbWVuc2lvbi5oZWlnaHQpLFxuICAgICAgICAgICAgdGhlbWUgPSB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgbGluZUh0bWwgPSAnJztcblxuICAgICAgICBsaW5lSHRtbCArPSB0aGlzLl9tYWtlTGluZUh0bWwoe1xuICAgICAgICAgICAgcG9zaXRpb25zOiBoUG9zaXRpb25zLFxuICAgICAgICAgICAgc2l6ZTogZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogJ2xlZnQnLFxuICAgICAgICAgICAgc2l6ZVR5cGU6ICdoZWlnaHQnLFxuICAgICAgICAgICAgbGluZUNvbG9yOiB0aGVtZS5saW5lQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmVIdG1sICs9IHRoaXMuX21ha2VMaW5lSHRtbCh7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IHZQb3NpdGlvbnMsXG4gICAgICAgICAgICBzaXplOiBkaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogJ2JvdHRvbScsXG4gICAgICAgICAgICBzaXplVHlwZTogJ3dpZHRoJyxcbiAgICAgICAgICAgIGxpbmVDb2xvcjogdGhlbWUubGluZUNvbG9yXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsLmlubmVySFRNTCA9IGxpbmVIdG1sO1xuXG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyQmFja2dyb3VuZChlbCwgdGhlbWUuYmFja2dyb3VuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaHRtbCBvZiBwbG90IGxpbmUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBwYXJhbXMucG9zaXRpb25zIHBvc2l0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zaXplIHdpZHRoIG9yIGhlaWdodFxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jbGFzc05hbWUgbGluZSBjbGFzc05hbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucG9zaXRpb25UeXBlIHBvc2l0aW9uIHR5cGUgKGxlZnQgb3IgYm90dG9tKVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5zaXplVHlwZSBzaXplIHR5cGUgKHNpemUgb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5saW5lQ29sb3IgbGluZSBjb2xvclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGluZUh0bWw6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBwbG90VGVtcGxhdGUudHBsUGxvdExpbmUsXG4gICAgICAgICAgICBsaW5lSHRtbCA9IHR1aS51dGlsLm1hcChwYXJhbXMucG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBjc3NUZXh0cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclV0aWwuY29uY2F0U3RyKHBhcmFtcy5wb3NpdGlvblR5cGUsICc6JywgcG9zaXRpb24sICdweCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyVXRpbC5jb25jYXRTdHIocGFyYW1zLnNpemVUeXBlLCAnOicsIHBhcmFtcy5zaXplLCAncHgnKVxuICAgICAgICAgICAgICAgICAgICBdLCBkYXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5saW5lQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dHMucHVzaChyZW5kZXJVdGlsLmNvbmNhdFN0cignYmFja2dyb3VuZC1jb2xvcjonLCBwYXJhbXMubGluZUNvbG9yKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtjbGFzc05hbWU6IHBhcmFtcy5jbGFzc05hbWUsIGNzc1RleHQ6IGNzc1RleHRzLmpvaW4oJzsnKX07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKGRhdGEpO1xuICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgIHJldHVybiBsaW5lSHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwaXhlbCB2YWx1ZSBvZiB2ZXJ0aWNhbCBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IHBsb3QgaGVpZ2h0XG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmVydGljYWxQaXhlbFBvc2l0aW9uczogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBjYWxjdWxhdG9yLm1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMoaGVpZ2h0LCB0aGlzLmRhdGEudlRpY2tDb3VudCk7XG4gICAgICAgIHBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRpdmlkZWQgcG9zaXRpb25zIG9mIHBsb3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHBsb3Qgd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZURpdmlkZWRQbG90UG9zaXRpb25zOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICB2YXIgdGlja0NvdW50ID0gcGFyc2VJbnQodGhpcy5kYXRhLmhUaWNrQ291bnQgLyAyLCAxMCkgKyAxLFxuICAgICAgICAgICAgeUF4aXNXaWR0aCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCd5QXhpcycpLndpZHRoLFxuICAgICAgICAgICAgbGVmdFdpZHRoLCByaWdodFdpZHRoLCBsZWZ0UG9zaXRpb25zLCByaWdodFBvc2l0aW9ucztcblxuICAgICAgICB3aWR0aCAtPSB5QXhpc1dpZHRoO1xuICAgICAgICBsZWZ0V2lkdGggPSBNYXRoLnJvdW5kKCh3aWR0aCkgLyAyKTtcbiAgICAgICAgcmlnaHRXaWR0aCA9IHdpZHRoIC0gbGVmdFdpZHRoO1xuXG4gICAgICAgIGxlZnRQb3NpdGlvbnMgPSBjYWxjdWxhdG9yLm1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMobGVmdFdpZHRoLCB0aWNrQ291bnQpO1xuICAgICAgICByaWdodFBvc2l0aW9ucyA9IGNhbGN1bGF0b3IubWFrZVRpY2tQaXhlbFBvc2l0aW9ucyhyaWdodFdpZHRoLCB0aWNrQ291bnQsIGxlZnRXaWR0aCArIHlBeGlzV2lkdGgpO1xuXG4gICAgICAgIGxlZnRQb3NpdGlvbnMucG9wKCk7XG4gICAgICAgIHJpZ2h0UG9zaXRpb25zLnNoaWZ0KCk7XG5cbiAgICAgICAgcmV0dXJuIGxlZnRQb3NpdGlvbnMuY29uY2F0KHJpZ2h0UG9zaXRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwaXhlbCB2YWx1ZSBvZiBob3Jpem9udGFsIHBvc2l0aW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggcGxvdCB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUhvcml6b250YWxQaXhlbFBvc2l0aW9uczogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9ucztcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpdmlkZWQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9ucyA9IHRoaXMuX21ha2VEaXZpZGVkUGxvdFBvc2l0aW9ucyh3aWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbnMgPSBjYWxjdWxhdG9yLm1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMod2lkdGgsIHRoaXMuZGF0YS5oVGlja0NvdW50KTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGxvdDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIHRlbXBsYXRlcyBvZiBwbG90IHZpZXcgLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVtcGxhdGVNYWtlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdGVtcGxhdGVNYWtlcicpO1xuXG52YXIgdGFncyA9IHtcbiAgICBIVE1MX1BMT1RfTElORTogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtcGxvdC1saW5lIHt7IGNsYXNzTmFtZSB9fVwiIHN0eWxlPVwie3sgY3NzVGV4dCB9fVwiPjwvZGl2Pidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRwbFBsb3RMaW5lOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKHRhZ3MuSFRNTF9QTE9UX0xJTkUpXG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWwgcmVuZGVyIHBsdWdpbi5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJhckNoYXJ0ID0gcmVxdWlyZSgnLi9yYXBoYWVsQmFyQ2hhcnQnKTtcbnZhciBMaW5lQ2hhcnQgPSByZXF1aXJlKCcuL3JhcGhhZWxMaW5lQ2hhcnQnKTtcbnZhciBBcmVhQ2hhcnQgPSByZXF1aXJlKCcuL3JhcGhhZWxBcmVhQ2hhcnQnKTtcbnZhciBQaWVDaGFydCA9IHJlcXVpcmUoJy4vcmFwaGFlbFBpZUNoYXJ0Jyk7XG52YXIgQnViYmxlQ2hhcnQgPSByZXF1aXJlKCcuL3JhcGhhZWxCdWJibGVDaGFydCcpO1xudmFyIE1hcENoYXJ0ID0gcmVxdWlyZSgnLi9yYXBoYWVsTWFwQ2hhcnQnKTtcbnZhciBNYXBMZWdlbmQgPSByZXF1aXJlKCcuL3JhcGhhZWxNYXBMZWdlbmQnKTtcbnZhciBDaXJjbGVMZWdlbmQgPSByZXF1aXJlKCcuL3JhcGhhZWxDaXJjbGVMZWdlbmQnKTtcblxudmFyIHBsdWdpbk5hbWUgPSAncmFwaGFlbCcsXG4gICAgcGx1Z2luUmFwaGFlbDtcblxucGx1Z2luUmFwaGFlbCA9IHtcbiAgICBiYXI6IEJhckNoYXJ0LFxuICAgIGNvbHVtbjogQmFyQ2hhcnQsXG4gICAgbGluZTogTGluZUNoYXJ0LFxuICAgIGFyZWE6IEFyZWFDaGFydCxcbiAgICBwaWU6IFBpZUNoYXJ0LFxuICAgIGJ1YmJsZTogQnViYmxlQ2hhcnQsXG4gICAgbWFwOiBNYXBDaGFydCxcbiAgICBtYXBMZWdlbmQ6IE1hcExlZ2VuZCxcbiAgICBjaXJjbGVMZWdlbmQ6IENpcmNsZUxlZ2VuZFxufTtcblxudHVpLmNoYXJ0LnJlZ2lzdGVyUGx1Z2luKHBsdWdpbk5hbWUsIHBsdWdpblJhcGhhZWwpO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWwgYXJlYSBjaGFydCByZW5kZXJlci5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJhcGhhZWxMaW5lQmFzZSA9IHJlcXVpcmUoJy4vcmFwaGFlbExpbmVUeXBlQmFzZScpLFxuICAgIHJhcGhhZWxSZW5kZXJVdGlsID0gcmVxdWlyZSgnLi9yYXBoYWVsUmVuZGVyVXRpbCcpO1xuXG52YXIgcmFwaGFlbCA9IHdpbmRvdy5SYXBoYWVsLFxuICAgIEVNUEhBU0lTX09QQUNJVFkgPSAxLFxuICAgIERFX0VNUEhBU0lTX09QQUNJVFkgPSAwLjM7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG52YXIgUmFwaGFlbEFyZWFDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFJhcGhhZWxMaW5lQmFzZSwgLyoqIEBsZW5kcyBSYXBoYWVsQXJlYUNoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmFwaGFlbEFyZWFDaGFydCBpcyBncmFwaCByZW5kZXJlciBmb3IgYXJlYSBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBSYXBoYWVsQXJlYUNoYXJ0XG4gICAgICogQGV4dGVuZHMgUmFwaGFlbExpbmVUeXBlQmFzZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogc2VsZWN0ZWQgbGVnZW5kIGluZGV4XG4gICAgICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdHlwZSBvZiBjaGFydFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSAnYXJlYSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBmdW5jdGlvbiBvZiBhcmVhIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge3tncm91cFBvc2l0aW9uczogQXJyYXkuPEFycmF5PiwgZGltZW5zaW9uOiBvYmplY3QsIHRoZW1lOiBvYmplY3QsIG9wdGlvbnM6IG9iamVjdH19IGRhdGEgcmVuZGVyIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uLFxuICAgICAgICAgICAgZ3JvdXBQb3NpdGlvbnMgPSBkYXRhLmdyb3VwUG9zaXRpb25zLFxuICAgICAgICAgICAgdGhlbWUgPSBkYXRhLnRoZW1lLFxuICAgICAgICAgICAgY29sb3JzID0gdGhlbWUuY29sb3JzLFxuICAgICAgICAgICAgb3BhY2l0eSA9IGRhdGEub3B0aW9ucy5oYXNEb3QgPyAxIDogMCxcbiAgICAgICAgICAgIGJvcmRlclN0eWxlID0gdGhpcy5tYWtlQm9yZGVyU3R5bGUodGhlbWUuYm9yZGVyQ29sb3IsIG9wYWNpdHkpLFxuICAgICAgICAgICAgb3V0RG90U3R5bGUgPSB0aGlzLm1ha2VPdXREb3RTdHlsZShvcGFjaXR5LCBib3JkZXJTdHlsZSksXG4gICAgICAgICAgICBwYXBlcjtcblxuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXIgPSByYXBoYWVsKGNvbnRhaW5lciwgMSwgZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIHRoaXMuc3RhY2tlZE9wdGlvbiA9IGRhdGEub3B0aW9ucy5zdGFja2VkO1xuICAgICAgICB0aGlzLmlzU3BsaW5lID0gZGF0YS5vcHRpb25zLnNwbGluZTtcbiAgICAgICAgdGhpcy5kaW1lbnNpb24gPSBkaW1lbnNpb247XG4gICAgICAgIHRoaXMuemVyb1RvcCA9IGRhdGEuemVyb1RvcDtcbiAgICAgICAgdGhpcy5oYXNSYW5nZURhdGEgPSBkYXRhLmhhc1JhbmdlRGF0YTtcblxuICAgICAgICB0aGlzLmdyb3VwUGF0aHMgPSB0aGlzLmlzU3BsaW5lID8gdGhpcy5fZ2V0U3BsaW5lQXJlYXNQYXRoKGdyb3VwUG9zaXRpb25zKSA6IHRoaXMuX2dldEFyZWFzUGF0aChncm91cFBvc2l0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3JvdXBBcmVhcyA9IHRoaXMuX3JlbmRlckFyZWFzKHBhcGVyLCB0aGlzLmdyb3VwUGF0aHMsIGNvbG9ycyk7XG4gICAgICAgIHRoaXMudG9vbHRpcExpbmUgPSB0aGlzLl9yZW5kZXJUb29sdGlwTGluZShwYXBlciwgZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIHRoaXMuZ3JvdXBEb3RzID0gdGhpcy5fcmVuZGVyRG90cyhwYXBlciwgZ3JvdXBQb3NpdGlvbnMsIGNvbG9ycywgb3BhY2l0eSk7XG5cbiAgICAgICAgaWYgKGRhdGEub3B0aW9ucy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRG90ID0gdGhpcy5fbWFrZVNlbGVjdGlvbkRvdChwYXBlcik7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbG9yID0gdGhlbWUuc2VsZWN0aW9uQ29sb3I7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1JhbmdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnREb3QgPSB0aGlzLl9tYWtlU2VsZWN0aW9uRG90KHBhcGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3V0RG90U3R5bGUgPSBvdXREb3RTdHlsZTtcbiAgICAgICAgdGhpcy5ncm91cFBvc2l0aW9ucyA9IGdyb3VwUG9zaXRpb25zO1xuICAgICAgICB0aGlzLmRvdE9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICBkZWxldGUgdGhpcy5waXZvdEdyb3VwRG90cztcblxuICAgICAgICByZXR1cm4gcGFwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhcmVhIGdyYXBocy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcGFwZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBncm91cFBhdGhzIGdyb3VwIHBhdGhzXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIGNvbG9yc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcmFwaGFlbCBvYmplY3RzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQXJlYXM6IGZ1bmN0aW9uKHBhcGVyLCBncm91cFBhdGhzLCBjb2xvcnMpIHtcbiAgICAgICAgdmFyIGdyb3VwQXJlYXM7XG5cbiAgICAgICAgY29sb3JzID0gY29sb3JzLnNsaWNlKDAsIGdyb3VwUGF0aHMubGVuZ3RoKTtcbiAgICAgICAgY29sb3JzLnJldmVyc2UoKTtcbiAgICAgICAgZ3JvdXBQYXRocy5yZXZlcnNlKCk7XG5cbiAgICAgICAgZ3JvdXBBcmVhcyA9IHR1aS51dGlsLm1hcChncm91cFBhdGhzLCBmdW5jdGlvbihwYXRoLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYXJlYUNvbG9yID0gY29sb3JzW2dyb3VwSW5kZXhdIHx8ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgbGluZUNvbG9yID0gYXJlYUNvbG9yLFxuICAgICAgICAgICAgICAgIHBvbHlnb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBhcmVhOiByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJBcmVhKHBhcGVyLCBwYXRoLmFyZWEuam9pbignICcpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBhcmVhQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IGFyZWFDb2xvclxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyTGluZShwYXBlciwgcGF0aC5saW5lLmpvaW4oJyAnKSwgbGluZUNvbG9yLCAxKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChwYXRoLnN0YXJ0TGluZSkge1xuICAgICAgICAgICAgICAgIHBvbHlnb25zLnN0YXJ0TGluZSA9IHJhcGhhZWxSZW5kZXJVdGlsLnJlbmRlckxpbmUocGFwZXIsIHBhdGguc3RhcnRMaW5lLmpvaW4oJyAnKSwgbGluZUNvbG9yLCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25zO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZ3JvdXBBcmVhcy5yZXZlcnNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaGVpZ2h0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgdG9wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0VG9wIHN0YXJ0IHRvcFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VIZWlnaHQ6IGZ1bmN0aW9uKHRvcCwgc3RhcnRUb3ApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvcCAtIHN0YXJ0VG9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBhcmVhcyBwYXRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfT59IHBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZyB8IG51bWJlcj59IHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXJlYXNQYXRoOiBmdW5jdGlvbihwb3NpdGlvbnMpIHtcbiAgICAgICAgdmFyIGxlbiA9IHBvc2l0aW9ucy5sZW5ndGggKiAyLFxuICAgICAgICAgICAgcGF0aCA9IFtdO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgcGF0aFtpbmRleF0gPSBbJ0wnLCBwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3BdO1xuICAgICAgICAgICAgcGF0aFtsZW4gLSBpbmRleCAtIDFdID0gWydMJywgcG9zaXRpb24ubGVmdCwgcG9zaXRpb24uc3RhcnRUb3BdO1xuICAgICAgICB9KTtcblxuICAgICAgICBwYXRoID0gY29uY2F0LmFwcGx5KFtdLCBwYXRoKTtcbiAgICAgICAgcGF0aFswXSA9ICdNJztcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFyZWEgcGF0aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHN0YXJ0VG9wOiBudW1iZXJ9Pj59IGdyb3VwUG9zaXRpb25zIHBvc2l0aW9uc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48e2FyZWE6IEFycmF5LjxzdHJpbmcgfCBudW1iZXI+LCBsaW5lOiBBcnJheS48c3RyaW5nIHwgbnVtYmVyPn0+fSBwYXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QXJlYXNQYXRoOiBmdW5jdGlvbihncm91cFBvc2l0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcGF0aHM7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uc1swXS5sZWZ0IC09IDE7XG5cbiAgICAgICAgICAgIHBhdGhzID0ge1xuICAgICAgICAgICAgICAgIGFyZWE6IHNlbGYuX21ha2VBcmVhc1BhdGgocG9zaXRpb25zKSxcbiAgICAgICAgICAgICAgICBsaW5lOiBzZWxmLl9tYWtlTGluZXNQYXRoKHBvc2l0aW9ucylcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmhhc1JhbmdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHBhdGhzLnN0YXJ0TGluZSA9IHNlbGYuX21ha2VMaW5lc1BhdGgocG9zaXRpb25zLCAnc3RhcnRUb3AnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzcGxpbmUgYXJlYSBib3R0b20gcGF0aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn0+fSBwb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9Pn0gcHJldlBvc2l0aW9ucyBwcmV2aW91cyBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZyB8IG51bWJlcj59IHNwbGluZSBhcmVhIHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3BsaW5lQXJlYUJvdHRvbVBhdGg6IGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gWydMJywgcG9zaXRpb24ubGVmdCwgc2VsZi56ZXJvVG9wXTtcbiAgICAgICAgfSkucmV2ZXJzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3BsaW5lIGFyZWFzIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfT4+fSBncm91cFBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHthcmVhOiBBcnJheS48c3RyaW5nIHwgbnVtYmVyPiwgbGluZTogQXJyYXkuPHN0cmluZyB8IG51bWJlcj59Pn0gcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFNwbGluZUFyZWFzUGF0aDogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoZ3JvdXBQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICAgICAgdmFyIGxpbmVzUGF0aCwgYXJlYXNCb3R0b21QYXRoO1xuXG4gICAgICAgICAgICBwb3NpdGlvbnNbMF0ubGVmdCAtPSAxO1xuICAgICAgICAgICAgbGluZXNQYXRoID0gc2VsZi5fbWFrZVNwbGluZUxpbmVzUGF0aChwb3NpdGlvbnMpO1xuICAgICAgICAgICAgYXJlYXNCb3R0b21QYXRoID0gc2VsZi5fbWFrZVNwbGluZUFyZWFCb3R0b21QYXRoKHBvc2l0aW9ucyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXJlYTogbGluZXNQYXRoLmNvbmNhdChhcmVhc0JvdHRvbVBhdGgpLFxuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVzUGF0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBncmFwaCBvZiBhcmVhIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheS48e2xlZnQ6bnVtYmVyLCB0b3A6bnVtYmVyfT4+fSBwYXJhbXMuZ3JvdXBQb3NpdGlvbnMgZ3JvdXAgcG9zaXRpb25zXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgZGltZW5zaW9uID0gcGFyYW1zLmRpbWVuc2lvbixcbiAgICAgICAgICAgIGdyb3VwUG9zaXRpb25zID0gcGFyYW1zLmdyb3VwUG9zaXRpb25zO1xuXG4gICAgICAgIHRoaXMuZ3JvdXBQb3NpdGlvbnMgPSBncm91cFBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5ncm91cFBhdGhzID0gdGhpcy5pc1NwbGluZSA/IHRoaXMuX2dldFNwbGluZUFyZWFzUGF0aChncm91cFBvc2l0aW9ucykgOiB0aGlzLl9nZXRBcmVhc1BhdGgoZ3JvdXBQb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLnBhcGVyLnNldFNpemUoZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgdGhpcy50b29sdGlwTGluZS5hdHRyKHt0b3A6IGRpbWVuc2lvbi5oZWlnaHR9KTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5ncm91cFBhdGhzLCBmdW5jdGlvbihwYXRoLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYXJlYSA9IHNlbGYuZ3JvdXBBcmVhc1tncm91cEluZGV4XTtcbiAgICAgICAgICAgIGFyZWEuYXJlYS5hdHRyKHtwYXRoOiBwYXRoLmFyZWEuam9pbignICcpfSk7XG4gICAgICAgICAgICBhcmVhLmxpbmUuYXR0cih7cGF0aDogcGF0aC5saW5lLmpvaW4oJyAnKX0pO1xuXG4gICAgICAgICAgICBpZiAoYXJlYS5zdGFydExpbmUpIHtcbiAgICAgICAgICAgICAgICBhcmVhLnN0YXJ0TGluZS5hdHRyKHtwYXRoOiBwYXRoLnN0YXJ0TGluZS5qb2luKCcgJyl9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHNlbGYuZ3JvdXBEb3RzW2dyb3VwSW5kZXhdLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdyb3VwUG9zaXRpb25zW2dyb3VwSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3NpdG9uO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fbW92ZURvdChpdGVtLmRvdC5kb3QsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGFydERvdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBvc2l0b24gPSB0dWkudXRpbC5leHRlbmQoe30sIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3NpdG9uLnRvcCA9IHN0YXJ0UG9zaXRvbi5zdGFydFRvcDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbW92ZURvdChpdGVtLnN0YXJ0RG90LmRvdCwgc3RhcnRQb3NpdG9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBsZWdlbmRJbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKi9cbiAgICBzZWxlY3RMZWdlbmQ6IGZ1bmN0aW9uKGxlZ2VuZEluZGV4KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIG5vbmVTZWxlY3RlZCA9IHR1aS51dGlsLmlzTnVsbChsZWdlbmRJbmRleCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4ID0gbGVnZW5kSW5kZXg7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuZ3JvdXBQYXRocywgZnVuY3Rpb24ocGF0aCwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIGFyZWEgPSBzZWxmLmdyb3VwQXJlYXNbZ3JvdXBJbmRleF0sXG4gICAgICAgICAgICAgICAgb3BhY2l0eSA9IChub25lU2VsZWN0ZWQgfHwgbGVnZW5kSW5kZXggPT09IGdyb3VwSW5kZXgpID8gRU1QSEFTSVNfT1BBQ0lUWSA6IERFX0VNUEhBU0lTX09QQUNJVFk7XG5cbiAgICAgICAgICAgIGFyZWEuYXJlYS5hdHRyKHsnZmlsbC1vcGFjaXR5Jzogb3BhY2l0eX0pO1xuICAgICAgICAgICAgYXJlYS5saW5lLmF0dHIoeydzdHJva2Utb3BhY2l0eSc6IG9wYWNpdHl9KTtcblxuICAgICAgICAgICAgaWYgKGFyZWEuc3RhcnRMaW5lKSB7XG4gICAgICAgICAgICAgICAgYXJlYS5zdGFydExpbmUuYXR0cih7J3N0cm9rZS1vcGFjaXR5Jzogb3BhY2l0eX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoc2VsZi5ncm91cERvdHNbZ3JvdXBJbmRleF0sIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kb3RPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZG90LmRvdC5hdHRyKHsnZmlsbC1vcGFjaXR5Jzogb3BhY2l0eX0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGFydERvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGFydERvdC5kb3QuYXR0cih7J2ZpbGwtb3BhY2l0eSc6IG9wYWNpdHl9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXBoYWVsQXJlYUNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWwgYmFyIGNoYXJ0IHJlbmRlcmVyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xudmFyIHJhcGhhZWxSZW5kZXJVdGlsID0gcmVxdWlyZSgnLi9yYXBoYWVsUmVuZGVyVXRpbCcpO1xuXG52YXIgcmFwaGFlbCA9IHdpbmRvdy5SYXBoYWVsO1xuXG52YXIgQU5JTUFUSU9OX1RJTUUgPSA3MDAsXG4gICAgRU1QSEFTSVNfT1BBQ0lUWSA9IDEsXG4gICAgREVfRU1QSEFTSVNfT1BBQ0lUWSA9IDAuMyxcbiAgICBERUZBVUxUX0xVTUlOQU5DID0gMC4yO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgUmFwaGFlbEJhckNoYXJ0IGlzIGdyYXBoIHJlbmRlcmVyIGZvciBiYXIsIGNvbHVtbiBjaGFydC5cbiAqIEBjbGFzcyBSYXBoYWVsQmFyQ2hhcnRcbiAqL1xudmFyIFJhcGhhZWxCYXJDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgUmFwaGFlbEJhckNoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGZ1bmN0aW9uIG9mIGJhciBjaGFydFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e3NpemU6IG9iamVjdCwgbW9kZWw6IG9iamVjdCwgb3B0aW9uczogb2JqZWN0LCB0b29sdGlwUG9zaXRpb246IHN0cmluZ319IGRhdGEgY2hhcnQgZGF0YVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSkge1xuICAgICAgICB2YXIgZ3JvdXBCb3VuZHMgPSBkYXRhLmdyb3VwQm91bmRzLFxuICAgICAgICAgICAgZGltZW5zaW9uID0gZGF0YS5kaW1lbnNpb24sXG4gICAgICAgICAgICBwYXBlcjtcblxuICAgICAgICBpZiAoIWdyb3VwQm91bmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFwZXIgPSBwYXBlciA9IHJhcGhhZWwoY29udGFpbmVyLCBkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuXG4gICAgICAgIHRoaXMudGhlbWUgPSBkYXRhLnRoZW1lO1xuICAgICAgICB0aGlzLnNlcmllc0RhdGFNb2RlbCA9IGRhdGEuc2VyaWVzRGF0YU1vZGVsO1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IGRhdGEuY2hhcnRUeXBlO1xuXG4gICAgICAgIHRoaXMuZ3JvdXBCYXJzID0gdGhpcy5fcmVuZGVyQmFycyhncm91cEJvdW5kcyk7XG4gICAgICAgIHRoaXMuZ3JvdXBCb3JkZXJzID0gdGhpcy5fcmVuZGVyQmFyQm9yZGVycyhncm91cEJvdW5kcyk7XG5cbiAgICAgICAgdGhpcy5vdmVybGF5ID0gdGhpcy5fcmVuZGVyT3ZlcmxheSgpO1xuICAgICAgICB0aGlzLnRoZW1lID0gZGF0YS50aGVtZTtcbiAgICAgICAgdGhpcy5ncm91cEJvdW5kcyA9IGdyb3VwQm91bmRzO1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IGRhdGEuY2hhcnRUeXBlO1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG92ZXJsYXkuXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJPdmVybGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLl9yZW5kZXJCYXIoe1xuICAgICAgICAgICAgYm91bmQ6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjogJyNmZmYnXG4gICAgICAgIH0pLmF0dHIoe1xuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciByZWN0XG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCBib3VuZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBzZXJpZXMgY29sb3JcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBiYXIgcmVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckJhcjogZnVuY3Rpb24oYm91bmQsIGNvbG9yKSB7XG4gICAgICAgIHZhciByZWN0O1xuXG4gICAgICAgIGlmIChib3VuZC53aWR0aCA8IDAgfHwgYm91bmQuaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZWN0ID0gdGhpcy5wYXBlci5yZWN0KGJvdW5kLmxlZnQsIGJvdW5kLnRvcCwgYm91bmQud2lkdGgsIGJvdW5kLmhlaWdodCk7XG4gICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYmFycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9Pj59IGdyb3VwQm91bmRzIGJvdW5kc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBiYXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQmFyczogZnVuY3Rpb24oZ3JvdXBCb3VuZHMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2luZ2xlQ29sb3JzID0gW10sXG4gICAgICAgICAgICBjb2xvcnMgPSB0aGlzLnRoZW1lLmNvbG9ycyxcbiAgICAgICAgICAgIGdyb3VwQmFycztcblxuICAgICAgICBpZiAoKGdyb3VwQm91bmRzWzBdLmxlbmd0aCA9PT0gMSkgJiYgdGhpcy50aGVtZS5zaW5nbGVDb2xvcnMpIHtcbiAgICAgICAgICAgIHNpbmdsZUNvbG9ycyA9IHRoaXMudGhlbWUuc2luZ2xlQ29sb3JzO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdXBCYXJzID0gdHVpLnV0aWwubWFwKGdyb3VwQm91bmRzLCBmdW5jdGlvbihib3VuZHMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzaW5nbGVDb2xvciA9IHNpbmdsZUNvbG9yc1tncm91cEluZGV4XTtcblxuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChib3VuZHMsIGZ1bmN0aW9uKGJvdW5kLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciwgcmVjdCwgaXRlbTtcblxuICAgICAgICAgICAgICAgIGlmICghYm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbSA9IHNlbGYuc2VyaWVzRGF0YU1vZGVsLmdldFNlcmllc0l0ZW0oZ3JvdXBJbmRleCwgaW5kZXgsIHNlbGYuY2hhcnRUeXBlKTtcblxuICAgICAgICAgICAgICAgIGNvbG9yID0gc2luZ2xlQ29sb3IgfHwgY29sb3JzW2luZGV4XTtcbiAgICAgICAgICAgICAgICByZWN0ID0gc2VsZi5fcmVuZGVyQmFyKGJvdW5kLnN0YXJ0LCBjb2xvcik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiBib3VuZC5lbmQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZTogaXRlbS5pc1JhbmdlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZ3JvdXBCYXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJlY3QgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCByZWN0IGJvdW5kXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGxlZnRUb3A6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHJpZ2h0VG9wOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn0sXG4gICAgICogICAgICByaWdodEJvdHRvbToge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9LFxuICAgICAqICAgICAgbGVmdEJvdHRvbToge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gcmVjdCBwb2ludHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUmVjdFBvaW50czogZnVuY3Rpb24oYm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnRUb3A6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBNYXRoLmNlaWwoYm91bmQubGVmdCksXG4gICAgICAgICAgICAgICAgdG9wOiBNYXRoLmNlaWwoYm91bmQudG9wKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJpZ2h0VG9wOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogTWF0aC5jZWlsKGJvdW5kLmxlZnQgKyBib3VuZC53aWR0aCksXG4gICAgICAgICAgICAgICAgdG9wOiBNYXRoLmNlaWwoYm91bmQudG9wKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJpZ2h0Qm90dG9tOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogTWF0aC5jZWlsKGJvdW5kLmxlZnQgKyBib3VuZC53aWR0aCksXG4gICAgICAgICAgICAgICAgdG9wOiBNYXRoLmNlaWwoYm91bmQudG9wICsgYm91bmQuaGVpZ2h0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlZnRCb3R0b206IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBNYXRoLmNlaWwoYm91bmQubGVmdCksXG4gICAgICAgICAgICAgICAgdG9wOiBNYXRoLmNlaWwoYm91bmQudG9wICsgYm91bmQuaGVpZ2h0KVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvcCBsaW5lIHBhdGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBvaW50cyBwb2ludHNcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb2ludHMubGVmdFRvcCBsZWZ0IHRvcFxuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvaW50cy5yaWdodFRvcCByaWdodCB0b3BcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvcCBsaW5lIHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9wTGluZVBhdGg6IGZ1bmN0aW9uKHBvaW50cywgY2hhcnRUeXBlLCBpdGVtKSB7XG4gICAgICAgIHZhciBsaW5lUGF0aCA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZW0udmFsdWUsXG4gICAgICAgICAgICBjbG9uZUxlZnRUb3A7XG5cbiAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gJ2JhcicgfHwgdmFsdWUgPj0gMCB8fCBpdGVtLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIGNsb25lTGVmdFRvcCA9IHR1aS51dGlsLmV4dGVuZCh7fSwgcG9pbnRzLmxlZnRUb3ApO1xuICAgICAgICAgICAgY2xvbmVMZWZ0VG9wLmxlZnQgLT0gY2hhcnRUeXBlID09PSAnY29sdW1uJyB8fCB2YWx1ZSA8IDAgPyAxIDogMDtcbiAgICAgICAgICAgIGxpbmVQYXRoID0gcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKGNsb25lTGVmdFRvcCwgcG9pbnRzLnJpZ2h0VG9wKS5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZVBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcmlnaHQgbGluZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludHMgcG9pbnRzXG4gICAgICogICAgICBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9pbnRzLnJpZ2h0VG9wIHJpZ2h0IHRvcFxuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvaW50cy5yaWdodEJvdHRvbSByaWdodCBib3R0b21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvcCBsaW5lIHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUmlnaHRMaW5lUGF0aDogZnVuY3Rpb24ocG9pbnRzLCBjaGFydFR5cGUsIGl0ZW0pIHtcbiAgICAgICAgdmFyIGxpbmVQYXRoID0gbnVsbDtcblxuICAgICAgICBpZiAoY2hhcnRUeXBlID09PSAnY29sdW1uJyB8fCBpdGVtLnZhbHVlID49IDAgfHwgaXRlbS5pc1JhbmdlKSB7XG4gICAgICAgICAgICBsaW5lUGF0aCA9IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VMaW5lUGF0aChwb2ludHMucmlnaHRUb3AsIHBvaW50cy5yaWdodEJvdHRvbSkuam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbmVQYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdHRvbSBsaW5lIHBhdGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBvaW50cyBwb2ludHNcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb2ludHMubGVmQm90dG9tIGxlZnQgYm90dG9tXG4gICAgICogICAgICBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9pbnRzLnJpZ2h0Qm90dG9tIHJpZ2h0IGJvdHRvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7SXRlbX0gaXRlbSBpdGVtXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdG9wIGxpbmUgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCb3R0b21MaW5lUGF0aDogZnVuY3Rpb24ocG9pbnRzLCBjaGFydFR5cGUsIGl0ZW0pIHtcbiAgICAgICAgdmFyIGxpbmVQYXRoID0gbnVsbDtcblxuICAgICAgICBpZiAoY2hhcnRUeXBlID09PSAnYmFyJyB8fCBpdGVtLnZhbHVlIDwgMCB8fCBpdGVtLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIGxpbmVQYXRoID0gcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHBvaW50cy5sZWZ0Qm90dG9tLCBwb2ludHMucmlnaHRCb3R0b20pLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5lUGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsZWZ0IGxpbmUgcGF0aC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcG9pbnRzIHBvaW50c1xuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvaW50cy5sZWZUb3AgbGVmdCB0b3BcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb2ludHMubGVmdEJvdHRvbSBsZWZ0IGJvdHRvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7SXRlbX0gaXRlbSBpdGVtXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdG9wIGxpbmUgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMZWZ0TGluZVBhdGg6IGZ1bmN0aW9uKHBvaW50cywgY2hhcnRUeXBlLCBpdGVtKSB7XG4gICAgICAgIHZhciBsaW5lUGF0aCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gJ2NvbHVtbicgfHwgaXRlbS52YWx1ZSA8IDAgfHwgaXRlbS5pc1JhbmdlKSB7XG4gICAgICAgICAgICBsaW5lUGF0aCA9IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VMaW5lUGF0aChwb2ludHMubGVmdFRvcCwgcG9pbnRzLmxlZnRCb3R0b20pLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5lUGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3JkZXIgbGluZXMgcGF0aHMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIHJlY3QgYm91bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gaXRlbVxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBzdHJpbmcsIHJpZ2h0OiBzdHJpbmcsIGJvdHRvbTogc3RyaW5nLCBsZWZ0OiBzdHJpbmd9fSBwYXRoc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCb3JkZXJMaW5lc1BhdGhzOiBmdW5jdGlvbihib3VuZCwgY2hhcnRUeXBlLCBpdGVtKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9tYWtlUmVjdFBvaW50cyhib3VuZCksXG4gICAgICAgICAgICBwYXRocyA9IHtcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuX21ha2VUb3BMaW5lUGF0aChwb2ludHMsIGNoYXJ0VHlwZSwgaXRlbSksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMuX21ha2VSaWdodExpbmVQYXRoKHBvaW50cywgY2hhcnRUeXBlLCBpdGVtKSxcbiAgICAgICAgICAgICAgICBib3R0b206IHRoaXMuX21ha2VCb3R0b21MaW5lUGF0aChwb2ludHMsIGNoYXJ0VHlwZSwgaXRlbSksXG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5fbWFrZUxlZnRMaW5lUGF0aChwb2ludHMsIGNoYXJ0VHlwZSwgaXRlbSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmZpbHRlcihwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYm9yZGVyIGxpbmVzO1xuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCBiYXIgYm91bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYm9yZGVyQ29sb3IgYm9yZGVyIGNvbG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtJdGVtfSBpdGVtIGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckJvcmRlckxpbmVzOiBmdW5jdGlvbihib3VuZCwgYm9yZGVyQ29sb3IsIGNoYXJ0VHlwZSwgaXRlbSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBib3JkZXJMaW5lUGF0aHMgPSB0aGlzLl9tYWtlQm9yZGVyTGluZXNQYXRocyhib3VuZCwgY2hhcnRUeXBlLCBpdGVtKSxcbiAgICAgICAgICAgIGxpbmVzID0ge307XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChib3JkZXJMaW5lUGF0aHMsIGZ1bmN0aW9uKHBhdGgsIG5hbWUpIHtcbiAgICAgICAgICAgIGxpbmVzW25hbWVdID0gcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyTGluZShzZWxmLnBhcGVyLCBwYXRoLCBib3JkZXJDb2xvciwgMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGJhciBib3JkZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0+Pn0gZ3JvdXBCb3VuZHMgYm91bmRzXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGJvcmRlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJCYXJCb3JkZXJzOiBmdW5jdGlvbihncm91cEJvdW5kcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IHRoaXMudGhlbWUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBncm91cEJvcmRlcnM7XG5cbiAgICAgICAgaWYgKCFib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cEJvcmRlcnMgPSB0dWkudXRpbC5tYXAoZ3JvdXBCb3VuZHMsIGZ1bmN0aW9uKGJvdW5kcywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChib3VuZHMsIGZ1bmN0aW9uKGJvdW5kLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNJdGVtO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXJpZXNJdGVtID0gc2VsZi5zZXJpZXNEYXRhTW9kZWwuZ2V0U2VyaWVzSXRlbShncm91cEluZGV4LCBpbmRleCwgc2VsZi5jaGFydFR5cGUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3JlbmRlckJvcmRlckxpbmVzKGJvdW5kLnN0YXJ0LCBib3JkZXJDb2xvciwgc2VsZi5jaGFydFR5cGUsIHNlcmllc0l0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBncm91cEJvcmRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgcmVjdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVjdCByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCByZWN0IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYW5pbWF0ZVJlY3Q6IGZ1bmN0aW9uKHJlY3QsIGJvdW5kKSB7XG4gICAgICAgIHJlY3QuYW5pbWF0ZSh7XG4gICAgICAgICAgICB4OiBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgeTogYm91bmQudG9wLFxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZC5oZWlnaHRcbiAgICAgICAgfSwgQU5JTUFUSU9OX1RJTUUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGJvcmRlcnMuXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gbGluZXMgcmFwaGFlbCBvYmplY3RzXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIHJlY3QgYm91bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gaXRlbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGVCb3JkZXJzOiBmdW5jdGlvbihsaW5lcywgYm91bmQsIGNoYXJ0VHlwZSwgaXRlbSkge1xuICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLl9tYWtlQm9yZGVyTGluZXNQYXRocyhib3VuZCwgY2hhcnRUeXBlLCBpdGVtKTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGxpbmVzLCBmdW5jdGlvbihsaW5lLCBuYW1lKSB7XG4gICAgICAgICAgICBsaW5lLmFuaW1hdGUoe3BhdGg6IHBhdGhzW25hbWVdfSwgQU5JTUFUSU9OX1RJTUUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkZpbmlzaCBmaW5pc2ggY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBhbmltYXRlOiBmdW5jdGlvbihvbkZpbmlzaCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBncm91cEJvcmRlcnMgPSB0aGlzLmdyb3VwQm9yZGVycyB8fCBbXTtcblxuICAgICAgICBpZiAodGhpcy5jYWxsYmFja1RpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNhbGxiYWNrVGltZW91dCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja1RpbWVvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwuZm9yRWFjaDJkQXJyYXkodGhpcy5ncm91cEJhcnMsIGZ1bmN0aW9uKGJhciwgZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGdyb3VwQm9yZGVyc1tncm91cEluZGV4XSAmJiBncm91cEJvcmRlcnNbZ3JvdXBJbmRleF1baW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFiYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9hbmltYXRlUmVjdChiYXIucmVjdCwgYmFyLmJvdW5kKTtcbiAgICAgICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgICAgIHNlbGYuX2FuaW1hdGVCb3JkZXJzKGxpbmVzLCBiYXIuYm91bmQsIHNlbGYuY2hhcnRUeXBlLCBiYXIuaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9uRmluaXNoKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuY2FsbGJhY2tUaW1lb3V0O1xuICAgICAgICAgICAgfSwgQU5JTUFUSU9OX1RJTUUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6bnVtYmVyfX0gZGF0YSBzaG93IGluZm9cbiAgICAgKi9cbiAgICBzaG93QW5pbWF0aW9uOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmdyb3VwQmFyc1tkYXRhLmdyb3VwSW5kZXhdW2RhdGEuaW5kZXhdLFxuICAgICAgICAgICAgYm91bmQgPSBiYXIuYm91bmQ7XG4gICAgICAgIHRoaXMub3ZlcmxheS5hdHRyKHtcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYm91bmQuaGVpZ2h0LFxuICAgICAgICAgICAgeDogYm91bmQubGVmdCxcbiAgICAgICAgICAgIHk6IGJvdW5kLnRvcCxcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAwLjNcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgYW5pbWF0aW9uLlxuICAgICAqL1xuICAgIGhpZGVBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm92ZXJsYXkuYXR0cih7XG4gICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDBcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSByZWN0IGJvdW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlY3QgcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlUmVjdEJvdW5kOiBmdW5jdGlvbihyZWN0LCBib3VuZCkge1xuICAgICAgICByZWN0LmF0dHIoe1xuICAgICAgICAgICAgeDogYm91bmQubGVmdCxcbiAgICAgICAgICAgIHk6IGJvdW5kLnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYm91bmQuaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYm9yZGVycyBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBsaW5lcyByYXBoYWVsIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtJdGVtfSBpdGVtIGl0ZW1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVCb3JkZXJzUGF0aDogZnVuY3Rpb24obGluZXMsIGJvdW5kLCBjaGFydFR5cGUsIGl0ZW0pIHtcbiAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5fbWFrZUJvcmRlckxpbmVzUGF0aHMoYm91bmQsIGNoYXJ0VHlwZSwgaXRlbSk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChsaW5lcywgZnVuY3Rpb24obGluZSwgbmFtZSkge1xuICAgICAgICAgICAgbGluZS5hdHRyKHtwYXRoOiBwYXRoc1tuYW1lXX0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIGdyYXBoIG9mIGJhciB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheS48e1xuICAgICAqICAgICAgICAgICAgICAgICAgbGVmdDpudW1iZXIsIHRvcDpudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyXG4gICAgICogICAgICAgICAgICAgIH0+Pn0gcGFyYW1zLmdyb3VwQm91bmRzIGdyb3VwIGJvdW5kc1xuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGdyb3VwQm9yZGVycyA9IHRoaXMuZ3JvdXBCb3JkZXJzIHx8IFtdLFxuICAgICAgICAgICAgZGltZW5zaW9uID0gcGFyYW1zLmRpbWVuc2lvbixcbiAgICAgICAgICAgIGdyb3VwQm91bmRzID0gcGFyYW1zLmdyb3VwQm91bmRzO1xuXG4gICAgICAgIHRoaXMuZ3JvdXBCb3VuZHMgPSBncm91cEJvdW5kcztcbiAgICAgICAgdGhpcy5wYXBlci5zZXRTaXplKGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG5cbiAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwuZm9yRWFjaDJkQXJyYXkodGhpcy5ncm91cEJhcnMsIGZ1bmN0aW9uKGJhciwgZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsaW5lcywgYm91bmQ7XG5cbiAgICAgICAgICAgIGlmICghYmFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lcyA9IGdyb3VwQm9yZGVyc1tncm91cEluZGV4XSAmJiBncm91cEJvcmRlcnNbZ3JvdXBJbmRleF1baW5kZXhdO1xuICAgICAgICAgICAgYm91bmQgPSBncm91cEJvdW5kc1tncm91cEluZGV4XVtpbmRleF0uZW5kO1xuICAgICAgICAgICAgYmFyLmJvdW5kID0gYm91bmQ7XG4gICAgICAgICAgICBzZWxmLl91cGRhdGVSZWN0Qm91bmQoYmFyLnJlY3QsIGJvdW5kKTtcblxuICAgICAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fdXBkYXRlQm9yZGVyc1BhdGgobGluZXMsIGJvdW5kLCBzZWxmLmNoYXJ0VHlwZSwgYmFyLml0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGJvcmRlcnMgY29sb3IuXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gbGluZXMgcmFwaGFlbCBvYmplY3RzXG4gICAgICogQHBhcmFtIHtib3JkZXJDb2xvcn0gYm9yZGVyQ29sb3IgYm9yZGVyIGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hhbmdlQm9yZGVyc0NvbG9yOiBmdW5jdGlvbihsaW5lcywgYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChsaW5lcywgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgbGluZS5hdHRyKHtzdHJva2U6IGJvcmRlckNvbG9yfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgYmFyIGNvbG9yLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBib3JkZXJDb2xvciBzdHJva2UgY29sb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGFuZ2VCYXJDb2xvcjogZnVuY3Rpb24oaW5kZXhlcywgY29sb3IsIGJvcmRlckNvbG9yKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmdyb3VwQmFyc1tpbmRleGVzLmdyb3VwSW5kZXhdW2luZGV4ZXMuaW5kZXhdLFxuICAgICAgICAgICAgbGluZXM7XG5cbiAgICAgICAgYmFyLnJlY3QuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBjb2xvclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIGxpbmVzID0gdGhpcy5ncm91cEJvcmRlcnNbaW5kZXhlcy5ncm91cEluZGV4XVtpbmRleGVzLmluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUJvcmRlcnNDb2xvcihsaW5lcywgYm9yZGVyQ29sb3IpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmdyb3VwQmFyc1tpbmRleGVzLmdyb3VwSW5kZXhdW2luZGV4ZXMuaW5kZXhdLFxuICAgICAgICAgICAgb2JqQ29sb3IgPSByYXBoYWVsLmNvbG9yKGJhci5jb2xvciksXG4gICAgICAgICAgICBzZWxlY3Rpb25Db2xvclRoZW1lID0gdGhpcy50aGVtZS5zZWxlY3Rpb25Db2xvcixcbiAgICAgICAgICAgIGNvbG9yID0gc2VsZWN0aW9uQ29sb3JUaGVtZSB8fCByYXBoYWVsUmVuZGVyVXRpbC5tYWtlQ2hhbmdlZEx1bWluYW5jZUNvbG9yKG9iakNvbG9yLmhleCwgREVGQVVMVF9MVU1JTkFOQyksXG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IHRoaXMudGhlbWUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBvYmpCb3JkZXJDb2xvcjtcblxuICAgICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIG9iakJvcmRlckNvbG9yID0gcmFwaGFlbC5jb2xvcihib3JkZXJDb2xvcik7XG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VDaGFuZ2VkTHVtaW5hbmNlQ29sb3Iob2JqQm9yZGVyQ29sb3IuaGV4LCBERUZBVUxUX0xVTUlOQU5DKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoYW5nZUJhckNvbG9yKGluZGV4ZXMsIGNvbG9yLCBib3JkZXJDb2xvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuc2VsZWN0IHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKi9cbiAgICB1bnNlbGVjdFNlcmllczogZnVuY3Rpb24oaW5kZXhlcykge1xuICAgICAgICB2YXIgYmFyID0gdGhpcy5ncm91cEJhcnNbaW5kZXhlcy5ncm91cEluZGV4XVtpbmRleGVzLmluZGV4XSxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yID0gdGhpcy50aGVtZS5ib3JkZXJDb2xvcjtcbiAgICAgICAgdGhpcy5fY2hhbmdlQmFyQ29sb3IoaW5kZXhlcywgYmFyLmNvbG9yLCBib3JkZXJDb2xvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBsZWdlbmRJbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKi9cbiAgICBzZWxlY3RMZWdlbmQ6IGZ1bmN0aW9uKGxlZ2VuZEluZGV4KSB7XG4gICAgICAgIHZhciBncm91cEJvcmRlcnMgPSB0aGlzLmdyb3VwQm9yZGVycyB8fCBbXSxcbiAgICAgICAgICAgIG5vbmVTZWxlY3RlZCA9IHR1aS51dGlsLmlzTnVsbChsZWdlbmRJbmRleCk7XG5cbiAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwuZm9yRWFjaDJkQXJyYXkodGhpcy5ncm91cEJhcnMsIGZ1bmN0aW9uKGJhciwgZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsaW5lcywgb3BhY2l0eTtcblxuICAgICAgICAgICAgaWYgKCFiYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmVzID0gZ3JvdXBCb3JkZXJzW2dyb3VwSW5kZXhdICYmIGdyb3VwQm9yZGVyc1tncm91cEluZGV4XVtpbmRleF07XG4gICAgICAgICAgICBvcGFjaXR5ID0gKG5vbmVTZWxlY3RlZCB8fCBsZWdlbmRJbmRleCA9PT0gaW5kZXgpID8gRU1QSEFTSVNfT1BBQ0lUWSA6IERFX0VNUEhBU0lTX09QQUNJVFk7XG5cbiAgICAgICAgICAgIGJhci5yZWN0LmF0dHIoeydmaWxsLW9wYWNpdHknOiBvcGFjaXR5fSk7XG4gICAgICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGxpbmVzLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUuYXR0cih7J3N0cm9rZS1vcGFjaXR5Jzogb3BhY2l0eX0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXBoYWVsQmFyQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmFwaGFlbCBidWJibGUgY2hhcnQgcmVuZGVyZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG52YXIgcmFwaGFlbFJlbmRlclV0aWwgPSByZXF1aXJlKCcuL3JhcGhhZWxSZW5kZXJVdGlsJyk7XG5cbnZhciByYXBoYWVsID0gd2luZG93LlJhcGhhZWw7XG5cbnZhciBBTklNQVRJT05fVElNRSA9IDcwMDtcbnZhciBDSVJDTEVfT1BBQ0lUWSA9IDAuNTtcbnZhciBTVFJPS0VfT1BBQ0lUWSA9IDAuMztcbnZhciBFTVBIQVNJU19PUEFDSVRZID0gMC41O1xudmFyIERFX0VNUEhBU0lTX09QQUNJVFkgPSAwLjM7XG52YXIgREVGQVVMVF9MVU1JTkFOQyA9IDAuMjtcbnZhciBPVkVSTEFZX0JPUkRFUl9XSURUSCA9IDI7XG5cbi8qKlxuICogYm91bmQgZm9yIGNpcmNsZVxuICogQHR5cGVkZWYge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByYWRpdXM6IG51bWJlcn19IGJvdW5kXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBmb3IgcmVuZGVyZWQgY2lyY2xlXG4gKiBAdHlwZWRlZiB7e2NpcmNsZTogb2JqZWN0LCBjb2xvcjogc3RyaW5nLCBib3VuZDogYm91bmR9fSBjaXJjbGVJbmZvXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjIFJhcGhhZWxCdWJibGVDaGFydCBpcyBncmFwaCByZW5kZXJlciBmb3IgYnViYmxlIGNoYXJ0LlxuICogQGNsYXNzIFJhcGhhZWxCdWJibGVDaGFydFxuICovXG52YXIgUmFwaGFlbEJ1YmJsZUNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBSYXBoYWVsQnViYmxlQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZnVuY3Rpb24gb2YgYnViYmxlIGNoYXJ0XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHNlcmllc0RhdGFNb2RlbDogU2VyaWVzRGF0YU1vZGVsLFxuICAgICAqICAgICAgZ3JvdXBCb3VuZHM6IEFycmF5LjxBcnJheS48Ym91bmQ+PixcbiAgICAgKiAgICAgIHRoZW1lOiBvYmplY3RcbiAgICAgKiB9fSBkYXRhIC0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHt7c2hvd1Rvb2x0aXA6IGZ1bmN0aW9uLCBoaWRlVG9vbHRpcDogZnVuY3Rpb259fSBjYWxsYmFja3MgLSBjYWxsYmFja3MgZm9yIHRvZ2dsZSBvZiB0b29sdGlwLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIGNhbGxiYWNrcykge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gZGF0YS5kaW1lbnNpb24sXG4gICAgICAgICAgICBwYXBlcjtcblxuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXIgPSByYXBoYWVsKGNvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZW1lXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRoZW1lID0gZGF0YS50aGVtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2VyaWVzRGF0YU1vZGVsXG4gICAgICAgICAqIEB0eXBlIHtTZXJpZXNEYXRhTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcmllc0RhdGFNb2RlbCA9IGRhdGEuc2VyaWVzRGF0YU1vZGVsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBncm91cCBib3VuZHNcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxBcnJheS48Ym91bmQ+Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXBCb3VuZHMgPSBkYXRhLmdyb3VwQm91bmRzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjYWxsYmFja3MgZm9yIHRvZ2dsZSBvZiB0b29sdGlwLlxuICAgICAgICAgKiBAdHlwZSB7e3Nob3dUb29sdGlwOiBGdW5jdGlvbiwgaGlkZVRvb2x0aXA6IEZ1bmN0aW9ufX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvdmVybGF5IGlzIGNpcmNsZSBvYmplY3Qgb2YgcmFwaGFlbCwgdGhhdCB1c2luZyBmb3IgbW91c2VvdmVyLlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vdmVybGF5ID0gdGhpcy5fcmVuZGVyT3ZlcmxheSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0d28tZGltZW5zaW9uYWwgYXJyYXkgYnkgY2lyY2xlSW5mb1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPEFycmF5LjxjaXJjbGVJbmZvPj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwQ2lyY2xlSW5mb3MgPSB0aGlzLl9yZW5kZXJDaXJjbGVzKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZXZpb3VzIHNlbGVjdGVkIGNpcmNsZVxuICAgICAgICAgKiBAdHlwZSB7P29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldkNpcmNsZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZXZpb3VzIG92ZXIgY2lyY2xlXG4gICAgICAgICAqIEB0eXBlIHs/b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2T3ZlckNpcmNsZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFuaW1hdGlvbiB0aW1lb3V0IGlkXG4gICAgICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG92ZXJsYXkuXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJPdmVybGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYXR0cmlidXRlID0ge1xuICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgc3Ryb2tlOiAnI2ZmZicsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiBTVFJPS0VfT1BBQ0lUWSxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAyXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjaXJjbGUgPSByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJDaXJjbGUodGhpcy5wYXBlciwgcG9zaXRpb24sIDAsIGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGNpcmNsZXMuXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48Y2lyY2xlSW5mbz4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckNpcmNsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb2xvcnMgPSB0aGlzLnRoZW1lLmNvbG9ycztcbiAgICAgICAgdmFyIHNpbmdsZUNvbG9ycyA9IFtdO1xuXG4gICAgICAgIGlmICgodGhpcy5ncm91cEJvdW5kc1swXS5sZW5ndGggPT09IDEpICYmIHRoaXMudGhlbWUuc2luZ2xlQ29sb3JzKSB7XG4gICAgICAgICAgICBzaW5nbGVDb2xvcnMgPSB0aGlzLnRoZW1lLnNpbmdsZUNvbG9ycztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodGhpcy5ncm91cEJvdW5kcywgZnVuY3Rpb24oYm91bmRzLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2luZ2xlQ29sb3IgPSBzaW5nbGVDb2xvcnNbZ3JvdXBJbmRleF07XG5cbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoYm91bmRzLCBmdW5jdGlvbihib3VuZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2lyY2xlSW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yLCBjaXJjbGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoYm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBzaW5nbGVDb2xvciB8fCBjb2xvcnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBjaXJjbGUgPSByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJDaXJjbGUoc2VsZi5wYXBlciwgYm91bmQsIDAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNpcmNsZS5kYXRhKCdncm91cEluZGV4JywgZ3JvdXBJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNpcmNsZS5kYXRhKCdpbmRleCcsIGluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBjaXJjbGVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2lyY2xlOiBjaXJjbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZDogYm91bmRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2lyY2xlSW5mbztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2lyY2xlIC0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gcmFkaXVzIG9mIGNpcmNsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGVDaXJjbGU6IGZ1bmN0aW9uKGNpcmNsZSwgcmFkaXVzKSB7XG4gICAgICAgIGNpcmNsZS5hbmltYXRlKHtcbiAgICAgICAgICAgIHI6IHJhZGl1cyxcbiAgICAgICAgICAgIG9wYWNpdHk6IENJUkNMRV9PUEFDSVRZXG4gICAgICAgIH0sIEFOSU1BVElPTl9USU1FKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkZpbmlzaCAtIGZpbmlzaCBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIGFuaW1hdGU6IGZ1bmN0aW9uKG9uRmluaXNoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25UaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1hdGlvblRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByYXBoYWVsUmVuZGVyVXRpbC5mb3JFYWNoMmRBcnJheSh0aGlzLmdyb3VwQ2lyY2xlSW5mb3MsIGZ1bmN0aW9uKGNpcmNsZUluZm8pIHtcbiAgICAgICAgICAgIGlmICghY2lyY2xlSW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX2FuaW1hdGVDaXJjbGUoY2lyY2xlSW5mby5jaXJjbGUsIGNpcmNsZUluZm8uYm91bmQucmFkaXVzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb25GaW5pc2goKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICB9LCBBTklNQVRJT05fVElNRSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNpcmNsZSBib3VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaXJjbGUgLSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBib3VuZCAtIGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uKGNpcmNsZSwgYm91bmQpIHtcbiAgICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICAgICAgY3g6IGJvdW5kLmxlZnQsXG4gICAgICAgICAgICBjeTogYm91bmQudG9wLFxuICAgICAgICAgICAgcjogYm91bmQucmFkaXVzXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgZ3JhcGggb2YgYnViYmxlIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gcGFyYW1zLmRpbWVuc2lvbiAtIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXkuPGJvdW5kPj59IHBhcmFtcy5ncm91cEJvdW5kcyAtIGdyb3VwIGJvdW5kc1xuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHBhcmFtcy5kaW1lbnNpb247XG4gICAgICAgIHZhciBncm91cEJvdW5kcyA9IHBhcmFtcy5ncm91cEJvdW5kcztcblxuICAgICAgICB0aGlzLmdyb3VwQm91bmRzID0gZ3JvdXBCb3VuZHM7XG4gICAgICAgIHRoaXMucGFwZXIuc2V0U2l6ZShkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuXG4gICAgICAgIHJhcGhhZWxSZW5kZXJVdGlsLmZvckVhY2gyZEFycmF5KHRoaXMuZ3JvdXBDaXJjbGVJbmZvcywgZnVuY3Rpb24oY2lyY2xlSW5mbywgZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBib3VuZCA9IGdyb3VwQm91bmRzW2dyb3VwSW5kZXhdW2luZGV4XTtcblxuICAgICAgICAgICAgY2lyY2xlSW5mby5ib3VuZCA9IGJvdW5kO1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlUG9zaXRpb24oY2lyY2xlSW5mby5jaXJjbGUsIGJvdW5kKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsaWNrIHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKi9cbiAgICBjbGlja1NlcmllczogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGNpcmNsZSA9IHRoaXMucGFwZXIuZ2V0RWxlbWVudEJ5UG9pbnQocG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wKTtcbiAgICAgICAgdmFyIHByZXZDaXJjbGUgPSB0aGlzLnByZXZDaXJjbGU7XG5cbiAgICAgICAgaWYgKGNpcmNsZSAmJiBwcmV2Q2lyY2xlKSB7XG4gICAgICAgICAgICB0aGlzLl91bnNlbGVjdFNlcmllcyhwcmV2Q2lyY2xlLmRhdGEoJ2dyb3VwSW5kZXgnKSwgcHJldkNpcmNsZS5kYXRhKCdpbmRleCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2Q2lyY2xlID09PSBjaXJjbGUpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkNpcmNsZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoY2lyY2xlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RTZXJpZXMoY2lyY2xlLmRhdGEoJ2dyb3VwSW5kZXgnKSwgY2lyY2xlLmRhdGEoJ2luZGV4JykpO1xuICAgICAgICAgICAgdGhpcy5wcmV2Q2lyY2xlID0gY2lyY2xlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzZXJpZXMgY29udGFpbmVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENvbnRhaW5lckJvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lckJvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kID0gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyQm91bmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBvciBub3QuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHByZXZQb3NpdGlvbiAtIHByZXZpb3VzIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIC0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0NoYW5nZWRQb3NpdGlvbjogZnVuY3Rpb24ocHJldlBvc2l0aW9uLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gIXByZXZQb3NpdGlvbiB8fCBwcmV2UG9zaXRpb24ubGVmdCAhPT0gcG9zaXRpb24ubGVmdCB8fCBwcmV2UG9zaXRpb24udG9wICE9PSBwb3NpdGlvbi50b3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgb3ZlcmxheSB3aGVuIG1vdXNlIG92ZXIgYSBjaXJjbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggLSBpbmRleCBvZiBjaXJjbGVzIGdyb3VwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2YgY2lyY2xlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3dPdmVybGF5OiBmdW5jdGlvbihncm91cEluZGV4LCBpbmRleCkge1xuICAgICAgICB2YXIgY2lyY2xlSW5mbyA9IHRoaXMuZ3JvdXBDaXJjbGVJbmZvc1tncm91cEluZGV4XVtpbmRleF07XG4gICAgICAgIHZhciBib3VuZCA9IGNpcmNsZUluZm8uYm91bmQ7XG5cbiAgICAgICAgdGhpcy5vdmVybGF5LmF0dHIoe1xuICAgICAgICAgICAgY3g6IGJvdW5kLmxlZnQsXG4gICAgICAgICAgICBjeTogYm91bmQudG9wLFxuICAgICAgICAgICAgcjogYm91bmQucmFkaXVzICsgT1ZFUkxBWV9CT1JERVJfV0lEVEgsXG4gICAgICAgICAgICBzdHJva2U6IGNpcmNsZUluZm8uY29sb3IsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIG92ZXJsYXkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlkZU92ZXJsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm92ZXJsYXkuYXR0cih7XG4gICAgICAgICAgICBjeDogMCxcbiAgICAgICAgICAgIGN5OiAwLFxuICAgICAgICAgICAgcjogMCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgY2lyY2xlLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiAtIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMgez9vYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZENpcmNsZTogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGNpcmNsZXMgPSBbXTtcbiAgICAgICAgdmFyIHBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgdmFyIGZvdW5kQ2lyY2xlLCBjaXJjbGU7XG5cbiAgICAgICAgd2hpbGUgKHR1aS51dGlsLmlzVW5kZWZpbmVkKGZvdW5kQ2lyY2xlKSkge1xuICAgICAgICAgICAgY2lyY2xlID0gcGFwZXIuZ2V0RWxlbWVudEJ5UG9pbnQocG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wKTtcblxuICAgICAgICAgICAgaWYgKGNpcmNsZSkge1xuICAgICAgICAgICAgICAgIGlmIChjaXJjbGUuYXR0cnMub3BhY2l0eSA+IERFX0VNUEhBU0lTX09QQUNJVFkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDaXJjbGUgPSBjaXJjbGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlcy5wdXNoKGNpcmNsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNpcmNsZS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3VuZENpcmNsZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvdW5kQ2lyY2xlKSB7XG4gICAgICAgICAgICBmb3VuZENpcmNsZSA9IGNpcmNsZXNbMF07XG4gICAgICAgIH1cblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY2lyY2xlcywgZnVuY3Rpb24oX2NpcmNsZSkge1xuICAgICAgICAgICAgX2NpcmNsZS5zaG93KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmb3VuZENpcmNsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSBtb3VzZSBvbiBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIC0gbW91c2UgcG9zaXRpb25cbiAgICAgKi9cbiAgICBtb3ZlTW91c2VPblNlcmllczogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGNpcmNsZSA9IHRoaXMuX2ZpbmRDaXJjbGUocG9zaXRpb24pO1xuICAgICAgICB2YXIgY29udGFpbmVyQm91bmQsIGlzQ2hhbmdlZCwgZ3JvdXBJbmRleCwgaW5kZXgsIGFyZ3M7XG5cbiAgICAgICAgaWYgKGNpcmNsZSAmJiB0dWkudXRpbC5pc0V4aXN0eShjaXJjbGUuZGF0YSgnZ3JvdXBJbmRleCcpKSkge1xuICAgICAgICAgICAgY29udGFpbmVyQm91bmQgPSB0aGlzLl9nZXRDb250YWluZXJCb3VuZCgpO1xuICAgICAgICAgICAgaXNDaGFuZ2VkID0gKHRoaXMucHJldk92ZXJDaXJjbGUgIT09IGNpcmNsZSk7XG4gICAgICAgICAgICBncm91cEluZGV4ID0gY2lyY2xlLmRhdGEoJ2dyb3VwSW5kZXgnKTtcbiAgICAgICAgICAgIGluZGV4ID0gY2lyY2xlLmRhdGEoJ2luZGV4Jyk7XG4gICAgICAgICAgICBhcmdzID0gW3t9LCBncm91cEluZGV4LCBpbmRleCwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgLSBjb250YWluZXJCb3VuZC5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wIC0gY29udGFpbmVyQm91bmQudG9wXG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dPdmVybGF5KGdyb3VwSW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ2hhbmdlZFBvc2l0aW9uKHRoaXMucHJldlBvc2l0aW9uLCBwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zaG93VG9vbHRpcC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZPdmVyQ2lyY2xlID0gY2lyY2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldk92ZXJDaXJjbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgdGhpcy5wcmV2T3ZlckNpcmNsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJbmRleCAtIGluZGV4IG9mIGdyb3VwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXhcbiAgICAgKi9cbiAgICBfc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihncm91cEluZGV4LCBpbmRleCkge1xuICAgICAgICB2YXIgY2lyY2xlSW5mbyA9IHRoaXMuZ3JvdXBDaXJjbGVJbmZvc1tncm91cEluZGV4XVtpbmRleF07XG4gICAgICAgIHZhciBvYmpDb2xvciA9IHJhcGhhZWwuY29sb3IoY2lyY2xlSW5mby5jb2xvcik7XG4gICAgICAgIHZhciB0aGVtZUNvbG9yID0gdGhpcy50aGVtZS5zZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgdmFyIGNvbG9yID0gdGhlbWVDb2xvciB8fCByYXBoYWVsUmVuZGVyVXRpbC5tYWtlQ2hhbmdlZEx1bWluYW5jZUNvbG9yKG9iakNvbG9yLmhleCwgREVGQVVMVF9MVU1JTkFOQyk7XG5cbiAgICAgICAgY2lyY2xlSW5mby5jaXJjbGUuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBjb2xvclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5zZWxlY3Qgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IC0gaW5kZXggb2YgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleFxuICAgICAqL1xuICAgIF91bnNlbGVjdFNlcmllczogZnVuY3Rpb24oZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNpcmNsZUluZm8gPSB0aGlzLmdyb3VwQ2lyY2xlSW5mb3NbZ3JvdXBJbmRleF1baW5kZXhdO1xuXG4gICAgICAgIGNpcmNsZUluZm8uY2lyY2xlLmF0dHIoe1xuICAgICAgICAgICAgZmlsbDogY2lyY2xlSW5mby5jb2xvclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGxlZ2VuZEluZGV4IC0gaW5kZXggb2YgbGVnZW5kXG4gICAgICovXG4gICAgc2VsZWN0TGVnZW5kOiBmdW5jdGlvbihsZWdlbmRJbmRleCkge1xuICAgICAgICB2YXIgbm9uZVNlbGVjdGVkID0gdHVpLnV0aWwuaXNOdWxsKGxlZ2VuZEluZGV4KTtcblxuICAgICAgICByYXBoYWVsUmVuZGVyVXRpbC5mb3JFYWNoMmRBcnJheSh0aGlzLmdyb3VwQ2lyY2xlSW5mb3MsIGZ1bmN0aW9uKGNpcmNsZUluZm8sIGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eTtcblxuICAgICAgICAgICAgaWYgKCFjaXJjbGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGFjaXR5ID0gKG5vbmVTZWxlY3RlZCB8fCBsZWdlbmRJbmRleCA9PT0gaW5kZXgpID8gRU1QSEFTSVNfT1BBQ0lUWSA6IERFX0VNUEhBU0lTX09QQUNJVFk7XG5cbiAgICAgICAgICAgIGNpcmNsZUluZm8uY2lyY2xlLmF0dHIoe29wYWNpdHk6IG9wYWNpdHl9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbEJ1YmJsZUNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWxDaXJjbGVMZWdlbmQgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIGNpcmNsZUxlZ2VuZC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJhcGhhZWxSZW5kZXJVdGlsID0gcmVxdWlyZSgnLi9yYXBoYWVsUmVuZGVyVXRpbCcpO1xuXG52YXIgcmFwaGFlbCA9IHdpbmRvdy5SYXBoYWVsO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgUmFwaGFlbENpcmNsZUxlZ2VuZCBpcyBncmFwaCByZW5kZXJlciBmb3IgY2lyY2xlTGVnZW5kLlxuICogQGNsYXNzIFJhcGhhZWxDaXJjbGVMZWdlbmRcbiAqL1xudmFyIFJhcGhhZWxDaXJjbGVMZWdlbmQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFJhcGhhZWxDaXJjbGVMZWdlbmQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZnVuY3Rpb24gb2YgbWFwIGNoYXJ0IGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gLSBkaW1lbnNpb24gb2YgY2lyY2xlIGxlZ2VuZCBhcmVhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFJhZGl1cyAtIHBpeGVsIHR5cGUgbWF4aW11bSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByYWRpdXNSYXRpb3MgLSByYWRpdXMgcmF0aW9zXG4gICAgICogQHJldHVybnMge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY29udGFpbmVyLCBkaW1lbnNpb24sIG1heFJhZGl1cywgcmFkaXVzUmF0aW9zKSB7XG4gICAgICAgIHZhciBwYXBlciA9IHJhcGhhZWwoY29udGFpbmVyLCBkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuXG4gICAgICAgIHRoaXMucGFwZXIgPSBwYXBlcjtcblxuICAgICAgICB0aGlzLl9yZW5kZXJDaXJjbGVzKGRpbWVuc2lvbiwgbWF4UmFkaXVzLCByYWRpdXNSYXRpb3MpO1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGNpcmNsZXMuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gLSBkaW1lbnNpb24gb2YgY2lyY2xlIGxlZ2VuZCBhcmVhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFJhZGl1cyAtIHBpeGVsIHR5cGUgbWF4aW11bSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByYWRpdXNSYXRpb3MgLSByYWRpdXMgcmF0aW9zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2lyY2xlczogZnVuY3Rpb24oZGltZW5zaW9uLCBtYXhSYWRpdXMsIHJhZGl1c1JhdGlvcykge1xuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICB2YXIgbGVmdCA9IGRpbWVuc2lvbi53aWR0aCAvIDI7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHJhZGl1c1JhdGlvcywgZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBtYXhSYWRpdXMgKiByYXRpbztcbiAgICAgICAgICAgIHZhciB0b3AgPSAoZGltZW5zaW9uLmhlaWdodCAtIHJhZGl1cykgLSAxO1xuXG4gICAgICAgICAgICByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJDaXJjbGUocGFwZXIsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgICAgICB9LCByYWRpdXMsIHtcbiAgICAgICAgICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjODg4JyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhcGhhZWxDaXJjbGVMZWdlbmQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmFwaGFlbCBsaW5lIGNoYXJ0IHJlbmRlcmVyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmFwaGFlbExpbmVCYXNlID0gcmVxdWlyZSgnLi9yYXBoYWVsTGluZVR5cGVCYXNlJyksXG4gICAgcmFwaGFlbFJlbmRlclV0aWwgPSByZXF1aXJlKCcuL3JhcGhhZWxSZW5kZXJVdGlsJyk7XG5cbnZhciByYXBoYWVsID0gd2luZG93LlJhcGhhZWwsXG4gICAgRU1QSEFTSVNfT1BBQ0lUWSA9IDEsXG4gICAgREVfRU1QSEFTSVNfT1BBQ0lUWSA9IDAuMztcblxudmFyIFJhcGhhZWxMaW5lQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhSYXBoYWVsTGluZUJhc2UsIC8qKiBAbGVuZHMgUmFwaGFlbExpbmVDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJhcGhhZWxMaW5lQ2hhcnRzIGlzIGdyYXBoIHJlbmRlcmVyIGZvciBsaW5lIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIFJhcGhhZWxMaW5lQ2hhcnRcbiAgICAgKiBAZXh0ZW5kcyBSYXBoYWVsTGluZVR5cGVCYXNlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZWxlY3RlZCBsZWdlbmQgaW5kZXhcbiAgICAgICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0eXBlIG9mIGNoYXJ0XG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9ICdsaW5lJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGZ1bmN0aW9uIG9mIGxpbmUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7e2dyb3VwUG9zaXRpb25zOiBBcnJheS48QXJyYXk+LCBkaW1lbnNpb246IG9iamVjdCwgdGhlbWU6IG9iamVjdCwgb3B0aW9uczogb2JqZWN0fX0gZGF0YSByZW5kZXIgZGF0YVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gZGF0YS5kaW1lbnNpb24sXG4gICAgICAgICAgICBncm91cFBvc2l0aW9ucyA9IGRhdGEuZ3JvdXBQb3NpdGlvbnMsXG4gICAgICAgICAgICB0aGVtZSA9IGRhdGEudGhlbWUsXG4gICAgICAgICAgICBjb2xvcnMgPSB0aGVtZS5jb2xvcnMsXG4gICAgICAgICAgICBvcGFjaXR5ID0gZGF0YS5vcHRpb25zLmhhc0RvdCA/IDEgOiAwLFxuICAgICAgICAgICAgaXNTcGxpbmUgPSBkYXRhLm9wdGlvbnMuc3BsaW5lLFxuICAgICAgICAgICAgZ3JvdXBQYXRocyA9IGlzU3BsaW5lID8gdGhpcy5fZ2V0U3BsaW5lTGluZXNQYXRoKGdyb3VwUG9zaXRpb25zKSA6IHRoaXMuX2dldExpbmVzUGF0aChncm91cFBvc2l0aW9ucyksXG4gICAgICAgICAgICBib3JkZXJTdHlsZSA9IHRoaXMubWFrZUJvcmRlclN0eWxlKHRoZW1lLmJvcmRlckNvbG9yLCBvcGFjaXR5KSxcbiAgICAgICAgICAgIG91dERvdFN0eWxlID0gdGhpcy5tYWtlT3V0RG90U3R5bGUob3BhY2l0eSwgYm9yZGVyU3R5bGUpLFxuICAgICAgICAgICAgcGFwZXI7XG5cbiAgICAgICAgdGhpcy5wYXBlciA9IHBhcGVyID0gcmFwaGFlbChjb250YWluZXIsIDEsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICB0aGlzLmlzU3BsaW5lID0gaXNTcGxpbmU7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uO1xuXG4gICAgICAgIHRoaXMuZ3JvdXBMaW5lcyA9IHRoaXMuX3JlbmRlckxpbmVzKHBhcGVyLCBncm91cFBhdGhzLCBjb2xvcnMpO1xuICAgICAgICB0aGlzLnRvb2x0aXBMaW5lID0gdGhpcy5fcmVuZGVyVG9vbHRpcExpbmUocGFwZXIsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICB0aGlzLmdyb3VwRG90cyA9IHRoaXMuX3JlbmRlckRvdHMocGFwZXIsIGdyb3VwUG9zaXRpb25zLCBjb2xvcnMsIG9wYWNpdHkpO1xuXG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkRvdCA9IHRoaXMuX21ha2VTZWxlY3Rpb25Eb3QocGFwZXIpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Db2xvciA9IHRoZW1lLnNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xvcnMgPSBjb2xvcnM7XG4gICAgICAgIHRoaXMuYm9yZGVyU3R5bGUgPSBib3JkZXJTdHlsZTtcbiAgICAgICAgdGhpcy5vdXREb3RTdHlsZSA9IG91dERvdFN0eWxlO1xuICAgICAgICB0aGlzLmdyb3VwUG9zaXRpb25zID0gZ3JvdXBQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBQYXRocyA9IGdyb3VwUGF0aHM7XG4gICAgICAgIHRoaXMuZG90T3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBpdm90R3JvdXBEb3RzO1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxpbmVzIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfT4+fSBncm91cFBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxzdHJpbmc+Pn0gcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVzUGF0aDogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoZ3JvdXBQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICAgICAgcG9zaXRpb25zWzBdLmxlZnQgLT0gMTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX21ha2VMaW5lc1BhdGgocG9zaXRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzcGxpbmUgbGluZXMgcGF0aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHN0YXJ0VG9wOiBudW1iZXJ9Pj59IGdyb3VwUG9zaXRpb25zIHBvc2l0aW9uc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFNwbGluZUxpbmVzUGF0aDogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFBvc2l0aW9ucywgdGhpcy5fbWFrZVNwbGluZUxpbmVzUGF0aCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxzdHJpbmc+Pn0gZ3JvdXBQYXRocyBwYXRoc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGNvbG9ycyBsaW5lIGNvbG9yc1xuICAgICAqIEBwYXJhbSB7P251bWJlcn0gc3Ryb2tlV2lkdGggc3Ryb2tlIHdpZHRoXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGxpbmVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTGluZXM6IGZ1bmN0aW9uKHBhcGVyLCBncm91cFBhdGhzLCBjb2xvcnMsIHN0cm9rZVdpZHRoKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoZ3JvdXBQYXRocywgZnVuY3Rpb24ocGF0aCwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JzW2dyb3VwSW5kZXhdIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICByZXR1cm4gcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyTGluZShwYXBlciwgcGF0aC5qb2luKCcgJyksIGNvbG9yLCBzdHJva2VXaWR0aCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgZ3JhcGggb2YgbGluZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDpudW1iZXJ9fSBwYXJhbXMuZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0Om51bWJlciwgdG9wOm51bWJlcn0+Pn0gcGFyYW1zLmdyb3VwUG9zaXRpb25zIGdyb3VwIHBvc2l0aW9uc1xuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHBhcmFtcy5kaW1lbnNpb24sXG4gICAgICAgICAgICBncm91cFBvc2l0aW9ucyA9IHBhcmFtcy5ncm91cFBvc2l0aW9ucztcblxuICAgICAgICB0aGlzLmdyb3VwUG9zaXRpb25zID0gZ3JvdXBQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBQYXRocyA9IHRoaXMuaXNTcGxpbmUgPyB0aGlzLl9nZXRTcGxpbmVMaW5lc1BhdGgoZ3JvdXBQb3NpdGlvbnMpIDogdGhpcy5fZ2V0TGluZXNQYXRoKGdyb3VwUG9zaXRpb25zKTtcbiAgICAgICAgdGhpcy5wYXBlci5zZXRTaXplKGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIHRoaXMudG9vbHRpcExpbmUuYXR0cih7dG9wOiBkaW1lbnNpb24uaGVpZ2h0fSk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuZ3JvdXBQYXRocywgZnVuY3Rpb24ocGF0aCwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgc2VsZi5ncm91cExpbmVzW2dyb3VwSW5kZXhdLmF0dHIoe3BhdGg6IHBhdGguam9pbignICcpfSk7XG5cbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZWxmLmdyb3VwRG90c1tncm91cEluZGV4XSwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9tb3ZlRG90KGl0ZW0uZG90LmRvdCwgZ3JvdXBQb3NpdGlvbnNbZ3JvdXBJbmRleF1baW5kZXhdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGxlZ2VuZEluZGV4IGxlZ2VuZCBpbmRleFxuICAgICAqL1xuICAgIHNlbGVjdExlZ2VuZDogZnVuY3Rpb24obGVnZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgbm9uZVNlbGVjdGVkID0gdHVpLnV0aWwuaXNOdWxsKGxlZ2VuZEluZGV4KTtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXggPSBsZWdlbmRJbmRleDtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5ncm91cFBhdGhzLCBmdW5jdGlvbihwYXRoLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IChub25lU2VsZWN0ZWQgfHwgbGVnZW5kSW5kZXggPT09IGdyb3VwSW5kZXgpID8gRU1QSEFTSVNfT1BBQ0lUWSA6IERFX0VNUEhBU0lTX09QQUNJVFk7XG5cbiAgICAgICAgICAgIHNlbGYuZ3JvdXBMaW5lc1tncm91cEluZGV4XS5hdHRyKHsnc3Ryb2tlLW9wYWNpdHknOiBvcGFjaXR5fSk7XG5cbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZWxmLmdyb3VwRG90c1tncm91cEluZGV4XSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0ub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kb3RPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZG90LmRvdC5hdHRyKHsnZmlsbC1vcGFjaXR5Jzogb3BhY2l0eX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXBoYWVsTGluZUNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWxMaW5lVHlwZUJhc2UgaXMgYmFzZSBjbGFzcyBmb3IgbGluZSB0eXBlIHJlbmRlcmVyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFwaGFlbFJlbmRlclV0aWwgPSByZXF1aXJlKCcuL3JhcGhhZWxSZW5kZXJVdGlsJyk7XG5cbnZhciBBTklNQVRJT05fVElNRSA9IDcwMCxcbiAgICBERUZBVUxUX0RPVF9SQURJVVMgPSAzLFxuICAgIEhPVkVSX0RPVF9SQURJVVMgPSA0LFxuICAgIFNFTEVDVElPTl9ET1RfUkFESVVTID0gNyxcbiAgICBERV9FTVBIQVNJU19PUEFDSVRZID0gMC4zO1xuXG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFJhcGhhZWxMaW5lVHlwZUJhc2UgaXMgYmFzZSBmb3IgbGluZSB0eXBlIHJlbmRlcmVyLlxuICogQGNsYXNzIFJhcGhhZWxMaW5lVHlwZUJhc2VcbiAqL1xudmFyIFJhcGhhZWxMaW5lVHlwZUJhc2UgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFJhcGhhZWxMaW5lVHlwZUJhc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBNYWtlIGxpbmVzIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHN0YXJ0VG9wOiBudW1iZXJ9Pn0gcG9zaXRpb25zIHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gcG9zVG9wVHlwZSBwb3NpdGlvbiB0b3AgdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nIHwgbnVtYmVyPn0gcGF0aHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGluZXNQYXRoOiBmdW5jdGlvbihwb3NpdGlvbnMsIHBvc1RvcFR5cGUpIHtcbiAgICAgICAgdmFyIHBhdGg7XG5cbiAgICAgICAgcG9zVG9wVHlwZSA9IHBvc1RvcFR5cGUgfHwgJ3RvcCc7XG4gICAgICAgIHBhdGggPSB0dWkudXRpbC5tYXAocG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIFsnTCcsIHBvc2l0aW9uLmxlZnQsIHBvc2l0aW9uW3Bvc1RvcFR5cGVdXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGF0aCA9IGNvbmNhdC5hcHBseShbXSwgcGF0aCk7XG4gICAgICAgIHBhdGhbMF0gPSAnTSc7XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbmNob3IuIChodHRwOi8vcmFwaGFlbGpzLmNvbS9hbmFseXRpY3MuanMpXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGZyb21Qb3MgZnJvbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3MgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gbmV4dFBvcyBuZXh0IHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge3t4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyfX0gYW5jaG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QW5jaG9yOiBmdW5jdGlvbihmcm9tUG9zLCBwb3MsIG5leHRQb3MpIHtcbiAgICAgICAgdmFyIGwxID0gKHBvcy5sZWZ0IC0gZnJvbVBvcy5sZWZ0KSAvIDIsXG4gICAgICAgICAgICBsMiA9IChuZXh0UG9zLmxlZnQgLSBwb3MubGVmdCkgLyAyLFxuICAgICAgICAgICAgYSA9IE1hdGguYXRhbigocG9zLmxlZnQgLSBmcm9tUG9zLmxlZnQpIC8gTWF0aC5hYnMocG9zLnRvcCAtIGZyb21Qb3MudG9wKSksXG4gICAgICAgICAgICBiID0gTWF0aC5hdGFuKChuZXh0UG9zLmxlZnQgLSBwb3MubGVmdCkgLyBNYXRoLmFicyhwb3MudG9wIC0gbmV4dFBvcy50b3ApKSxcbiAgICAgICAgICAgIGFscGhhLCBkeDEsIGR5MSwgZHgyLCBkeTI7XG5cbiAgICAgICAgYSA9IGZyb21Qb3MudG9wIDwgcG9zLnRvcCA/IE1hdGguUEkgLSBhIDogYTtcbiAgICAgICAgYiA9IG5leHRQb3MudG9wIDwgcG9zLnRvcCA/IE1hdGguUEkgLSBiIDogYjtcbiAgICAgICAgYWxwaGEgPSBNYXRoLlBJIC8gMiAtICgoYSArIGIpICUgKE1hdGguUEkgKiAyKSkgLyAyO1xuICAgICAgICBkeDEgPSBsMSAqIE1hdGguc2luKGFscGhhICsgYSk7XG4gICAgICAgIGR5MSA9IGwxICogTWF0aC5jb3MoYWxwaGEgKyBhKTtcbiAgICAgICAgZHgyID0gbDIgKiBNYXRoLnNpbihhbHBoYSArIGIpO1xuICAgICAgICBkeTIgPSBsMiAqIE1hdGguY29zKGFscGhhICsgYik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiBwb3MubGVmdCAtIGR4MSxcbiAgICAgICAgICAgIHkxOiBwb3MudG9wICsgZHkxLFxuICAgICAgICAgICAgeDI6IHBvcy5sZWZ0ICsgZHgyLFxuICAgICAgICAgICAgeTI6IHBvcy50b3AgKyBkeTJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzcGxpbmUgbGluZXMgcGF0aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn0+fSBwb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmcgfCBudW1iZXI+fSBwYXRoc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTcGxpbmVMaW5lc1BhdGg6IGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBmaXJzdFBvcyA9IHBvc2l0aW9uc1swXSxcbiAgICAgICAgICAgIHBvc2l0aW9uc0xlbiA9IHBvc2l0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICBmcm9tUG9zID0gZmlyc3RQb3MsXG4gICAgICAgICAgICBsYXN0UG9zID0gcG9zaXRpb25zW3Bvc2l0aW9uc0xlbiAtIDFdLFxuICAgICAgICAgICAgbWlkZGxlUG9zaXRpb25zID0gcG9zaXRpb25zLnNsaWNlKDEpLnNsaWNlKDAsIHBvc2l0aW9uc0xlbiAtIDIpLFxuICAgICAgICAgICAgcGF0aCA9IHR1aS51dGlsLm1hcChtaWRkbGVQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0UG9zID0gcG9zaXRpb25zW2luZGV4ICsgMl0sXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IHNlbGYuX2dldEFuY2hvcihmcm9tUG9zLCBwb3NpdGlvbiwgbmV4dFBvcyk7XG4gICAgICAgICAgICAgICAgZnJvbVBvcyA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYW5jaG9yLngxLCBhbmNob3IueTEsIHBvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnRvcCwgYW5jaG9yLngyLCBhbmNob3IueTJdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZmlyc3RQb3MubGVmdCAtPSAxO1xuICAgICAgICBwYXRoLnB1c2goW2xhc3RQb3MubGVmdCwgbGFzdFBvcy50b3AsIGxhc3RQb3MubGVmdCwgbGFzdFBvcy50b3BdKTtcbiAgICAgICAgcGF0aC51bnNoaWZ0KFsnTScsIGZpcnN0UG9zLmxlZnQsIGZpcnN0UG9zLnRvcCwgJ0MnLCBmaXJzdFBvcy5sZWZ0LCBmaXJzdFBvcy50b3BdKTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRvb2x0aXAgbGluZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaGVpZ2h0XG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJUb29sdGlwTGluZTogZnVuY3Rpb24ocGFwZXIsIGhlaWdodCkge1xuICAgICAgICB2YXIgbGluZVBhdGggPSByYXBoYWVsUmVuZGVyVXRpbC5tYWtlTGluZVBhdGgoe1xuICAgICAgICAgICAgbGVmdDogMTAsXG4gICAgICAgICAgICB0b3A6IGhlaWdodFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsZWZ0OiAxMCxcbiAgICAgICAgICAgIHRvcDogMFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyTGluZShwYXBlciwgbGluZVBhdGgsICd0cmFuc3BhcmVudCcsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvcmRlciBzdHlsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYm9yZGVyQ29sb3IgYm9yZGVyIGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHt7c3Ryb2tlOiBzdHJpbmcsIHN0cm9rZS13aWR0aDogbnVtYmVyLCBzdHJpa2Utb3BhY2l0eTogbnVtYmVyfX0gYm9yZGVyIHN0eWxlXG4gICAgICovXG4gICAgbWFrZUJvcmRlclN0eWxlOiBmdW5jdGlvbihib3JkZXJDb2xvciwgb3BhY2l0eSkge1xuICAgICAgICB2YXIgYm9yZGVyU3R5bGU7XG5cbiAgICAgICAgaWYgKGJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICBib3JkZXJTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IGJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAxLFxuICAgICAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IG9wYWNpdHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9yZGVyU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZG90IHN0eWxlIGZvciBtb3VzZW91dCBldmVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBvcGFjaXR5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvcmRlclN0eWxlIGJvcmRlciBzdHlsZVxuICAgICAqIEByZXR1cm5zIHt7ZmlsbC1vcGFjaXR5OiBudW1iZXIsIHN0cm9rZS1vcGFjaXR5OiBudW1iZXIsIHI6IG51bWJlcn19IHN0eWxlXG4gICAgICovXG4gICAgbWFrZU91dERvdFN0eWxlOiBmdW5jdGlvbihvcGFjaXR5LCBib3JkZXJTdHlsZSkge1xuICAgICAgICB2YXIgb3V0RG90U3R5bGUgPSB7XG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5Jzogb3BhY2l0eSxcbiAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDAsXG4gICAgICAgICAgICByOiBERUZBVUxUX0RPVF9SQURJVVNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYm9yZGVyU3R5bGUpIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmV4dGVuZChvdXREb3RTdHlsZSwgYm9yZGVyU3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dERvdFN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZG90LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGFlclxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBkb3QgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgZG90IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJhcGhhZWwgZG90XG4gICAgICovXG4gICAgcmVuZGVyRG90OiBmdW5jdGlvbihwYXBlciwgcG9zaXRpb24sIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICAgIHZhciBkb3QgPSBwYXBlci5jaXJjbGUocG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wLCBERUZBVUxUX0RPVF9SQURJVVMpLFxuICAgICAgICAgICAgZG90U3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IG9wYWNpdHksXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICBkb3QuYXR0cihkb3RTdHlsZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvdDogZG90LFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBkb3RzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBncm91cFBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjb2xvcnMgY29sb3JzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gZG90c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckRvdHM6IGZ1bmN0aW9uKHBhcGVyLCBncm91cFBvc2l0aW9ucywgY29sb3JzLCBvcGFjaXR5KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGRvdHMgPSB0dWkudXRpbC5tYXAoZ3JvdXBQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9ucywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yc1tncm91cEluZGV4XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvdE1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdDogc2VsZi5yZW5kZXJEb3QocGFwZXIsIHBvc2l0aW9uLCBjb2xvciwgb3BhY2l0eSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zaXRvbjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNSYW5nZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRvbiA9IHR1aS51dGlsLmV4dGVuZCh7fSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3NpdG9uLnRvcCA9IHN0YXJ0UG9zaXRvbi5zdGFydFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdE1hcC5zdGFydERvdCA9IHNlbGYucmVuZGVyRG90KHBhcGVyLCBzdGFydFBvc2l0b24sIGNvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3RNYXA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZG90cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNlbnRlciBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBmcm9tUG9zIGZyb20gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gdG9Qb3MgdG8gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENlbnRlcjogZnVuY3Rpb24oZnJvbVBvcywgdG9Qb3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IChmcm9tUG9zLmxlZnQgKyB0b1Bvcy5sZWZ0KSAvIDIsXG4gICAgICAgICAgICB0b3A6IChmcm9tUG9zLnRvcCArIHRvUG9zLnRvcCkgLyAyXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgZG90LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkb3QgcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93RG90OiBmdW5jdGlvbihkb3QpIHtcbiAgICAgICAgZG90LmF0dHIoe1xuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwLjMsXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMixcbiAgICAgICAgICAgIHI6IEhPVkVSX0RPVF9SQURJVVNcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBsaW5lIHN0cm9rZSB3aWR0aC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbGluZSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJva2VXaWR0aCBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVMaW5lU3Ryb2tlV2lkdGg6IGZ1bmN0aW9uKGxpbmUsIHN0cm9rZVdpZHRoKSB7XG4gICAgICAgIGxpbmUuYXR0cih7XG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogc3Ryb2tlV2lkdGhcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6bnVtYmVyfX0gZGF0YSBzaG93IGluZm9cbiAgICAgKi9cbiAgICBzaG93QW5pbWF0aW9uOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGRhdGEuZ3JvdXBJbmRleCwgLy8gTGluZSBjaGFydCBoYXMgcGl2b3QgdmFsdWVzLlxuICAgICAgICAgICAgZ3JvdXBJbmRleCA9IGRhdGEuaW5kZXgsXG4gICAgICAgICAgICBsaW5lID0gdGhpcy5ncm91cExpbmVzID8gdGhpcy5ncm91cExpbmVzW2dyb3VwSW5kZXhdIDogdGhpcy5ncm91cEFyZWFzW2dyb3VwSW5kZXhdLFxuICAgICAgICAgICAgaXRlbSA9IHRoaXMuZ3JvdXBEb3RzW2dyb3VwSW5kZXhdW2luZGV4XSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLCBzdGFydExpbmU7XG5cbiAgICAgICAgaWYgKHRoaXMuY2hhcnRUeXBlID09PSAnYXJlYScpIHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gMjtcbiAgICAgICAgICAgIHN0YXJ0TGluZSA9IGxpbmUuc3RhcnRMaW5lO1xuICAgICAgICAgICAgbGluZSA9IGxpbmUubGluZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gMztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxpbmVTdHJva2VXaWR0aChsaW5lLCBzdHJva2VXaWR0aCk7XG5cbiAgICAgICAgaWYgKHN0YXJ0TGluZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGluZVN0cm9rZVdpZHRoKHN0YXJ0TGluZSwgc3Ryb2tlV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2hvd0RvdChpdGVtLmRvdC5kb3QpO1xuXG4gICAgICAgIGlmIChpdGVtLnN0YXJ0RG90KSB7XG4gICAgICAgICAgICB0aGlzLl9zaG93RG90KGl0ZW0uc3RhcnREb3QuZG90KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGl2b3QgZ3JvdXAgZG90cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5Pn0gZG90c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFBpdm90R3JvdXBEb3RzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBpdm90R3JvdXBEb3RzKSB7XG4gICAgICAgICAgICB0aGlzLnBpdm90R3JvdXBEb3RzID0gdHVpLnV0aWwucGl2b3QodGhpcy5ncm91cERvdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGl2b3RHcm91cERvdHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgZ3JvdXAgZG90cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93R3JvdXBEb3RzOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBncm91cERvdHMgPSB0aGlzLl9nZXRQaXZvdEdyb3VwRG90cygpO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShncm91cERvdHNbaW5kZXhdLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBzZWxmLl9zaG93RG90KGl0ZW0uZG90LmRvdCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGxpbmUgZm9yIGdyb3VwIHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYm91bmQgYm91bmRcbiAgICAgKi9cbiAgICBzaG93R3JvdXBUb29sdGlwTGluZTogZnVuY3Rpb24oYm91bmQpIHtcbiAgICAgICAgdmFyIGxpbmVQYXRoID0gcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHtcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kLnBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICB0b3A6IGJvdW5kLnBvc2l0aW9uLnRvcCArIGJvdW5kLmRpbWVuc2lvbi5oZWlnaHRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGVmdDogYm91bmQucG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIHRvcDogYm91bmQucG9zaXRpb24udG9wXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudG9vbHRpcExpbmUuYXR0cih7XG4gICAgICAgICAgICBwYXRoOiBsaW5lUGF0aCxcbiAgICAgICAgICAgIHN0cm9rZTogJyM5OTknLFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBncm91cCBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICovXG4gICAgc2hvd0dyb3VwQW5pbWF0aW9uOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB0aGlzLl9zaG93R3JvdXBEb3RzKGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBkb3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRvdCByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gb3BhY2l0eSBvcGFjaXR5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlkZURvdDogZnVuY3Rpb24oZG90LCBvcGFjaXR5KSB7XG4gICAgICAgIHZhciBvdXREb3RTdHlsZSA9IHRoaXMub3V0RG90U3R5bGU7XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc1VuZGVmaW5lZChvcGFjaXR5KSkge1xuICAgICAgICAgICAgb3V0RG90U3R5bGUgPSB0dWkudXRpbC5leHRlbmQoe30sIHRoaXMub3V0RG90U3R5bGUsIHtcbiAgICAgICAgICAgICAgICAnZmlsbC1vcGFjaXR5Jzogb3BhY2l0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBkb3QuYXR0cihvdXREb3RTdHlsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6bnVtYmVyfX0gZGF0YSBoaWRlIGluZm9cbiAgICAgKi9cbiAgICBoaWRlQW5pbWF0aW9uOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGRhdGEuZ3JvdXBJbmRleCwgLy8gTGluZSBjaGFydCBoYXMgcGl2b3QgdmFsdWVzLlxuICAgICAgICAgICAgZ3JvdXBJbmRleCA9IGRhdGEuaW5kZXgsXG4gICAgICAgICAgICBsaW5lID0gdGhpcy5ncm91cExpbmVzID8gdGhpcy5ncm91cExpbmVzW2dyb3VwSW5kZXhdIDogdGhpcy5ncm91cEFyZWFzW2dyb3VwSW5kZXhdLFxuICAgICAgICAgICAgaXRlbSA9IHRoaXMuZ3JvdXBEb3RzW2dyb3VwSW5kZXhdW2luZGV4XSxcbiAgICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLmRvdE9wYWNpdHksXG4gICAgICAgICAgICBzdHJva2VXaWR0aCwgc3RhcnRMaW5lO1xuXG4gICAgICAgIGlmICh0aGlzLmNoYXJ0VHlwZSA9PT0gJ2FyZWEnKSB7XG4gICAgICAgICAgICBzdHJva2VXaWR0aCA9IDE7XG4gICAgICAgICAgICBzdGFydExpbmUgPSBsaW5lLnN0YXJ0TGluZTtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLmxpbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJva2VXaWR0aCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3BhY2l0eSAmJiAhdHVpLnV0aWwuaXNOdWxsKHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCkgJiYgdGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4ICE9PSBncm91cEluZGV4KSB7XG4gICAgICAgICAgICBvcGFjaXR5ID0gREVfRU1QSEFTSVNfT1BBQ0lUWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMaW5lU3Ryb2tlV2lkdGgobGluZSwgc3Ryb2tlV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0TGluZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGluZVN0cm9rZVdpZHRoKHN0YXJ0TGluZSwgc3Ryb2tlV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGVEb3QoaXRlbS5kb3QuZG90LCBvcGFjaXR5KTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0uc3RhcnREb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlRG90KGl0ZW0uc3RhcnREb3QuZG90LCBvcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGdyb3VwIGRvdHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlkZUdyb3VwRG90czogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgZG90cyA9IHRoaXMuX2dldFBpdm90R3JvdXBEb3RzKCksXG4gICAgICAgICAgICBoYXNTZWxlY3RlZEluZGV4ID0gIXR1aS51dGlsLmlzTnVsbCh0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXgpLFxuICAgICAgICAgICAgYmFzZU9wYWNpdHkgPSB0aGlzLmRvdE9wYWNpdHk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGRvdHNbaW5kZXhdLCBmdW5jdGlvbihpdGVtLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IGJhc2VPcGFjaXR5O1xuXG4gICAgICAgICAgICBpZiAob3BhY2l0eSAmJiBoYXNTZWxlY3RlZEluZGV4ICYmIHNlbGYuc2VsZWN0ZWRMZWdlbmRJbmRleCAhPT0gZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBERV9FTVBIQVNJU19PUEFDSVRZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLl9oaWRlRG90KGl0ZW0uZG90LmRvdCwgb3BhY2l0eSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGxpbmUgZm9yIGdyb3VwIHRvb2x0aXAuXG4gICAgICovXG4gICAgaGlkZUdyb3VwVG9vbHRpcExpbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnRvb2x0aXBMaW5lLmF0dHIoe1xuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBncm91cCBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICovXG4gICAgaGlkZUdyb3VwQW5pbWF0aW9uOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB0aGlzLl9oaWRlR3JvdXBEb3RzKGluZGV4KTtcbiAgICB9LFxuXG4gICAgX21vdmVEb3Q6IGZ1bmN0aW9uKGRvdCwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGRvdEF0dHJzID0ge1xuICAgICAgICAgICAgY3g6IHBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICBjeTogcG9zaXRpb24udG9wXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuZG90T3BhY2l0eSkge1xuICAgICAgICAgICAgZG90QXR0cnMgPSB0dWkudXRpbC5leHRlbmQoeydmaWxsLW9wYWNpdHknOiB0aGlzLmRvdE9wYWNpdHl9LCBkb3RBdHRycywgdGhpcy5ib3JkZXJTdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkb3QuYXR0cihkb3RBdHRycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25GaW5pc2ggY2FsbGJhY2tcbiAgICAgKi9cbiAgICBhbmltYXRlOiBmdW5jdGlvbihvbkZpbmlzaCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZXJpZXNXaWR0aCA9IHRoaXMuZGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgc2VyaWVzSGVpZ2h0ID0gdGhpcy5kaW1lbnNpb24uaGVpZ2h0O1xuXG4gICAgICAgIHR1aS5jaGFydC5yZW5kZXJVdGlsLmNhbmNlbEFuaW1hdGlvbih0aGlzLmFuaW1hdGlvbik7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSB0dWkuY2hhcnQucmVuZGVyVXRpbC5zdGFydEFuaW1hdGlvbihBTklNQVRJT05fVElNRSwgZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IE1hdGgubWluKHNlcmllc1dpZHRoICogcmF0aW8sIHNlcmllc1dpZHRoKTtcblxuICAgICAgICAgICAgc2VsZi5wYXBlci5zZXRTaXplKHdpZHRoLCBzZXJpZXNIZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAocmF0aW8gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBvbkZpbmlzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZWxlY3Rpb24gZG90LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VsZWN0aW9uIGRvdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZWxlY3Rpb25Eb3Q6IGZ1bmN0aW9uKHBhcGVyKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25Eb3QgPSBwYXBlci5jaXJjbGUoMCwgMCwgU0VMRUNUSU9OX0RPVF9SQURJVVMpO1xuXG4gICAgICAgIHNlbGVjdGlvbkRvdC5hdHRyKHtcbiAgICAgICAgICAgICdmaWxsJzogJyNmZmZmZmYnLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25Eb3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5ncm91cERvdHNbaW5kZXhlcy5pbmRleF1baW5kZXhlcy5ncm91cEluZGV4XSxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5ncm91cFBvc2l0aW9uc1tpbmRleGVzLmluZGV4XVtpbmRleGVzLmdyb3VwSW5kZXhdO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Eb3QuYXR0cih7XG4gICAgICAgICAgICBjeDogcG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIGN5OiBwb3NpdGlvbi50b3AsXG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMC41LFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMSxcbiAgICAgICAgICAgIHN0cm9rZTogdGhpcy5zZWxlY3Rpb25Db2xvciB8fCBpdGVtLmRvdC5jb2xvclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydERvdCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydERvdC5hdHRyKHtcbiAgICAgICAgICAgICAgICBjeDogcG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgICAgICBjeTogcG9zaXRpb24uc3RhcnRUb3AsXG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAuNSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAxLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5zZWxlY3Rpb25Db2xvciB8fCBpdGVtLnN0YXJ0RG90LmNvbG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbnNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgdW5zZWxlY3RTZXJpZXM6IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdyb3VwRG90c1tpbmRleGVzLmluZGV4XVtpbmRleGVzLmdyb3VwSW5kZXhdO1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Eb3QuYXR0cih7XG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydERvdCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydERvdC5hdHRyKHtcbiAgICAgICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMCxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhcGhhZWxMaW5lVHlwZUJhc2U7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmFwaGFlbFBpZUNoYXJ0cyBpcyBncmFwaCByZW5kZXJlciBmb3IgbWFwIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFwaGFlbFJlbmRlclV0aWwgPSByZXF1aXJlKCcuL3JhcGhhZWxSZW5kZXJVdGlsJyk7XG5cbnZhciByYXBoYWVsID0gd2luZG93LlJhcGhhZWw7XG5cbnZhciBTVFJPS0VfQ09MT1IgPSAnZ3JheScsXG4gICAgQU5JTUFUSU9OX1RJTUUgPSAxMDA7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBSYXBoYWVsTWFwQ2hhcnRzIGlzIGdyYXBoIHJlbmRlcmVyIGZvciBtYXAgY2hhcnQuXG4gKiBAY2xhc3MgUmFwaGFlbE1hcENoYXJ0XG4gKi9cbnZhciBSYXBoYWVsTWFwQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFJhcGhhZWxNYXBDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBmdW5jdGlvbiBvZiBtYXAgY2hhcnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGF0YS5kaW1lbnNpb24gc2VyaWVzIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48e2NvZGU6IHN0cmluZywgcGF0aDogc3RyaW5nfT59IGRhdGEubWFwIG1hcERhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7TWFwQ2hhcnRDb2xvck1vZGVsfSBkYXRhLmNvbG9yTW9kZWwgY29sb3IgbW9kZWxcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uLFxuICAgICAgICAgICAgbWFwRGltZW5zaW9uID0gZGF0YS5tYXBNb2RlbC5nZXRNYXBEaW1lbnNpb24oKSxcbiAgICAgICAgICAgIHBhcGVyO1xuXG4gICAgICAgIHRoaXMucGFwZXIgPSBwYXBlciA9IHJhcGhhZWwoY29udGFpbmVyLCBkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICB0aGlzLnNlY3RvcnMgPSB0aGlzLl9yZW5kZXJNYXAoZGF0YSk7XG4gICAgICAgIHRoaXMub3ZlckNvbG9yID0gZGF0YS50aGVtZS5vdmVyQ29sb3I7XG5cbiAgICAgICAgcGFwZXIuc2V0Vmlld0JveCgwLCAwLCBtYXBEaW1lbnNpb24ud2lkdGgsIG1hcERpbWVuc2lvbi5oZWlnaHQsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gcGFwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBtYXAgZ3JhcGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkYXRhLmRpbWVuc2lvbiBzZXJpZXMgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5Ljx7Y29kZTogc3RyaW5nLCBwYXRoOiBzdHJpbmd9Pn0gZGF0YS5tYXAgbWFwRGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtNYXBDaGFydENvbG9yTW9kZWx9IGRhdGEuY29sb3JNb2RlbCBjb2xvciBtb2RlbFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e3NlY3Rvcjogb2JqZWN0LCBjb2xvcjogc3RyaW5nLCBkYXRhOiBvYmplY3R9Pn0gcmVuZGVyZWQgbWFwIGluZm9ybWF0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTWFwOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXIsXG4gICAgICAgICAgICBjb2xvck1vZGVsID0gZGF0YS5jb2xvck1vZGVsO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoZGF0YS5tYXBNb2RlbC5nZXRNYXBEYXRhKCksIGZ1bmN0aW9uKGRhdHVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gZGF0dW0ucmF0aW8gfHwgMCxcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yTW9kZWwuZ2V0Q29sb3IocmF0aW8pLFxuICAgICAgICAgICAgICAgIHNlY3RvciA9IHJhcGhhZWxSZW5kZXJVdGlsLnJlbmRlckFyZWEocGFwZXIsIGRhdHVtLnBhdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogU1RST0tFX0NPTE9SLFxuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAxXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlY3Rvci5kYXRhKCdpbmRleCcsIGluZGV4KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZWN0b3I6IHNlY3RvcixcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgcmF0aW86IGRhdHVtLnJhdGlvXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBzZWN0b3IgaW5kZXguXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMgez9udW1iZXJ9IGZvdW5kIGluZGV4XG4gICAgICovXG4gICAgZmluZFNlY3RvckluZGV4OiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5wYXBlci5nZXRFbGVtZW50QnlQb2ludChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApLFxuICAgICAgICAgICAgZm91bmRJbmRleCA9IHNlY3RvciAmJiBzZWN0b3IuZGF0YSgnaW5kZXgnKSxcbiAgICAgICAgICAgIGRhdGEgPSAhdHVpLnV0aWwuaXNVbmRlZmluZWQoZm91bmRJbmRleCkgJiYgdGhpcy5zZWN0b3JzW2ZvdW5kSW5kZXhdO1xuXG4gICAgICAgIHJldHVybiBkYXRhICYmICF0dWkudXRpbC5pc1VuZGVmaW5lZChkYXRhLnJhdGlvKSA/IGZvdW5kSW5kZXggOiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgY29sb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICovXG4gICAgY2hhbmdlQ29sb3I6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBzZWN0b3IgPSB0aGlzLnNlY3RvcnNbaW5kZXhdO1xuXG4gICAgICAgIHNlY3Rvci5zZWN0b3IuYW5pbWF0ZSh7XG4gICAgICAgICAgICBmaWxsOiB0aGlzLm92ZXJDb2xvclxuICAgICAgICB9LCBBTklNQVRJT05fVElNRSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgY29sb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICovXG4gICAgcmVzdG9yZUNvbG9yOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5zZWN0b3JzW2luZGV4XTtcblxuICAgICAgICBzZWN0b3Iuc2VjdG9yLmFuaW1hdGUoe1xuICAgICAgICAgICAgZmlsbDogc2VjdG9yLmNvbG9yXG4gICAgICAgIH0sIEFOSU1BVElPTl9USU1FKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHNpemVcbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBzZXRTaXplOiBmdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgICAgICAgdGhpcy5wYXBlci5zZXRTaXplKGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbE1hcENoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWxNYXBMZWdlbmQgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIG1hcCBjaGFydCBsZWdlbmQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50IG5vLW1hZ2ljLW51bWJlcnM6IDAqL1xuXG52YXIgcmFwaGFlbCA9IHdpbmRvdy5SYXBoYWVsO1xuXG52YXIgUEFERElORyA9IDEwO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgUmFwaGFlbE1hcExlZ2VuZCBpcyBncmFwaCByZW5kZXJlciBmb3IgbWFwIGNoYXJ0IGxlZ2VuZC5cbiAqIEBjbGFzcyBSYXBoYWVsTWFwTGVnZW5kXG4gKi9cbnZhciBSYXBoYWVsTWFwTGVnZW5kID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBSYXBoYWVsTWFwTGVnZW5kLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGZ1bmN0aW9uIG9mIG1hcCBjaGFydCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGxlZ2VuZCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge01hcENoYXJ0Q29sb3JNb2RlbH0gY29sb3JNb2RlbCBtYXAgY2hhcnQgY29sb3IgbW9kZWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSG9yaXpvbnRhbCB3aGV0aGVyIGhvcml6b250YWwgbGVnZW5kIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGltZW5zaW9uLCBjb2xvck1vZGVsLCBpc0hvcml6b250YWwpIHtcbiAgICAgICAgdmFyIHBhcGVyID0gcmFwaGFlbChjb250YWluZXIsIGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyR3JhZGllbnRCYXIocGFwZXIsIGRpbWVuc2lvbiwgY29sb3JNb2RlbCwgaXNIb3Jpem9udGFsKTtcbiAgICAgICAgdGhpcy53ZWRnZSA9IHRoaXMuX3JlbmRlcldlZGdlKHBhcGVyKTtcblxuICAgICAgICByZXR1cm4gcGFwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBncmFkaWVudCBiYXIuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gbGVnZW5kIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7TWFwQ2hhcnRDb2xvck1vZGVsfSBjb2xvck1vZGVsIG1hcCBjaGFydCBjb2xvciBtb2RlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIb3Jpem9udGFsIHdoZXRoZXIgaG9yaXpvbnRhbCBsZWdlbmQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyR3JhZGllbnRCYXI6IGZ1bmN0aW9uKHBhcGVyLCBkaW1lbnNpb24sIGNvbG9yTW9kZWwsIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgcmVjdFdpZHRoID0gZGltZW5zaW9uLndpZHRoIC0gUEFERElORyxcbiAgICAgICAgICAgIHJlY3RIZWlnaHQgPSBkaW1lbnNpb24uaGVpZ2h0LFxuICAgICAgICAgICAgbGVmdCA9IDAsXG4gICAgICAgICAgICBkZWdyZWU7XG5cbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmVjdEhlaWdodCAtPSBQQURESU5HO1xuICAgICAgICAgICAgbGVmdCA9IFBBRERJTkcgLyAyO1xuICAgICAgICAgICAgZGVncmVlID0gMzYwO1xuICAgICAgICAgICAgdGhpcy5fbWFrZVdlZGdoUGF0aCA9IHRoaXMuX21ha2VIb3Jpem9udGFsV2VkZ2VQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVncmVlID0gMjcwO1xuICAgICAgICAgICAgdGhpcy5fbWFrZVdlZGdoUGF0aCA9IHRoaXMuX21ha2VWZXJ0aWNhbFdlZGdlUGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcGVyLnJlY3QobGVmdCwgMCwgcmVjdFdpZHRoLCByZWN0SGVpZ2h0KS5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IGRlZ3JlZSArICctJyArIGNvbG9yTW9kZWwuc3RhcnQgKyAnLScgKyBjb2xvck1vZGVsLmVuZCxcbiAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgd2VkZ2UuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJXZWRnZTogZnVuY3Rpb24ocGFwZXIpIHtcbiAgICAgICAgdmFyIHdlZGdlID0gcGFwZXIucGF0aCh0aGlzLnZlcnRpY2FsQmFzZVBhdGgpLmF0dHIoe1xuICAgICAgICAgICAgJ2ZpbGwnOiAnZ3JheScsXG4gICAgICAgICAgICBzdHJva2U6ICdub25lJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHdlZGdlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBiYXNlIHBhdGhcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdmVydGljYWxCYXNlUGF0aDogWydNJywgMTYsIDYsICdMJywgMjQsIDMsICdMJywgMjQsIDldLFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB2ZXJ0aWNhbCB3ZWRnZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgdG9wXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsV2VkZ2VQYXRoOiBmdW5jdGlvbih0b3ApIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnZlcnRpY2FsQmFzZVBhdGg7XG5cbiAgICAgICAgcGF0aFsyXSA9IHRvcDtcbiAgICAgICAgcGF0aFs1XSA9IHRvcCAtIDM7XG4gICAgICAgIHBhdGhbOF0gPSB0b3AgKyAzO1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIGJhc2UgcGF0aFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBob3Jpem9udGFsQmFzZVBhdGg6IFsnTScsIDUsIDE2LCAnTCcsIDgsIDI0LCAnTCcsIDIsIDI0XSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaG9yaXpvbnRhbCB3ZWRnZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGxlZnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbFdlZGdlUGF0aDogZnVuY3Rpb24obGVmdCkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuaG9yaXpvbnRhbEJhc2VQYXRoO1xuXG4gICAgICAgIGxlZnQgKz0gUEFERElORyAvIDI7XG5cbiAgICAgICAgcGF0aFsxXSA9IGxlZnQ7XG4gICAgICAgIHBhdGhbNF0gPSBsZWZ0ICsgMztcbiAgICAgICAgcGF0aFs3XSA9IGxlZnQgLSAzO1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHdlZGdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblZhbHVlIHRvcFxuICAgICAqL1xuICAgIHNob3dXZWRnZTogZnVuY3Rpb24ocG9zaXRpb25WYWx1ZSkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuX21ha2VXZWRnaFBhdGgocG9zaXRpb25WYWx1ZSk7XG5cbiAgICAgICAgdGhpcy53ZWRnZS5hdHRyKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHdlZGdlXG4gICAgICovXG4gICAgaGlkZVdlZGdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy53ZWRnZS5hdHRyKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbE1hcExlZ2VuZDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSYXBoYWVsUGllQ2hhcnRzIGlzIGdyYXBoIHJlbmRlcmVyIGZvciBwaWUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIHJhcGhhZWwgPSB3aW5kb3cuUmFwaGFlbCxcbiAgICBERUdSRUVfMTgwID0gMTgwLFxuICAgIERFR1JFRV8zNjAgPSAzNjAsXG4gICAgTUlOX0RFR1JFRSA9IDAuMDEsXG4gICAgUkFEID0gTWF0aC5QSSAvIERFR1JFRV8xODAsXG4gICAgQU5JTUFUSU9OX1RJTUUgPSA1MDAsXG4gICAgTE9BRElOR19BTklNQVRJT05fVElNRSA9IDcwMCxcbiAgICBFTVBIQVNJU19PUEFDSVRZID0gMSxcbiAgICBERV9FTVBIQVNJU19PUEFDSVRZID0gMC4zLFxuICAgIERFRkFVTFRfTFVNSU5BTkMgPSAwLjI7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBSYXBoYWVsUGllQ2hhcnRzIGlzIGdyYXBoIHJlbmRlcmVyIGZvciBwaWUgY2hhcnQuXG4gKiBAY2xhc3MgUmFwaGFlbFBpZUNoYXJ0XG4gKi9cbnZhciBSYXBoYWVsUGllQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFJhcGhhZWxQaWVDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBmdW5jdGlvbiBvZiBwaWUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgc2VjdG9yRGF0YTogQXJyYXkuPG9iamVjdD4sXG4gICAgICogICAgICBjaXJjbGVCb3VuZDoge2N4OiBudW1iZXIsIGN5OiBudW1iZXIsIHI6IG51bWJlcn0sXG4gICAgICogICAgICBkaW1lbnNpb246IG9iamVjdCwgdGhlbWU6IG9iamVjdCwgb3B0aW9uczogb2JqZWN0XG4gICAgICogfX0gZGF0YSByZW5kZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYWxsYmFja3MgY2FsbGJhY2tzXG4gICAgICogICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3Muc2hvd1Rvb2x0aXAgc2hvdyB0b29sdGlwIGZ1bmN0aW9uXG4gICAgICogICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3MuaGlkZVRvb2x0aXAgaGlkZSB0b29sdGlwIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhLCBjYWxsYmFja3MpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uLFxuICAgICAgICAgICAgcGFwZXI7XG5cbiAgICAgICAgLy9SYXBoYWVsLl9vaWQgPSAwO1xuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXIgPSByYXBoYWVsKGNvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICBpZiAoIXBhcGVyLmN1c3RvbUF0dHJpYnV0ZXMuc2VjdG9yKSB7XG4gICAgICAgICAgICBwYXBlci5jdXN0b21BdHRyaWJ1dGVzLnNlY3RvciA9IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZVNlY3RvclBhdGgsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbG9yID0gZGF0YS50aGVtZS5zZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgdGhpcy5jaXJjbGVCb3VuZCA9IGRhdGEuY2lyY2xlQm91bmQ7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyUGllKHBhcGVyLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHBhcGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBwYXBlci5cbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucGFwZXIuY2xlYXIoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VjdG9yIHBhdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN4IGNlbnRlciB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN5IGNlbnRlciB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHIgcmFkaXVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGUgc3RhcnQgYW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGUgZW5kIGFuZ2VsXG4gICAgICogQHJldHVybnMge3twYXRoOiBBcnJheX19IHNlY3RvciBwYXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNlY3RvclBhdGg6IGZ1bmN0aW9uKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgICAgICAgdmFyIHgxID0gY3ggKyByICogTWF0aC5zaW4oc3RhcnRBbmdsZSAqIFJBRCksIC8vIOybkCDtmLjsnZgg7Iuc7J6RIHgg7KKM7ZGcXG4gICAgICAgICAgICB5MSA9IGN5IC0gciAqIE1hdGguY29zKHN0YXJ0QW5nbGUgKiBSQUQpLCAvLyDsm5Ag7Zi47J2YIOyLnOyekSB5IOyijO2RnFxuICAgICAgICAgICAgeDIgPSBjeCArIHIgKiBNYXRoLnNpbihlbmRBbmdsZSAqIFJBRCksIC8vIOybkCDtmLjsnZgg7KKF66OMIHgg7KKM7ZGcXG4gICAgICAgICAgICB5MiA9IGN5IC0gciAqIE1hdGguY29zKGVuZEFuZ2xlICogUkFEKSwgLy8g7JuQIO2YuOydmCDsooXro4wgeSDsooztkZxcbiAgICAgICAgICAgIGxhcmdlQXJjRmxhZyA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSA+IERFR1JFRV8xODAgPyAxIDogMCxcbiAgICAgICAgICAgIHBhdGggPSBbJ00nLCBjeCwgY3ksXG4gICAgICAgICAgICAgICAgJ0wnLCB4MSwgeTEsXG4gICAgICAgICAgICAgICAgJ0EnLCByLCByLCAwLCBsYXJnZUFyY0ZsYWcsIDEsIHgyLCB5MixcbiAgICAgICAgICAgICAgICAnWidcbiAgICAgICAgICAgIF07XG4gICAgICAgIC8vIHBhdGjsl5Ag64yA7ZWcIOyekOyEuO2VnCDshKTrqoXsnYAg7JWE656YIOunge2BrOulvCDssLjqs6BcbiAgICAgICAgLy8gaHR0cDovL3d3dy53M3NjaG9vbHMuY29tL3N2Zy9zdmdfcGF0aC5hc3BcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9kXG4gICAgICAgIHJldHVybiB7cGF0aDogcGF0aH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzZWN0b3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMucGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqICAgICAgQHBhcmFtIHt7Y3g6IG51bWJlciwgY3k6IG51bWJlciwgcjpudW1iZXJ9fSBwYXJhbXMuY2lyY2xlQm91bmQgY2lyY2xlIGJvdW5kc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydEFuZ2xlIHN0YXJ0IGFuZ2xlXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZEFuZ2xlIGVuZCBhbmdsZVxuICAgICAqICAgICAgQHBhcmFtIHt7ZmlsbDogc3RyaW5nLCBzdHJva2U6IHN0cmluZywgc3RyaWtlLXdpZHRoOiBzdHJpbmd9fSBwYXJhbXMuYXR0cnMgYXR0cnNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlY3RvcjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBjaXJjbGVCb3VuZCA9IHBhcmFtcy5jaXJjbGVCb3VuZCxcbiAgICAgICAgICAgIGFuZ2xlcyA9IHBhcmFtcy5hbmdsZXM7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5wYXBlci5wYXRoKCkuYXR0cih7XG4gICAgICAgICAgICBzZWN0b3I6IFtjaXJjbGVCb3VuZC5jeCwgY2lyY2xlQm91bmQuY3ksIGNpcmNsZUJvdW5kLnIsIGFuZ2xlcy5zdGFydEFuZ2xlLCBhbmdsZXMuZW5kQW5nbGVdXG4gICAgICAgIH0pLmF0dHIocGFyYW1zLmF0dHJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHBpZSBncmFwaC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgc2VjdG9yRGF0YTogQXJyYXkuPG9iamVjdD4sXG4gICAgICogICAgICBjaXJjbGVCb3VuZDoge2N4OiBudW1iZXIsIGN5OiBudW1iZXIsIHI6IG51bWJlcn0sXG4gICAgICogICAgICBkaW1lbnNpb246IG9iamVjdCwgdGhlbWU6IG9iamVjdCwgb3B0aW9uczogb2JqZWN0XG4gICAgICogfX0gZGF0YSByZW5kZXIgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclBpZTogZnVuY3Rpb24ocGFwZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgY2lyY2xlQm91bmQgPSBkYXRhLmNpcmNsZUJvdW5kLFxuICAgICAgICAgICAgY29sb3JzID0gZGF0YS50aGVtZS5jb2xvcnMsXG4gICAgICAgICAgICBjaGFydEJhY2tncm91bmQgPSBkYXRhLmNoYXJ0QmFja2dyb3VuZCxcbiAgICAgICAgICAgIHNlY3RvcnMgPSBbXTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoZGF0YS5zZWN0b3JEYXRhLCBmdW5jdGlvbihzZWN0b3JEYXR1bSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwZXJjZW50VmFsdWUgPSBzZWN0b3JEYXR1bS5wZXJjZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgY29sb3IgPSBjb2xvcnNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIHNlY3RvciA9IHNlbGYuX3JlbmRlclNlY3Rvcih7XG4gICAgICAgICAgICAgICAgICAgIHBhcGVyOiBwYXBlcixcbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlQm91bmQ6IGNpcmNsZUJvdW5kLFxuICAgICAgICAgICAgICAgICAgICBhbmdsZXM6IHNlY3RvckRhdHVtLmFuZ2xlcy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBjaGFydEJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0b3IuZGF0YSgnaW5kZXgnLCBpbmRleCk7XG4gICAgICAgICAgICBzZWN0b3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlY3Rvcjogc2VjdG9yLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICBhbmdsZXM6IHNlY3RvckRhdHVtLmFuZ2xlcy5lbmQsXG4gICAgICAgICAgICAgICAgcGVyY2VudFZhbHVlOiBwZXJjZW50VmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNlY3RvcnMgPSBzZWN0b3JzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbGVnZW5kIGxpbmVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IG91dGVyUG9zaXRpb25zIG91dGVyIHBvc2l0aW9uXG4gICAgICovXG4gICAgcmVuZGVyTGVnZW5kTGluZXM6IGZ1bmN0aW9uKG91dGVyUG9zaXRpb25zKSB7XG4gICAgICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXIsXG4gICAgICAgICAgICBwYXRocztcblxuICAgICAgICBpZiAoIXRoaXMubGVnZW5kTGluZXMpIHtcbiAgICAgICAgICAgIHBhdGhzID0gdGhpcy5fbWFrZUxpbmVQYXRocyhvdXRlclBvc2l0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmxlZ2VuZExpbmVzID0gdHVpLnV0aWwubWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhcGhhZWxSZW5kZXJVdGlsLnJlbmRlckxpbmUocGFwZXIsIHBhdGgsICd0cmFuc3BhcmVudCcsIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsaW5lIHBhdGhzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IG91dGVyUG9zaXRpb25zIG91dGVyIHBvc2l0aW9uc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gbGluZSBwYXRocy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGluZVBhdGhzOiBmdW5jdGlvbihvdXRlclBvc2l0aW9ucykge1xuICAgICAgICB2YXIgcGF0aHMgPSB0dWkudXRpbC5tYXAob3V0ZXJQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICByYXBoYWVsUmVuZGVyVXRpbC5tYWtlTGluZVBhdGgocG9zaXRpb25zLnN0YXJ0LCBwb3NpdGlvbnMubWlkZGxlKSxcbiAgICAgICAgICAgICAgICByYXBoYWVsUmVuZGVyVXRpbC5tYWtlTGluZVBhdGgocG9zaXRpb25zLm1pZGRsZSwgcG9zaXRpb25zLmVuZCksXG4gICAgICAgICAgICAgICAgJ1onXG4gICAgICAgICAgICBdLmpvaW4oJycpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGF0aHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZCBzZWxlY3RvciByYWRpdXMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlY3RvciBwaWUgc2VjdG9yXG4gICAgICovXG4gICAgX2V4cGFuZFNlY3RvcjogZnVuY3Rpb24oc2VjdG9yKSB7XG4gICAgICAgIHZhciBjeCA9IHRoaXMuY2lyY2xlQm91bmQuY3gsXG4gICAgICAgICAgICBjeSA9IHRoaXMuY2lyY2xlQm91bmQuY3k7XG5cbiAgICAgICAgc2VjdG9yLmFuaW1hdGUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAnczEuMSAxLjEgJyArIGN4ICsgJyAnICsgY3lcbiAgICAgICAgfSwgQU5JTUFUSU9OX1RJTUUsICdlbGFzdGljJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgc2VsZWN0b3IgcmFkaXVzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZWN0b3IgcGllIHNlY3RvclxuICAgICAqL1xuICAgIF9yZXN0b3JlU2VjdG9yOiBmdW5jdGlvbihzZWN0b3IpIHtcbiAgICAgICAgc2VjdG9yLmFuaW1hdGUoe3RyYW5zZm9ybTogJyd9LCBBTklNQVRJT05fVElNRSwgJ2VsYXN0aWMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYW5pbWF0ZSBleHBhbmRpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHNlY3RvciBpbmRleFxuICAgICAqL1xuICAgIF9hbmltYXRlRXhwYW5kaW5nOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5zZWN0b3JzW2luZGV4XS5zZWN0b3I7XG5cbiAgICAgICAgaWYgKHRoaXMucHJldk1vdmVkU2VjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlUmVzdG9yaW5nKHRoaXMucHJldk1vdmVkU2VjdG9yLmRhdGEoJ2luZGV4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZXhwYW5kU2VjdG9yKHNlY3Rvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgcmVzdG9yaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBzZWN0b3IgaW5kZXhcbiAgICAgKi9cbiAgICBfYW5pbWF0ZVJlc3RvcmluZzogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHNlY3RvciA9IHRoaXMuc2VjdG9yc1tpbmRleF0uc2VjdG9yO1xuICAgICAgICB0aGlzLl9yZXN0b3JlU2VjdG9yKHNlY3Rvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBhbmltYXRlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgZGVsYXlUaW1lID0gMCxcbiAgICAgICAgICAgIGNpcmNsZUJvdW5kID0gdGhpcy5jaXJjbGVCb3VuZDtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5zZWN0b3JzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB2YXIgYW5nbGVzID0gaXRlbS5hbmdsZXMsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uVGltZSwgYW5pbTtcblxuICAgICAgICAgICAgaWYgKGFuZ2xlcy5zdGFydEFuZ2xlID09PSAwICYmIGFuZ2xlcy5lbmRBbmdsZSA9PT0gREVHUkVFXzM2MCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlcy5lbmRBbmdsZSA9IERFR1JFRV8zNjAgLSBNSU5fREVHUkVFO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbmltYXRpb25UaW1lID0gTE9BRElOR19BTklNQVRJT05fVElNRSAqIGl0ZW0ucGVyY2VudFZhbHVlO1xuICAgICAgICAgICAgYW5pbSA9IHJhcGhhZWwuYW5pbWF0aW9uKHtcbiAgICAgICAgICAgICAgICBzZWN0b3I6IFtjaXJjbGVCb3VuZC5jeCwgY2lyY2xlQm91bmQuY3ksIGNpcmNsZUJvdW5kLnIsIGFuZ2xlcy5zdGFydEFuZ2xlLCBhbmdsZXMuZW5kQW5nbGVdXG4gICAgICAgICAgICB9LCBhbmltYXRpb25UaW1lKTtcblxuICAgICAgICAgICAgaXRlbS5zZWN0b3IuYW5pbWF0ZShhbmltLmRlbGF5KGRlbGF5VGltZSkpO1xuICAgICAgICAgICAgZGVsYXlUaW1lICs9IGFuaW1hdGlvblRpbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXlUaW1lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGxlZ2VuZCBsaW5lcy5cbiAgICAgKi9cbiAgICBhbmltYXRlTGVnZW5kTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMubGVnZW5kTGluZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmxlZ2VuZExpbmVzLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICBsaW5lLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgICdzdHJva2UnOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgZ3JhcGggb2YgcGllIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge3tjeDpudW1iZXIsIGN5Om51bWJlciwgcjogbnVtYmVyfX0gcGFyYW1zLmNpcmNsZUJvdW5kIGNpcmNsZSBib3VuZFxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBwYXJhbXMuZGltZW5zaW9uLFxuICAgICAgICAgICAgY2lyY2xlQm91bmQgPSBwYXJhbXMuY2lyY2xlQm91bmQ7XG5cbiAgICAgICAgdGhpcy5jaXJjbGVCb3VuZCA9IGNpcmNsZUJvdW5kO1xuICAgICAgICB0aGlzLnBhcGVyLnNldFNpemUoZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY29udGFpbmVyQm91bmQ7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuc2VjdG9ycywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIGFuZ2xlcyA9IGl0ZW0uYW5nbGVzO1xuICAgICAgICAgICAgaXRlbS5zZWN0b3IuYXR0cih7XG4gICAgICAgICAgICAgICAgc2VjdG9yOiBbY2lyY2xlQm91bmQuY3gsIGNpcmNsZUJvdW5kLmN5LCBjaXJjbGVCb3VuZC5yLCBhbmdsZXMuc3RhcnRBbmdsZSwgYW5nbGVzLmVuZEFuZ2xlXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGxlZ2VuZCBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBvdXRlclBvc2l0aW9ucyBvdXRlciBwb3NpdGlvbnNcbiAgICAgKi9cbiAgICBtb3ZlTGVnZW5kTGluZXM6IGZ1bmN0aW9uKG91dGVyUG9zaXRpb25zKSB7XG4gICAgICAgIHZhciBwYXRocztcblxuICAgICAgICBpZiAoIXRoaXMubGVnZW5kTGluZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGhzID0gdGhpcy5fbWFrZUxpbmVQYXRocyhvdXRlclBvc2l0aW9ucyk7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmxlZ2VuZExpbmVzLCBmdW5jdGlvbihsaW5lLCBpbmRleCkge1xuICAgICAgICAgICAgbGluZS5hdHRyKHtwYXRoOiBwYXRoc1tpbmRleF19KTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xpY2sgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIGNsaWNrU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5wYXBlci5nZXRFbGVtZW50QnlQb2ludChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApO1xuXG4gICAgICAgIGlmIChzZWN0b3IgJiYgdGhpcy5wcmV2U2VsZWN0ZWRTZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc2VsZWN0U2VyaWVzKHRoaXMucHJldlNlbGVjdGVkU2VjdG9yLmRhdGEoJ2luZGV4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJldlNlbGVjdGVkU2VjdG9yID09PSBzZWN0b3IpIHtcbiAgICAgICAgICAgIHNlY3RvciA9IG51bGw7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2U2VsZWN0ZWRTZWN0b3I7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RTZXJpZXMoc2VjdG9yLmRhdGEoJ2luZGV4JykpO1xuICAgICAgICAgICAgdGhpcy5wcmV2U2VsZWN0ZWRTZWN0b3IgPSBzZWN0b3I7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VyaWVzIGNvbnRhaW5lciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBjb250YWluZXIgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDb250YWluZXJCb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXJCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJCb3VuZCA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckJvdW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNoYW5nZWQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2UG9zaXRpb24gcHJldmlvdXMgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0NoYW5nZWRQb3NpdGlvbjogZnVuY3Rpb24ocHJldlBvc2l0aW9uLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gIXByZXZQb3NpdGlvbiB8fCBwcmV2UG9zaXRpb24ubGVmdCAhPT0gcG9zaXRpb24ubGVmdCB8fCBwcmV2UG9zaXRpb24udG9wICE9PSBwb3NpdGlvbi50b3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmUgbW91c2Ugb24gc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIG1vdmVNb3VzZU9uU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5wYXBlci5nZXRFbGVtZW50QnlQb2ludChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApLFxuICAgICAgICAgICAgY29udGFpbmVyQm91bmQsIGFyZ3MsIGNoYW5nZWRTZWN0b3I7XG5cbiAgICAgICAgaWYgKHNlY3RvciAmJiB0aGlzLnNlY3RvcnNbc2VjdG9yLmRhdGEoJ2luZGV4JyldKSB7XG4gICAgICAgICAgICBjb250YWluZXJCb3VuZCA9IHRoaXMuX2dldENvbnRhaW5lckJvdW5kKCk7XG4gICAgICAgICAgICBjaGFuZ2VkU2VjdG9yID0gdGhpcy5wcmV2TW92ZWRTZWN0b3IgIT09IHNlY3RvcjtcbiAgICAgICAgICAgIGFyZ3MgPSBbe30sIDAsIHNlY3Rvci5kYXRhKCdpbmRleCcpLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGNvbnRhaW5lckJvdW5kLmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgLSBjb250YWluZXJCb3VuZC50b3BcbiAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICBpZiAoY2hhbmdlZFNlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVFeHBhbmRpbmcoc2VjdG9yLmRhdGEoJ2luZGV4JykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNDaGFuZ2VkUG9zaXRpb24odGhpcy5wcmV2UG9zaXRpb24sIHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNob3dUb29sdGlwLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldk1vdmVkU2VjdG9yID0gc2VjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldk1vdmVkU2VjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlUmVzdG9yaW5nKHRoaXMucHJldk1vdmVkU2VjdG9yLmRhdGEoJ2luZGV4JykpO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIHRoaXMucHJldk1vdmVkU2VjdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Qgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbGVjdFNlcmllczogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnNlY3RvcnNbaW5kZXhdLFxuICAgICAgICAgICAgb2JqQ29sb3IgPSByYXBoYWVsLmNvbG9yKGl0ZW0uY29sb3IpLFxuICAgICAgICAgICAgY29sb3IgPSB0aGlzLnNlbGVjdGlvbkNvbG9yIHx8IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VDaGFuZ2VkTHVtaW5hbmNlQ29sb3Iob2JqQ29sb3IuaGV4LCBERUZBVUxUX0xVTUlOQU5DKTtcblxuICAgICAgICBpdGVtLnNlY3Rvci5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IGNvbG9yXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmVsZWN0IHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bnNlbGVjdFNlcmllczogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHNlY3RvciA9IHRoaXMuc2VjdG9yc1tpbmRleF07XG5cbiAgICAgICAgc2VjdG9yLnNlY3Rvci5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IHNlY3Rvci5jb2xvclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGxlZ2VuZEluZGV4IGxlZ2VuZCBpbmRleFxuICAgICAqL1xuICAgIHNlbGVjdExlZ2VuZDogZnVuY3Rpb24obGVnZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIGlzTnVsbCA9IHR1aS51dGlsLmlzTnVsbChsZWdlbmRJbmRleCk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuc2VjdG9ycywgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5O1xuXG4gICAgICAgICAgICBvcGFjaXR5ID0gKGlzTnVsbCB8fCBsZWdlbmRJbmRleCA9PT0gaW5kZXgpID8gRU1QSEFTSVNfT1BBQ0lUWSA6IERFX0VNUEhBU0lTX09QQUNJVFk7XG5cbiAgICAgICAgICAgIGl0ZW0uc2VjdG9yLmF0dHIoe1xuICAgICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBvcGFjaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbFBpZUNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWwgZm9yIHJhcGhhZWwgcmVuZGVyaW5nLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFV0aWwgZm9yIHJhcGhhZWwgcmVuZGVyaW5nLlxuICogQG1vZHVsZSByYXBoYWVsUmVuZGVyVXRpbFxuICovXG52YXIgcmFwaGFlbFJlbmRlclV0aWwgPSB7XG4gICAgLyoqXG4gICAgICogTWFrZSBsaW5lIHBhdGguXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyYXBoYWVsUmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBmcm9tUG9zIGZyb20gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gdG9Qb3MgdG8gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwYXRoXG4gICAgICovXG4gICAgbWFrZUxpbmVQYXRoOiBmdW5jdGlvbihmcm9tUG9zLCB0b1Bvcywgd2lkdGgpIHtcbiAgICAgICAgdmFyIGZyb21Qb2ludCA9IFtmcm9tUG9zLmxlZnQsIGZyb21Qb3MudG9wXSxcbiAgICAgICAgICAgIHRvUG9pbnQgPSBbdG9Qb3MubGVmdCwgdG9Qb3MudG9wXTtcblxuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGZyb21Qb2ludCwgZnVuY3Rpb24oZnJvbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0b1BvaW50W2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGZyb21Qb2ludFtpbmRleF0gPSB0b1BvaW50W2luZGV4XSA9IE1hdGgucm91bmQoZnJvbSkgLSAod2lkdGggJSAyIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gWydNJ10uY29uY2F0KGZyb21Qb2ludCkuY29uY2F0KCdMJykuY29uY2F0KHRvUG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbGluZS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJhcGhhZWxSZW5kZXJVdGlsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBsaW5lIHBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgbGluZSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJva2VXaWR0aCBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByYXBoYWVsIGxpbmVcbiAgICAgKi9cbiAgICByZW5kZXJMaW5lOiBmdW5jdGlvbihwYXBlciwgcGF0aCwgY29sb3IsIHN0cm9rZVdpZHRoKSB7XG4gICAgICAgIHZhciBsaW5lID0gcGFwZXIucGF0aChbcGF0aF0pLFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogc3Ryb2tlV2lkdGggfHwgMlxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlLnN0cm9rZSA9ICcjZmZmJztcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlWydzdHJva2Utb3BhY2l0eSddID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsaW5lLmF0dHIoc3Ryb2tlU3R5bGUpO1xuXG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYXJlYSBncmFwaC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGhcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZmlsbFN0eWxlIGZpbGwgc3R5bGVcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBmaWxsU3R5bGUuZmlsbCBmaWxsIGNvbG9yXG4gICAgICogICAgICBAcGFyYW0gez9udW1iZXJ9IGZpbGxTdHlsZS5vcGFjaXR5IGZpbGwgb3BhY2l0eVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IGZpbGxTdHlsZS5zdHJva2Ugc3Ryb2tlIGNvbG9yXG4gICAgICogICAgICBAcGFyYW0gez9udW1iZXJ9IGZpbGxTdHlsZS5zdHJva2Utb3BhY2l0eSBzdHJva2Ugb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gcmFwaGFlbCBvYmplY3RcbiAgICAgKi9cbiAgICByZW5kZXJBcmVhOiBmdW5jdGlvbihwYXBlciwgcGF0aCwgZmlsbFN0eWxlKSB7XG4gICAgICAgIHZhciBhcmVhID0gcGFwZXIucGF0aChwYXRoKTtcblxuICAgICAgICBmaWxsU3R5bGUgPSB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMFxuICAgICAgICB9LCBmaWxsU3R5bGUpO1xuICAgICAgICBhcmVhLmF0dHIoZmlsbFN0eWxlKTtcblxuICAgICAgICByZXR1cm4gYXJlYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGNpcmNsZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgLSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiAtIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIHJhZGl1c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW5kZXJDaXJjbGU6IGZ1bmN0aW9uKHBhcGVyLCBwb3NpdGlvbiwgcmFkaXVzLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBjaXJjbGUgPSBwYXBlci5jaXJjbGUocG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wLCByYWRpdXMpO1xuXG4gICAgICAgIGNpcmNsZS5hdHRyKGF0dHJpYnV0ZXMpO1xuXG4gICAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBpdGVtcyBvZiBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBncm91cEl0ZW1zIGdyb3VwIGl0ZW1zXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1JlbmRlckl0ZW0gZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmb3JFYWNoMmRBcnJheTogZnVuY3Rpb24oZ3JvdXBJdGVtcywgZnVuY1JlbmRlckl0ZW0pIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGdyb3VwSXRlbXMsIGZ1bmN0aW9uKGl0ZW1zLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgZnVuY1JlbmRlckl0ZW0oaXRlbSwgZ3JvdXBJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNoYW5nZWQgbHVtaW5hbmNlIGNvbG9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXggaGF4IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGx1bSBsdW1pbmFuY2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjaGFuZ2VkIGNvbG9yXG4gICAgICovXG4gICAgbWFrZUNoYW5nZWRMdW1pbmFuY2VDb2xvcjogZnVuY3Rpb24oaGV4LCBsdW0pIHtcbiAgICAgICAgLyplc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogMCovXG4gICAgICAgIHZhciBjaGFuZ2VkSGV4O1xuXG4gICAgICAgIGhleCA9IGhleC5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgICBsdW0gPSBsdW0gfHwgMDtcblxuICAgICAgICBjaGFuZ2VkSGV4ID0gdHVpLnV0aWwubWFwKHR1aS51dGlsLnJhbmdlKDMpLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgdmFyIGhkID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpbmRleCAqIDIsIDIpLCAxNik7XG4gICAgICAgICAgICB2YXIgbmV3SGQgPSBoZCArIChoZCAqIGx1bSk7XG5cbiAgICAgICAgICAgIG5ld0hkID0gTWF0aC5yb3VuZChNYXRoLm1pbihNYXRoLm1heCgwLCBuZXdIZCksIDI1NSkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJldHVybiB0dWkuY2hhcnQucmVuZGVyVXRpbC5mb3JtYXRUb1plcm9GaWxsKG5ld0hkLCAyKTtcbiAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuICcjJyArIGNoYW5nZWRIZXg7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSByYXBoYWVsUmVuZGVyVXRpbDtcbiIsIi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT05cbmlmICghd2luZG93LkpTT04pIHtcbiAgICB3aW5kb3cuSlNPTiA9IHtcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHNKU09OKSB7IHJldHVybiBldmFsKCcoJyArIHNKU09OICsgJyknKTsgfSxcbiAgICAgICAgc3RyaW5naWZ5OiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICAgICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdG9TdHJpbmcuY2FsbChhKSA9PT0gJ1tvYmplY3QgQXJyYXldJzsgfTtcbiAgICAgICAgICAgIHZhciBlc2NNYXAgPSB7J1wiJzogJ1xcXFxcIicsICdcXFxcJzogJ1xcXFxcXFxcJywgJ1xcYic6ICdcXFxcYicsICdcXGYnOiAnXFxcXGYnLCAnXFxuJzogJ1xcXFxuJywgJ1xccic6ICdcXFxccicsICdcXHQnOiAnXFxcXHQnfTtcbiAgICAgICAgICAgIHZhciBlc2NGdW5jID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGVzY01hcFttXSB8fCAnXFxcXHUnICsgKG0uY2hhckNvZGVBdCgwKSArIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7IH07XG4gICAgICAgICAgICB2YXIgZXNjUkUgPSAvW1xcXFxcIlxcdTAwMDAtXFx1MDAxRlxcdTIwMjhcXHUyMDI5XS9nO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogJ251bGwnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlLnRvSlNPTigpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9ICdbJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IChpID8gJywgJyA6ICcnKSArIHN0cmluZ2lmeSh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goc3RyaW5naWZ5KGspICsgJzogJyArIHN0cmluZ2lmeSh2YWx1ZVtrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd7JyArIHRtcC5qb2luKCcsICcpICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnXCInICsgdmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKGVzY1JFLCBlc2NGdW5jKSArICdcIic7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpXG4gICAgfTtcbn1cblxuLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbi8vIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcblxuLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJ5IEVyaWsgTcO2bGxlci4gZml4ZXMgZnJvbSBQYXVsIElyaXNoIGFuZCBUaW5vIFppamRlbFxuXG4vLyBNSVQgbGljZW5zZVxuXG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgdmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ11cbiAgICAgICAgICAgIHx8IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIH1cblxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGltZVRvQ2FsbCk7XG4gICAgICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIH07XG4gICAgfVxufSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuL2NvbnN0JyksXG4gICAgY2hhcnRGYWN0b3J5ID0gcmVxdWlyZSgnLi9mYWN0b3JpZXMvY2hhcnRGYWN0b3J5JyksXG4gICAgQmFyQ2hhcnQgPSByZXF1aXJlKCcuL2NoYXJ0cy9iYXJDaGFydCcpLFxuICAgIENvbHVtbkNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvY29sdW1uQ2hhcnQnKSxcbiAgICBMaW5lQ2hhcnQgPSByZXF1aXJlKCcuL2NoYXJ0cy9saW5lQ2hhcnQnKSxcbiAgICBBcmVhQ2hhcnQgPSByZXF1aXJlKCcuL2NoYXJ0cy9hcmVhQ2hhcnQnKSxcbiAgICBDb21ib0NoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvY29tYm9DaGFydCcpLFxuICAgIFBpZUNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvcGllQ2hhcnQnKSxcbiAgICBCdWJibGVDaGFydCA9IHJlcXVpcmUoJy4vY2hhcnRzL2J1YmJsZUNoYXJ0JyksXG4gICAgTWFwQ2hhcnQgPSByZXF1aXJlKCcuL2NoYXJ0cy9tYXBDaGFydCcpO1xuXG5jaGFydEZhY3RvcnkucmVnaXN0ZXIoY2hhcnRDb25zdC5DSEFSVF9UWVBFX0JBUiwgQmFyQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9DT0xVTU4sIENvbHVtbkNoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfTElORSwgTGluZUNoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfQVJFQSwgQXJlYUNoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfQ09NQk8sIENvbWJvQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9QSUUsIFBpZUNoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfQlVCQkxFLCBCdWJibGVDaGFydCk7XG5jaGFydEZhY3RvcnkucmVnaXN0ZXIoY2hhcnRDb25zdC5DSEFSVF9UWVBFX01BUCwgTWFwQ2hhcnQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4vY29uc3QnKSxcbiAgICB0aGVtZUZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3Rvcmllcy90aGVtZUZhY3RvcnknKSxcbiAgICBkZWZhdWx0VGhlbWUgPSByZXF1aXJlKCcuL3RoZW1lcy9kZWZhdWx0VGhlbWUnKTtcblxudGhlbWVGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuREVGQVVMVF9USEVNRV9OQU1FLCBkZWZhdWx0VGhlbWUpO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFyZWEgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyksXG4gICAgTGluZVR5cGVTZXJpZXNCYXNlID0gcmVxdWlyZSgnLi9saW5lVHlwZVNlcmllc0Jhc2UnKSxcbiAgICBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpO1xuXG52YXIgQXJlYUNoYXJ0U2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoU2VyaWVzLCAvKiogQGxlbmRzIEFyZWFDaGFydFNlcmllcy5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEFyZWEgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBBcmVhQ2hhcnRTZXJpZXNcbiAgICAgKiBAZXh0ZW5kcyBTZXJpZXNcbiAgICAgKiBAbWl4ZXMgTGluZVR5cGVTZXJpZXNCYXNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm1vZGVsIHNlcmllcyBtb2RlbFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIHNlcmllcyBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBTZXJpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwb3NpdGlvbiB0b3Agb2YgemVybyBwb2ludC5cbiAgICAgKiBAcGFyYW0ge3toZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB0b3BcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUG9zaXRpb25Ub3BPZlplcm9Qb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJyksXG4gICAgICAgICAgICBsaW1pdCA9IHRoaXMuZGF0YS5saW1pdCxcbiAgICAgICAgICAgIGxpbWl0RGlzdGFuY2UgPSB0aGlzLl9nZXRMaW1pdERpc3RhbmNlRnJvbVplcm9Qb2ludChkaW1lbnNpb24uaGVpZ2h0LCBsaW1pdCksXG4gICAgICAgICAgICB0b3AgPSBsaW1pdERpc3RhbmNlLnRvTWF4O1xuXG4gICAgICAgIGlmIChsaW1pdC5taW4gPj0gMCAmJiAhdG9wKSB7XG4gICAgICAgICAgICB0b3AgPSBkaW1lbnNpb24uaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvcCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN0YWNrZWQgcG9zaXRpb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn0+Pn0gZ3JvdXBQb3NpdGlvbnMgZ3JvdXAgcG9zaXRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHN0YXJ0VG9wOiBudW1iZXJ9Pj59IHN0YWNrZWQgcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVN0YWNrZWRQb3NpdGlvbnM6IGZ1bmN0aW9uKGdyb3VwUG9zaXRpb25zKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJykuaGVpZ2h0ICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICBmaXJzdFN0YXJ0VG9wID0gdGhpcy5fbWFrZVBvc2l0aW9uVG9wT2ZaZXJvUG9pbnQoKSxcbiAgICAgICAgICAgIHByZXZQb3NpdGlvblRvcHMgPSBbXTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGdyb3VwUG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAocG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlRvcCA9IHByZXZQb3NpdGlvblRvcHNbaW5kZXhdIHx8IGZpcnN0U3RhcnRUb3AsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrZWRIZWlnaHQgPSBoZWlnaHQgLSBwb3NpdGlvbi50b3AsXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHByZXZUb3AgLSBzdGFja2VkSGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc3RhcnRUb3AgPSBwcmV2VG9wO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnRvcCA9IHRvcDtcblxuICAgICAgICAgICAgICAgIHByZXZQb3NpdGlvblRvcHNbaW5kZXhdID0gdG9wO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwb3NpdGlvbnMuXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHN0YXJ0VG9wOiBudW1iZXJ9Pj59IHN0YWNrZWQgcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBvc2l0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncm91cFBvc2l0aW9ucyA9IHRoaXMuX21ha2VCYXNpY1Bvc2l0aW9ucygpO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNWYWxpZFN0YWNrZWRPcHRpb24odGhpcy5vcHRpb25zLnN0YWNrZWQpKSB7XG4gICAgICAgICAgICBncm91cFBvc2l0aW9ucyA9IHRoaXMuX21ha2VTdGFja2VkUG9zaXRpb25zKGdyb3VwUG9zaXRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncm91cFBvc2l0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKSxcbiAgICAgICAgICAgIHplcm9Ub3AgPSB0aGlzLl9nZXRMaW1pdERpc3RhbmNlRnJvbVplcm9Qb2ludChkaW1lbnNpb24uaGVpZ2h0LCB0aGlzLmRhdGEubGltaXQpLnRvTWF4O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cFBvc2l0aW9uczogdGhpcy5fbWFrZVBvc2l0aW9ucygpLFxuICAgICAgICAgICAgaGFzUmFuZ2VEYXRhOiB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzRGF0YU1vZGVsKHRoaXMuY2hhcnRUeXBlKS5oYXNSYW5nZURhdGEoKSxcbiAgICAgICAgICAgIHplcm9Ub3A6IHplcm9Ub3AgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG5MaW5lVHlwZVNlcmllc0Jhc2UubWl4aW4oQXJlYUNoYXJ0U2VyaWVzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcmVhQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmFyIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuL3NlcmllcycpLFxuICAgIEJhclR5cGVTZXJpZXNCYXNlID0gcmVxdWlyZSgnLi9iYXJUeXBlU2VyaWVzQmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIGNhbGN1bGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGN1bGF0b3InKTtcblxudmFyIEJhckNoYXJ0U2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoU2VyaWVzLCAvKiogQGxlbmRzIEJhckNoYXJ0U2VyaWVzLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQmFyIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgQmFyQ2hhcnRTZXJpZXNcbiAgICAgKiBAZXh0ZW5kcyBTZXJpZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubW9kZWwgc2VyaWVzIG1vZGVsXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgc2VyaWVzIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgc2VyaWVzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIFNlcmllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kIG9mIGJhciBjaGFydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgdG9wIHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0TGVmdCBzdGFydCBsZWZ0IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZExlZnQgZW5kIGxlZnQgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgc3RhcnQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBlbmQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn1cbiAgICAgKiB9fSBjb2x1bW4gY2hhcnQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQm91bmQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHRvcCwgc3RhcnRMZWZ0LCBlbmRMZWZ0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHN0YXJ0TGVmdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGVuZExlZnQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhZGRpdGlvbmFsIGxlZnQgZm9yIGRpdmlkZWQgb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQWRkaXRpb25hbExlZnQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBhZGRpdGlvbmFsTGVmdCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXZpZGVkICYmIHZhbHVlID4gMCkge1xuICAgICAgICAgICAgYWRkaXRpb25hbExlZnQgPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbigneUF4aXMnKS53aWR0aCArIGNoYXJ0Q29uc3QuT1ZFUkxBUFBJTkdfV0lEVEg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWRkaXRpb25hbExlZnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYmFyIGNoYXJ0IGJvdW5kLlxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgYmFzZVNpemU6IG51bWJlcixcbiAgICAgKiAgICAgIGJhc2VQb3NpdGlvbjogbnVtYmVyLFxuICAgICAqICAgICAgc3RlcDogbnVtYmVyLFxuICAgICAqICAgICAgYWRkaXRpb25hbFBvc2l0aW9uOiA/bnVtYmVyLFxuICAgICAqICAgICAgYmFyU2l6ZTogbnVtYmVyXG4gICAgICogfX0gYmFzZURhdGEgYmFzZSBkYXRhIGZvciBtYWtpbmcgYm91bmRcbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGJhc2VUb3A6IG51bWJlcixcbiAgICAgKiAgICAgIHRvcDogbnVtYmVyLFxuICAgICAqICAgICAgcGx1c0xlZnQ6IG51bWJlcixcbiAgICAgKiAgICAgIG1pbnVzTGVmdDogbnVtYmVyLFxuICAgICAqICAgICAgcHJldlN0YWNrOiA/c3RyaW5nXG4gICAgICogfX0gaXRlcmF0aW9uRGF0YSBpdGVyYXRpb24gZGF0YVxuICAgICAqIEBwYXJhbSB7P2Jvb2xlYW59IGlzU3RhY2tlZCB3aGV0aGVyIHN0YWNrZWQgb3B0aW9uIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge1Nlcmllc0l0ZW19IHNlcmllc0l0ZW0gc2VyaWVzIGl0ZW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgc3RhcnQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBlbmQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn1cbiAgICAgKiB9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXJDaGFydEJvdW5kOiBmdW5jdGlvbihiYXNlRGF0YSwgaXRlcmF0aW9uRGF0YSwgaXNTdGFja2VkLCBzZXJpZXNJdGVtLCBpbmRleCkge1xuICAgICAgICB2YXIgYmFyV2lkdGggPSBiYXNlRGF0YS5iYXNlQmFyU2l6ZSAqIHNlcmllc0l0ZW0ucmF0aW9EaXN0YW5jZSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxMZWZ0ID0gdGhpcy5fY2FsY3VsYXRlQWRkaXRpb25hbExlZnQoc2VyaWVzSXRlbS52YWx1ZSksXG4gICAgICAgICAgICBiYXJTdGFydExlZnQgPSBiYXNlRGF0YS5iYXNlQmFyU2l6ZSAqIHNlcmllc0l0ZW0uc3RhcnRSYXRpbyxcbiAgICAgICAgICAgIHN0YXJ0TGVmdCA9IGJhc2VEYXRhLmJhc2VQb3NpdGlvbiArIGJhclN0YXJ0TGVmdCArIGFkZGl0aW9uYWxMZWZ0ICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICBjaGFuZ2VkU3RhY2sgPSAoc2VyaWVzSXRlbS5zdGFjayAhPT0gaXRlcmF0aW9uRGF0YS5wcmV2U3RhY2spLFxuICAgICAgICAgICAgc3RlcENvdW50LCBlbmRMZWZ0LCBib3VuZDtcblxuICAgICAgICBpZiAoIWlzU3RhY2tlZCB8fCAoIXRoaXMub3B0aW9ucy5kaXZlcmdpbmcgJiYgY2hhbmdlZFN0YWNrKSkge1xuICAgICAgICAgICAgc3RlcENvdW50ID0gaXNTdGFja2VkID8gdGhpcy5kYXRhUHJvY2Vzc29yLmZpbmRTdGFja0luZGV4KHNlcmllc0l0ZW0uc3RhY2spIDogaW5kZXg7XG4gICAgICAgICAgICBpdGVyYXRpb25EYXRhLnRvcCA9IChiYXNlRGF0YS5zdGVwICogc3RlcENvdW50KSArIGl0ZXJhdGlvbkRhdGEuYmFzZVRvcCArIGJhc2VEYXRhLmFkZGl0aW9uYWxQb3NpdGlvbjtcbiAgICAgICAgICAgIGl0ZXJhdGlvbkRhdGEucGx1c0xlZnQgPSAwO1xuICAgICAgICAgICAgaXRlcmF0aW9uRGF0YS5taW51c0xlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcmllc0l0ZW0udmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgZW5kTGVmdCA9IHN0YXJ0TGVmdCArIGl0ZXJhdGlvbkRhdGEucGx1c0xlZnQ7XG4gICAgICAgICAgICBpdGVyYXRpb25EYXRhLnBsdXNMZWZ0ICs9IGJhcldpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0aW9uRGF0YS5taW51c0xlZnQgLT0gYmFyV2lkdGg7XG4gICAgICAgICAgICBlbmRMZWZ0ID0gc3RhcnRMZWZ0ICsgaXRlcmF0aW9uRGF0YS5taW51c0xlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRpb25EYXRhLnByZXZTdGFjayA9IHNlcmllc0l0ZW0uc3RhY2s7XG5cbiAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlQm91bmQoYmFyV2lkdGgsIGJhc2VEYXRhLmJhclNpemUsIGl0ZXJhdGlvbkRhdGEudG9wLCBzdGFydExlZnQsIGVuZExlZnQpO1xuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZHMgb2YgYmFyIGNoYXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBib3VuZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFNlcmllc0RhdGFNb2RlbCh0aGlzLmNoYXJ0VHlwZSksXG4gICAgICAgICAgICBpc1N0YWNrZWQgPSBwcmVkaWNhdGUuaXNWYWxpZFN0YWNrZWRPcHRpb24odGhpcy5vcHRpb25zLnN0YWNrZWQpLFxuICAgICAgICAgICAgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpLFxuICAgICAgICAgICAgYmFzZURhdGEgPSB0aGlzLl9tYWtlQmFzZURhdGFGb3JNYWtpbmdCb3VuZChkaW1lbnNpb24uaGVpZ2h0LCBkaW1lbnNpb24ud2lkdGgpO1xuXG4gICAgICAgIHJldHVybiBzZXJpZXNEYXRhTW9kZWwubWFwKGZ1bmN0aW9uKHNlcmllc0dyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYmFzZVRvcCA9IChncm91cEluZGV4ICogYmFzZURhdGEuZ3JvdXBTaXplKSArIGJhc2VEYXRhLmZpcnN0QWRkaXRpb25hbFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgICAgIGl0ZXJhdGlvbkRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VUb3A6IGJhc2VUb3AsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogYmFzZVRvcCxcbiAgICAgICAgICAgICAgICAgICAgcGx1c0xlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIG1pbnVzTGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlN0YWNrOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpdGVyYXRlZSA9IHR1aS51dGlsLmJpbmQoc2VsZi5fbWFrZUJhckNoYXJ0Qm91bmQsIHNlbGYsIGJhc2VEYXRhLCBpdGVyYXRpb25EYXRhLCBpc1N0YWNrZWQpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAubWFwKGl0ZXJhdGVlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VyaWVzIHJlbmRlcmluZyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOm51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCAtIGJvdW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IC0gbGFiZWwgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgLSBsYWJlbFxuICAgICAqIEBwYXJhbSB7P2Jvb2xlYW59IGlzU3RhcnQgLSB3aGV0aGVyIHN0YXJ0IG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IC0gcmVuZGVyaW5nIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc1JlbmRlcmluZ1Bvc2l0aW9uOiBmdW5jdGlvbihib3VuZCwgbGFiZWxIZWlnaHQsIHZhbHVlLCBsYWJlbCwgaXNTdGFydCkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSxcbiAgICAgICAgICAgIGxlZnQgPSBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgdG9wID0gYm91bmQudG9wICsgKGJvdW5kLmhlaWdodCAtIGxhYmVsSGVpZ2h0ICsgY2hhcnRDb25zdC5URVhUX1BBRERJTkcpIC8gMjtcblxuICAgICAgICBpZiAoKHZhbHVlID49IDAgJiYgIWlzU3RhcnQpIHx8ICh2YWx1ZSA8IDAgJiYgaXNTdGFydCkpIHtcbiAgICAgICAgICAgIGxlZnQgKz0gYm91bmQud2lkdGggKyBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCAtPSBsYWJlbFdpZHRoICsgY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgdG9wOiB0b3BcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRvcCBwb3NpdGlvbiBvZiBzdW0gbGFiZWwuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRvcCBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVRvcFBvc2l0aW9uT2ZTdW1MYWJlbDogZnVuY3Rpb24oYm91bmQsIGxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBib3VuZC50b3AgKyAoKGJvdW5kLmhlaWdodCAtIGxhYmVsSGVpZ2h0ICsgY2hhcnRDb25zdC5URVhUX1BBRERJTkcpIC8gMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaHRtbCBvZiBwbHVzIHN1bSBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgdmFsdWVzXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBsdXMgc3VtIGxhYmVsIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUGx1c1N1bUxhYmVsSHRtbDogZnVuY3Rpb24odmFsdWVzLCBib3VuZCwgbGFiZWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIHN1bSwgZm9ybWF0dGVkU3VtLFxuICAgICAgICAgICAgaHRtbCA9ICcnO1xuXG4gICAgICAgIGlmIChib3VuZCkge1xuICAgICAgICAgICAgc3VtID0gY2FsY3VsYXRvci5zdW1QbHVzVmFsdWVzKHZhbHVlcyk7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdW0gPSByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKHN1bSwgdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpLCAnc2VyaWVzJyk7XG4gICAgICAgICAgICBodG1sID0gdGhpcy5fbWFrZVNlcmllc0xhYmVsSHRtbCh7XG4gICAgICAgICAgICAgICAgbGVmdDogYm91bmQubGVmdCArIGJvdW5kLndpZHRoICsgY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORyxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuX2NhbGN1bGF0ZVRvcFBvc2l0aW9uT2ZTdW1MYWJlbChib3VuZCwgbGFiZWxIZWlnaHQpXG4gICAgICAgICAgICB9LCBmb3JtYXR0ZWRTdW0sIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG1pbnVzIHN1bSBsYWJlbCBodG1sLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlcyB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYm91bmQgYm91bmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGx1cyBtaW51cyBsYWJlbCBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU1pbnVzU3VtTGFiZWxIdG1sOiBmdW5jdGlvbih2YWx1ZXMsIGJvdW5kLCBsYWJlbEhlaWdodCkge1xuICAgICAgICB2YXIgc3VtLCBmb3JtYXR0ZWRTdW0sIGxhYmVsV2lkdGgsXG4gICAgICAgICAgICBodG1sID0gJyc7XG5cbiAgICAgICAgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgICBzdW0gPSBjYWxjdWxhdG9yLnN1bU1pbnVzVmFsdWVzKHZhbHVlcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gTWF0aC5hYnMoc3VtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0dGVkU3VtID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZShzdW0sIHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGb3JtYXRGdW5jdGlvbnMoKSwgJ3NlcmllcycpO1xuICAgICAgICAgICAgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGZvcm1hdHRlZFN1bSwgdGhpcy50aGVtZS5sYWJlbCk7XG4gICAgICAgICAgICBodG1sID0gdGhpcy5fbWFrZVNlcmllc0xhYmVsSHRtbCh7XG4gICAgICAgICAgICAgICAgbGVmdDogYm91bmQubGVmdCAtIGxhYmVsV2lkdGggLSBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HLFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5fY2FsY3VsYXRlVG9wUG9zaXRpb25PZlN1bUxhYmVsKGJvdW5kLCBsYWJlbEhlaWdodClcbiAgICAgICAgICAgIH0sIGZvcm1hdHRlZFN1bSwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxufSk7XG5cbkJhclR5cGVTZXJpZXNCYXNlLm1peGluKEJhckNoYXJ0U2VyaWVzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXJDaGFydFNlcmllcztcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb2x1bW4gY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgQmFyVHlwZVNlcmllc0Jhc2UgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIEJhclR5cGVTZXJpZXNCYXNlLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBhZGQgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncm91cEJvdW5kcyA9IHRoaXMuX21ha2VCb3VuZHModGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JvdXBCb3VuZHM6IHRoaXMuZ3JvdXBCb3VuZHMsXG4gICAgICAgICAgICBzZXJpZXNEYXRhTW9kZWw6IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRTZXJpZXNEYXRhTW9kZWwodGhpcy5jaGFydFR5cGUpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYmFyIGd1dHRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBTaXplIGJhciBncm91cCBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGl0ZW1Db3VudCBncm91cCBpdGVtIGNvdW50XG4gICAgICogQHJldHVybnMge251bWJlcn0gYmFyIGd1dHRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXJHdXR0ZXI6IGZ1bmN0aW9uKGdyb3VwU2l6ZSwgaXRlbUNvdW50KSB7XG4gICAgICAgIHZhciBiYXNlU2l6ZSA9IGdyb3VwU2l6ZSAvIChpdGVtQ291bnQgKyAxKSAvIDIsXG4gICAgICAgICAgICBzdGFuZGFyZFNpemUgPSA2LFxuICAgICAgICAgICAgZ3V0dGVyO1xuXG4gICAgICAgIGlmIChiYXNlU2l6ZSA8PSAyKSB7XG4gICAgICAgICAgICBndXR0ZXIgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGJhc2VTaXplIDw9IHN0YW5kYXJkU2l6ZSkge1xuICAgICAgICAgICAgZ3V0dGVyID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGd1dHRlciA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGd1dHRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBiYXIgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBTaXplIGJhciBncm91cCBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhckd1dHRlciBiYXIgcGFkZGluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgZ3JvdXAgaXRlbSBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGJhciBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhclNpemU6IGZ1bmN0aW9uKGdyb3VwU2l6ZSwgYmFyR3V0dGVyLCBpdGVtQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIChncm91cFNpemUgLSAoYmFyR3V0dGVyICogKGl0ZW1Db3VudCAtIDEpKSkgLyAoaXRlbUNvdW50ICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugb3B0aW9uIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhclNpemUgYmFyIHNpemVcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IG9wdGlvbkJhcldpZHRoIGJhcldpZHRoIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG9wdGlvbiBzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU9wdGlvblNpemU6IGZ1bmN0aW9uKGJhclNpemUsIG9wdGlvbkJhcldpZHRoKSB7XG4gICAgICAgIHZhciBvcHRpb25zU2l6ZSA9IDA7XG4gICAgICAgIGlmIChvcHRpb25CYXJXaWR0aCkge1xuICAgICAgICAgICAgb3B0aW9uc1NpemUgPSBNYXRoLm1pbihiYXJTaXplLCBvcHRpb25CYXJXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnNTaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9wdGlvblNpemUgYW5kIGJhclNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhclNpemUgYmFyIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9uU2l6ZSBvcHRpb24gc2l6ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgaXRlbSBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGFkZGl0aW9uIHBhZGRpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVBZGRpdGlvbmFsUG9zaXRpb246IGZ1bmN0aW9uKGJhclNpemUsIG9wdGlvblNpemUsIGl0ZW1Db3VudCkge1xuICAgICAgICB2YXIgYWRkaXRpb25hbFBvc2l0aW9uID0gMDtcblxuICAgICAgICBpZiAob3B0aW9uU2l6ZSAmJiBvcHRpb25TaXplIDwgYmFyU2l6ZSkge1xuICAgICAgICAgICAgYWRkaXRpb25hbFBvc2l0aW9uID0gKGJhclNpemUgLyAyKSArICgoYmFyU2l6ZSAtIG9wdGlvblNpemUpICogaXRlbUNvdW50IC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWRkaXRpb25hbFBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJhc2UgZGF0YSBmb3IgbWFraW5nIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlR3JvdXBTaXplIGJhc2UgZ3JvdXAgc2l6ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlQmFyU2l6ZSBiYXNlIGJhciBzaXplXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGJhc2VCYXJTaXplOiBudW1iZXIsXG4gICAgICogICAgICBncm91cFNpemU6IG51bWJlcixcbiAgICAgKiAgICAgIGJhclNpemU6IG51bWJlcixcbiAgICAgKiAgICAgIHN0ZXA6IG51bWJlcixcbiAgICAgKiAgICAgIGZpcnN0QWRkaXRpb25hbFBvc2l0aW9uOiBudW1iZXIsXG4gICAgICogICAgICBhZGRpdGlvbmFsUG9zaXRpb246IG51bWJlcixcbiAgICAgKiAgICAgIGJhc2VQb3NpdGlvbjogbnVtYmVyXG4gICAgICogfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQmFzZURhdGFGb3JNYWtpbmdCb3VuZDogZnVuY3Rpb24oYmFzZUdyb3VwU2l6ZSwgYmFzZUJhclNpemUpIHtcbiAgICAgICAgdmFyIGlzU3RhY2tlZCA9IHByZWRpY2F0ZS5pc1ZhbGlkU3RhY2tlZE9wdGlvbih0aGlzLm9wdGlvbnMuc3RhY2tlZCksXG4gICAgICAgICAgICBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzRGF0YU1vZGVsKHRoaXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIGdyb3VwU2l6ZSA9IGJhc2VHcm91cFNpemUgLyBzZXJpZXNEYXRhTW9kZWwuZ2V0R3JvdXBDb3VudCgpLFxuICAgICAgICAgICAgZmlyc3RBZGRpdGlvbmFsUG9zaXRpb24gPSAwLFxuICAgICAgICAgICAgaXRlbUNvdW50LCBiYXJHdXR0ZXIsIGJhclNpemUsIG9wdGlvblNpemUsIGFkZGl0aW9uYWxQb3NpdGlvbiwgYmFzZVBvc2l0aW9uO1xuXG4gICAgICAgIGlmICghaXNTdGFja2VkKSB7XG4gICAgICAgICAgICBpdGVtQ291bnQgPSBzZXJpZXNEYXRhTW9kZWwuZ2V0Rmlyc3RTZXJpZXNHcm91cCgpLmdldFNlcmllc0l0ZW1Db3VudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbUNvdW50ID0gdGhpcy5vcHRpb25zLmRpdmVyZ2luZyA/IDEgOiB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U3RhY2tDb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFyR3V0dGVyID0gdGhpcy5fbWFrZUJhckd1dHRlcihncm91cFNpemUsIGl0ZW1Db3VudCk7XG4gICAgICAgIGJhclNpemUgPSB0aGlzLl9tYWtlQmFyU2l6ZShncm91cFNpemUsIGJhckd1dHRlciwgaXRlbUNvdW50KTtcbiAgICAgICAgb3B0aW9uU2l6ZSA9IHRoaXMuX21ha2VPcHRpb25TaXplKGJhclNpemUsIHRoaXMub3B0aW9ucy5iYXJXaWR0aCk7XG4gICAgICAgIGFkZGl0aW9uYWxQb3NpdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZUFkZGl0aW9uYWxQb3NpdGlvbihiYXJTaXplLCBvcHRpb25TaXplLCBpdGVtQ291bnQpO1xuICAgICAgICBiYXJTaXplID0gb3B0aW9uU2l6ZSB8fCBiYXJTaXplO1xuICAgICAgICBiYXNlUG9zaXRpb24gPSB0aGlzLl9nZXRMaW1pdERpc3RhbmNlRnJvbVplcm9Qb2ludChiYXNlQmFyU2l6ZSwgdGhpcy5kYXRhLmxpbWl0KS50b01pbjtcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzQ29sdW1uQ2hhcnQodGhpcy5jaGFydFR5cGUpKSB7XG4gICAgICAgICAgICBiYXNlUG9zaXRpb24gPSBiYXNlQmFyU2l6ZSAtIGJhc2VQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmJhcldpZHRoIHx8IGJhclNpemUgPCB0aGlzLm9wdGlvbnMuYmFyV2lkdGgpIHtcbiAgICAgICAgICAgIGZpcnN0QWRkaXRpb25hbFBvc2l0aW9uID0gKGJhclNpemUgLyAyKSArIGFkZGl0aW9uYWxQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXNlQmFyU2l6ZTogYmFzZUJhclNpemUsXG4gICAgICAgICAgICBncm91cFNpemU6IGdyb3VwU2l6ZSxcbiAgICAgICAgICAgIGJhclNpemU6IGJhclNpemUsXG4gICAgICAgICAgICBzdGVwOiBiYXJHdXR0ZXIgKyBiYXJTaXplLFxuICAgICAgICAgICAgZmlyc3RBZGRpdGlvbmFsUG9zaXRpb246IGZpcnN0QWRkaXRpb25hbFBvc2l0aW9uLFxuICAgICAgICAgICAgYWRkaXRpb25hbFBvc2l0aW9uOiBhZGRpdGlvbmFsUG9zaXRpb24sXG4gICAgICAgICAgICBiYXNlUG9zaXRpb246IGJhc2VQb3NpdGlvblxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGh0bWwgZm9yIHNlcmllcyBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJbmRleCBpbmRleCBvZiBzZXJpZXMgZ3JvdXBzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqIEBwYXJhbSB7U2VyaWVzSXRlbX0gc2VyaWVzSXRlbSBzZXJpZXMgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleCBvZiBzZXJpZXMgZ3JvdXBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNMYWJlbHNIdG1sOiBmdW5jdGlvbihncm91cEluZGV4LCBsYWJlbEhlaWdodCwgc2VyaWVzSXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gdGhpcy5zZXJpZXNEYXRhLmdyb3VwQm91bmRzW2dyb3VwSW5kZXhdW2luZGV4XS5lbmQsXG4gICAgICAgICAgICB2YWx1ZSA9IHNlcmllc0l0ZW0udmFsdWUsXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX21ha2VTZXJpZXNSZW5kZXJpbmdQb3NpdGlvbihib3VuZCwgbGFiZWxIZWlnaHQsIHZhbHVlLCBzZXJpZXNJdGVtLmxhYmVsKSxcbiAgICAgICAgICAgIGxhYmVsSHRtbCA9IHRoaXMuX21ha2VTZXJpZXNMYWJlbEh0bWwocG9zaXRpb24sIHNlcmllc0l0ZW0uZW5kTGFiZWwsIGluZGV4KTtcblxuICAgICAgICBpZiAoc2VyaWVzSXRlbS5pc1JhbmdlKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX21ha2VTZXJpZXNSZW5kZXJpbmdQb3NpdGlvbihib3VuZCwgbGFiZWxIZWlnaHQsIHZhbHVlLCBzZXJpZXNJdGVtLnN0YXJ0TGFiZWwsIHRydWUpO1xuICAgICAgICAgICAgbGFiZWxIdG1sICs9IHRoaXMuX21ha2VTZXJpZXNMYWJlbEh0bWwocG9zaXRpb24sIHNlcmllc0l0ZW0uc3RhcnRMYWJlbCwgaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsSHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG5vcm1hbCBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxTZXJpZXNMYWJlbEFyZWEgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlck5vcm1hbFNlcmllc0xhYmVsOiBmdW5jdGlvbihlbFNlcmllc0xhYmVsQXJlYSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzRGF0YU1vZGVsKHRoaXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIGZpcnN0TGFiZWwgPSBzZXJpZXNEYXRhTW9kZWwuZ2V0Rmlyc3RJdGVtTGFiZWwoKSxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGZpcnN0TGFiZWwsIHRoaXMudGhlbWUubGFiZWwpLFxuICAgICAgICAgICAgaHRtbDtcblxuICAgICAgICBodG1sID0gc2VyaWVzRGF0YU1vZGVsLm1hcChmdW5jdGlvbihzZXJpZXNHcm91cCwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIG1ha2VTZXJpZXNMYWJlbHNIdG1sID0gdHVpLnV0aWwuYmluZChzZWxmLl9tYWtlU2VyaWVzTGFiZWxzSHRtbCwgc2VsZiwgZ3JvdXBJbmRleCwgbGFiZWxIZWlnaHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAubWFwKG1ha2VTZXJpZXNMYWJlbHNIdG1sKS5qb2luKCcnKTtcbiAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgZWxTZXJpZXNMYWJlbEFyZWEuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdW0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlcyB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzdW0gcmVzdWx0LlxuICAgICAqL1xuICAgIF9tYWtlU3VtVmFsdWVzOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgdmFyIHN1bSA9IHR1aS51dGlsLnN1bSh2YWx1ZXMpO1xuXG4gICAgICAgIHJldHVybiByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKHN1bSwgdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpLCAnc2VpcmVzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3RhY2tlZCBsYWJlbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgbGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGJvdW5kIGVsZW1lbnQgYm91bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgbGFiZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3RhY2tlZExhYmVsUG9zaXRpb246IGZ1bmN0aW9uKGJvdW5kLCBsYWJlbCwgbGFiZWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChsYWJlbCwgdGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBsZWZ0ID0gYm91bmQubGVmdCArICgoYm91bmQud2lkdGggLSBsYWJlbFdpZHRoICsgY2hhcnRDb25zdC5URVhUX1BBRERJTkcpIC8gMiksXG4gICAgICAgICAgICB0b3AgPSBib3VuZC50b3AgKyAoKGJvdW5kLmhlaWdodCAtIGxhYmVsSGVpZ2h0ICsgY2hhcnRDb25zdC5URVhUX1BBRERJTkcpIC8gMik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN0YWNrZWQgbGFiZWxzIGh0bWwuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmdyb3VwSW5kZXggZ3JvdXAgaW5kZXhcbiAgICAgKiAgICAgIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHBhcmFtcy5ib3VuZHMgYm91bmRzLFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBsYWJlbHMgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTdGFja2VkTGFiZWxzSHRtbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNlcmllc0dyb3VwID0gcGFyYW1zLnNlcmllc0dyb3VwLFxuICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSBwYXJhbXMubGFiZWxIZWlnaHQsXG4gICAgICAgICAgICBodG1scywgcGx1c0JvdW5kLCBtaW51c0JvdW5kLCB2YWx1ZXM7XG5cbiAgICAgICAgaHRtbHMgPSBzZXJpZXNHcm91cC5tYXAoZnVuY3Rpb24oc2VyaWVzSXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBib3VuZCA9IHBhcmFtcy5ib3VuZHNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIGxhYmVsSHRtbCA9ICcnLFxuICAgICAgICAgICAgICAgIGJvdW5kRW5kLCBwb3NpdGlvbjtcblxuICAgICAgICAgICAgaWYgKGJvdW5kICYmIHNlcmllc0l0ZW0pIHtcbiAgICAgICAgICAgICAgICBib3VuZEVuZCA9IGJvdW5kLmVuZDtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHNlbGYuX21ha2VTdGFja2VkTGFiZWxQb3NpdGlvbihib3VuZEVuZCwgc2VyaWVzSXRlbS5sYWJlbCwgcGFyYW1zLmxhYmVsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBsYWJlbEh0bWwgPSBzZWxmLl9tYWtlU2VyaWVzTGFiZWxIdG1sKHBvc2l0aW9uLCBzZXJpZXNJdGVtLmxhYmVsLCBpbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXNJdGVtLnZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgIHBsdXNCb3VuZCA9IGJvdW5kRW5kO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJpZXNJdGVtLnZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgIG1pbnVzQm91bmQgPSBib3VuZEVuZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsSHRtbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFja2VkID09PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgdmFsdWVzID0gc2VyaWVzR3JvdXAucGx1Y2soJ3ZhbHVlJyk7XG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMuX21ha2VQbHVzU3VtTGFiZWxIdG1sKHZhbHVlcywgcGx1c0JvdW5kLCBsYWJlbEhlaWdodCkpO1xuICAgICAgICAgICAgaHRtbHMucHVzaCh0aGlzLl9tYWtlTWludXNTdW1MYWJlbEh0bWwodmFsdWVzLCBtaW51c0JvdW5kLCBsYWJlbEhlaWdodCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc3RhY2tlZCBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxTZXJpZXNMYWJlbEFyZWEgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclN0YWNrZWRTZXJpZXNMYWJlbDogZnVuY3Rpb24oZWxTZXJpZXNMYWJlbEFyZWEpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgZ3JvdXBCb3VuZHMgPSB0aGlzLnNlcmllc0RhdGEuZ3JvdXBCb3VuZHMsXG4gICAgICAgICAgICBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzRGF0YU1vZGVsKHRoaXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIGZpcnN0TGFiZWwgPSBzZXJpZXNEYXRhTW9kZWwuZ2V0Rmlyc3RJdGVtTGFiZWwodGhpcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQoZmlyc3RMYWJlbCwgdGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBodG1sO1xuXG4gICAgICAgIGh0bWwgPSBzZXJpZXNEYXRhTW9kZWwubWFwKGZ1bmN0aW9uKHNlcmllc0dyb3VwLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsc0h0bWwgPSBzZWxmLl9tYWtlU3RhY2tlZExhYmVsc0h0bWwoe1xuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIHNlcmllc0dyb3VwOiBzZXJpZXNHcm91cCxcbiAgICAgICAgICAgICAgICBib3VuZHM6IGdyb3VwQm91bmRzW2luZGV4XSxcbiAgICAgICAgICAgICAgICBsYWJlbEhlaWdodDogbGFiZWxIZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsc0h0bWw7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuXG4gICAgICAgIGVsU2VyaWVzTGFiZWxBcmVhLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxTZXJpZXNMYWJlbEFyZWEgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0xhYmVsOiBmdW5jdGlvbihlbFNlcmllc0xhYmVsQXJlYSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YWNrZWRTZXJpZXNMYWJlbChlbFNlcmllc0xhYmVsQXJlYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJOb3JtYWxTZXJpZXNMYWJlbChlbFNlcmllc0xhYmVsQXJlYSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuQmFyVHlwZVNlcmllc0Jhc2UubWl4aW4gPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdHVpLnV0aWwuZXh0ZW5kKGZ1bmMucHJvdG90eXBlLCBCYXJUeXBlU2VyaWVzQmFzZS5wcm90b3R5cGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXJUeXBlU2VyaWVzQmFzZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBCdWJibGUgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgQnViYmxlQ2hhcnRTZXJpZXMgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhTZXJpZXMsIC8qKiBAbGVuZHMgQnViYmxlQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBCdWJibGUgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBCdWJibGVDaGFydFNlcmllc1xuICAgICAqIEBleHRlbmRzIFNlcmllc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBTZXJpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHN0ZXAgdmFsdWUgZm9yIGxhYmVsIGF4aXMuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVTdGVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSAwO1xuICAgICAgICB2YXIgZGltZW5zaW9uLCBzZXJpZXNEYXRhTW9kZWwsIHNpemUsIGxlbjtcblxuICAgICAgICBpZiAodGhpcy5kYXRhUHJvY2Vzc29yLmhhc0NhdGVnb3JpZXMoKSkge1xuICAgICAgICAgICAgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuICAgICAgICAgICAgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFNlcmllc0RhdGFNb2RlbCh0aGlzLmNoYXJ0VHlwZSk7XG4gICAgICAgICAgICBsZW4gPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Q2F0ZWdvcmllcygpLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHNlcmllc0RhdGFNb2RlbC5pc1hDb3VudEdyZWF0ZXJUaGFuWUNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gZGltZW5zaW9uLmhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGRpbWVuc2lvbi53aWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RlcCA9IHNpemUgLyBsZW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZCBmb3IgYnViYmxlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyLCByOiBudW1iZXJ9fSByYXRpb01hcCAtIHJhdGlvIG1hcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbkJ5U3RlcCAtIHBvc2l0aW9uIHZhbHVlIGJ5IHN0ZXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4UmFkaXVzIC0gbWF4IHJhZGl1c1xuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmFpdXM6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJvdW5kOiBmdW5jdGlvbihyYXRpb01hcCwgcG9zaXRpb25CeVN0ZXAsIG1heFJhZGl1cykge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuICAgICAgICB2YXIgbGVmdCA9IHR1aS51dGlsLmlzRXhpc3R5KHJhdGlvTWFwLngpID8gKHJhdGlvTWFwLnggKiBkaW1lbnNpb24ud2lkdGgpIDogcG9zaXRpb25CeVN0ZXA7XG4gICAgICAgIHZhciB0b3AgPSB0dWkudXRpbC5pc0V4aXN0eShyYXRpb01hcC55KSA/IChyYXRpb01hcC55ICogZGltZW5zaW9uLmhlaWdodCkgOiBwb3NpdGlvbkJ5U3RlcDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHRvcDogZGltZW5zaW9uLmhlaWdodCAtIHRvcCxcbiAgICAgICAgICAgIHJhZGl1czogTWF0aC5tYXgobWF4UmFkaXVzICogcmF0aW9NYXAuciwgMilcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZHMgZm9yIGJ1YmJsZSBjaGFydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmFkaXVzOiBudW1iZXJ9Pj59IHBvc2l0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzRGF0YU1vZGVsKHRoaXMuY2hhcnRUeXBlKTtcbiAgICAgICAgdmFyIG1heFJhZGl1cyA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0TWluaW11bVBpeGVsU3RlcEZvckF4aXMoKTtcbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9jYWxjdWxhdGVTdGVwKCk7XG4gICAgICAgIHZhciBzdGFydCA9IHN0ZXAgPyBzdGVwIC8gMiA6IDA7XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc0RhdGFNb2RlbC5tYXAoZnVuY3Rpb24oc2VyaWVzR3JvdXAsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25CeVN0ZXAgPSBzdGFydCArIChzdGVwICogaW5kZXgpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAubWFwKGZ1bmN0aW9uKHNlcmllc0l0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzUmF0aW9uTWFwID0gKHNlcmllc0l0ZW0gJiYgc2VyaWVzSXRlbS5yYXRpb01hcCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzUmF0aW9uTWFwID8gc2VsZi5fbWFrZUJvdW5kKHNlcmllc0l0ZW0ucmF0aW9NYXAsIHBvc2l0aW9uQnlTdGVwLCBtYXhSYWRpdXMpIDogbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgZ3JvdXBCb3VuZHM6IEFycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHJhZGl1czogbnVtYmVyfT4+LFxuICAgICAqICAgICAgc2VyaWVzRGF0YU1vZGVsOiBTZXJpZXNEYXRhTW9kZWxcbiAgICAgKiB9fSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwQm91bmRzOiB0aGlzLl9tYWtlQm91bmRzKCksXG4gICAgICAgICAgICBzZXJpZXNEYXRhTW9kZWw6IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRTZXJpZXNEYXRhTW9kZWwodGhpcy5jaGFydFR5cGUpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VyaWVzIHJlbmRlcmluZyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOm51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCAtIGJvdW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IC0gbGFiZWwgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgLSBsYWJlbFxuICAgICAqIEBwYXJhbSB7P2Jvb2xlYW59IGlzU3RhcnQgLSB3aGV0aGVyIHN0YXJ0IG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IC0gcmVuZGVyaW5nIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc1JlbmRlcmluZ1Bvc2l0aW9uOiBmdW5jdGlvbihib3VuZCwgbGFiZWxIZWlnaHQsIHZhbHVlLCBsYWJlbCwgaXNTdGFydCkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSxcbiAgICAgICAgICAgIGxlZnQgPSBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgdG9wID0gYm91bmQudG9wICsgKGJvdW5kLmhlaWdodCAtIGxhYmVsSGVpZ2h0ICsgY2hhcnRDb25zdC5URVhUX1BBRERJTkcpIC8gMjtcblxuICAgICAgICBpZiAoKHZhbHVlID49IDAgJiYgIWlzU3RhcnQpIHx8ICh2YWx1ZSA8IDAgJiYgaXNTdGFydCkpIHtcbiAgICAgICAgICAgIGxlZnQgKz0gYm91bmQud2lkdGggKyBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCAtPSBsYWJlbFdpZHRoICsgY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgdG9wOiB0b3BcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2hvd1Rvb2x0aXAgaXMgbW91c2VvdmVyIGV2ZW50IGNhbGxiYWNrIG9uIHNlcmllcyBncmFwaC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmFsbG93TmVnYXRpdmVUb29sdGlwIHdoZXRoZXIgYWxsb3cgbmVnYXRpdmUgdG9vbHRpcCBvciBub3RcbiAgICAgKiBAcGFyYW0ge3t0b3A6bnVtYmVyLCBsZWZ0OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgZ3JhcGggYm91bmQgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJbmRleCBncm91cCBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBtb3VzZVBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKHBhcmFtcywgYm91bmQsIGdyb3VwSW5kZXgsIGluZGV4LCBtb3VzZVBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd1Rvb2x0aXAnLCB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2VQb3NpdGlvbjogbW91c2VQb3NpdGlvblxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGlkZVRvb2x0aXAgaXMgbW91c2VvdXQgZXZlbnQgY2FsbGJhY2sgb24gc2VyaWVzIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCB0b29sdGlwIGlkXG4gICAgICovXG4gICAgaGlkZVRvb2x0aXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2hpZGVUb29sdGlwJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciByYXBoYWVsIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfcmVuZGVyR3JhcGg6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSkge1xuICAgICAgICB2YXIgc2hvd1Rvb2x0aXAgPSB0dWkudXRpbC5iaW5kKHRoaXMuc2hvd1Rvb2x0aXAsIHRoaXMsIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBzaG93VG9vbHRpcDogc2hvd1Rvb2x0aXAsXG4gICAgICAgICAgICBoaWRlVG9vbHRpcDogdHVpLnV0aWwuYmluZCh0aGlzLmhpZGVUb29sdGlwLCB0aGlzKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5fbWFrZVBhcmFtc0ZvckdyYXBoUmVuZGVyaW5nKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSk7XG5cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlbmRlcih0aGlzLnNlcmllc0NvbnRhaW5lciwgcGFyYW1zLCBjYWxsYmFja3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGh0bWwgZm9yIGxhYmVsIG9mIHNlcmllcyBhcmVhLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBiYXNlUG9zaXRpb24gLSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCAtIGxhYmVsIG9mIFNlcmllc0l0ZW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc0xhYmVsc0h0bWw6IGZ1bmN0aW9uKGJhc2VQb3NpdGlvbiwgbGFiZWwsIGluZGV4KSB7XG4gICAgICAgIHZhciBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChsYWJlbCwgdGhpcy50aGVtZS5sYWJlbCk7XG4gICAgICAgIHZhciBsYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGFiZWwsIHRoaXMudGhlbWUubGFiZWwpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICBsZWZ0OiBiYXNlUG9zaXRpb24ubGVmdCAtIChsYWJlbFdpZHRoIC8gMiksXG4gICAgICAgICAgICB0b3A6IGJhc2VQb3NpdGlvbi50b3AgLSAobGFiZWxIZWlnaHQgLyAyKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYWtlU2VyaWVzTGFiZWxIdG1sKHBvc2l0aW9uLCBsYWJlbCwgaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxhYmVsQ29udGFpbmVyIC0gY29udGFpbmVyIGZvciBsYWJlbCBhcmVhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU2VyaWVzTGFiZWw6IGZ1bmN0aW9uKGxhYmVsQ29udGFpbmVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlcmllc0RhdGFNb2RlbCA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRTZXJpZXNEYXRhTW9kZWwodGhpcy5jaGFydFR5cGUpO1xuICAgICAgICB2YXIgaHRtbCA9IHNlcmllc0RhdGFNb2RlbC5tYXAoZnVuY3Rpb24oc2VyaWVzR3JvdXAsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNHcm91cC5tYXAoZnVuY3Rpb24oc2VyaWVzSXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmQgPSBzZWxmLnNlcmllc0RhdGEuZ3JvdXBCb3VuZHNbZ3JvdXBJbmRleF1baW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllc0l0ZW0gPyBzZWxmLl9tYWtlU2VyaWVzTGFiZWxzSHRtbChib3VuZCwgc2VyaWVzSXRlbS5sYWJlbCwgaW5kZXgpIDogJyc7XG4gICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgbGFiZWxDb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2sgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIG9uQ2xpY2tTZXJpZXM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuX2V4ZWN1dGVHcmFwaFJlbmRlcmVyKHBvc2l0aW9uLCAnY2xpY2tTZXJpZXMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW92ZSBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICovXG4gICAgb25Nb3ZlU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9leGVjdXRlR3JhcGhSZW5kZXJlcihwb3NpdGlvbiwgJ21vdmVNb3VzZU9uU2VyaWVzJyk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihCdWJibGVDaGFydFNlcmllcyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnViYmxlQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29sdW1uIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuL3NlcmllcycpLFxuICAgIEJhclR5cGVTZXJpZXNCYXNlID0gcmVxdWlyZSgnLi9iYXJUeXBlU2VyaWVzQmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIGNhbGN1bGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGN1bGF0b3InKTtcblxudmFyIENvbHVtbkNoYXJ0U2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoU2VyaWVzLCAvKiogQGxlbmRzIENvbHVtbkNoYXJ0U2VyaWVzLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQ29sdW1uIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgQ29sdW1uQ2hhcnRTZXJpZXNcbiAgICAgKiBAZXh0ZW5kcyBTZXJpZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubW9kZWwgc2VyaWVzIG1vZGVsXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgc2VyaWVzIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgc2VyaWVzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIFNlcmllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kIG9mIGNvbHVtbiBjaGFydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IHRvcCBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFRvcCBzdGFydCB0b3AgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kVG9wIGVuZCB0b3AgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgc3RhcnQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBlbmQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn1cbiAgICAgKiB9fSBjb2x1bW4gY2hhcnQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQm91bmQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGxlZnQsIHN0YXJ0VG9wLCBlbmRUb3ApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgdG9wOiBzdGFydFRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICB0b3A6IGVuZFRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNvbHVtbiBjaGFydCBib3VuZC5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGJhc2VTaXplOiBudW1iZXIsXG4gICAgICogICAgICBiYXNlUG9zaXRpb246IG51bWJlcixcbiAgICAgKiAgICAgIHN0ZXA6IG51bWJlcixcbiAgICAgKiAgICAgIGFkZGl0aW9uYWxQb3NpdGlvbjogP251bWJlcixcbiAgICAgKiAgICAgIGJhclNpemU6IG51bWJlclxuICAgICAqIH19IGJhc2VEYXRhIGJhc2UgZGF0YSBmb3IgbWFraW5nIGJvdW5kXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBiYXNlTGVmdDogbnVtYmVyLFxuICAgICAqICAgICAgbGVmdDogbnVtYmVyLFxuICAgICAqICAgICAgcGx1c1RvcDogbnVtYmVyLFxuICAgICAqICAgICAgbWludXNUb3A6IG51bWJlcixcbiAgICAgKiAgICAgIHByZXZTdGFjazogP3N0cmluZ1xuICAgICAqIH19IGl0ZXJhdGlvbkRhdGEgaXRlcmF0aW9uIGRhdGFcbiAgICAgKiBAcGFyYW0gez9ib29sZWFufSBpc1N0YWNrZWQgd2hldGhlciBzdGFja2VkIG9wdGlvbiBvciBub3QuXG4gICAgICogQHBhcmFtIHtTZXJpZXNJdGVtfSBzZXJpZXNJdGVtIHNlcmllcyBpdGVtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIHN0YXJ0OiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgZW5kOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9XG4gICAgICogfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ29sdW1uQ2hhcnRCb3VuZDogZnVuY3Rpb24oYmFzZURhdGEsIGl0ZXJhdGlvbkRhdGEsIGlzU3RhY2tlZCwgc2VyaWVzSXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGJhckhlaWdodCA9IE1hdGguYWJzKGJhc2VEYXRhLmJhc2VCYXJTaXplICogc2VyaWVzSXRlbS5yYXRpb0Rpc3RhbmNlKSxcbiAgICAgICAgICAgIGJhclN0YXJ0VG9wID0gYmFzZURhdGEuYmFzZUJhclNpemUgKiBzZXJpZXNJdGVtLnN0YXJ0UmF0aW8sXG4gICAgICAgICAgICBzdGFydFRvcCA9IGJhc2VEYXRhLmJhc2VQb3NpdGlvbiAtIGJhclN0YXJ0VG9wICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICBjaGFuZ2VkU3RhY2sgPSAoc2VyaWVzSXRlbS5zdGFjayAhPT0gaXRlcmF0aW9uRGF0YS5wcmV2U3RhY2spLFxuICAgICAgICAgICAgc3RlcENvdW50LCBlbmRUb3AsIGJvdW5kO1xuXG4gICAgICAgIGlmICghaXNTdGFja2VkIHx8ICghdGhpcy5vcHRpb25zLmRpdmVyZ2luZyAmJiBjaGFuZ2VkU3RhY2spKSB7XG4gICAgICAgICAgICBzdGVwQ291bnQgPSBpc1N0YWNrZWQgPyB0aGlzLmRhdGFQcm9jZXNzb3IuZmluZFN0YWNrSW5kZXgoc2VyaWVzSXRlbS5zdGFjaykgOiBpbmRleDtcbiAgICAgICAgICAgIGl0ZXJhdGlvbkRhdGEubGVmdCA9IChiYXNlRGF0YS5zdGVwICogc3RlcENvdW50KSArIGl0ZXJhdGlvbkRhdGEuYmFzZUxlZnQgKyBiYXNlRGF0YS5hZGRpdGlvbmFsUG9zaXRpb247XG4gICAgICAgICAgICBpdGVyYXRpb25EYXRhLnBsdXNUb3AgPSAwO1xuICAgICAgICAgICAgaXRlcmF0aW9uRGF0YS5taW51c1RvcCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VyaWVzSXRlbS52YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICBpdGVyYXRpb25EYXRhLnBsdXNUb3AgLT0gYmFySGVpZ2h0O1xuICAgICAgICAgICAgZW5kVG9wID0gc3RhcnRUb3AgKyBpdGVyYXRpb25EYXRhLnBsdXNUb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmRUb3AgPSBzdGFydFRvcCArIGl0ZXJhdGlvbkRhdGEubWludXNUb3A7XG4gICAgICAgICAgICBpdGVyYXRpb25EYXRhLm1pbnVzVG9wICs9IGJhckhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXJhdGlvbkRhdGEucHJldlN0YWNrID0gc2VyaWVzSXRlbS5zdGFjaztcbiAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlQm91bmQoYmFzZURhdGEuYmFyU2l6ZSwgYmFySGVpZ2h0LCBpdGVyYXRpb25EYXRhLmxlZnQsIHN0YXJ0VG9wLCBlbmRUb3ApO1xuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZHMgb2YgY29sdW1uIGNoYXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBib3VuZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFNlcmllc0RhdGFNb2RlbCh0aGlzLmNoYXJ0VHlwZSksXG4gICAgICAgICAgICBpc1N0YWNrZWQgPSBwcmVkaWNhdGUuaXNWYWxpZFN0YWNrZWRPcHRpb24odGhpcy5vcHRpb25zLnN0YWNrZWQpLFxuICAgICAgICAgICAgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpLFxuICAgICAgICAgICAgYmFzZURhdGEgPSB0aGlzLl9tYWtlQmFzZURhdGFGb3JNYWtpbmdCb3VuZChkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiBzZXJpZXNEYXRhTW9kZWwubWFwKGZ1bmN0aW9uKHNlcmllc0dyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYmFzZUxlZnQgPSAoZ3JvdXBJbmRleCAqIGJhc2VEYXRhLmdyb3VwU2l6ZSkgKyBiYXNlRGF0YS5maXJzdEFkZGl0aW9uYWxQb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSxcbiAgICAgICAgICAgICAgICBpdGVyYXRpb25EYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBiYXNlTGVmdDogYmFzZUxlZnQsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGJhc2VMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBwbHVzVG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICBtaW51c1RvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlN0YWNrOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpdGVyYXRlZSA9IHR1aS51dGlsLmJpbmQoc2VsZi5fbWFrZUNvbHVtbkNoYXJ0Qm91bmQsIHNlbGYsIGJhc2VEYXRhLCBpdGVyYXRpb25EYXRhLCBpc1N0YWNrZWQpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAubWFwKGl0ZXJhdGVlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VyaWVzIHJlbmRlcmluZyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOm51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCAtIGJvdW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IC0gbGFiZWwgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgLSBsYWJlbCBvZiBzZXJpZXNJdGVtXG4gICAgICogQHBhcmFtIHs/Ym9vbGVhbn0gaXNTdGFydCAtIHdoZXRoZXIgc3RhcnQgb3Igbm90XG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcmVuZGVyaW5nIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc1JlbmRlcmluZ1Bvc2l0aW9uOiBmdW5jdGlvbihib3VuZCwgbGFiZWxIZWlnaHQsIHZhbHVlLCBsYWJlbCwgaXNTdGFydCkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSxcbiAgICAgICAgICAgIHRvcCA9IGJvdW5kLnRvcCxcbiAgICAgICAgICAgIGxlZnQgPSBib3VuZC5sZWZ0ICsgKGJvdW5kLndpZHRoIC0gbGFiZWxXaWR0aCkgLyAyO1xuXG4gICAgICAgIGlmICgodmFsdWUgPj0gMCAmJiAhaXNTdGFydCkgfHwgKHZhbHVlIDwgMCAmJiBpc1N0YXJ0KSkge1xuICAgICAgICAgICAgdG9wIC09IGxhYmVsSGVpZ2h0ICsgY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcCArPSBib3VuZC5oZWlnaHQgKyBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbGVmdCBwb3NpdGlvbiBvZiBzdW0gbGFiZWwuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdHRlZFN1bSBmb3JtYXR0ZWQgc3VtLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGxlZnQgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVMZWZ0UG9zaXRpb25PZlN1bUxhYmVsOiBmdW5jdGlvbihib3VuZCwgZm9ybWF0dGVkU3VtKSB7XG4gICAgICAgIHZhciBsYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgoZm9ybWF0dGVkU3VtLCB0aGlzLnRoZW1lLmxhYmVsKTtcbiAgICAgICAgcmV0dXJuIGJvdW5kLmxlZnQgKyAoKGJvdW5kLndpZHRoIC0gbGFiZWxXaWR0aCArIGNoYXJ0Q29uc3QuVEVYVF9QQURESU5HKSAvIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBsdXMgc3VtIGxhYmVsIGh0bWwuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVzIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBib3VuZCBib3VuZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwbHVzIHN1bSBsYWJlbCBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBsdXNTdW1MYWJlbEh0bWw6IGZ1bmN0aW9uKHZhbHVlcywgYm91bmQsIGxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIHZhciBzdW0sIGZvcm1hdHRlZFN1bSxcbiAgICAgICAgICAgIGh0bWwgPSAnJztcblxuICAgICAgICBpZiAoYm91bmQpIHtcbiAgICAgICAgICAgIHN1bSA9IGNhbGN1bGF0b3Iuc3VtUGx1c1ZhbHVlcyh2YWx1ZXMpO1xuICAgICAgICAgICAgZm9ybWF0dGVkU3VtID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZShzdW0sIHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGb3JtYXRGdW5jdGlvbnMoKSwgJ3NlcmllcycpO1xuICAgICAgICAgICAgaHRtbCA9IHRoaXMuX21ha2VTZXJpZXNMYWJlbEh0bWwoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuX2NhbGN1bGF0ZUxlZnRQb3NpdGlvbk9mU3VtTGFiZWwoYm91bmQsIGZvcm1hdHRlZFN1bSksXG4gICAgICAgICAgICAgICAgdG9wOiBib3VuZC50b3AgLSBsYWJlbEhlaWdodCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkdcbiAgICAgICAgICAgIH0sIGZvcm1hdHRlZFN1bSwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbWludXMgc3VtIGxhYmVsIGh0bWwuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVzIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBib3VuZCBib3VuZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBsdXMgbWludXMgbGFiZWwgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VNaW51c1N1bUxhYmVsSHRtbDogZnVuY3Rpb24odmFsdWVzLCBib3VuZCkge1xuICAgICAgICB2YXIgc3VtLCBmb3JtYXR0ZWRTdW0sXG4gICAgICAgICAgICBodG1sID0gJyc7XG5cbiAgICAgICAgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgICBzdW0gPSBjYWxjdWxhdG9yLnN1bU1pbnVzVmFsdWVzKHZhbHVlcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gTWF0aC5hYnMoc3VtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0dGVkU3VtID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZShzdW0sIHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGb3JtYXRGdW5jdGlvbnMoKSwgJ3NlcmllcycpO1xuICAgICAgICAgICAgaHRtbCA9IHRoaXMuX21ha2VTZXJpZXNMYWJlbEh0bWwoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuX2NhbGN1bGF0ZUxlZnRQb3NpdGlvbk9mU3VtTGFiZWwoYm91bmQsIGZvcm1hdHRlZFN1bSksXG4gICAgICAgICAgICAgICAgdG9wOiBib3VuZC50b3AgKyBib3VuZC5oZWlnaHQgKyBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HXG4gICAgICAgICAgICB9LCBmb3JtYXR0ZWRTdW0sIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbn0pO1xuXG5CYXJUeXBlU2VyaWVzQmFzZS5taXhpbihDb2x1bW5DaGFydFNlcmllcyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTGluZSBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2VyaWVzID0gcmVxdWlyZSgnLi9zZXJpZXMnKSxcbiAgICBMaW5lVHlwZVNlcmllc0Jhc2UgPSByZXF1aXJlKCcuL2xpbmVUeXBlU2VyaWVzQmFzZScpO1xuXG52YXIgTGluZUNoYXJ0U2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoU2VyaWVzLCAvKiogQGxlbmRzIExpbmVDaGFydFNlcmllcy5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIExpbmUgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBMaW5lQ2hhcnRTZXJpZXNcbiAgICAgKiBAZXh0ZW5kcyBTZXJpZXNcbiAgICAgKiBAbWl4ZXMgTGluZVR5cGVTZXJpZXNCYXNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm1vZGVsIHNlcmllcyBtb2RlbFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIHNlcmllcyBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBTZXJpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwb3NpdGlvbnMuXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9Pj59IHBvc2l0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQb3NpdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFrZUJhc2ljUG9zaXRpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VyaWVzIGRhdGEuXG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cFBvc2l0aW9uczogdGhpcy5fbWFrZVBvc2l0aW9ucygpXG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbkxpbmVUeXBlU2VyaWVzQmFzZS5taXhpbihMaW5lQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVDaGFydFNlcmllcztcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBMaW5lVHlwZVNlcmllc0Jhc2UgaXMgYmFzZSBjbGFzcyBmb3IgbGluZSB0eXBlIHNlcmllcy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuLyoqXG4gKiBAY2xhc3NkZXNjIExpbmVUeXBlU2VyaWVzQmFzZSBpcyBiYXNlIGNsYXNzIGZvciBsaW5lIHR5cGUgc2VyaWVzLlxuICogQGNsYXNzIExpbmVUeXBlU2VyaWVzQmFzZVxuICogQG1peGluXG4gKi9cbnZhciBMaW5lVHlwZVNlcmllc0Jhc2UgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIExpbmVUeXBlU2VyaWVzQmFzZS5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIE1ha2UgcG9zaXRpb25zIG9mIGxpbmUgY2hhcnQuXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IHBvc2l0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXNpY1Bvc2l0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJyksXG4gICAgICAgICAgICBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzRGF0YU1vZGVsKHRoaXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIHdpZHRoID0gZGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGxlbiA9IHNlcmllc0RhdGFNb2RlbC5nZXRHcm91cENvdW50KCksXG4gICAgICAgICAgICBzdGFydCA9IGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgc3RlcDtcblxuICAgICAgICBpZiAodGhpcy5kYXRhLmFsaWduZWQpIHtcbiAgICAgICAgICAgIHN0ZXAgPSB3aWR0aCAvIChsZW4gLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ZXAgPSB3aWR0aCAvIGxlbjtcbiAgICAgICAgICAgIHN0YXJ0ICs9IChzdGVwIC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzRGF0YU1vZGVsLm1hcChmdW5jdGlvbihzZXJpZXNHcm91cCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLm1hcChmdW5jdGlvbihzZXJpZXNJdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc3RhcnQgKyAoc3RlcCAqIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBoZWlnaHQgLSAoc2VyaWVzSXRlbS5yYXRpbyAqIGhlaWdodCkgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAodHVpLnV0aWwuaXNFeGlzdHkoc2VyaWVzSXRlbS5zdGFydFJhdGlvKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5zdGFydFRvcCA9IGhlaWdodCAtIChzZXJpZXNJdGVtLnN0YXJ0UmF0aW8gKiBoZWlnaHQpICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbGFiZWwgcG9zaXRpb24gdG9wLlxuICAgICAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfX0gYmFzZVBvc2l0aW9uIC0gYmFzZSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlIG9mIHNlcmllc0l0ZW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxIZWlnaHQgLSBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RhcnQgLSB3aGV0aGVyIHN0YXJ0IHZhbHVlIG9mIHNlcmllc0l0ZW0gb3Igbm90XG4gICAgICogQHJldHVybnMge251bWJlcn0gcG9zaXRpb24gdG9wXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlTGFiZWxQb3NpdGlvblRvcDogZnVuY3Rpb24oYmFzZVBvc2l0aW9uLCB2YWx1ZSwgbGFiZWxIZWlnaHQsIGlzU3RhcnQpIHtcbiAgICAgICAgdmFyIGJhc2VUb3AgPSBiYXNlUG9zaXRpb24udG9wLFxuICAgICAgICAgICAgdG9wO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNWYWxpZFN0YWNrZWRPcHRpb24odGhpcy5vcHRpb25zLnN0YWNrZWQpKSB7XG4gICAgICAgICAgICB0b3AgPSAoYmFzZVBvc2l0aW9uLnN0YXJ0VG9wICsgYmFzZVRvcCAtIGxhYmVsSGVpZ2h0KSAvIDIgKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKCh2YWx1ZSA+PSAwICYmICFpc1N0YXJ0KSB8fCAodmFsdWUgPCAwICYmIGlzU3RhcnQpKSB7XG4gICAgICAgICAgICB0b3AgPSBiYXNlVG9wIC0gbGFiZWxIZWlnaHQgLSBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wID0gYmFzZVRvcCArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxhYmVsIHBvc2l0aW9uIGZvciByZW5kZXJpbmcgbGFiZWwgb2Ygc2VyaWVzIGFyZWEuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6ID9udW1iZXJ9fSBiYXNlUG9zaXRpb24gLSBiYXNlIHBvc2l0aW9uIGZvciBjYWxjdWxhdGluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEhlaWdodCAtIGxhYmVsIGhlaWdodFxuICAgICAqIEBwYXJhbSB7KHN0cmluZyB8IG51bWJlcil9IGxhYmVsIC0gbGFiZWwgb2Ygc2VyaWVzSXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlIG9mIHNlcmllc0l0ZW1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RhcnQgLSB3aGV0aGVyIHN0YXJ0IGxhYmVsIHBvc2l0aW9uIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxhYmVsUG9zaXRpb246IGZ1bmN0aW9uKGJhc2VQb3NpdGlvbiwgbGFiZWxIZWlnaHQsIGxhYmVsLCB2YWx1ZSwgaXNTdGFydCkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogYmFzZVBvc2l0aW9uLmxlZnQgLSAobGFiZWxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgdG9wOiB0aGlzLl9jYWxjdWxhdGVMYWJlbFBvc2l0aW9uVG9wKGJhc2VQb3NpdGlvbiwgdmFsdWUsIGxhYmVsSGVpZ2h0LCBpc1N0YXJ0KVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGh0bWwgZm9yIHNlcmllcyBsYWJlbCBmb3IgbGluZSB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IC0gaW5kZXggb2Ygc2VyaWVzRGF0YU1vZGVsLmdyb3Vwc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIHNlcmllc0dyb3VwLml0ZW1zXG4gICAgICogQHBhcmFtIHtTZXJpZXNJdGVtfSBzZXJpZXNJdGVtIC0gc2VyaWVzIGl0ZW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxIZWlnaHQgLSBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RhcnQgLSB3aGV0aGVyIHN0YXJ0IGxhYmVsIHBvc2l0aW9uIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc0xhYmVsSHRtbEZvckxpbmVUeXBlOiBmdW5jdGlvbihncm91cEluZGV4LCBpbmRleCwgc2VyaWVzSXRlbSwgbGFiZWxIZWlnaHQsIGlzU3RhcnQpIHtcbiAgICAgICAgdmFyIGJhc2VQb3NpdGlvbiA9IHR1aS51dGlsLmV4dGVuZCh7fSwgdGhpcy5zZXJpZXNEYXRhLmdyb3VwUG9zaXRpb25zW2dyb3VwSW5kZXhdW2luZGV4XSksXG4gICAgICAgICAgICBsYWJlbCwgcG9zaXRpb247XG5cbiAgICAgICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgICAgICAgIGxhYmVsID0gc2VyaWVzSXRlbS5zdGFydExhYmVsO1xuICAgICAgICAgICAgYmFzZVBvc2l0aW9uLnRvcCA9IGJhc2VQb3NpdGlvbi5zdGFydFRvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsID0gc2VyaWVzSXRlbS5lbmRMYWJlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5fbWFrZUxhYmVsUG9zaXRpb24oYmFzZVBvc2l0aW9uLCBsYWJlbEhlaWdodCwgbGFiZWwsIHNlcmllc0l0ZW0udmFsdWUsIGlzU3RhcnQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYWtlU2VyaWVzTGFiZWxIdG1sKHBvc2l0aW9uLCBsYWJlbCwgZ3JvdXBJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxTZXJpZXNMYWJlbEFyZWEgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0xhYmVsOiBmdW5jdGlvbihlbFNlcmllc0xhYmVsQXJlYSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzRGF0YU1vZGVsKHRoaXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIGZpcnN0TGFiZWwgPSBzZXJpZXNEYXRhTW9kZWwuZ2V0Rmlyc3RJdGVtTGFiZWwoKSxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGZpcnN0TGFiZWwsIHRoaXMudGhlbWUubGFiZWwpLFxuICAgICAgICAgICAgaHRtbHM7XG5cbiAgICAgICAgaHRtbHMgPSBzZXJpZXNEYXRhTW9kZWwubWFwKGZ1bmN0aW9uKHNlcmllc0dyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAubWFwKGZ1bmN0aW9uKHNlcmllc0l0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsSHRtbCA9IHNlbGYuX21ha2VTZXJpZXNMYWJlbEh0bWxGb3JMaW5lVHlwZShncm91cEluZGV4LCBpbmRleCwgc2VyaWVzSXRlbSwgbGFiZWxIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlcmllc0l0ZW0uaXNSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbEh0bWwgKz0gc2VsZi5fbWFrZVNlcmllc0xhYmVsSHRtbEZvckxpbmVUeXBlKGdyb3VwSW5kZXgsIGluZGV4LCBzZXJpZXNJdGVtLCBsYWJlbEhlaWdodCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsSHRtbDtcbiAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICBlbFNlcmllc0xhYmVsQXJlYS5pbm5lckhUTUwgPSBodG1scy5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjaGFuZ2VkIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJbmRleCBncm91cCBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIGNoYW5nZWQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNDaGFuZ2VkOiBmdW5jdGlvbihncm91cEluZGV4LCBpbmRleCkge1xuICAgICAgICB2YXIgcHJldkluZGV4ZXMgPSB0aGlzLnByZXZJbmRleGVzO1xuXG4gICAgICAgIHRoaXMucHJldkluZGV4ZXMgPSB7XG4gICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICFwcmV2SW5kZXhlcyB8fCAocHJldkluZGV4ZXMuZ3JvdXBJbmRleCAhPT0gZ3JvdXBJbmRleCkgfHwgKHByZXZJbmRleGVzLmluZGV4ICE9PSBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgc2hvd0dyb3VwVG9vbHRpcExpbmUgZnVuY3Rpb24gb2YgZ3JhcGhSZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBib3VuZCBib3VuZFxuICAgICAqL1xuICAgIG9uU2hvd0dyb3VwVG9vbHRpcExpbmU6IGZ1bmN0aW9uKGJvdW5kKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaFJlbmRlcmVyLnNob3dHcm91cFRvb2x0aXBMaW5lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnNob3dHcm91cFRvb2x0aXBMaW5lKGJvdW5kKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBoaWRlR3JvdXBUb29sdGlwTGluZSBmdW5jdGlvbiBvZiBncmFwaFJlbmRlcmVyLlxuICAgICAqL1xuICAgIG9uSGlkZUdyb3VwVG9vbHRpcExpbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGhSZW5kZXJlci5oaWRlR3JvdXBUb29sdGlwTGluZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5oaWRlR3JvdXBUb29sdGlwTGluZSgpO1xuICAgIH1cbn0pO1xuXG5MaW5lVHlwZVNlcmllc0Jhc2UubWl4aW4gPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdHVpLnV0aWwuZXh0ZW5kKGZ1bmMucHJvdG90eXBlLCBMaW5lVHlwZVNlcmllc0Jhc2UucHJvdG90eXBlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZVR5cGVTZXJpZXNCYXNlO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hcCBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2VyaWVzID0gcmVxdWlyZSgnLi9zZXJpZXMnKSxcbiAgICBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbnZhciBNYXBDaGFydFNlcmllcyA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFNlcmllcywgLyoqIEBsZW5kcyBNYXBDaGFydFNlcmllcy5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIE1hcCBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIE1hcENoYXJ0U2VyaWVzXG4gICAgICogQGV4dGVuZHMgU2VyaWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgc2VyaWVzIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgc2VyaWVzIHRoZW1lXG4gICAgICogICAgICBAcGFyYW0ge01hcENoYXJ0RGF0YVByb2Nlc3Nvcn0gcGFyYW1zLmRhdGFQcm9jZXNzb3IgZGF0YSBwcm9jZXNzb3IgZm9yIG1hcCBjaGFydFxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQmFzZSBwb3NpdGlvbi5cbiAgICAgICAgICogQHR5cGUge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmFzZVBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBab29tIG1hZ25pZmljYXRpb24uXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpvb21NYWduID0gMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIHJhdGlvLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBSYXRpbyA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHR5cGUge3t9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncmFwaERpbWVuc2lvbiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaW1pdCBwb3NpdGlvbi5cbiAgICAgICAgICogQHR5cGUge3t9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW1pdFBvc2l0aW9uID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBtb2RlbC5cbiAgICAgICAgICogQHR5cGUge01hcENoYXJ0TWFwTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcE1vZGVsID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJldmlvdXMgbW91c2UgcG9zaXRpb24uXG4gICAgICAgICAqIEB0eXBlIHs/e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2UG9zaXRpb24gPSBudWxsO1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZXZpb3VzIG1vdmVkIGluZGV4LlxuICAgICAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldk1vdmVkSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIGRyYWcgb3Igbm90LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNEcmFnID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IHBvc2l0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7P3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IG51bGw7XG5cbiAgICAgICAgU2VyaWVzLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IG1hcCByYXRpby5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRNYXBSYXRpbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNEaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJyksXG4gICAgICAgICAgICBtYXBEaW1lbnNpb24gPSB0aGlzLm1hcE1vZGVsLmdldE1hcERpbWVuc2lvbigpLFxuICAgICAgICAgICAgd2lkdGhSYXRpbyA9IHNlcmllc0RpbWVuc2lvbi53aWR0aCAvIG1hcERpbWVuc2lvbi53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodFJhdGlvID0gc2VyaWVzRGltZW5zaW9uLmhlaWdodCAvIG1hcERpbWVuc2lvbi5oZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5tYXBSYXRpbyA9IE1hdGgubWluKHdpZHRoUmF0aW8sIGhlaWdodFJhdGlvKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGdyYXBoIGRpbWVuc2lvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRHcmFwaERpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNEaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJyk7XG5cbiAgICAgICAgdGhpcy5ncmFwaERpbWVuc2lvbiA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBzZXJpZXNEaW1lbnNpb24ud2lkdGggKiB0aGlzLnpvb21NYWduLFxuICAgICAgICAgICAgaGVpZ2h0OiBzZXJpZXNEaW1lbnNpb24uaGVpZ2h0ICogdGhpcy56b29tTWFnblxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHNlcmllcyBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBjb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5tYXBNb2RlbCA9IGRhdGEubWFwTW9kZWw7XG4gICAgICAgIHRoaXMuX3NldE1hcFJhdGlvKCk7XG5cbiAgICAgICAgY29udGFpbmVyID0gU2VyaWVzLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGxpbWl0IHBvc2l0aW9uIHRvIG1vdmUgbWFwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExpbWl0UG9zaXRpb25Ub01vdmVNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzRGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpLFxuICAgICAgICAgICAgZ3JhcGhEaW1lbnNpb24gPSB0aGlzLmdyYXBoRGltZW5zaW9uO1xuXG4gICAgICAgIHRoaXMubGltaXRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHNlcmllc0RpbWVuc2lvbi53aWR0aCAtIGdyYXBoRGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgdG9wOiBzZXJpZXNEaW1lbnNpb24uaGVpZ2h0IC0gZ3JhcGhEaW1lbnNpb24uaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciByYXBoYWVsIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3JlbmRlckdyYXBoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoQ29udGFpbmVyID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1zZXJpZXMtZ3JhcGgtYXJlYScpO1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ncmFwaENvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRHcmFwaERpbWVuc2lvbigpO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckRpbWVuc2lvbih0aGlzLmdyYXBoQ29udGFpbmVyLCB0aGlzLmdyYXBoRGltZW5zaW9uKTtcblxuICAgICAgICB0aGlzLl9zZXRMaW1pdFBvc2l0aW9uVG9Nb3ZlTWFwKCk7XG5cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlbmRlcih0aGlzLmdyYXBoQ29udGFpbmVyLCB7XG4gICAgICAgICAgICBjb2xvck1vZGVsOiB0aGlzLmRhdGEuY29sb3JNb2RlbCxcbiAgICAgICAgICAgIG1hcE1vZGVsOiB0aGlzLm1hcE1vZGVsLFxuICAgICAgICAgICAgZGltZW5zaW9uOiB0aGlzLmdyYXBoRGltZW5zaW9uLFxuICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2VyaWVzTGFiZWxDb250YWluZXIgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0xhYmVsOiBmdW5jdGlvbihzZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBodG1scyA9IHR1aS51dGlsLm1hcCh0aGlzLm1hcE1vZGVsLmdldExhYmVsRGF0YSh0aGlzLnpvb21NYWduICogdGhpcy5tYXBSYXRpbyksIGZ1bmN0aW9uKGRhdHVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGRhdHVtLm5hbWUgfHwgZGF0dW0uY29kZSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGRhdHVtLmxhYmVsUG9zaXRpb24ubGVmdCAtIChyZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChsYWJlbCwgc2VsZi50aGVtZS5sYWJlbCkgLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gZGF0dW0ubGFiZWxQb3NpdGlvbi50b3AgLSAocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGxhYmVsLCBzZWxmLnRoZW1lLmxhYmVsKSAvIDIpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX21ha2VTZXJpZXNMYWJlbEh0bWwoe1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICAgICAgICAgIH0sIGRhdHVtLm5hbWUsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBzZXJpZXNMYWJlbENvbnRhaW5lci5pbm5lckhUTUwgPSBodG1scy5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNlcmllcyBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNlcmllc0NvbnRhaW5lciBzZXJpZXMgYXJlYSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1JlbmRlckdyYXBoIGZ1bmN0aW9uIGZvciBncmFwaCByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZXJpZXNBcmVhOiBmdW5jdGlvbihzZXJpZXNDb250YWluZXIsIGRhdGEsIGZ1bmNSZW5kZXJHcmFwaCkge1xuICAgICAgICBTZXJpZXMucHJvdG90eXBlLl9yZW5kZXJTZXJpZXNBcmVhLmNhbGwodGhpcywgc2VyaWVzQ29udGFpbmVyLCBkYXRhLCBmdW5jUmVuZGVyR3JhcGgpO1xuICAgICAgICB0aGlzLmdyYXBoQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgbWFwIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSB0YXJnZXRQb3NpdGlvbiB0YXJnZXQgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBhZGp1c3RlZCBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkanVzdE1hcFBvc2l0aW9uOiBmdW5jdGlvbih0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0UG9zaXRpb24ubGVmdCwgMCksIHRoaXMubGltaXRQb3NpdGlvbi5sZWZ0KSxcbiAgICAgICAgICAgIHRvcDogTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0UG9zaXRpb24udG9wLCAwKSwgdGhpcy5saW1pdFBvc2l0aW9uLnRvcClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGJhc2UgcG9zaXRpb24gZm9yIHpvb20uXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwcmV2RGltZW5zaW9uIHByZXZpb3VzIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2TGltaXRQb3NpdGlvbiBwcmV2aW91cyBsaW1pdCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFuZ2VkUmF0aW8gY2hhbmdlZCByYXRpb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUJhc2VQb3NpdGlvbkZvclpvb206IGZ1bmN0aW9uKHByZXZEaW1lbnNpb24sIHByZXZMaW1pdFBvc2l0aW9uLCBjaGFuZ2VkUmF0aW8pIHtcbiAgICAgICAgdmFyIHByZXZCYXNlUG9zaXRpb24gPSB0aGlzLmJhc2VQb3NpdGlvbixcbiAgICAgICAgICAgIHByZXZMZWZ0ID0gcHJldkJhc2VQb3NpdGlvbi5sZWZ0IC0gKHByZXZMaW1pdFBvc2l0aW9uLmxlZnQgLyAyKSxcbiAgICAgICAgICAgIHByZXZUb3AgPSBwcmV2QmFzZVBvc2l0aW9uLnRvcCAtIChwcmV2TGltaXRQb3NpdGlvbi50b3AgLyAyKSxcbiAgICAgICAgICAgIG5ld0Jhc2VQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAocHJldkxlZnQgKiBjaGFuZ2VkUmF0aW8pICsgKHRoaXMubGltaXRQb3NpdGlvbi5sZWZ0IC8gMiksXG4gICAgICAgICAgICAgICAgdG9wOiAocHJldlRvcCAqIGNoYW5nZWRSYXRpbykgKyAodGhpcy5saW1pdFBvc2l0aW9uLnRvcCAvIDIpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYmFzZVBvc2l0aW9uID0gdGhpcy5fYWRqdXN0TWFwUG9zaXRpb24obmV3QmFzZVBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbmdlZFJhdGlvIGNoYW5nZWQgcmF0aW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF96b29tOiBmdW5jdGlvbihjaGFuZ2VkUmF0aW8pIHtcbiAgICAgICAgdmFyIHByZXZEaW1lbnNpb24gPSB0aGlzLmdyYXBoRGltZW5zaW9uLFxuICAgICAgICAgICAgcHJldkxpbWl0UG9zaXRpb24gPSB0aGlzLmxpbWl0UG9zaXRpb247XG5cbiAgICAgICAgdGhpcy5fc2V0R3JhcGhEaW1lbnNpb24oKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24odGhpcy5ncmFwaENvbnRhaW5lciwgdGhpcy5ncmFwaERpbWVuc2lvbik7XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zZXRTaXplKHRoaXMuZ3JhcGhEaW1lbnNpb24pO1xuXG4gICAgICAgIHRoaXMuX3NldExpbWl0UG9zaXRpb25Ub01vdmVNYXAoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmFzZVBvc2l0aW9uRm9yWm9vbShwcmV2RGltZW5zaW9uLCBwcmV2TGltaXRQb3NpdGlvbiwgY2hhbmdlZFJhdGlvKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbih0aGlzLmdyYXBoQ29udGFpbmVyLCB0aGlzLmJhc2VQb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyU2VyaWVzTGFiZWwodGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwb3NpdGlvbnMgdG8gcmVzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmV2TWFwUmF0aW8gcHJldmlvdXMgcmF0aW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVQb3NpdGlvbnNUb1Jlc2l6ZTogZnVuY3Rpb24ocHJldk1hcFJhdGlvKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkUmF0aW8gPSB0aGlzLm1hcFJhdGlvIC8gcHJldk1hcFJhdGlvO1xuXG4gICAgICAgIHRoaXMuYmFzZVBvc2l0aW9uLmxlZnQgKj0gY2hhbmdlZFJhdGlvO1xuICAgICAgICB0aGlzLmJhc2VQb3NpdGlvbi50b3AgKj0gY2hhbmdlZFJhdGlvO1xuXG4gICAgICAgIHRoaXMubGltaXRQb3NpdGlvbi5sZWZ0ICo9IGNoYW5nZWRSYXRpbztcbiAgICAgICAgdGhpcy5saW1pdFBvc2l0aW9uLnRvcCAqPSBjaGFuZ2VkUmF0aW87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBncmFwaC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNpemVHcmFwaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcmV2UmF0aW8gPSB0aGlzLm1hcFJhdGlvO1xuXG4gICAgICAgIHRoaXMuX3NldE1hcFJhdGlvKCk7XG5cbiAgICAgICAgdGhpcy5fc2V0R3JhcGhEaW1lbnNpb24oKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24odGhpcy5ncmFwaENvbnRhaW5lciwgdGhpcy5ncmFwaERpbWVuc2lvbik7XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zZXRTaXplKHRoaXMuZ3JhcGhEaW1lbnNpb24pO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uc0ZvclJlc2l6aW5nKHByZXZSYXRpbyk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24odGhpcy5ncmFwaENvbnRhaW5lciwgdGhpcy5iYXNlUG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0xhYmVsKHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGljayBzZXJpZXMuXG4gICAgICovXG4gICAgb25DbGlja1NlcmllczogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBvciBub3QuXG4gICAgICogQHBhcmFtIHs/e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2UG9zaXRpb24gcHJldmlvdXMgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0NoYW5nZWRQb3NpdGlvbjogZnVuY3Rpb24ocHJldlBvc2l0aW9uLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gIXByZXZQb3NpdGlvbiB8fCBwcmV2UG9zaXRpb24ubGVmdCAhPT0gcG9zaXRpb24ubGVmdCB8fCBwcmV2UG9zaXRpb24udG9wICE9PSBwb3NpdGlvbi50b3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgd2VkZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IG1hcCBkYXRhIGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd1dlZGdlOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgZGF0dW0gPSB0aGlzLm1hcE1vZGVsLmdldERhdHVtKGluZGV4KTtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKGRhdHVtLnJhdGlvKSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdzaG93V2VkZ2UnLCBkYXR1bS5yYXRpbyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IG1hcCBkYXRhIGluZGV4XG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IG1vdXNlUG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93VG9vbHRpcDogZnVuY3Rpb24oaW5kZXgsIG1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5maXJlKCdzaG93VG9vbHRpcCcsIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICAgICAgICBpbmRleGVzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2VQb3NpdGlvbjogbW91c2VQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlcmllcyBjb250YWluZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gY29udGFpbmVyIGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q29udGFpbmVyQm91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyQm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyQm91bmQgPSB0aGlzLnNlcmllc0NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJCb3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW92ZSBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICovXG4gICAgb25Nb3ZlU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgZm91bmRJbmRleCA9IHRoaXMuX2V4ZWN1dGVHcmFwaFJlbmRlcmVyKHBvc2l0aW9uLCAnZmluZFNlY3RvckluZGV4JyksXG4gICAgICAgICAgICBjb250YWluZXJCb3VuZDtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzTnVsbChmb3VuZEluZGV4KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldk1vdmVkSW5kZXggIT09IGZvdW5kSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXR1aS51dGlsLmlzTnVsbCh0aGlzLnByZXZNb3ZlZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIucmVzdG9yZUNvbG9yKHRoaXMucHJldk1vdmVkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2hpZGVXZWRnZScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2hpZGVUb29sdGlwJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLmNoYW5nZUNvbG9yKGZvdW5kSW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNDaGFuZ2VkUG9zaXRpb24odGhpcy5wcmV2UG9zaXRpb24sIHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kID0gdGhpcy5fZ2V0Q29udGFpbmVyQm91bmQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG93VG9vbHRpcChmb3VuZEluZGV4LCB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgLSBjb250YWluZXJCb3VuZC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCAtIGNvbnRhaW5lckJvdW5kLnRvcFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldk1vdmVkSW5kZXggPSBmb3VuZEluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zaG93V2VkZ2UoZm91bmRJbmRleCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXR1aS51dGlsLmlzTnVsbCh0aGlzLnByZXZNb3ZlZEluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlc3RvcmVDb2xvcih0aGlzLnByZXZNb3ZlZEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVdlZGdlJyk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2hpZGVUb29sdGlwJyk7XG4gICAgICAgICAgICB0aGlzLnByZXZNb3ZlZEluZGV4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBkcmFnIHN0YXJ0IHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKi9cbiAgICBvbkRyYWdTdGFydFNlcmllczogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHN0YXJ0UG9zaXRpb24gc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gZW5kUG9zaXRpb24gZW5kIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW92ZVBvc2l0aW9uOiBmdW5jdGlvbihzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xuICAgICAgICB2YXIgbW92ZW1lbnRQb3NpdGlvbiA9IHRoaXMuX2FkanVzdE1hcFBvc2l0aW9uKHtcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMuYmFzZVBvc2l0aW9uLmxlZnQgKyAoZW5kUG9zaXRpb24ubGVmdCAtIHN0YXJ0UG9zaXRpb24ubGVmdCksXG4gICAgICAgICAgICB0b3A6IHRoaXMuYmFzZVBvc2l0aW9uLnRvcCArIChlbmRQb3NpdGlvbi50b3AgLSBzdGFydFBvc2l0aW9uLnRvcClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbih0aGlzLmdyYXBoQ29udGFpbmVyLCBtb3ZlbWVudFBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmJhc2VQb3NpdGlvbiA9IG1vdmVtZW50UG9zaXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGRyYWcgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqL1xuICAgIG9uRHJhZ1NlcmllczogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fbW92ZVBvc2l0aW9uKHRoaXMuc3RhcnRQb3NpdGlvbiwgcG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0RyYWcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVRvb2x0aXAnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBkcmFnIGVuZCBzZXJpZXMuXG4gICAgICovXG4gICAgb25EcmFnRW5kU2VyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pc0RyYWcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSBwb3NpdGlvbiBmb3Igem9vbS5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbmdlZFJhdGlvIGNoYW5nZWQgcmF0aW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3ZlUG9zaXRpb25Gb3Jab29tOiBmdW5jdGlvbihwb3NpdGlvbiwgY2hhbmdlZFJhdGlvKSB7XG4gICAgICAgIHZhciBzZXJpZXNEaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJyksXG4gICAgICAgICAgICBjb250YWluZXJCb3VuZCA9IHRoaXMuX2dldENvbnRhaW5lckJvdW5kKCksXG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IChzZXJpZXNEaW1lbnNpb24ud2lkdGggLyAyKSArIGNvbnRhaW5lckJvdW5kLmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiAoc2VyaWVzRGltZW5zaW9uLmhlaWdodCAvIDIpICsgY29udGFpbmVyQm91bmQudG9wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW92ZW1lbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0IC0gc3RhcnRQb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wIC0gc3RhcnRQb3NpdGlvbi50b3BcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmRQb3NpdGlvbjtcblxuICAgICAgICBjaGFuZ2VkUmF0aW8gPSBjaGFuZ2VkUmF0aW8gPiAxID8gLShjaGFuZ2VkUmF0aW8gLyAyKSA6IGNoYW5nZWRSYXRpbztcblxuICAgICAgICBlbmRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHN0YXJ0UG9zaXRpb24ubGVmdCArIChtb3ZlbWVudFBvc2l0aW9uLmxlZnQgKiBjaGFuZ2VkUmF0aW8pLFxuICAgICAgICAgICAgdG9wOiBzdGFydFBvc2l0aW9uLnRvcCArIChtb3ZlbWVudFBvc2l0aW9uLnRvcCAqIGNoYW5nZWRSYXRpbylcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9tb3ZlUG9zaXRpb24oc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiB6b29tLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdNYWduIG5ldyB6b29tIG1hZ25pZmljYXRpb25cbiAgICAgKiBAcGFyYW0gez97bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICovXG4gICAgb25ab29tOiBmdW5jdGlvbihuZXdNYWduLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgY2hhbmdlZFJhdGlvID0gbmV3TWFnbiAvIHRoaXMuem9vbU1hZ247XG5cbiAgICAgICAgdGhpcy56b29tTWFnbiA9IG5ld01hZ247XG5cbiAgICAgICAgdGhpcy5fem9vbShjaGFuZ2VkUmF0aW8pO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbW92ZVBvc2l0aW9uRm9yWm9vbShwb3NpdGlvbiwgY2hhbmdlZFJhdGlvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXNlckV2ZW50LmZpcmUoJ3pvb20nLCBuZXdNYWduKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgYW5pbWF0ZUNvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0ZVNob3dpbmdBYm91dFNlcmllc0xhYmVsQXJlYSgpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oTWFwQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENoYXJ0U2VyaWVzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFBpZSBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2VyaWVzID0gcmVxdWlyZSgnLi9zZXJpZXMnKSxcbiAgICBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcblxudmFyIFBpZUNoYXJ0U2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoU2VyaWVzLCAvKiogQGxlbmRzIFBpZUNoYXJ0U2VyaWVzLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTGluZSBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIFBpZUNoYXJ0U2VyaWVzXG4gICAgICogQGV4dGVuZHMgU2VyaWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm1vZGVsIHNlcmllcyBtb2RlbFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIHNlcmllcyBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogbGVnZW5kIGFsaWduIG9wdGlvbi5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlZ2VuZEFsaWduID0gcGFyYW1zLmxlZ2VuZEFsaWduO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCBiYWNrZ3JvdW5kLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydEJhY2tncm91bmQgPSBwYXJhbXMuY2hhcnRCYWNrZ3JvdW5kO1xuXG4gICAgICAgIFNlcmllcy5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VjdG9ycyBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByOiBudW1iZXJ9fSBjaXJjbGVCb3VuZCBjaXJjbGUgYm91bmRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59IHNlY3RvcnMgaW5mb3JtYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VjdG9yRGF0YTogZnVuY3Rpb24oY2lyY2xlQm91bmQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VyaWVzR3JvdXAgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzRGF0YU1vZGVsKHRoaXMuY2hhcnRUeXBlKS5nZXRGaXJzdFNlcmllc0dyb3VwKCksXG4gICAgICAgICAgICBjeCA9IGNpcmNsZUJvdW5kLmN4LFxuICAgICAgICAgICAgY3kgPSBjaXJjbGVCb3VuZC5jeSxcbiAgICAgICAgICAgIHIgPSBjaXJjbGVCb3VuZC5yLFxuICAgICAgICAgICAgYW5nbGUgPSAwLFxuICAgICAgICAgICAgZGVsdGEgPSAxMCxcbiAgICAgICAgICAgIHBhdGhzO1xuXG4gICAgICAgIHBhdGhzID0gc2VyaWVzR3JvdXAubWFwKGZ1bmN0aW9uKHNlcmllc0l0ZW0pIHtcbiAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsQW5nbGUgPSBjaGFydENvbnN0LkFOR0xFXzM2MCAqIHNlcmllc0l0ZW0ucmF0aW8sXG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBhbmdsZSArIGFkZGl0aW9uYWxBbmdsZSxcbiAgICAgICAgICAgICAgICBwb3B1cEFuZ2xlID0gYW5nbGUgKyAoYWRkaXRpb25hbEFuZ2xlIC8gMiksXG4gICAgICAgICAgICAgICAgYW5nbGVzID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogYW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgICAgICBhbmdsZTogcG9wdXBBbmdsZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFuZ2xlID0gZW5kQW5nbGU7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudFZhbHVlOiBzZXJpZXNJdGVtLnJhdGlvLFxuICAgICAgICAgICAgICAgIGFuZ2xlczogYW5nbGVzLFxuICAgICAgICAgICAgICAgIGNlbnRlclBvc2l0aW9uOiBzZWxmLl9nZXRBcmNQb3NpdGlvbih0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICByOiAociAvIDIpICsgZGVsdGFcbiAgICAgICAgICAgICAgICB9LCBwb3NpdGlvbkRhdGEpKSxcbiAgICAgICAgICAgICAgICBvdXRlclBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWxmLl9nZXRBcmNQb3NpdGlvbih0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcjogclxuICAgICAgICAgICAgICAgICAgICB9LCBwb3NpdGlvbkRhdGEpKSxcbiAgICAgICAgICAgICAgICAgICAgbWlkZGxlOiBzZWxmLl9nZXRBcmNQb3NpdGlvbih0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcjogciArIGRlbHRhXG4gICAgICAgICAgICAgICAgICAgIH0sIHBvc2l0aW9uRGF0YSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllcyBkYXRhLlxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBjaGFydEJhY2tncm91bmQ6IHN0cmluZyxcbiAgICAgKiAgICAgIGNpcmNsZUJvdW5kOiAoe2N4OiBudW1iZXIsIGN5OiBudW1iZXIsIHI6IG51bWJlcn0pLFxuICAgICAqICAgICAgc2VjdG9yRGF0YTogQXJyYXkuPG9iamVjdD5cbiAgICAgKiB9fSBhZGQgZGF0YSBmb3IgZ3JhcGggcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2lyY2xlQm91bmQgPSB0aGlzLl9tYWtlQ2lyY2xlQm91bmQodGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpLCB7XG4gICAgICAgICAgICAgICAgc2hvd0xhYmVsOiB0aGlzLm9wdGlvbnMuc2hvd0xhYmVsLFxuICAgICAgICAgICAgICAgIGxlZ2VuZEFsaWduOiB0aGlzLmxlZ2VuZEFsaWduXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNlY3RvckRhdGEgPSB0aGlzLl9tYWtlU2VjdG9yRGF0YShjaXJjbGVCb3VuZCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYXJ0QmFja2dyb3VuZDogdGhpcy5jaGFydEJhY2tncm91bmQsXG4gICAgICAgICAgICBjaXJjbGVCb3VuZDogY2lyY2xlQm91bmQsXG4gICAgICAgICAgICBzZWN0b3JEYXRhOiBzZWN0b3JEYXRhXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY2lyY2xlIGJvdW5kXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IGRpbWVuc2lvbiBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tzaG93TGFiZWw6IGJvb2xlYW4sIGxlZ2VuZEFsaWduOiBzdHJpbmd9fSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7e2N4OiBudW1iZXIsIGN5OiBudW1iZXIsIHI6IG51bWJlcn19IGNpcmNsZSBib3VuZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ2lyY2xlQm91bmQ6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgd2lkdGggPSBkaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBkaW1lbnNpb24uaGVpZ2h0LFxuICAgICAgICAgICAgaXNTbWFsbFBpZSA9IHByZWRpY2F0ZS5pc0xlZ2VuZEFsaWduT3V0ZXIob3B0aW9ucy5sZWdlbmRBbGlnbikgJiYgb3B0aW9ucy5zaG93TGFiZWwsXG4gICAgICAgICAgICByYWRpdXNSYXRlID0gaXNTbWFsbFBpZSA/IGNoYXJ0Q29uc3QuUElFX0dSQVBIX1NNQUxMX1JBVEUgOiBjaGFydENvbnN0LlBJRV9HUkFQSF9ERUZBVUxUX1JBVEUsXG4gICAgICAgICAgICBkaWFtZXRlciA9IHR1aS51dGlsLm11bHRpcGxpY2F0aW9uKE1hdGgubWluKHdpZHRoLCBoZWlnaHQpLCByYWRpdXNSYXRlKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3g6IHR1aS51dGlsLmRpdmlzaW9uKHdpZHRoLCAyKSxcbiAgICAgICAgICAgIGN5OiB0dWkudXRpbC5kaXZpc2lvbihoZWlnaHQsIDIpLFxuICAgICAgICAgICAgcjogdHVpLnV0aWwuZGl2aXNpb24oZGlhbWV0ZXIsIDIpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhcmMgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmN4IGNlbnRlciB4XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmN5IGNlbnRlciB5XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnIgcmFkaXVzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmFuZ2xlIGFuZ2xlKGRlZ3JlZSlcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBhcmMgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRBcmNQb3NpdGlvbjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBwYXJhbXMuY3ggKyAocGFyYW1zLnIgKiBNYXRoLnNpbihwYXJhbXMuYW5nbGUgKiBjaGFydENvbnN0LlJBRCkpLFxuICAgICAgICAgICAgdG9wOiBwYXJhbXMuY3kgLSAocGFyYW1zLnIgKiBNYXRoLmNvcyhwYXJhbXMuYW5nbGUgKiBjaGFydENvbnN0LlJBRCkpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciByYXBoYWVsIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfcmVuZGVyR3JhcGg6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSkge1xuICAgICAgICB2YXIgc2hvd1Rvb3RsdGlwID0gdHVpLnV0aWwuYmluZCh0aGlzLnNob3dUb29sdGlwLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZVRvb2x0aXA6ICEhdGhpcy5hbGxvd05lZ2F0aXZlVG9vbHRpcCxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgICAgICBzaG93VG9vbHRpcDogc2hvd1Rvb3RsdGlwLFxuICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwOiB0dWkudXRpbC5iaW5kKHRoaXMuaGlkZVRvb2x0aXAsIHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1zID0gdGhpcy5fbWFrZVBhcmFtc0ZvckdyYXBoUmVuZGVyaW5nKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSk7XG5cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlbmRlcih0aGlzLnNlcmllc0NvbnRhaW5lciwgcGFyYW1zLCBjYWxsYmFja3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgU2VyaWVzLnByb3RvdHlwZS5yZXNpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fbW92ZUxlZ2VuZExpbmVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNob3dUb29sdGlwIGlzIG1vdXNlb3ZlciBldmVudCBjYWxsYmFjayBvbiBzZXJpZXMgZ3JhcGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5hbGxvd05lZ2F0aXZlVG9vbHRpcCB3aGV0aGVyIGFsbG93IG5lZ2F0aXZlIHRvb2x0aXAgb3Igbm90XG4gICAgICogQHBhcmFtIHt7dG9wOm51bWJlciwgbGVmdDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIGdyYXBoIGJvdW5kIGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggZ3JvdXAgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gbW91c2VQb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIHNob3dUb29sdGlwOiBmdW5jdGlvbihwYXJhbXMsIGJvdW5kLCBncm91cEluZGV4LCBpbmRleCwgbW91c2VQb3NpdGlvbikge1xuICAgICAgICB0aGlzLmZpcmUoJ3Nob3dUb29sdGlwJywgdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb246IG1vdXNlUG9zaXRpb25cbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhpZGVUb29sdGlwIGlzIG1vdXNlb3V0IGV2ZW50IGNhbGxiYWNrIG9uIHNlcmllcyBncmFwaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdG9vbHRpcCBpZFxuICAgICAqL1xuICAgIGhpZGVUb29sdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllcyBkYXRhIGJ5IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e2luZGV4ZXM6IHtpbmRleDogbnVtYmVyLCBncm91cEluZGV4OiBudW1iZXJ9fX0gc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YUJ5U2VsZWN0aW9uOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiBpbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5sZWdlbmQgbGVnZW5kXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmxhYmVsIGxhYmVsXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNlcGFyYXRvciBzZXBhcmF0b3JcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZ2VuZEFsaWduOiA/c3RyaW5nLCBzaG93TGFiZWw6IGJvb2xlYW59fSBwYXJhbXMub3B0aW9ucyBvcHRpb25zXG4gICAgICogQHJldHVybnMge3N0cmluZ30gc2VyaWVzIGxhYmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U2VyaWVzTGFiZWw6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgc2VyaWVzTGFiZWwgPSAnJztcblxuICAgICAgICBpZiAodGhpcy5sZWdlbmRBbGlnbikge1xuICAgICAgICAgICAgc2VyaWVzTGFiZWwgPSAnPHNwYW4gY2xhc3M9XCJ0dWktY2hhcnQtc2VyaWVzLWxlZ2VuZFwiPicgKyBwYXJhbXMubGVnZW5kICsgJzwvc3Bhbj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TGFiZWwpIHtcbiAgICAgICAgICAgIHNlcmllc0xhYmVsICs9IChzZXJpZXNMYWJlbCA/IHBhcmFtcy5zZXBhcmF0b3IgOiAnJykgKyBwYXJhbXMubGFiZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzTGFiZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjZW50ZXIgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gcGFyYW1zLnBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2VwYXJhdG9yIHNlcGFyYXRvclxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHBhcmFtcy5mdW5jTW92ZVRvUG9zaXRpb24gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzZXJpZXNMYWJlbENvbnRhaW5lciBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTGVnZW5kTGFiZWw6IGZ1bmN0aW9uKHBhcmFtcywgc2VyaWVzTGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgcG9zaXRpb25zID0gcGFyYW1zLnBvc2l0aW9ucyxcbiAgICAgICAgICAgIGh0bWxzO1xuXG4gICAgICAgIGh0bWxzID0gdHVpLnV0aWwubWFwKHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRMZWdlbmRMYWJlbHMoKSwgZnVuY3Rpb24obGVnZW5kLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGh0bWwgPSAnJyxcbiAgICAgICAgICAgICAgICBsYWJlbCwgcG9zaXRpb247XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBzZWxmLl9nZXRTZXJpZXNMYWJlbCh7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZDogbGVnZW5kLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogc2VsZi5kYXRhUHJvY2Vzc29yLmdldEZpcnN0SXRlbUxhYmVsKHNlbGYuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yOiBwYXJhbXMuc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwYXJhbXMuZnVuY01vdmVUb1Bvc2l0aW9uKHBvc2l0aW9uc1tpbmRleF0sIGxhYmVsKTtcbiAgICAgICAgICAgICAgICBodG1sID0gc2VsZi5fbWFrZVNlcmllc0xhYmVsSHRtbChwb3NpdGlvbiwgbGFiZWwsIGluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXJpZXNMYWJlbENvbnRhaW5lci5pbm5lckhUTUwgPSBodG1scy5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0byBjZW50ZXIgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIGxhYmVsXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gY2VudGVyIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW92ZVRvQ2VudGVyUG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uLCBsYWJlbCkge1xuICAgICAgICB2YXIgbGVmdCA9IHBvc2l0aW9uLmxlZnQgLSAocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGFiZWwsIHRoaXMudGhlbWUubGFiZWwpIC8gMiksXG4gICAgICAgICAgICB0b3AgPSBwb3NpdGlvbi50b3AgLSAocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSAvIDIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgdG9wOiB0b3BcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGljayBwb2lzdGlvbnMgZnJvbSBzZWN0b3IgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25UeXBlIHBvc2l0aW9uIHR5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHBvc2l0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BpY2tQb3NpdGlvbnNGcm9tU2VjdG9yRGF0YTogZnVuY3Rpb24ocG9zaXRpb25UeXBlKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodGhpcy5zZXJpZXNEYXRhLnNlY3RvckRhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0dW0ucGVyY2VudFZhbHVlID8gZGF0dW1bcG9zaXRpb25UeXBlXSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgY2VudGVyIGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzZXJpZXNMYWJlbENvbnRhaW5lciBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2VudGVyTGVnZW5kOiBmdW5jdGlvbihzZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICB0aGlzLl9yZW5kZXJMZWdlbmRMYWJlbCh7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IHRoaXMuX3BpY2tQb3NpdGlvbnNGcm9tU2VjdG9yRGF0YSgnY2VudGVyUG9zaXRpb24nKSxcbiAgICAgICAgICAgIGZ1bmNNb3ZlVG9Qb3NpdGlvbjogdHVpLnV0aWwuYmluZCh0aGlzLl9tb3ZlVG9DZW50ZXJQb3NpdGlvbiwgdGhpcyksXG4gICAgICAgICAgICBzZXBhcmF0b3I6ICc8YnI+J1xuICAgICAgICB9LCBzZXJpZXNMYWJlbENvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBlbmQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNlbnRlckxlZnQgY2VudGVyIGxlZnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBwb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkRW5kUG9zaXRpb246IGZ1bmN0aW9uKGNlbnRlckxlZnQsIHBvc2l0aW9ucykge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkocG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIGVuZDtcblxuICAgICAgICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW5kID0gdHVpLnV0aWwuZXh0ZW5kKHt9LCBwb3NpdGlvbi5taWRkbGUpO1xuICAgICAgICAgICAgaWYgKGVuZC5sZWZ0IDwgY2VudGVyTGVmdCkge1xuICAgICAgICAgICAgICAgIGVuZC5sZWZ0IC09IGNoYXJ0Q29uc3QuU0VSSUVTX09VVEVSX0xBQkVMX1BBRERJTkc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZC5sZWZ0ICs9IGNoYXJ0Q29uc3QuU0VSSUVTX09VVEVSX0xBQkVMX1BBRERJTkc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSBlbmQ7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIG91dGVyIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXJMZWZ0IGNlbnRlciBsZWZ0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIGxhYmVsXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gb3V0ZXIgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3ZlVG9PdXRlclBvc2l0aW9uOiBmdW5jdGlvbihjZW50ZXJMZWZ0LCBwb3NpdGlvbiwgbGFiZWwpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uRW5kID0gcG9zaXRpb24uZW5kLFxuICAgICAgICAgICAgbGVmdCA9IHBvc2l0aW9uRW5kLmxlZnQsXG4gICAgICAgICAgICB0b3AgPSBwb3NpdGlvbkVuZC50b3AgLSAocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSAvIDIpO1xuXG4gICAgICAgIGlmIChsZWZ0IDwgY2VudGVyTGVmdCkge1xuICAgICAgICAgICAgbGVmdCAtPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChsYWJlbCwgdGhpcy50aGVtZS5sYWJlbCkgKyBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCArPSBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgb3V0ZXIgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNlcmllc0xhYmVsQ29udGFpbmVyIHNlcmllcyBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJPdXRlckxlZ2VuZDogZnVuY3Rpb24oc2VyaWVzTGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgdmFyIGNlbnRlckxlZnQgPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignY2hhcnQnKS53aWR0aCAvIDIsXG4gICAgICAgICAgICBvdXRlclBvc2l0aW9ucyA9IHRoaXMuX3BpY2tQb3NpdGlvbnNGcm9tU2VjdG9yRGF0YSgnb3V0ZXJQb3NpdGlvbicpLFxuICAgICAgICAgICAgZmlsdGVyZWRQb3NpdGlvbnMgPSB0dWkudXRpbC5maWx0ZXIob3V0ZXJQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkRW5kUG9zaXRpb24oY2VudGVyTGVmdCwgZmlsdGVyZWRQb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLl9yZW5kZXJMZWdlbmRMYWJlbCh7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IG91dGVyUG9zaXRpb25zLFxuICAgICAgICAgICAgZnVuY01vdmVUb1Bvc2l0aW9uOiB0dWkudXRpbC5iaW5kKHRoaXMuX21vdmVUb091dGVyUG9zaXRpb24sIHRoaXMsIGNlbnRlckxlZnQpLFxuICAgICAgICAgICAgc2VwYXJhdG9yOiAnOiZuYnNwOydcbiAgICAgICAgfSwgc2VyaWVzTGFiZWxDb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5yZW5kZXJMZWdlbmRMaW5lcyhmaWx0ZXJlZFBvc2l0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2VyaWVzTGFiZWxDb250YWluZXIgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0xhYmVsOiBmdW5jdGlvbihzZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICB2YXIgbGVnZW5kQWxpZ24gPSB0aGlzLmxlZ2VuZEFsaWduO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNMZWdlbmRBbGlnbk91dGVyKGxlZ2VuZEFsaWduKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyT3V0ZXJMZWdlbmQoc2VyaWVzTGFiZWxDb250YWluZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ2VudGVyTGVnZW5kKHNlcmllc0xhYmVsQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIHNob3dpbmcgYWJvdXQgc2VyaWVzIGxhYmVsIGFyZWEuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgYW5pbWF0ZVNob3dpbmdBYm91dFNlcmllc0xhYmVsQXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5hbmltYXRlTGVnZW5kTGluZXMoKTtcbiAgICAgICAgU2VyaWVzLnByb3RvdHlwZS5hbmltYXRlU2hvd2luZ0Fib3V0U2VyaWVzTGFiZWxBcmVhLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmUgbGVnZW5kIGxpbmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21vdmVMZWdlbmRMaW5lczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjZW50ZXJMZWZ0ID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2NoYXJ0Jykud2lkdGggLyAyLFxuICAgICAgICAgICAgb3V0ZXJQb3NpdGlvbnMgPSB0aGlzLl9waWNrUG9zaXRpb25zRnJvbVNlY3RvckRhdGEoJ291dGVyUG9zaXRpb24nKSxcbiAgICAgICAgICAgIGZpbHRlcmVkUG9zaXRpb25zID0gdHVpLnV0aWwuZmlsdGVyKG91dGVyUG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZEVuZFBvc2l0aW9uKGNlbnRlckxlZnQsIGZpbHRlcmVkUG9zaXRpb25zKTtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLm1vdmVMZWdlbmRMaW5lcyhmaWx0ZXJlZFBvc2l0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGNsaWNrIHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKi9cbiAgICBvbkNsaWNrU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9leGVjdXRlR3JhcGhSZW5kZXJlcihwb3NpdGlvbiwgJ2NsaWNrU2VyaWVzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdmUgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIG9uTW92ZVNlcmllczogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fZXhlY3V0ZUdyYXBoUmVuZGVyZXIocG9zaXRpb24sICdtb3ZlTW91c2VPblNlcmllcycpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oUGllQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBpZUNoYXJ0U2VyaWVzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlcmllcyBiYXNlIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNlcmllc1RlbXBsYXRlID0gcmVxdWlyZSgnLi9zZXJpZXNUZW1wbGF0ZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBwbHVnaW5GYWN0b3J5ID0gcmVxdWlyZSgnLi4vZmFjdG9yaWVzL3BsdWdpbkZhY3RvcnknKTtcblxudmFyIFNlcmllcyA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgU2VyaWVzLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogU2VyaWVzIGJhc2UgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIFNlcmllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIHNlcmllcyBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbGliVHlwZSA9IHBhcmFtcy5saWJUeXBlIHx8IGNoYXJ0Q29uc3QuREVGQVVMVF9QTFVHSU47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYXJ0IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gcGFyYW1zLmNoYXJ0VHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcG9uZW50VHlwZSA9IHBhcmFtcy5jb21wb25lbnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIHByb2Nlc3NvclxuICAgICAgICAgKiBAdHlwZSB7RGF0YVByb2Nlc3Nvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IHBhcmFtcy5kYXRhUHJvY2Vzc29yO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZHMgbWFrZXJcbiAgICAgICAgICogQHR5cGUge0JvdW5kc01ha2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlciA9IHBhcmFtcy5ib3VuZHNNYWtlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlciBldmVudCBsaXN0ZW5lclxuICAgICAgICAgKiBAdHlwZSB7VXNlckV2ZW50TGlzdGVuZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZXJFdmVudCA9IHBhcmFtcy51c2VyRXZlbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVtZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmdUaGVtZSA9IHRoaXMudGhlbWUgPSBwYXJhbXMudGhlbWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgY2hhcnQgaGFzIGF4ZXMgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNBeGVzID0gISFwYXJhbXMuaGFzQXhlcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGggcmVuZGVyZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlciA9IHBsdWdpbkZhY3RvcnkuZ2V0KGxpYlR5cGUsIHBhcmFtcy5jaGFydFR5cGUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXJpZXMgdmlldyBjbGFzc05hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jaGFydC1zZXJpZXMtYXJlYSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlcmllcyBjb250YWluZXJcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJpZXNDb250YWluZXIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXJpZXMgbGFiZWwgY29udGFpbmVyXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXJpZXMgZGF0YVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcmllc0RhdGEgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0ZWQgbGVnZW5kIGluZGV4XG4gICAgICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzZXJpZXNEYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VyaWVzIGRhdGFcbiAgICAgKi9cbiAgICBnZXRTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9yZW5kZXJTZXJpZXNMYWJlbDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzZXJpZXMgbGFiZWwgYXJlYVxuICAgICAqIEBwYXJhbSB7P0hUTUxFbGVtZW50fSBzZXJpZXNMYWJlbENvbnRhaW5lciBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU2VyaWVzTGFiZWxBcmVhOiBmdW5jdGlvbihzZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICBpZiAoIXNlcmllc0xhYmVsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBzZXJpZXNMYWJlbENvbnRhaW5lciA9IGRvbS5jcmVhdGUoJ2RpdicsICd0dWktY2hhcnQtc2VyaWVzLWxhYmVsLWFyZWEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0xhYmVsKHNlcmllc0xhYmVsQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIHNlcmllc0xhYmVsQ29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2VyaWVzQ29udGFpbmVyIHNlcmllcyBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jUmVuZGVyR3JhcGggZnVuY3Rpb24gZm9yIGdyYXBoIHJlbmRlcmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0FyZWE6IGZ1bmN0aW9uKHNlcmllc0NvbnRhaW5lciwgZGF0YSwgZnVuY1JlbmRlckdyYXBoKSB7XG4gICAgICAgIHZhciBleHBhbnNpb25Cb3VuZCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0Qm91bmQoJ2V4dGVuZGVkU2VyaWVzJyksXG4gICAgICAgICAgICBzZXJpZXNEYXRhLCBzZXJpZXNMYWJlbENvbnRhaW5lcjtcblxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgICAgIHRoaXMuc2VyaWVzRGF0YSA9IHNlcmllc0RhdGEgPSB0aGlzLl9tYWtlU2VyaWVzRGF0YSgpO1xuXG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKHNlcmllc0NvbnRhaW5lciwgZXhwYW5zaW9uQm91bmQuZGltZW5zaW9uKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyUG9zaXRpb24oc2VyaWVzQ29udGFpbmVyLCBleHBhbnNpb25Cb3VuZC5wb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGZ1bmNSZW5kZXJHcmFwaCkge1xuICAgICAgICAgICAgZnVuY1JlbmRlckdyYXBoKGV4cGFuc2lvbkJvdW5kLmRpbWVuc2lvbiwgc2VyaWVzRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpZXNMYWJlbENvbnRhaW5lciA9IHRoaXMuX3JlbmRlclNlcmllc0xhYmVsQXJlYSh0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyKTtcblxuICAgICAgICBpZiAoIXRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIgPSBzZXJpZXNMYWJlbENvbnRhaW5lcjtcbiAgICAgICAgICAgIGRvbS5hcHBlbmQoc2VyaWVzQ29udGFpbmVyLCBzZXJpZXNMYWJlbENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwYXJhbWV0ZXJzIGZvciBncmFwaCByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc0RhdGEgc2VyaWVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJhbWV0ZXJzIGZvciBncmFwaCByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUGFyYW1zRm9yR3JhcGhSZW5kZXJpbmc6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjogZGltZW5zaW9uLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zXG4gICAgICAgIH0sIHNlcmllc0RhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgcmFwaGFlbCBncmFwaC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckdyYXBoOiBmdW5jdGlvbihkaW1lbnNpb24sIHNlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuX21ha2VQYXJhbXNGb3JHcmFwaFJlbmRlcmluZyhkaW1lbnNpb24sIHNlcmllc0RhdGEpO1xuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIucmVuZGVyKHRoaXMuc2VyaWVzQ29udGFpbmVyLCBwYXJhbXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHNlcmllcyBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKTtcblxuICAgICAgICB0aGlzLnNlcmllc0NvbnRhaW5lciA9IGVsO1xuICAgICAgICB0aGlzLl9yZW5kZXJTZXJpZXNBcmVhKGVsLCBkYXRhLCB0dWkudXRpbC5iaW5kKHRoaXMuX3JlbmRlckdyYXBoLCB0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGxlZ2VuZCB0aGVtZVxuICAgICAqIEBwYXJhbSB7P0FycmF5Ljw/Ym9vbGVhbj59IGNoZWNrZWRMZWdlbmRzIGNoZWNrZWQgbGVnZW5kc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHVwZGF0ZWQgdGhlbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVUaGVtZTogZnVuY3Rpb24odGhlbWUsIGNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgIHZhciBjbG9uZVRoZW1lO1xuXG4gICAgICAgIGlmICghY2hlY2tlZExlZ2VuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhlbWU7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9uZVRoZW1lID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGVtZSkpO1xuICAgICAgICBjbG9uZVRoZW1lLmNvbG9ycyA9IHR1aS51dGlsLmZpbHRlcihjbG9uZVRoZW1lLmNvbG9ycywgZnVuY3Rpb24oY29sb3IsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tlZExlZ2VuZHNbaW5kZXhdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2xvbmVUaGVtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVyZW5kZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKi9cbiAgICByZXJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5ncmFwaFJlbmRlcmVyLmNsZWFyKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VyaWVzQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXJpZXNEYXRhID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRHcm91cENvdW50KHRoaXMuY2hhcnRUeXBlKSkge1xuICAgICAgICAgICAgdGhpcy50aGVtZSA9IHRoaXMuX3VwZGF0ZVRoZW1lKHRoaXMub3JnVGhlbWUsIGRhdGEuY2hlY2tlZExlZ2VuZHMpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyU2VyaWVzQXJlYSh0aGlzLnNlcmllc0NvbnRhaW5lciwgZGF0YSwgdHVpLnV0aWwuYmluZCh0aGlzLl9yZW5kZXJHcmFwaCwgdGhpcykpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWxTaG93ZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMubGFiZWxTaG93ZXIudGltZXJJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgcmFwaGFlbCBncmFwaC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2l6ZUdyYXBoOiBmdW5jdGlvbihkaW1lbnNpb24sIHNlcmllc0RhdGEpIHtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlc2l6ZSh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgZGltZW5zaW9uOiBkaW1lbnNpb25cbiAgICAgICAgfSwgc2VyaWVzRGF0YSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiB9fSBib3VuZCBzZXJpZXMgYm91bmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyU2VyaWVzQXJlYSh0aGlzLnNlcmllc0NvbnRhaW5lciwgZGF0YSwgdHVpLnV0aWwuYmluZCh0aGlzLl9yZXNpemVHcmFwaCwgdGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYm91bmRzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgc2VyaWVzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gcG9zaXRpb24gc2VyaWVzIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyUG9zaXRpb246IGZ1bmN0aW9uKGVsLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgaGlkZGVuV2lkdGggPSByZW5kZXJVdGlsLmlzT2xkQnJvd3NlcigpID8gMCA6IDA7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihlbCwge1xuICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgLSAoaGlkZGVuV2lkdGggKiAyKSxcbiAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgLSBoaWRkZW5XaWR0aFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxpbWl0IGRpc3RhbmNlIGZyb20gemVybyBwb2ludC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBjaGFydCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgbGltaXRcbiAgICAgKiBAcmV0dXJucyB7e3RvTWF4OiBudW1iZXIsIHRvTWluOiBudW1iZXJ9fSBwaXhlbCBkaXN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbWl0RGlzdGFuY2VGcm9tWmVyb1BvaW50OiBmdW5jdGlvbihzaXplLCBsaW1pdCkge1xuICAgICAgICB2YXIgbWluID0gbGltaXQubWluLFxuICAgICAgICAgICAgbWF4ID0gbGltaXQubWF4LFxuICAgICAgICAgICAgZGlzdGFuY2UgPSBtYXggLSBtaW4sXG4gICAgICAgICAgICB0b01heCA9IDAsXG4gICAgICAgICAgICB0b01pbiA9IDA7XG5cbiAgICAgICAgaWYgKG1pbiA8PSAwICYmIG1heCA+PSAwKSB7XG4gICAgICAgICAgICB0b01heCA9IChkaXN0YW5jZSArIG1pbikgLyBkaXN0YW5jZSAqIHNpemU7XG4gICAgICAgICAgICB0b01pbiA9IChkaXN0YW5jZSAtIG1heCkgLyBkaXN0YW5jZSAqIHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9NYXg6IHRvTWF4LFxuICAgICAgICAgICAgdG9NaW46IHRvTWluXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbGFiZWwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRhcmdldCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gbGFiZWwgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRMYWJlbEVsZW1lbnQ6IGZ1bmN0aW9uKGVsVGFyZ2V0KSB7XG4gICAgICAgIHZhciBlbExhYmVsID0gbnVsbDtcblxuICAgICAgICBpZiAoZG9tLmhhc0NsYXNzKGVsVGFyZ2V0LCBjaGFydENvbnN0LkNMQVNTX05BTUVfU0VSSUVTX0xBQkVMKSkge1xuICAgICAgICAgICAgZWxMYWJlbCA9IGVsVGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxMYWJlbCA9IGRvbS5maW5kUGFyZW50QnlDbGFzcyhlbFRhcmdldCwgY2hhcnRDb25zdC5DTEFTU19OQU1FX1NFUklFU19MQUJFTCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxMYWJlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBzaG93QW5pbWF0aW9uIGZ1bmN0aW9uIG9mIGdyYXBoUmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gZGF0YSBkYXRhXG4gICAgICovXG4gICAgb25TaG93QW5pbWF0aW9uOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaFJlbmRlcmVyLnNob3dBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd0FuaW1hdGlvbihkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBoaWRlQW5pbWF0aW9uIGZ1bmN0aW9uIG9mIGdyYXBoUmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gZGF0YSBkYXRhXG4gICAgICovXG4gICAgb25IaWRlQW5pbWF0aW9uOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaFJlbmRlcmVyLmhpZGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuaGlkZUFuaW1hdGlvbihkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBzaG93R3JvdXBBbmltYXRpb24gZnVuY3Rpb24gb2YgZ3JhcGhSZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBvblNob3dHcm91cEFuaW1hdGlvbjogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd0dyb3VwQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnNob3dHcm91cEFuaW1hdGlvbihpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgaGlkZUdyb3VwQW5pbWF0aW9uIGZ1bmN0aW9uIG9mIGdyYXBoUmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICovXG4gICAgb25IaWRlR3JvdXBBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaFJlbmRlcmVyLmhpZGVHcm91cEFuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5oaWRlR3JvdXBBbmltYXRpb24oaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBhbmltYXRlQ29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhSZW5kZXJlci5hbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuYW5pbWF0ZSh0dWkudXRpbC5iaW5kKHRoaXMuYW5pbWF0ZVNob3dpbmdBYm91dFNlcmllc0xhYmVsQXJlYSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugb3BhY2l0eSBjc3NUZXh0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjc3NUZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU9wYWNpdHlDc3NUZXh0OiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmdW5jTWFrZU9wYWNpdHlDc3NUZXh0O1xuICAgICAgICBpZiAocmVuZGVyVXRpbC5pc09sZEJyb3dzZXIoKSkge1xuICAgICAgICAgICAgZnVuY01ha2VPcGFjaXR5Q3NzVGV4dCA9IGZ1bmN0aW9uKG9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJztmaWx0ZXI6IGFscGhhKG9wYWNpdHk9JyArIChvcGFjaXR5ICogY2hhcnRDb25zdC5PTERfQlJPV1NFUl9PUEFDSVRZXzEwMCkgKyAnKSc7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVuY01ha2VPcGFjaXR5Q3NzVGV4dCA9IGZ1bmN0aW9uKF9vcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc7b3BhY2l0eTogJyArIF9vcGFjaXR5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY01ha2VPcGFjaXR5Q3NzVGV4dDtcbiAgICB9KSgpLFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBodG1sIGFib3V0IHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gLSBwb3NpdGlvbiBmb3IgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0gbGFiZWwgb2YgU2VyaWVzSXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIGxlZ2VuZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc0xhYmVsSHRtbDogZnVuY3Rpb24ocG9zaXRpb24sIGxhYmVsLCBpbmRleCkge1xuICAgICAgICB2YXIgY3NzT2JqID0gdHVpLnV0aWwuZXh0ZW5kKHBvc2l0aW9uLCB0aGlzLnRoZW1lLmxhYmVsKTtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzTnVsbCh0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXgpICYmICh0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXggIT09IGluZGV4KSkge1xuICAgICAgICAgICAgY3NzT2JqLm9wYWNpdHkgPSB0aGlzLl9tYWtlT3BhY2l0eUNzc1RleHQoY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfT1BBQ0lUWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjc3NPYmoub3BhY2l0eSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpZXNUZW1wbGF0ZS50cGxTZXJpZXNMYWJlbCh7XG4gICAgICAgICAgICBjc3NUZXh0OiBzZXJpZXNUZW1wbGF0ZS50cGxDc3NUZXh0KGNzc09iaiksXG4gICAgICAgICAgICBsYWJlbDogbGFiZWxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgc2hvd2luZyBhYm91dCBzZXJpZXMgbGFiZWwgYXJlYS5cbiAgICAgKi9cbiAgICBhbmltYXRlU2hvd2luZ0Fib3V0U2VyaWVzTGFiZWxBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICgoIXRoaXMub3B0aW9ucy5zaG93TGFiZWwgJiYgIXRoaXMubGVnZW5kQWxpZ24pIHx8ICF0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ3Nob3cnKTtcblxuICAgICAgICBpZiAocmVuZGVyVXRpbC5pc0lFNygpKSB7XG4gICAgICAgICAgICB0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyLnN0eWxlLmZpbHRlciA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYWJlbFNob3dlciA9IG5ldyB0dWkuY29tcG9uZW50LkVmZmVjdHMuRmFkZSh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMzAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubGFiZWxTaG93ZXIuYWN0aW9uKHtcbiAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICBlbmQ6IDEsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHNlbGYubGFiZWxTaG93ZXIudGltZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmxhYmVsU2hvd2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZXhwb3J0YXRpb24gZGF0YSBmb3Igc2VyaWVzIHR5cGUgdXNlckV2ZW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhXG4gICAgICogQHJldHVybnMge3tjaGFydFR5cGU6IHN0cmluZywgbGVnZW5kOiBzdHJpbmcsIGxlZ2VuZEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBleHBvcnQgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VFeHBvcnRhdGlvblNlcmllc0RhdGE6IGZ1bmN0aW9uKHNlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIGxlZ2VuZEluZGV4ID0gc2VyaWVzRGF0YS5pbmRleGVzLmluZGV4LFxuICAgICAgICAgICAgbGVnZW5kRGF0YSA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRMZWdlbmRJdGVtKGxlZ2VuZEluZGV4KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhcnRUeXBlOiBsZWdlbmREYXRhLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIGxlZ2VuZDogbGVnZW5kRGF0YS5sYWJlbCxcbiAgICAgICAgICAgIGxlZ2VuZEluZGV4OiBsZWdlbmRJbmRleCxcbiAgICAgICAgICAgIGluZGV4OiBzZXJpZXNEYXRhLmluZGV4ZXMuZ3JvdXBJbmRleFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGdyYXBoIHJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jTmFtZSBmdW5jdGlvbiBuYW1lXG4gICAgICogQHJldHVybnMgeyp9IHJlc3VsdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9leGVjdXRlR3JhcGhSZW5kZXJlcjogZnVuY3Rpb24ocG9zaXRpb24sIGZ1bmNOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcENvbnRhaW5lcicpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xhYmVsKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3ModGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ3Nob3cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZ3JhcGhSZW5kZXJlcltmdW5jTmFtZV0ocG9zaXRpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xhYmVsKSB7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ3Nob3cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd1Rvb2x0aXBDb250YWluZXInKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIHNlbGVjdFNlcmllcyBjYWxsYmFjayBvZiB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc0RhdGEgc2VyaWVzIGRhdGFcbiAgICAgKi9cbiAgICBvblNlbGVjdFNlcmllczogZnVuY3Rpb24oc2VyaWVzRGF0YSkge1xuICAgICAgICB0aGlzLnVzZXJFdmVudC5maXJlKCdzZWxlY3RTZXJpZXMnLCB0aGlzLl9tYWtlRXhwb3J0YXRpb25TZXJpZXNEYXRhKHNlcmllc0RhdGEpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zZWxlY3RTZXJpZXMoc2VyaWVzRGF0YS5pbmRleGVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIHVuc2VsZWN0U2VyaWVzIGNhbGxiYWNrIG9mIHVzZXJFdmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YS5cbiAgICAgKi9cbiAgICBvblVuc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihzZXJpZXNEYXRhKSB7XG4gICAgICAgIHRoaXMudXNlckV2ZW50LmZpcmUoJ3Vuc2VsZWN0U2VyaWVzJywgdGhpcy5fbWFrZUV4cG9ydGF0aW9uU2VyaWVzRGF0YShzZXJpZXNEYXRhKSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIudW5zZWxlY3RTZXJpZXMoc2VyaWVzRGF0YS5pbmRleGVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKk9uIHNlbGVjdCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBsZWdlbmRJbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKi9cbiAgICBvblNlbGVjdExlZ2VuZDogZnVuY3Rpb24oY2hhcnRUeXBlLCBsZWdlbmRJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5jaGFydFR5cGUgIT09IGNoYXJ0VHlwZSAmJiAhdHVpLnV0aWwuaXNOdWxsKGxlZ2VuZEluZGV4KSkge1xuICAgICAgICAgICAgbGVnZW5kSW5kZXggPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCA9IGxlZ2VuZEluZGV4O1xuXG4gICAgICAgIGlmICh0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzRGF0YU1vZGVsKHRoaXMuY2hhcnRUeXBlKS5nZXRHcm91cENvdW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0FyZWEodGhpcy5zZXJpZXNDb250YWluZXIsIHRoaXMuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2VsZWN0TGVnZW5kKGxlZ2VuZEluZGV4KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGxhYmVsLlxuICAgICAqL1xuICAgIHNob3dMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaG93TGFiZWwgPSB0cnVlO1xuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ3Nob3cgb3BhY2l0eScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGxhYmVsLlxuICAgICAqL1xuICAgIGhpZGVMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaG93TGFiZWwgPSBmYWxzZTtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIsICdzaG93Jyk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VyaWVzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgaXMgdGVtcGxhdGVzIG9mIHNlcmllcy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRlbXBsYXRlTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RlbXBsYXRlTWFrZXInKTtcblxudmFyIGh0bWxzID0ge1xuICAgIEhUTUxfU0VSSUVTX0xBQkVMOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1zZXJpZXMtbGFiZWxcIiBzdHlsZT1cInt7IGNzc1RleHQgfX1cIj57eyBsYWJlbCB9fTwvZGl2PicsXG4gICAgVEVYVF9DU1NfVEVYVDogJ2xlZnQ6e3sgbGVmdCB9fXB4O3RvcDp7eyB0b3AgfX1weDtmb250LWZhbWlseTp7eyBmb250RmFtaWx5IH19OycgK1xuICAgICAgICAnZm9udC1zaXplOnt7IGZvbnRTaXplIH19cHh7e29wYWNpdHl9fScsXG4gICAgSFRNTF9aT09NX0JVVFRPTlM6ICc8YSBjbGFzcz1cInR1aS1jaGFydC16b29tLWJ0blwiIGhyZWY9XCIjXCIgZGF0YS1tYWduPVwiMlwiPicgK1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJob3Jpem9udGFsLWxpbmVcIj48L2Rpdj48ZGl2IGNsYXNzPVwidmVydGljYWwtbGluZVwiPjwvZGl2PjwvYT4nICtcbiAgICAgICAgJzxhIGNsYXNzPVwidHVpLWNoYXJ0LXpvb20tYnRuXCIgaHJlZj1cIiNcIiBkYXRhLW1hZ249XCIwLjVcIj48ZGl2IGNsYXNzPVwiaG9yaXpvbnRhbC1saW5lXCI+PC9kaXY+PC9hPidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRwbFNlcmllc0xhYmVsOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfU0VSSUVTX0xBQkVMKSxcbiAgICB0cGxDc3NUZXh0OiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLlRFWFRfQ1NTX1RFWFQpLFxuICAgIFpPT01fQlVUVE9OUzogaHRtbHMuSFRNTF9aT09NX0JVVFRPTlNcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgWm9vbSBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzZXJpZXNUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vc2VyaWVzVGVtcGxhdGUnKSxcbiAgICBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyksXG4gICAgZXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZXZlbnRMaXN0ZW5lcicpO1xuXG52YXIgWm9vbSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgWm9vbS5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogWm9vbSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0JvdW5kc01ha2VyfSBwYXJhbXMuYm91bmRzTWFrZXIgYm91bmRzIG1ha2VyXG4gICAgICogQGNvbnN0cnVjdHMgWm9vbVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktY2hhcnQtem9vbS1hcmVhJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmRzIG1ha2VyXG4gICAgICAgICAqIEB0eXBlIHtCb3VuZHNNYWtlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBwYXJhbXMuYm91bmRzTWFrZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hZ25pZmljYXRpb24uXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hZ24gPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFja2VkIHdoZWVsRGVsdGEuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrZWRXaGVlbERlbHRhID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyLlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gem9vbSBjb250YWluZXJcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpO1xuXG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgKz0gc2VyaWVzVGVtcGxhdGUuWk9PTV9CVVRUT05TO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGNvbnRhaW5lciwgdGhpcy5ib3VuZHNNYWtlci5nZXRQb3NpdGlvbignc2VyaWVzJykpO1xuICAgICAgICB0aGlzLl9hdHRhY2hFdmVudChjb250YWluZXIpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYnV0dG9uIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IHRhcmdldCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHs/SFRNTEVsZW1lbnR9IGJ1dHRvbiBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZEJ0bkVsZW1lbnQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICB2YXIgYnRuQ2xhc3NOYW1lID0gJ3R1aS1jaGFydC16b29tLWJ0bicsXG4gICAgICAgICAgICBidG5FbGVtZW50ID0gdGFyZ2V0O1xuXG4gICAgICAgIGlmICghZG9tLmhhc0NsYXNzKHRhcmdldCwgYnRuQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgYnRuRWxlbWVudCA9IGRvbS5maW5kUGFyZW50QnlDbGFzcyh0YXJnZXQsIGJ0bkNsYXNzTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnRuRWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYWduIG1hZ25pZmljYXRpb25cbiAgICAgKiBAcGFyYW0gez97bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfem9vbTogZnVuY3Rpb24obWFnbiwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGNoYW5nZWRNYWduID0gTWF0aC5taW4oTWF0aC5tYXgoMSwgdGhpcy5tYWduICogbWFnbiksIGNoYXJ0Q29uc3QuTUFYX1pPT01fTUFHTik7XG5cbiAgICAgICAgaWYgKGNoYW5nZWRNYWduICE9PSB0aGlzLm1hZ24pIHtcbiAgICAgICAgICAgIHRoaXMubWFnbiA9IGNoYW5nZWRNYWduO1xuICAgICAgICAgICAgdGhpcy5maXJlKCd6b29tJywgdGhpcy5tYWduLCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2suXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICogQHJldHVybnMgez9ib29sZWFufSBwcmV2ZW50IGRlZmF1bHQgZm9yIGllXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxuICAgICAgICAgICAgYnRuRWxlbWVudCA9IHRoaXMuX2ZpbmRCdG5FbGVtZW50KHRhcmdldCksXG4gICAgICAgICAgICBtYWduO1xuXG4gICAgICAgIGlmIChidG5FbGVtZW50KSB7XG4gICAgICAgICAgICBtYWduID0gcGFyc2VGbG9hdChidG5FbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1tYWduJykpO1xuICAgICAgICAgICAgdGhpcy5fem9vbShtYWduKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBldmVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdHRhY2hFdmVudDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdjbGljaycsIHRhcmdldCwgdGhpcy5fb25DbGljaywgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBtYWduaWZpY2F0aW9uIGZyb20gd2hlZWxEZWx0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2hlZWxEZWx0YSB3aGVlbERlbHRhXG4gICAgICogQHJldHVybnMge251bWJlcn0gbWFnbmlmaWNhdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZU1hZ246IGZ1bmN0aW9uKHdoZWVsRGVsdGEpIHtcbiAgICAgICAgdmFyIHRpY2sgPSBwYXJzZUludCh3aGVlbERlbHRhIC8gY2hhcnRDb25zdC5XSEVFTF9USUNLLCAxMCksXG4gICAgICAgICAgICBtYWduO1xuXG4gICAgICAgIGlmICh0aWNrID4gMCkge1xuICAgICAgICAgICAgbWFnbiA9IE1hdGgucG93KDIsIHRpY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFnbiA9IE1hdGgucG93KDAuNSwgTWF0aC5hYnModGljaykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hZ247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIHdoZWVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aGVlbERlbHRhIHdoZWVsRGVsdGFcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKi9cbiAgICBvbldoZWVsOiBmdW5jdGlvbih3aGVlbERlbHRhLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgbWFnbjtcblxuICAgICAgICBpZiAoTWF0aC5hYnMod2hlZWxEZWx0YSkgPCBjaGFydENvbnN0LldIRUVMX1RJQ0spIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tlZFdoZWVsRGVsdGEgKz0gd2hlZWxEZWx0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tlZFdoZWVsRGVsdGEgPSB3aGVlbERlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuc3RhY2tlZFdoZWVsRGVsdGEpIDwgY2hhcnRDb25zdC5XSEVFTF9USUNLKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtYWduID0gdGhpcy5fY2FsY3VsYXRlTWFnbih0aGlzLnN0YWNrZWRXaGVlbERlbHRhKTtcblxuICAgICAgICB0aGlzLl96b29tKG1hZ24sIHBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLnN0YWNrZWRXaGVlbERlbHRhID0gdGhpcy5zdGFja2VkV2hlZWxEZWx0YSAlIGNoYXJ0Q29uc3QuV0hFRUxfVElDSztcbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFpvb20pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFpvb207XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBERUZBVUxUX0NPTE9SID0gJyMwMDAwMDAnLFxuICAgIERFRkFVTFRfQkFDS0dST1VORCA9ICcjZmZmZmZmJyxcbiAgICBFTVBUWSA9ICcnLFxuICAgIERFRkFVTFRfQVhJUyA9IHtcbiAgICAgICAgdGlja0NvbG9yOiBERUZBVUxUX0NPTE9SLFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgZm9udEZhbWlseTogRU1QVFksXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9DT0xPUlxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgZm9udEZhbWlseTogRU1QVFksXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9DT0xPUlxuICAgICAgICB9XG4gICAgfTtcblxudmFyIGRlZmF1bHRUaGVtZSA9IHtcbiAgICBjaGFydDoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBERUZBVUxUX0JBQ0tHUk9VTkQsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdWZXJkYW5hJ1xuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgICAgZm9udFNpemU6IDE4LFxuICAgICAgICBmb250RmFtaWx5OiBFTVBUWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfQ09MT1JcbiAgICB9LFxuICAgIHlBeGlzOiBERUZBVUxUX0FYSVMsXG4gICAgeEF4aXM6IERFRkFVTFRfQVhJUyxcbiAgICBwbG90OiB7XG4gICAgICAgIGxpbmVDb2xvcjogJyNkZGRkZGQnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmZmZmZidcbiAgICB9LFxuICAgIHNlcmllczoge1xuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgZm9udFNpemU6IDExLFxuICAgICAgICAgICAgZm9udEZhbWlseTogRU1QVFksXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9DT0xPUlxuICAgICAgICB9LFxuICAgICAgICBjb2xvcnM6IFsnI2FjNDE0MicsICcjZDI4NDQ1JywgJyNmNGJmNzUnLCAnIzkwYTk1OScsICcjNzViNWFhJywgJyM2YTlmYjUnLCAnI2FhNzU5ZicsICcjOGY1NTM2J10sXG4gICAgICAgIHNpbmdsZUNvbG9yczogW10sXG4gICAgICAgIGJvcmRlckNvbG9yOiBFTVBUWSxcbiAgICAgICAgc2VsZWN0aW9uQ29sb3I6IEVNUFRZLFxuICAgICAgICBzdGFydENvbG9yOiAnI0Y0RjRGNCcsXG4gICAgICAgIGVuZENvbG9yOiAnIzM0NTM5MScsXG4gICAgICAgIG92ZXJDb2xvcjogJyNGMEM5NTInXG4gICAgfSxcbiAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IEVNUFRZLFxuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfQ09MT1JcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdFRoZW1lO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEdyb3VwIHRvb2x0aXAgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9vbHRpcEJhc2UgPSByZXF1aXJlKCcuL3Rvb2x0aXBCYXNlJyksXG4gICAgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCA9IHJlcXVpcmUoJy4vZ3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCcpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBkZWZhdWx0VGhlbWUgPSByZXF1aXJlKCcuLi90aGVtZXMvZGVmYXVsdFRoZW1lJyksXG4gICAgdG9vbHRpcFRlbXBsYXRlID0gcmVxdWlyZSgnLi90b29sdGlwVGVtcGxhdGUnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIEdyb3VwVG9vbHRpcCBjb21wb25lbnQuXG4gKiBAY2xhc3MgR3JvdXBUb29sdGlwXG4gKi9cbnZhciBHcm91cFRvb2x0aXAgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhUb29sdGlwQmFzZSwgLyoqIEBsZW5kcyBHcm91cFRvb2x0aXAucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBHcm91cCB0b29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBHcm91cFRvb2x0aXBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7Qm91bmRzTWFrZXJ9IHBhcmFtcy5ib3VuZHNNYWtlciBib3VuZHMgbWFrZXJcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBUb29sdGlwQmFzZS5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBodG1sLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSBjYXRlZ29yeVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHt2YWx1ZTogc3RyaW5nLCBsZWdlbmQ6IHN0cmluZywgY2hhcnRUeXBlOiBzdHJpbmcsIHN1ZmZpeDogP3N0cmluZ30+fSBpdGVtcyBpdGVtcyBkYXRhXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdG9vbHRpcCBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBIdG1sOiBmdW5jdGlvbihjYXRlZ29yeSwgaXRlbXMpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gdG9vbHRpcFRlbXBsYXRlLnRwbEdyb3VwSXRlbSxcbiAgICAgICAgICAgIGNzc1RleHRUZW1wbGF0ZSA9IHRvb2x0aXBUZW1wbGF0ZS50cGxHcm91cENzc1RleHQsXG4gICAgICAgICAgICBjb2xvcnMgPSB0aGlzLl9tYWtlQ29sb3JzKHRoaXMudGhlbWUpLFxuICAgICAgICAgICAgaXRlbXNIdG1sID0gdHVpLnV0aWwubWFwKGl0ZW1zLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZSh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjc3NUZXh0OiBjc3NUZXh0VGVtcGxhdGUoe2NvbG9yOiBjb2xvcnNbaW5kZXhdfSlcbiAgICAgICAgICAgICAgICB9LCBpdGVtKSk7XG4gICAgICAgICAgICB9KS5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gdG9vbHRpcFRlbXBsYXRlLnRwbEdyb3VwKHtcbiAgICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yeSxcbiAgICAgICAgICAgIGl0ZW1zOiBpdGVtc0h0bWxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IGFsaWduIG9wdGlvbiBvZiB0b29sdGlwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldERlZmF1bHRUb29sdGlwUG9zaXRpb25PcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsaWduKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9HUk9VUF9BTElHTl9PUFRJT047XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9HUk9VUF9IT1JJWk9OVEFMX0FMSUdOX09QVElPTjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdG9vbHRpcCBjb21wb25lbnQuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWwgPSBUb29sdGlwQmFzZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyksXG4gICAgICAgICAgICBjaGFydERpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdjaGFydCcpLFxuICAgICAgICAgICAgYm91bmQgPSB0aGlzLmJvdW5kc01ha2VyLmdldEJvdW5kKCd0b29sdGlwJyk7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbk1vZGVsID0gbmV3IEdyb3VwVG9vbHRpcFBvc2l0aW9uTW9kZWwoY2hhcnREaW1lbnNpb24sIGJvdW5kLCB0aGlzLmlzVmVydGljYWwsIHRoaXMub3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXJlbmRlci5cbiAgICAgKiBAcGFyYW0ge3tjaGVja2VkTGVnZW5kczogQXJyYXkuPGJvb2xlYW4+fX0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIFRvb2x0aXBCYXNlLnByb3RvdHlwZS5yZXJlbmRlci5jYWxsKHRoaXMsIGRhdGEpO1xuXG4gICAgICAgIHRoaXMudGhlbWUgPSB0aGlzLl91cGRhdGVMZWdlbmRUaGVtZShkYXRhLmNoZWNrZWRMZWdlbmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGxlZ2VuZCB0aGVtZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdCB8IEFycmF5Ljxib29sZWFuPn1jaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKiBAcmV0dXJucyB7e2NvbG9yczogQXJyYXkuPHN0cmluZz59fSBsZWdlbmQgdGhlbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVMZWdlbmRUaGVtZTogZnVuY3Rpb24oY2hlY2tlZExlZ2VuZHMpIHtcbiAgICAgICAgdmFyIGNvbG9ycyA9IFtdO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0T3JpZ2luYWxMZWdlbmREYXRhKCksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBfY2hlY2tlZExlZ2VuZHMgPSBjaGVja2VkTGVnZW5kc1tpdGVtLmNoYXJ0VHlwZV0gfHwgY2hlY2tlZExlZ2VuZHM7XG4gICAgICAgICAgICBpZiAoX2NoZWNrZWRMZWdlbmRzW2l0ZW0uaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzLnB1c2goaXRlbS50aGVtZS5jb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2xvcnM6IGNvbG9yc1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvb2x0aXAgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59IHRvb2x0aXAgZGF0YVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzR3JvdXBzKCksIGZ1bmN0aW9uKHNlcmllc0dyb3VwLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogc2VsZi5kYXRhUHJvY2Vzc29yLmdldENhdGVnb3J5KGluZGV4KSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHNlcmllc0dyb3VwLnBsdWNrKCdsYWJlbCcpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjb2xvcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRvb2x0aXAgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IGNvbG9yc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDb2xvcnM6IGZ1bmN0aW9uKHRoZW1lKSB7XG4gICAgICAgIHZhciBjb2xvckluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlZ2VuZExhYmVscyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRMZWdlbmREYXRhKCksXG4gICAgICAgICAgICBkZWZhdWx0Q29sb3JzLCBjb2xvcnMsIHByZXZDaGFydFR5cGU7XG5cbiAgICAgICAgaWYgKHRoZW1lLmNvbG9ycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoZW1lLmNvbG9ycztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHRDb2xvcnMgPSBkZWZhdWx0VGhlbWUuc2VyaWVzLmNvbG9ycy5zbGljZSgwLCBsZWdlbmRMYWJlbHMubGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHR1aS51dGlsLnBsdWNrKGxlZ2VuZExhYmVscywgJ2NoYXJ0VHlwZScpLCBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBjb2xvcjtcbiAgICAgICAgICAgIGlmIChwcmV2Q2hhcnRUeXBlICE9PSBjaGFydFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSB0aGVtZVtjaGFydFR5cGVdID8gdGhlbWVbY2hhcnRUeXBlXS5jb2xvcnMgOiBkZWZhdWx0Q29sb3JzO1xuICAgICAgICAgICAgICAgIGNvbG9ySW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkNoYXJ0VHlwZSA9IGNoYXJ0VHlwZTtcbiAgICAgICAgICAgIGNvbG9yID0gY29sb3JzW2NvbG9ySW5kZXhdO1xuICAgICAgICAgICAgY29sb3JJbmRleCArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSByZW5kZXJpbmcgZGF0YSBhYm91dCBsZWdlbmQgaXRlbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSB2YWx1ZXMgdmFsdWVzXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7dmFsdWU6IHN0cmluZywgbGVnZW5kOiBzdHJpbmcsIGNoYXJ0VHlwZTogc3RyaW5nLCBzdWZmaXg6ID9zdHJpbmd9Pn0gbGVnZW5kIGl0ZW0gZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSXRlbVJlbmRlcmluZ0RhdGE6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YVByb2Nlc3NvciA9IHRoaXMuZGF0YVByb2Nlc3NvcixcbiAgICAgICAgICAgIHN1ZmZpeCA9IHRoaXMuc3VmZml4O1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsZWdlbmRMYWJlbCA9IGRhdGFQcm9jZXNzb3IuZ2V0TGVnZW5kSXRlbShpbmRleCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGxlZ2VuZDogbGVnZW5kTGFiZWwubGFiZWwsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBsZWdlbmRMYWJlbC5jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggZ3JvdXAgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0b29sdGlwIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlR3JvdXBUb29sdGlwSHRtbDogZnVuY3Rpb24oZ3JvdXBJbmRleCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YVtncm91cEluZGV4XSxcbiAgICAgICAgICAgIGl0ZW1zID0gdGhpcy5fbWFrZUl0ZW1SZW5kZXJpbmdEYXRhKGRhdGEudmFsdWVzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZUZ1bmMoZGF0YS5jYXRlZ29yeSwgaXRlbXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdG9vbHRpcCBzZWN0b3IgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHNlY3RvciBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0VG9vbHRpcFNlY3RvckVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JvdXBUb29sdGlwU2VjdG9yO1xuXG4gICAgICAgIGlmICghdGhpcy5ncm91cFRvb2x0aXBTZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBUb29sdGlwU2VjdG9yID0gZ3JvdXBUb29sdGlwU2VjdG9yID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1ncm91cC10b29sdGlwLXNlY3RvcicpO1xuICAgICAgICAgICAgZG9tLmFwcGVuZCh0aGlzLnRvb2x0aXBDb250YWluZXIsIGdyb3VwVG9vbHRpcFNlY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ncm91cFRvb2x0aXBTZWN0b3I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYm91bmQgYWJvdXQgdG9vbHRpcCBzZWN0b3Igb2YgdmVydGljYWwgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGhlaWdodFxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGluZSB3aGV0aGVyIGxpbmUgb3Igbm90XG4gICAgICogQHJldHVybnMge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19fSBib3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VWZXJ0aWNhbFRvb2x0aXBTZWN0b3JCb3VuZDogZnVuY3Rpb24oaGVpZ2h0LCByYW5nZSwgaXNMaW5lKSB7XG4gICAgICAgIHZhciB3aWR0aDtcblxuICAgICAgICBpZiAoaXNMaW5lKSB7XG4gICAgICAgICAgICB3aWR0aCA9IDE7XG4gICAgICAgICAgICBoZWlnaHQgKz0gNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpZHRoID0gcmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGltZW5zaW9uOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiByYW5nZS5zdGFydCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgICAgIHRvcDogY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZCBhYm91dCB0b29sdGlwIHNlY3RvciBvZiBob3Jpem9udGFsIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHdpZHRoXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOm51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHJldHVybnMge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19fSBib3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VIb3Jpem9udGFsVG9vbHRpcFNlY3RvckJvdW5kOiBmdW5jdGlvbih3aWR0aCwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSxcbiAgICAgICAgICAgICAgICB0b3A6IHJhbmdlLnN0YXJ0ICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZCBhYm91dCB0b29sdGlwIHNlY3Rvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB3aWR0aCBvciBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGluZSB3aGV0aGVyIGxpbmUgdHlwZSBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBTZWN0b3JCb3VuZDogZnVuY3Rpb24oc2l6ZSwgcmFuZ2UsIGlzVmVydGljYWwsIGlzTGluZSkge1xuICAgICAgICB2YXIgYm91bmQ7XG5cbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIGJvdW5kID0gdGhpcy5fbWFrZVZlcnRpY2FsVG9vbHRpcFNlY3RvckJvdW5kKHNpemUsIHJhbmdlLCBpc0xpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlSG9yaXpvbnRhbFRvb2x0aXBTZWN0b3JCb3VuZChzaXplLCByYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgdG9vbHRpcCBzZWN0b3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgd2lkdGggb3IgaGVpZ2h0XG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOm51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd1Rvb2x0aXBTZWN0b3I6IGZ1bmN0aW9uKHNpemUsIHJhbmdlLCBpc1ZlcnRpY2FsLCBpbmRleCkge1xuICAgICAgICB2YXIgZ3JvdXBUb29sdGlwU2VjdG9yID0gdGhpcy5fZ2V0VG9vbHRpcFNlY3RvckVsZW1lbnQoKSxcbiAgICAgICAgICAgIGlzTGluZSA9IChyYW5nZS5zdGFydCA9PT0gcmFuZ2UuZW5kKSxcbiAgICAgICAgICAgIGJvdW5kID0gdGhpcy5fbWFrZVRvb2x0aXBTZWN0b3JCb3VuZChzaXplLCByYW5nZSwgaXNWZXJ0aWNhbCwgaXNMaW5lKTtcblxuICAgICAgICBpZiAoaXNMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3Nob3dHcm91cFRvb2x0aXBMaW5lJywgYm91bmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oZ3JvdXBUb29sdGlwU2VjdG9yLCBib3VuZC5kaW1lbnNpb24pO1xuICAgICAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihncm91cFRvb2x0aXBTZWN0b3IsIGJvdW5kLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhncm91cFRvb2x0aXBTZWN0b3IsICdzaG93Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpcmUoJ3Nob3dHcm91cEFuaW1hdGlvbicsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSB0b29sdGlwIHNlY3Rvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlVG9vbHRpcFNlY3RvcjogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGdyb3VwVG9vbHRpcFNlY3RvciA9IHRoaXMuX2dldFRvb2x0aXBTZWN0b3JFbGVtZW50KCk7XG5cbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGdyb3VwVG9vbHRpcFNlY3RvciwgJ3Nob3cnKTtcbiAgICAgICAgdGhpcy5maXJlKCdoaWRlR3JvdXBBbmltYXRpb24nLCBpbmRleCk7XG4gICAgICAgIHRoaXMuZmlyZSgnaGlkZUdyb3VwVG9vbHRpcExpbmUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVG9vbHRpcCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3tpbmRleDogbnVtYmVyLCByYW5nZToge3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfSxcbiAgICAgKiAgICAgICAgICBzaXplOiBudW1iZXIsIGRpcmVjdGlvbjogc3RyaW5nLCBpc1ZlcnRpY2FsOiBib29sZWFuXG4gICAgICogICAgICAgIH19IHBhcmFtcyBjb29yZGluYXRlIGV2ZW50IHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcHJldlBvc2l0aW9uIHByZXYgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93VG9vbHRpcDogZnVuY3Rpb24oZWxUb29sdGlwLCBwYXJhbXMsIHByZXZQb3NpdGlvbikge1xuICAgICAgICB2YXIgZGltZW5zaW9uLCBwb3NpdGlvbjtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKHRoaXMucHJldkluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlR3JvdXBBbmltYXRpb24nLCB0aGlzLnByZXZJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbFRvb2x0aXAuaW5uZXJIVE1MID0gdGhpcy5fbWFrZUdyb3VwVG9vbHRpcEh0bWwocGFyYW1zLmluZGV4KTtcblxuICAgICAgICB0aGlzLl9maXJlQmVmb3JlU2hvd1Rvb2x0aXAocGFyYW1zLmluZGV4LCBwYXJhbXMucmFuZ2UpO1xuXG4gICAgICAgIGRvbS5hZGRDbGFzcyhlbFRvb2x0aXAsICdzaG93Jyk7XG5cbiAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBTZWN0b3IocGFyYW1zLnNpemUsIHBhcmFtcy5yYW5nZSwgcGFyYW1zLmlzVmVydGljYWwsIHBhcmFtcy5pbmRleCk7XG5cbiAgICAgICAgZGltZW5zaW9uID0gdGhpcy5nZXRUb29sdGlwRGltZW5zaW9uKGVsVG9vbHRpcCk7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbk1vZGVsLmNhbGN1bGF0ZVBvc2l0aW9uKGRpbWVuc2lvbiwgcGFyYW1zLnJhbmdlKTtcblxuICAgICAgICB0aGlzLl9tb3ZlVG9Qb3NpdGlvbihlbFRvb2x0aXAsIHBvc2l0aW9uLCBwcmV2UG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVBZnRlclNob3dUb29sdGlwKHBhcmFtcy5pbmRleCwgcGFyYW1zLnJhbmdlLCB7XG4gICAgICAgICAgICBlbGVtZW50OiBlbFRvb2x0aXAsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBwYXJhbXMuaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgYmVmb3JlU2hvd1Rvb2x0aXAgY2FsbGJhY2sgb2YgdXNlckV2ZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlQmVmb3JlU2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKGluZGV4LCByYW5nZSkge1xuICAgICAgICB0aGlzLnVzZXJFdmVudC5maXJlKCdiZWZvcmVTaG93VG9vbHRpcCcsIHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBhZnRlclNob3dUb29sdGlwIGNhbGxiYWNrIG9mIHVzZXJFdmVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFkZGl0aW9uUGFyYW1zIGFkZGl0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlQWZ0ZXJTaG93VG9vbHRpcDogZnVuY3Rpb24oaW5kZXgsIHJhbmdlLCBhZGRpdGlvblBhcmFtcykge1xuICAgICAgICB0aGlzLnVzZXJFdmVudC5maXJlKCdhZnRlclNob3dUb29sdGlwJywgdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgICB9LCBhZGRpdGlvblBhcmFtcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hpZGVUb29sdGlwOiBmdW5jdGlvbihlbFRvb2x0aXAsIGluZGV4KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByZXZJbmRleDtcbiAgICAgICAgdGhpcy5faGlkZVRvb2x0aXBTZWN0b3IoaW5kZXgpO1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoZWxUb29sdGlwLCAnc2hvdycpO1xuICAgICAgICBlbFRvb2x0aXAuc3R5bGUuY3NzVGV4dCA9ICcnO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwVG9vbHRpcDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBHcm91cFRvb2x0aXBQb3NpdGlvbk1vZGVsIGlzIHBvc2l0aW9uIG1vZGVsIGZvciBncm91cCB0b29sdGlwLi5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEdyb3VwVG9vbHRpcFBvc2l0aW9uTW9kZWwgaXMgcG9zaXRpb24gbW9kZWwgZm9yIGdyb3VwIHRvb2x0aXAuXG4gICAgICogQGNvbnN0cnVjdHMgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbFxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gY2hhcnREaW1lbnNpb24gY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYXJlYUJvdW5kIHRvb2x0aXAgYXJlYSBib3VuZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7e2FsaWduOiA/c3RyaW5nLCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gb3B0aW9ucyB0b29sdGlwIG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihjaGFydERpbWVuc2lvbiwgYXJlYUJvdW5kLCBpc1ZlcnRpY2FsLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCBkaW1lbnNpb25cbiAgICAgICAgICogQHR5cGUge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0RGltZW5zaW9uID0gY2hhcnREaW1lbnNpb247XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvb2x0aXAgYXJlYSBib3VuZFxuICAgICAgICAgKiBAdHlwZSB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFyZWFCb3VuZCA9IGFyZWFCb3VuZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVmVydGljYWwgPSBpc1ZlcnRpY2FsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b29sdGlwIG9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge3thbGlnbjogP3N0cmluZywgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgY2FjaGluZ1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSB7fTtcblxuICAgICAgICB0aGlzLl9zZXREYXRhKGNoYXJ0RGltZW5zaW9uLCBhcmVhQm91bmQsIGlzVmVydGljYWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgaG9yaXpvbnRhbCBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBhbGlnbk9wdGlvbiBhbGlnbiBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRIb3Jpem9udGFsRGlyZWN0aW9uOiBmdW5jdGlvbihhbGlnbk9wdGlvbikge1xuICAgICAgICB2YXIgZGlyZWN0aW9uO1xuXG4gICAgICAgIGFsaWduT3B0aW9uID0gYWxpZ25PcHRpb24gfHwgJyc7XG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdsZWZ0JykgPiAtMSkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9CQUNLV0FSRDtcbiAgICAgICAgfSBlbHNlIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdjZW50ZXInKSA+IC0xKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0NFTlRFUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdmVydGljYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGNoYXJ0RGltZW5zaW9uIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IGFyZWFCb3VuZCB0b29sdGlwIGFyZWEgYm91bmRcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IGFsaWduT3B0aW9uIGFsaWduIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBwb3NpdGlvblR5cGU6IHN0cmluZywgc2l6ZVR5cGU6IHN0cmluZywgZGlyZWN0aW9uOiAoc3RyaW5nKSxcbiAgICAgKiAgICAgIGFyZWFQb3NpdGlvbjogbnVtYmVyLCBhcmVhU2l6ZTogbnVtYmVyLCBjaGFydFNpemU6IG51bWJlcixcbiAgICAgKiAgICAgIGJhc2VQb3NpdGlvbjogKG51bWJlcilcbiAgICAgKiB9fSB2ZXJ0aWNhbCBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsRGF0YTogZnVuY3Rpb24oY2hhcnREaW1lbnNpb24sIGFyZWFCb3VuZCwgYWxpZ25PcHRpb24pIHtcbiAgICAgICAgdmFyIGhEaXJlY3Rpb24gPSB0aGlzLl9nZXRIb3Jpem9udGFsRGlyZWN0aW9uKGFsaWduT3B0aW9uKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb25UeXBlOiAnbGVmdCcsXG4gICAgICAgICAgICBzaXplVHlwZTogJ3dpZHRoJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogaERpcmVjdGlvbixcbiAgICAgICAgICAgIGFyZWFQb3NpdGlvbjogYXJlYUJvdW5kLnBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICBhcmVhU2l6ZTogYXJlYUJvdW5kLmRpbWVuc2lvbi53aWR0aCxcbiAgICAgICAgICAgIGNoYXJ0U2l6ZTogY2hhcnREaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBiYXNlUG9zaXRpb246IGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB2ZXJ0aWNhbCBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBhbGlnbk9wdGlvbiBhbGlnbiBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRWZXJ0aWNhbERpcmVjdGlvbjogZnVuY3Rpb24oYWxpZ25PcHRpb24pIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbjtcblxuICAgICAgICBhbGlnbk9wdGlvbiA9IGFsaWduT3B0aW9uIHx8ICcnO1xuXG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCd0b3AnKSA+IC0xKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJEO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ2JvdHRvbScpID4gLTEpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fQ0VOVEVSO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBob3Jpem9udGFsIGRhdGEuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBjaGFydERpbWVuc2lvbiBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBhcmVhQm91bmQgdG9vbHRpcCBhcmVhIGJvdW5kXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBhbGlnbk9wdGlvbiBhbGlnbiBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgcG9zaXRpb25UeXBlOiBzdHJpbmcsIHNpemVUeXBlOiBzdHJpbmcsIGRpcmVjdGlvbjogKHN0cmluZyksXG4gICAgICogICAgICBhcmVhUG9zaXRpb246IG51bWJlciwgYXJlYVNpemU6IG51bWJlciwgY2hhcnRTaXplOiBudW1iZXIsXG4gICAgICogICAgICBiYXNlUG9zaXRpb246IChudW1iZXIpXG4gICAgICogfX0gaG9yaXpvbnRhbCBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUhvcml6b250YWxEYXRhOiBmdW5jdGlvbihjaGFydERpbWVuc2lvbiwgYXJlYUJvdW5kLCBhbGlnbk9wdGlvbikge1xuICAgICAgICB2YXIgdkRpcmVjdGlvbiA9IHRoaXMuX2dldFZlcnRpY2FsRGlyZWN0aW9uKGFsaWduT3B0aW9uKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb25UeXBlOiAndG9wJyxcbiAgICAgICAgICAgIHNpemVUeXBlOiAnaGVpZ2h0JyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdkRpcmVjdGlvbixcbiAgICAgICAgICAgIGFyZWFQb3NpdGlvbjogYXJlYUJvdW5kLnBvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGFyZWFTaXplOiBhcmVhQm91bmQuZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGNoYXJ0U2l6ZTogY2hhcnREaW1lbnNpb24uaGVpZ2h0LFxuICAgICAgICAgICAgYmFzZVBvc2l0aW9uOiBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGNoYXJ0RGltZW5zaW9uIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IGFyZWFCb3VuZCB0b29sdGlwIGFyZWEgYm91bmRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcGFyYW0ge3thbGlnbjogP3N0cmluZywgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IG9wdGlvbnMgdG9vbHRpcCBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0RGF0YTogZnVuY3Rpb24oY2hhcnREaW1lbnNpb24sIGFyZWFCb3VuZCwgaXNWZXJ0aWNhbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdmVydGljYWxEYXRhID0gdGhpcy5fbWFrZVZlcnRpY2FsRGF0YShjaGFydERpbWVuc2lvbiwgYXJlYUJvdW5kLCBvcHRpb25zLmFsaWduKSxcbiAgICAgICAgICAgIGhvcml6b250YWxEYXRhID0gdGhpcy5fbWFrZUhvcml6b250YWxEYXRhKGNoYXJ0RGltZW5zaW9uLCBhcmVhQm91bmQsIG9wdGlvbnMuYWxpZ24pO1xuXG4gICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLm1haW5EYXRhID0gdmVydGljYWxEYXRhO1xuICAgICAgICAgICAgdGhpcy5zdWJEYXRhID0gaG9yaXpvbnRhbERhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW5EYXRhID0gaG9yaXpvbnRhbERhdGE7XG4gICAgICAgICAgICB0aGlzLnN1YkRhdGEgPSB2ZXJ0aWNhbERhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvc2l0aW9uT3B0aW9uID0gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgfSwgb3B0aW9ucy5wb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIG1haW4gcG9zaXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvb2x0aXBTaXplIHRvb2x0aXAgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gZGF0YS5kaXJlY3Rpb24gZGlyZWN0aW9uXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5iYXNlUG9zaXRpb24gYmFzZVBvc2l0aW9uXG4gICAgICogQHJldHVybnMge251bWJlcn0gcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVNYWluUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odG9vbHRpcFNpemUsIHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIHZhciBpc0xpbmUgPSAocmFuZ2Uuc3RhcnQgPT09IHJhbmdlLmVuZCksXG4gICAgICAgICAgICBsaW5lVHlwZVBhZGRpbmcgPSA5LFxuICAgICAgICAgICAgb3RoZXJUeXBlUGFkZGluZyA9IDUsXG4gICAgICAgICAgICBwYWRkaW5nID0gaXNMaW5lID8gbGluZVR5cGVQYWRkaW5nIDogb3RoZXJUeXBlUGFkZGluZyxcbiAgICAgICAgICAgIHZhbHVlID0gZGF0YS5iYXNlUG9zaXRpb247XG5cbiAgICAgICAgaWYgKGRhdGEuZGlyZWN0aW9uID09PSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0ZPUldBUkQpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHJhbmdlLmVuZCArIHBhZGRpbmc7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5kaXJlY3Rpb24gPT09IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fQkFDS1dBUkQpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHJhbmdlLnN0YXJ0IC0gdG9vbHRpcFNpemUgLSBwYWRkaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgdmFsdWUgKz0gcmFuZ2Uuc3RhcnQgLSB0b29sdGlwU2l6ZSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSArPSByYW5nZS5zdGFydCArICgocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQgLSB0b29sdGlwU2l6ZSkgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHN1YiBwb3NpdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYXJlYVNpemUgdG9vbHRpcCBhcmVhIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLmRpcmVjdGlvbiBkaXJlY3Rpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmJhc2VQb3NpdGlvbiBiYXNlUG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVN1YlBvc2l0aW9uVmFsdWU6IGZ1bmN0aW9uKHRvb2x0aXBTaXplLCBkYXRhKSB7XG4gICAgICAgIHZhciBtaWRkbGUgPSBkYXRhLmFyZWFTaXplIC8gMixcbiAgICAgICAgICAgIHZhbHVlO1xuXG4gICAgICAgIGlmIChkYXRhLmRpcmVjdGlvbiA9PT0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9GT1JXQVJEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1pZGRsZSArIGRhdGEuYmFzZVBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuZGlyZWN0aW9uID09PSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1pZGRsZSAtIHRvb2x0aXBTaXplICsgZGF0YS5iYXNlUG9zaXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1pZGRsZSAtICh0b29sdGlwU2l6ZSAvIDIpICsgZGF0YS5iYXNlUG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcG9zaXRpb24gdmFsdWUgZGlmZi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgcG9zaXRvaW4gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuY2hhcnRTaXplIGNoYXJ0IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFyZWFQb3NpdGlvbiB0b29sdGlwIGFyZWEgcG9zaXRpb24gKGxlZnQgb3IgdG9wKVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGRpZmZcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUG9zaXRpb25WYWx1ZURpZmY6IGZ1bmN0aW9uKHZhbHVlLCB0b29sdGlwU2l6ZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgKyBkYXRhLmFyZWFQb3NpdGlvbiArIHRvb2x0aXBTaXplIC0gZGF0YS5jaGFydFNpemU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBiYWNrd2FyZCBwb3NpdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvb2x0aXBTaXplIHRvb2x0aXAgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmNoYXJ0U2l6ZSBjaGFydCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5hcmVhUG9zaXRpb24gdG9vbHRpcCBhcmVhIHBvc2l0aW9uIChsZWZ0IG9yIHRvcClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmJhc2VQb3NpdGlvbiBiYXNlUG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkanVzdEJhY2t3YXJkUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odmFsdWUsIHJhbmdlLCB0b29sdGlwU2l6ZSwgZGF0YSkge1xuICAgICAgICB2YXIgY2hhbmdlZFZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSA8IC1kYXRhLmFyZWFQb3NpdGlvbikge1xuICAgICAgICAgICAgY2hhbmdlZFZhbHVlID0gdGhpcy5fY2FsY3VsYXRlTWFpblBvc2l0aW9uVmFsdWUodG9vbHRpcFNpemUsIHJhbmdlLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0ZPUldBUkQsXG4gICAgICAgICAgICAgICAgYmFzZVBvc2l0aW9uOiBkYXRhLmJhc2VQb3NpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWFrZVBvc2l0aW9uVmFsdWVEaWZmKGNoYW5nZWRWYWx1ZSwgdG9vbHRpcFNpemUsIGRhdGEpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gLWRhdGEuYXJlYVBvc2l0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYW5nZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IGZvcndhcmQgcG9zaXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b29sdGlwU2l6ZSB0b29sdGlwIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5jaGFydFNpemUgY2hhcnQgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYXJlYVBvc2l0aW9uIHRvb2x0aXAgYXJlYSBwb3NpdGlvbiAobGVmdCBvciB0b3ApXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5iYXNlUG9zaXRpb24gYmFzZVBvc2l0aW9uXG4gICAgICogQHJldHVybnMge251bWJlcn0gcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGp1c3RGb3J3YXJkUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odmFsdWUsIHJhbmdlLCB0b29sdGlwU2l6ZSwgZGF0YSkge1xuICAgICAgICB2YXIgZGlmZiA9IHRoaXMuX21ha2VQb3NpdGlvblZhbHVlRGlmZih2YWx1ZSwgdG9vbHRpcFNpemUsIGRhdGEpLFxuICAgICAgICAgICAgY2hhbmdlZFZhbHVlO1xuXG4gICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgY2hhbmdlZFZhbHVlID0gdGhpcy5fY2FsY3VsYXRlTWFpblBvc2l0aW9uVmFsdWUodG9vbHRpcFNpemUsIHJhbmdlLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJELFxuICAgICAgICAgICAgICAgIGJhc2VQb3NpdGlvbjogZGF0YS5iYXNlUG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRWYWx1ZSA8IC1kYXRhLmFyZWFQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhbHVlIC09IGRpZmY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhbmdlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgbWFpbiBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuY2hhcnRTaXplIGNoYXJ0IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFyZWFQb3NpdGlvbiB0b29sdGlwIGFyZWEgcG9zaXRpb24gKGxlZnQgb3IgdG9wKVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRqdXN0TWFpblBvc2l0aW9uVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCByYW5nZSwgdG9vbHRpcFNpemUsIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuZGlyZWN0aW9uID09PSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkanVzdEJhY2t3YXJkUG9zaXRpb25WYWx1ZSh2YWx1ZSwgcmFuZ2UsIHRvb2x0aXBTaXplLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmRpcmVjdGlvbiA9PT0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9GT1JXQVJEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkanVzdEZvcndhcmRQb3NpdGlvblZhbHVlKHZhbHVlLCByYW5nZSwgdG9vbHRpcFNpemUsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heCh2YWx1ZSwgLWRhdGEuYXJlYVBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5taW4odmFsdWUsIGRhdGEuY2hhcnRTaXplIC0gZGF0YS5hcmVhUG9zaXRpb24gLSB0b29sdGlwU2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBzdWIgcG9zaXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvb2x0aXBTaXplIHRvb2x0aXAgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmNoYXJ0U2l6ZSBjaGFydCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5hcmVhUG9zaXRpb24gdG9vbHRpcCBhcmVhIHBvc2l0aW9uIChsZWZ0IG9yIHRvcClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmJhc2VQb3NpdGlvbiBiYXNlUG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkanVzdFN1YlBvc2l0aW9uVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCB0b29sdGlwU2l6ZSwgZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5kaXJlY3Rpb24gPT09IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRCkge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbih2YWx1ZSwgZGF0YS5jaGFydFNpemUgLSBkYXRhLmFyZWFQb3NpdGlvbiAtIHRvb2x0aXBTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5tYXgodmFsdWUsIC1kYXRhLmFyZWFQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY2FjaGluZyBrZXkuXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGtleVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDYWNoaW5nS2V5OiBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnQgKyAnLScgKyByYW5nZS5lbmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBwb3NpdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uVHlwZSBwb3NpdGlvbiB0eXBlIChsZWZ0IG9yIHRvcClcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZFBvc2l0aW9uT3B0aW9uVmFsdWU6IGZ1bmN0aW9uKHBvc2l0aW9uLCBwb3NpdGlvblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uICsgdGhpcy5wb3NpdGlvbk9wdGlvbltwb3NpdGlvblR5cGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG1haW4gcG9zaXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSB0b29sdGlwRGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSB0b29sdGlwIHNlY3RvciByYW5nZVxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgcG9zaXRpb25UeXBlOiBzdHJpbmcsIHNpemVUeXBlOiBzdHJpbmcsIGRpcmVjdGlvbjogKHN0cmluZyksXG4gICAgICogICAgICBhcmVhUG9zaXRpb246IG51bWJlciwgYXJlYVNpemU6IG51bWJlciwgY2hhcnRTaXplOiBudW1iZXIsXG4gICAgICogICAgICBiYXNlUG9zaXRpb246IChudW1iZXIpXG4gICAgICogfX0gbWFpbiBtYWluIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VNYWluUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odG9vbHRpcERpbWVuc2lvbiwgcmFuZ2UsIG1haW4pIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gdGhpcy5fY2FsY3VsYXRlTWFpblBvc2l0aW9uVmFsdWUodG9vbHRpcERpbWVuc2lvblttYWluLnNpemVUeXBlXSwgcmFuZ2UsIG1haW4pO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkZFBvc2l0aW9uT3B0aW9uVmFsdWUodmFsdWUsIG1haW4ucG9zaXRpb25UeXBlKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9hZGp1c3RNYWluUG9zaXRpb25WYWx1ZSh2YWx1ZSwgcmFuZ2UsIHRvb2x0aXBEaW1lbnNpb25bbWFpbi5zaXplVHlwZV0sIG1haW4pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdWIgcG9zaXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSB0b29sdGlwRGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBwb3NpdGlvblR5cGU6IHN0cmluZywgc2l6ZVR5cGU6IHN0cmluZywgZGlyZWN0aW9uOiAoc3RyaW5nKSxcbiAgICAgKiAgICAgIGFyZWFQb3NpdGlvbjogbnVtYmVyLCBhcmVhU2l6ZTogbnVtYmVyLCBjaGFydFNpemU6IG51bWJlcixcbiAgICAgKiAgICAgIGJhc2VQb3NpdGlvbjogKG51bWJlcilcbiAgICAgKiB9fSBzdWIgc3ViIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTdWJQb3NpdGlvblZhbHVlOiBmdW5jdGlvbih0b29sdGlwRGltZW5zaW9uLCBzdWIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gdGhpcy5fY2FsY3VsYXRlU3ViUG9zaXRpb25WYWx1ZSh0b29sdGlwRGltZW5zaW9uW3N1Yi5zaXplVHlwZV0sIHN1Yik7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fYWRkUG9zaXRpb25PcHRpb25WYWx1ZSh2YWx1ZSwgc3ViLnBvc2l0aW9uVHlwZSk7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fYWRqdXN0U3ViUG9zaXRpb25WYWx1ZSh2YWx1ZSwgdG9vbHRpcERpbWVuc2lvbltzdWIuc2l6ZVR5cGVdLCBzdWIpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGdyb3VwIHRvb2x0aXAgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSB0b29sdGlwRGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSB0b29sdGlwIHNlY3RvciByYW5nZVxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGdyb3VwIHRvb2x0aXAgcG9zaXRpb25cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVQb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcERpbWVuc2lvbiwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX21ha2VDYWNoaW5nS2V5KHJhbmdlKSxcbiAgICAgICAgICAgIG1haW4gPSB0aGlzLm1haW5EYXRhLFxuICAgICAgICAgICAgc3ViID0gdGhpcy5zdWJEYXRhLFxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uc1trZXldO1xuXG4gICAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0ge307XG4gICAgICAgICAgICBwb3NpdGlvblttYWluLnBvc2l0aW9uVHlwZV0gPSB0aGlzLl9tYWtlTWFpblBvc2l0aW9uVmFsdWUodG9vbHRpcERpbWVuc2lvbiwgcmFuZ2UsIG1haW4pO1xuICAgICAgICAgICAgcG9zaXRpb25bc3ViLnBvc2l0aW9uVHlwZV0gPSB0aGlzLl9tYWtlU3ViUG9zaXRpb25WYWx1ZSh0b29sdGlwRGltZW5zaW9uLCBzdWIpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnNba2V5XSA9IHBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdG9vbHRpcCBvcHRpb25zIGZvciBwb3NpdGlvbiBjYWxjdWxhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3thbGlnbjogP3N0cmluZywgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IG9wdGlvbnMgdG9vbHRpcCBvcHRpb25zXG4gICAgICovXG4gICAgdXBkYXRlT3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9zZXREYXRhKHRoaXMuY2hhcnREaW1lbnNpb24sIHRoaXMuYXJlYUJvdW5kLCB0aGlzLmlzVmVydGljYWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdG9vbHRpcCBib3VuZCBmb3IgcG9zaXRpb24gY2FsY3VsYXRpb24uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYm91bmQgdG9vbHRpcCBhcmVhIGJvdW5kXG4gICAgICovXG4gICAgdXBkYXRlQm91bmQ6IGZ1bmN0aW9uKGJvdW5kKSB7XG4gICAgICAgIHRoaXMuYXJlYUJvdW5kID0gYm91bmQ7XG4gICAgICAgIHRoaXMuX3NldERhdGEodGhpcy5jaGFydERpbWVuc2lvbiwgYm91bmQsIHRoaXMuaXNWZXJ0aWNhbCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cFRvb2x0aXBQb3NpdGlvbk1vZGVsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRvb2x0aXAgY29tcG9uZW50IGZvciBtYXAgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBUb29sdGlwQmFzZSA9IHJlcXVpcmUoJy4vdG9vbHRpcEJhc2UnKSxcbiAgICBzaW5nbGVUb29sdGlwTWl4ZXIgPSByZXF1aXJlKCcuL3NpbmdsZVRvb2x0aXBNaXhlcicpLFxuICAgIHRvb2x0aXBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdG9vbHRpcFRlbXBsYXRlJyk7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBNYXBDaGFydFRvb2x0aXAgY29tcG9uZW50LlxuICogQGNsYXNzIE1hcENoYXJ0VG9vbHRpcFxuICovXG52YXIgTWFwQ2hhcnRUb29sdGlwID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoVG9vbHRpcEJhc2UsIC8qKiBAbGVuZHMgTWFwQ2hhcnRUb29sdGlwLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTWFwIGNoYXJ0IHRvb2x0aXAgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIE1hcENoYXJ0VG9vbHRpcFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtCb3VuZHNNYWtlcn0gcGFyYW1zLmJvdW5kc01ha2VyIGJvdW5kcyBtYWtlclxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBheGlzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgbW9kZWxcbiAgICAgICAgICogQHR5cGUge01hcENoYXJ0TWFwTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcE1vZGVsID0gbnVsbDtcblxuICAgICAgICBUb29sdGlwQmFzZS5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBodG1sLlxuICAgICAqIEBwYXJhbSB7e25hbWU6IHN0cmluZywgdmFsdWU6IG51bWJlcn19IGRhdHVtIHRvb2x0aXAgZGF0dW1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0b29sdGlwIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcEh0bWw6IGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgIHJldHVybiB0b29sdGlwVGVtcGxhdGUudHBsTWFwQ2hhcnREZWZhdWx0KGRhdHVtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzaW5nbGUgdG9vbHRpcCBodG1sLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvb2x0aXAgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTaW5nbGVUb29sdGlwSHRtbDogZnVuY3Rpb24oY2hhcnRUeXBlLCBpbmRleGVzKSB7XG4gICAgICAgIHZhciBkYXR1bSA9IHRoaXMubWFwTW9kZWwuZ2V0RGF0dW0oaW5kZXhlcy5pbmRleCksXG4gICAgICAgICAgICBzdWZmaXggPSB0aGlzLm9wdGlvbnMuc3VmZml4ID8gJyAnICsgdGhpcy5vcHRpb25zLnN1ZmZpeCA6ICcnO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlRnVuYyh7XG4gICAgICAgICAgICBuYW1lOiBkYXR1bS5uYW1lIHx8IGRhdHVtLmNvZGUsXG4gICAgICAgICAgICB2YWx1ZTogZGF0dW0ubGFiZWwsXG4gICAgICAgICAgICBzdWZmaXg6IHN1ZmZpeFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwYXJhbWV0ZXJzIGZvciBzaG93IHRvb2x0aXAgdXNlciBldmVudC5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYWRkaXRpb25QYXJhbXMgYWRkaXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHt7Y2hhcnRUeXBlOiBzdHJpbmcsIGxlZ2VuZDogc3RyaW5nLCBsZWdlbmRJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gcGFyYW1ldGVycyBmb3Igc2hvdyB0b29sdGlwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNob3dUb29sdGlwUGFyYW1zOiBmdW5jdGlvbihpbmRleGVzLCBhZGRpdGlvblBhcmFtcykge1xuICAgICAgICB2YXIgZGF0dW0gPSB0aGlzLm1hcE1vZGVsLmdldERhdHVtKGluZGV4ZXMuaW5kZXgpLFxuICAgICAgICAgICAgcGFyYW1zO1xuXG4gICAgICAgIHBhcmFtcyA9IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgY29kZTogZGF0dW0uY29kZSxcbiAgICAgICAgICAgIG5hbWU6IGRhdHVtLm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogZGF0dW0ubGFiZWwsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhlcy5pbmRleFxuICAgICAgICB9LCBhZGRpdGlvblBhcmFtcyk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGVmYXVsdCBhbGlnbiBvcHRpb24gb2YgdG9vbHRpcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZXREZWZhdWx0VG9vbHRpcFBvc2l0aW9uT3B0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxpZ24pIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbGlnbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ERUZBVUxUX0FMSUdOX09QVElPTjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIuXG4gICAgICogQHBhcmFtIHt7bWFwTW9kZWw6IE1hcENoYXJ0TWFwTW9kZWx9fSBkYXRhIGRhdGEgZm9yIHJlbmRlcmluZ1xuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdG9vbHRpcCBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMubWFwTW9kZWwgPSBkYXRhLm1hcE1vZGVsO1xuXG4gICAgICAgIHJldHVybiBUb29sdGlwQmFzZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgfVxufSk7XG5cbnNpbmdsZVRvb2x0aXBNaXhlci5taXhpbihNYXBDaGFydFRvb2x0aXApO1xubW9kdWxlLmV4cG9ydHMgPSBNYXBDaGFydFRvb2x0aXA7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgc2luZ2xlVG9vbHRpcE1peGVyIGlzIHNpbmdsZSB0b29sdGlwIG1peGVyIG9mIG1hcCBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG4vKipcbiAqIHNpbmdsZVRvb2x0aXBNaXhlciBpcyBzaW5nbGUgdG9vbHRpcCBtaXhlciBvZiBtYXAgY2hhcnQuXG4gKiBAbWl4aW5cbiAqL1xudmFyIHNpbmdsZVRvb2x0aXBNaXhlciA9IHtcblxuICAgIC8qKlxuICAgICAqIEZpcmUgY3VzdG9tIGV2ZW50IHNob3dBbmltYXRpb24uXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZVNob3dBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4ZXMsIGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gcmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzaG93JywgY2hhcnRUeXBlLCAnYW5pbWF0aW9uJyk7XG5cbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwgaW5kZXhlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmUgY3VzdG9tIGV2ZW50IGhpZGVBbmltYXRpb24uXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUhpZGVBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4ZXMsIGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gcmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdoaWRlJywgY2hhcnRUeXBlLCAnYW5pbWF0aW9uJyk7XG5cbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwgaW5kZXhlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBkYXRhIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6bnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0SW5kZXhlc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24oZWxUb29sdGlwLCBpbmRleGVzKSB7XG4gICAgICAgIGVsVG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXBJbmRleCcsIGluZGV4ZXMuZ3JvdXBJbmRleCk7XG4gICAgICAgIGVsVG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBpbmRleGVzLmluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGRhdGEgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVG9vbHRpcCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRJbmRleGVzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbihlbFRvb2x0aXApIHtcbiAgICAgICAgdmFyIGdyb3VwSW5kZXggPSBlbFRvb2x0aXAuZ2V0QXR0cmlidXRlKCdkYXRhLWdyb3VwSW5kZXgnKSxcbiAgICAgICAgICAgIGluZGV4ID0gZWxUb29sdGlwLmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpLFxuICAgICAgICAgICAgaW5kZXhlcyA9IG51bGw7XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc051bGwoZ3JvdXBJbmRleCkgJiYgIXR1aS51dGlsLmlzTnVsbChpbmRleCkpIHtcbiAgICAgICAgICAgIGluZGV4ZXMgPSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBJbmRleDogcGFyc2VJbnQoZ3JvdXBJbmRleCwgMTApLFxuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJzZUludChpbmRleCwgMTApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgc2hvd2VkIGN1c3RvbSBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdHVzIHdoZXRoZXIgc2hvd2VkIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNob3dlZEN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24oZWxUb29sdGlwLCBzdGF0dXMpIHtcbiAgICAgICAgZWxUb29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1zaG93ZWQnLCBzdGF0dXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHNob3dlZCB0b29sdGlwIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRvb2x0aXAgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgc2hvd2VkIHRvb2x0aXAgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNTaG93ZWRUb29sdGlwOiBmdW5jdGlvbihlbFRvb2x0aXApIHtcbiAgICAgICAgdmFyIGlzU2hvd2VkID0gZWxUb29sdGlwLmdldEF0dHJpYnV0ZSgnZGF0YS1zaG93ZWQnKTtcblxuICAgICAgICByZXR1cm4gaXNTaG93ZWQgPT09ICd0cnVlJyB8fCBpc1Nob3dlZCA9PT0gdHJ1ZTsgLy8gaWU37JeQ7ISc64qUIGJvb2xlYW7tmJXtg5zsnZggdHJ1ZeulvCDrsJjtmZjtlahcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsZWZ0IHBvc2l0aW9uIG9mIG5vdCBiYXIgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VMZWZ0IGJhc2UgbGVmdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbk9wdGlvbiBhbGlnbiBvcHRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludXNXaWR0aCBtaW51cyB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lR2FwIGxpbmUgZ2FwXG4gICAgICogQHJldHVybnMge251bWJlcn0gbGVmdCBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMZWZ0UG9zaXRpb25PZk5vdEJhckNoYXJ0OiBmdW5jdGlvbihiYXNlTGVmdCwgYWxpZ25PcHRpb24sIG1pbnVzV2lkdGgsIGxpbmVHYXApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBiYXNlTGVmdDtcblxuICAgICAgICBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignbGVmdCcpID4gLTEpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gbWludXNXaWR0aCArIGxpbmVHYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignY2VudGVyJykgPiAtMSkge1xuICAgICAgICAgICAgbGVmdCAtPSBtaW51c1dpZHRoIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgKz0gbGluZUdhcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvcCBwb3NpdGlvbiBvZiBub3QgYmFyIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlVG9wIGJhc2UgdG9wXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWduT3B0aW9uIGFsaWduIG9wdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b29sdGlwSGVpZ2h0IHRvb2x0aXAgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVHYXAgbGluZSBnYXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0b3AgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9wUG9zaXRpb25PZk5vdEJhckNoYXJ0OiBmdW5jdGlvbihiYXNlVG9wLCBhbGlnbk9wdGlvbiwgdG9vbHRpcEhlaWdodCwgbGluZUdhcCkge1xuICAgICAgICB2YXIgdG9wID0gYmFzZVRvcDtcblxuICAgICAgICBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignYm90dG9tJykgPiAtMSkge1xuICAgICAgICAgICAgdG9wICs9IHRvb2x0aXBIZWlnaHQgKyBsaW5lR2FwO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ21pZGRsZScpID4gLTEpIHtcbiAgICAgICAgICAgIHRvcCArPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcCAtPSBjaGFydENvbnN0LlRPT0xUSVBfR0FQO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwIHBvc2l0aW9uIG9mIG5vdCBiYXIgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tib3VuZDogb2JqZWN0fX0gcGFyYW1zLmRhdGEgZ3JhcGggaW5mb3JtYXRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmRpbWVuc2lvbiB0b29sdGlwIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hbGlnbk9wdGlvbiBwb3NpdGlvbiBvcHRpb24gKGV4OiAnbGVmdCB0b3AnKVxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBQb3NpdGlvbk9mTm90QmFyQ2hhcnQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgYm91bmQgPSBwYXJhbXMuYm91bmQsXG4gICAgICAgICAgICBwb3NpdGlvbk9wdGlvbiA9IHBhcmFtcy5wb3NpdGlvbk9wdGlvbixcbiAgICAgICAgICAgIG1pbnVzV2lkdGggPSBwYXJhbXMuZGltZW5zaW9uLndpZHRoIC0gKGJvdW5kLndpZHRoIHx8IDApLFxuICAgICAgICAgICAgbGluZUdhcCA9IGJvdW5kLndpZHRoID8gMCA6IGNoYXJ0Q29uc3QuVE9PTFRJUF9HQVAsXG4gICAgICAgICAgICBhbGlnbk9wdGlvbiA9IHBhcmFtcy5hbGlnbk9wdGlvbiB8fCAnJyxcbiAgICAgICAgICAgIHRvb2x0aXBIZWlnaHQgPSBwYXJhbXMuZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGJhc2VMZWZ0ID0gYm91bmQubGVmdCArIHBvc2l0aW9uT3B0aW9uLmxlZnQsXG4gICAgICAgICAgICBiYXNlVG9wID0gYm91bmQudG9wIC0gdG9vbHRpcEhlaWdodCArIHBvc2l0aW9uT3B0aW9uLnRvcDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogdGhpcy5fbWFrZUxlZnRQb3NpdGlvbk9mTm90QmFyQ2hhcnQoYmFzZUxlZnQsIGFsaWduT3B0aW9uLCBtaW51c1dpZHRoLCBsaW5lR2FwKSxcbiAgICAgICAgICAgIHRvcDogdGhpcy5fbWFrZVRvcFBvc2l0aW9uT2ZOb3RCYXJDaGFydChiYXNlVG9wLCBhbGlnbk9wdGlvbiwgdG9vbHRpcEhlaWdodCwgbGluZUdhcClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwIHBvc2l0aW9uIHRvIGV2ZW50IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBhcmFtcy5ib3VuZCBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBhcmFtcy5tb3VzZVBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcFBvc2l0aW9uVG9Nb3VzZVBvc2l0aW9uOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLmJvdW5kID0gcGFyYW1zLmJvdW5kIHx8IHt9O1xuICAgICAgICB0dWkudXRpbC5leHRlbmQocGFyYW1zLmJvdW5kLCBwYXJhbXMubW91c2VQb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWtlVG9vbHRpcFBvc2l0aW9uT2ZOb3RCYXJDaGFydChwYXJhbXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxlZnQgcG9zaXRpb24gb2YgYmFyIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlTGVmdCBiYXNlIGxlZnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ25PcHRpb24gYWxpZ24gb3B0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvb2x0aXBXaWR0aCB0b29sdGlwIHdpZHRoXG4gICAgICogQHJldHVybnMge251bWJlcn0gbGVmdCBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMZWZ0UG9zaXRpb25PZkJhckNoYXJ0OiBmdW5jdGlvbihiYXNlTGVmdCwgYWxpZ25PcHRpb24sIHRvb2x0aXBXaWR0aCkge1xuICAgICAgICB2YXIgbGVmdCA9IGJhc2VMZWZ0O1xuXG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdsZWZ0JykgPiAtMSkge1xuICAgICAgICAgICAgbGVmdCAtPSB0b29sdGlwV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignY2VudGVyJykgPiAtMSkge1xuICAgICAgICAgICAgbGVmdCAtPSB0b29sdGlwV2lkdGggLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCArPSBjaGFydENvbnN0LlRPT0xUSVBfR0FQO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9wIHBvc2l0aW9uIG9mIGJhciBjaGFydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZVRvcCBiYXNlIHRvcFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbk9wdGlvbiBhbGlnbiBvcHRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludXNIZWlnaHQgbWludXMgd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0b3AgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9wUG9zaXRpb25PZkJhckNoYXJ0OiBmdW5jdGlvbihiYXNlVG9wLCBhbGlnbk9wdGlvbiwgbWludXNIZWlnaHQpIHtcbiAgICAgICAgdmFyIHRvcCA9IGJhc2VUb3A7XG5cbiAgICAgICAgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ3RvcCcpID4gLTEpIHtcbiAgICAgICAgICAgIHRvcCAtPSBtaW51c0hlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdtaWRkbGUnKSA+IC0xKSB7XG4gICAgICAgICAgICB0b3AgLT0gbWludXNIZWlnaHQgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwIHBvc2l0aW9uIG9mIGJhciBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e2JvdW5kOiBvYmplY3R9fSBwYXJhbXMuZGF0YSBncmFwaCBpbmZvcm1hdGlvblxuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuZGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFsaWduT3B0aW9uIHBvc2l0aW9uIG9wdGlvbiAoZXg6ICdsZWZ0IHRvcCcpXG4gICAgICogQHJldHVybnMge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcFBvc2l0aW9uT2ZCYXJDaGFydDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHBhcmFtcy5ib3VuZCxcbiAgICAgICAgICAgIHBvc2l0aW9uT3B0aW9uID0gcGFyYW1zLnBvc2l0aW9uT3B0aW9uLFxuICAgICAgICAgICAgbWludXNIZWlnaHQgPSBwYXJhbXMuZGltZW5zaW9uLmhlaWdodCAtIChib3VuZC5oZWlnaHQgfHwgMCksXG4gICAgICAgICAgICBhbGlnbk9wdGlvbiA9IHBhcmFtcy5hbGlnbk9wdGlvbiB8fCAnJyxcbiAgICAgICAgICAgIHRvb2x0aXBXaWR0aCA9IHBhcmFtcy5kaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBiYXNlTGVmdCA9IGJvdW5kLmxlZnQgKyBib3VuZC53aWR0aCArIHBvc2l0aW9uT3B0aW9uLmxlZnQsXG4gICAgICAgICAgICBiYXNlVG9wID0gYm91bmQudG9wICsgcG9zaXRpb25PcHRpb24udG9wO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiB0aGlzLl9tYWtlTGVmdFBvc2l0aW9uT2ZCYXJDaGFydChiYXNlTGVmdCwgYWxpZ25PcHRpb24sIHRvb2x0aXBXaWR0aCksXG4gICAgICAgICAgICB0b3A6IHRoaXMuX21ha2VUb3BQb3NpdGlvbk9mQmFyQ2hhcnQoYmFzZVRvcCwgYWxpZ25PcHRpb24sIG1pbnVzSGVpZ2h0KVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSB0b29sdGlwRGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYWRqdXN0ZWQgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGp1c3RQb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcERpbWVuc2lvbiwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGNoYXJ0RGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2NoYXJ0JyksXG4gICAgICAgICAgICBhcmVhUG9zaXRpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKCd0b29sdGlwJyk7XG5cbiAgICAgICAgcG9zaXRpb24ubGVmdCA9IE1hdGgubWF4KHBvc2l0aW9uLmxlZnQsIC1hcmVhUG9zaXRpb24ubGVmdCk7XG4gICAgICAgIHBvc2l0aW9uLmxlZnQgPSBNYXRoLm1pbihwb3NpdGlvbi5sZWZ0LCBjaGFydERpbWVuc2lvbi53aWR0aCAtIGFyZWFQb3NpdGlvbi5sZWZ0IC0gdG9vbHRpcERpbWVuc2lvbi53aWR0aCk7XG4gICAgICAgIHBvc2l0aW9uLnRvcCA9IE1hdGgubWF4KHBvc2l0aW9uLnRvcCwgLWFyZWFQb3NpdGlvbi50b3ApO1xuICAgICAgICBwb3NpdGlvbi50b3AgPSBNYXRoLm1pbihwb3NpdGlvbi50b3AsIGNoYXJ0RGltZW5zaW9uLmhlaWdodCAtIGFyZWFQb3NpdGlvbi50b3AgLSB0b29sdGlwRGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuYm91bmQgZ3JhcGggYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmFsbG93TmVnYXRpdmVUb29sdGlwIHdoZXRoZXIgYWxsb3cgbmVnYXRpdmUgdG9vbHRpcCBvciBub3RcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmRpbWVuc2lvbiB0b29sdGlwIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hbGlnbk9wdGlvbiBwb3NpdGlvbiBvcHRpb24gKGV4OiAnbGVmdCB0b3AnKVxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHt9LFxuICAgICAgICAgICAgc2l6ZVR5cGUsIHBvc2l0aW9uVHlwZSwgYWRkUGFkZGluZztcblxuICAgICAgICBpZiAocGFyYW1zLm1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fbWFrZVRvb2x0aXBQb3NpdGlvblRvTW91c2VQb3NpdGlvbihwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0JhckNoYXJ0KHBhcmFtcy5jaGFydFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9tYWtlVG9vbHRpcFBvc2l0aW9uT2ZCYXJDaGFydChwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHNpemVUeXBlID0gJ3dpZHRoJztcbiAgICAgICAgICAgICAgICBwb3NpdGlvblR5cGUgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYWRkUGFkZGluZyA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fbWFrZVRvb2x0aXBQb3NpdGlvbk9mTm90QmFyQ2hhcnQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICBzaXplVHlwZSA9ICdoZWlnaHQnO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uVHlwZSA9ICd0b3AnO1xuICAgICAgICAgICAgICAgIGFkZFBhZGRpbmcgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5hbGxvd05lZ2F0aXZlVG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fbW92ZVRvU3ltbWV0cnkocG9zaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmQ6IHBhcmFtcy5ib3VuZCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlczogcGFyYW1zLmluZGV4ZXMsXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogcGFyYW1zLmRpbWVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBwYXJhbXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICBzaXplVHlwZTogc2l6ZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogcG9zaXRpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICBhZGRQYWRkaW5nOiBhZGRQYWRkaW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fYWRqdXN0UG9zaXRpb24ocGFyYW1zLmRpbWVuc2lvbiwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHN5bW1ldHJ5LlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiB0b29sdGlwIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5ib3VuZCBncmFwaCBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5pZCB0b29sdGlwIGlkXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2l6ZVR5cGUgc2l6ZSB0eXBlICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBvc2l0aW9uVHlwZSBwb3NpdGlvbiB0eXBlIChsZWZ0IG9yIHRvcClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuYWRkUGFkZGluZyBhZGQgcGFkZGluZ1xuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IG1vdmVkIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW92ZVRvU3ltbWV0cnk6IGZ1bmN0aW9uKHBvc2l0aW9uLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gcGFyYW1zLmJvdW5kLFxuICAgICAgICAgICAgc2l6ZVR5cGUgPSBwYXJhbXMuc2l6ZVR5cGUsXG4gICAgICAgICAgICBwb3NpdGlvblR5cGUgPSBwYXJhbXMucG9zaXRpb25UeXBlLFxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0VmFsdWUocGFyYW1zLmluZGV4ZXMuZ3JvdXBJbmRleCwgcGFyYW1zLmluZGV4ZXMuaW5kZXgsIHBhcmFtcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgdG9vbHRpcFNpemVIYWxmLCBiYXJQb3NpdGlvbiwgYmFyU2l6ZUhhbGYsIG1vdmVkUG9zaXRpb25WYWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0b29sdGlwU2l6ZUhhbGYgPSBwYXJhbXMuZGltZW5zaW9uW3NpemVUeXBlXSAvIDI7XG4gICAgICAgICAgICBiYXJQb3NpdGlvbiA9IGJvdW5kW3Bvc2l0aW9uVHlwZV07XG4gICAgICAgICAgICBiYXJTaXplSGFsZiA9IGJvdW5kW3NpemVUeXBlXSAvIDI7XG4gICAgICAgICAgICBtb3ZlZFBvc2l0aW9uVmFsdWUgPSAoYmFyUG9zaXRpb24gKyBiYXJTaXplSGFsZiAtIHRvb2x0aXBTaXplSGFsZikgKiAyIC0gcG9zaXRpb25bcG9zaXRpb25UeXBlXTtcbiAgICAgICAgICAgIHBvc2l0aW9uW3Bvc2l0aW9uVHlwZV0gPSBtb3ZlZFBvc2l0aW9uVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBpbmRleGVzIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBwcmV2SW5kZXhlcyBwcmV2IGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBjaGFuZ2VkIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2hhbmdlZEluZGV4ZXM6IGZ1bmN0aW9uKHByZXZJbmRleGVzLCBpbmRleGVzKSB7XG4gICAgICAgIHJldHVybiAhIXByZXZJbmRleGVzICYmIChwcmV2SW5kZXhlcy5ncm91cEluZGV4ICE9PSBpbmRleGVzLmdyb3VwSW5kZXggfHwgcHJldkluZGV4ZXMuaW5kZXggIT09IGluZGV4ZXMuaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2luZGV4ZXM6IHtncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9LCBib3VuZDogb2JqZWN0fX0gcGFyYW1zIHRvb2x0aXAgZGF0YVxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2UG9zaXRpb24gcHJldiBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3dUb29sdGlwOiBmdW5jdGlvbihlbFRvb2x0aXAsIHBhcmFtcywgcHJldlBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBpbmRleGVzID0gcGFyYW1zLmluZGV4ZXMsXG4gICAgICAgICAgICBwcmV2SW5kZXhlcyA9IHRoaXMuX2dldEluZGV4ZXNDdXN0b21BdHRyaWJ1dGUoZWxUb29sdGlwKSxcbiAgICAgICAgICAgIHByZXZDaGFydFR5cGUsIHBvc2l0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc0NoYW5nZWRJbmRleGVzKHByZXZJbmRleGVzLCBpbmRleGVzKSkge1xuICAgICAgICAgICAgcHJldkNoYXJ0VHlwZSA9IGVsVG9vbHRpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2hhcnQtdHlwZScpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZUhpZGVBbmltYXRpb24ocHJldkluZGV4ZXMsIHByZXZDaGFydFR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxUb29sdGlwLmlubmVySFRNTCA9IHRoaXMuX21ha2VTaW5nbGVUb29sdGlwSHRtbChwYXJhbXMuY2hhcnRUeXBlLCBpbmRleGVzKTtcblxuICAgICAgICBlbFRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWNoYXJ0LXR5cGUnLCBwYXJhbXMuY2hhcnRUeXBlKTtcbiAgICAgICAgdGhpcy5fc2V0SW5kZXhlc0N1c3RvbUF0dHJpYnV0ZShlbFRvb2x0aXAsIGluZGV4ZXMpO1xuICAgICAgICB0aGlzLl9zZXRTaG93ZWRDdXN0b21BdHRyaWJ1dGUoZWxUb29sdGlwLCB0cnVlKTtcblxuICAgICAgICB0aGlzLl9maXJlQmVmb3JlU2hvd1Rvb2x0aXAoaW5kZXhlcyk7XG5cbiAgICAgICAgZG9tLmFkZENsYXNzKGVsVG9vbHRpcCwgJ3Nob3cnKTtcblxuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX21ha2VUb29sdGlwUG9zaXRpb24odHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjogdGhpcy5nZXRUb29sdGlwRGltZW5zaW9uKGVsVG9vbHRpcCksXG4gICAgICAgICAgICBwb3NpdGlvbk9wdGlvbjogdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uKSxcbiAgICAgICAgICAgIGFsaWduT3B0aW9uOiB0aGlzLm9wdGlvbnMuYWxpZ24gfHwgJydcbiAgICAgICAgfSwgcGFyYW1zKSk7XG5cbiAgICAgICAgdGhpcy5fbW92ZVRvUG9zaXRpb24oZWxUb29sdGlwLCBwb3NpdGlvbiwgcHJldlBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fZmlyZVNob3dBbmltYXRpb24oaW5kZXhlcywgcGFyYW1zLmNoYXJ0VHlwZSk7XG4gICAgICAgIHRoaXMuX2ZpcmVBZnRlclNob3dUb29sdGlwKGluZGV4ZXMsIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsVG9vbHRpcCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBiZWZvcmVTaG93VG9vbHRpcCBjYWxsYmFjayBvZiB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUJlZm9yZVNob3dUb29sdGlwOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLl9tYWtlU2hvd1Rvb2x0aXBQYXJhbXMoaW5kZXhlcyk7XG5cbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnYmVmb3JlU2hvd1Rvb2x0aXAnLCBwYXJhbXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIGFmdGVyU2hvd1Rvb2x0aXAgY2FsbGJhY2sgb2YgdXNlckV2ZW50LlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhZGRpdGlvblBhcmFtcyBhZGRpdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUFmdGVyU2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKGluZGV4ZXMsIGFkZGl0aW9uUGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLl9tYWtlU2hvd1Rvb2x0aXBQYXJhbXMoaW5kZXhlcywgYWRkaXRpb25QYXJhbXMpO1xuXG4gICAgICAgIHRoaXMudXNlckV2ZW50LmZpcmUoJ2FmdGVyU2hvd1Rvb2x0aXAnLCBwYXJhbXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9vbHRpcEVsZW1lbnQgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlkZVRvb2x0aXA6IGZ1bmN0aW9uKHRvb2x0aXBFbGVtZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGluZGV4ZXMgPSB0aGlzLl9nZXRJbmRleGVzQ3VzdG9tQXR0cmlidXRlKHRvb2x0aXBFbGVtZW50KSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZSA9IHRvb2x0aXBFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jaGFydC10eXBlJyk7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc01vdXNlUG9zaXRpb25DaGFydChjaGFydFR5cGUpKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3ModG9vbHRpcEVsZW1lbnQsICdzaG93Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRTaG93ZWRDdXN0b21BdHRyaWJ1dGUodG9vbHRpcEVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVIaWRlQW5pbWF0aW9uKGluZGV4ZXMsIGNoYXJ0VHlwZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NoYW5nZWRJbmRleGVzKHRoaXMucHJldkluZGV4ZXMsIGluZGV4ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucHJldkluZGV4ZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2lzU2hvd2VkVG9vbHRpcCh0b29sdGlwRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyh0b29sdGlwRWxlbWVudCwgJ3Nob3cnKTtcbiAgICAgICAgICAgICAgICB0b29sdGlwRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gJyc7XG5cbiAgICAgICAgICAgICAgICBpbmRleGVzID0gbnVsbDtcbiAgICAgICAgICAgIH0sIGNoYXJ0Q29uc3QuSElERV9ERUxBWSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gc2hvdyB0b29sdGlwIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBvblNob3dUb29sdGlwQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50b29sdGlwQ29udGFpbmVyLnN0eWxlLnpJbmRleCA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9aSU5ERVg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGhpZGUgdG9vbHRpcCBjb250YWluZXIuXG4gICAgICovXG4gICAgb25IaWRlVG9vbHRpcENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcENvbnRhaW5lci5zdHlsZS56SW5kZXggPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXggaW4uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyB0YXJnZXQgZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgbWl4aW46IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKGZ1bmMucHJvdG90eXBlLCB0aGlzKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNpbmdsZVRvb2x0aXBNaXhlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUb29sdGlwIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRvb2x0aXBCYXNlID0gcmVxdWlyZSgnLi90b29sdGlwQmFzZScpO1xudmFyIHNpbmdsZVRvb2x0aXBNaXhlciA9IHJlcXVpcmUoJy4vc2luZ2xlVG9vbHRpcE1peGVyJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcbnZhciByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG52YXIgdG9vbHRpcFRlbXBsYXRlID0gcmVxdWlyZSgnLi90b29sdGlwVGVtcGxhdGUnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFRvb2x0aXAgY29tcG9uZW50LlxuICogQGNsYXNzIFRvb2x0aXBcbiAqL1xudmFyIFRvb2x0aXAgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhUb29sdGlwQmFzZSwgLyoqIEBsZW5kcyBUb29sdGlwLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogVG9vbHRpcCBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgVG9vbHRpcFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtCb3VuZHNNYWtlcn0gcGFyYW1zLmJvdW5kc01ha2VyIGJvdW5kcyBtYWtlclxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBheGlzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIFRvb2x0aXBCYXNlLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwIGh0bWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IGNhdGVnb3J5XG4gICAgICogQHBhcmFtIHt7dmFsdWU6IHN0cmluZywgbGVnZW5kOiBzdHJpbmcsIGNoYXJ0VHlwZTogc3RyaW5nLCBzdWZmaXg6ID9zdHJpbmd9fSBpdGVtIGl0ZW0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvb2x0aXAgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwSHRtbDogZnVuY3Rpb24oY2F0ZWdvcnksIGl0ZW0pIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNCdWJibGVDaGFydCh0aGlzLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gdG9vbHRpcFRlbXBsYXRlLnRwbEJ1YmJsZUNoYXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0b29sdGlwVGVtcGxhdGUudHBsRGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgY2F0ZWdvcnk6IGNhdGVnb3J5IHx8ICcnXG4gICAgICAgIH0sIGl0ZW0pKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBodG1sIGZvciB2YWx1ZSB0eXBlcyBsaWtlIHgsIHksIHJcbiAgICAgKiBAcGFyYW0ge3t4OiA/bnVtYmVyLCB5OiA/bnVtYmVyLCByOiA/bnVtYmVyfX0gZGF0YSAtIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSB2YWx1ZVR5cGVzIC0gdHlwZXMgb2YgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VIdG1sRm9yVmFsdWVUeXBlczogZnVuY3Rpb24oZGF0YSwgdmFsdWVUeXBlcykge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHZhbHVlVHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoZGF0YVt0eXBlXSkgPyAnPGRpdj4nICsgdHlwZSArICc6ICcgKyBkYXRhW3R5cGVdICsgJzwvZGl2PicgOiAnJztcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2luZ2xlIHRvb2x0aXAgaHRtbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0b29sdGlwIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2luZ2xlVG9vbHRpcEh0bWw6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgaW5kZXhlcykge1xuICAgICAgICB2YXIgZGF0YSA9IHR1aS51dGlsLnBpY2sodGhpcy5kYXRhLCBjaGFydFR5cGUsIGluZGV4ZXMuZ3JvdXBJbmRleCwgaW5kZXhlcy5pbmRleCk7XG5cbiAgICAgICAgZGF0YSA9IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBzdWZmaXg6IHRoaXMuc3VmZml4XG4gICAgICAgIH0sIGRhdGEpO1xuICAgICAgICBkYXRhLnZhbHVlVHlwZXMgPSB0aGlzLl9tYWtlSHRtbEZvclZhbHVlVHlwZXMoZGF0YSwgWyd4JywgJ3knLCAnciddKTtcblxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZUZ1bmMoZGF0YS5jYXRlZ29yeSwgZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IGFsaWduIG9wdGlvbiBvZiB0b29sdGlwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldERlZmF1bHRUb29sdGlwUG9zaXRpb25PcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsaWduKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9BTElHTl9PUFRJT047XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9IT1JJWk9OVEFMX0FMSUdOX09QVElPTjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBhcmFtZXRlcnMgZm9yIHNob3cgdG9vbHRpcCB1c2VyIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhZGRpdGlvblBhcmFtcyBhZGRpdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge3tjaGFydFR5cGU6IHN0cmluZywgbGVnZW5kOiBzdHJpbmcsIGxlZ2VuZEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBwYXJhbWV0ZXJzIGZvciBzaG93IHRvb2x0aXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2hvd1Rvb2x0aXBQYXJhbXM6IGZ1bmN0aW9uKGluZGV4ZXMsIGFkZGl0aW9uUGFyYW1zKSB7XG4gICAgICAgIHZhciBsZWdlbmRJbmRleCA9IGluZGV4ZXMuaW5kZXgsXG4gICAgICAgICAgICBsZWdlbmREYXRhID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldExlZ2VuZEl0ZW0obGVnZW5kSW5kZXgpLFxuICAgICAgICAgICAgcGFyYW1zO1xuXG4gICAgICAgIGlmICghbGVnZW5kRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogbGVnZW5kRGF0YS5jaGFydFR5cGUsXG4gICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZERhdGEubGFiZWwsXG4gICAgICAgICAgICBsZWdlbmRJbmRleDogbGVnZW5kSW5kZXgsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhlcy5ncm91cEluZGV4XG4gICAgICAgIH0sIGFkZGl0aW9uUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHZhbHVlIG9mIHZhbHVlTWFwXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlTWFwIC0gbWFwIG9mIHZhbHVlIGxpa2UgdmFsdWUsIHgsIHksIHJcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZm9ybWF0VmFsdWVNYXA6IGZ1bmN0aW9uKHZhbHVlTWFwKSB7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZU1hcCA9IHt9O1xuICAgICAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2godmFsdWVNYXAsIGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlTWFwW3ZhbHVlVHlwZV0gPSByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKHZhbHVlLCBmb3JtYXRGdW5jdGlvbnMsICd0b29sdGlwJywgdmFsdWVUeXBlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFZhbHVlTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvb2x0aXAgZGF0dW0uXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGVnZW5kTGFiZWxzIC0gbGVnZW5kIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSAtIGNhdGVnb3J5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge1Nlcmllc0l0ZW19IHNlcmllc0l0ZW0gLSBTZXJpZXNJdGVtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwRGF0dW06IGZ1bmN0aW9uKGxlZ2VuZExhYmVscywgY2F0ZWdvcnksIGNoYXJ0VHlwZSwgc2VyaWVzSXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxlZ2VuZCA9IGxlZ2VuZExhYmVsc1tjaGFydFR5cGVdW2luZGV4XTtcblxuICAgICAgICB2YXIgbGFiZWxQcmVmaXggPSAobGVnZW5kICYmIHNlcmllc0l0ZW0ubGFiZWwpID8gJzombmJzcDsnIDogJyc7XG4gICAgICAgIHZhciBsYWJlbCA9IHNlcmllc0l0ZW0ubGFiZWwgPyBsYWJlbFByZWZpeCArIHNlcmllc0l0ZW0ubGFiZWwgOiAnJztcbiAgICAgICAgdmFyIHZhbHVlTWFwID0gdGhpcy5fZm9ybWF0VmFsdWVNYXAoc2VyaWVzSXRlbS5waWNrVmFsdWVNYXAoKSk7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcnksXG4gICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZCxcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICB9LCB2YWx1ZU1hcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gdG9vbHRpcCBkYXRhXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGNhdGVnb3JpZXMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Q2F0ZWdvcmllcygpLFxuICAgICAgICAgICAgb3JnTGVnZW5kTGFiZWxzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldExlZ2VuZExhYmVscygpLFxuICAgICAgICAgICAgbGVnZW5kTGFiZWxzID0ge30sXG4gICAgICAgICAgICB0b29sdGlwRGF0YSA9IHt9O1xuXG4gICAgICAgIGlmICh0dWkudXRpbC5pc0FycmF5KG9yZ0xlZ2VuZExhYmVscykpIHtcbiAgICAgICAgICAgIGxlZ2VuZExhYmVsc1t0aGlzLmNoYXJ0VHlwZV0gPSBvcmdMZWdlbmRMYWJlbHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWdlbmRMYWJlbHMgPSBvcmdMZWdlbmRMYWJlbHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IuZWFjaEJ5U2VyaWVzR3JvdXAoZnVuY3Rpb24oc2VyaWVzR3JvdXAsIGdyb3VwSW5kZXgsIGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5ID0gY2F0ZWdvcmllc1tncm91cEluZGV4XSB8fCAnJztcbiAgICAgICAgICAgIHZhciBkYXRhO1xuXG4gICAgICAgICAgICBjaGFydFR5cGUgPSBjaGFydFR5cGUgfHwgc2VsZi5jaGFydFR5cGU7XG5cbiAgICAgICAgICAgIGRhdGEgPSBzZXJpZXNHcm91cC5tYXAoZnVuY3Rpb24oc2VyaWVzSXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzSXRlbSA/IHNlbGYuX21ha2VUb29sdGlwRGF0dW0obGVnZW5kTGFiZWxzLCBjYXRlZ29yeSwgY2hhcnRUeXBlLCBzZXJpZXNJdGVtLCBpbmRleCkgOiBudWxsO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghdG9vbHRpcERhdGFbY2hhcnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBEYXRhW2NoYXJ0VHlwZV0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9vbHRpcERhdGFbY2hhcnRUeXBlXS5wdXNoKGRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdG9vbHRpcERhdGE7XG4gICAgfVxufSk7XG5cbnNpbmdsZVRvb2x0aXBNaXhlci5taXhpbihUb29sdGlwKTtcbm1vZHVsZS5leHBvcnRzID0gVG9vbHRpcDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUb29sdGlwQmFzZSBpcyBiYXNlIGNsYXNzIG9mIHRvb2x0aXAgY29tcG9uZW50cy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgVG9vbHRpcEJhc2UgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFRvb2x0aXBCYXNlLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogVG9vbHRpcEJhc2UgaXMgYmFzZSBjbGFzcyBvZiB0b29sdGlwIGNvbXBvbmVudHMuXG4gICAgICogQGNvbnN0cnVjdHMgVG9vbHRpcEJhc2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBhcmFtcy52YWx1ZXMgY29udmVydGVkIHZhbHVlc1xuICAgICAqICAgICAgQHBhcmFtIHtCb3VuZHNNYWtlcn0gcGFyYW1zLmJvdW5kc01ha2VyIGJvdW5kcyBtYWtlclxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBheGlzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpc1BpZUNoYXJ0ID0gcHJlZGljYXRlLmlzUGllQ2hhcnQocGFyYW1zLmNoYXJ0VHlwZSk7XG5cbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbGFzc05hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jaGFydC10b29sdGlwLWFyZWEnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb29sdGlwIGNvbnRhaW5lci5cbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b29sdGlwQ29udGFpbmVyID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG9vbHRpcCBzdWZmaXguXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHRoaXMub3B0aW9ucy5zdWZmaXggPyAnJm5ic3A7JyArIHRoaXMub3B0aW9ucy5zdWZmaXggOiAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG9vbHRpcCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZW1wbGF0ZUZ1bmMgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUgfHwgdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlVG9vbHRpcEh0bWwsIHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb29sdGlwIGFuaW1hdGlvbiB0aW1lLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb25UaW1lID0gaXNQaWVDaGFydCA/IGNoYXJ0Q29uc3QuVE9PTFRJUF9QSUVfQU5JTUFUSU9OX1RJTUUgOiBjaGFydENvbnN0LlRPT0xUSVBfQU5JTUFUSU9OX1RJTUU7XG5cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb29sdGlwQmFzZSBiYXNlIGRhdGEuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gW107XG5cbiAgICAgICAgdGhpcy5fc2V0RGVmYXVsdFRvb2x0aXBQb3NpdGlvbk9wdGlvbigpO1xuICAgICAgICB0aGlzLl9zYXZlT3JpZ2luYWxQb3NpdGlvbk9wdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwIGh0bWwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBIdG1sOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlZmF1bHQgYWxpZ24gb3B0aW9uIG9mIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfc2V0RGVmYXVsdFRvb2x0aXBQb3NpdGlvbk9wdGlvbjogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFNhdmUgcG9zaXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zYXZlT3JpZ2luYWxQb3NpdGlvbk9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9yZ1Bvc2l0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFsaWduOiB0aGlzLm9wdGlvbnMuYWxpZ24sXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX21ha2VUb29sdGlwRGF0YTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0b29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRvb2x0aXAgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKTtcblxuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLl9tYWtlVG9vbHRpcERhdGEoKTtcblxuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGVsLCB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKCd0b29sdGlwJykpO1xuXG4gICAgICAgIHRoaXMudG9vbHRpcENvbnRhaW5lciA9IGVsO1xuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVyZW5kZXIuXG4gICAgICovXG4gICAgcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLl9tYWtlVG9vbHRpcERhdGEoKTtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25Nb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbk1vZGVsLnVwZGF0ZUJvdW5kKHRoaXMuYm91bmRzTWFrZXIuZ2V0Qm91bmQoJ3Rvb2x0aXAnKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHRvb2x0aXAgY29tcG9uZW50LlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24odGhpcy50b29sdGlwQ29udGFpbmVyLCB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKCd0b29sdGlwJykpO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uTW9kZWwudXBkYXRlQm91bmQodGhpcy5ib3VuZHNNYWtlci5nZXRCb3VuZCgndG9vbHRpcCcpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdG9vbHRpcCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0VG9vbHRpcEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG9vbHRpcEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXBFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBFbGVtZW50ID0gdG9vbHRpcEVsZW1lbnQgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LXRvb2x0aXAnKTtcbiAgICAgICAgICAgIGRvbS5hcHBlbmQodGhpcy50b29sdGlwQ29udGFpbmVyLCB0b29sdGlwRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwRWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogb25TaG93IGlzIGNhbGxiYWNrIG9mIGN1c3RvbSBldmVudCBzaG93VG9vbHRpcCBmb3IgU2VyaWVzVmlldy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIGNvb3JkaW5hdGUgZXZlbnQgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIG9uU2hvdzogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB0b29sdGlwRWxlbWVudCA9IHRoaXMuX2dldFRvb2x0aXBFbGVtZW50KCksXG4gICAgICAgICAgICBwcmV2UG9zaXRpb247XG5cbiAgICAgICAgaWYgKCFwcmVkaWNhdGUuaXNNb3VzZVBvc2l0aW9uQ2hhcnQocGFyYW1zLmNoYXJ0VHlwZSkgJiYgdG9vbHRpcEVsZW1lbnQub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgIHByZXZQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0b29sdGlwRWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogdG9vbHRpcEVsZW1lbnQub2Zmc2V0VG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXAodG9vbHRpcEVsZW1lbnQsIHBhcmFtcywgcHJldlBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9vbHRpcEVsZW1lbnQgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHJlbmRlcmVkIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICovXG4gICAgZ2V0VG9vbHRpcERpbWVuc2lvbjogZnVuY3Rpb24odG9vbHRpcEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0b29sdGlwRWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdG9vbHRpcEVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gUG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9vbHRpcEVsZW1lbnQgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHByZXZQb3NpdGlvbiBwcmV2IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW92ZVRvUG9zaXRpb246IGZ1bmN0aW9uKHRvb2x0aXBFbGVtZW50LCBwb3NpdGlvbiwgcHJldlBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwcmV2UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3NsaWRlVG9vbHRpcCh0b29sdGlwRWxlbWVudCwgcHJldlBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKHRvb2x0aXBFbGVtZW50LCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2xpZGUgdG9vbHRpcFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvb2x0aXBFbGVtZW50IHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2UG9zaXRpb24gcHJldiBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NsaWRlVG9vbHRpcDogZnVuY3Rpb24odG9vbHRpcEVsZW1lbnQsIHByZXZQb3NpdGlvbiwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIG1vdmVUb3AgPSBwb3NpdGlvbi50b3AgLSBwcmV2UG9zaXRpb24udG9wLFxuICAgICAgICAgICAgbW92ZUxlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gcHJldlBvc2l0aW9uLmxlZnQ7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5jYW5jZWxBbmltYXRpb24odGhpcy5zbGlkaW5nQW5pbWF0aW9uKTtcblxuICAgICAgICB0aGlzLnNsaWRpbmdBbmltYXRpb24gPSByZW5kZXJVdGlsLnN0YXJ0QW5pbWF0aW9uKHRoaXMuYW5pbWF0aW9uVGltZSwgZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbW92ZUxlZnQgKiByYXRpbyxcbiAgICAgICAgICAgICAgICB0b3AgPSBtb3ZlVG9wICogcmF0aW87XG4gICAgICAgICAgICB0b29sdGlwRWxlbWVudC5zdHlsZS5sZWZ0ID0gKHByZXZQb3NpdGlvbi5sZWZ0ICsgbGVmdCkgKyAncHgnO1xuICAgICAgICAgICAgdG9vbHRpcEVsZW1lbnQuc3R5bGUudG9wID0gKHByZXZQb3NpdGlvbi50b3AgKyB0b3ApICsgJ3B4JztcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG9uSGlkZSBpcyBjYWxsYmFjayBvZiBjdXN0b20gZXZlbnQgaGlkZVRvb2x0aXAgZm9yIFNlcmllc1ZpZXdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBvbkhpZGU6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciB0b29sdGlwRWxlbWVudCA9IHRoaXMuX2dldFRvb2x0aXBFbGVtZW50KCk7XG5cbiAgICAgICAgdGhpcy5faGlkZVRvb2x0aXAodG9vbHRpcEVsZW1lbnQsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvb2x0aXAgYWxpZ24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbiBhbGlnblxuICAgICAqL1xuICAgIHNldEFsaWduOiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBhbGlnbjtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25Nb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbk1vZGVsLnVwZGF0ZU9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgcG9zaXRpb24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3ZpbmcgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uID0gdHVpLnV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24sIHBvc2l0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25Nb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbk1vZGVsLnVwZGF0ZU9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0b29sdGlwIGFsaWduIG9wdGlvbi5cbiAgICAgKi9cbiAgICByZXNldEFsaWduOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFsaWduID0gdGhpcy5vcmdQb3NpdGlvbk9wdGlvbnMuYWxpZ247XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmFsaWduID0gYWxpZ247XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbC51cGRhdGVPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdG9vbHRpcCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICByZXNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5vcmdQb3NpdGlvbk9wdGlvbnMucG9zaXRpb247XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbC51cGRhdGVPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFRvb2x0aXBCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb29sdGlwQmFzZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIHRlbXBsYXRlcyBvZiB0b29sdGlwLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVtcGxhdGVNYWtlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdGVtcGxhdGVNYWtlcicpO1xuXG52YXIgaHRtbHMgPSB7XG4gICAgSFRNTF9ERUZBVUxUX1RFTVBMQVRFOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1kZWZhdWx0LXRvb2x0aXBcIj4nICtcbiAgICAgICAgJzxkaXY+e3sgY2F0ZWdvcnkgfX08L2Rpdj4nICtcbiAgICAgICAgJzxkaXY+JyArXG4gICAgICAgICAgICAnPHNwYW4+e3sgbGVnZW5kIH19PC9zcGFuPicgK1xuICAgICAgICAgICAgJzxzcGFuPnt7IGxhYmVsIH19PC9zcGFuPicgK1xuICAgICAgICAgICAgJzxzcGFuPnt7IHN1ZmZpeCB9fTwvc3Bhbj4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICc8L2Rpdj4nLFxuICAgIEhUTUxfQlVCQkxFX0NIQVJUX1RFTVBMQVRFOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1kZWZhdWx0LXRvb2x0aXBcIj4nICtcbiAgICAgICAgJzxkaXY+e3sgY2F0ZWdvcnkgfX08L2Rpdj4nICtcbiAgICAgICAgJzxkaXY+JyArXG4gICAgICAgICAgICAnPHNwYW4+e3sgbGVnZW5kIH19PC9zcGFuPicgK1xuICAgICAgICAgICAgJzxzcGFuPnt7IGxhYmVsIH19PC9zcGFuPicgK1xuICAgICAgICAnPC9kaXY+e3sgdmFsdWVUeXBlcyB9fScgK1xuICAgICc8L2Rpdj4nLFxuICAgIEhUTUxfR1JPVVA6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LWRlZmF1bHQtdG9vbHRpcCB0dWktY2hhcnQtZ3JvdXAtdG9vbHRpcFwiPicgK1xuICAgICAgICAnPGRpdj57eyBjYXRlZ29yeSB9fTwvZGl2PicgK1xuICAgICAgICAne3sgaXRlbXMgfX0nICtcbiAgICAnPC9kaXY+JyxcbiAgICBIVE1MX0dST1VQX0lURU06ICc8ZGl2PicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1sZWdlbmQtcmVjdCB7eyBjaGFydFR5cGUgfX1cIiBzdHlsZT1cInt7IGNzc1RleHQgfX1cIj48L2Rpdj4nICtcbiAgICAgICAgJyZuYnNwOzxzcGFuPnt7IGxlZ2VuZCB9fTwvc3Bhbj46Jm5ic3A7PHNwYW4+e3sgdmFsdWUgfX08L3NwYW4+JyArXG4gICAgICAgICc8c3Bhbj57eyBzdWZmaXggfX08L3NwYW4+JyArXG4gICAgJzwvZGl2PicsXG4gICAgR1JPVVBfQ1NTX1RFWFQ6ICdiYWNrZ3JvdW5kLWNvbG9yOnt7IGNvbG9yIH19JyxcbiAgICBIVE1MX01BUF9DSEFSVF9ERUZBVUxUX1RFTVBMQVRFOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1kZWZhdWx0LXRvb2x0aXBcIj4nICtcbiAgICAgICAgJzxkaXY+e3sgbmFtZSB9fToge3sgdmFsdWUgfX17eyBzdWZmaXggfX08L2Rpdj4nICtcbiAgICAnPC9kaXY+J1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdHBsRGVmYXVsdDogdGVtcGxhdGVNYWtlci50ZW1wbGF0ZShodG1scy5IVE1MX0RFRkFVTFRfVEVNUExBVEUpLFxuICAgIHRwbEJ1YmJsZUNoYXJ0OiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfQlVCQkxFX0NIQVJUX1RFTVBMQVRFKSxcbiAgICB0cGxHcm91cDogdGVtcGxhdGVNYWtlci50ZW1wbGF0ZShodG1scy5IVE1MX0dST1VQKSxcbiAgICB0cGxHcm91cEl0ZW06IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9HUk9VUF9JVEVNKSxcbiAgICB0cGxHcm91cENzc1RleHQ6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuR1JPVVBfQ1NTX1RFWFQpLFxuICAgIHRwbE1hcENoYXJ0RGVmYXVsdDogdGVtcGxhdGVNYWtlci50ZW1wbGF0ZShodG1scy5IVE1MX01BUF9DSEFSVF9ERUZBVUxUX1RFTVBMQVRFKVxufTtcbiJdfQ==
