(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @fileoverview  Axis component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('../helpers/domHandler');
var chartConst = require('../const');
var predicate = require('../helpers/predicate');
var calculator = require('../helpers/calculator');
var renderUtil = require('../helpers/renderUtil');
var axisTemplate = require('./axisTemplate');

var Axis = tui.util.defineClass(/** @lends Axis.prototype */ {
    /**
     * Axis component.
     * @constructs Axis
     * @param {object} params parameters
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     *      @param {object} params.options axis options
     */
    init: function(params) {
        /**
         * Axis view className
         * @type {string}
         */
        this.className = 'tui-chart-axis-area';

        /**
         * Chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * Data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * Theme
         * @type {object}
         */
        this.theme = params.theme || {};

        /**
         * Whether label type or not.
         * @type {boolean}
         */
        this.isLabel = params.isLabel;

        /**
         * Whether vertical type or not.
         */
        this.isVertical = params.isVertical;

        /**
         * Data for rendering
         * @type {object}
         */
        this.data = {};
    },

    /**
     * Make height of x axis area.
     * @returns {number} height
     * @private
     */
    _makeXAxisHeight: function() {
        var title = this.options.title;
        var titleHeight = renderUtil.getRenderedLabelHeight(title, this.theme.title);
        var titleAreaHeight = titleHeight ? (titleHeight + chartConst.TITLE_PADDING) : 0;
        var labelHeight = renderUtil.getRenderedLabelHeight(chartConst.MAX_HEIGHT_WORLD, this.theme.label);

        return titleAreaHeight + labelHeight + chartConst.CHART_PADDING;
    },

    /**
     * Make width of y axis area.
     * @param {Array.<string | number>} labels labels
     * @param {{title: ?string, isCenter: ?boolean, rotateTitle: ?boolean}} options - options
     * @returns {number}
     * @private
     */
    _makeYAxisWidth: function(labels, options) {
        var title = options.title || '';
        var theme = this.theme;
        var titleAreaWidth = 0;
        var width = 0;

        if (options.isCenter) {
            width += chartConst.AXIS_LABEL_PADDING;
        } else if (options.rotateTitle === false) {
            titleAreaWidth = renderUtil.getRenderedLabelWidth(title, theme.title) + chartConst.TITLE_PADDING;
        } else {
            titleAreaWidth = renderUtil.getRenderedLabelHeight(title, theme.title) + chartConst.TITLE_PADDING;
        }

        width += renderUtil.getRenderedLabelsMaxWidth(labels, theme.label) + titleAreaWidth +
            chartConst.AXIS_LABEL_PADDING;

        return width;
    },

    /**
     * Whether valid axis or not.
     * @returns {boolean} whether valid axis or not.
     * @private
     */
    _isValidAxis: function() {
        var isValid = true;

        if (this.componentName === 'rightYAxis') {
            isValid = this.dataProcessor.isValidAllSeriesDataModel();
        }

        return isValid;
    },

    /**
     * Register legend dimension to boundsMaker.
     */
    registerDimension: function() {
        var dimension = {};
        var categories;

        if (!this._isValidAxis()) {
            return;
        }

        if (this.componentType === 'xAxis') {
            dimension.height = this._makeXAxisHeight();
            this.boundsMaker.registerBaseDimension(this.componentName, dimension);
        } else if (this.isLabel) {
            categories = this.dataProcessor.getCategories(this.isVertical);
            dimension.width = this._makeYAxisWidth(categories, this.options);
            this.boundsMaker.registerBaseDimension(this.componentName, dimension);
        }
    },

    /**
     * Register legend additional dimension to boundsMaker.
     */
    registerAdditionalDimension: function() {
        var axesData = this.boundsMaker.axesData;
        var dimension, options;

        if (!this._isValidAxis()) {
            return;
        }

        if ((this.componentType === 'yAxis') && !this.isLabel) {
            if (this.componentName === 'rightYAxis') {
                options = this.options;
            } else {
                options = axesData.yAxis.options;
            }

            dimension = {
                width: this._makeYAxisWidth(axesData.yAxis.labels, options)
            };

            this.boundsMaker.registerBaseDimension(this.componentName, dimension);
        }
    },

    /**
     * Render opposite side tick area.
     * @param {string} tickHtml tick html
     * @returns {?HTMLElement} right tick area element
     * @private
     */
    _renderOppositeSideTickArea: function(tickHtml) {
        var tickContainer;

        if (this.options.isCenter) {
            tickContainer = dom.create('DIV', 'tui-chart-tick-area opposite-side');
            tickContainer.innerHTML = tickHtml;
        }

        return tickContainer;
    },

    /**
     * Add css classes.
     * @param {HTMLElement} axisContainer axis container
     * @private
     */
    _addCssClasses: function(axisContainer) {
        dom.addClass(axisContainer, this.isVertical ? 'vertical' : 'horizontal');
        dom.addClass(axisContainer, this.options.isCenter ? 'center' : '');
        dom.addClass(axisContainer, this.options.divided ? 'division' : '');
        dom.addClass(axisContainer, this.data.isPositionRight ? 'right' : '');
    },


    /**
     * Render child containers like title area, label area and tick area.
     * @param {number} size xAxis width or yAxis height
     * @param {number} width axis width
     * @param {number} tickCount tick count
     * @param {Array.<number|string>} categories categories
     * @param {number} additionalWidth additional width
     * @returns {Array.<HTMLElement>} child containers
     * @private
     */
    _renderChildContainers: function(size, width, tickCount, categories, additionalWidth) {
        var titleContainer = this._renderTitleArea(size),
            labelContainer = this._renderLabelArea(size, width, tickCount, categories, additionalWidth),
            childContainers = [titleContainer, labelContainer],
            isVerticalLineType = this.isVertical && this.data.aligned,
            tickContainer, oppositeSideTickContainer;

        if (!isVerticalLineType) {
            tickContainer = this._renderTickArea(size, tickCount, additionalWidth);
            oppositeSideTickContainer = this._renderOppositeSideTickArea(tickContainer.innerHTML);
            childContainers = childContainers.concat([tickContainer, oppositeSideTickContainer]);
        }

        return childContainers;
    },

    /**
     * Render divided xAxis if yAxis rendered in the center.
     * @param {HTMLElement} axisContainer axis container element
     * @param {number} width axis area width
     * @private
     */
    _renderDividedAxis: function(axisContainer, width) {
        var lWidth = Math.round(width / 2);
        var rWidth = width - lWidth;
        var tickCount = this.data.tickCount;
        var halfTickCount = parseInt(tickCount / 2, 10) + 1;
        var categories = this.data.labels;
        var lCategories = categories.slice(0, halfTickCount);
        var rCategories = categories.slice(halfTickCount - 1, tickCount);
        var additionalWidth = lWidth + this.boundsMaker.getDimension('yAxis').width;
        var lContainers = this._renderChildContainers(lWidth, lWidth, halfTickCount, lCategories);
        var rContainers = this._renderChildContainers(rWidth, rWidth, halfTickCount, rCategories, additionalWidth);
        var rTitleContainer = rContainers[0];

        dom.addClass(rTitleContainer, 'right');
        dom.append(axisContainer, lContainers.concat(rContainers));
    },

    /**
     * Render single axis if not divided.
     * @param {HTMLElement} axisContainer axis container element
     * @param {{width: number, height: number}} dimension axis area dimension
     * @private
     */
    _renderNotDividedAxis: function(axisContainer, dimension) {
        var data = this.data;
        var isVertical = this.isVertical;
        var width = dimension.width;
        var size = isVertical ? dimension.height : width;
        var additionalSize = 0;
        var childContainers;

        if (data.positionRatio) {
            additionalSize = size * data.positionRatio;
        }

        childContainers = this._renderChildContainers(size, width, data.tickCount, data.labels, additionalSize);

        dom.append(axisContainer, childContainers);
    },

    /**
     * Render axis area.
     * @param {HTMLElement} axisContainer axis area element
     * @param {{isVertical: boolean, isPositionRight: boolean, aligned: aligned}} data rendering data
     * @private
     */
    _renderAxisArea: function(axisContainer) {
        var dimension = tui.util.extend({}, this.boundsMaker.getDimension(this.componentName));

        this._addCssClasses(axisContainer);

        if (this.options.divided) {
            this.containerWidth = dimension.width + this.boundsMaker.getDimension('yAxis').width;
            this._renderDividedAxis(axisContainer, dimension.width);
            dimension.width = this.containerWidth;
        } else {
            this._renderNotDividedAxis(axisContainer, dimension);
            dimension.width += this.options.isCenter ? 2 : 0;
        }

        renderUtil.renderDimension(axisContainer, dimension);
        renderUtil.renderPosition(axisContainer, this.boundsMaker.getPosition(this.componentName));
    },

    /**
     * Render axis component.
     * @param {{isPositionRight: boolean, aligned: aligned}} data rendering data
     * @returns {HTMLElement} axis area base element
     */
    render: function(data) {
        var container = dom.create('DIV', this.className);

        this.data = data;
        this._renderAxisArea(container);
        this.axisContainer = container;

        return container;
    },

    /**
     * Rerender axis component.
     * @param {object} data - data for rendering
     */
    rerender: function(data) {
        this.axisContainer.innerHTML = '';

        if (this._isValidAxis()) {
            if (data.options) {
                this.options = data.options;
            }
            this.data = data;
            this._renderAxisArea(this.axisContainer);
        }
    },

    /**
     * Resize axis component.
     * @param {object} data - data for rendering
     */
    resize: function(data) {
        this.rerender(data);
    },

    /**
     * Zoom.
     * @param {object} data - data for rendering
     */
    zoom: function(data) {
        this.rerender(data);
    },

    /**
     * Move axis to left.
     * @param {number} tickSize - tick size for moving
     * @private
     */
    _moveToLeft: function(tickSize) {
        var ticksElement = this.ticksElement;
        var firstTickElement = ticksElement.firstChild;
        var labelContainer = this.labelContainer;
        var firstLabelElement = labelContainer.firstChild;
        var ticksBeforeLeft = parseInt(ticksElement.style.left, 10) || 0;
        var labelBeforeLeft = parseInt(labelContainer.style.left, 10) || 0;
        var startIndex = this.data.startIndex || 0;

        renderUtil.startAnimation(300, function(ratio) {
            var left = tickSize * ratio;
            var opacity = 1 - ratio;

            ticksElement.style.left = (ticksBeforeLeft - left) + 'px';
            labelContainer.style.left = (labelBeforeLeft - left) + 'px';

            if (startIndex === 0) {
                renderUtil.setOpacity([firstTickElement, firstLabelElement], opacity);
            }
        });
    },

    /**
     * Resize by tick size.
     * @param {number} tickSize - tick size for resizing
     * @private
     */
    _resizeByTickSize: function(tickSize) {
        var ticksElement = this.ticksElement;
        var labelContainer = this.labelContainer;
        var beforeWidth = parseInt(ticksElement.style.width, 10) || ticksElement.offsetWidth;

        renderUtil.startAnimation(300, function(ratio) {
            var width = beforeWidth - (tickSize * ratio);

            ticksElement.style.width = width + 'px';
            labelContainer.style.width = width + 'px';
        });
    },

    /**
     * Animate for adding data.
     * @param {{tickSize: number}} data - data for animate
     */
    animateForAddingData: function(data) {
        if (this.isVertical) {
            return;
        }

        if (data.shifting) {
            this._moveToLeft(data.tickSize);
        } else {
            this._resizeByTickSize(data.tickSize);
        }
    },

    /**
     * Make cssText from position map for css.
     * @param {object.<string, number>} positionMap - position map for css
     * @returns {string}
     * @private
     */
    _makeCssTextFromPositionMap: function(positionMap) {
        tui.util.forEach(positionMap, function(value, name) {
            positionMap[name] = value + 'px';
        });

        return renderUtil.makeCssTextFromMap(positionMap);
    },

    /**
     * Make position map for center align option of y axis.
     * @returns {{left: number, bottom: number}}
     * @private
     */
    _makePositionMapForCenterAlign: function() {
        var titleWidth = renderUtil.getRenderedLabelWidth(this.options.title, this.theme.title);
        var yAxisWidth = this.boundsMaker.getDimension('yAxis').width;
        var xAxisHeight = this.boundsMaker.getDimension('xAxis').height;

        return {
            left: (yAxisWidth - titleWidth) / 2,
            bottom: -xAxisHeight
        };
    },

    /**
     * Make right position for right y axis.
     * @param {number} size - width or height
     * @returns {number}
     * @private
     */
    _makeRightPosition: function(size) {
        var rightPosition;

        if (renderUtil.isIE7() || this.options.rotateTitle === false) {
            rightPosition = 0;
        } else {
            rightPosition = -size;
        }

        return rightPosition;
    },

    /**
     * Make top position.
     * @param {number} size - width or height
     * @returns {?number}
     * @private
     */
    _makeTopPosition: function(size) {
        var topPosition = null;
        var titleHeight;

        if (this.options.rotateTitle === false) {
            titleHeight = renderUtil.getRenderedLabelHeight(this.options.title, this.theme.title);
            topPosition = (size - titleHeight) / 2;
        } else if (this.data.isPositionRight) {
            topPosition = 0;
        } else if (!renderUtil.isOldBrowser()) {
            topPosition = size;
        }

        return topPosition;
    },

    /**
     * Make positionMap for not center align.
     * @param {number} size - width or height
     * @returns {object.<string, number>}
     * @private
     */
    _makePositionMapForNotCenterAlign: function(size) {
        var positionMap = {};
        var topPosition;

        if (this.data.isPositionRight) {
            positionMap.right = this._makeRightPosition(size);
        } else {
            positionMap.left = 0;
        }

        topPosition = this._makeTopPosition(size);

        if (!tui.util.isNull(topPosition)) {
            positionMap.top = topPosition;
        }

        return positionMap;
    },

    /**
     * Render css style of title area
     * @param {HTMLElement} titleContainer title element
     * @param {number} size width or height
     * @private
     */
    _renderTitleAreaStyle: function(titleContainer, size) {
        var cssPositionMap;
        var cssText;

        if (this.options.isCenter) {
            cssPositionMap = this._makePositionMapForCenterAlign();
        } else {
            cssPositionMap = this._makePositionMapForNotCenterAlign(size);
        }

        if (this.options.rotateTitle !== false) {
            cssPositionMap.width = size;
        }

        cssText = this._makeCssTextFromPositionMap(cssPositionMap);
        titleContainer.style.cssText += ';' + cssText;
    },

    /**
     * Title area renderer
     * @param {?number} size (width or height)
     * @returns {HTMLElement} title element
     * @private
     */
    _renderTitleArea: function(size) {
        var titleContainer = renderUtil.renderTitle(this.options.title, this.theme.title, 'tui-chart-title-area');

        if (titleContainer && this.isVertical) {
            this._renderTitleAreaStyle(titleContainer, size);
        }

        if (this.options.rotateTitle !== false) {
            dom.addClass(titleContainer, 'rotation');
        }

        return titleContainer;
    },

    /**
     * Make tick line html.
     * @param {number} areaSize - area size (width or height)
     * @param {string} posType - position type
     * @param {boolean} isNotDividedXAxis - whether not divided xAxis or not
     * @param {number} additionalSize - additional size
     * @returns {string}
     * @private
     */
    _makeTickLineHtml: function(areaSize, posType, isNotDividedXAxis, additionalSize) {
        var tickLineExtend = isNotDividedXAxis ? chartConst.OVERLAPPING_WIDTH : 0;
        var linePositionValue = -tickLineExtend;
        var lineSize, html;

        if (this.data.lineWidth) {
            lineSize = this.data.lineWidth;
        } else {
            lineSize = areaSize + tickLineExtend;
            linePositionValue += additionalSize;
        }

        html = axisTemplate.tplTickLine({
            positionType: posType,
            positionValue: linePositionValue,
            sizeType: this.isVertical ? 'height' : 'width',
            size: lineSize
        });

        return html;
    },

    /**
     * Make percentage position.
     * @param {Array.<number>} positions - positions
     * @param {number} areaSize - area size
     * @returns {Array.<number>}
     * @private
     */
    _makePercentagePositions: function(positions, areaSize) {
        areaSize = this.containerWidth || areaSize;

        return tui.util.map(positions, function(position) {
            return calculator.makePercentageValue(position, areaSize);
        });
    },

    /**
     * Make tick html.
     * @param {number} size - area size
     * @param {number} tickCount - tick count
     * @param {boolean} isNotDividedXAxis - whether not divided xAxis or not
     * @param {number} additionalSize - additional size
     * @returns {string}
     * @private
     */
    _makeTickHtml: function(size, tickCount, isNotDividedXAxis, additionalSize) {
        var tickColor = this.theme.tickColor;
        var sizeRatio = this.data.sizeRatio || 1;
        var posType = this.isVertical ? 'bottom' : 'left';
        var positions = calculator.makeTickPixelPositions((size * sizeRatio), tickCount);
        var containerWidth = this.containerWidth || size;
        var template, html;

        positions.length = this.data.labels.length;

        additionalSize = calculator.makePercentageValue(additionalSize, containerWidth);
        positions = this._makePercentagePositions(positions, size);

        template = axisTemplate.tplAxisTick;
        html = tui.util.map(positions, function(position, index) {
            var tickHtml, cssTexts;

            position -= (index === 0 && isNotDividedXAxis) ? calculator.makePercentageValue(1, containerWidth) : 0;

            cssTexts = [
                renderUtil.concatStr('background-color:', tickColor),
                renderUtil.concatStr(posType, ': ', additionalSize + position, '%')
            ].join(';');
            tickHtml = template({cssText: cssTexts});

            return tickHtml;
        }).join('');

        return html;
    },

    /**
     * Render tick line.
     * @param {number} areaSize - width or height
     * @param {boolean} isNotDividedXAxis - whether is not divided x axis or not.
     * @param {number} additionalSize - additional size
     * @returns {HTMLElement}
     * @private
     */
    _renderTickLine: function(areaSize, isNotDividedXAxis, additionalSize) {
        var tickLineElement = dom.create('DIV', 'tui-chart-tick-line');
        var tickLineExtend = isNotDividedXAxis ? chartConst.OVERLAPPING_WIDTH : 0;
        var positionValue = -tickLineExtend;
        var cssMap = {};
        var sizeType, posType, lineSize;

        if (this.isVertical) {
            sizeType = 'height';
            posType = 'bottom';
        } else {
            sizeType = 'width';
            posType = 'left';
        }

        if (this.data.lineWidth) {
            lineSize = this.data.lineWidth;
        } else {
            lineSize = areaSize + tickLineExtend;
            positionValue += additionalSize;
        }

        cssMap[posType] = positionValue;
        cssMap[sizeType] = lineSize;

        tickLineElement.style.cssText = this._makeCssTextFromPositionMap(cssMap);

        return tickLineElement;
    },

    /**
     * Render ticks.
     * @param {number} areaSize - width or height
     * @param {number} tickCount - tick count
     * @param {boolean} isNotDividedXAxis - whether is not divided x axis or not.
     * @param {number} additionalSize - additional size
     * @returns {HTMLElement}
     * @private
     */
    _renderTicks: function(areaSize, tickCount, isNotDividedXAxis, additionalSize) {
        var ticksElement = dom.create('DIV', 'tui-chart-ticks');
        var ticksHtml = this._makeTickHtml(areaSize, tickCount, isNotDividedXAxis, additionalSize);

        ticksElement.innerHTML = ticksHtml;

        return ticksElement;
    },

    /**
     * Render tick area.
     * @param {number} size - width or height
     * @param {number} tickCount - tick count
     * @param {?number} additionalSize - additional size (width or height)
     * @returns {HTMLElement}
     * @private
     */
    _renderTickArea: function(size, tickCount, additionalSize) {
        var tickContainer = dom.create('DIV', 'tui-chart-tick-area');
        var isNotDividedXAxis = !this.isVertical && !this.options.divided;
        var tickLineElement, ticksElement;

        additionalSize = additionalSize || 0;
        tickLineElement = this._renderTickLine(size, isNotDividedXAxis, additionalSize);
        ticksElement = this._renderTicks(size, tickCount, isNotDividedXAxis, additionalSize);
        dom.append(tickContainer, tickLineElement);
        dom.append(tickContainer, ticksElement);

        this.ticksElement = ticksElement;

        return tickContainer;
    },

    /**
     * Make cssText of vertical label.
     * @param {number} axisWidth axis width
     * @param {number} titleAreaWidth title area width
     * @returns {string} cssText
     * @private
     */
    _makeVerticalLabelCssText: function(axisWidth, titleAreaWidth) {
        return ';width:' + (axisWidth - titleAreaWidth + chartConst.V_LABEL_RIGHT_PADDING) + 'px';
    },

    /**
     * Apply css style of label area.
     * @param {HTMLElement} labelContainer label container
     * @param {number} axisWidth axis width
     * @private
     */
    _applyLabelAreaStyle: function(labelContainer, axisWidth) {
        var cssText = renderUtil.makeFontCssText(this.theme.label),
            titleAreaWidth;

        if (this.isVertical) {
            titleAreaWidth = this._getRenderedTitleHeight() + chartConst.TITLE_AREA_WIDTH_PADDING;
            cssText += this._makeVerticalLabelCssText(axisWidth, titleAreaWidth);
        }

        labelContainer.style.cssText = cssText;
    },

    /**
     * Render label area.
     * @param {number} size label area size
     * @param {number} axisWidth axis area width
     * @param {number} tickCount tick count
     * @param {Array.<string>} categories categories
     * @param {?number} additionalSize additional size (width or height)
     * @returns {HTMLElement} label area element
     * @private
     */
    _renderLabelArea: function(size, axisWidth, tickCount, categories, additionalSize) {
        var labelContainer = dom.create('DIV', 'tui-chart-label-area');
        var sizeRatio = this.data.sizeRatio || 1;
        var tickPixelPositions = calculator.makeTickPixelPositions((size * sizeRatio), tickCount);
        var labelSize = tickPixelPositions[1] - tickPixelPositions[0];
        var options = this.options;
        var containerWidth = this.containerWidth || size;
        var labelsHtml;

        if (predicate.isValidLabelInterval(options.labelInterval, options.tickInterval)) {
            labelSize *= options.labelInterval;
        }

        additionalSize = additionalSize ? calculator.makePercentageValue(additionalSize, containerWidth) : 0;
        labelsHtml = this._makeLabelsHtml(size, tickPixelPositions, categories, labelSize, additionalSize);
        labelContainer.innerHTML = labelsHtml;

        this._applyLabelAreaStyle(labelContainer, axisWidth);
        this._changeLabelAreaPosition(labelContainer, labelSize);

        this.labelContainer = labelContainer;

        return labelContainer;
    },

    /**
     * Get height of title area ;
     * @returns {number} height
     * @private
     */
    _getRenderedTitleHeight: function() {
        var title = this.options.title,
            theme = this.theme.title,
            result = title ? renderUtil.getRenderedLabelHeight(title, theme) : 0;

        return result;
    },

    /**
     * Make cssText of label.
     * @param {number} labelSize label size (width or height)
     * @returns {string[]} cssTexts
     * @private
     */
    _makeLabelCssText: function(labelSize) {
        var isVertical = this.isVertical;
        var cssTexts = [];

        if (isVertical && this.isLabel) {
            cssTexts.push(renderUtil.concatStr('height:', labelSize, 'px'));
            cssTexts.push(renderUtil.concatStr('line-height:', labelSize, 'px'));
        } else if (!isVertical) {
            cssTexts.push(renderUtil.concatStr('width:', labelSize, 'px'));
        }

        return cssTexts.length ? cssTexts.join(';') + ';' : '';
    },

    /**
     * Calculate rotation moving position.
     * @param {object} params parameters
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {number} params.moveLeft move left
     *      @param {number} params.top top
     * @returns {{top:number, left: number}} position
     * @private
     */
    _calculateRotationMovingPosition: function(params) {
        var moveLeft = params.moveLeft;
        var degree = this.boundsMaker.xAxisDegree;
        var containerWidth = this.containerWidth || params.size;

        if (degree === chartConst.ANGLE_85) {
            moveLeft += calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, params.labelHeight / 2);
        }

        return {
            top: params.top,
            left: params.left - calculator.makePercentageValue(moveLeft, containerWidth)
        };
    },

    /**
     * Calculate rotation moving position for old browser(IE7, IE8).
     * @param {object} params parameters
     *      @param {number} params.labelWidth label width
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {(string | number)} params.label label
     *      @param {object} theme label theme
     * @returns {{top:number, left: number}} position
     * @private
     */
    _calculateRotationMovingPositionForOldBrowser: function(params) {
        var labelWidth = renderUtil.getRenderedLabelWidth(params.label, params.theme);
        var degree = this.boundsMaker.xAxisDegree;
        var smallAreaWidth = calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, params.labelHeight / 2);
        var newLabelWidth = (calculator.calculateAdjacent(degree, labelWidth / 2) + smallAreaWidth) * 2;
        var changedWidth = renderUtil.isIE7() ? 0 : (labelWidth - newLabelWidth);
        var moveLeft = (params.labelWidth / 2) - (smallAreaWidth * 2);
        var containerWidth = this.containerWidth || params.size;

        if (degree === chartConst.ANGLE_85) {
            moveLeft += smallAreaWidth;
        }

        return {
            top: chartConst.XAXIS_LABEL_TOP_MARGIN,
            left: params.left + calculator.makePercentageValue(changedWidth - moveLeft, containerWidth)
        };
    },

    /**
     * Make cssText for rotation moving.
     * @param {object} params parameters
     *      @param {number} params.labelWidth label width
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {number} params.moveLeft move left
     *      @param {number} params.top top
     *      @param {(string | number)} params.label label
     *      @param {object} theme label theme
     * @returns {string} cssText
     * @private
     */
    _makeCssTextForRotationMoving: function(params) {
        var position;

        if (renderUtil.isOldBrowser()) {
            position = this._calculateRotationMovingPositionForOldBrowser(params);
        } else {
            position = this._calculateRotationMovingPosition(params);
        }

        return renderUtil.concatStr('left:', position.left, '%', ';top:', position.top, 'px');
    },

    /**
     * Make html of rotation labels.
     * @param {number} areaSize - area size.
     * @param {Array.<object>} positions label position array
     * @param {string[]} categories categories
     * @param {number} labelSize label size
     * @param {number} additionalSize additional size
     * @returns {string} labels html
     * @private
     */
    _makeRotationLabelsHtml: function(areaSize, positions, categories, labelSize, additionalSize) {
        var self = this;
        var degree = this.boundsMaker.xAxisDegree;
        var template = axisTemplate.tplAxisLabel;
        var labelHeight = renderUtil.getRenderedLabelHeight(categories[0], this.theme.label);
        var labelCssText = this._makeLabelCssText(labelSize);
        var additionalClass = ' tui-chart-xaxis-rotation tui-chart-xaxis-rotation' + degree;
        var halfWidth = labelSize / 2;
        var moveLeft = calculator.calculateAdjacent(degree, halfWidth);
        var top = calculator.calculateOpposite(degree, halfWidth) + chartConst.XAXIS_LABEL_TOP_MARGIN;
        var spanCssText = (renderUtil.isIE7() && degree) ? chartConst.IE7_ROTATION_FILTER_STYLE_MAP[degree] : '';
        var labelsHtml;

        additionalSize = additionalSize || 0;
        labelsHtml = tui.util.map(positions, function(position, index) {
            var label = categories[index],
                rotationCssText = self._makeCssTextForRotationMoving({
                    size: areaSize,
                    labelHeight: labelHeight,
                    labelWidth: labelSize,
                    top: top,
                    left: position + additionalSize,
                    moveLeft: moveLeft,
                    label: label,
                    theme: self.theme.label
                });

            return template({
                additionalClass: additionalClass,
                cssText: labelCssText + rotationCssText,
                spanCssText: spanCssText,
                label: label
            });
        }).join('');

        return labelsHtml;
    },

    /**
     * Make html of normal labels.
     * @param {Array.<object>} positions label position array
     * @param {string[]} categories categories
     * @param {number} labelSize label size
     * @param {number} additionalSize additional size
     * @returns {string} labels html
     * @private
     */
    _makeNormalLabelsHtml: function(positions, categories, labelSize, additionalSize) {
        var template = axisTemplate.tplAxisLabel,
            labelCssText = this._makeLabelCssText(labelSize),
            posType, labelsHtml;

        if (this.isVertical) {
            posType = this.isLabel ? 'top' : 'bottom';
        } else {
            posType = 'left';
        }

        labelsHtml = tui.util.map(positions, function(position, index) {
            var addCssText = renderUtil.concatStr(posType, ':', (position + additionalSize), '%');

            return template({
                additionalClass: '',
                cssText: labelCssText + addCssText,
                label: categories[index],
                spanCssText: ''
            });
        }).join('');

        return labelsHtml;
    },

    /**
     * Make labels html.
     * @param {number} areaSize - area size
     * @param {Array.<object>} positions - positions for labels
     * @param {Array.<string>} categories - categories
     * @param {number} labelSize label size
     * @param {number} additionalSize additional size
     * @returns {string} labels html
     * @private
     */
    _makeLabelsHtml: function(areaSize, positions, categories, labelSize, additionalSize) {
        var isRotationlessXAxis = !this.isVertical && this.isLabel && this.options.rotateLabel === false;
        var hasRotatedXAxisLabel = this.componentName === 'xAxis' && this.boundsMaker.xAxisDegree;
        var labelsHtml;

        if (isRotationlessXAxis) {
            categories = this.dataProcessor.getMultilineCategories();
        }

        if (categories.length) {
            positions.length = categories.length;
        }

        positions = this._makePercentagePositions(positions, areaSize);

        if (hasRotatedXAxisLabel) {
            labelsHtml = this._makeRotationLabelsHtml(areaSize, positions, categories, labelSize, additionalSize);
        } else {
            labelsHtml = this._makeNormalLabelsHtml(positions, categories, labelSize, additionalSize);
        }

        return labelsHtml;
    },

    /**
     * Change position of label area.
     * @param {HTMLElement} labelContainer label area element
     * @param {number} labelSize label size (width or height)
     * @private
     */
    _changeLabelAreaPosition: function(labelContainer, labelSize) {
        var labelHeight;

        if (this.isLabel && !this.data.aligned) {
            return;
        }

        if (this.isVertical) {
            labelHeight = renderUtil.getRenderedLabelHeight('ABC', this.theme.label);
            labelContainer.style.top = renderUtil.concatStr(parseInt(labelHeight / 2, 10), 'px');
        } else {
            labelContainer.style.left = renderUtil.concatStr('-', parseInt(labelSize / 2, 10), 'px');
        }
    }
});

module.exports = Axis;

},{"../const":31,"../helpers/calculator":57,"../helpers/domHandler":59,"../helpers/predicate":61,"../helpers/renderUtil":63,"./axisTemplate":2}],2:[function(require,module,exports){
/**
 * @fileoverview This is templates or axis view.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var htmls = {
    HTML_AXIS_TICK_LINE: '<div class="tui-chart-tick-line"' +
        ' style="{{ positionType }}:{{ positionValue }}px;{{ sizeType }}:{{ size }}px"></div>',
    HTML_AXIS_TICK: '<div class="tui-chart-tick" style="{{ cssText }}"></div>',
    HTML_AXIS_LABEL: '<div class="tui-chart-label{{ additionalClass }}" style="{{ cssText }}">' +
        '<span{{ spanCssText }}>{{ label }}</span></div>'
};

module.exports = {
    tplTickLine: templateMaker.template(htmls.HTML_AXIS_TICK_LINE),
    tplAxisTick: templateMaker.template(htmls.HTML_AXIS_TICK),
    tplAxisLabel: templateMaker.template(htmls.HTML_AXIS_LABEL)
};

},{"../helpers/templateMaker":64}],3:[function(require,module,exports){
/**
 * @fileoverview chart.js is entry point of Toast UI Chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('./const');
var chartFactory = require('./factories/chartFactory');
var pluginFactory = require('./factories/pluginFactory');
var themeFactory = require('./factories/themeFactory');
var mapFactory = require('./factories/mapFactory');

var _createChart;

require('./polyfill');
require('./code-snippet-util');
require('./registerCharts');
require('./registerThemes');

/**
 * Raw series datum.
 * @typedef {{name: ?string, data: Array.<number>, stack: ?string}} rawSeriesDatum
 */

/**
 * Raw series data.
 * @typedef {Array.<rawSeriesDatum>} rawSeriesData
 */

/**
 * Raw data.
 * @typedef {{
 *      categories: ?Array.<string>,
 *      series: (rawSeriesData|{line: ?rawSeriesData, column: ?rawSeriesData})
 * }} rawData
 */

/**
 * NHN Entertainment Toast UI Chart.
 * @namespace tui.chart
 */
tui.util.defineNamespace('tui.chart');

/**
 * Create chart.
 * @param {HTMLElement} container container
 * @param {rawData} rawData - raw data
 * @param {{
 *   chart: {
 *     width: number,
 *     height: number,
 *     title: string,
 *     format: string
 *   },
 *   yAxis: {
 *     title: string,
 *     min: number
 *   },
 *   xAxis: {
 *     title: string,
 *     min: number
 *   },
 *   tooltip: {
 *     suffix: string,
 *     template: function
 *   },
 *   theme: string
 * }} options - chart options
 * @returns {object} chart instance.
 * @private
 * @ignore
 */
_createChart = function(container, rawData, options) {
    var themeName, theme, chart;

    rawData = JSON.parse(JSON.stringify(rawData));
    options = options ? tui.util.deepCopy(options) : {};
    themeName = options.theme || chartConst.DEFAULT_THEME_NAME;
    theme = themeFactory.get(themeName);

    chart = chartFactory.get(options.chartType, rawData, theme, options);
    container.appendChild(chart.render());
    chart.animateChart();

    return chart;
};

/**
 * Bar chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container - chart container
 * @param {rawData} rawData - raw data
 *      @param {Array.<string>} rawData.categories - categories
 *      @param {Array.<Array>} rawData.series - series data
 * @param {object} options - chart options
 *      @param {object} options.chart - base options for chart
 *          @param {number} options.chart.width - chart width
 *          @param {number} options.chart.height - chart height
 *          @param {string} options.chart.title - chart title
 *          @param {string | function} options.chart.format - formatter for value
 *      @param {object} options.yAxis - options for y axis component
 *          @param {string} options.yAxis.title - title for y axis
 *          @param {string} options.yAxis.align - align option for center y axis
 *          @param {boolean} options.yAxis.rotateTitle - whether rotate title or not (default: true)
 *      @param {object} options.xAxis - options for x axis component
 *          @param {string} options.xAxis.title - title for x axis
 *          @param {number} options.xAxis.min - minimum value for x axis
 *          @param {number} options.xAxis.max - maximum value for x axis
 *      @param {object} options.series - options for series component
 *          @param {string} options.series.stackType - type of stack
 *          @param {boolean} options.series.showLabel - whether show label or not
 *          @param {number} options.series.barWidth - bar width
 *          @param {boolean} options.series.allowSelect - whether allow select or not
 *          @param {boolean} options.series.diverging - whether diverging or not
 *      @param {object} options.tooltip - options for tooltip component
 *          @param {string} options.tooltip.suffix - suffix for tooltip
 *          @param {function} [options.tooltip.template] - template for tooltip
 *          @param {string} options.tooltip.align - align option for tooltip
 *          @param {object} options.tooltip.position - relative position
 *              @param {number} options.tooltip.position.left - position left
 *              @param {number} options.tooltip.position.top - position top
 *          @param {boolean} options.tooltip.grouped - whether group tooltip or not
 *      @param {object} options.legend - options for legend component
 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
 *      @param {object} options.plot - options for plot component
 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
 *      @param {string} options.theme - theme name
 *      @param {string} options.libType - type of graph library
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Bar Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.barChart(container, rawData, options);
 */
tui.chart.barChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_BAR;
    return _createChart(container, rawData, options);
};

/**
 * Column chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container - chart container
 * @param {rawData} rawData - raw data
 *      @param {Array.<string>} rawData.categories - categories
 *      @param {Array.<Array>} rawData.series - series data
 * @param {object} options - chart options
 *      @param {object} options.chart - base options for chart
 *          @param {number} options.chart.width - chart width
 *          @param {number} options.chart.height - chart height
 *          @param {string} options.chart.title - chart title
 *          @param {string | function} options.chart.format - formatter for value
 *      @param {object} options.yAxis - options for y axis component
 *          @param {string} options.yAxis.title - title for y axis
 *          @param {number} options.yAxis.min - minimum value for y axis
 *          @param {number} options.yAxis.max - maximum value for y axis
 *          @param {boolean} options.yAxis.rotateTitle - whether rotate title or not (default: true)
 *      @param {object} options.xAxis - options for x axis component
 *          @param {string} options.xAxis.title - title for x axis
 *          @param {number} options.xAxis.labelInterval - label interval for x axis
 *          @param {boolean} options.xAxis.rotateLabel - whether rotate label or not (default: true)
 *      @param {object} options.series - options for series component
 *          @param {string} options.series.stackType - type of stack
 *          @param {boolean} options.series.showLabel - whether show label or not
 *          @param {number} options.series.barWidth - bar width
 *          @param {boolean} options.series.allowSelect - whether allow select or not
 *          @param {boolean} options.series.diverging - whether diverging or not
 *      @param {object} options.tooltip - options for tooltip component
 *          @param {string} options.tooltip.suffix - suffix for tooltip
 *          @param {function} [options.tooltip.template] - template for tooltip
 *          @param {string} options.tooltip.align - align option for tooltip
 *          @param {object} options.tooltip.position - relative position
 *              @param {number} options.tooltip.position.left - position left
 *              @param {number} options.tooltip.position.top - position top
 *          @param {boolean} options.tooltip.grouped - whether group tooltip or not
 *      @param {object} options.legend - options for legend component
 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
 *      @param {object} options.plot - options for plot component
 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
 *      @param {string} options.theme - theme name
 *      @param {string} options.libType - type of graph library
 * @returns {object} column chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Column Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.columnChart(container, rawData, options);
 */
tui.chart.columnChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_COLUMN;
    return _createChart(container, rawData, options);
};

/**
 * Line chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container - chart container
 * @param {rawData} rawData - raw data
 *      @param {Array.<string>} rawData.categories - categories
 *      @param {Array.<Array>} rawData.series - series data
 * @param {object} options - chart options
 *      @param {object} options.chart - base options for chart
 *          @param {number} options.chart.width - chart width
 *          @param {number} options.chart.height - chart height
 *          @param {string} options.chart.title - chart title
 *          @param {string | function} options.chart.format - formatter for value
 *      @param {object} options.yAxis - options for y axis component
 *          @param {string} options.yAxis.title - title for y axis
 *          @param {number} options.yAxis.min - minimum value for y axis
 *          @param {number} options.yAxis.max - maximum value for y axis
 *          @param {boolean} options.yAxis.rotateTitle - whether rotate title or not (default: true)
 *      @param {object} options.xAxis - options for x axis component
 *          @param {string} options.xAxis.title - title for x axis
 *          @param {number} options.xAxis.labelInterval - label interval for x axis
 *          @param {string} options.xAxis.tickInterval - tick interval for x axis
 *          @param {boolean} options.xAxis.rotateLabel - whether rotate label or not (default: true)
 *      @param {object} options.series - options for series component
 *          @param {boolean} options.series.showDot - whether show dot or not
 *          @param {boolean} options.series.showLabel - whether show label or not
 *          @param {boolean} options.series.allowSelect - whether allow select or not
 *          @param {boolean} options.series.spline - whether spline or not
 *          @param {boolean} options.series.zoomable - whether zoomable or not
 *          @param {boolean} options.series.shifting - whether shifting or not
 *      @param {object} options.tooltip - options for tooltip component
 *          @param {string} options.tooltip.suffix - suffix for tooltip
 *          @param {function} [options.tooltip.template] - template for tooltip
 *          @param {string} options.tooltip.align - align option for tooltip
 *          @param {object} options.tooltip.position - relative position
 *              @param {number} options.tooltip.position.left - position left
 *              @param {number} options.tooltip.position.top - position top
 *          @param {boolean} options.tooltip.grouped - whether group tooltip or not
 *      @param {object} options.legend - options for legend component
 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
 *      @param {object} options.plot - options for plot component
 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
 *      @param {string} options.theme - theme name
 *      @param {string} options.libType - type of graph library
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Line Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       },
 *       series: {
 *         showDot: true
 *       }
 *     };
 * tui.chart.lineChart(container, rawData, options);
 */
tui.chart.lineChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_LINE;
    return _createChart(container, rawData, options);
};

/**
 * Area chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container - chart container
 * @param {rawData} rawData - raw data
 *      @param {Array.<string>} rawData.categories - categories
 *      @param {Array.<Array>} rawData.series - series data
 * @param {object} options - chart options
 *      @param {object} options.chart - base options for chart
 *          @param {number} options.chart.width - chart width
 *          @param {number} options.chart.height - chart height
 *          @param {string} options.chart.title - chart title
 *          @param {string | function} options.chart.format - formatter for value
 *      @param {object} options.yAxis - options for y axis component
 *          @param {string} options.yAxis.title - title for y axis
 *          @param {number} options.yAxis.min - minimum value for y axis
 *          @param {number} options.yAxis.max - maximum value for y axis
 *          @param {boolean} options.yAxis.rotateTitle - whether rotate title or not (default: true)
 *      @param {object} options.xAxis - options for x axis component
 *          @param {string} options.xAxis.title - title for x axis
 *          @param {number} options.xAxis.labelInterval - label interval for x axis
 *          @param {boolean} options.xAxis.rotateLabel - whether rotate label or not (default: true)
 *          @param {string} options.xAxis.tickInterval - tick interval for x axis
 *      @param {object} options.series - options for series component
 *          @param {boolean} options.series.showDot - whether show dot or not
 *          @param {boolean} options.series.showLabel - whether show label or not
 *          @param {boolean} options.series.allowSelect - whether allow select or not
 *          @param {boolean} options.series.spline - whether spline or not
 *          @param {boolean} options.series.zoomable - whether zoomable or not
 *          @param {boolean} options.series.shifting - whether shifting or not
 *      @param {object} options.tooltip - options for tooltip component
 *          @param {string} options.tooltip.suffix - suffix for tooltip
 *          @param {function} [options.tooltip.template] - template for tooltip
 *          @param {string} options.tooltip.align - align option for tooltip
 *          @param {object} options.tooltip.position - relative position
 *              @param {number} options.tooltip.position.left - position left
 *              @param {number} options.tooltip.position.top - position top
 *          @param {boolean} options.tooltip.grouped - whether group tooltip or not
 *      @param {object} options.legend - options for legend component
 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
 *      @param {object} options.plot - options for plot component
 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
 *      @param {string} options.theme - theme name
 *      @param {string} options.libType - type of graph library
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Area Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.areaChart(container, rawData, options);
 */
tui.chart.areaChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_AREA;
    return _createChart(container, rawData, options);
};

/**
 * Bubble chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container - chart container
 * @param {rawData} rawData - raw data
 *      @param {Array.<string>} rawData.categories - categories
 *      @param {Array.<Array>} rawData.series - series data
 * @param {object} options - chart options
 *      @param {object} options.chart - base options for chart
 *          @param {number} options.chart.width - chart width
 *          @param {number} options.chart.height - chart height
 *          @param {string} options.chart.title - chart title
 *          @param {string | function} options.chart.format - formatter for value
 *      @param {object} options.yAxis - options for y axis component
 *          @param {string} options.yAxis.title - title for y axis
 *          @param {number} options.yAxis.min - minimum value for y axis
 *          @param {number} options.yAxis.max - maximum value for y axis
 *          @param {boolean} options.yAxis.rotateTitle - whether rotate title or not (default: true)
 *      @param {object} options.xAxis - options for x axis component
 *          @param {string} options.xAxis.title - title for x axis
 *          @param {number} options.xAxis.labelInterval - label interval for x axis
 *          @param {boolean} options.xAxis.rotateLabel - whether rotate label or not (default: true)
 *          @param {number} options.xAxis.min - minimum value for y axis
 *          @param {number} options.xAxis.max - maximum value for y axis
 *      @param {object} options.series - options for series component
 *          @param {boolean} options.series.showLabel - whether show label or not
 *          @param {boolean} options.series.allowSelect - whether allow select or not
 *      @param {object} options.tooltip - options for tooltip component
 *          @param {string} options.tooltip.suffix - suffix for tooltip
 *          @param {function} [options.tooltip.template] - template for tooltip
 *          @param {string} options.tooltip.align - align option for tooltip
 *          @param {object} options.tooltip.position - relative position
 *              @param {number} options.tooltip.position.left - position left
 *              @param {number} options.tooltip.position.top - position top
 *      @param {object} options.legend - options for legend component
 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
 *      @param {object} options.circleLegend - options for circleLegend
 *          @param {boolean} options.circleLegend.visible - whether visible or not (default: true)
 *      @param {object} options.plot - options for plot component
 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
 *      @param {string} options.theme - theme name
 *      @param {string} options.libType - type of graph library
 * @returns {object} bubble chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [{
 *              x: 10,
 *              y: 20,
 *              r: 15,
 *              label: 'Lable1'
 *           }, {
 *              x: 20,
 *              y: 40,
 *              r: 10,
 *              label: 'Lable2'
 *           }]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [{
 *              x: 40,
 *              y: 10,
 *              r: 5,
 *              label: 'Lable3'
 *           }, {
 *              x: 30,
 *              y: 40,
 *              r: 8,
 *              label: 'Lable4'
 *           }]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Bubble Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.bubbleChart(container, rawData, options);
 */
tui.chart.bubbleChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_BUBBLE;
    return _createChart(container, rawData, options);
};

/**
 * Scatter chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container - chart container
 * @param {rawData} rawData - raw data
 *      @param {Array.<string>} rawData.categories - categories
 *      @param {Array.<Array>} rawData.series - series data
 * @param {object} options - chart options
 *      @param {object} options.chart - base options for chart
 *          @param {number} options.chart.width - chart width
 *          @param {number} options.chart.height - chart height
 *          @param {string} options.chart.title - chart title
 *          @param {string | function} options.chart.format - formatter for value
 *      @param {object} options.yAxis - options for y axis component
 *          @param {string} options.yAxis.title - title for y axis
 *          @param {number} options.yAxis.min - minimum value for y axis
 *          @param {number} options.yAxis.max - maximum value for y axis
 *          @param {boolean} options.yAxis.rotateTitle - whether rotate title or not (default: true)
 *      @param {object} options.xAxis - options for x axis component
 *          @param {string} options.xAxis.title - title for x axis
 *          @param {number} options.xAxis.min - minimum value for y axis
 *          @param {number} options.xAxis.max - maximum value for y axis
 *      @param {object} options.series - options for series component
 *          @param {boolean} options.series.showLabel - whether show label or not
 *          @param {boolean} options.series.allowSelect - whether allow select or not
 *      @param {object} options.tooltip - options for tooltip component
 *          @param {string} options.tooltip.suffix - suffix for tooltip
 *          @param {function} [options.tooltip.template] - template for tooltip
 *          @param {string} options.tooltip.align - align option for tooltip
 *          @param {object} options.tooltip.position - relative position
 *              @param {number} options.tooltip.position.left - position left
 *              @param {number} options.tooltip.position.top - position top
 *      @param {object} options.legend - options for legend component
 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
 *      @param {object} options.plot - options for plot component
 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
 *      @param {string} options.theme - theme name
 *      @param {string} options.libType - type of graph library
 * @returns {object} scatter chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [{
 *              x: 10,
 *              y: 20
 *           }, {
 *              x: 20,
 *              y: 40
 *           }]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [{
 *              x: 40,
 *              y: 10
 *           }, {
 *              x: 30,
 *              y: 40
 *           }]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Scatter Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.scatterChart(container, rawData, options);
 */
tui.chart.scatterChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_SCATTER;
    return _createChart(container, rawData, options);
};

/**
 * Heatmap chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container - chart container
 * @param {rawData} rawData - raw data
 *      @param {{x: Array.<string | number>, y: Array.<string | number>}} rawData.categories - categories
 *      @param {Array.<Array.<number>>} rawData.series - series data
 * @param {object} options - chart options
 *      @param {object} options.chart - base options for chart
 *          @param {number} options.chart.width - chart width
 *          @param {number} options.chart.height - chart height
 *          @param {string} options.chart.title - chart title
 *          @param {string | function} options.chart.format - formatter for value
 *      @param {object} options.yAxis - options for y axis component
 *          @param {string} options.yAxis.title - title for y axis
 *          @param {boolean} options.yAxis.rotateTitle - whether rotate title or not (default: true)
 *      @param {object} options.xAxis - options for x axis component
 *          @param {string} options.xAxis.title - title for x axis
 *      @param {object} options.series - options for series component
 *          @param {boolean} options.series.showLabel - whether show label or not
 *      @param {object} options.tooltip - options for tooltip component
 *          @param {string} options.tooltip.suffix - suffix for tooltip
 *          @param {function} [options.tooltip.template] - template for tooltip
 *          @param {string} options.tooltip.align - align option for tooltip
 *          @param {object} options.tooltip.position - relative position
 *              @param {number} options.tooltip.position.left - position left
 *              @param {number} options.tooltip.position.top - position top
 *      @param {object} options.legend - options for legend component
 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
 *      @param {string} options.theme - theme name
 *      @param {string} options.libType - type of graph library
 * @returns {object} scatter chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       categories: {
 *           x: [10, 20, 30, 40, 50],
 *           y: [1, 2, 3, 4, 5, 6]
 *       },
 *       series: [
 *           [10, 20, 30, 40, 50],
 *           [1, 4, 6, 7, 8],
 *           [20, 4, 5, 70, 8],
 *           [100, 40, 30, 80, 30],
 *           [20, 10, 60, 90, 20],
 *           [50, 40, 30, 20, 10]
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Heatmap Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.heatmapChart(container, rawData, options);
 */
tui.chart.heatmapChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_HEATMAP;
    return _createChart(container, rawData, options);
};

/**
 * Treemap chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container - chart container
 * @param {rawData} rawData - raw data
 *      @param {Array.<Array.<object>>} rawData.series - series data
 * @param {object} options - chart options
 *      @param {object} options.chart - base options for chart
 *          @param {number} options.chart.width - chart width
 *          @param {number} options.chart.height - chart height
 *          @param {string} options.chart.title - chart title
 *          @param {string | function} options.chart.format - formatter for value
 *      @param {object} options.series - options for series component
 *          @param {boolean} options.series.showLabel - whether show label or not
 *          @param {boolean} options.series.useColorValue - whether use colorValue or not
 *          @param {boolean} options.series.zoomable - whether zoomable or not
 *          @param {boolean} options.series.useLeafLabel - whether use leaf label or not
 *      @param {object} options.tooltip - options for tooltip component
 *          @param {string} options.tooltip.suffix - suffix for tooltip
 *          @param {function} [options.tooltip.template] - template for tooltip
 *          @param {object} options.tooltip.position - relative position
 *              @param {number} options.tooltip.position.left - position left
 *              @param {number} options.tooltip.position.top - position top
 *      @param {object} options.legend - options for legend component
 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
 *      @param {string} options.theme - theme name
 *      @param {string} options.libType - type of graph library
 * @returns {object} scatter chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       series: [
 *          {
 *              label: 'label1',
 *              value: 6
 *          },
 *          {
 *              label: 'label2',
 *              value: 6
 *          },
 *          {
 *              label: 'label3',
 *              value: 4
 *          },
 *          {
 *              label: 'label4',
 *              value: 3
 *          },
 *          {
 *              label: 'label5',
 *              value: 2
 *          },
 *          {
 *              label: 'label6',
 *              value: 2
 *          },
 *          {
 *              label: 'label7',
 *              value: 1
 *          }
 *     ],
 *     options = {
 *       chart: {
 *         title: 'Treemap Chart'
 *       }
 *     };
 * tui.chart.treemapChart(container, rawData, options);
 */
tui.chart.treemapChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_TREEMAP;
    return _createChart(container, rawData, options);
};

/**
 * Combo chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container - chart container
 * @param {rawData} rawData - raw data
 *      @param {Array.<string>} rawData.categories - categories
 *      @param {Array.<Array>} rawData.series - series data
 * @param {object} options - chart options
 *      @param {object} options.chart - base options for chart
 *          @param {number} options.chart.width - chart width
 *          @param {number} options.chart.height - chart height
 *          @param {string} options.chart.title - chart title
 *          @param {string | function} options.chart.format - formatter for value
 *      @param {object|Array} options.yAxis - options for y axis component
 *          @param {string} options.yAxis.title - title for y axis
 *          @param {number} options.yAxis.min - minimum value for y axis
 *          @param {number} options.yAxis.max - maximum value for y axis
 *          @param {boolean} options.yAxis.rotateTitle - whether rotate title or not (default: true)
 *      @param {object} options.xAxis - options for x axis component
 *          @param {string} options.xAxis.title - title for x axis
 *          @param {number} options.xAxis.labelInterval - label interval for x axis
 *          @param {boolean} options.xAxis.rotateLabel - whether rotate label or not (default: true)
 *      @param {object} options.series - options for series component
 *          @param {?object} options.series.column - options for column series component
 *              @param {string} options.series.column.stackType - type of stack
 *              @param {boolean} options.series.column.showLabel - whether show label or not
 *              @param {number} options.series.column.barWidth - bar width
 *              @param {boolean} options.series.column.allowSelect - whether allow select or not
 *          @param {?object} options.series.line - options for line series component
 *              @param {boolean} options.series.line.showDot - whether show dot or not
 *              @param {boolean} options.series.line.showLabel - whether show label or not
 *              @param {boolean} options.series.line.allowSelect - whether allow select or not
 *              @param {boolean} options.series.line.spline - whether spline or not
 *          @param {?object} options.series.area - options for line series component
 *              @param {boolean} options.series.area.showDot - whether show dot or not
 *              @param {boolean} options.series.area.showLabel - whether show label or not
 *              @param {boolean} options.series.area.allowSelect - whether allow select or not
 *              @param {boolean} options.series.area.spline - whether spline or not
 *          @param {?object} options.series.pie - options for pie series component
 *              @param {boolean} options.series.pie.showLabel - whether show label or not
 *              @param {number} options.series.pie.radiusRatio - ratio of radius for pie graph
 *              @param {boolean} options.series.pie.allowSelect - whether allow select or not
 *              @param {boolean} options.series.pie.startAngle - start angle
 *              @param {boolean} options.series.pie.endAngle - end angle
 *          @param {boolean} options.series.showDot - whether show dot or not
 *          @param {boolean} options.series.showLabel - whether show label or not
 *          @param {boolean} options.series.allowSelect - whether allow select or not
 *          @param {boolean} options.series.spline - whether spline or not
 *          @param {boolean} options.series.zoomable - whether zoomable or not
 *          @param {boolean} options.series.shifting - whether shifting or not
 *      @param {object} options.tooltip - options for tooltip component
 *          @param {object} options.tooltip.column - options for column tooltip
 *              @param {string} options.tooltip.column.suffix - suffix for tooltip
 *              @param {function} [options.tooltip.column.template] template of tooltip
 *              @param {string} options.tooltip.column.align - align option for tooltip
 *              @param {object} options.tooltip.column.position - relative position
 *                  @param {number} options.tooltip.column.position.left - position left
 *                  @param {number} options.tooltip.column.position.top - position top
 *          @param {boolean} options.tooltip.grouped - whether group tooltip or not
 *      @param {object} options.legend - options for legend component
 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
 *      @param {object} options.plot - options for plot component
 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
 *      @param {string} options.theme - theme name
 *      @param {string} options.libType - type of graph library
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: {
 *         column: [
 *           {
 *             name: 'Legend1',
 *             data: [20, 30, 50]]
 *           },
 *           {
 *             name: 'Legend2',
 *             data: [40, 40, 60]
 *           },
 *           {
 *             name: 'Legend3',
 *             data: [60, 50, 10]
 *           },
 *           {
 *             name: 'Legend4',
 *             data: [80, 10, 70]
 *           }
 *         },
 *         line: [
 *           {
 *             name: 'Legend5',
 *             data: [1, 2, 3]
 *           }
 *         ]
 *       }
 *     },
 *     options = {
 *       chart: {
 *         title: 'Combo Chart'
 *       },
 *       yAxis:[
 *         {
 *           title: 'Y Axis',
 *           chartType: 'line'
 *         },
 *         {
 *           title: 'Y Right Axis'
 *         }
 *       ],
 *       xAxis: {
 *         title: 'X Axis'
 *       },
 *       series: {
 *         showDot: true
 *       }
 *     };
 * tui.chart.comboChart(container, rawData, options);
 */
tui.chart.comboChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_COMBO;
    return _createChart(container, rawData, options);
};

/**
 * Pie chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container - chart container
 * @param {rawData} rawData - raw data
 *      @param {Array.<Array>} rawData.series - series data
 * @param {object} options - chart options
 *      @param {object} options.chart - base options for chart
 *          @param {number} options.chart.width - chart width
 *          @param {number} options.chart.height - chart height
 *          @param {string} options.chart.title - chart title
 *          @param {string | function} options.chart.format - formatter for value
 *      @param {object} options.series - options for series component
 *          @param {boolean} options.series.showLabel - whether show label or not
 *          @param {number} options.series.radiusRatio - ratio of radius for pie graph
 *          @param {boolean} options.series.allowSelect - whether allow select or not
 *          @param {boolean} options.series.startAngle - start angle
 *          @param {boolean} options.series.endAngle - end angle
 *      @param {object} options.tooltip - options for tooltip component
 *          @param {string} options.tooltip.suffix - suffix for tooltip
 *          @param {function} [options.tooltip.template] - template for tooltip
 *          @param {string} options.tooltip.align - align option for tooltip
 *          @param {object} options.tooltip.position - relative position
 *              @param {number} options.tooltip.position.left - position left
 *              @param {number} options.tooltip.position.top - position top
 *      @param {object} options.legend - options for legend component
 *          @param {string} options.legend.align - align option for legend (top|bottom|left|center|outer)
 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
 *      @param {string} options.theme - theme name
 *      @param {string} options.libType - type of graph library
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: 20
 *         },
 *         {
 *           name: 'Legend2',
 *           data: 40
 *         },
 *         {
 *           name: 'Legend3',
 *           data: 60
 *         },
 *         {
 *           name: 'Legend4',
 *           data: 80
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Pie Chart'
 *       }
 *     };
 * tui.chart.pieChart(container, rawData, options);
 */
tui.chart.pieChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_PIE;
    return _createChart(container, rawData, options);
};

/**
 * Map chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container - chart container
 * @param {rawData} rawData chart data
 *      @param {Array.<Array>} rawData.series - series data
 * @param {object} options - chart options
 *      @param {object} options.chart - base options for chart
 *          @param {number} options.chart.width - chart width
 *          @param {number} options.chart.height - chart height
 *          @param {string} options.chart.title - chart title
 *          @param {string | function} options.chart.format - formatter for value
 *      @param {object} options.series - options for series component
 *          @param {boolean} options.series.showLabel - whether show label or not
 *      @param {object} options.tooltip - options for tooltip component
 *          @param {string} options.tooltip.suffix - suffix for tooltip
 *          @param {function} [options.tooltip.template] - template for tooltip
 *          @param {string} options.tooltip.align - align option for tooltip
 *          @param {object} options.tooltip.position - relative position
 *              @param {number} options.tooltip.position.left - position left
 *              @param {number} options.tooltip.position.top - position top
 *      @param {object} options.legend - options for legend component
 *          @param {string} options.legend.align - align option for legend (top|bottom|left|center|outer)
 *      @param {string} options.theme - theme name
 *      @param {string} options.map map type
 *      @param {string} options.libType - type of graph library
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     rawData = {
 *       series: [
 *         {
 *           code: 'KR',
 *           data: 100,
 *           labelCoordinate: {
 *             x: 0.6,
 *             y: 0.7
 *           }
 *         },
 *         {
 *           code: 'JP',
 *           data: 50
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Map Chart'
 *       },
 *       map: 'world'
 *     };
 * tui.chart.mapChart(container, rawData, options);
 */
tui.chart.mapChart = function(container, rawData, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_MAP;
    options.map = mapFactory.get(options.map);

    return _createChart(container, rawData, options);
};

/**
 * Register theme.
 * @memberOf tui.chart
 * @param {string} themeName theme name
 * @param {object} theme application chart theme
 *      @param {object} theme.chart chart theme
 *          @param {string} theme.chart.fontFamily font family of chart
 *          @param {string} theme.chart.background background of chart
 *      @param {object} theme.title chart theme
 *          @param {number} theme.title.fontSize font size of chart title
 *          @param {string} theme.title.fontFamily font family of chart title
 *          @param {string} theme.title.color font color of chart title
 *          @param {string} theme.title.background background of chart title
 *      @param {object} theme.yAxis theme of vertical axis
 *          @param {object} theme.yAxis.title theme of vertical axis title
 *              @param {number} theme.yAxis.title.fontSize font size of vertical axis title
 *              @param {string} theme.yAxis.title.fontFamily font family of vertical axis title
 *              @param {string} theme.yAxis.title.color font color of vertical axis title
 *          @param {object} theme.yAxis.label theme of vertical axis label
 *              @param {number} theme.yAxis.label.fontSize font size of vertical axis label
 *              @param {string} theme.yAxis.label.fontFamily font family of vertical axis label
 *              @param {string} theme.yAxis.label.color font color of vertical axis label
 *          @param {string} theme.yAxis.tickColor color of vertical axis tick
 *      @param {object} theme.xAxis theme of horizontal axis
 *          @param {object} theme.xAxis.title theme of horizontal axis title
 *              @param {number} theme.xAxis.title.fontSize font size of horizontal axis title
 *              @param {string} theme.xAxis.title.fontFamily font family of horizontal axis title
 *              @param {string} theme.xAxis.title.color font color of horizontal axis title
 *          @param {object} theme.xAxis.label theme of horizontal axis label
 *              @param {number} theme.xAxis.label.fontSize font size of horizontal axis label
 *              @param {string} theme.xAxis.label.fontFamily font family of horizontal axis label
 *              @param {string} theme.xAxis.label.color font color of horizontal axis label
 *          @param {string} theme.xAxis.tickColor color of horizontal axis tick
 *      @param {object} theme.plot plot theme
 *          @param {string} theme.plot.lineColor plot line color
 *          @param {string} theme.plot.background plot background
 *      @param {object} theme.series series theme
 *          @param {Array.<string>} theme.series.colors series colors
 *          @param {string} theme.series.borderColor series border color
 *          @param {string} theme.series.selectionColor series selection color
 *          @param {string} theme.series.startColor start color for map chart
 *          @param {string} theme.series.endColor end color for map chart
 *          @param {string} theme.series.overColor end color for map chart
 *      @param {object} theme.legend legend theme
 *          @param {object} theme.legend.label theme of legend label
 *              @param {number} theme.legend.label.fontSize font size of legend label
 *              @param {string} theme.legend.label.fontFamily font family of legend label
 *              @param {string} theme.legend.label.color font color of legend label
 * @api
 * @example
 * var theme = {
 *   yAxis: {
 *     tickColor: '#ccbd9a',
 *       title: {
 *         color: '#333333'
 *       },
 *       label: {
 *         color: '#6f491d'
 *       }
 *     },
 *     xAxis: {
 *       tickColor: '#ccbd9a',
 *       title: {
 *         color: '#333333'
 *       },
 *       label: {
 *         color: '#6f491d'
 *       }
 *     },
 *     plot: {
 *       lineColor: '#e5dbc4',
 *       background: '#f6f1e5'
 *     },
 *     series: {
 *       colors: ['#40abb4', '#e78a31', '#c1c452', '#795224', '#f5f5f5'],
 *       borderColor: '#8e6535',
 *       selectionColor: '#cccccc',
 *       startColor: '#efefef',
 *       endColor: 'blue',
 *       overColor: 'yellow'
 *     },
 *     legend: {
 *       label: {
 *         color: '#6f491d'
 *       }
 *     }
 *   };
 * tui.chart.registerTheme('newTheme', theme);
 */
tui.chart.registerTheme = function(themeName, theme) {
    themeFactory.register(themeName, theme);
};

/**
 * Register map.
 * @param {string} mapName map name
 * @param {Array.<{code: string, name: string, path: string}>} data map data
 * @api
 * @example
 * var data = [
 *   {
 *     code: 'KR',
 *     name: 'South Korea',
 *     path: 'M835.13,346.53L837.55,350.71...',
 *     labelCoordinate: {
 *       x: 0.6,
 *       y: 0.7
 *     }
 *   },
 *   //...
 * ];
 * tui.chart.registerMap('newMap', data);
 */
tui.chart.registerMap = function(mapName, data) {
    mapFactory.register(mapName, data);
};

/**
 * Register graph plugin.
 * @memberOf tui.chart
 * @param {string} libType type of graph library
 * @param {object} plugin plugin to control library
 * @example
 * var pluginRaphael = {
 *   bar: function() {} // Render class
 * };
 * tui.chart.registerPlugin('raphael', pluginRaphael);
 */
tui.chart.registerPlugin = function(libType, plugin) {
    pluginFactory.register(libType, plugin);
};

},{"./code-snippet-util":30,"./const":31,"./factories/chartFactory":50,"./factories/mapFactory":51,"./factories/pluginFactory":52,"./factories/themeFactory":53,"./polyfill":86,"./registerCharts":87,"./registerThemes":88}],4:[function(require,module,exports){
'use strict';

var chartConst = require('../const');

/**
 * addingDynamicData is mixer for adding dynamic data.
 * @mixin
 */
var addingDynamicDataMixer = {
    /**
     * Initialize for adding data.
     * @private
     */
    _initForAddingData: function() {
        /**
         * whether lookupping or not
         * @type {boolean}
         */
        this.lookupping = false;

        /**
         * whether paused or not
         * @type {boolean}
         */
        this.paused = false;

        /**
         * rendering delay timer id
         * @type {null}
         */
        this.rerenderingDelayTimerId = null;

        /**
         * added data count
         * @type {number}
         */
        this.addedDataCount = 0;

        /**
         * checked legends.
         * @type {null | Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}}
         */
        this.checkedLegends = null;
    },

    /**
     * Animate for adding data.
     * @private
     */
    _animateForAddingData: function() {
        var self = this;
        var boundsMaker = this.boundsMaker;
        var shiftingOption = !!tui.util.pick(this.options.series, 'shifting');
        var beforeAxesData = boundsMaker.getAxesData();
        var beforeSizeRatio = beforeAxesData.xAxis.sizeRatio || 1;

        this.addedDataCount += 1;
        this.axisScaleMakerMap = null;
        boundsMaker.initBoundsData();

        this._render(function() {
            var xAxisWidth = boundsMaker.getDimension('xAxis').width * beforeSizeRatio;
            var tickSize = (xAxisWidth / (self.dataProcessor.getCategoryCount(false) - 1));

            self._renderComponents({
                tickSize: tickSize + chartConst.OVERLAPPING_WIDTH,
                shifting: shiftingOption
            }, 'animateForAddingData');
        }, beforeAxesData);

        if (shiftingOption) {
            this.dataProcessor.shiftData();
        }
    },

    /**
     * Rerender for adding data.
     * @private
     */
    _rerenderForAddingData: function() {
        var self = this;

        if (tui.util.pick(this.options.series, 'shifting')) {
            this.boundsMaker.initBoundsData();
        }

        this.axisScaleMakerMap = null;

        this._render(function(renderingData) {
            renderingData.animatable = false;
            self._renderComponents(renderingData, 'rerender');
        });
    },

    /**
     * Check for added data.
     * @private
     */
    _checkForAddedData: function() {
        var self = this;
        var added = this.dataProcessor.addDataFromDynamicData();

        if (!added) {
            this.lookupping = false;

            return;
        }

        if (this.paused) {
            return;
        }

        this._animateForAddingData();
        this.rerenderingDelayTimerId = setTimeout(function() {
            self.rerenderingDelayTimerId = null;
            self._rerenderForAddingData();
            self._checkForAddedData();
        }, 400);
    },

    /**
     * Pause animation for adding data.
     * @private
     */
    _pauseAnimationForAddingData: function() {
        this.paused = true;
        this._initForAutoTickInterval();

        if (this.rerenderingDelayTimerId) {
            clearTimeout(this.rerenderingDelayTimerId);
            this.rerenderingDelayTimerId = null;

            if (tui.util.pick(this.options.series, 'shifting')) {
                this.dataProcessor.shiftData();
            }
        }
    },

    /**
     * Restart animation for adding data.
     * @private
     */
    _restartAnimationForAddingData: function() {
        this.paused = false;
        this.lookupping = false;
        this._startLookup();
    },

    /**
     * Start lookup.
     * @private
     */
    _startLookup: function() {
        if (this.lookupping) {
            return;
        }

        this.lookupping = true;

        this._checkForAddedData();
    },

    /**
     * Add data.
     * @param {string} category - category
     * @param {Array} values - values
     */
    addData: function(category, values) {
        this.dataProcessor.addDynamicData(category, values);
        this._startLookup();
    },


    /**
     * Change checked legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @param {?object} rawData rawData
     * @param {?object} boundsParams addition params for calculating bounds
     * @override
     */
    _changeCheckedLegends: function(checkedLegends, rawData, boundsParams) {
        var self = this;
        var pastPaused = this.paused;

        if (!pastPaused) {
            this._pauseAnimationForAddingData();
        }

        this.checkedLegends = checkedLegends;
        this._rerender(checkedLegends, rawData, boundsParams);


        if (!pastPaused) {
            setTimeout(function() {
                self._restartAnimationForAddingData();
            }, chartConst.RERENDER_TIME);
        }
    }
};

module.exports = addingDynamicDataMixer;

},{"../const":31}],5:[function(require,module,exports){
/**
 * @fileoverview Area chart
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var lineTypeMixer = require('./lineTypeMixer');
var autoTickMixer = require('./autoTickMixer');
var zoomMixer = require('./zoomMixer');
var axisTypeMixer = require('./axisTypeMixer');
var addingDynamicDataMixer = require('./addingDynamicDataMixer');
var rawDataHandler = require('../helpers/rawDataHandler');
var Series = require('../series/areaChartSeries');

var AreaChart = tui.util.defineClass(ChartBase, /** @lends LineChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-area-chart',

    /**
     * Series class
     * @type {function}
     */
    Series: Series,

    /**
     * Area chart.
     * @constructs AreaChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     * @mixes axisTypeMixer
     * @mixes lineTypeMixer
     */
    init: function(rawData, theme, options) {
        rawDataHandler.removeSeriesStack(rawData.series);
        this._lineTypeInit(rawData, theme, options);
        this._initForAutoTickInterval();
        this._initForAddingData();
    },

    /**
     * On change checked legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @param {?object} rawData rawData
     * @param {?object} boundsParams addition params for calculating bounds
     * @override
     */
    onChangeCheckedLegends: function(checkedLegends, rawData, boundsParams) {
        this._changeCheckedLegends(checkedLegends, rawData, boundsParams);
    }
});

tui.util.extend(AreaChart.prototype,
    axisTypeMixer, lineTypeMixer, autoTickMixer, zoomMixer, addingDynamicDataMixer);

module.exports = AreaChart;

},{"../helpers/rawDataHandler":62,"../series/areaChartSeries":89,"./addingDynamicDataMixer":4,"./autoTickMixer":6,"./axisTypeMixer":7,"./chartBase":11,"./lineTypeMixer":20,"./zoomMixer":29}],6:[function(require,module,exports){
/**
 * @fileoverview autoTickMixer is mixer for making auto tick.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var axisDataMaker = require('../helpers/axisDataMaker');

/**
 * autoTickMixer is mixer for making auto tick.
 * @mixin
 */
var autoTickMixer = {
    /**
     * Initialize for auto tick interval option.
     * @private
     */
    _initForAutoTickInterval: function() {
        /**
         * previous updated xAxisData
         * @type {null | object}
         */
        this.prevUpdatedData = null;

        /**
         * first updated tick count
         */
        this.firstTickCount = null;
    },

    /**
     * Update axesData.
     * @private
     * @override
     */
    _updateAxesData: function() {
        var boundsMaker = this.boundsMaker;
        var axesData = boundsMaker.getAxesData();
        var xAxisData = axesData.xAxis;
        var seriesWidth = boundsMaker.getDimension('series').width;
        var shiftingOption = tui.util.pick(this.options.series, 'shifting');
        var prevUpdatedData = this.prevUpdatedData;

        if (shiftingOption || !prevUpdatedData) {
            axisDataMaker.updateLabelAxisDataForAutoTickInterval(xAxisData, seriesWidth, this.addedDataCount);
        } else {
            axisDataMaker.updateLabelAxisDataForStackingDynamicData(xAxisData, prevUpdatedData, this.firstTickCount);
        }

        this.prevUpdatedData = xAxisData;

        if (!this.firstTickCount) {
            this.firstTickCount = xAxisData.tickCount;
        }

        boundsMaker.registerAxesData(axesData);
    }
};

module.exports = autoTickMixer;

},{"../helpers/axisDataMaker":54}],7:[function(require,module,exports){
/**
 * @fileoverview axisTypeMixer is mixer for help to axis types charts like bar, column, line, area,
 *                  bubble, column&line combo.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var axisDataMaker = require('../helpers/axisDataMaker');
var renderUtil = require('../helpers/renderUtil');
var predicate = require('../helpers/predicate');
var Axis = require('../axes/axis');
var Plot = require('../plots/plot');
var Legend = require('../legends/legend');
var GroupTypeCustomEvent = require('../customEvents/groupTypeCustomEvent');
var BoundsTypeCustomEvent = require('../customEvents/boundsTypeCustomEvent');
var Tooltip = require('../tooltips/tooltip');
var GroupTooltip = require('../tooltips/groupTooltip');

/**
 * Axis limit value.
 * @typedef {{min: number, max: number}} axisLimit
 */

/**
 * axisTypeMixer is mixer for help to axis types charts like bar, column, line, area, bubble, column&line combo.
 * @mixin
 */
var axisTypeMixer = {
    /**
     * Add axis components.
     * @param {Array.<object>} axes axes option
     * @param {boolean} aligned whether aligned or not
     * @private
     */
    _addAxisComponents: function(axes, aligned) {
        var self = this;
        tui.util.forEach(axes, function(axis) {
            var axisParams = {
                aligned: aligned,
                isLabel: !!axis.isLabel,
                isVertical: !!axis.isVertical,
                chartType: axis.chartType
            };

            if (axis.name === 'rightYAxis') {
                axisParams.componentType = 'yAxis';
                axisParams.index = 1;
            }

            self.componentManager.register(axis.name, Axis, axisParams);
        });
    },

    /**
     * Add series components
     * @param {Array<object>} serieses serieses
     * @param {object} options options
     * @param {boolean} aligned whether aligned or not
     * @private
     */
    _addSeriesComponents: function(serieses, options) {
        var self = this,
            seriesBaseParams = {
                libType: options.libType,
                chartType: options.chartType,
                userEvent: this.userEvent,
                componentType: 'series',
                chartBackground: this.theme.chart.background
            };

        tui.util.forEach(serieses, function(series) {
            var seriesParams = tui.util.extend(seriesBaseParams, series.data);
            self.componentManager.register(series.name, series.SeriesClass, seriesParams);
        });
    },

    /**
     * Add tooltip component.
     * @private
     */
    _addTooltipComponent: function() {
        var TooltipClass = this.hasGroupTooltip ? GroupTooltip : Tooltip;
        this.componentManager.register('tooltip', TooltipClass, this._makeTooltipData());
    },

    /**
     * Add legend component.
     * @param {null | object} LegendClass - Legend type class
     * @param {Array.<string>} seriesNames - series names
     * @param {string} chartType chartType
     * @private
     */
    _addLegendComponent: function(LegendClass, seriesNames, chartType) {
        this.componentManager.register('legend', LegendClass || Legend, {
            seriesNames: seriesNames,
            chartType: chartType,
            userEvent: this.userEvent
        });
    },

    /**
     * Add components for axis type chart.
     * @param {object} params parameters
     *      @param {object} params.axes axes data
     *      @param {object} params.plotData plot data
     *      @param {function} params.serieses serieses
     * @private
     */
    _addComponentsForAxisType: function(params) {
        var options = this.options;
        var aligned = !!params.aligned;
        var LegendClass;

        if (params.plot) {
            this.componentManager.register('plot', Plot);
        }

        this._addAxisComponents(params.axis, aligned);

        if (options.legend.visible) {
            LegendClass = tui.util.isObject(params.legend) ? params.legend.LegendClass : null;
            this._addLegendComponent(LegendClass, params.seriesNames, params.chartType);
        }

        this._addSeriesComponents(params.series, options);
        this._addTooltipComponent();
        this._addCustomEventComponent();
    },

    /**
     * Get limit map.
     * @param {{yAxis: object, xAxis: object}} axesData axes data
     * @param {Array.<string>} chartTypes chart types
     * @returns {{column: ?axisLimit, line: ?axisLimit}} limit map
     * @private
     */
    _getLimitMap: function(axesData, chartTypes) {
        var limitMap = {},
            yAxisLimit = axesData.yAxis ? axesData.yAxis.limit : axesData.rightYAxis.limit;

        limitMap[chartTypes[0]] = this.isVertical ? yAxisLimit : axesData.xAxis.limit;

        if (chartTypes.length > 1) {
            limitMap[chartTypes[1]] = axesData.rightYAxis ? axesData.rightYAxis.limit : yAxisLimit;
        }

        return limitMap;
    },

    /**
     * Get map for AxisScaleMaker of axes(xAxis, yAxis).
     * @returns {Object.<string, AxisScaleMaker>}
     * @private
     */
    _getAxisScaleMakerMap: function() {
        if (!this.axisScaleMakerMap) {
            this.axisScaleMakerMap = this._makeAxisScaleMakerMap();
        }

        return this.axisScaleMakerMap;
    },

    /**
     * Make axis data for rendering area of axis like yAxis, xAxis, rightYAxis.
     * @param {AxisScaleMaker} axisScaleMaker - AxisScaleMaker
     * @param {object} options - options for axis
     * @param {boolean} [isVertical] - whether vertical or not
     * @param {boolean} [isPositionRight] - whether right position or not
     * @returns {object}
     * @private
     */
    _makeAxisData: function(axisScaleMaker, options, isVertical, isPositionRight) {
        var aligned = predicate.isLineTypeChart(this.chartType, this.chartTypes);
        var axisData;

        if (axisScaleMaker) {
            axisData = axisDataMaker.makeValueAxisData({
                axisScaleMaker: axisScaleMaker,
                options: options,
                isVertical: !!isVertical,
                isPositionRight: !!isPositionRight,
                aligned: !!aligned
            });
        } else {
            axisData = axisDataMaker.makeLabelAxisData({
                labels: this.dataProcessor.getCategories(isVertical),
                options: options,
                isVertical: !!isVertical,
                isPositionRight: !!isPositionRight,
                aligned: !!aligned,
                addedDataCount: tui.util.pick(this.options.series, 'shifting') ? this.addedDataCount : 0
            });
        }

        return axisData;
    },

    /**
     * Make axes data, used in a axis component like yAxis, xAxis, rightYAxis.
     * @returns {object} axes data
     * @private
     * @override
     */
    _makeAxesData: function() {
        var axisScaleMakerMap = this._getAxisScaleMakerMap();
        var options = this.options;
        var yAxisOptions = tui.util.isArray(options.yAxis) ? options.yAxis : [options.yAxis];
        var axesData = {
            xAxis: this._makeAxisData(axisScaleMakerMap.xAxis, options.xAxis),
            yAxis: this._makeAxisData(axisScaleMakerMap.yAxis, yAxisOptions[0], true)
        };

        if (this.hasRightYAxis) {
            axesData.rightYAxis = this._makeAxisData(null, yAxisOptions[1], true, true);
        }

        return axesData;
    },

    /**
     * Make series data for rendering.
     * @param {{yAxis: object, xAxis: object}} axesData axes data
     * @param {Array.<string>} chartTypes chart types
     * @param {boolean} isVertical whether vertical or not
     * @returns {object} series data
     * @private
     */
    _makeSeriesDataForRendering: function(axesData, chartTypes) {
        var limitMap = this._getLimitMap(axesData, chartTypes);
        var aligned = axesData.xAxis.aligned;
        var seriesData = {};

        tui.util.forEachArray(chartTypes, function(chartType) {
            seriesData[chartType + 'Series'] = {
                limit: limitMap[chartType],
                aligned: aligned,
                hasAxes: true
            };
        });

        return seriesData;
    },

    /**
     * Add data ratios.
     * @private
     * @override
     */
    _addDataRatios: function() {
        var self = this;
        var axesData = this.boundsMaker.getAxesData();
        var chartTypes = this.chartTypes || [this.chartType];
        var limitMap = this._getLimitMap(axesData, chartTypes);
        var stackType = tui.util.pick(this.options.series, 'stackType');

        tui.util.forEachArray(chartTypes, function(chartType) {
            self.dataProcessor.addDataRatios(limitMap[chartType], stackType, chartType);
        });
    },

    /**
     * Make rendering data for axis type chart.
     * @returns {object} data for rendering
     * @private
     * @override
     */
    _makeRenderingData: function() {
        var axesData = this.boundsMaker.getAxesData();
        var optionChartTypes = this.chartTypes || [this.chartType];
        var seriesData = this._makeSeriesDataForRendering(axesData, optionChartTypes, this.isVertical);
        var yAxis = axesData.yAxis ? axesData.yAxis : axesData.rightYAxis;
        var xAxis = axesData.xAxis;

        return tui.util.extend({
            plot: {
                vTickCount: yAxis.validTickCount,
                hTickCount: axesData.xAxis.validTickCount
            },
            customEvent: {
                tickCount: this.isVertical ? (xAxis.eventTickCount || xAxis.tickCount) : yAxis.tickCount
            }
        }, seriesData, axesData);
    },

    /**
     * Add grouped event handler layer.
     * @private
     * @override
     */
    _addCustomEventComponentForGroupTooltip: function() {
        this.componentManager.register('customEvent', GroupTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical,
            chartTypes: this.chartTypes,
            zoomable: tui.util.pick(this.options.series, 'zoomable')
        });
    },

    /**
     * Add custom event component for normal tooltip.
     * @private
     */
    _addCustomEventComponentForNormalTooltip: function() {
        this.componentManager.register('customEvent', BoundsTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical
        });
    },

    /**
     * Add custom event component.
     * @private
     */
    _addCustomEventComponent: function() {
        if (this.hasGroupTooltip) {
            this._addCustomEventComponentForGroupTooltip();
        } else {
            this._addCustomEventComponentForNormalTooltip();
        }
    },

    /**
     * Attach coordinate event.
     * @param {CustomEvent} customEvent custom event component
     * @param {Tooltip} tooltip tooltip component
     * @param {Array.<Series>} serieses series components
     * @private
     */
    _attachCustomEventForGroupTooltip: function(customEvent, tooltip, serieses) {
        customEvent.on('showGroupTooltip', tooltip.onShow, tooltip);
        customEvent.on('hideGroupTooltip', tooltip.onHide, tooltip);

        tui.util.forEach(serieses, function(series) {
            if (series.onShowGroupTooltipLine) {
                tooltip.on('showGroupTooltipLine', series.onShowGroupTooltipLine, series);
                tooltip.on('hideGroupTooltipLine', series.onHideGroupTooltipLine, series);
            }
            tooltip.on('showGroupAnimation', series.onShowGroupAnimation, series);
            tooltip.on('hideGroupAnimation', series.onHideGroupAnimation, series);
        });
    },

    /**
     * Attach custom event for normal tooltip.
     * @param {CustomEvent} customEvent custom event component
     * @param {Tooltip} tooltip tooltip component
     * @param {Array.<Series>} serieses series components
     * @private
     */
    _attachCustomEventForNormalTooltip: function(customEvent, tooltip, serieses) {
        customEvent.on('showTooltip', tooltip.onShow, tooltip);
        customEvent.on('hideTooltip', tooltip.onHide, tooltip);

        tui.util.forEach(serieses, function(series) {
            var showAnimationEventName, hideAnimationEventName;

            if (series.onShowAnimation) {
                showAnimationEventName = renderUtil.makeCustomEventName('show', series.chartType, 'animation');
                hideAnimationEventName = renderUtil.makeCustomEventName('hide', series.chartType, 'animation');
                tooltip.on(showAnimationEventName, series.onShowAnimation, series);
                tooltip.on(hideAnimationEventName, series.onHideAnimation, series);
            }
        });
    },

    /**
     * Attach custom event for series selection.
     * @param {CustomEvent} customEvent custom event component
     * @param {Array.<Series>} serieses series components
     * @private
     */
    _attachCustomEventForSeriesSelection: function(customEvent, serieses) {
        tui.util.forEach(serieses, function(series) {
            var selectSeriesEventName = renderUtil.makeCustomEventName('select', series.chartType, 'series'),
                unselectSeriesEventName = renderUtil.makeCustomEventName('unselect', series.chartType, 'series');

            customEvent.on(selectSeriesEventName, series.onSelectSeries, series);
            customEvent.on(unselectSeriesEventName, series.onUnselectSeries, series);
        });
    },

    /**
     * Attach custom event.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var serieses = this.componentManager.where({componentType: 'series'}),
            customEvent = this.componentManager.get('customEvent'),
            tooltip = this.componentManager.get('tooltip');

        ChartBase.prototype._attachCustomEvent.call(this, serieses);

        if (this.hasGroupTooltip) {
            this._attachCustomEventForGroupTooltip(customEvent, tooltip, serieses);
        } else {
            this._attachCustomEventForNormalTooltip(customEvent, tooltip, serieses);
        }

        this._attachCustomEventForSeriesSelection(customEvent, serieses);
    }
};

module.exports = axisTypeMixer;

},{"../axes/axis":1,"../customEvents/boundsTypeCustomEvent":35,"../customEvents/groupTypeCustomEvent":37,"../helpers/axisDataMaker":54,"../helpers/predicate":61,"../helpers/renderUtil":63,"../legends/legend":67,"../plots/plot":72,"../tooltips/groupTooltip":108,"../tooltips/tooltip":112,"./chartBase":11}],8:[function(require,module,exports){
/**
 * @fileoverview Bar chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var chartConst = require('../const');
var axisTypeMixer = require('./axisTypeMixer');
var barTypeMixer = require('./barTypeMixer');
var predicate = require('../helpers/predicate');
var Series = require('../series/barChartSeries');

var BarChart = tui.util.defineClass(ChartBase, /** @lends BarChart.prototype */ {
    /**
     * Bar chart.
     * @constructs BarChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        /**
         * className
         * @type {string}
         */
        this.className = 'tui-bar-chart';

        /**
         * Whether has right y axis or not.
         * @type {boolean}
         */
        this.hasRightYAxis = false;

        options.yAxis = options.yAxis || {};
        options.xAxis = options.xAxis || {};
        options.plot = options.plot || {};
        options.series = options.series || {};

        if (predicate.isValidStackOption(options.series.stackType)) {
            rawData.series = this._sortRawSeriesData(rawData.series);
        }

        if (options.series.diverging) {
            rawData.series = this._makeRawSeriesDataForDiverging(rawData.series, options.series.stackType);
            this._updateDivergingOption(options);
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Update options for diverging option.
     * @param {object} options options
     * @private
     */
    _updateDivergingOption: function(options) {
        var isCenter;

        options.series.stackType = options.series.stackType || chartConst.NORMAL_STACK_TYPE;
        this.hasRightYAxis = tui.util.isArray(options.yAxis) && options.yAxis.length > 1;

        isCenter = predicate.isYAxisAlignCenter(this.hasRightYAxis, options.yAxis.align);

        options.yAxis.isCenter = isCenter;
        options.xAxis.divided = isCenter;
        options.series.divided = isCenter;
        options.plot.divided = isCenter;
    },

    /**
     * Make map for AxisScaleMaker of axes(xAxis, yAxis).
     * @returns {Object.<string, AxisScaleMaker>}
     * @private
     */
    _makeAxisScaleMakerMap: function() {
        return {
            xAxis: this._createAxisScaleMaker(this.options.xAxis, 'xAxis')
        };
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        var axes = [
            {
                name: 'yAxis',
                isLabel: true,
                isVertical: true
            },
            {
                name: 'xAxis'
            }
        ];

        if (this.hasRightYAxis) {
            axes.push({
                name: 'rightYAxis',
                isLabel: true,
                isVertical: true
            });
        }
        this._addComponentsForAxisType({
            chartType: chartType,
            axis: axes,
            series: [
                {
                    name: 'barSeries',
                    SeriesClass: Series
                }
            ],
            plot: true
        });
    },

    /**
     * On change selected legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     */
    onChangeCheckedLegends: function(checkedLegends) {
        var boundParams;

        if (this.hasRightYAxis) {
            boundParams = {
                optionChartTypes: ['bar', 'bar']
            };
        }

        ChartBase.prototype.onChangeCheckedLegends.call(this, checkedLegends, null, boundParams);
    }
});

tui.util.extend(BarChart.prototype, axisTypeMixer, barTypeMixer);

module.exports = BarChart;

},{"../const":31,"../helpers/predicate":61,"../series/barChartSeries":90,"./axisTypeMixer":7,"./barTypeMixer":9,"./chartBase":11}],9:[function(require,module,exports){
/**
 * @fileoverview barTypeMixer is mixer of bar type chart(bar, column).
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    rawDataHandler = require('../helpers/rawDataHandler'),
    predicate = require('../helpers/predicate');

/**
 * barTypeMixer is mixer of bar type chart(bar, column).
 * @mixin
 */
var barTypeMixer = {
    /**
     * Make minus values.
     * @param {Array.<number>} data number data
     * @returns {Array} minus values
     * @private
     */
    _makeMinusValues: function(data) {
        return tui.util.map(data, function(value) {
            return value < 0 ? 0 : -value;
        });
    },

    /**
     * Make plus values.
     * @param {Array.<number>} data number data
     * @returns {Array} plus values
     * @private
     */
    _makePlusValues: function(data) {
        return tui.util.map(data, function(value) {
            return value < 0 ? 0 : value;
        });
    },

    /**
     * Make normal diverging raw series data.
     * @param {{data: Array.<number>}} rawSeriesData raw series data
     * @returns {{data: Array.<number>}} changed raw series data
     * @private
     */
    _makeNormalDivergingRawSeriesData: function(rawSeriesData) {
        rawSeriesData.length = Math.min(rawSeriesData.length, 2);

        rawSeriesData[0].data = this._makeMinusValues(rawSeriesData[0].data);

        if (rawSeriesData[1]) {
            rawSeriesData[1].data = this._makePlusValues(rawSeriesData[1].data);
        }

        return rawSeriesData;
    },

    /**
     * Make raw series data for stacked diverging option.
     * @param {{data: Array.<number>, stack: string}} rawSeriesData raw series data
     * @returns {{data: Array.<number>}} changed raw series data
     * @private
     */
    _makeRawSeriesDataForStackedDiverging: function(rawSeriesData) {
        var self = this,
            stacks = rawDataHandler.pickStacks(rawSeriesData, true),
            result = [],
            leftStack = stacks[0],
            rightStack = stacks[1];

        rawSeriesData = rawDataHandler.sortSeriesData(rawSeriesData, stacks);

        tui.util.forEachArray(rawSeriesData, function(seriesDatum) {
            var stack = seriesDatum.stack || chartConst.DEFAULT_STACK;
            if (stack === leftStack) {
                seriesDatum.data = self._makeMinusValues(seriesDatum.data);
                result.push(seriesDatum);
            } else if (stack === rightStack) {
                seriesDatum.data = self._makePlusValues(seriesDatum.data);
                result.push(seriesDatum);
            }
        });

        return result;
    },

    /**
     * Make raw series data for diverging.
     * @param {{data: Array.<number>, stack: string}} rawSeriesData raw series data
     * @param {?string} stackTypeOption stackType option
     * @returns {{data: Array.<number>}} changed raw series data
     * @private
     */
    _makeRawSeriesDataForDiverging: function(rawSeriesData, stackTypeOption) {
        if (predicate.isValidStackOption(stackTypeOption)) {
            rawSeriesData = this._makeRawSeriesDataForStackedDiverging(rawSeriesData);
        } else {
            rawSeriesData = this._makeNormalDivergingRawSeriesData(rawSeriesData);
        }

        return rawSeriesData;
    },

    /**
     * Sort raw series data from stacks.
     * @param {Array.<{data: Array.<number>, stack: string}>} rawSeriesData raw series data
     * @returns {Array.<{data: Array.<number>, stack: string}>}
     * @private
     */
    _sortRawSeriesData: function(rawSeriesData) {
        var stacks = rawDataHandler.pickStacks(rawSeriesData);

        return rawDataHandler.sortSeriesData(rawSeriesData, stacks);
    }
};

module.exports = barTypeMixer;

},{"../const":31,"../helpers/predicate":61,"../helpers/rawDataHandler":62}],10:[function(require,module,exports){
/**
 * @fileoverview Bubble chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var chartConst = require('../const');
var Series = require('../series/bubbleChartSeries');
var CircleLegend = require('../legends/circleLegend');
var axisTypeMixer = require('./axisTypeMixer');
var predicate = require('../helpers/predicate');
var SimpleCustomEvent = require('../customEvents/simpleCustomEvent');

var BubbleChart = tui.util.defineClass(ChartBase, /** @lends BubbleChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-bubble-chart',
    /**
     * Bubble chart.
     * @constructs BubbleChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        options.tooltip = options.tooltip || {};

        this.axisScaleMakerMap = null;

        if (!options.tooltip.align) {
            options.tooltip.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Set default options.
     * @param {object} options - options for bubble chart
     * @private
     * @override
     */
    _setDefaultOptions: function(options) {
        ChartBase.prototype._setDefaultOptions.call(this, options);
        this.options.circleLegend = this.options.circleLegend || {};

        if (tui.util.isUndefined(this.options.circleLegend.visible)) {
            this.options.circleLegend.visible = true;
        }
    },

    /**
     * Make map for AxisScaleMaker of axes(xAxis, yAxis).
     * @returns {Object.<string, AxisScaleMaker>}
     * @private
     */
    _makeAxisScaleMakerMap: function() {
        var hasCategories = this.dataProcessor.hasCategories();
        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType);
        var isXCountGreaterThanYCount = seriesDataModel.isXCountGreaterThanYCount();
        var options = this.options;
        var scaleMakerMap = {};

        if (hasCategories) {
            if (isXCountGreaterThanYCount) {
                scaleMakerMap.xAxis = this._createAxisScaleMaker(options.xAxis, 'xAxis', 'x');
            } else {
                scaleMakerMap.yAxis = this._createAxisScaleMaker(options.yAxis, 'yAxis', 'y', null, {
                    isVertical: true
                });
            }
        } else {
            scaleMakerMap.xAxis = this._createAxisScaleMaker(options.xAxis, 'xAxis', 'x');
            scaleMakerMap.yAxis = this._createAxisScaleMaker(options.yAxis, 'yAxis', 'y', null, {
                isVertical: true
            });
        }

        return scaleMakerMap;
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        this._addComponentsForAxisType({
            chartType: chartType,
            axis: [
                {
                    name: 'yAxis',
                    isVertical: true
                },
                {
                    name: 'xAxis'
                }
            ],
            series: [
                {
                    name: 'bubbleSeries',
                    SeriesClass: Series
                }
            ],
            plot: true
        });

        if (this.options.circleLegend.visible) {
            this.componentManager.register('circleLegend', CircleLegend, {
                chartType: chartType,
                baseFontFamily: this.theme.chart.fontFamily
            });
        }
    },

    /**
     * Update width of legend and series of boundsMaker.
     * @param {number} seriesWidth - width of series area
     * @param {number} legendWidth - width of legend area
     * @private
     */
    _updateLegendAndSeriesWidth: function(seriesWidth, legendWidth) {
        var circleLegendWidth = this.boundsMaker.getDimension('circleLegend').width;

        if (predicate.hasVerticalLegendWidth(this.options.legend)) {
            this.boundsMaker.registerBaseDimension('legend', {
                width: circleLegendWidth
            });
        }

        this.boundsMaker.registerBaseDimension('series', {
            width: seriesWidth - (circleLegendWidth - legendWidth)
        });
    },

    /**
     * Update width of legend area by width of circle legend area.
     * @private
     */
    _updateLegendWidthByCircleLegendWidth: function() {
        var boundsMaker = this.boundsMaker;
        var axesData = boundsMaker.getAxesData();
        var circleLegendWidth = boundsMaker.getDimension('circleLegend').width;
        var legendWidth = boundsMaker.getDimension('calculationLegend').width;
        var isXAxisLabel, seriesWidth;

        if (legendWidth >= circleLegendWidth) {
            return;
        }

        isXAxisLabel = axesData.xAxis.isLabel;
        seriesWidth = boundsMaker.getDimension('series').width;

        this._updateLegendAndSeriesWidth(seriesWidth, legendWidth);

        if (!isXAxisLabel) {
            this.axisScaleMakerMap = null;
            this._registerAxesData();
        }
    },

    /**
     * Update dimensions.
     * @private
     * @override
     */
    _updateDimensions: function() {
        if (!this.options.circleLegend.visible) {
            return;
        }

        this.componentManager.get('circleLegend').registerCircleLegendDimension();
        this._updateLegendWidthByCircleLegendWidth();
    }
});

tui.util.extend(BubbleChart.prototype, axisTypeMixer);

/**
 * Add data ratios.
 * @private
 * @override
 */
BubbleChart.prototype._addDataRatios = function() {
    var scaleMakerMap = this._getAxisScaleMakerMap();
    var limitMap = {};

    if (scaleMakerMap.xAxis) {
        limitMap.x = scaleMakerMap.xAxis.getLimit();
    }

    if (scaleMakerMap.yAxis) {
        limitMap.y = scaleMakerMap.yAxis.getLimit();
    }

    this.dataProcessor.addDataRatiosForCoordinateType(this.chartType, limitMap, true);
};

/**
 * Add custom event component for normal tooltip.
 * @private
 */
BubbleChart.prototype._attachCustomEvent = function() {
    var componentManager = this.componentManager;
    var customEvent = componentManager.get('customEvent');
    var bubbleSeries = componentManager.get('bubbleSeries');
    var tooltip = componentManager.get('tooltip');

    axisTypeMixer._attachCustomEvent.call(this);

    customEvent.on({
        clickBubbleSeries: bubbleSeries.onClickSeries,
        moveBubbleSeries: bubbleSeries.onMoveSeries
    }, bubbleSeries);

    bubbleSeries.on({
        showTooltip: tooltip.onShow,
        hideTooltip: tooltip.onHide,
        showTooltipContainer: tooltip.onShowTooltipContainer,
        hideTooltipContainer: tooltip.onHideTooltipContainer
    }, tooltip);
};

/**
 * Add custom event component.
 * @private
 */
BubbleChart.prototype._addCustomEventComponent = function() {
    this.componentManager.register('customEvent', SimpleCustomEvent, {
        chartType: this.chartType
    });
};

module.exports = BubbleChart;

},{"../const":31,"../customEvents/simpleCustomEvent":39,"../helpers/predicate":61,"../legends/circleLegend":66,"../series/bubbleChartSeries":92,"./axisTypeMixer":7,"./chartBase":11}],11:[function(require,module,exports){
/**
 * @fileoverview ChartBase
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ComponentManager = require('./componentManager');
var DefaultDataProcessor = require('../dataModels/dataProcessor');
var BoundsMaker = require('../helpers/boundsMaker');
var AxisScaleMaker = require('../helpers/axisScaleMaker');
var dom = require('../helpers/domHandler');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');
var UserEventListener = require('../helpers/userEventListener');

var ChartBase = tui.util.defineClass(/** @lends ChartBase.prototype */ {
    /**
     * Chart base.
     * @constructs ChartBase
     * @param {object} params parameters
     *      @param {object} params.rawData raw data
     *      @param {object} params.theme chart theme
     *      @param {object} params.options chart options
     *      @param {boolean} params.hasAxes whether has axes or not
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {DataProcessor} params.DataProcessor DataProcessor
     */
    init: function(params) {
        /**
         * theme
         * @type {object}
         */
        this.theme = params.theme;

        /**
         * options
         * @type {object}
         */
        this.options = null;
        this._setDefaultOptions(params.options);

        /**
         * chart type
         * @type {string}
         */
        this.chartType = this.options.chartType;

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = params.hasAxes;

        /**
         * whether vertical or not
         * @type {boolean}
         */
        this.isVertical = !!params.isVertical;

        /**
         * whether chart has group tooltip or not
         * @type {boolean}
         */
        this.hasGroupTooltip = !!tui.util.pick(this.options, 'tooltip', 'grouped');

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = this._createDataProcessor(params);

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = new BoundsMaker({
            options: this.options,
            theme: this.theme,
            dataProcessor: this.dataProcessor,
            hasAxes: this.hasAxes,
            isVertical: this.isVertical,
            chartType: this.chartType,
            chartTypes: params.seriesNames
        });

        /**
         * component manager
         * @type {ComponentManager}
         */
        this.componentManager = new ComponentManager({
            dataProcessor: this.dataProcessor,
            options: this.options,
            theme: this.theme,
            boundsMaker: this.boundsMaker,
            hasAxes: this.hasAxes
        });

        /**
         * user event listener
         * @type {object}
         */
        this.userEvent = new UserEventListener();
    },

    /**
     * Set default options.
     * @param {object} options - options for chart
     * @private
     */
    _setDefaultOptions: function(options) {
        options.legend = options.legend || {};

        if (tui.util.isUndefined(options.legend.visible)) {
            options.legend.visible = true;
        }

        this.options = options;
    },

    /**
     * Create dataProcessor for processing raw data.
     * @param {object} params parameters
     *      @param {object} params.rawData - raw data
     *      @param {DataProcessor} params.DataProcessor - DataProcessor class
     *      @param {{chart: object, chartType: string}} params.options - chart options
     *      @param {Array} params.seriesNames series - chart types for rendering series
     * @returns {object} data processor
     * @private
     */
    _createDataProcessor: function(params) {
        var DataProcessor, dataProcessor;

        DataProcessor = params.DataProcessor || DefaultDataProcessor;
        dataProcessor = new DataProcessor(params.rawData, this.chartType, params.options, params.seriesNames);

        return dataProcessor;
    },

    /**
     * Pick limit from options.
     * @param {{min: number, max: number, title: string}} options - axis options
     * @returns {{min: ?number, max: ?number}}
     * @private
     */
    _pickLimitFromOptions: function(options) {
        options = options || {};

        return {
            min: options.min,
            max: options.max
        };
    },

    /**
     * Create AxisScaleMaker.
     * AxisScaleMaker calculates the limit and step into values of processed data and returns it.
     * @param {{title: string, min: number, max: number}} axisOptions - options for axis
     * @param {string} areaType - type of area like series, xAxis, yAxis, circleLegend, legend
     * @param {string} valueType - type of value like value, x, y, r
     * @param {string} chartType - type of chart
     * @param {?object} additionalParams additional parameters
     * @returns {AxisScaleMaker}
     * @private
     */
    _createAxisScaleMaker: function(axisOptions, areaType, valueType, chartType, additionalParams) {
        var limit = this._pickLimitFromOptions(axisOptions);
        var seriesOptions = this.options.series || {};

        chartType = chartType || this.chartType;
        seriesOptions = seriesOptions[chartType] || seriesOptions;

        return new AxisScaleMaker(tui.util.extend({
            dataProcessor: this.dataProcessor,
            boundsMaker: this.boundsMaker,
            options: {
                stackType: seriesOptions.stackType,
                diverging: seriesOptions.diverging,
                limit: limit
            },
            isVertical: this.isVertical,
            areaType: areaType,
            valueType: valueType,
            chartType: chartType
        }, additionalParams));
    },

    /**
     * Make data for tooltip component.
     * @returns {object} tooltip data
     * @private
     */
    _makeTooltipData: function() {
        return {
            isVertical: this.isVertical,
            userEvent: this.userEvent,
            chartType: this.chartType
        };
    },

    /**
     * Make rendering data for axis type chart.
     * @returns {object} rendering data.
     * @private
     */
    _makeRenderingData: function() {
        return {};
    },

    /**
     * Attach custom event.
     * @param {Array.<object>} serieses serieses
     * @private
     */
    _attachCustomEvent: function(serieses) {
        var legend = this.componentManager.get('legend');
        var customEvent = this.componentManager.get('customEvent');

        serieses = serieses || this.componentManager.where({componentType: 'series'});

        if (tui.util.pick(this.options.series, 'zoomable')) {
            customEvent.on('zoom', this.onZoom, this);
            customEvent.on('resetZoom', this.onResetZoom, this);
        }

        if (legend) {
            legend.on('changeCheckedLegends', this.onChangeCheckedLegends, this);
            tui.util.forEach(serieses, function(series) {
                var selectLegendEventName = renderUtil.makeCustomEventName('select', series.chartType, 'legend');
                legend.on(selectLegendEventName, series.onSelectLegend, series);
            });
        }
    },

    /**
     * Make axes data, used in a axis component like yAxis, xAxis, rightYAxis.
     * @abstract
     * @private
     */
    _makeAxesData: function() {},

    /**
     * Update dimensions.
     * @abstract
     * @private
     */
    _updateDimensions: function() {},

    /**
     * Add data ratios.
     * @private
     * @abstract
     */
    _addDataRatios: function() {},

    /**
     * Execute component function.
     * @param {string} funcName function name
     * @private
     */
    _executeComponentFunc: function(funcName) {
        this.componentManager.each(function(component) {
            if (component[funcName]) {
                component[funcName]();
            }
        });
    },

    /**
     * Register axes data, used in a axis component like yAxis, xAxis.
     * @private
     */
    _registerAxesData: function() {
        var axesData = this._makeAxesData();
        this.boundsMaker.registerAxesData(axesData);
    },

    /**
     * Update axesData.
     * @private
     * @abstract
     */
    _updateAxesData: function() {},

    /**
     * Render.
     * @param {function} onRender render callback function
     * @private
     */
    _render: function(onRender) {
        var labelAxisOptions = (this.isVertical ? this.options.xAxis : this.options.yAxis) || {};
        var renderingData;

        this._executeComponentFunc('registerDimension');
        this._registerAxesData();
        this._executeComponentFunc('registerAdditionalDimension');
        this.boundsMaker.registerSeriesDimension();

        if (this.hasAxes && predicate.isAutoTickInterval(labelAxisOptions.tickInterval)) {
            this._updateAxesData();
        }

        this._updateDimensions();

        this.boundsMaker.registerBoundsData();
        this._addDataRatios();

        renderingData = this._makeRenderingData();

        onRender(renderingData);

        this._sendSeriesData();
    },

    /**
     * Render chart.
     * @returns {HTMLElement} chart element
     */
    render: function() {
        var el = dom.create('DIV', this.className),
            self = this;

        dom.addClass(el, 'tui-chart');
        this._renderTitle(el);
        renderUtil.renderDimension(el, this.boundsMaker.getDimension('chart'));
        renderUtil.renderBackground(el, this.theme.chart.background);
        renderUtil.renderFontFamily(el, this.theme.chart.fontFamily);

        this._render(function(renderingData) {
            self._renderComponents(renderingData, 'render', el);
        });

        this._attachCustomEvent();
        this.chartContainer = el;

        return el;
    },

    /**
     * Filter raw data belong to checked legend.
     * @param {object} rawData raw data
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @returns {object} rawData
     * @private
     */
    _filterCheckedRawData: function(rawData, checkedLegends) {
        var cloneData = JSON.parse(JSON.stringify(rawData));

        if (tui.util.isArray(cloneData.series)) {
            cloneData.series = tui.util.filter(cloneData.series, function(series, index) {
                return checkedLegends[index];
            });
        } else {
            tui.util.forEach(cloneData.series, function(serieses, chartType) {
                if (!checkedLegends[chartType]) {
                    cloneData.series[chartType] = [];
                } else if (checkedLegends[chartType].length) {
                    cloneData.series[chartType] = tui.util.filter(serieses, function(series, index) {
                        return checkedLegends[chartType][index];
                    });
                }
            });
        }

        return cloneData;
    },

    /**
     * Make rerendering data.
     * @param {object} renderingData rendering data
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @returns {object} rendering data
     * @private
     */
    _makeRerenderingData: function(renderingData, checkedLegends) {
        var tooltipData = this._makeTooltipData();
        var serieses = this.componentManager.where({componentType: 'series'});

        renderingData.tooltip = tui.util.extend({
            checkedLegends: checkedLegends
        }, tooltipData, renderingData.tooltip);

        tui.util.forEach(serieses, function(series) {
            renderingData[series.componentName] = tui.util.extend({
                checkedLegends: checkedLegends[series.seriesName] || checkedLegends
            }, renderingData[series.componentName]);
        });

        return renderingData;
    },

    /**
     * Rerender.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @param {?object} rawData rawData
     * @private
     */
    _rerender: function(checkedLegends, rawData) {
        var self = this;
        var dataProcessor = this.dataProcessor;

        if (!rawData) {
            rawData = this._filterCheckedRawData(dataProcessor.getZoomedRawData(), checkedLegends);
        }

        this.axisScaleMakerMap = null;
        this.dataProcessor.initData(rawData);
        this.boundsMaker.initBoundsData();
        this._render(function(renderingData) {
            renderingData = self._makeRerenderingData(renderingData, checkedLegends);
            self._renderComponents(renderingData, 'rerender');
        });
    },

    /**
     * On change checked legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @param {?object} rawData rawData
     * @param {?object} boundsParams addition params for calculating bounds
     */
    onChangeCheckedLegends: function(checkedLegends, rawData, boundsParams) {
        this._rerender(checkedLegends, rawData, boundsParams);
    },

    /**
     * On zoom.
     * @abstract
     */
    onZoom: function() {},

    /**
     * On reset zoom.
     * @abstract
     */
    onResetZoom: function() {},

    /**
     * Render title.
     * @param {HTMLElement} container - container
     * @private
     */
    _renderTitle: function(container) {
        var chartOptions = this.options.chart || {};
        var titleElement = renderUtil.renderTitle(chartOptions.title, this.theme.title, 'tui-chart-title');

        dom.append(container, titleElement);
    },

    /**
     * Render components.
     * @param {object} renderingData data for rendering
     * @param {string} funcName function name for execution
     * @param {HTMLElement} container container element
     * @private
     */
    _renderComponents: function(renderingData, funcName, container) {
        var paper;
        var elements = this.componentManager.map(function(component) {
            var element = null;
            var data, result;

            if (component[funcName]) {
                data = renderingData[component.componentName] || renderingData || {};
                data.paper = paper;
                result = component[funcName](data);

                if (result && result.container) {
                    element = result.container;
                    paper = result.paper;
                } else {
                    element = result;
                }
            }

            return element;
        });

        if (container) {
            dom.append(container, elements);
        }
    },

    /**
     * Send series data to custom event component.
     * @param {string} chartType - type of chart
     * @private
     */
    _sendSeriesData: function(chartType) {
        var self = this,
            customEvent = this.componentManager.get('customEvent'),
            seriesInfos, chartTypes;

        if (!customEvent) {
            return;
        }

        chartTypes = this.chartTypes || [chartType || this.chartType];
        seriesInfos = tui.util.map(chartTypes, function(seriesName) {
            var _chartType = self.dataProcessor.findChartType(seriesName);
            var componentName = (seriesName || _chartType) + 'Series';
            var component = self.componentManager.get(componentName) || self.componentManager.get('series');

            return {
                chartType: _chartType,
                data: component.getSeriesData()
            };
        });

        customEvent.initCustomEventData(seriesInfos);
    },

    /**
     * Make event name for animation.
     * @param {string} chartType chart type
     * @param {string} prefix prefix
     * @returns {string} event name
     * @private
     */
    _makeAnimationEventName: function(chartType, prefix) {
        return prefix + chartType.substring(0, 1).toUpperCase() + chartType.substring(1) + 'Animation';
    },

    /**
     * Animate chart.
     */
    animateChart: function() {
        this.componentManager.each(function(component) {
            if (component.animateComponent) {
                component.animateComponent();
            }
        });
    },

    /**
     * Register of user event.
     * @param {string} eventName event name
     * @param {function} func event callback
     */
    on: function(eventName, func) {
        this.userEvent.register(eventName, func);
    },

    /**
     * Update dimension of chart.
     * @param {{width: number, height: number}} dimension dimension
     * @returns {boolean} whether updated or not
     * @private
     */
    _updateChartDimension: function(dimension) {
        var updated = false;
        var chartOptions = this.options.chart;

        if (dimension.width && chartOptions.width !== dimension.width) {
            chartOptions.width = dimension.width;
            updated = true;
        }

        if (dimension.height && chartOptions.height !== dimension.height) {
            chartOptions.height = dimension.height;
            updated = true;
        }

        return updated;
    },

    /**
     * Public API for resizable.
     * @param {object} dimension dimension
     *      @param {number} dimension.width width
     *      @param {number} dimension.height height
     * @api
     */
    resize: function(dimension) {
        var self = this;
        var updated;

        if (!dimension) {
            return;
        }

        updated = this._updateChartDimension(dimension);

        if (!updated) {
            return;
        }

        this.boundsMaker.initBoundsData(this.options.chart);
        renderUtil.renderDimension(this.chartContainer, this.boundsMaker.getDimension('chart'));

        this._render(function(renderingData) {
            self._renderComponents(renderingData, 'resize');
        });
    },

    /**
     * Set tooltip align option.
     * @param {string} align align (left|center|right, top|middle|bottom)
     * @api
     */
    setTooltipAlign: function(align) {
        this.componentManager.get('tooltip').setAlign(align);
    },

    /**
     * Set position option.
     * @param {object} position moving position
     *      @param {number} position.left left
     *      @param {number} position.top top
     * @api
     */
    setTooltipPosition: function(position) {
        this.componentManager.get('tooltip').setPosition(position);
    },

    /**
     * Reset tooltip align option.
     * @api
     */
    resetTooltipAlign: function() {
        this.componentManager.get('tooltip').resetAlign();
    },

    /**
     * Reset tooltip position.
     * @api
     */
    resetTooltipPosition: function() {
        this.componentManager.get('tooltip').resetPosition();
    },

    /**
     * Show series label.
     * @api
     */
    showSeriesLabel: function() {
        var serieses = this.componentManager.where({componentType: 'series'});

        tui.util.forEachArray(serieses, function(series) {
            series.showLabel();
        });
    },

    /**
     * Hide series label.
     * @api
     */
    hideSeriesLabel: function() {
        var serieses = this.componentManager.where({componentType: 'series'});

        tui.util.forEachArray(serieses, function(series) {
            series.hideLabel();
        });
    },

    /**
     * Add data.
     * @abstract
     */
    addData: function() {}
});

module.exports = ChartBase;

},{"../dataModels/dataProcessor":42,"../helpers/axisScaleMaker":55,"../helpers/boundsMaker":56,"../helpers/domHandler":59,"../helpers/predicate":61,"../helpers/renderUtil":63,"../helpers/userEventListener":65,"./componentManager":16}],12:[function(require,module,exports){
/**
 * @fileoverview ColorSpectrum create a color spectrum and provide color value.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var colorutil = require('../helpers/colorutil');

var ColorSpectrum = tui.util.defineClass(/** @lends ColorSpectrum.prototype */ {
    /**
     * ColorSpectrum create a color spectrum and provide color value.
     * @constructs ColorSpectrum
     * @param {string} startColor hex color
     * @param {string} endColor hex color
     */
    init: function(startColor, endColor) {
        var endRGB;

        this.start = colorutil.colorNameToHex(startColor);
        this.startRGB = colorutil.hexToRGB(this.start);
        this.end = colorutil.colorNameToHex(endColor);

        endRGB = colorutil.hexToRGB(this.end);
        this.distances = this._makeDistances(this.startRGB, endRGB);
        this.colorMap = {};
    },

    /**
     * Make distances start RGB to end RGB.
     * @param {Array.<number>} startRGB start RGB
     * @param {Array.<number>} endRGB end RGB
     * @returns {Array.<number>} distances
     * @private
     */
    _makeDistances: function(startRGB, endRGB) {
        return tui.util.map(startRGB, function(value, index) {
            return endRGB[index] - value;
        });
    },

    /**
     * Get hex color.
     * @param {number} ratio ratio
     * @returns {string} hex color
     */
    getColor: function(ratio) {
        var hexColor = this.colorMap[ratio];
        var distances, rgbColor;

        if (!hexColor) {
            distances = this.distances;
            rgbColor = tui.util.map(this.startRGB, function(start, index) {
                return start + parseInt(distances[index] * ratio, 10);
            });
            hexColor = colorutil.rgbToHEX.apply(null, rgbColor);
        }

        return hexColor || null;
    }
});

module.exports = ColorSpectrum;

},{"../helpers/colorutil":58}],13:[function(require,module,exports){
/**
 * @fileoverview Column chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var chartConst = require('../const');
var axisTypeMixer = require('./axisTypeMixer');
var barTypeMixer = require('./barTypeMixer');
var predicate = require('../helpers/predicate');
var Series = require('../series/columnChartSeries');

var ColumnChart = tui.util.defineClass(ChartBase, /** @lends ColumnChart.prototype */ {
    /**
     * Column chart.
     * @constructs ColumnChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @mixes verticalTypeMixer
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     * @param {object} initedData initialized data from combo chart
     */
    init: function(rawData, theme, options) {
        /**
         * className
         * @type {string}
         */
        this.className = 'tui-column-chart';

        options.series = options.series || {};
        options.yAxis = options.yAxis || {};

        if (predicate.isValidStackOption(options.series.stackType)) {
            rawData.series = this._sortRawSeriesData(rawData.series);
        }

        if (options.series.diverging) {
            rawData.series = this._makeRawSeriesDataForDiverging(rawData.series, options.series.stackType);
            options.series.stackType = options.series.stackType || chartConst.NORMAL_STACK_TYPE;
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Make map for AxisScaleMaker of axes(xAxis, yAxis).
     * @returns {Object.<string, AxisScaleMaker>}
     * @private
     */
    _makeAxisScaleMakerMap: function() {
        return {
            yAxis: this._createAxisScaleMaker(this.options.yAxis, 'yAxis')
        };
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        this._addComponentsForAxisType({
            chartType: chartType,
            axis: [
                {
                    name: 'yAxis',
                    isVertical: true
                },
                {
                    name: 'xAxis',
                    isLabel: true
                }
            ],
            series: [
                {
                    name: 'columnSeries',
                    SeriesClass: Series,
                    data: {
                        allowNegativeTooltip: true
                    }
                }
            ],
            plot: true
        });
    }
});

tui.util.extend(ColumnChart.prototype, axisTypeMixer, barTypeMixer);

module.exports = ColumnChart;

},{"../const":31,"../helpers/predicate":61,"../series/columnChartSeries":93,"./axisTypeMixer":7,"./barTypeMixer":9,"./chartBase":11}],14:[function(require,module,exports){
/**
 * @fileoverview Column and Line Combo chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var axisTypeMixer = require('./axisTypeMixer');
var comboTypeMixer = require('./comboTypeMixer');
var verticalTypeComboMixer = require('./verticalTypeComboMixer');

var ColumnLineComboChart = tui.util.defineClass(ChartBase, /** @lends ColumnLineComboChart.prototype */ {
    /**
     * Column and Line Combo chart.
     * @constructs ColumnLineComboChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        this._initForVerticalTypeCombo(rawData, theme, options);
    },

    /**
     * On change selected legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     */
    onChangeCheckedLegends: function(checkedLegends) {
        var originalRawData = this.dataProcessor.getOriginalRawData();
        var rawData = this._filterCheckedRawData(originalRawData, checkedLegends);
        var chartTypesMap = this._makeChartTypesMap(rawData.series, this.options.yAxis);

        tui.util.extend(this, chartTypesMap);

        ChartBase.prototype.onChangeCheckedLegends.call(this, checkedLegends, rawData, chartTypesMap);
    }
});

tui.util.extend(ColumnLineComboChart.prototype, axisTypeMixer, comboTypeMixer, verticalTypeComboMixer);

module.exports = ColumnLineComboChart;

},{"./axisTypeMixer":7,"./chartBase":11,"./comboTypeMixer":15,"./verticalTypeComboMixer":28}],15:[function(require,module,exports){
/**
 * @fileoverview comboTypeMixer is mixer of combo type chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var defaultTheme = require('../themes/defaultTheme');

/**
 * comboTypeMixer is mixer of combo type chart.
 * @mixin
 */
var comboTypeMixer = {
    /**
     * Get base series options.
     * @param {object.<string, object>} seriesOptions - series options
     * @param {Array.<string>} chartTypes - chart types
     * @returns {object}
     * @private
     */
    _getBaseSeriesOptions: function(seriesOptions, chartTypes) {
        var baseSeriesOptions = tui.util.extend({}, seriesOptions);

        tui.util.forEachArray(chartTypes, function(chartType) {
            delete baseSeriesOptions[chartType];
        });

        return baseSeriesOptions;
    },

    /**
     * Make options map
     * @param {Array.<string>} chartTypes - chart types
     * @returns {object}
     * @private
     */
    _makeOptionsMap: function(chartTypes) {
        var seriesOptions = this.options.series;
        var baseSeriesOptions = this._getBaseSeriesOptions(seriesOptions, chartTypes);
        var optionsMap = {};

        tui.util.forEachArray(chartTypes, function(chartType) {
            optionsMap[chartType] = tui.util.extend({}, baseSeriesOptions, seriesOptions[chartType]);
        });

        return optionsMap;
    },

    /**
     * Make theme map
     * @param {object} seriesNames - series names
     * @returns {object} theme map
     * @private
     */
    _makeThemeMap: function(seriesNames) {
        var dataProcessor = this.dataProcessor;
        var theme = this.theme;
        var themeMap = {};
        var colorCount = 0;

        tui.util.forEachArray(seriesNames, function(chartType) {
            var chartTheme = JSON.parse(JSON.stringify(theme));
            var removedColors;

            if (chartTheme.series[chartType]) {
                themeMap[chartType] = chartTheme.series[chartType];
            } else if (!chartTheme.series.colors) {
                themeMap[chartType] = JSON.parse(JSON.stringify(defaultTheme.series));
                themeMap[chartType].label.fontFamily = chartTheme.chart.fontFamily;
            } else {
                removedColors = chartTheme.series.colors.splice(0, colorCount);
                chartTheme.series.colors = chartTheme.series.colors.concat(removedColors);
                themeMap[chartType] = chartTheme.series;
                colorCount += dataProcessor.getLegendLabels(chartType).length;
            }
        });

        return themeMap;
    }
};

module.exports = comboTypeMixer;

},{"../themes/defaultTheme":107}],16:[function(require,module,exports){
/**
 * @fileoverview ComponentManager manages components of chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ComponentManager = tui.util.defineClass(/** @lends ComponentManager.prototype */ {
    /**
     * ComponentManager manages components of chart.
     * @param {object} params parameters
     *      @param {object} params.theme theme
     *      @param {object} params.options options
     *      @param {DataProcessor} params.dataProcessor data processor
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     * @constructs ComponentManager
     */
    init: function(params) {
        /**
         * Components
         * @type {Array.<object>}
         */
        this.components = [];

        /**
         * Component map.
         * @type {object}
         */
        this.componentMap = {};

        /**
         * theme
         * @type {object}
         */
        this.theme = params.theme || {};

        /**
         * options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = params.hasAxes;
    },

    /**
     * Make component options.
     * @param {object} options options
     * @param {string} componentType component type
     * @param {number} index component index
     * @returns {object} options
     * @private
     */
    _makeComponentOptions: function(options, componentType, index) {
        options = options || this.options[componentType];
        options = tui.util.isArray(options) ? options[index] : options || {};

        return options;
    },

    /**
     * Register component.
     * The component refers to a component of the chart.
     * The component types are axis, legend, plot, series and customEvent.
     * Chart Component Description : https://i-msdn.sec.s-msft.com/dynimg/IC267997.gif
     * @param {string} name component name
     * @param {function} Component component constructor
     * @param {object} params component parameters
     */
    register: function(name, Component, params) {
        var index,
            component, componentType;

        params = params || {};

        componentType = params.componentType || name;
        index = params.index || 0;

        params.theme = params.theme || this.theme[componentType];
        params.options = this._makeComponentOptions(params.options, componentType, index);

        params.dataProcessor = this.dataProcessor;
        params.boundsMaker = this.boundsMaker;
        params.hasAxes = this.hasAxes;

        component = new Component(params);
        component.componentName = name;
        component.componentType = componentType;

        this.components.push(component);
        this.componentMap[name] = component;
    },

    /**
     * Iterate each components.
     * @param {function} iteratee iteratee
     */
    each: function(iteratee) {
        tui.util.forEachArray(this.components, iteratee);
    },

    /**
     * Return the results of applying the iteratee to each components.
     *  @param {function} iteratee iteratee
     * @returns {Array.<object>} components
     */
    map: function(iteratee) {
        return tui.util.map(this.components, iteratee);
    },

    /**
     * Find components to conditionMap.
     * @param {object} conditionMap condition map
     * @returns {Array.<object>} filtered components
     */
    where: function(conditionMap) {
        return tui.util.filter(this.components, function(component) {
            var contained = true;

            tui.util.forEach(conditionMap, function(value, key) {
                if (component[key] !== value) {
                    contained = false;
                }

                return contained;
            });

            return contained;
        });
    },

    /**
     * Get component.
     * @param {string} name component name
     * @returns {object} component instance
     */
    get: function(name) {
        return this.componentMap[name];
    }
});

module.exports = ComponentManager;

},{}],17:[function(require,module,exports){
/**
 * @fileoverview Heatmap chart is a graphical representation of data where the individual values contained
 *                      in a matrix are represented as colors.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var ColorSpectrum = require('./colorSpectrum');
var Series = require('../series/heatmapChartSeries');
var chartConst = require('../const');
var axisTypeMixer = require('./axisTypeMixer');
var axisDataMaker = require('../helpers/axisDataMaker');
var Legend = require('../legends/spectrumLegend');

var HeatmapChart = tui.util.defineClass(ChartBase, /** @lends HeatmapChart.prototype */ {
    /**
     *
     * className
     * @type {string}
     */
    className: 'tui-heatmap-chart',
    /**
     * Heatmap chart is a graphical representation of data where the individual values contained
     *      in a matrix are represented as colors.
     * @constructs HeatmapChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        options.tooltip = options.tooltip || {};

        if (!options.tooltip.align) {
            options.tooltip.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        }

        options.tooltip.grouped = false;

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Make map for AxisScaleMaker of axes(xAxis, yAxis).
     * @returns {object}
     * @private
     */
    _makeAxisScaleMakerMap: function() {
        return {
            legend: this._createAxisScaleMaker({}, 'legend', null, this.chartType, {
                valueCount: chartConst.SPECTRUM_LEGEND_TICK_COUNT
            })
        };
    },

    /**
     * Add components.
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function() {
        this._addComponentsForAxisType({
            axis: [
                {
                    name: 'yAxis',
                    isLabel: true,
                    isVertical: true
                },
                {
                    name: 'xAxis',
                    isLabel: true
                }
            ],
            legend: {
                LegendClass: Legend
            },
            series: [
                {
                    name: 'heatmapSeries',
                    SeriesClass: Series
                }
            ],
            tooltip: true,
            customEvent: true
        });
    }
});

tui.util.extend(HeatmapChart.prototype, axisTypeMixer);

/**
 * Add data ratios for rendering graph.
 * @private
 * @override
 */
HeatmapChart.prototype._addDataRatios = function() {
    var limit = this._getAxisScaleMakerMap().legend.getLimit();

    this.dataProcessor.addDataRatios(limit, null, this.chartType);
};

/**
 * Make rendering data for delivery to each component.
 * @returns {object}
 * @private
 * @override
 */
HeatmapChart.prototype._makeRenderingData = function() {
    var data = axisTypeMixer._makeRenderingData.call(this);
    var seriesTheme = this.theme.series;
    var colorSpectrum = new ColorSpectrum(seriesTheme.startColor, seriesTheme.endColor);

    data.legend = {
        colorSpectrum: colorSpectrum,
        axesData: axisDataMaker.makeValueAxisData({
            axisScaleMaker: this._getAxisScaleMakerMap().legend,
            isVertical: true
        })
    };
    data.heatmapSeries.colorSpectrum = colorSpectrum;

    return data;
};

/**
 * Attach custom event between components.
 * @private
 * @override
 */
HeatmapChart.prototype._attachCustomEvent = function() {
    var customEvent = this.componentManager.get('customEvent');
    var heatmapSeries = this.componentManager.get('heatmapSeries');
    var legend = this.componentManager.get('legend');

    axisTypeMixer._attachCustomEvent.call(this);

    customEvent.on('showTooltip', heatmapSeries.onShowTooltip, heatmapSeries);
    customEvent.on('hideTooltip', legend.onHideWedge, legend);

    heatmapSeries.on('showWedge', legend.onShowWedge, legend);
};

module.exports = HeatmapChart;

},{"../const":31,"../helpers/axisDataMaker":54,"../legends/spectrumLegend":71,"../series/heatmapChartSeries":95,"./axisTypeMixer":7,"./chartBase":11,"./colorSpectrum":12}],18:[function(require,module,exports){
/**
 * @fileoverview Line and Area Combo chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var axisTypeMixer = require('./axisTypeMixer');
var autoTickMixer = require('./autoTickMixer');
var zoomMixer = require('./zoomMixer');
var addingDynamicDataMixer = require('./addingDynamicDataMixer');
var comboTypeMixer = require('./comboTypeMixer');
var verticalTypeComboMixer = require('./verticalTypeComboMixer');

var LineAreaComboChart = tui.util.defineClass(ChartBase, /** @lends LineAreaComboChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-combo-chart',
    /**
     * Line and Area Combo chart.
     * @constructs LineAreaComboChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData - raw data
     * @param {object} theme - chart theme
     * @param {object} options - chart options
     */
    init: function(rawData, theme, options) {
        this._initForVerticalTypeCombo(rawData, theme, options);
        this._initForAutoTickInterval();
        this._initForAddingData();
    },

    /**
     * On change selected legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     */
    onChangeCheckedLegends: function(checkedLegends) {
        var zoomedRawData = this.dataProcessor.getZoomedRawData();
        var rawData = this._filterCheckedRawData(zoomedRawData, checkedLegends);
        var chartTypesMap = this._makeChartTypesMap(rawData.series, this.options.yAxis);

        tui.util.extend(this, chartTypesMap);

        this._changeCheckedLegends(checkedLegends, rawData, chartTypesMap);
    }
});

tui.util.extend(LineAreaComboChart.prototype,
    axisTypeMixer, autoTickMixer, zoomMixer, addingDynamicDataMixer, comboTypeMixer, verticalTypeComboMixer);

module.exports = LineAreaComboChart;

},{"./addingDynamicDataMixer":4,"./autoTickMixer":6,"./axisTypeMixer":7,"./chartBase":11,"./comboTypeMixer":15,"./verticalTypeComboMixer":28,"./zoomMixer":29}],19:[function(require,module,exports){
/**
 * @fileoverview Line chart
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var lineTypeMixer = require('./lineTypeMixer');
var autoTickMixer = require('./autoTickMixer');
var zoomMixer = require('./zoomMixer');
var axisTypeMixer = require('./axisTypeMixer');
var addingDynamicDataMixer = require('./addingDynamicDataMixer');
var Series = require('../series/lineChartSeries');

var LineChart = tui.util.defineClass(ChartBase, /** @lends LineChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-line-chart',

    /**
     * Series class
     * @type {function}
     */
    Series: Series,

    /**
     * Line chart.
     * @constructs LineChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @mixes lineTypeMixer
     */
    init: function() {
        this._lineTypeInit.apply(this, arguments);
        this._initForAutoTickInterval();
        this._initForAddingData();
    },

    /**
     * On change checked legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @param {?object} rawData rawData
     * @param {?object} boundsParams addition params for calculating bounds
     * @override
     */
    onChangeCheckedLegends: function(checkedLegends, rawData, boundsParams) {
        this._changeCheckedLegends(checkedLegends, rawData, boundsParams);
    }
});

tui.util.extend(LineChart.prototype,
    axisTypeMixer, lineTypeMixer, autoTickMixer, zoomMixer, addingDynamicDataMixer);

module.exports = LineChart;

},{"../series/lineChartSeries":96,"./addingDynamicDataMixer":4,"./autoTickMixer":6,"./axisTypeMixer":7,"./chartBase":11,"./lineTypeMixer":20,"./zoomMixer":29}],20:[function(require,module,exports){
/**
 * @fileoverview lineTypeMixer is mixer of line type chart(line, area).
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var AreaTypeCustomEvent = require('../customEvents/areaTypeCustomEvent');

/**
 * lineTypeMixer is mixer of line type chart(line, area).
 * @mixin
 */
var lineTypeMixer = {
    /**
     * Initialize line type chart.
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     * @private
     */
    _lineTypeInit: function(rawData, theme, options) {
        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Make map for AxisScaleMaker of axes(xAxis, yAxis).
     * @returns {Object.<string, AxisScaleMaker>}
     * @private
     */
    _makeAxisScaleMakerMap: function() {
        return {
            yAxis: this._createAxisScaleMaker(this.options.yAxis, 'yAxis')
        };
    },

    /**
     * Add custom event component for normal tooltip.
     * @private
     */
    _addCustomEventComponentForNormalTooltip: function() {
        this.componentManager.register('customEvent', AreaTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical,
            zoomable: tui.util.pick(this.options.series, 'zoomable')
        });
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        this._addComponentsForAxisType({
            chartType: chartType,
            axis: [
                {
                    name: 'yAxis',
                    isVertical: true
                },
                {
                    name: 'xAxis',
                    isLabel: true
                }
            ],
            series: [
                {
                    name: this.options.chartType + 'Series',
                    SeriesClass: this.Series
                }
            ],
            plot: true
        });
    }
};

module.exports = lineTypeMixer;

},{"../customEvents/areaTypeCustomEvent":32,"./chartBase":11}],21:[function(require,module,exports){
/**
 * @fileoverview Map chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var chartConst = require('../const');
var MapChartMapModel = require('./mapChartMapModel');
var ColorSpectrum = require('./colorSpectrum');
var MapChartDataProcessor = require('../dataModels/mapChartDataProcessor');
var axisDataMaker = require('../helpers/axisDataMaker');
var Series = require('../series/mapChartSeries');
var Zoom = require('../series/zoom');
var Legend = require('../legends/spectrumLegend');
var MapChartTooltip = require('../tooltips/mapChartTooltip');
var mapChartCustomEvent = require('../customEvents/mapChartCustomEvent');

var MapChart = tui.util.defineClass(ChartBase, /** @lends MapChart.prototype */ {
    /**
     * Map chart.
     * @constructs MapChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        /**
         * class name
         * @type {string}
         */
        this.className = 'tui-map-chart';

        options.tooltip = options.tooltip || {};
        options.legend = options.legend || {};

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            DataProcessor: MapChartDataProcessor
        });

        this._addComponents(options);
    },

    /**
     * Add components
     * @param {object} options chart options
     * @private
     */
    _addComponents: function(options) {
        options.legend = options.legend || {};

        this.componentManager.register('legend', Legend);

        this.componentManager.register('tooltip', MapChartTooltip, this._makeTooltipData());

        this.componentManager.register('mapSeries', Series, {
            libType: options.libType,
            chartType: options.chartType,
            componentType: 'series',
            userEvent: this.userEvent
        });

        this.componentManager.register('zoom', Zoom);

        this.componentManager.register('customEvent', mapChartCustomEvent, {
            chartType: this.chartType
        });
    },

    /**
     * Make axes data
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        var axisScaleMaker = this._createAxisScaleMaker({}, 'legend', null, this.chartType, {
            valueCount: chartConst.SPECTRUM_LEGEND_TICK_COUNT
        });

        return axisDataMaker.makeValueAxisData({
            axisScaleMaker: axisScaleMaker,
            isVertical: true
        });
    },

    /**
     * Add data ratios.
     * @private
     * @override
     */
    _addDataRatios: function() {
        var axesData = this.boundsMaker.getAxesData();

        this.dataProcessor.addDataRatios(axesData.limit);
    },

    /**
     * Make rendering data for map chart.
     * @returns {object} data for rendering
     * @private
     * @override
     */
    _makeRenderingData: function() {
        var axesData = this.boundsMaker.getAxesData();
        var seriesTheme = this.theme.series;
        var colorSpectrum = new ColorSpectrum(seriesTheme.startColor, seriesTheme.endColor);
        var mapModel = new MapChartMapModel(this.dataProcessor, this.options.map);

        return {
            legend: {
                colorSpectrum: colorSpectrum,
                axesData: axesData
            },
            mapSeries: {
                mapModel: mapModel,
                colorSpectrum: colorSpectrum
            },
            tooltip: {
                mapModel: mapModel
            }
        };
    },

    /**
     * Attach custom evnet.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var customEvent = this.componentManager.get('customEvent'),
            mapSeries = this.componentManager.get('mapSeries'),
            legend = this.componentManager.get('legend'),
            tooltip = this.componentManager.get('tooltip'),
            zoom = this.componentManager.get('zoom');

        customEvent.on({
            clickMapSeries: mapSeries.onClickSeries,
            moveMapSeries: mapSeries.onMoveSeries,
            dragStartMapSeries: mapSeries.onDragStartSeries,
            dragMapSeries: mapSeries.onDragSeries,
            dragEndMapSeries: mapSeries.onDragEndSeries,
            wheel: tui.util.bind(zoom.onWheel, zoom)
        }, mapSeries);

        mapSeries.on({
            showWedge: legend.onShowWedge,
            hideWedge: legend.onHideWedge
        }, legend);

        mapSeries.on({
            showTooltip: tooltip.onShow,
            hideTooltip: tooltip.onHide,
            showTooltipContainer: tooltip.onShowTooltipContainer,
            hideTooltipContainer: tooltip.onHideTooltipContainer
        }, tooltip);

        zoom.on('zoom', mapSeries.onZoom, mapSeries, mapSeries);
    }
});

module.exports = MapChart;

},{"../const":31,"../customEvents/mapChartCustomEvent":38,"../dataModels/mapChartDataProcessor":43,"../helpers/axisDataMaker":54,"../legends/spectrumLegend":71,"../series/mapChartSeries":98,"../series/zoom":106,"../tooltips/mapChartTooltip":110,"./chartBase":11,"./colorSpectrum":12,"./mapChartMapModel":22}],22:[function(require,module,exports){
/**
 * @fileoverview MapChartMapModel is map model of map chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

var MapChartMapModel = tui.util.defineClass(/** @lends MapChartMapModel.prototype */ {
    /**
     * MapChartMapModel is map model of map chart.
     * @constructs MapChartMapModel
     * @param {MapChartDataProcessor} dataProcessor Map chart data processor
     * @param {Array.<{name: string, path: string, labelCoordinate: ?{x: number, y:number}}>} rawMapData raw map data
     */
    init: function(dataProcessor, rawMapData) {
        /**
         * Command function map.
         * @type {{
         *      M: MapChartMapModel._makeCoordinate, m: MapChartMapModel._makeCoordinateFromRelativeCoordinate,
         *      L: MapChartMapModel._makeCoordinate, l: MapChartMapModel._makeCoordinateFromRelativeCoordinate,
         *      H: MapChartMapModel._makeXCoordinate, h: MapChartMapModel._makeXCoordinateFroRelativeCoordinate,
         *      V: MapChartMapModel._makeYCoordinate, v: MapChartMapModel._makeYCoordinateFromRelativeCoordinate
         * }}
         */
        this.commandFuncMap = {
            M: tui.util.bind(this._makeCoordinate, this),
            m: tui.util.bind(this._makeCoordinateFromRelativeCoordinate, this),
            L: tui.util.bind(this._makeCoordinate, this),
            l: tui.util.bind(this._makeCoordinateFromRelativeCoordinate, this),
            H: tui.util.bind(this._makeXCoordinate, this),
            h: tui.util.bind(this._makeXCoordinateFroRelativeCoordinate, this),
            V: tui.util.bind(this._makeYCoordinate, this),
            v: tui.util.bind(this._makeYCoordinateFromRelativeCoordinate, this)
        };

        /**
         * Ignore command map.
         * @type {{Z: boolean, z: boolean}}
         */
        this.ignoreCommandMap = {
            Z: true,
            z: true
        };

        /**
         * Map data.
         * @type {Array}
         */
        this.mapData = [];

        /**
         * Map dimension
         * @type {{width: number, height: number}}
         */
        this.mapDimension = null;

        /**
         * Map chart data processor.
         * @type {MapChartDataProcessor}
         */
        this.dataProcessor = dataProcessor;

        this._createMapData(rawMapData);
    },

    /**
     * Split coordinate string.
     * @param {string} coordinateStr coordinate string
     * @returns {{x: number, y: number}} coordinate map
     * @private
     */
    _splitCoordinate: function(coordinateStr) {
        var coordinates = coordinateStr.split(','),
            result = {
                x: parseFloat(coordinates[0])
            };

        if (coordinates[1]) {
            result.y = parseFloat(coordinates[1]);
        }

        return result;
    },

    /**
     * Make coordinate
     * @param {string} coordinateStr coordinate
     * @returns {{x: number, y: number}} coordinate
     * @private
     */
    _makeCoordinate: function(coordinateStr) {
        return this._splitCoordinate(coordinateStr);
    },

    /**
     * Make coordinate from relative coordinate.
     * @param {string} coordinateStr coordinate
     * @param {{x: number, y: number}} prevCoordinate previous coordinate
     * @returns {{x: number, y: number}} coordinate
     * @private
     */
    _makeCoordinateFromRelativeCoordinate: function(coordinateStr, prevCoordinate) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            x: coordinate.x + prevCoordinate.x,
            y: coordinate.y + prevCoordinate.y
        };
    },

    /**
     * Make x coordinate.
     * @param {string} coordinateStr coordinate
     * @returns {{x: number}} x coordinate
     * @private
     */
    _makeXCoordinate: function(coordinateStr) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            x: coordinate.x
        };
    },

    /**
     * Make x coordinate from relative coordinate.
     * @param {string} coordinateStr coordinate
     * @param {{x: number, y: number}} prevCoordinate previous coordinate
     * @returns {{x: number}} x coordinate
     * @private
     */
    _makeXCoordinateFroRelativeCoordinate: function(coordinateStr, prevCoordinate) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            x: coordinate.x + prevCoordinate.x
        };
    },

    /**
     * Make y coordinate.
     * @param {string} coordinateStr coordinate
     * @returns {{y: number}} y coordinate
     * @private
     */
    _makeYCoordinate: function(coordinateStr) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            y: coordinate.x
        };
    },

    /**
     * Make y coordinate from relative coordinate.
     * @param {string} coordinateStr coordinate
     * @param {{x: number, y: number}} prevCoordinate previous coordinate
     * @returns {{y: number}} y coordinate
     * @private
     */
    _makeYCoordinateFromRelativeCoordinate: function(coordinateStr, prevCoordinate) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            y: coordinate.x + prevCoordinate.y
        };
    },

    /**
     * Split path.
     * @param {string} path path
     * @returns {Array.<{type: string, coordinate: string}>} splitted path data
     * @private
     */
    _splitPath: function(path) {
        var i = 0,
            len = path.length,
            pathData = [],
            coordinate = '',
            chr, commandType;

        for (; i < len; i += 1) {
            chr = path.charAt(i);
            if (this.commandFuncMap[chr]) {
                if (commandType && coordinate) {
                    pathData.push({
                        type: commandType,
                        coordinate: coordinate
                    });
                }
                commandType = chr;
                coordinate = '';
            } else if (!this.ignoreCommandMap[chr]) {
                coordinate += chr;
            }
        }

        if (commandType && coordinate) {
            pathData.push({
                type: commandType,
                coordinate: coordinate
            });
        }

        return pathData;
    },

    /**
     * Make coordinates from path.
     * @param {string} path path
     * @returns {Array.<{x: number, y: number}>} coordinates
     * @private
     */
    _makeCoordinatesFromPath: function(path) {
        var self = this,
            pathData = this._splitPath(path),
            prevCoordinate = {
                x: 0,
                y: 0
            };

        return tui.util.map(pathData, function(datum) {
            var commandFunc = self.commandFuncMap[datum.type],
                coordinate = commandFunc(datum.coordinate, prevCoordinate);

            tui.util.extend(prevCoordinate, coordinate);

            return coordinate;
        });
    },

    /**
     * Find bound from coordinates.
     * @param {Array.<{left: number, top: number}>} coordinates coordinates
     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} bound
     * @private
     */
    _findBoundFromCoordinates: function(coordinates) {
        var xs = tui.util.filter(tui.util.pluck(coordinates, 'x'), function(x) {
                return !tui.util.isUndefined(x);
            }),
            ys = tui.util.filter(tui.util.pluck(coordinates, 'y'), function(y) {
                return !tui.util.isUndefined(y);
            }),
            maxLeft = tui.util.max(xs),
            minLeft = tui.util.min(xs),
            maxTop = tui.util.max(ys),
            minTop = tui.util.min(ys);

        return {
            dimension: {
                width: maxLeft - minLeft,
                height: maxTop - minTop
            },
            position: {
                left: minLeft,
                top: minTop
            }
        };
    },

    /**
     * Make label position.
     * @param {{dimension: {width: number, height: number}, position: {top: number, left: number}}} bound bound
     * @param {?{left: number, top: number}} positionRatio position ratio
     * @returns {{left: number, top: number}} label position
     * @private
     */
    _makeLabelPosition: function(bound, positionRatio) {
        positionRatio = positionRatio || chartConst.MAP_CHART_LABEL_DEFAULT_POSITION_RATIO;

        return {
            left: bound.position.left + (bound.dimension.width * positionRatio.x),
            top: bound.position.top + (bound.dimension.height * positionRatio.y)
        };
    },

    /**
     * Create map data.
     * @param {Array.<{name: string, path: string, labelCoordinate: ?{x: number, y:number}}>} rawMapData raw map data
     * @private
     */
    _createMapData: function(rawMapData) {
        var self = this;

        this.mapData = tui.util.map(rawMapData, function(datum) {
            var coordinate = self._makeCoordinatesFromPath(datum.path),
                bound = self._findBoundFromCoordinates(coordinate),
                userData = self.dataProcessor.getValueMapDatum(datum.code),
                name, labelCoordinate, label, ratio, resultData;

            if (userData) {
                label = userData.label;
                ratio = userData.ratio;
                name = userData.name || datum.name;
                labelCoordinate = userData.labelCoordinate || datum.labelCoordinate;
            }

            resultData = {
                code: datum.code,
                name: name,
                path: datum.path,
                bound: bound,
                labelPosition: self._makeLabelPosition(bound, labelCoordinate)
            };

            if (label) {
                resultData.label = label;
            }

            if (ratio) {
                resultData.ratio = ratio;
            }

            return resultData;
        });
    },

    getMapData: function() {
        return this.mapData;
    },

    getDatum: function(index) {
        return this.mapData[index];
    },

    /**
     * Get label data.
     * @param {number} ratio ratio
     * @returns {Array.<{name: string, bound: {dimension: {width: number, height: number},
     *          position: {top: number, left: number}}, labelPosition: {width: number, height: number}}>} map data
     */
    getLabelData: function(ratio) {
        var self = this,
            labelData = tui.util.filter(this.mapData, function(datum) {
                return self.dataProcessor.getValueMapDatum(datum.code);
            });

        return tui.util.map(labelData, function(datum) {
            return {
                name: datum.name,
                labelPosition: {
                    left: datum.labelPosition.left * ratio,
                    top: datum.labelPosition.top * ratio
                }
            };
        });
    },

    /**
     * Make map dimension
     * @returns {{width: number, height: number}} map dimension
     * @private
     */
    _makeMapDimension: function() {
        var mapData = this.mapData,
            lefts = tui.util.map(mapData, function(datum) {
                return datum.bound.position.left;
            }),
            rights = tui.util.map(mapData, function(datum) {
                return datum.bound.position.left + datum.bound.dimension.width;
            }),
            tops = tui.util.map(mapData, function(datum) {
                return datum.bound.position.top;
            }),
            bottoms = tui.util.map(mapData, function(datum) {
                return datum.bound.position.top + datum.bound.dimension.height;
            });

        return {
            width: tui.util.max(rights) - tui.util.min(lefts),
            height: tui.util.max(bottoms) - tui.util.min(tops)
        };
    },

    /**
     * Get map dimension.
     * @returns {{width: number, height: number}} map dimension
     */
    getMapDimension: function() {
        if (!this.mapDimension) {
            this.mapDimension = this._makeMapDimension();
        }

        return this.mapDimension;
    }
});

module.exports = MapChartMapModel;

},{"../const":31}],23:[function(require,module,exports){
/**
 * @fileoverview Pie chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var pieTypeMixer = require('./pieTypeMixer');
var chartConst = require('../const');

var PieChart = tui.util.defineClass(ChartBase, /** @lends PieChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-pie-chart',

    /**
     * Pie chart.
     * @constructs PieChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        options.tooltip = options.tooltip || {};

        if (!options.tooltip.align) {
            options.tooltip.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options
        });

        this._addComponents();
    },

    /**
     * Add components
     * @private
     */
    _addComponents: function() {
        this._addLegendComponent();
        this._addTooltipComponent();
        this._addSeriesComponents([{
            name: 'pieSeries',
            additionalParams: {
                chartType: this.chartType
            }
        }]);
        this._addCustomEventComponent();
    },

    /**
     * Add data ratios.
     * @private
     * @override
     */
    _addDataRatios: function() {
        this.dataProcessor.addDataRatiosOfPieChart(this.chartType);
    },

    /**
     * Send series data.
     * @private
     * @override
     */
    _sendSeriesData: function() {
        ChartBase.prototype._sendSeriesData.call(this, chartConst.CHART_TYPE_PIE);
    },

    /**
     * Attach custom event.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var pieSeries = this.componentManager.get('pieSeries');

        this._attachCustomEventForPieTypeChart([pieSeries]);
        ChartBase.prototype._attachCustomEvent.call(this);
    }
});

tui.util.extend(PieChart.prototype, pieTypeMixer);

module.exports = PieChart;

},{"../const":31,"./chartBase":11,"./pieTypeMixer":25}],24:[function(require,module,exports){
/**
 * @fileoverview Pie and Donut Combo chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var pieTypeMixer = require('./pieTypeMixer');
var comboTypeMixer = require('./comboTypeMixer');
var predicate = require('../helpers/predicate');

var PieDonutComboChart = tui.util.defineClass(ChartBase, /** @lends PieDonutComboChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-combo-chart',

    /**
     * Pie and Donut Combo chart.
     * @constructs PieDonutComboChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        /**
         * chart types.
         * @type {Array.<string>}
         */
        this.chartTypes = tui.util.keys(rawData.series).sort();

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            isVertical: true,
            seriesNames: this.chartTypes
        });

        this._addComponents();
    },

    /**
     * Make data for adding series component.
     * @returns {Array.<object>}
     * @private
     */
    _makeDataForAddingSeriesComponent: function() {
        var seriesNames = this.chartTypes;
        var optionsMap = this._makeOptionsMap(this.chartTypes);
        var themeMap = this._makeThemeMap(seriesNames);
        var dataProcessor = this.dataProcessor;
        var isShowOuterLabel = tui.util.any(optionsMap, predicate.isShowOuterLabel);
        var seriesData = tui.util.map(seriesNames, function(seriesName) {
            var chartType = dataProcessor.findChartType(seriesName);
            var additionalParams = {
                chartType: chartType,
                seriesName: seriesName,
                options: optionsMap[seriesName],
                isShowOuterLabel: isShowOuterLabel,
                isCombo: true,
                theme: themeMap[seriesName]
            };

            return {
                name: seriesName + 'Series',
                additionalParams: additionalParams
            };
        });

        return seriesData;
    },

    /**
     * Add components
     * @private
     */
    _addComponents: function() {
        this._addLegendComponent(this.chartTypes);
        this._addTooltipComponent();
        this._addSeriesComponents(this._makeDataForAddingSeriesComponent());
        this._addCustomEventComponent();
    },

    /**
     * Add data ratios.
     * @private
     * @override
     */
    _addDataRatios: function() {
        var self = this;
        var chartTypes = this.chartTypes || [this.chartType];

        tui.util.forEachArray(chartTypes, function(chartType) {
            self.dataProcessor.addDataRatiosOfPieChart(chartType);
        });
    },

    /**
     * Add custom event.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var componentManager = this.componentManager;
        var serieses;

        ChartBase.prototype._attachCustomEvent.call(this);

        serieses = tui.util.map(this.chartTypes, function(seriesName) {
            return componentManager.get(seriesName + 'Series');
        });
        this._attachCustomEventForPieTypeChart(serieses);
    },

    /**
     * On change selected legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @override
     */
    onChangeCheckedLegends: function(checkedLegends) {
        var originalRawData = this.dataProcessor.getOriginalRawData();
        var rawData = this._filterCheckedRawData(originalRawData, checkedLegends);

        ChartBase.prototype.onChangeCheckedLegends.call(this, checkedLegends, rawData, {
            seriesNames: this.chartTypes
        });
    }
});

tui.util.extend(PieDonutComboChart.prototype, pieTypeMixer, comboTypeMixer);

module.exports = PieDonutComboChart;

},{"../helpers/predicate":61,"./chartBase":11,"./comboTypeMixer":15,"./pieTypeMixer":25}],25:[function(require,module,exports){
/**
 * @fileoverview pieTypeMixer is mixer of pie type chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var renderUtil = require('../helpers/renderUtil');
var Legend = require('../legends/legend');
var Tooltip = require('../tooltips/tooltip');
var PieChartSeries = require('../series/pieChartSeries');
var SimpleCustomEvent = require('../customEvents/simpleCustomEvent');

/**
 * pieTypeMixer is mixer of pie type chart.
 * @mixin
 */
var pieTypeMixer = {
    /**
     * Add legend component.
     * @param {Array.<string>} [chartTypes] - chart types
     * @private
     */
    _addLegendComponent: function(chartTypes) {
        var legendOption = this.options.legend || {};

        if (legendOption.visible) {
            this.componentManager.register('legend', Legend, {
                seriesNames: chartTypes,
                chartType: this.chartType,
                userEvent: this.userEvent
            });
        }
    },

    /**
     * Add tooltip component.
     * @private
     */
    _addTooltipComponent: function() {
        this.componentManager.register('tooltip', Tooltip, this._makeTooltipData());
    },

    /**
     * Add series components.
     * @param {Array.<{name: string, additionalParams: ?object}>} seriesData - data for adding series component
     * @private
     */
    _addSeriesComponents: function(seriesData) {
        var componentManager = this.componentManager;
        var seriesBaseParams = {
            libType: this.options.libType,
            componentType: 'series',
            chartBackground: this.theme.chart.background,
            userEvent: this.userEvent
        };

        tui.util.forEach(seriesData, function(seriesDatum) {
            var seriesParams = tui.util.extend(seriesBaseParams, seriesDatum.additionalParams);

            componentManager.register(seriesDatum.name, PieChartSeries, seriesParams);
        });
    },

    /**
     * Add custom event component.
     * @private
     * @override
     */
    _addCustomEventComponent: function() {
        this.componentManager.register('customEvent', SimpleCustomEvent, {
            chartType: this.chartType
        });
    },

    /**
     * Add custom event.
     * @param {Array.<object>} seriesComponents - series components
     * @private
     */
    _attachCustomEventForPieTypeChart: function(seriesComponents) {
        var clickEventName = renderUtil.makeCustomEventName('click', this.chartType, 'series');
        var moveEventName = renderUtil.makeCustomEventName('move', this.chartType, 'series');
        var customEvent = this.componentManager.get('customEvent');
        var tooltip = this.componentManager.get('tooltip');
        var eventMap = {};

        tui.util.forEachArray(seriesComponents, function(series) {
            eventMap[clickEventName] = series.onClickSeries;
            eventMap[moveEventName] = series.onMoveSeries;
            customEvent.on(eventMap, series);

            series.on({
                showTooltip: tooltip.onShow,
                hideTooltip: tooltip.onHide,
                showTooltipContainer: tooltip.onShowTooltipContainer,
                hideTooltipContainer: tooltip.onHideTooltipContainer
            }, tooltip);
        });
    }
};

module.exports = pieTypeMixer;

},{"../customEvents/simpleCustomEvent":39,"../helpers/renderUtil":63,"../legends/legend":67,"../series/pieChartSeries":99,"../tooltips/tooltip":112}],26:[function(require,module,exports){
/**
 * @fileoverview Scatter chart is a type of plot or mathematical diagram using Cartesian coordinates
 *                  to display values for typically two variables for a set of data.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var chartConst = require('../const');
var Series = require('../series/scatterChartSeries');
var axisTypeMixer = require('./axisTypeMixer');
var SimpleCustomEvent = require('../customEvents/simpleCustomEvent');

var ScatterChart = tui.util.defineClass(ChartBase, /** @lends ScatterChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-scatter-chart',
    /**
     * Scatter chart is a type of plot or mathematical diagram using Cartesian coordinates
     *  to display values for typically two variables for a set of data.
     * @constructs ScatterChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        options.tooltip = options.tooltip || {};

        this.axisScaleMakerMap = null;

        if (!options.tooltip.align) {
            options.tooltip.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Make map for AxisScaleMaker of axes(xAxis, yAxis).
     * @returns {Object.<string, AxisScaleMaker>}
     * @private
     */
    _makeAxisScaleMakerMap: function() {
        var options = this.options;

        return {
            xAxis: this._createAxisScaleMaker(options.xAxis, 'xAxis', 'x'),
            yAxis: this._createAxisScaleMaker(options.yAxis, 'yAxis', 'y')
        };
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        this._addComponentsForAxisType({
            chartType: chartType,
            axis: [
                {
                    name: 'yAxis',
                    isVertical: true
                },
                {
                    name: 'xAxis'
                }
            ],
            series: [
                {
                    name: 'scatterSeries',
                    SeriesClass: Series
                }
            ],
            plot: true
        });
    }
});

tui.util.extend(ScatterChart.prototype, axisTypeMixer);

/**
 * Add data ratios.
 * @private
 * @override
 */
ScatterChart.prototype._addDataRatios = function() {
    var scaleMakerMap = this._getAxisScaleMakerMap();

    this.dataProcessor.addDataRatiosForCoordinateType(this.chartType, {
        x: scaleMakerMap.xAxis.getLimit(),
        y: scaleMakerMap.yAxis.getLimit()
    }, false);
};

/**
 * Add custom event component for normal tooltip.
 * @private
 */
ScatterChart.prototype._attachCustomEvent = function() {
    var componentManager = this.componentManager;
    var customEvent = componentManager.get('customEvent');
    var scatterSeries = componentManager.get('scatterSeries');
    var tooltip = componentManager.get('tooltip');

    axisTypeMixer._attachCustomEvent.call(this);

    customEvent.on({
        clickScatterSeries: scatterSeries.onClickSeries,
        moveScatterSeries: scatterSeries.onMoveSeries
    }, scatterSeries);

    scatterSeries.on({
        showTooltip: tooltip.onShow,
        hideTooltip: tooltip.onHide,
        showTooltipContainer: tooltip.onShowTooltipContainer,
        hideTooltipContainer: tooltip.onHideTooltipContainer
    }, tooltip);
};

/**
 * Add custom event component.
 * @private
 */
ScatterChart.prototype._addCustomEventComponent = function() {
    this.componentManager.register('customEvent', SimpleCustomEvent, {
        chartType: this.chartType
    });
};

module.exports = ScatterChart;

},{"../const":31,"../customEvents/simpleCustomEvent":39,"../series/scatterChartSeries":101,"./axisTypeMixer":7,"./chartBase":11}],27:[function(require,module,exports){
/**
 * @fileoverview Treemap chart is graphical representation of hierarchical data by using rectangles.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase');
var ColorSpectrum = require('./colorSpectrum');
var Series = require('../series/treemapChartSeries');
var Tooltip = require('../tooltips/tooltip');
var Legend = require('../legends/spectrumLegend');
var axisDataMaker = require('../helpers/axisDataMaker');
var BoundsTypeCustomEvent = require('../customEvents/boundsTypeCustomEvent');
var chartConst = require('../const');

var TreemapChart = tui.util.defineClass(ChartBase, /** @lends TreemapChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-treemap-chart',
    /**
     * Treemap chart is graphical representation of hierarchical data by using rectangles.
     * @constructs TreemapChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        options.series = options.series || {};
        options.tooltip = options.tooltip || {};
        options.tooltip.grouped = false;

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: false,
            isVertical: true
        });

        /**
         * scale information like limit, step for rendering legend
         * @type {{limit: {min: number, max: number}, step: number}}
         */
        this.lengedScale = null;

        this._addComponents(options.chartType);
    },

    /**
     * Add components.
     * @private
     */
    _addComponents: function() {
        var useColorValue = tui.util.pick(this.options, 'series', 'useColorValue');

        this.componentManager.register('series', Series, {
            chartBackground: this.theme.chart.background,
            chartType: this.chartType,
            userEvent: this.userEvent
        });

        this.componentManager.register('tooltip', Tooltip, tui.util.extend({
            labelTheme: tui.util.pick(this.theme, 'series', 'label')
        }, this._makeTooltipData()));

        if (useColorValue) {
            this.componentManager.register('legend', Legend, {
                chartType: this.chartType,
                userEvent: this.userEvent
            });
        }

        this.componentManager.register('customEvent', BoundsTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical
        });
    },

    /**
     * Get legend scale
     * @returns {Object.<string, AxisScaleMaker>}
     * @private
     */
    _getLegendScale: function() {
        if (!this.lengedScale) {
            this.lengedScale = this._createAxisScaleMaker({}, 'legend', null, this.chartType, {
                valueCount: chartConst.SPECTRUM_LEGEND_TICK_COUNT
            });
        }

        return this.lengedScale;
    },

    /**
     * Add data ratios to dataProcessor for rendering graph.
     * @private
     * @override
     */
    _addDataRatios: function() {
        var limit = this._getLegendScale().getLimit();

        this.dataProcessor.addDataRatiosForTreemapChart(limit, this.chartType);
    },

    /**
     * Make rendering data for delivery to each component.
     * @returns {object}
     * @private
     * @override
     */
    _makeRenderingData: function() {
        var data = {};
        var seriesTheme = this.theme.series;
        var useColorValue = tui.util.pick(this.options, 'series', 'useColorValue');
        var colorSpectrum = useColorValue ? (new ColorSpectrum(seriesTheme.startColor, seriesTheme.endColor)) : null;

        data.legend = {
            colorSpectrum: colorSpectrum,
            axesData: axisDataMaker.makeValueAxisData({
                axisScaleMaker: this._getLegendScale(),
                isVertical: true
            })
        };
        data.series = {
            colorSpectrum: colorSpectrum
        };

        return data;
    },

    /**
     * Attach custom event.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var series = this.componentManager.get('series');
        var customEvent = this.componentManager.get('customEvent');
        var tooltip = this.componentManager.get('tooltip');
        var legend = this.componentManager.get('legend');

        ChartBase.prototype._attachCustomEvent.call(this);

        customEvent.on('showTooltip', tooltip.onShow, tooltip);
        customEvent.on('hideTooltip', tooltip.onHide, tooltip);

        tooltip.on('showTreemapAnimation', series.onShowAnimation, series);
        tooltip.on('hideTreemapAnimation', series.onHideAnimation, series);

        series.on('afterZoom', customEvent.onAfterZoom, customEvent);

        if (legend) {
            customEvent.on('showTooltip', series.onShowTooltip, series);
            customEvent.on('hideTooltip', legend.onHideWedge, legend);

            series.on('showWedge', legend.onShowWedge, legend);
        }
    },

    /**
     * On zoom.
     * @param {number} index - index of target seriesItem
     */
    onZoom: function(index) {
        this._renderComponents({
            'series': {
                index: index
            }
        }, 'zoom');
        this._sendSeriesData();
    }
});

module.exports = TreemapChart;

},{"../const":31,"../customEvents/boundsTypeCustomEvent":35,"../helpers/axisDataMaker":54,"../legends/spectrumLegend":71,"../series/treemapChartSeries":105,"../tooltips/tooltip":112,"./chartBase":11,"./colorSpectrum":12}],28:[function(require,module,exports){
/**
 * @fileoverview Column and Line Combo chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var calculator = require('../helpers/calculator');
var renderUtil = require('../helpers/renderUtil');
var ChartBase = require('./chartBase');
var ColumnChartSeries = require('../series/columnChartSeries');
var LineChartSeries = require('../series/lineChartSeries');
var AreaChartSeries = require('../series/areaChartSeries');

var verticalTypeComboMixer = {
    /**
     * Column and Line Combo chart.
     * @constructs verticalTypeComboMixer
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    _initForVerticalTypeCombo: function(rawData, theme, options) {
        var chartTypesMap;

        chartTypesMap = this._makeChartTypesMap(rawData.series, options.yAxis, options.chartType);

        tui.util.extend(this, chartTypesMap);

        options.tooltip = options.tooltip || {};
        options.tooltip.grouped = true;

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true,
            seriesNames: chartTypesMap.seriesNames
        });

        /**
         * yAxis options map
         * @type {object}
         */
        this.yAxisOptionsMap = this._makeYAxisOptionsMap(chartTypesMap.chartTypes, options.yAxis);
        this._addComponents(chartTypesMap);
    },

    /**
     * Make yAxis options map.
     * @param {Array.<string>} chartTypes chart types
     * @param {?object} yAxisOptions yAxis options
     * @returns {{column: ?object, line: ?object}} options map
     * @private
     */
    _makeYAxisOptionsMap: function(chartTypes, yAxisOptions) {
        var optionsMap = {};
        yAxisOptions = yAxisOptions || {};
        tui.util.forEachArray(chartTypes, function(chartType, index) {
            optionsMap[chartType] = yAxisOptions[index] || yAxisOptions;
        });

        return optionsMap;
    },

    /**
     * Make chart types map.
     * @param {object} rawSeriesData raw series data
     * @param {object} yAxisOption option for y axis
     * @returns {object} chart types map
     * @private
     */
    _makeChartTypesMap: function(rawSeriesData, yAxisOption) {
        var seriesNames = tui.util.keys(rawSeriesData).sort();
        var optionChartTypes = this._getYAxisOptionChartTypes(seriesNames, yAxisOption);
        var chartTypes = optionChartTypes.length ? optionChartTypes : seriesNames;
        var validChartTypes = tui.util.filter(optionChartTypes, function(_chartType) {
            return rawSeriesData[_chartType].length;
        });
        var chartTypesMap;

        if (validChartTypes.length === 1) {
            chartTypesMap = {
                chartTypes: validChartTypes,
                seriesNames: validChartTypes,
                optionChartTypes: !optionChartTypes.length ? optionChartTypes : validChartTypes
            };
        } else {
            chartTypesMap = {
                chartTypes: chartTypes,
                seriesNames: seriesNames,
                optionChartTypes: optionChartTypes
            };
        }

        return chartTypesMap;
    },

    /**
     * Make data for adding series component.
     * @param {Array.<string>} seriesNames - series names
     * @returns {Array.<object>}
     * @private
     */
    _makeDataForAddingSeriesComponent: function(seriesNames) {
        var seriesClasses = {
            column: ColumnChartSeries,
            line: LineChartSeries,
            area: AreaChartSeries
        };
        var optionsMap = this._makeOptionsMap(seriesNames);
        var themeMap = this._makeThemeMap(seriesNames);
        var dataProcessor = this.dataProcessor;
        var serieses = tui.util.map(seriesNames, function(seriesName) {
            var chartType = dataProcessor.findChartType(seriesName);
            var data = {
                allowNegativeTooltip: true,
                chartType: chartType,
                seriesName: seriesName,
                options: optionsMap[seriesName],
                theme: themeMap[seriesName]
            };

            return {
                name: seriesName + 'Series',
                SeriesClass: seriesClasses[chartType],
                data: data
            };
        });

        return serieses;
    },

    /**
     * Add components
     * @param {object} chartTypesMap chart types map
     * @private
     */
    _addComponents: function(chartTypesMap) {
        var axes = [
            {
                name: 'yAxis',
                chartType: chartTypesMap.chartTypes[0],
                isVertical: true
            },
            {
                name: 'xAxis',
                isLabel: true
            }
        ];
        var serieses = this._makeDataForAddingSeriesComponent(chartTypesMap.seriesNames);

        if (chartTypesMap.optionChartTypes.length) {
            axes.push({
                name: 'rightYAxis',
                chartType: chartTypesMap.chartTypes[1],
                isVertical: true
            });
        }

        this._addComponentsForAxisType({
            chartType: this.options.chartType,
            seriesNames: chartTypesMap.seriesNames,
            axis: axes,
            series: serieses,
            plot: true
        });
    },

    /**
     * Get y axis option chart types.
     * @param {Array.<string>} chartTypes chart types
     * @param {object} yAxisOptions y axis options
     * @returns {Array.<string>} chart types
     * @private
     */
    _getYAxisOptionChartTypes: function(chartTypes, yAxisOptions) {
        var resultChartTypes = chartTypes.slice(),
            isReverse = false,
            optionChartTypes;

        yAxisOptions = yAxisOptions ? [].concat(yAxisOptions) : [];

        if (yAxisOptions.length === 1 && !yAxisOptions[0].chartType) {
            resultChartTypes = [];
        } else if (yAxisOptions.length) {
            optionChartTypes = tui.util.map(yAxisOptions, function(option) {
                return option.chartType;
            });

            tui.util.forEachArray(optionChartTypes, function(chartType, index) {
                isReverse = isReverse || (chartType && resultChartTypes[index] !== chartType || false);
            });

            if (isReverse) {
                resultChartTypes.reverse();
            }
        }

        return resultChartTypes;
    },

    /**
     * Create AxisScaleMake for y axis.
     * @param {number} index - index of this.chartTypes
     * @param {boolean} isSingleYAxis - whether single y axis or not.
     * @returns {AxisScaleMaker}
     * @private
     */
    _createYAxisScaleMaker: function(index, isSingleYAxis) {
        var chartType = this.chartTypes[index];
        var yAxisOption = this.yAxisOptionsMap[chartType];
        var additionalParams = {
            isSingleYAxis: !!isSingleYAxis
        };

        return this._createAxisScaleMaker(yAxisOption, 'yAxis', null, chartType, additionalParams);
    },

    /**
     * Make map for AxisScaleMaker of axes(xAxis, yAxis).
     * @returns {Object.<string, AxisScaleMaker>}
     * @private
     */
    _makeAxisScaleMakerMap: function() {
        var isSingleYAxis = this.optionChartTypes.length < 2;
        var axisScaleMakerMap = {
            yAxis: this._createYAxisScaleMaker(0, isSingleYAxis)
        };

        if (!isSingleYAxis) {
            axisScaleMakerMap.rightYAxis = this._createYAxisScaleMaker(1);
        }

        return axisScaleMakerMap;
    },

    /**
     * Increase yAxis tick count.
     * @param {number} increaseTickCount increase tick count
     * @param {object} yAxisData yAxis data
     * @private
     */
    _increaseYAxisTickCount: function(increaseTickCount, yAxisData) {
        var formatFunctions = this.dataProcessor.getFormatFunctions();
        var labels;

        yAxisData.limit.max += yAxisData.step * increaseTickCount;
        labels = calculator.makeLabelsFromLimit(yAxisData.limit, yAxisData.step);
        yAxisData.labels = renderUtil.formatValues(labels, formatFunctions, this.chartType, 'yAxis');
        yAxisData.tickCount += increaseTickCount;
        yAxisData.validTickCount += increaseTickCount;
    },

    /**
     * Update tick count to make the same tick count of y Axes(yAxis, rightYAxis).
     * @param {{yAxis: object, rightYAxis: object}} axesData - axesData
     * @private
     */
    _updateYAxisTickCount: function(axesData) {
        var yAxisData = axesData.yAxis;
        var rightYAxisData = axesData.rightYAxis;
        var tickCountDiff = rightYAxisData.tickCount - yAxisData.tickCount;

        if (tickCountDiff > 0) {
            this._increaseYAxisTickCount(tickCountDiff, yAxisData);
        } else if (tickCountDiff < 0) {
            this._increaseYAxisTickCount(-tickCountDiff, rightYAxisData);
        }
    },

    /**
     * Make axes data, used in a axis component like yAxis, xAxis, rightYAxis.
     * @returns {object} axes data
     * @private
     * @override
     */
    _makeAxesData: function() {
        var axisScaleMakerMap = this._getAxisScaleMakerMap();
        var yAxisOptionsMap = this.yAxisOptionsMap;
        var yAxisOptions = yAxisOptionsMap[this.chartTypes[0]];
        var axesData = {
            xAxis: this._makeAxisData(null, this.options.xAxis),
            yAxis: this._makeAxisData(axisScaleMakerMap.yAxis, yAxisOptions, true)
        };

        if (axisScaleMakerMap.rightYAxis) {
            yAxisOptions = yAxisOptionsMap[this.chartTypes[1]];
            axesData.rightYAxis = this._makeAxisData(axisScaleMakerMap.rightYAxis, yAxisOptions, true, true);
            axesData.rightYAxis.aligned = axesData.xAxis.aligned;

            this._updateYAxisTickCount(axesData);
        }

        return axesData;
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};


module.exports = verticalTypeComboMixer;

},{"../helpers/calculator":57,"../helpers/renderUtil":63,"../series/areaChartSeries":89,"../series/columnChartSeries":93,"../series/lineChartSeries":96,"./chartBase":11}],29:[function(require,module,exports){
/**
 * @fileoverview zoomMixer is mixer of line type chart(line, area).
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * zoomMixer is mixer of line type chart(line, area).
 * @mixin
 */
var zoomMixer = {
    /**
     * Render for zoom.
     * @param {boolean} isResetZoom - whether reset zoom or not
     * @private
     */
    _renderForZoom: function(isResetZoom) {
        var self = this;

        this.boundsMaker.initBoundsData();
        this._render(function(renderingData) {
            renderingData.customEvent.isResetZoom = isResetZoom;
            self._renderComponents(renderingData, 'zoom');
        });
    },

    /**
     * On zoom.
     * @param {Array.<number>} indexRange - index range for zoom
     * @override
     */
    onZoom: function(indexRange) {
        this._pauseAnimationForAddingData();
        this.dataProcessor.updateRawDataForZoom(indexRange);
        this.axisScaleMakerMap = null;
        this._renderForZoom(false);
    },

    /**
     * On reset zoom.
     * @override
     */
    onResetZoom: function() {
        var rawData = this.dataProcessor.getOriginalRawData();

        if (this.checkedLegends) {
            rawData = this._filterCheckedRawData(rawData, this.checkedLegends);
        }

        this.axisScaleMakerMap = null;
        this.prevUpdatedData = null;
        this.firstTickCount = null;

        this.dataProcessor.initData(rawData);
        this.dataProcessor.initZoomedRawData();
        this.dataProcessor.addDataFromRemainDynamicData(tui.util.pick(this.options.series, 'shifting'));
        this._renderForZoom(true);
        this._restartAnimationForAddingData();
    }
};

module.exports = zoomMixer;

},{}],30:[function(require,module,exports){
'use strict';

/**
 * Pick minimum value from value array.
 * @param {Array} arr value array
 * @param {?function} condition condition function
 * @param {?object} context target context
 * @returns {*} minimum value
 */
var min = function(arr, condition, context) {
    var result, minValue, rest;

    if (!condition) {
        result =  Math.min.apply(null, arr);
    } else {
        result = arr[0];
        minValue = condition.call(context, result, 0);
        rest = arr.slice(1);
        tui.util.forEachArray(rest, function(item, index) {
            var compareValue = condition.call(context, item, index + 1);
            if (compareValue < minValue) {
                minValue = compareValue;
                result = item;
            }
        });
    }

    return result;
};

/**
 * Pick maximum value from value array.
 * @param {Array} arr value array
 * @param {?function} condition condition function
 * @param {?object} context target context
 * @returns {*} maximum value
 */
var max = function(arr, condition, context) {
    var result, maxValue, rest;

    if (!condition) {
        result = Math.max.apply(null, arr);
    } else {
        result = arr[0];
        maxValue = condition.call(context, result, 0);
        rest = arr.slice(1);
        tui.util.forEachArray(rest, function(item, index) {
            var compareValue = condition.call(context, item, index + 1);
            if (compareValue > maxValue) {
                maxValue = compareValue;
                result = item;
            }
        });
    }

    return result;
};

/**
 * Whether one of them is true or not.
 * @param {Array} collection target collection
 * @param {function} condition condition function
 * @param {?object} context target context
 * @returns {boolean} result boolean
 */
var any = function(collection, condition, context) {
    var result = false;
    tui.util.forEach(collection, function(item, key) {
        if (condition.call(context, item, key, collection)) {
            result = true;
            return false;
        }
    });
    return result;
};

/**
 * All of them is true or not.
 * @param {Array} collection target collection
 * @param {function} condition condition function
 * @param {[object]} context target context
 * @returns {boolean} result boolean
 */
var all = function(collection, condition, context) {
    var result = !!(collection || []).length;
    tui.util.forEach(collection, function(item, key) {
        if (!condition.call(context, item, key, collection)) {
            result = false;
            return false;
        }
    });
    return result;
};

/**
 * Make unique values.
 * @param {Array} arr target array
 * @param {?boolean} sorted whether sorted or not.
 * @param {?function} iteratee iteratee function
 * @param {?object} context target context
 * @returns {Array} unique values
 */
var unique = function(arr, sorted, iteratee, context) {
    var result = [],
        prevValue;

    if (!tui.util.isBoolean(sorted)) {
        context = iteratee;
        iteratee = sorted;
        sorted = false;
    }

    iteratee = iteratee || function(value) {
        return value;
    };

    if (sorted) {
        tui.util.forEachArray(arr, function (value, index) {
            value = iteratee.call(context, value, index, arr);
            if (!index || prevValue !== value) {
                result.push(value);
            }
            prevValue = value;
        });
    } else {
        tui.util.forEachArray(arr, function(value, index) {
            value = iteratee.call(context, value, index, arr);
            if (tui.util.inArray(value, result) === -1) {
                result.push(value);
            }
        });
    }

    return result;
};

/**
 * Array pivot.
 * @memberOf module:calculator
 * @param {Array.<Array>} arr2d target 2d array
 * @returns {Array.<Array>} pivoted 2d array
 */
var pivot = function(arr2d) {
    var result = [];
    var len = tui.util.max(tui.util.map(arr2d, function(arr) {
        return arr.length;
    }));
    var index;

    tui.util.forEachArray(arr2d, function(arr) {
        for(index = 0; index < len; index += 1) {
            if (!result[index]) {
                result[index] = [];
            }
            result[index].push(arr[index]);
        }
    });
    return result;
};

/**
 * Get length after decimal point.
 * @param {string | number} value target value
 * @returns {number} result length
 */
var getDecimalLength = function(value) {
    var valueArr = String(value).split('.');
    return valueArr.length === 2 ? valueArr[1].length : 0;
};

/**
 * Find multiple num.
 * @param {...Array} target values
 * @returns {number} multiple num
 */
var findMultipleNum = function() {
    var args = [].slice.call(arguments),
        underPointLens = tui.util.map(args, function(value) {
            return tui.util.getDecimalLength(value);
        }),
        underPointLen = tui.util.max(underPointLens),
        multipleNum = Math.pow(10, underPointLen);
    return multipleNum;
};

/**
 * Modulo operation for floating point operation.
 * @param {number} target target values
 * @param {number} modNum mod num
 * @returns {number} result mod
 */
var mod = function(target, modNum) {
    var multipleNum = tui.util.findMultipleNum(modNum);
    return ((target * multipleNum) % (modNum * multipleNum)) / multipleNum;
};

/**
 * Addition for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} addition result
 */
var addition = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) + (b * multipleNum)) / multipleNum;
};

/**
 * Subtraction for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} subtraction result
 */
var subtraction = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) - (b * multipleNum)) / multipleNum;
};

/**
 * Multiplication for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} multiplication result
 */
var multiplication = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) * (b * multipleNum)) / (multipleNum * multipleNum);
};

/**
 * Division for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} division result
 */
var division = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return (a * multipleNum) / (b * multipleNum);
};

/**
 * Sum.
 * @param {Array.<number>} values target values
 * @returns {number} result value
 */
var sum = function(values) {
    var copyArr = values.slice();
    copyArr.unshift(0);
    return tui.util.reduce(copyArr, function(base, add) {
        return tui.util.addition(parseFloat(base), parseFloat(add));
    });
};

/**
 * Proper case.
 * @param {string} value - string value
 * @returns {string}
 */
var properCase = function(value) {
    return value.substring(0, 1).toUpperCase() + value.substring(1);
};

/**
 * Deep copy.
 * @param {object|Array|*} origin - original data
 * @returns {*}
 */
var deepCopy = function(origin) {
    var clone;

    if (tui.util.isArray(origin)) {
        clone = [];
        tui.util.forEachArray(origin, function (value, index) {
            clone[index] = deepCopy(value);
        });
    } else if (tui.util.isFunction(origin)) {
        clone = origin;
    } else if (tui.util.isObject(origin)) {
        clone = {};
        tui.util.forEach(origin, function(value, key) {
            clone[key] = deepCopy(value);
        });
    } else {
        clone = origin;
    }

    return clone;
};

tui.util.min = min;
tui.util.max = max;
tui.util.any = any;
tui.util.all = all;
tui.util.unique = unique;
tui.util.pivot = pivot;
tui.util.getDecimalLength = getDecimalLength;
tui.util.mod = mod;
tui.util.findMultipleNum = findMultipleNum;
tui.util.addition = addition;
tui.util.subtraction = subtraction;
tui.util.multiplication = multiplication;
tui.util.division = division;
tui.util.sum = sum;
tui.util.properCase = properCase;
tui.util.deepCopy = deepCopy;

},{}],31:[function(require,module,exports){
/**
 * @fileoverview Chart const
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

/*eslint no-magic-numbers: 0*/

/**
 * Chart const
 * @readonly
 * @enum {number}
 */
var chartConst = {
    /** tui class names
     * @type {string}
     */
    CLASS_NAME_LEGEND_LABEL: 'tui-chart-legend-label',
    /** @type {string} */
    CLASS_NAME_LEGEND_CHECKBOX: 'tui-chart-legend-checkbox',
    /** @type {string} */
    CLASS_NAME_SERIES_LABEL: 'tui-chart-series-label',
    /** @type {string} */
    CLASS_NAME_SERIES_LEGEND: 'tui-chart-series-legend',
    /** @type {string} */
    CLASS_NAME_RESET_ZOOM_BTN: 'tui-chart-reset-zoom-btn',
    /** chart types
     * @type {string}
     */
    CHART_TYPE_BAR: 'bar',
    /** @type {string} */
    CHART_TYPE_COLUMN: 'column',
    /** @type {string} */
    CHART_TYPE_LINE: 'line',
    /** @type {string} */
    CHART_TYPE_AREA: 'area',
    /** @type {string} */
    CHART_TYPE_COMBO: 'combo',
    /** @type {string} */
    CHART_TYPE_COLUMN_LINE_COMBO: 'columnLineCombo',
    /** @type {string} */
    CHART_TYPE_LINE_AREA_COMBO: 'lineAreaCombo',
    /** @type {string} */
    CHART_TYPE_PIE_DONUT_COMBO: 'pieDonutCombo',
    /** @type {string} */
    CHART_TYPE_PIE: 'pie',
    /** @type {string} */
    CHART_TYPE_BUBBLE: 'bubble',
    /** @type {string} */
    CHART_TYPE_SCATTER: 'scatter',
    /** @type {string} */
    CHART_TYPE_HEATMAP: 'heatmap',
    /** @type {string} */
    CHART_TYPE_TREEMAP: 'treemap',
    /** @type {string} */
    CHART_TYPE_MAP: 'map',
    /** chart padding */
    CHART_PADDING: 10,
    /** chart default width */
    CHART_DEFAULT_WIDTH: 500,
    /** chart default height */
    CHART_DEFAULT_HEIGHT: 400,
    /** overlapping width of xAxis and yAxis */
    OVERLAPPING_WIDTH: 1,
    /** rendered text padding */
    TEXT_PADDING: 2,
    /** series expand size */
    SERIES_EXPAND_SIZE: 10,
    /** series label padding */
    SERIES_LABEL_PADDING: 5,
    /** default font size of title */
    DEFAULT_TITLE_FONT_SIZE: 14,
    /** default font size of axis title */
    DEFAULT_AXIS_TITLE_FONT_SIZE: 10,
    /** default font size of label */
    DEFAULT_LABEL_FONT_SIZE: 12,
    /** default font size of series label */
    DEFAULT_SERIES_LABEL_FONT_SIZE: 11,
    /** default graph plugin
     * @type {string}
     */
    DEFAULT_PLUGIN: 'raphael',
    /** default tick color
     * @type {string}
     */
    DEFAULT_TICK_COLOR: 'black',
    /** default theme name
     * @type {string}
     */
    DEFAULT_THEME_NAME: 'default',
    MAX_HEIGHT_WORLD: 'A',
    /** stack type
     * @type {string}
     */
    NORMAL_STACK_TYPE: 'normal',
    /** @type {string} */
    PERCENT_STACK_TYPE: 'percent',
    /** default stack
     * @type {string}
     */
    DEFAULT_STACK: '___DEFAULT___STACK___',
    /** dummy key
     * @type {string}
     */
    DUMMY_KEY: '___DUMMY___KEY___',
    /** root id of treemap
     * @type {string}
     */
    TREEMAP_ROOT_ID: '___TUI_TREEMAP_ROOT___',
    /** id prefix of treemap
     * @type {string}
     */
    TREEMAP_ID_PREFIX: '___TUI_TREEMAP_ID___',
    /** prefix for caching seriesItems
     * @type {string}
     */
    TREEMAP_DEPTH_KEY_PREFIX: '___TUI_TREEMAP_DEPTH___',
    /** @type {string} */
    TREEMAP_PARENT_KEY_PREFIX: '___TUI_TREEMAP_PARENT___',
    /** @type {string} */
    TREEMAP_LEAF_KEY_PREFIX: '___TUI_TREEMAP_LEAF___',
    /** @type {string} */
    TREEMAP_LIMIT_DEPTH_KEY_PREFIX: '___TUI_TREEMAP_LIMIT_DEPTH___',
    /** default border color for treemap chart
     * @type {string}
     */
    TREEMAP_DEFAULT_BORDER: '#ccc',
    /** empty axis label */
    EMPTY_AXIS_LABEL: '',
    /** angel */
    ANGLE_85: 85,
    ANGLE_90: 90,
    ANGLE_360: 360,
    /** radian */
    RAD: Math.PI / 180,
    RERENDER_TIME: 700,
    /** series label align outer
     * @type {string}
     */
    LABEL_ALIGN_OUTER: 'outer',
    /** @type {string} */
    LEGEND_ALIGN_TOP: 'top',
    /** @type {string} */
    LEGEND_ALIGN_BOTTOM: 'bottom',
    /** @type {string} */
    LEGEND_ALIGN_LEFT: 'left',
    /** series outer label padding */
    SERIES_OUTER_LABEL_PADDING: 20,
    /** default ratio for pie graph */
    PIE_GRAPH_DEFAULT_RATIO: 0.8,
    /** small ratio for pie graph */
    PIE_GRAPH_SMALL_RATIO: 0.65,
    /** tick count for spectrum legend */
    SPECTRUM_LEGEND_TICK_COUNT: 4,
    /** default position ratio of map chart label
     * @type {object}
     */
    MAP_CHART_LABEL_DEFAULT_POSITION_RATIO: {
        x: 0.5,
        y: 0.5
    },
    /** dot radius */
    DOT_RADIUS: 4,
    /** radius for circle of scatter chart*/
    SCATTER_RADIUS: 5,
    /** yAxis properties
     * @type {Array.<string>}
     */
    YAXIS_PROPS: ['tickColor', 'title', 'label'], // yaxis theme의 속성 - chart type filtering할 때 사용됨
    /** series properties
     * @type {Array.<string>}
     */
    SERIES_PROPS: ['label', 'colors', 'borderColor', 'singleColors',
        'selectionColor', 'startColor', 'endColor', 'overColor'], // series theme의 속성 - chart type filtering할 때 사용됨
    /** title area width padding */
    TITLE_AREA_WIDTH_PADDING: 20,
    /** top margin of x axis label */
    XAXIS_LABEL_TOP_MARGIN: 10,
    /** right padding of vertical label */
    V_LABEL_RIGHT_PADDING: 10,
    /** tooltip prefix
     * @type {string}
     */
    TOOLTIP_PREFIX: 'tui-chart-tooltip',
    /** tooltip z-index **/
    TOOLTIP_ZINDEX: 500,
    /** tooltip animation time */
    TOOLTIP_ANIMATION_TIME: 100,
    /** tooltip animation time for pie chart */
    TOOLTIP_PIE_ANIMATION_TIME: 50,
    /** minimum pixel type step size */
    MIN_PIXEL_TYPE_STEP_SIZE: 45,
    /** maximum pixel type step size */
    MAX_PIXEL_TYPE_STEP_SIZE: 65,
    /** axis scale for percent stack option
     * @type {object}
     */
    PERCENT_STACKED_AXIS_SCALE: {
        limit: {
            min: 0,
            max: 100
        },
        step: 25,
        labels: [0, 25, 50, 75, 100]
    },
    /** axis scale for minus percent stack option
     * @type {object}
     */
    MINUS_PERCENT_STACKED_AXIS_SCALE: {
        limit: {
            min: -100,
            max: 0
        },
        step: 25,
        labels: [0, -25, -50, -75, -100]
    },
    /** axis scale of dual percent stack option
     * @type {object}
     */
    DUAL_PERCENT_STACKED_AXIS_SCALE: {
        limit: {
            min: -100,
            max: 100
        },
        step: 25,
        labels: [-100, -75, -50, -25, 0, 25, 50, 75, 100]
    },
    /** axis scale of diverging percent stack option
     * @type {object}
     */
    DIVERGING_PERCENT_STACKED_AXIS_SCALE: {
        limit: {
            min: -100,
            max: 100
        },
        step: 25,
        labels: [100, 75, 50, 25, 0, 25, 50, 75, 100]
    },
    /** title add padding */
    TITLE_PADDING: 10,
    /** legend area padding */
    LEGEND_AREA_PADDING: 10,
    /** legend checkbox width */
    LEGEND_CHECKBOX_WIDTH: 20,
    /** legend rect width */
    LEGEND_RECT_WIDTH: 12,
    /** lgend label left padding */
    LEGEND_LABEL_LEFT_PADDING: 5,
    MIN_LEGEND_WIDTH: 100,
    /** map legend height */
    MAP_LEGEND_SIZE: 200,
    /** map legend graph size */
    MAP_LEGEND_GRAPH_SIZE: 25,
    /** map legend label padding */
    MAP_LEGEND_LABEL_PADDING: 5,
    CIRCLE_LEGEND_LABEL_FONT_SIZE: 9,
    CIRCLE_LEGEND_PADDING: 10,
    HALF_RATIO: 0.5,
    /** AXIS LABEL PADDING */
    AXIS_LABEL_PADDING: 7,
    /** rotations degree candidates */
    DEGREE_CANDIDATES: [25, 45, 65, 85],
    /**
     * auto tick interval
     * @type {string}
     */
    TICK_INTERVAL_AUTO: 'auto',
    /** yAxis align option
     * @type {string}
     */
    YAXIS_ALIGN_CENTER: 'center',
    /** xAxis label compare margin */
    XAXIS_LABEL_COMPARE_MARGIN: 20,
    /** xAxis label gutter */
    XAXIS_LABEL_GUTTER: 2,
    /**
     * Standard multiple nums of axis
     * @type {Array}
     */
    AXIS_STANDARD_MULTIPLE_NUMS: [1, 2, 5, 10, 20, 50, 100],
    /**
     * Last standard multiple num of axis
     */
    AXIS_LAST_STANDARD_MULTIPLE_NUM: 100,
    /** label padding top */
    LABEL_PADDING_TOP: 2,
    /** line margin top */
    LINE_MARGIN_TOP: 5,
    /** tooltip gap */
    TOOLTIP_GAP: 5,
    /** tooltip direction
     * @type {string}
     */
    TOOLTIP_DIRECTION_FORWARD: 'forword',
    /** @type {string} */
    TOOLTIP_DIRECTION_CENTER: 'center',
    /** @type {string} */
    TOOLTIP_DIRECTION_BACKWARD: 'backword',
    /** tooltip align options
     * @type {string}
     */
    TOOLTIP_DEFAULT_ALIGN_OPTION: 'center top',
    /** @type {string} */
    TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION: 'right middle',
    /** @type {string} */
    TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION: 'right middle',
    /** @type {string} */
    TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION: 'center bottom',
    /** hide delay */
    HIDE_DELAY: 200,
    OLD_BROWSER_OPACITY_100: 100,
    SERIES_LABEL_OPACITY: 0.3,
    WHEEL_TICK: 120,
    MAX_ZOOM_MAGN: 32,
    FF_WHEELDELTA_ADJUSTING_VALUE: -40,
    IE7_ROTATION_FILTER_STYLE_MAP: {
        25: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' +
                ' M11=0.9063077870366499, M12=0.42261826174069944, M21=-0.42261826174069944, M22=0.9063077870366499)"',
        45: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' +
                ' M11=0.7071067811865476, M12=0.7071067811865475, M21=-0.7071067811865475, M22=0.7071067811865476)"',
        65: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' +
                ' M11=0.42261826174069944, M12=0.9063077870366499, M21=-0.9063077870366499, M22=0.42261826174069944)"',
        85: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' +
                ' M11=0.08715574274765814, M12=0.9961946980917455, M21=-0.9961946980917455, M22=0.08715574274765814)"'
    }
};
module.exports = chartConst;

},{}],32:[function(require,module,exports){
/**
 * @fileoverview AreaTypeCustomEvent is event handle layer for line type chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase');
var zoomMixer = require('./zoomMixer');
var AreaTypeDataModel = require('./areaTypeDataModel');

var AreaTypeCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends AreaTypeCustomEvent.prototype */ {
    /**
     * AreaTypeCustomEvent is custom event for line type chart.
     * @param {object} params parameters
     * @constructs AreaTypeCustomEvent
     * @extends CustomEventBase
     */
    init: function(params) {
        CustomEventBase.call(this, params);

        /**
         * previous found data
         * @type {null | object}
         */
        this.prevFoundData = null;

        this._initForZoom(params.zoomable);
    },

    /**
     * Initialize data of custom event
     * @param {Array.<object>} seriesInfos series infos
     * @override
     */
    initCustomEventData: function(seriesInfos) {
        var seriesInfo = seriesInfos[0];

        this.dataModel = new AreaTypeDataModel(seriesInfo);
        CustomEventBase.prototype.initCustomEventData.call(this, seriesInfos);

        this._showTooltipAfterZoom();
    },

    /**
     * Find data by client position.
     * @param {number} clientX - clientX
     * @param {number} clientY - clientY
     * @returns {object}
     * @private
     */
    _findData: function(clientX, clientY) {
        var layerPosition = this._calculateLayerPosition(clientX, clientY);
        var groupIndex = this.tickBaseCoordinateModel.findIndex(layerPosition.x);

        return this.dataModel.findData(groupIndex, layerPosition.y);
    },

    /**
     * Get first model data.
     * @param {number} index - index
     * @returns {object}
     * @private
     */
    _getFirstData: function(index) {
        return this.dataModel.getFirstData(index);
    },

    /**
     * Get last model data.
     * @param {number} index - index
     * @returns {object}
     * @private
     */
    _getLastData: function(index) {
        return this.dataModel.getLastData(index);
    },

    /**
     * Show tooltip.
     * @param {object} foundData - model data
     * @private
     */
    _showTooltip: function(foundData) {
        this.fire('showTooltip', foundData);
    },

    /**
     * Hide tooltip.
     * @private
     */
    _hideTooltip: function() {
        this.fire('hideTooltip', this.prevFoundData);
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onMousemove: function(e) {
        var foundData;

        CustomEventBase.prototype._onMousemove.call(this, e);

        foundData = this._findData(e.clientX, e.clientY);

        if (this._isAfterDragMouseup() || !this._isChangedSelectData(this.prevFoundData, foundData)) {
            return;
        }

        if (foundData) {
            this._showTooltip(foundData);
        } else if (this.prevFoundData) {
            this._hideTooltip();
        }

        this.prevFoundData = foundData;
    },

    /**
     * On mouseout.
     * @private
     * @override
     */
    _onMouseout: function() {
        if (this.prevFoundData) {
            this._hideTooltip();
        }

        CustomEventBase.prototype._onMouseout.call(this);
    }
});

zoomMixer.mixin(AreaTypeCustomEvent);

module.exports = AreaTypeCustomEvent;

},{"./areaTypeDataModel":33,"./customEventBase":36,"./zoomMixer":41}],33:[function(require,module,exports){
/**
 * @fileoverview AreaTypeDataModel is data model for custom event of area type.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var AreaTypeDataModel = tui.util.defineClass(/** @lends AreaTypeDataModel.prototype */ {
    /**
     * AreaTypeDataModel is data mode for custom event of area type.
     * @constructs AreaTypeDataModel
     * @param {object} seriesInfo series info
     */
    init: function(seriesInfo) {
        this.data = this._makeData(seriesInfo.data.groupPositions, seriesInfo.chartType);
    },

    /**
     * Make area type data for custom event.
     * @param {Array.<Array.<object>>} groupPositions - group positions
     * @param {string} chartType - chart type
     * @returns {Array}
     * @private
     */
    _makeData: function(groupPositions, chartType) {
        groupPositions = tui.util.pivot(groupPositions);

        return tui.util.map(groupPositions, function(positions, groupIndex) {
            return tui.util.map(positions, function(position, index) {
                return {
                    chartType: chartType,
                    indexes: {
                        groupIndex: groupIndex,
                        index: index
                    },
                    bound: position
                };
            });
        });
    },

    /**
     * Find Data.
     * @param {number} groupIndex - group index
     * @param {number} layerY - mouse position
     * @returns {object}
     */
    findData: function(groupIndex, layerY) {
        var result = null,
            min = 10000;
        tui.util.forEach(this.data[groupIndex], function(data) {
            var diff = Math.abs(layerY - data.bound.top);
            if (min > diff) {
                min = diff;
                result = data;
            }
        });

        return result;
    },

    /**
     * Get first data.
     * @param {number} index - index
     * @returns {object}
     */
    getFirstData: function(index) {
        return this.data[0][index];
    },

    /**
     * Get last data.
     * @param {number} index - index
     * @returns {object}
     */
    getLastData: function(index) {
        var lastGroupIndex = this.data.length - 1;

        return this.data[lastGroupIndex][index];
    }
});

module.exports = AreaTypeDataModel;

},{}],34:[function(require,module,exports){
/**
 * @fileoverview BoundsBaseCoordinateModel is data mode for custom event of point type.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * position
 * @typedef {{left: number, top: number}} position
 */

/**
 * bound
 * @typedef {{
 *      dimension: {width: number, height: number},
 *      position: position
 *}} bound
 */

/**
 * group bound
 *  @typedef {Array.<Array.<bound>>} groupBound
 */

/**
 * group position
 *  @typedef {Array.<Array.<position>>} groupPosition
 */

/**
 * series info
 * @typedef {{
 *      chartType: {string},
 *      data: {
 *          groupBounds: ?groupBound,
 *          groupValues: ?Array.<Array.<number>>,
 *          groupPositions: ?groupPosition
 *      }
 *}} seriesInfo
 */

var chartConst = require('../const'),
    predicate = require('../helpers/predicate');

var BoundsBaseCoordinateModel = tui.util.defineClass(/** @lends BoundsBaseCoordinateModel.prototype */ {
    /**
     * BoundsBaseCoordinateModel is data mode for custom event of point type.
     * @constructs BoundsBaseCoordinateModel
     * @param {Array.<seriesInfo>} seriesInfos series infos
     */
    init: function(seriesInfos) {
        this.data = this._makeData(seriesInfos);
    },

    /**
     * Make coordinate data about bar type graph
     * @param {groupBound} groupBounds group bounds
     * @param {string} chartType chart type
     * @returns {Array} coordinate data
     * @private
     */
    _makeRectTypeCoordinateData: function(groupBounds, chartType) {
        var allowNegativeTooltip = !predicate.isBoxTypeChart(chartType);

        return tui.util.map(groupBounds, function(bounds, groupIndex) {
            return tui.util.map(bounds, function(_bound, index) {
                var bound;
                if (!_bound) {
                    return null;
                }

                bound = _bound.end;

                return {
                    sendData: {
                        chartType: chartType,
                        indexes: {
                            groupIndex: groupIndex,
                            index: index
                        },
                        allowNegativeTooltip: allowNegativeTooltip,
                        bound: bound
                    },
                    bound: {
                        left: bound.left,
                        top: bound.top,
                        right: bound.left + bound.width,
                        bottom: bound.top + bound.height
                    }
                };
            });
        });
    },

    /**
     * Make coordinate data about dot type graph
     * @param {groupPositions} groupPositions group positions
     * @param {string} chartType chart type
     * @returns {Array.<Array.<object>>} coordinate data
     * @private
     */
    _makeDotTypeCoordinateData: function(groupPositions, chartType) {
        if (!groupPositions) {
            return [];
        }

        return tui.util.map(tui.util.pivot(groupPositions), function(positions, groupIndex) {
            return tui.util.map(positions, function(position, index) {
                return {
                    sendData: {
                        chartType: chartType,
                        indexes: {
                            groupIndex: groupIndex,
                            index: index
                        },
                        bound: position
                    },
                    bound: {
                        left: position.left - chartConst.DOT_RADIUS,
                        top: position.top - chartConst.DOT_RADIUS,
                        right: position.left + chartConst.DOT_RADIUS,
                        bottom: position.top + chartConst.DOT_RADIUS
                    }
                };
            });
        });
    },

    /**
     * Join data.
     * @param {Array.<Array.<Array.<object>>>} groupData group data
     * @returns {Array.<Array.<object>>} joined data
     * @private
     */
    _joinData: function(groupData) {
        var results = [];
        tui.util.forEachArray(groupData, function(coordData) {
            tui.util.forEachArray(coordData, function(data, index) {
                if (!results[index]) {
                    results[index] = [];
                }
                results[index] = results[index].concat(data);
            });
        });

        return results;
    },

    /**
     * Make coordinate data.
     * @param {Array.<seriesInfo>} seriesInfos series infos
     * @returns {Array.<Array.<object>>} coordinate data
     * @private
     */
    _makeData: function(seriesInfos) {
        var self = this,
            coordinateData;

        seriesInfos.reverse();
        coordinateData = tui.util.map(seriesInfos, function(info) {
            var result;
            if (predicate.isLineTypeChart(info.chartType)) {
                result = self._makeDotTypeCoordinateData(info.data.groupPositions, info.chartType);
            } else {
                result = self._makeRectTypeCoordinateData(info.data.groupBounds, info.chartType);
            }

            return result;
        });

        return this._joinData(coordinateData);
    },

    /**
     * Find candidates.
     * @param {{bound: {left: number, top: number, right: number, bottom: number}}} data data
     * @param {number} layerX layerX
     * @param {number} layerY layerY
     * @returns {Array.<{sendData: object}>} candidates
     * @private
     */
    _findCandidates: function(data, layerX, layerY) {
        return tui.util.filter(data, function(datum) {
            var bound = datum && datum.bound,
                included = false,
                includedX, includedY;

            if (bound) {
                includedX = bound.left <= layerX && bound.right >= layerX;
                includedY = bound.top <= layerY && bound.bottom >= layerY;
                included = includedX && includedY;
            }

            return included;
        });
    },

    /**
     * Find tooltip data.
     * @param {number} groupIndex group index
     * @param {number} layerX mouse position x
     * @param {number} layerY mouse position y
     * @returns {object} tooltip data
     */
    findData: function(groupIndex, layerX, layerY) {
        var min = 10000,
            result = null,
            candidates;

        if (groupIndex > -1) {
            // layerX, layerY를 포함하는 data 추출
            candidates = this._findCandidates(this.data[groupIndex], layerX, layerY);

            // 추출된 data 중 top이 layerY와 가장 가까운 data 찾아내기
            tui.util.forEachArray(candidates, function(data) {
                var diff = Math.abs(layerY - data.sendData.bound.top);
                if (min > diff) {
                    min = diff;
                    result = data.sendData;
                }
            });
        }

        return result;
    }
});

module.exports = BoundsBaseCoordinateModel;

},{"../const":31,"../helpers/predicate":61}],35:[function(require,module,exports){
/**
 * @fileoverview BoundsTypeCustomEvent is event handle layer for bounds.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase');
var chartConst = require('../const');
var predicate = require('../helpers/predicate');
var dom = require('../helpers/domHandler');

var BoundsTypeCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends BoundsTypeCustomEvent.prototype */ {
    /**
     * BoundsTypeCustomEvent is event handle layer for line type chart.
     * @constructs BoundsTypeCustomEvent
     * @extends CustomEventBase
     */
    init: function() {
        CustomEventBase.apply(this, arguments);

        /**
         * previous found data
         * @type {null | object}
         */
        this.prevFoundData = null;

        /**
         * history array for treemap chart.
         * @type {number}
         */
        this.zoomHistory = [-1];

        /**
         * button for zoom history back
         * @type {null | HTMLElement}
         */
        this.historyBackBtn = null;
    },

    /**
     * Hide tooltip.
     * @private
     */
    _hideTooltip: function() {
        this.fire('hideTooltip', this.prevFoundData);
        this.prevFoundData = null;
        this.styleCursor(false);
    },

    /**
     * Style css cursor.
     * @param {boolean} hasChild - whether has child or not
     */
    styleCursor: function(hasChild) {
        var container = this.customEventContainer;
        if (hasChild) {
            container.style.cursor = 'pointer';
        } else {
            container.style.cursor = 'default';
        }
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onMousemove: function(e) {
        var foundData = this._findDataFromBoundsCoordinateModel(this.customEventContainer, e.clientX, e.clientY);
        var seriesItem;

        if (!this._isChangedSelectData(this.prevFoundData, foundData)) {
            return;
        }

        if (this.prevFoundData) {
            this._hideTooltip();
        }

        this.prevFoundData = foundData;

        if (!foundData) {
            return;
        }

        if (predicate.isTreemapChart(this.chartType)) {
            seriesItem = this._getSeriesItemByIndexes(foundData.indexes);
            this.styleCursor(seriesItem.hasChild);
        }

        this.fire('showTooltip', foundData);
    },

    /**
     * Zoom history back.
     * @private
     */
    _zoomHistoryBack: function() {
        var index = this.zoomHistory[this.zoomHistory.length - 2];

        this.zoomHistory.pop();
        this.fire('zoom', index);

        if (this.zoomHistory.length === 1) {
            this.customEventContainer.removeChild(this.historyBackBtn);
            this.historyBackBtn = null;
        }
    },

    /**
     * Get seriesItem by indexes
     * @param {{groupIndex: number, index: number}} indexes - indexes
     * @returns {SeriesItem}
     * @private
     */
    _getSeriesItemByIndexes: function(indexes) {
        var seriesDataModel = this.dataProcessor.getSeriesDataModel(chartConst.CHART_TYPE_TREEMAP);

        return seriesDataModel.getSeriesItem(indexes.groupIndex, indexes.index, true);
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onClick: function(e) {
        var target = e.target || e.srcElement;
        var foundData, seriesItem;

        if (!predicate.isTreemapChart(this.chartType)) {
            return;
        }

        if (dom.hasClass(target, chartConst.CLASS_NAME_RESET_ZOOM_BTN)) {
            this._hideTooltip();
            this._zoomHistoryBack();

            return;
        }

        foundData = this._findDataFromBoundsCoordinateModel(target, e.clientX, e.clientY);

        if (foundData) {
            seriesItem = this._getSeriesItemByIndexes(foundData.indexes);

            if (!seriesItem.hasChild) {
                return;
            }

            this._hideTooltip();
            this.fire('zoom', foundData.indexes.index);
        }
    },

    /**
     * On mouseout.
     * @override
     */
    _onMouseout: function(e) {
        var bound = this._getContainerBound();
        var clientX = e.clientX;
        var clientY = e.clientY;

        if ((bound.left <= clientX) && (bound.top <= clientY) &&
            (bound.right >= clientX) && (bound.bottom >= clientY)) {
            return;
        }

        if (this.prevFoundData) {
            this._hideTooltip();
        }

        CustomEventBase.prototype._onMouseout.call(this);
    },

    /**
     * On after zoom.
     * @param {number} index - index of target seriesItem
     */
    onAfterZoom: function(index) {
        if (!this.historyBackBtn) {
            this.historyBackBtn = dom.create('DIV', chartConst.CLASS_NAME_RESET_ZOOM_BTN);
            this.historyBackBtn.innerHTML = '< Back';
            dom.append(this.customEventContainer, this.historyBackBtn);
        }

        if (this.zoomHistory[this.zoomHistory.length - 1] !== index) {
            this.zoomHistory.push(index);
        }
    }
});

module.exports = BoundsTypeCustomEvent;

},{"../const":31,"../helpers/domHandler":59,"../helpers/predicate":61,"./customEventBase":36}],36:[function(require,module,exports){
/**
 * @fileoverview CustomEventBase is base class for event handle layers.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var TickBaseCoordinateModel = require('./tickBaseCoordinateModel');
var BoundsBaseCoordinateModel = require('./boundsBaseCoordinateModel');
var chartConst = require('../const');
var eventListener = require('../helpers/eventListener');
var predicate = require('../helpers/predicate');
var dom = require('../helpers/domHandler');
var renderUtil = require('../helpers/renderUtil');

var CustomEventBase = tui.util.defineClass(/** @lends CustomEventBase.prototype */ {
    /**
     * CustomEventBase is base class for custom event components.
     * @constructs CustomEventBase
     * @param {object} params parameters
     *      @param {{
     *          dimension: {width: number, height: number},
     *          position: {left: number, top: number}
     *      }} params.bound bound
     *      @param {string} params.chartType chart type
     *      @param {boolean} params.isVertical whether vertical or not
     */
    init: function(params) {
        var isLineTypeChart;

        /**
         * type of chart
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * chartTypes is available in combo chart
         * @type {Array.<string>}
         */
        this.chartTypes = params.chartTypes;

        /**
         * whether vertical or not
         * @type {boolean}
         */
        this.isVertical = params.isVertical;

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * selected series item.
         * @type {null | object}
         */
        this.selectedData = null;

        /**
         * previous client position of mouse event (clientX, clientY)
         * @type {null | object}
         */
        this.prevClientPosition = null;

        /**
         * previous found data
         * @type {null | object}
         */
        this.prevFoundData = null;


        isLineTypeChart = predicate.isLineTypeChart(this.chartType, this.chartTypes);

        /**
         * expand size
         * @type {number}
         */
        this.expandSize = isLineTypeChart ? chartConst.SERIES_EXPAND_SIZE : 0;

        /**
         * container bound
         * @type {null | {left: number, top: number, right: number, bottom: number}}
         */
        this.containerBound = null;
    },

    /**
     * Get bound for rendering.
     * @returns {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }}
     * @private
     */
    _getRenderingBound: function() {
        var renderingBound;

        if (predicate.isLineTypeChart(this.chartType, this.chartTypes)) {
            renderingBound = renderUtil.expandBound(this.boundsMaker.getBound('customEvent'));
        } else {
            renderingBound = this.boundsMaker.getBound('customEvent');
        }

        return renderingBound;
    },

    /**
     * Render event handle layer area.
     * @param {HTMLElement} customEventContainer - container element for custom event
     * @param {object} data - data for rendering
     * @private
     */
    _renderCustomEventArea: function(customEventContainer, data) {
        var dimension = this.boundsMaker.getDimension('customEvent');
        var renderingBound, tbcm;

        this.dimension = dimension;
        tbcm = new TickBaseCoordinateModel(dimension, data.tickCount, this.chartType, this.isVertical, this.chartTypes);
        this.tickBaseCoordinateModel = tbcm;
        renderingBound = this._getRenderingBound();
        renderUtil.renderDimension(customEventContainer, renderingBound.dimension);
        renderUtil.renderPosition(customEventContainer, renderingBound.position);
    },

    /**
     * Render for customEvent component.
     * @param {object} data - data for rendering
     * @returns {HTMLElement} container for custom event
     */
    render: function(data) {
        var container = dom.create('DIV', 'tui-chart-series-custom-event-area');

        this._renderCustomEventArea(container, data);
        this.attachEvent(container);
        this.customEventContainer = container;

        return container;
    },

    /**
     * Get container bound.
     * @returns {ClientRect}
     * @private
     */
    _getContainerBound: function() {
        if (!this.containerBound) {
            this.containerBound = this.customEventContainer.getBoundingClientRect();
        }

        return this.containerBound;
    },

    /**
     * Create BoundsBaseCoordinateModel from seriesBounds for custom event.
     * @param {Array.<object>} seriesBounds - series bounds
     */
    initCustomEventData: function(seriesBounds) {
        this.boundsBaseCoordinateModel = new BoundsBaseCoordinateModel(seriesBounds);
    },

    /**
     * Rerender for customEvent component.
     * @param {{tickCount: number}} data - data for rerendering
     */
    rerender: function(data) {
        this._renderCustomEventArea(this.customEventContainer, data);
    },

    /**
     * Resize for customEvent component.
     * @param {{tickCount: number}} data - data for resizing
     */
    resize: function(data) {
        this.containerBound = null;
        this.rerender(data);
    },

    /**
     * Whether changed select data or not.
     * @param {object} prev - previous data
     * @param {object} cur - current data
     * @returns {boolean}
     * @private
     */
    _isChangedSelectData: function(prev, cur) {
        return !prev || !cur || prev.chartType !== cur.chartType ||
            prev.indexes.groupIndex !== cur.indexes.groupIndex || prev.indexes.index !== cur.indexes.index;
    },

    /**
     * Find coordinate data from boundsCoordinateModel.
     * @param {HTMLElement} target - target element
     * @param {number} clientX mouse - position x
     * @param {number} clientY mouse - position y
     * @returns {object}
     * @private
     */
    _findDataFromBoundsCoordinateModel: function(target, clientX, clientY) {
        var bound = target.getBoundingClientRect();
        var layerX = clientX - bound.left;
        var layerY = clientY - bound.top;
        var groupIndex;

        if (predicate.isTreemapChart(this.chartType)) {
            groupIndex = 0;
        } else {
            groupIndex = this.tickBaseCoordinateModel.findIndex(this.isVertical ? layerX : layerY);
            layerX += chartConst.SERIES_EXPAND_SIZE;
            layerY += chartConst.SERIES_EXPAND_SIZE;
        }

        return this.boundsBaseCoordinateModel.findData(groupIndex, layerX, layerY);
    },

    /**
     * Unselect selected data.
     * @private
     */
    _unselectSelectedData: function() {
        var eventName = renderUtil.makeCustomEventName('unselect', this.selectedData.chartType, 'series');
        this.fire(eventName, this.selectedData);
        this.selectedData = null;
    },

    /**
     * Find data.
     * @private
     * @abstract
     */
    _findData: function() {},

    /**
     * Show tooltip
     * @private
     * @abstract
     */
    _showTooltip: function() {},

    /**
     * Animate for adding data.
     */
    animateForAddingData: function() {
        var foundData, isMoving;

        if (!this.prevClientPosition) {
            return;
        }

        foundData = this._findData(this.prevClientPosition.x, this.prevClientPosition.y);

        if (foundData) {
            isMoving = this.prevFoundData && (this.prevFoundData.indexes.groupIndex === foundData.indexes.groupIndex);
            this._showTooltip(foundData, isMoving);
        }

        this.prevFoundData = foundData;
    },

    /**
     * On mouse event.
     * @param {string} eventType - custom event type
     * @param {MouseEvent} e - mouse event
     * @private
     */
    _onMouseEvent: function(eventType, e) {
        var eventName = renderUtil.makeCustomEventName(eventType, this.chartType, 'series');

        dom.addClass(this.customEventContainer, 'hide');
        this.fire(eventName, {
            left: e.clientX,
            top: e.clientY
        });
        dom.removeClass(this.customEventContainer, 'hide');
    },

    /**
     * On click
     * @param {MouseEvent} e - mouse event
     * @private
     */
    _onClick: function(e) {
        var target = e.target || e.srcElement;
        var clientX = e.clientX - this.expandSize;
        var foundData = this._findDataFromBoundsCoordinateModel(target, clientX, e.clientY);

        if (!this._isChangedSelectData(this.selectedData, foundData)) {
            this._unselectSelectedData();
        } else if (foundData) {
            if (this.selectedData) {
                this._unselectSelectedData();
            }
            this.fire(renderUtil.makeCustomEventName('select', foundData.chartType, 'series'), foundData);
            this.selectedData = foundData;
        }
    },

    /**
     * On mouse down
     * @private
     * @abstract
     */
    _onMousedown: function() {},

    /**
     * On mouse up
     * @private
     * @abstract
     */
    _onMouseup: function() {},

    /**
     * On mouse move
     * @param {MouseEvent} e - mouse event
     * @private
     */
    _onMousemove: function(e) {
        this.prevClientPosition = {
            x: e.clientX,
            y: e.clientY
        };
    },

    /**
     * On mouse out
     * @private
     */
    _onMouseout: function() {
        this.prevClientPosition = null;
        this.prevFoundData = null;
    },

    /**
     * Attach event
     * @param {HTMLElement} target - target element
     */
    attachEvent: function(target) {
        eventListener.on(target, {
            click: this._onClick,
            mousedown: this._onMousedown,
            mouseup: this._onMouseup,
            mousemove: this._onMousemove,
            mouseout: this._onMouseout
        }, this);
    }
});

tui.util.CustomEvents.mixin(CustomEventBase);

module.exports = CustomEventBase;

},{"../const":31,"../helpers/domHandler":59,"../helpers/eventListener":60,"../helpers/predicate":61,"../helpers/renderUtil":63,"./boundsBaseCoordinateModel":34,"./tickBaseCoordinateModel":40}],37:[function(require,module,exports){
/**
 * @fileoverview GroupTypeCustomEvent is event handle layer for grouped tooltip option.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase');
var zoomMixer = require('./zoomMixer');
var chartConst = require('../const');

var GroupTypeCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends GroupTypeCustomEvent.prototype */ {
    /**
     * GroupTypeCustomEvent is event handle layer for grouped tooltip option.
     * @param {object} params parameters
     * @constructs GroupTypeCustomEvent
     * @extends CustomEventBase
     */
    init: function(params) {
        CustomEventBase.call(this, params);

        /**
         * previous index of group data
         * @type {null}
         */
        this.prevIndex = null;

        /**
         * type of size
         * @type {string}
         */
        this.sizeType = this.isVertical ? 'height' : 'width';

        this._initForZoom(params.zoomable);
    },

    /**
     * Initialize data of custom event
     * @param {Array.<object>} seriesInfos series infos
     * @override
     */
    initCustomEventData: function(seriesInfos) {
        CustomEventBase.prototype.initCustomEventData.call(this, seriesInfos);

        this._showTooltipAfterZoom();
    },

    /**
     * Find data by client position.
     * @param {number} clientX - clientX
     * @param {number} clientY - clientY
     * @returns {object}
     * @private
     */
    _findData: function(clientX, clientY) {
        var layerPosition = this._calculateLayerPosition(clientX, clientY, true);
        var pointValue;

        if (this.isVertical) {
            pointValue = layerPosition.x - this.expandSize;
        } else {
            pointValue = layerPosition.y - chartConst.SERIES_EXPAND_SIZE;
        }

        return {
            indexes: {
                groupIndex: this.tickBaseCoordinateModel.findIndex(pointValue)
            }
        };
    },

    /**
     * Get first data.
     * @returns {{indexes: {groupIndex: number}}} - data
     * @private
     */
    _getFirstData: function() {
        return {
            indexes: {
                groupIndex: 0
            }
        };
    },

    /**
     * Get last data
     * @returns {{indexes: {groupIndex: number}}} - data
     * @private
     */
    _getLastData: function() {
        return {
            indexes: {
                groupIndex: this.tickBaseCoordinateModel.getLastIndex()
            }
        };
    },

    /**
     * Whether out position or not.
     * @param {number} layerX layerX
     * @param {number} layerY layerY
     * @returns {boolean} result boolean
     * @private
     */
    _isOutPosition: function(layerX, layerY) {
        var dimension = this.dimension;

        return layerX < 0 || layerX > dimension.width || layerY < 0 || layerY > dimension.height;
    },

    /**
     * Show tooltip.
     * @param {{indexes: {groupIndex: number}}} foundData - data
     * @param {boolean} [isMoving] - whether moving or not
     * @private
     */
    _showTooltip: function(foundData, isMoving) {
        var index = foundData.indexes.groupIndex;

        this.prevIndex = index;
        this.fire('showGroupTooltip', {
            index: index,
            range: this.tickBaseCoordinateModel.makeRange(index),
            size: this.dimension[this.sizeType],
            isVertical: this.isVertical,
            isMoving: isMoving
        });
    },

    /**
     * Hide tooltip
     * @private
     */
    _hideTooltip: function() {
        this.fire('hideGroupTooltip', this.prevIndex);
        this.prevIndex = null;
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e mouse event object
     * @private
     * @override
     */
    _onMousemove: function(e) {
        var foundData, index;

        CustomEventBase.prototype._onMousemove.call(this, e);

        if (this._isAfterDragMouseup()) {
            return;
        }

        foundData = this._findData(e.clientX, e.clientY);
        index = foundData.indexes.groupIndex;

        if (index === -1) {
            this._onMouseout(e);
        } else if (this.prevIndex !== index) {
            this._showTooltip(foundData);
        }
    },

    /**
     * On mouseout.
     * @override
     */
    _onMouseout: function(e) {
        var layerPosition;

        layerPosition = this._calculateLayerPosition(e.clientX, e.clientY, false);

        if (this._isOutPosition(layerPosition.x, layerPosition.y) && !tui.util.isNull(this.prevIndex)) {
            this._hideTooltip();
        }

        CustomEventBase.prototype._onMouseout.call(this);
    }
});

zoomMixer.mixin(GroupTypeCustomEvent);

module.exports = GroupTypeCustomEvent;

},{"../const":31,"./customEventBase":36,"./zoomMixer":41}],38:[function(require,module,exports){
/**
 * @fileoverview MapChartCustomEvent is event handle layer for map chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase'),
    chartConst = require('../const'),
    eventListener = require('../helpers/eventListener'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

var MapChartCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends MapChartCustomEvent.prototype */ {
    /**
     * MapChartCustomEvent is event handle layer for map chart.
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker boundsMaker instance
     * @constructs MapChartCustomEvent
     * @extends CustomEventBase
     */
    init: function(params) {
        this.boundsMaker = params.boundsMaker;
        this.chartType = params.chartType;
        this.isDown = false;
    },
    /**
     * Render event handle layer area
     * @param {HTMLElement} customEventContainer custom event container element
     * @private
     */
    _renderCustomEventArea: function(customEventContainer) {
        var bound = this.boundsMaker.getBound('customEvent');
        renderUtil.renderDimension(customEventContainer, bound.dimension);
        renderUtil.renderPosition(customEventContainer, bound.position);
    },

    /**
     * Initialize data of custom event
     * @override
     */
    initCustomEventData: function() {},

    /**
     * On click.
     * @private
     * @override
     */
    _onClick: function() {},

    /**
     * On mouse down
     * @param {mouseevent} e mouse event
     * @private
     * @override
     */
    _onMousedown: function(e) {
        this.isDown = true;
        this.fire('dragStartMapSeries', {
            left: e.clientX,
            top: e.clientY
        });
    },

    /**
     * Drag end.
     * @private
     */
    _dragEnd: function() {
        this.isDrag = false;
        dom.removeClass(this.customEventContainer, 'drag');
        this.fire('dragEndMapSeries');
    },

    /**
     * On mouse up
     * @param {mouseevent} e mouse event
     * @private
     * @override
     */
    _onMouseup: function(e) {
        this.isDown = false;
        if (this.isDrag) {
            this._dragEnd();
        } else if (!this.isMove) {
            this._onMouseEvent('click', e);
        }
        this.isMove = false;
    },

    /**
     * On mouse move.
     * @param {mouseevent} e mouse event
     * @private
     * @override
     */
    _onMousemove: function(e) {
        if (this.isDown) {
            if (!this.isDrag) {
                dom.addClass(this.customEventContainer, 'drag');
            }
            this.isDrag = true;
            this.fire('dragMapSeries', {
                left: e.clientX,
                top: e.clientY
            });
        } else {
            this.isMove = true;
            this._onMouseEvent('move', e);
        }
    },

    /**
     * On mouse out
     * @private
     * @override
     */
    _onMouseout: function(e) {
        if (this.isDrag) {
            this._dragEnd();
        } else {
            this._onMouseEvent('move', e);
        }
        this.isDown = false;
    },

    /**
     * On mouse wheel.
     * @param {mouseevent} e mouse event
     * @returns {?boolean}
     * @private
     */
    _onMousewheel: function(e) {
        var wheelDelta = e.wheelDelta || e.detail * chartConst.FF_WHEELDELTA_ADJUSTING_VALUE;

        this.fire('wheel', wheelDelta, {
            left: e.clientX,
            top: e.clientY
        });

        if (e.preventDefault) {
            e.preventDefault();
        }

        return false;
    },

    /**
     * Attach event
     * @param {HTMLElement} target target element
     * @override
     */
    attachEvent: function(target) {
        CustomEventBase.prototype.attachEvent.call(this, target);

        if (tui.util.browser.firefox) {
            eventListener.on(target, 'DOMMouseScroll', this._onMousewheel, this);
        } else {
            eventListener.on(target, 'mousewheel', this._onMousewheel, this);
        }
    }
});

tui.util.CustomEvents.mixin(MapChartCustomEvent);

module.exports = MapChartCustomEvent;

},{"../const":31,"../helpers/domHandler":59,"../helpers/eventListener":60,"../helpers/renderUtil":63,"./customEventBase":36}],39:[function(require,module,exports){
/**
 * @fileoverview SimpleCustomEvent is event handle layer for simply sending clientX, clientY.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase');
var renderUtil = require('../helpers/renderUtil');

var SimpleCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends SimpleCustomEvent.prototype */ {
    /**
     * SimpleCustomEvent is event handle layer for simply sending clientX, clientY.
     * @constructs SimpleCustomEvent
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker - bounds maker instance
     *      @param {string} params.chartType - chart type
     * @extends CustomEventBase
     */
    init: function(params) {
        this.boundsMaker = params.boundsMaker;
        this.chartType = params.chartType;
    },

    /**
     * Render event handle layer area
     * @param {HTMLElement} customEventContainer - container element for custom event
     * @private
     */
    _renderCustomEventArea: function(customEventContainer) {
        var bound = this.boundsMaker.getBound('customEvent');
        renderUtil.renderDimension(customEventContainer, bound.dimension);
        renderUtil.renderPosition(customEventContainer, bound.position);
    },

    /**
     * Initialize data of custom event
     * @override
     */
    initCustomEventData: function() {},

    /**
     * On click.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onClick: function(e) {
        this._onMouseEvent('click', e);
    },

    /**
     * On mouse move.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onMousemove: function(e) {
        this._onMouseEvent('move', e);
    },

    /**
     * On mouse out.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onMouseout: function(e) {
        this._onMouseEvent('move', e);
    }
});

tui.util.CustomEvents.mixin(SimpleCustomEvent);

module.exports = SimpleCustomEvent;

},{"../helpers/renderUtil":63,"./customEventBase":36}],40:[function(require,module,exports){
/**
 * @fileoverview TickBaseDataModel is tick base data model.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var predicate = require('../helpers/predicate');

var TickBaseDataModel = tui.util.defineClass(/** @lends TickBaseDataModel.prototype */ {
    /**
     * TickBaseDataModel is tick base data model.
     * @param {{width: number, height: number}} dimension dimension
     * @param {number} tickCount tick count
     * @param {string} chartType chart type
     * @param {boolean} isVertical whether vertical or not
     * @param {Array.<string>} [chartTypes] - chart types of combo chart
     * @constructs TickBaseDataModel
     */
    init: function(dimension, tickCount, chartType, isVertical, chartTypes) {
        /**
         * whether line type or not
         * @type {boolean}
         */
        this.isLineType = predicate.isLineTypeChart(chartType, chartTypes);

        this.data = this._makeData(dimension, tickCount, isVertical);
    },

    /**
     * Make tick base data about line type chart.
     * @param {number} width width
     * @param {number} tickCount tick count
     * @returns {Array} tick base data
     * @private
     */
    _makeLineTypeData: function(width, tickCount) {
        var tickInterval = (width + 1) / (tickCount - 1),
            halfInterval = tickInterval / 2,
            ranges = tui.util.map(tui.util.range(0, tickCount), function(index) {
                return {
                    min: index * tickInterval - halfInterval,
                    max: index * tickInterval + halfInterval
                };
            });
        ranges[tickCount - 1].max -= 1;

        return ranges;
    },

    /**
     * Make tick base data about non line type chart.
     * @param {number} size width or height
     * @param {number} tickCount tick count
     * @returns {Array} tick base data
     * @private
     */
    _makeNormalData: function(size, tickCount) {
        var len = tickCount - 1;
        var tickInterval = size / len;
        var prev = 0;

        return tui.util.map(tui.util.range(0, len), function(index) {
            var max = tui.util.min([size, (index + 1) * tickInterval]);
            var limit = {
                min: prev,
                max: max
            };
            prev = max;

            return limit;
        });
    },

    /**
     * Make tick base data for custom event.
     * @param {{width: number, height: number}} dimension dimension
     * @param {number} tickCount tick count
     * @param {boolean} isVertical whether vertical or not
     * @returns {Array.<object>} tick base data
     * @private
     */
    _makeData: function(dimension, tickCount, isVertical) {
        var sizeType = isVertical ? 'width' : 'height';
        var data;

        if (this.isLineType) {
            data = this._makeLineTypeData(dimension[sizeType], tickCount);
        } else {
            data = this._makeNormalData(dimension[sizeType], tickCount);
        }

        return data;
    },

    /**
     * Find index.
     * @param {number} pointValue mouse position point value
     * @returns {number} group index
     */
    findIndex: function(pointValue) {
        var foundIndex = -1;

        tui.util.forEachArray(this.data, function(limit, index) {
            if (limit.min < pointValue && limit.max >= pointValue) {
                foundIndex = index;

                return false;
            }

            return true;
        });

        return foundIndex;
    },

    /**
     * Get last index.
     * @returns {number}
     */
    getLastIndex: function() {
        return this.data.length - 1;
    },

    /**
     * Make range of tooltip position.
     * @param {number} index index
     * @param {string} chartType chart type
     * @returns {{start: number, end: number}} range type value
     * @private
     */
    makeRange: function(index) {
        var limit = this.data[index],
            range, center;
        if (this.isLineType) {
            center = parseInt(limit.max - (limit.max - limit.min) / 2, 10);
            range = {
                start: center,
                end: center
            };
        } else {
            range = {
                start: limit.min,
                end: limit.max
            };
        }

        return range;
    }
});

module.exports = TickBaseDataModel;

},{"../helpers/predicate":61}],41:[function(require,module,exports){
/**
 * @fileoverview  Mixer for zoom event of area type custom event.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase');
var chartConst = require('../const');
var dom = require('../helpers/domHandler');
var renderUtil = require('../helpers/renderUtil');
var eventListener = require('../helpers/eventListener');

/**
 * Mixer for zoom event of area type custom event.
 * @mixin
 */
var zoomMixer = {
    /**
     * Initialize for zoom.
     * @param {boolean} zoomable - whether zoomable or not
     * @private
     */
    _initForZoom: function(zoomable) {
        /**
         * whether zoomable or not
         * @type {boolean}
         */
        this.zoomable = zoomable;

        /**
         * drag start index.
         * @type {null | object}
         */
        this.dragStartIndexes = null;

        /**
         * start client position(clientX, clientY) of mouse event.
         * @type {null | {x: number, y: number}}
         */
        this.startClientPosition = null;

        /**
         * start layerX position
         * @type {null | number}
         */
        this.startLayerX = null;

        /**
         * drag selection element
         * @type {null | HTMLElement}
         */
        this.dragSelectionElement = null;

        /**
         * container bound
         * @type {null | {left: number, right: number, top: number}}
         */
        this.containerBound = null;

        /**
         * whether show tooltip after zoom or not.
         * @type {boolean}
         */
        this.isShowTooltipAfterZoom = false;

        /**
         * whether after mouseup or not.
         * @type {boolean}
         */
        this.afterMouseup = false;

        /**
         * previouse distance of range
         * @type {null | number}
         */
        this.prevDistanceOfRange = null;

        /**
         * whether reverse move or not.
         * @type {null | number}
         */
        this.reverseMove = null;

        /**
         * reset zoom button element.
         * @type {null | HTMLElement}
         */
        this.resetZoomBtn = null;
    },

    /**
     * Show tooltip after zoom.
     * @private
     */
    _showTooltipAfterZoom: function() {
        var isShowTooltipAfterZoom = this.isShowTooltipAfterZoom;
        var lastDataBeforeZoom;

        this.isShowTooltipAfterZoom = false;

        if (!isShowTooltipAfterZoom || !this.dragStartIndexes) {
            return;
        }

        if (this.reverseMove) {
            lastDataBeforeZoom = this._getFirstData(this.dragStartIndexes.index);
        } else {
            lastDataBeforeZoom = this._getLastData(this.dragEndIndexes.index);
        }

        this._showTooltip(lastDataBeforeZoom);
    },

    /**
     * Update dimension for drag selection element.
     * @param {HTMLElement} selectionElement - drag selection element
     * @private
     */
    _updateDimensionForDragSelection: function(selectionElement) {
        renderUtil.renderDimension(selectionElement, {
            height: this.boundsMaker.getDimension('customEvent').height
        });
    },

    /**
     * Render drag selection.
     * @returns {HTMLElement}
     * @private
     */
    _renderDragSelection: function() {
        var selectionElement = dom.create('DIV', 'tui-chart-drag-selection');

        this._updateDimensionForDragSelection(selectionElement);

        return selectionElement;
    },

    /**
     * Render.
     * @param {object} data - data for rendering
     * @returns {HTMLElement}
     * @override
     */
    render: function(data) {
        var container = CustomEventBase.prototype.render.call(this, data);
        var selectionElement = this._renderDragSelection();

        dom.append(container, selectionElement);
        this.dragSelectionElement = selectionElement;

        return container;
    },

    /**
     * Calculate layer position by client position.
     * @param {number} clientX - clientX
     * @param {number} [clientY] - clientY
     * @param {boolean} [checkLimit] - whether check limit or not
     * @returns {{x: number, y: ?number}}
     * @private
     */
    _calculateLayerPosition: function(clientX, clientY, checkLimit) {
        var bound = this._getContainerBound();
        var layerPosition = {};
        var expandSize = this.expandSize;
        var maxLeft, minLeft;

        checkLimit = tui.util.isUndefined(checkLimit) ? true : checkLimit;

        if (checkLimit) {
            maxLeft = bound.right - expandSize;
            minLeft = bound.left + expandSize;
            clientX = Math.min(Math.max(clientX, minLeft), maxLeft);
        }

        layerPosition.x = clientX - bound.left;

        if (!tui.util.isUndefined(clientY)) {
            layerPosition.y = clientY - bound.top;
        }

        return layerPosition;
    },

    /**
     * Resize.
     * @param {{tickCount: number}} data - data for resizing
     * @override
     */
    resize: function(data) {
        this.containerBound = null;
        CustomEventBase.prototype.resize.call(this, data);
        this._updateDimensionForDragSelection(this.dragSelectionElement);
    },

    /**
     * On click
     * @private
     * @override
     */
    _onClick: function() {},

    /**
     * Whether after drag mouseup or not.
     * @returns {boolean}
     * @private
     */
    _isAfterDragMouseup: function() {
        var afterMouseup = this.afterMouseup;

        if (afterMouseup) {
            this.afterMouseup = false;
        }

        return afterMouseup;
    },

    /**
     * Bind drag event for zoom.
     * @param {HTMLElement} target - target element
     * @private
     */
    _bindDragEvent: function(target) {
        if (target.setCapture) {
            target.setCapture();
        }

        eventListener.on(document, 'mousemove', this._onDrag, this);
        eventListener.off(this.customEventContainer, 'mouseup', this._onMouseup, this);
        eventListener.on(document, 'mouseup', this._onMouseupAfterDrag, this);
    },

    /**
     * Unbind drag event for zoom.
     * @private
     */
    _unbindDragEvent: function() {
        if (this.downTarget && this.downTarget.releaseCapture) {
            this.downTarget.releaseCapture();
        }

        eventListener.off(document, 'mousemove', this._onDrag, this);
        eventListener.off(document, 'mouseup', this._onMouseupAfterDrag, this);
        eventListener.on(this.customEventContainer, 'mouseup', this._onMouseup, this);
    },

    /**
     * On mouse down.
     * @param {MouseEvent} e - mouse event
     * @private
     * @override
     */
    _onMousedown: function(e) {
        var target;

        if (!this.zoomable) {
            return;
        }

        target = e.target || e.srcElement;

        this.startClientPosition = {
            x: e.clientX,
            y: e.clientY
        };
        this.startLayerX = this._calculateLayerPosition(e.clientX).x;
        this.downTarget = target;

        this._bindDragEvent(target);
    },

    /**
     * Show drag selection.
     * @param {number} clientX - clientX
     * @private
     */
    _showDragSelection: function(clientX) {
        var layerX = this._calculateLayerPosition(clientX).x;
        var left = Math.min(layerX, this.startLayerX);
        var width = Math.abs(layerX - this.startLayerX);
        var element = this.dragSelectionElement;

        element.style.left = left + chartConst.SERIES_EXPAND_SIZE + 'px';
        element.style.width = width + 'px';

        dom.addClass(element, 'show');
    },

    /**
     * Hide drag selection.
     * @private
     */
    _hideDragSelection: function() {
        dom.removeClass(this.dragSelectionElement, 'show');
    },

    /**
     * On mouse drag.
     * @param {MouseEvent} e - mouse event
     * @private
     */
    _onDrag: function(e) {
        var clientPos = this.startClientPosition;

        if (tui.util.isNull(this.dragStartIndexes)) {
            this.dragStartIndexes = this._findData(clientPos.x, clientPos.y).indexes;
        } else {
            this._showDragSelection(e.clientX);
        }
    },

    /**
     * Adjust index range for ensure three indexes.
     * @param {number} startIndex - start index
     * @param {number} endIndex - end index
     * @returns {Array.<number>}
     * @private
     */
    _adjustIndexRange: function(startIndex, endIndex) {
        var indexRange = [startIndex, endIndex].sort(function(a, b) {
            return a - b;
        });
        var distanceOfRange = indexRange[1] - indexRange[0];

        if (distanceOfRange === 0) {
            if (indexRange[0] === 0) {
                indexRange[1] += 2;
            } else {
                indexRange[0] -= 1;
                indexRange[1] += 1;
            }
        } else if (distanceOfRange === 1) {
            if (indexRange[0] === 0) {
                indexRange[1] += 1;
            } else {
                indexRange[0] -= 1;
            }
        }

        return indexRange;
    },

    /**
     * Fire zoom custom event.
     * @param {number} startIndex - start index
     * @param {number} endIndex - end index
     * @private
     */
    _fireZoom: function(startIndex, endIndex) {
        var reverseMove = startIndex > endIndex;
        var indexRange = this._adjustIndexRange(startIndex, endIndex);
        var distanceOfRange = indexRange[1] - indexRange[0];

        if (this.prevDistanceOfRange === distanceOfRange) {
            return;
        }

        this.prevDistanceOfRange = distanceOfRange;
        this.reverseMove = reverseMove;
        this.fire('zoom', indexRange);
    },

    /**
     * Set flag about whether show tooltip after zoom or not.
     * @param {number} clientX - clientX of mouse event
     * @param {number} clientY - clientY of mouse event
     * @private
     */
    _setIsShowTooltipAfterZoomFlag: function(clientX, clientY) {
        var layerX = this._calculateLayerPosition(clientX, clientY, false).x;
        var limitLayerX = this._calculateLayerPosition(clientX, clientY).x;

        this.isShowTooltipAfterZoom = (layerX === limitLayerX);
    },

    /**
     * On mouseup after drag event.
     * @param {MouseEvent} e - mouse event
     * @private
     */
    _onMouseupAfterDrag: function(e) {
        var target;

        this._unbindDragEvent();

        if (tui.util.isNull(this.dragStartIndexes)) {
            target = e.target || e.srcElement;
            if (dom.hasClass(target, chartConst.CLASS_NAME_RESET_ZOOM_BTN)) {
                this._hideTooltip();
                this.prevDistanceOfRange = null;
                this.fire('resetZoom');
            } else {
                CustomEventBase.prototype._onClick.call(this, e);
            }
        } else {
            this.dragEndIndexes = this._findData(e.clientX, e.clientY).indexes;
            this._setIsShowTooltipAfterZoomFlag(e.clientX, e.clientY);
            this._hideDragSelection();
            this._fireZoom(this.dragStartIndexes.groupIndex, this.dragEndIndexes.groupIndex);
        }

        this.startClientPosition = null;
        this.dragStartIndexes = null;
        this.startLayerX = null;
        this.afterMouseup = true;
    },

    /**
     * Render reset zoom button element.
     * @returns {HTMLElement}
     * @private
     */
    _renderResetZoomBtn: function() {
        var resetBtn = dom.create('DIV', chartConst.CLASS_NAME_RESET_ZOOM_BTN);
        resetBtn.innerHTML = 'Reset Zoom';

        return resetBtn;
    },

    /**
     * Zoom.
     * @param {object} data - data for rendering
     */
    zoom: function(data) {
        this.prevFoundData = null;
        this.rerender(data);
        this._updateDimensionForDragSelection(this.dragSelectionElement);

        if (!this.resetZoomBtn) {
            this.resetZoomBtn = this._renderResetZoomBtn();
            dom.append(this.customEventContainer, this.resetZoomBtn);
        } else if (data.isResetZoom) {
            this.customEventContainer.removeChild(this.resetZoomBtn);
            this.resetZoomBtn = null;
        }
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = zoomMixer;

},{"../const":31,"../helpers/domHandler":59,"../helpers/eventListener":60,"../helpers/renderUtil":63,"./customEventBase":36}],42:[function(require,module,exports){
/**
 * @fileoverview DataProcessor process rawData.
 * rawData.categories --> categories
 * rawData.series --> SeriesDataModel, legendLabels, legendData
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');
var SeriesDataModel = require('../dataModels/seriesDataModel');
var SeriesDataModelForTreemap = require('../dataModels/seriesDataModelForTreemap');
var SeriesGroup = require('./seriesGroup');
var rawDataHandler = require('../helpers/rawDataHandler');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');

var concat = Array.prototype.concat;

/**
 * Raw series datum.
 * @typedef {{name: ?string, data: Array.<number>, stack: ?string}} rawSeriesDatum
 */

/**
 * Raw series data.
 * @typedef {Array.<rawSeriesDatum>} rawSeriesData
 */

/**
 * Raw data by user.
 * @typedef {{
 *      categories: ?Array.<string>,
 *      series: (rawSeriesData|{line: ?rawSeriesData, column: ?rawSeriesData})
 * }} rawData
 */

/**
 * SeriesDataModel is base model for drawing graph of chart series area,
 *      and create from rawSeriesData by user,
 * SeriesDataModel.groups has SeriesGroups.
 */

/**
 * SeriesGroup is a element of SeriesDataModel.groups.
 * SeriesGroup.items has SeriesItem.
 */

var DataProcessor = tui.util.defineClass(/** @lends DataProcessor.prototype */{
    /**
     * Data processor.
     * @constructs DataProcessor
     * @param {rawData} rawData raw data
     * @param {string} chartType chart type
     * @param {object} options options
     * @param {Array.<string>} seriesNames chart types
     */
    init: function(rawData, chartType, options, seriesNames) {
        var seriesOption = options.series || {};

        /**
         * original raw data.
         * @type {{categories: ?Array.<string>, series: Array.<object>}}
         */
        this.originalRawData = JSON.parse(JSON.stringify(rawData));

        /**
         * chart type
         * @type {string}
         */
        this.chartType = chartType;

        /**
         * chart options
         * @type {Object}
         */
        this.options = options;

        /**
         * seriesNames is sorted chart types for rendering series area of combo chart.
         * @type {Array.<string>}
         */
        this.seriesNames = seriesNames;

        /**
         * diverging option
         * @type {boolean}
         */
        this.divergingOption = predicate.isBarTypeChart(options.chartType) && seriesOption.diverging;

        /**
         * legend data for rendering legend of group tooltip
         * @type {Array.<{chartType: string, label: string}>}
         */
        this.originalLegendData = null;

        /**
         * dynamic data array for adding data.
         * @type {Array.<{category: string | number, values: Array.<number>}>}
         */
        this.dynamicData = [];

        this.initData(rawData);
        this.initZoomedRawData();
    },

    /**
     * Get original raw data.
     * @returns {rawData} raw data
     */
    getOriginalRawData: function() {
        return JSON.parse(JSON.stringify(this.originalRawData));
    },

    /**
     * Get zoomed raw data.
     * @returns {*|null}
     */
    getZoomedRawData: function() {
        var zoomedRawData = this.zoomedRawData;
        if (zoomedRawData) {
            zoomedRawData = JSON.parse(JSON.stringify(zoomedRawData));
        } else {
            zoomedRawData = this.getOriginalRawData();
        }

        return zoomedRawData;
    },

    /**
     * Filter seriesData by index range.
     * @param {Array.<{data: Array}>} seriesData - series data
     * @param {number} startIndex - start index
     * @param {number} endIndex - end index
     * @returns {Array.<Array.<object>>}
     * @private
     */
    _filterSeriesDataByIndexRange: function(seriesData, startIndex, endIndex) {
        tui.util.forEachArray(seriesData, function(seriesDatum) {
            seriesDatum.data = seriesDatum.data.slice(startIndex, endIndex + 1);
        });

        return seriesData;
    },

    /**
     * Filter raw data by index range.
     * @param {{series: Array.<object>, categories: Array.<string>}} rawData - raw data
     * @param {Array.<number>} indexRange - index range for zoom
     * @returns {*}
     * @private
     */
    _filterRawDataByIndexRange: function(rawData, indexRange) {
        var self = this;
        var startIndex = indexRange[0];
        var endIndex = indexRange[1];

        if (tui.util.isArray(rawData.series)) {
            rawData.series = this._filterSeriesDataByIndexRange(rawData.series, startIndex, endIndex);
        } else {
            tui.util.forEach(rawData.series, function(seriesDataSet, seriesName) {
                rawData.series[seriesName] = self._filterSeriesDataByIndexRange(seriesDataSet, startIndex, endIndex);
            });
        }

        rawData.categories = rawData.categories.slice(startIndex, endIndex + 1);

        return rawData;
    },

    /**
     * Update raw data for zoom
     * @param {Array.<number>} indexRange - index range for zoom
     */
    updateRawDataForZoom: function(indexRange) {
        var rawData = this.getRawData();
        var zoomedRawData = this.getZoomedRawData();

        this.zoomedRawData = this._filterRawDataByIndexRange(zoomedRawData, indexRange);
        rawData = this._filterRawDataByIndexRange(rawData, indexRange);
        this.initData(rawData);
    },

    /**
     * Init zoomed raw data.
     */
    initZoomedRawData: function() {
        this.zoomedRawData = null;
    },

    /**
     * Initialize data.
     * @param {rawData} rawData raw data
     */
    initData: function(rawData) {
        /**
         * raw data
         * @type {rawData}
         */
        this.rawData = rawData;

        /**
         * categories
         * @type {Array.<string>}
         */
        this.categoriesMap = null;

        /**
         * stacks
         * @type {Array.<number>}
         */
        this.stacks = null;

        /**
         * seriesDataModel map
         * @type {object.<string, SeriesDataModel>}
         */
        this.seriesDataModelMap = {};

        /**
         * SeriesGroups
         * @type {Array.<SeriesGroup>}
         */
        this.seriesGroups = null;

        /**
         * map of values of SeriesItems
         * @type {Object.<string, Array.<number>>}
         */
        this.valuesMap = {};

        /**
         * legend labels for rendering legend area
         * @type {{column: Array.<string>, line: Array.<string> | Array.<string>}}
         */
        this.legendLabels = null;

        /**
         * legend data for rendering legend
         * @type {Array.<{chartType: string, label: string}>}
         */
        this.legendData = null;

        /**
         * functions for formatting
         * @type {Array.<function>}
         */
        this.formatFunctions = null;

        /**
         * multiline categories
         * @type {Array.<string>}
         */
        this.multilineCategories = null;
    },

    /**
     * Get raw data.
     * @returns {rawData}
     */
    getRawData: function() {
        return this.rawData;
    },

    /**
     * Find chart type from series name.
     * @param {string} seriesName - series name
     * @returns {*}
     */
    findChartType: function(seriesName) {
        return rawDataHandler.findChartType(this.rawData.seriesAlias, seriesName);
    },

    /**
     * Escape categories
     * @param {Array.<string, number>} categories - cetegories
     * @returns {*|Array.<Object>|Array}
     * @private
     */
    _escapeCategories: function(categories) {
        return tui.util.map(categories, function(category) {
            return tui.util.encodeHTMLEntity(String(category));
        });
    },

    /**
     * Process categories
     * @param {string} type - category type (x or y)
     * @returns {null | Array.<string>} processed categories
     * @private
     */
    _processCategories: function(type) {
        var rawCategories = this.rawData.categories;
        var categoriesMap = {};

        if (tui.util.isArray(rawCategories)) {
            categoriesMap[type] = this._escapeCategories(rawCategories);
        } else if (rawCategories) {
            if (rawCategories.x) {
                categoriesMap.x = this._escapeCategories(rawCategories.x);
            }

            if (rawCategories.y) {
                categoriesMap.y = this._escapeCategories(rawCategories.y).reverse();
            }
        }

        return categoriesMap;
    },

    /**
     * Get Categories
     * @param {boolean} isVertical - whether vertical or not
     * @returns {Array.<string>}}
     */
    getCategories: function(isVertical) {
        var type = isVertical ? 'y' : 'x';
        var foundCategories = [];

        if (!this.categoriesMap) {
            this.categoriesMap = this._processCategories(type);
        }

        if (tui.util.isExisty(isVertical)) {
            foundCategories = this.categoriesMap[type] || [];
        } else {
            tui.util.forEach(this.categoriesMap, function(categories) {
                foundCategories = categories;

                return false;
            });
        }

        return foundCategories;
    },

    /**
     * Get category count.
     * @param {boolean} isVertical - whether vertical or not
     * @returns {*}
     */
    getCategoryCount: function(isVertical) {
        var categories = this.getCategories(isVertical);

        return categories ? categories.length : 0;
    },

    /**
     * Whether has categories or not.
     * @param {boolean} isVertical - whether vertical or not
     * @returns {boolean}
     */
    hasCategories: function(isVertical) {
        return !!this.getCategoryCount(isVertical);
    },

    /**
     * Get category.
     * @param {number} index index
     * @param {boolean} isVertical - whether vertical or not
     * @returns {string} category
     */
    getCategory: function(index, isVertical) {
        return this.getCategories(isVertical)[index];
    },

    /**
     * Get category for tooltip.
     * @param {number} firstIndex - index
     * @param {number} oppositeIndex - opposite index
     * @param {boolean} isVerticalChart - whether vertical chart or not
     * @returns {string}
     */
    getTooltipCategory: function(firstIndex, oppositeIndex, isVerticalChart) {
        var isHorizontal = !isVerticalChart;
        var category = this.getCategory(firstIndex, isHorizontal);
        var categoryCount = this.getCategoryCount(!isHorizontal);

        if (categoryCount) {
            category += ', ' + this.getCategory(categoryCount - oppositeIndex - 1, isVerticalChart);
        }

        return category;
    },

    /**
     * Get stacks.
     * @returns {Array.<string>}
     */
    getStacks: function() {
        if (!this.stacks) {
            this.stacks = rawDataHandler.pickStacks(this.rawData.series);
        }

        return this.stacks;
    },

    /**
     * Get stack count.
     * @returns {Number}
     */
    getStackCount: function() {
        return this.getStacks().length;
    },

    /**
     * Find stack index.
     * @param {string} stack stack
     * @returns {number}
     */
    findStackIndex: function(stack) {
        return tui.util.inArray(stack, this.getStacks());
    },

    /**
     * Get SeriesDataModel.
     * @param {string} seriesName - series name
     * @returns {SeriesDataModel}
     */
    getSeriesDataModel: function(seriesName) {
        var rawSeriesData, chartType, SeriesDataModelClass;

        if (!this.seriesDataModelMap[seriesName]) {
            chartType = this.findChartType(seriesName);
            rawSeriesData = this.rawData.series[seriesName] || this.rawData.series;

            if (predicate.isTreemapChart(this.chartType)) {
                SeriesDataModelClass = SeriesDataModelForTreemap;
            } else {
                SeriesDataModelClass = SeriesDataModel;
            }

            this.seriesDataModelMap[seriesName] = new SeriesDataModelClass(rawSeriesData, chartType,
                this.options, this.getFormatFunctions());
        }

        return this.seriesDataModelMap[seriesName];
    },

    /**
     * Get group count.
     * @param {string} chartType chart type
     * @returns {number}
     */
    getGroupCount: function(chartType) {
        return this.getSeriesDataModel(chartType).getGroupCount();
    },

    /**
     * Push category.
     * @param {string} category - category
     * @private
     */
    _pushCategory: function(category) {
        this.rawData.categories.push(category);
        this.originalRawData.categories.push(category);
    },

    /**
     * Shift category.
     * @private
     */
    _shiftCategory: function() {
        this.rawData.categories.shift();
        this.originalRawData.categories.shift();
    },

    /**
     * Find raw series datum by name.
     * @param {string} name - legend name
     * @param {string} [seriesName] - series name
     * @returns {object}
     * @private
     */
    _findRawSeriesDatumByName: function(name, seriesName) {
        var foundSeriesDatum = null;
        var seriesData = seriesName ? this.rawData.series[seriesName] : this.rawData.series;

        tui.util.forEachArray(seriesData, function(seriesDatum) {
            var isEqual = seriesDatum.name === name;

            if (isEqual) {
                foundSeriesDatum = seriesDatum;
            }

            return !isEqual;
        });

        return foundSeriesDatum;
    },

    /**
     * Push values to series of originalRawData and series of rawData.
     * @param {Array.<{name: string, data: Array}>} seriesData - series data
     * @param {Array} values - values
     * @param {string} [seriesName] - series name
     * @private
     */
    _pushValues: function(seriesData, values, seriesName) {
        var self = this;

        tui.util.forEachArray(seriesData, function(seriesDatum, index) {
            var value = values[index];
            var rawSeriesDatum = self._findRawSeriesDatumByName(seriesDatum.name, seriesName);

            seriesDatum.data.push(value);
            if (rawSeriesDatum) {
                rawSeriesDatum.data.push(value);
            }
        });
    },

    /**
     * Push series data.
     * @param {Array.<number>} values - values
     * @private
     */
    _pushSeriesData: function(values) {
        var self = this;

        if (tui.util.isArray(this.originalRawData.series)) {
            this._pushValues(this.originalRawData.series, values);
        } else {
            tui.util.forEach(this.originalRawData.series, function(seriesData, seriesName) {
                self._pushValues(seriesData, values[seriesName], seriesName);
            });
        }
    },

    /**
     * Shift values.
     * @param {Array.<{name: string, data: Array}>} seriesData - series data
     * @param {string} seriesName - series name
     * @private
     */
    _shiftValues: function(seriesData, seriesName) {
        var self = this;

        tui.util.forEachArray(seriesData, function(seriesDatum) {
            var rawSeriesDatum = self._findRawSeriesDatumByName(seriesDatum.name, seriesName);

            seriesDatum.data.shift();
            if (rawSeriesDatum) {
                rawSeriesDatum.data.shift();
            }
        });
    },

    /**
     * Shift series data.
     * @private
     */
    _shiftSeriesData: function() {
        var self = this;

        if (tui.util.isArray(this.originalRawData.series)) {
            this._shiftValues(this.originalRawData.series);
        } else {
            tui.util.forEach(this.originalRawData.series, function(seriesData, seriesName) {
                self._shiftValues(seriesData, seriesName);
            });
        }
    },

    /**
     * Add dynamic data.
     * @param {string} category - category
     * @param {Array.<number>} values - values
     */
    addDynamicData: function(category, values) {
        this.dynamicData.push({
            category: category,
            values: values
        });
    },

    /**
     * Add data from dynapmic data.
     * @returns {boolean}
     */
    addDataFromDynamicData: function() {
        var datum = this.dynamicData.shift();

        if (!datum) {
            return false;
        }

        this._pushCategory(datum.category);
        this._pushSeriesData(datum.values);

        this.initData(this.rawData);

        return true;
    },

    /**
     * Shift data.
     */
    shiftData: function() {
        this._shiftCategory();
        this._shiftSeriesData();

        this.initData(this.rawData);
    },

    /**
     * Add data from remain dynamic data.
     * @param {boolean} shiftingOption - whether has shifting option or not.
     */
    addDataFromRemainDynamicData: function(shiftingOption) {
        var self = this;
        var dynamicData = this.dynamicData;

        this.dynamicData = [];

        tui.util.forEach(dynamicData, function(datum) {
            self._pushCategory(datum.category);
            self._pushSeriesData(datum.values);
            if (shiftingOption) {
                self._shiftCategory();
                self._shiftSeriesData();
            }
        });

        this.initData(this.rawData);
    },

    /**
     * Traverse all SeriesDataModel by seriesNames, and executes iteratee function.
     * @param {function} iteratee iteratee function
     * @private
     */
    _eachByAllSeriesDataModel: function(iteratee) {
        var self = this,
            seriesNames = this.seriesNames || [this.chartType];

        tui.util.forEachArray(seriesNames, function(chartType) {
            return iteratee(self.getSeriesDataModel(chartType), chartType);
        });
    },

    /**
     * Whether valid all SeriesDataModel or not.
     * @returns {boolean}
     */
    isValidAllSeriesDataModel: function() {
        var isValid = true;

        this._eachByAllSeriesDataModel(function(seriesDataModel) {
            isValid = !!seriesDataModel.getGroupCount();

            return isValid;
        });

        return isValid;
    },

    /**
     * Make SeriesGroups.
     * @returns {Array.<SeriesGroup>}
     * @private
     */
    _makeSeriesGroups: function() {
        var joinedGroups = [],
            seriesGroups;

        this._eachByAllSeriesDataModel(function(seriesDataModel) {
            seriesDataModel.each(function(seriesGroup, index) {
                if (!joinedGroups[index]) {
                    joinedGroups[index] = [];
                }
                joinedGroups[index] = joinedGroups[index].concat(seriesGroup.items);
            });
        });

        seriesGroups = tui.util.map(joinedGroups, function(items) {
            return new SeriesGroup(items);
        });

        return seriesGroups;
    },

    /**
     * Get SeriesGroups.
     * @returns {Array.<SeriesGroup>}
     */
    getSeriesGroups: function() {
        if (!this.seriesGroups) {
            this.seriesGroups = this._makeSeriesGroups();
        }

        return this.seriesGroups;
    },

    /**
     * Get value.
     * @param {number} groupIndex group index
     * @param {number} index index
     * @param {?string} chartType chart type
     * @returns {number} value
     */
    getValue: function(groupIndex, index, chartType) {
        return this.getSeriesDataModel(chartType).getValue(groupIndex, index);
    },

    /**
     * Create values that picked value from SeriesItems of specific SeriesDataModel.
     * @param {?string} chartType - type of chart
     * @param {?string} valueType - type of value like value, x, y, r.
     * @returns {Array.<number>}
     * @private
     */
    _createValues: function(chartType, valueType) {
        var values;

        if (chartType === chartConst.DUMMY_KEY) {
            values = [];
            this._eachByAllSeriesDataModel(function(seriesDataModel) {
                values = values.concat(seriesDataModel.getValues(valueType));
            });
        } else {
            values = this.getSeriesDataModel(chartType).getValues(valueType);
        }

        return values;
    },

    /**
     * Get values from valuesMap.
     * @param {?string} chartType - type of chart
     * @param {?string} valueType - type of value like value, x, y, r.
     * @returns {Array.<number>}
     */
    getValues: function(chartType, valueType) {
        var mapKey;

        chartType = chartType || chartConst.DUMMY_KEY;

        mapKey = chartType + valueType;

        if (!this.valuesMap[mapKey]) {
            this.valuesMap[mapKey] = this._createValues(chartType, valueType);
        }

        return this.valuesMap[mapKey];
    },

    /**
     * Get max value.
     * @param {?string} chartType - type of chart
     * @param {?string} valueType - type of value like value, x, y, r
     * @returns {number}
     */
    getMaxValue: function(chartType, valueType) {
        return tui.util.max(this.getValues(chartType, valueType));
    },

    /**
     * Get formatted max value.
     * @param {?string} chartType - type of chart
     * @param {?string} areaType - type of area like circleLegend
     * @param {?string} valueType - type of value like value, x, y, r
     * @returns {string | number}
     */
    getFormattedMaxValue: function(chartType, areaType, valueType) {
        var maxValue = this.getMaxValue(chartType, valueType);
        var formatFunctions = this.getFormatFunctions();

        return renderUtil.formatValue(maxValue, formatFunctions, chartType, areaType, valueType);
    },

    /**
     * Traverse SeriesGroup of all SeriesDataModel, and executes iteratee function.
     * @param {function} iteratee iteratee function
     * @param {boolean} [isPivot] - whether pivot or not
     */
    eachBySeriesGroup: function(iteratee, isPivot) {
        this._eachByAllSeriesDataModel(function(seriesDataModel, chartType) {
            seriesDataModel.each(function(seriesGroup, groupIndex) {
                iteratee(seriesGroup, groupIndex, chartType);
            }, isPivot);
        });
    },

    /**
     * Pick legend label.
     * @param {object} item item
     * @returns {string} label
     * @private
     */
    _pickLegendLabel: function(item) {
        return item.name ? tui.util.encodeHTMLEntity(item.name) : null;
    },

    /**
     * Pick legend labels from raw data.
     * @returns {string[]} labels
     */
    _pickLegendLabels: function() {
        var self = this;
        var seriesData = this.rawData.series;
        var legendLabels;

        if (tui.util.isArray(seriesData)) {
            legendLabels = tui.util.map(seriesData, this._pickLegendLabel);
        } else {
            legendLabels = {};
            tui.util.forEach(seriesData, function(seriesDatum, type) {
                legendLabels[type] = tui.util.map(seriesDatum, self._pickLegendLabel);
            });
        }

        legendLabels = tui.util.filter(legendLabels, function(label) {
            return tui.util.isExisty(label);
        });

        return legendLabels;
    },

    /**
     * Get legend labels.
     * @param {?string} chartType chart type
     * @returns {Array.<string> | {column: ?Array.<string>, line: ?Array.<string>}} legend labels
     */
    getLegendLabels: function(chartType) {
        if (!this.legendLabels) {
            this.legendLabels = this._pickLegendLabels();
        }

        return this.legendLabels[chartType] || this.legendLabels;
    },

    /**
     * Make legend data.
     * @returns {Array} labels
     * @private
     */
    _makeLegendData: function() {
        var legendLabels = this.getLegendLabels(),
            seriesNames = this.seriesNames || [this.chartType],
            legendLabelsMap, legendData;

        if (tui.util.isArray(legendLabels)) {
            legendLabelsMap = [this.chartType];
            legendLabelsMap[this.chartType] = legendLabels;
        } else {
            seriesNames = this.seriesNames;
            legendLabelsMap = legendLabels;
        }

        legendData = tui.util.map(seriesNames, function(chartType) {
            return tui.util.map(legendLabelsMap[chartType], function(label) {
                return {
                    chartType: chartType,
                    label: label
                };
            });
        });

        return concat.apply([], legendData);
    },

    /**
     * Get legend data.
     * @returns {Array.<{chartType: string, label: string}>} legend data
     */
    getLegendData: function() {
        if (!this.legendData) {
            this.legendData = this._makeLegendData();
        }

        if (!this.originalLegendData) {
            this.originalLegendData = this.legendData;
        }

        return this.legendData;
    },

    /**
     * get original legend data.
     * @returns {Array.<{chartType: string, label: string}>}
     */
    getOriginalLegendData: function() {
        return this.originalLegendData;
    },

    /**
     * Get legend item.
     * @param {number} index index
     * @returns {{chartType: string, label: string}} legend data
     */
    getLegendItem: function(index) {
        return this.getLegendData()[index];
    },

    /**
     * Get format functions.
     * @returns {Array.<function>} functions
     */
    getFormatFunctions: function() {
        if (!this.formatFunctions) {
            this.formatFunctions = this._findFormatFunctions();
        }

        return this.formatFunctions;
    },

    /**
     * Get first label of SeriesItem.
     * @param {?string} chartType chartType
     * @returns {string} formatted value
     */
    getFirstItemLabel: function(chartType) {
        return this.getSeriesDataModel(chartType).getFirstItemLabel();
    },

    /**
     * Pick max length under point.
     * @param {string[]} values chart values
     * @returns {number} max length under point
     * @private
     */
    _pickMaxLenUnderPoint: function(values) {
        var max = 0;

        tui.util.forEachArray(values, function(value) {
            var len = tui.util.getDecimalLength(value);
            if (len > max) {
                max = len;
            }
        });

        return max;
    },

    /**
     * Whether zero fill format or not.
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isZeroFill: function(format) {
        return format.length > 2 && format.charAt(0) === '0';
    },

    /**
     * Whether decimal format or not.
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isDecimal: function(format) {
        var indexOf = format.indexOf('.');

        return indexOf > -1 && indexOf < format.length - 1;
    },

    /**
     * Whether comma format or not.
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isComma: function(format) {
        return format.indexOf(',') > -1;
    },

    /**
     * Format to zero fill.
     * @param {number} len length of result
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    _formatToZeroFill: function(len, value) {
        var isMinus = value < 0;

        value = renderUtil.formatToZeroFill(Math.abs(value), len);

        return (isMinus ? '-' : '') + value;
    },

    /**
     * Format to Decimal.
     * @param {number} len length of under decimal point
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    _formatToDecimal: function(len, value) {
        return renderUtil.formatToDecimal(value, len);
    },

    /**
     * Find simple type format functions.
     * @param {string} format - simple format
     * @returns {Array.<function>}
     */
    _findSimpleTypeFormatFunctions: function(format) {
        var funcs = [];
        var len;

        if (this._isDecimal(format)) {
            len = this._pickMaxLenUnderPoint([format]);
            funcs = [tui.util.bind(this._formatToDecimal, this, len)];
        } else if (this._isZeroFill(format)) {
            len = format.length;
            funcs = [tui.util.bind(this._formatToZeroFill, this, len)];

            return funcs;
        }

        if (this._isComma(format)) {
            funcs.push(renderUtil.formatToComma);
        }

        return funcs;
    },

    /**
     * Find format functions.
     * @returns {function[]} functions
     */
    _findFormatFunctions: function() {
        var format = tui.util.pick(this.options, 'chart', 'format');
        var funcs = [];

        if (tui.util.isFunction(format)) {
            funcs = [format];
        } else if (tui.util.isString(format)) {
            funcs = this._findSimpleTypeFormatFunctions(format);
        }

        return funcs;
    },

    /**
     * Make multiline category.
     * @param {string} category category
     * @param {number} limitWidth limit width
     * @param {object} theme label theme
     * @returns {string} multiline category
     * @private
     */
    _makeMultilineCategory: function(category, limitWidth, theme) {
        var words = String(category).split(/\s+/),
            lineWords = words[0],
            lines = [];

        tui.util.forEachArray(words.slice(1), function(word) {
            var width = renderUtil.getRenderedLabelWidth(lineWords + ' ' + word, theme);

            if (width > limitWidth) {
                lines.push(lineWords);
                lineWords = word;
            } else {
                lineWords += ' ' + word;
            }
        });

        if (lineWords) {
            lines.push(lineWords);
        }

        return lines.join('<br>');
    },

    /**
     * Get multiline categories.
     * @param {number} limitWidth limit width
     * @param {object} theme label theme
     * @param {Array.<(number | string)>} xAxisLabels labels of xAxis
     * @returns {Array} multiline categories
     */
    getMultilineCategories: function(limitWidth, theme, xAxisLabels) {
        var self = this;

        if (!this.multilineCategories) {
            this.multilineCategories = tui.util.map(xAxisLabels, function(category) {
                return self._makeMultilineCategory(category, limitWidth, theme);
            });
        }

        return this.multilineCategories;
    },

    /**
     * Add data ratios of pie chart.
     * @param {string} chartType - type of chart.
     */
    addDataRatiosOfPieChart: function(chartType) {
        this.getSeriesDataModel(chartType).addDataRatiosOfPieChart();
    },

    /**
     * Add data ratios for chart of coordinate type.
     * @param {string} chartType - type of chart.
     * @param {{x: {min: number, max: number}, y: {min: number, max: number}}} limitMap - limit map
     * @param {boolean} [hasRadius] - whether has radius or not
     */
    addDataRatiosForCoordinateType: function(chartType, limitMap, hasRadius) {
        this.getSeriesDataModel(chartType).addDataRatiosForCoordinateType(limitMap, hasRadius);
    },

    /**
     * Add start value to all series item.
     * @param {{min: number, max: number}} limit - limit
     * @param {string} chartType - chart type
     * @private
     */
    _addStartValueToAllSeriesItem: function(limit, chartType) {
        var start = 0;

        if (limit.min >= 0) {
            start = limit.min;
        } else if (limit.max <= 0) {
            start = limit.max;
        }

        this.getSeriesDataModel(chartType).addStartValueToAllSeriesItem(start);
    },

    /**
     * Register percent values.
     * @param {{min: number, max: number}} limit axis limit
     * @param {string} stackType stackType option
     * @param {string} chartType chart type
     * @private
     */
    addDataRatios: function(limit, stackType, chartType) {
        var seriesDataModel = this.getSeriesDataModel(chartType);

        this._addStartValueToAllSeriesItem(limit, chartType);
        seriesDataModel.addDataRatios(limit, stackType);
    },

    /**
     * Add data ratios for treemap chart.
     * @param {{min: number, max: number}} limit - limit
     * @param {string} chartType - chart type
     */
    addDataRatiosForTreemapChart: function(limit, chartType) {
        this.getSeriesDataModel(chartType).addDataRatios(limit);
    }
});

module.exports = DataProcessor;

},{"../const":31,"../dataModels/seriesDataModel":44,"../dataModels/seriesDataModelForTreemap":45,"../helpers/predicate":61,"../helpers/rawDataHandler":62,"../helpers/renderUtil":63,"./seriesGroup":46}],43:[function(require,module,exports){
/**
 * @fileoverview Data processor for map chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var DataProcessor = require('./dataProcessor');
var renderUtil = require('../helpers/renderUtil');

/**
 * Raw series data.
 * @typedef {Array.<{code: string, name: ?string, data: number}>} rawSeriesData
 */

/**
 * Value map.
 * @typedef {{value: number, label: string, name: ?string}} valueMap
 */

var MapChartDataProcessor = tui.util.defineClass(DataProcessor, /** @lends MapChartDataProcessor.prototype */{
    /**
     * Data processor for map chart.
     * @constructs MapChartDataProcessor
     * @extends DataProcessor
     */
    init: function() {
        DataProcessor.apply(this, arguments);
    },

    /**
     * Update raw data.
     * @param {{series: rawSeriesData}} rawData raw data
     */
    initData: function(rawData) {
        this.rawData = rawData;

        /**
         * value map
         * @type {valueMap}
         */
        this.valueMap = null;
    },

    /**
     * Make value map.
     * @returns {valueMap} value map
     * @private
     */
    _makeValueMap: function() {
        var rawSeriesData = this.rawData.series;
        var valueMap = {};
        var formatFunctions = this._findFormatFunctions();

        tui.util.forEachArray(rawSeriesData, function(datum) {
            var result = {
                value: datum.data,
                label: renderUtil.formatValue(datum.data, formatFunctions, 'map', 'series')
            };

            if (datum.name) {
                result.name = datum.name;
            }

            if (datum.labelCoordinate) {
                result.labelCoordinate = datum.labelCoordinate;
            }

            valueMap[datum.code] = result;
        });

        return valueMap;
    },

    /**
     * Get value map.
     * @returns {number} value
     */
    getValueMap: function() {
        if (!this.valueMap) {
            this.valueMap = this._makeValueMap();
        }

        return this.valueMap;
    },

    /**
     * Get values.
     * @returns {Array.<number>} picked values.
     */
    getValues: function() {
        return tui.util.pluck(this.getValueMap(), 'value');
    },

    /**
     * Get valueMap datum.
     * @param {string} code map code
     * @returns {{code: string, name: string, label: number,
     *              labelCoordinate: {x: number, y: number}}} valueMap datum
     */
    getValueMapDatum: function(code) {
        return this.getValueMap()[code];
    },

    /**
     * Add data ratios of map chart.
     * @param {{min: number, max: number}} limit axis limit
     */
    addDataRatios: function(limit) {
        var min = limit.min,
            max = limit.max - min;
        tui.util.forEach(this.getValueMap(), function(map) {
            map.ratio = (map.value - min) / max;
        });
    }
});

module.exports = MapChartDataProcessor;

},{"../helpers/renderUtil":63,"./dataProcessor":42}],44:[function(require,module,exports){
/**
 * @fileoverview SeriesDataModel is base model for drawing graph of chart series area,
 *                  and create from rawSeriesData by user,
 * SeriesDataModel.groups has SeriesGroups.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * Raw series datum.
 * @typedef {{name: ?string, data: Array.<number>, stack: ?string}} rawSeriesDatum
 */

/**
 * Raw series data.
 * @typedef {Array.<rawSeriesDatum>} rawSeriesData
 */

/**
 * Groups.
 * @typedef {Array.<SeriesGroup>} groups
 */

/**
 * SeriesGroup is a element of SeriesDataModel.groups.
 * SeriesGroup.items has SeriesItem.
 */

/**
 * SeriesItem is a element of SeriesGroup.items.
 * SeriesItem has processed terminal data like value, ratio, etc.
 */

var SeriesGroup = require('./seriesGroup');
var SeriesItem = require('./seriesItem');
var SeriesItemForCoordinateType = require('./seriesItemForCoordinateType');
var predicate = require('../helpers/predicate');
var calculator = require('../helpers/calculator');

var concat = Array.prototype.concat;

var SeriesDataModel = tui.util.defineClass(/** @lends SeriesDataModel.prototype */{
    /**
     * SeriesDataModel is base model for drawing graph of chart series area,
     *      and create from rawSeriesData by user.
     * SeriesDataModel.groups has SeriesGroups.
     * @constructs SeriesDataModel
     * @param {rawSeriesData} rawSeriesData raw series data
     * @param {string} chartType chart type
     * @param {object} options options
     * @param {Array.<function>} formatFunctions format functions
     */
    init: function(rawSeriesData, chartType, options, formatFunctions) {
        /**
         * chart type
         * @type {string}
         */
        this.chartType = chartType;

        /**
         * chart options
         * @type {Object}
         */
        this.options = options || {};

        /**
         * functions for formatting
         * @type {Array.<function>}
         */
        this.formatFunctions = formatFunctions;

        /**
         * rawData.series
         * @type {rawSeriesData}
         */
        this.rawSeriesData = rawSeriesData || [];

        /**
         * baseGroups is base data for making SeriesGroups.
         * SeriesGroups is made by pivoted baseGroups, lf line type chart.
         * @type {Array.Array<SeriesItem>}
         */
        this.baseGroups = null;

        /**
         * groups has SeriesGroups.
         * @type {Array.<SeriesGroup>}
         */
        this.groups = null;

        /**
         * map of values by value type like value, x, y, r.
         * @type {object.<string, Array.<number>>}
         */
        this.valuesMap = {};

        this._removeRangeValue();
    },

    /**
     * Remove range value of item, if has stackType option.
     * @private
     */
    _removeRangeValue: function() {
        var seriesOption = tui.util.pick(this.options, 'series') || {};

        if (predicate.isAllowRangeData(this.chartType) &&
            !predicate.isValidStackOption(seriesOption.stackType) && !seriesOption.spline) {
            return;
        }

        tui.util.forEachArray(this.rawSeriesData, function(rawItem) {
            if (!tui.util.isArray(rawItem.data)) {
                return;
            }
            tui.util.forEachArray(rawItem.data, function(value, index) {
                rawItem.data[index] = concat.apply(value)[0];
            });
        });
    },

    /**
     * Create base groups.
     * Base groups is two-dimensional array by seriesItems.
     * @returns {Array.<Array.<(SeriesItem | SeriesItemForCoordinateType)>>}
     * @private
     */
    _createBaseGroups: function() {
        var self = this;
        var SeriesItemClass;

        if (predicate.isCoordinateTypeChart(this.chartType)) {
            SeriesItemClass = SeriesItemForCoordinateType;
        } else {
            SeriesItemClass = SeriesItem;
        }

        return tui.util.map(this.rawSeriesData, function(rawDatum) {
            var values;

            if (tui.util.isArray(rawDatum)) {
                values = rawDatum;
            } else {
                values = concat.apply(rawDatum.data);
            }

            return tui.util.map(values, function(value) {
                return new SeriesItemClass(value, rawDatum.stack, self.formatFunctions, self.chartType);
            });
        });
    },

    /**
     * Get base groups.
     * @returns {Array.Array.<SeriesItem>}
     * @private
     */
    _getBaseGroups: function() {
        if (!this.baseGroups) {
            this.baseGroups = this._createBaseGroups();
        }

        return this.baseGroups;
    },

    /**
     * Create SeriesGroups from rawData.series.
     * @param {boolean} isPivot - whether pivot or not.
     * @returns {Array.<SeriesGroup>}
     * @private
     */
    _createSeriesGroupsFromRawData: function(isPivot) {
        var baseGroups = this._getBaseGroups();

        if (isPivot) {
            baseGroups = tui.util.pivot(baseGroups);
        }

        return tui.util.map(baseGroups, function(items) {
            return new SeriesGroup(items);
        });
    },

    /**
     * Get SeriesGroups.
     * @returns {(Array.<SeriesGroup>|object)}
     * @private
     */
    _getSeriesGroups: function() {
        if (!this.groups) {
            this.groups = this._createSeriesGroupsFromRawData(true);
        }

        return this.groups;
    },

    /**
     * Get group count.
     * @returns {Number}
     */
    getGroupCount: function() {
        return this._getSeriesGroups().length;
    },

    /**
     * Get pivot groups.
     * @returns {(Array.<SeriesGroup>|object)}
     */
    _getPivotGroups: function() {
        if (!this.pivotGroups) {
            this.pivotGroups = this._createSeriesGroupsFromRawData();
        }

        return this.pivotGroups;
    },

    /**
     * Get SeriesGroup.
     * @param {number} index - index
     * @param {boolean} [isPivot] - whether pivot or not
     * @returns {SeriesGroup}
     */
    getSeriesGroup: function(index, isPivot) {
        return isPivot ? this._getPivotGroups()[index] : this._getSeriesGroups()[index];
    },

    /**
     * Get first SeriesGroup.
     * @param {boolean} [isPivot] - whether pivot or not
     * @returns {SeriesGroup}
     */
    getFirstSeriesGroup: function(isPivot) {
        return this.getSeriesGroup(0, isPivot);
    },

    /**
     * Get first label of SeriesItem.
     * @returns {string} formatted value
     */
    getFirstItemLabel: function() {
        return this.getFirstSeriesGroup().getFirstSeriesItem().label;
    },

    /**
     * Get series item.
     * @param {number} groupIndex - index of series groups
     * @param {number} index - index of series items
     * @param {boolean} [isPivot] - whether pivot or not
     * @returns {SeriesItem}
     */
    getSeriesItem: function(groupIndex, index, isPivot) {
        return this.getSeriesGroup(groupIndex, isPivot).getSeriesItem(index);
    },

    /**
     * Get first series item.
     * @returns {SeriesItem}
     */
    getFirstSeriesItem: function() {
        return this.getSeriesItem(0, 0);
    },

    /**
     * Get value.
     * @param {number} groupIndex - index of series groups
     * @param {number} index - index of series items
     * @returns {number} value
     */
    getValue: function(groupIndex, index) {
        return this.getSeriesItem(groupIndex, index).value;
    },

    /**
     * Get minimum value.
     * @param {string} valueType - value type like value, x, y, r.
     * @returns {number}
     */
    getMinValue: function(valueType) {
        return tui.util.min(this.getValues(valueType));
    },

    /**
     * Get maximum value.
     * @param {string} valueType - value type like value, x, y, r.
     * @returns {number}
     */
    getMaxValue: function(valueType) {
        return tui.util.max(this.getValues(valueType));
    },

    /**
     * Traverse seriesGroups, and returns to found SeriesItem by result of execution seriesGroup.find with condition.
     * @param {function} condition - condition function
     * @returns {SeriesItem}
     * @private
     */
    _findSeriesItem: function(condition) {
        var foundItem;

        this.each(function(seriesGroup) {
            foundItem = seriesGroup.find(condition);

            return !foundItem;
        });

        return foundItem;
    },

    /**
     * Find SeriesItem by value.
     * @param {string} valueType - value type like value, x, y, r.
     * @param {number} value - comparing value
     * @param {function} condition - condition function
     * @returns {SeriesItem}
     * @private
     */
    _findSeriesItemByValue: function(valueType, value, condition) {
        condition = condition || function() {
            return;
        };

        return this._findSeriesItem(function(seriesItem) {
            return seriesItem && (seriesItem[valueType] === value) && condition(seriesItem);
        });
    },

    /**
     * Find minimum SeriesItem.
     * @param {string} valueType - value type like value, x, y, r.
     * @param {function} condition - condition function
     * @returns {SeriesItem}
     */
    findMinSeriesItem: function(valueType, condition) {
        var minValue = this.getMinValue(valueType);

        return this._findSeriesItemByValue(valueType, minValue, condition);
    },

    /**
     * Find maximum SeriesItem.
     * @param {string} valueType - value type like value, x, y, r.
     * @param {function} condition - condition function
     * @returns {*|SeriesItem}
     */
    findMaxSeriesItem: function(valueType, condition) {
        var maxValue = this.getMaxValue(valueType);

        return this._findSeriesItemByValue(valueType, maxValue, condition);
    },

    /**
     * Create values that picked value from SeriesItems of SeriesGroups.
     * @param {?string} valueType - type of value
     * @returns {Array.<number>}
     * @private
     */
    _createValues: function(valueType) {
        var values = this.map(function(seriesGroup) {
            return seriesGroup.getValues(valueType);
        });

        values = concat.apply([], values);

        return tui.util.filter(values, function(value) {
            return !isNaN(value);
        });
    },

    /**
     * Get values form valuesMap.
     * @param {?string} valueType - type of value
     * @returns {Array.<number>}
     */
    getValues: function(valueType) {
        valueType = valueType || 'value';

        if (!this.valuesMap[valueType]) {
            this.valuesMap[valueType] = this._createValues(valueType);
        }

        return this.valuesMap[valueType];
    },

    /**
     * Whether count of x values greater than count of y values.
     * @returns {boolean}
     */
    isXCountGreaterThanYCount: function() {
        return this.getValues('x').length > this.getValues('y').length;
    },

    /**
     * Add ratios, when has normal stackType option.
     * @param {{min: number, max: number}} limit - axis limit
     * @private
     */
    _addRatiosWhenNormalStacked: function(limit) {
        var distance = Math.abs(limit.max - limit.min);

        this.each(function(seriesGroup) {
            seriesGroup.addRatios(distance);
        });
    },

    /**
     * Calculate base ratio for calculating ratio of item.
     * @returns {number}
     * @private
     */
    _calculateBaseRatio: function() {
        var values = this.getValues(),
            plusSum = calculator.sumPlusValues(values),
            minusSum = Math.abs(calculator.sumMinusValues(values)),
            ratio = (plusSum > 0 && minusSum > 0) ? 0.5 : 1;

        return ratio;
    },

    /**
     * Add ratios, when has percent stackType option.
     * @private
     */
    _addRatiosWhenPercentStacked: function() {
        var baseRatio = this._calculateBaseRatio();

        this.each(function(seriesGroup) {
            seriesGroup.addRatiosWhenPercentStacked(baseRatio);
        });
    },

    /**
     * Add ratios, when has diverging stackType option.
     * @private
     */
    _addRatiosWhenDivergingStacked: function() {
        this.each(function(seriesGroup) {
            var values = seriesGroup.pluck('value'),
                plusSum = calculator.sumPlusValues(values),
                minusSum = Math.abs(calculator.sumMinusValues(values));

            seriesGroup.addRatiosWhenDivergingStacked(plusSum, minusSum);
        });
    },

    /**
     * Make subtraction value for making ratio of no option chart.
     * @param {{min: number, max: number}} limit - limit
     * @returns {number}
     * @private
     */
    _makeSubtractionValue: function(limit) {
        var allowMinusPointRender = predicate.allowMinusPointRender(this.chartType),
            subValue = 0;

        if (!allowMinusPointRender && predicate.isMinusLimit(limit)) {
            subValue = limit.max;
        } else if (allowMinusPointRender || limit.min >= 0) {
            subValue = limit.min;
        }

        return subValue;
    },

    /**
     * Add ratios, when has not option.
     * @param {{min: number, max: number}} limit - axis limit
     * @private
     */
    _addRatios: function(limit) {
        var distance = Math.abs(limit.max - limit.min),
            subValue = this._makeSubtractionValue(limit);

        this.each(function(seriesGroup) {
            seriesGroup.addRatios(distance, subValue);
        });
    },

    /**
     * Add data ratios.
     * @param {{min: number, max: number}} limit - axis limit
     * @param {string} stackType - stackType option
     * @private
     */
    addDataRatios: function(limit, stackType) {
        var isAllowedStackOption = predicate.isAllowedStackOption(this.chartType);

        if (isAllowedStackOption && predicate.isNormalStack(stackType)) {
            this._addRatiosWhenNormalStacked(limit);
        } else if (isAllowedStackOption && predicate.isPercentStack(stackType)) {
            if (this.divergingOption) {
                this._addRatiosWhenDivergingStacked();
            } else {
                this._addRatiosWhenPercentStacked();
            }
        } else {
            this._addRatios(limit);
        }
    },

    /**
     * Add data ratios of pie chart.
     */
    addDataRatiosOfPieChart: function() {
        this.each(function(seriesGroup) {
            var sum = tui.util.sum(seriesGroup.pluck('value'));

            seriesGroup.addRatios(sum);
        });
    },

    /**
     * Add ratios of data for chart of coordinate type.
     * @param {{x: {min: number, max: number}, y: {min: number, max: number}}} limitMap - limit map
     * @param {boolean} [hasRadius] - whether has radius or not
     */
    addDataRatiosForCoordinateType: function(limitMap, hasRadius) {
        var xLimit = limitMap.x;
        var yLimit = limitMap.y;
        var maxRadius = hasRadius ? tui.util.max(this.getValues('r')) : 0;
        var xDistance, xSubValue, yDistance, ySubValue;

        if (xLimit) {
            xDistance = Math.abs(xLimit.max - xLimit.min);
            xSubValue = this._makeSubtractionValue(xLimit);
        }

        if (yLimit) {
            yDistance = Math.abs(yLimit.max - yLimit.min);
            ySubValue = this._makeSubtractionValue(yLimit);
        }

        this.each(function(seriesGroup) {
            seriesGroup.each(function(item) {
                if (!item) {
                    return;
                }
                item.addRatio('x', xDistance, xSubValue);
                item.addRatio('y', yDistance, ySubValue);
                item.addRatio('r', maxRadius, 0);
            });
        });
    },

    /**
     * Add start to all series item.
     * @param {number} start - start value
     */
    addStartValueToAllSeriesItem: function(start) {
        this.each(function(seriesGroup) {
            seriesGroup.addStartValueToAllSeriesItem(start);
        });
    },

    /**
     * Whether has range data or not.
     * @returns {boolean}
     */
    hasRangeData: function() {
        var hasRangeData = false;

        this.each(function(seriesGroup) {
            hasRangeData = seriesGroup.hasRangeData();

            return !hasRangeData;
        });

        return hasRangeData;
    },

    /**
     * Traverse groups, and executes iteratee function.
     * @param {function} iteratee - iteratee function
     * @param {boolean} isPivot - whether pivot or not
     */
    each: function(iteratee, isPivot) {
        var groups = isPivot ? this._getPivotGroups() : this._getSeriesGroups();

        tui.util.forEachArray(groups, function(seriesGroup, index) {
            return iteratee(seriesGroup, index);
        });
    },

    /**
     * Traverse groups, and returns to result of execution about iteratee function.
     * @param {function} iteratee - iteratee function
     * @param {boolean} isPivot - whether pivot or not
     * @returns {Array}
     */
    map: function(iteratee, isPivot) {
        var results = [];

        this.each(function(seriesGroup, index) {
            results.push(iteratee(seriesGroup, index));
        }, isPivot);

        return results;
    }
});

module.exports = SeriesDataModel;

},{"../helpers/calculator":57,"../helpers/predicate":61,"./seriesGroup":46,"./seriesItem":47,"./seriesItemForCoordinateType":48}],45:[function(require,module,exports){
/**
 * @fileoverview SeriesDataModelForTreemap is base model for drawing graph of treemap chart series area.
 * SeriesDataModel.groups has SeriesGroups.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var SeriesDataModel = require('./seriesDataModel');
var SeriesItem = require('./seriesItemForTreemap');
var chartConst = require('../const');

var aps = Array.prototype.slice;

var SeriesDataModelForTreemap = tui.util.defineClass(SeriesDataModel, {
    /**
     * SeriesDataModelForTreemap is base model for drawing graph of treemap chart series area.
     * @constructs SeriesDataModelForTreemap
     */
    init: function() {
        SeriesDataModel.apply(this, arguments);

        /**
         * cached found seriesItems map
         * @type {object.<string, Array.<SeriesItem>>}
         */
        this.foundSeriesItemsMap = {};

        /**
         * cached seriesItem map
         * @type {object<string, SeriesItem>}
         */
        this.seriesItemMap = {};
    },

    /**
     * Flatten hierarchical data.
     * @param {Array.<object>} rawSeriesData - raw series data
     * @param {string | number} parent - parent id
     * @returns {Array.<object>}
     * @private
     */
    _flattenHierarchicalData: function(rawSeriesData, parent) {
        var self = this;
        var flatData = [];
        var idPrefix;

        if (parent) {
            idPrefix = parent + '_';
        } else {
            idPrefix = chartConst.TREEMAP_ID_PREFIX;
            parent = chartConst.TREEMAP_ROOT_ID;
        }

        tui.util.forEachArray(rawSeriesData, function(datum, index) {
            var id = idPrefix + index;
            var children = datum.children;

            flatData.push(datum);

            if (!datum.id) {
                datum.id = id;
            }

            if (!datum.parent) {
                datum.parent = parent;
            }

            if (children) {
                flatData = flatData.concat(self._flattenHierarchicalData(children, id));
                delete datum.children;
            }
        });

        return flatData;
    },

    /**
     * Partition raw series data by parent id
     * @param {Array.<object>} rawSeriesData - raw series data
     * @param {string | number} parent - parent id
     * @returns {Array.<Array>}
     * @private
     */
    _partitionRawSeriesDataByParent: function(rawSeriesData, parent) {
        var filtered = [];
        var rejected = [];

        tui.util.forEachArray(rawSeriesData, function(datum) {
            if (datum.parent === parent) {
                filtered.push(datum);
            } else {
                rejected.push(datum);
            }
        });

        return [filtered, rejected];
    },

    /**
     * Set tree properties like depth, group in raw series data.
     * @param {Array.<object>} rawSeriesData - raw series data
     * @param {number} depth - tree depth
     * @param {number} parent - parent id
     * @param {number} group - tree group
     * @returns {Array.<object>}
     * @private
     */
    _setTreeProperties: function(rawSeriesData, depth, parent, group) {
        var self = this;
        var parted = this._partitionRawSeriesDataByParent(rawSeriesData, parent);
        var filtered = parted[0];
        var rejected = parted[1];
        var childDepth = depth + 1;

        tui.util.forEachArray(filtered, function(datum, index) {
            var descendants, children;

            datum.depth = depth;
            datum.group = tui.util.isUndefined(group) ? index : group;

            descendants = self._setTreeProperties(rejected, childDepth, datum.id, datum.group);
            children = tui.util.filter(descendants, function(descendant) {
                return descendant.depth === childDepth;
            });

            if (children.length) {
                datum.value = tui.util.sum(tui.util.pluck(children, 'value'));
                datum.hasChild = true;
            } else {
                datum.hasChild = false;
            }

            filtered = filtered.concat(descendants);
        });

        return filtered;
    },

    /**
     * Create base groups.
     * @returns {Array.<Array.<SeriesItem>>}
     * @private
     * @override
     */
    _createBaseGroups: function() {
        var chartType = this.chartType;
        var rawSeriesData = this.rawSeriesData;
        var seriesItemMap = this.seriesItemMap;
        var formatFunctions = this.formatFunctions;

        rawSeriesData = this._flattenHierarchicalData(rawSeriesData);
        rawSeriesData = this._setTreeProperties(rawSeriesData, 1, chartConst.TREEMAP_ROOT_ID);

        return [tui.util.map(rawSeriesData, function(rawDatum) {
            var seriesItem = new SeriesItem(rawDatum, formatFunctions, chartType);

            seriesItemMap[seriesItem.id] = seriesItem;

            return seriesItem;
        })];
    },

    /**
     * Find SeriesItems.
     * @param {string} key - key
     * @param {function} condition - condition function
     * @returns {Array.<SeriesItem>}
     * @private
     */
    _findSeriesItems: function(key, condition) {
        if (!this.foundSeriesItemsMap[key]) {
            this.foundSeriesItemsMap[key] = this.getFirstSeriesGroup(true).filter(condition);
        }

        return this.foundSeriesItemsMap[key];
    },

    /**
     * Make cache key for caching found SeriesItems.
     * @param {string} prefix - prefix
     * @returns {string}
     * @private
     */
    _makeCacheKey: function(prefix) {
        var key = prefix;

        if (arguments.length > 1) {
            key += aps.call(arguments, 1).join('_');
        }

        return key;
    },

    /**
     * Whether valid group or not.
     * If comparingGroup is undefined or group and comparingGroup are equal, this group is valid.
     * @param {number} group - group
     * @param {number} [comparingGroup] - comparing group
     * @returns {boolean}
     * @private
     */
    _isValidGroup: function(group, comparingGroup) {
        return !tui.util.isExisty(comparingGroup) || (group === comparingGroup);
    },

    /**
     * Find SeriesItems by depth.
     * @param {number} depth - tree depth
     * @param {number} [group] - tree group
     * @returns {Array.<SeriesItem>}
     */
    findSeriesItemsByDepth: function(depth, group) {
        var self = this;
        var key = this._makeCacheKey(chartConst.TREEMAP_DEPTH_KEY_PREFIX, depth, group);

        return this._findSeriesItems(key, function(seriesItem) {
            return (seriesItem.depth === depth) && self._isValidGroup(seriesItem.group, group);
        });
    },

    /**
     * Find SeriesItems by parent id.
     * @param {string | number} parent - parent id
     * @returns {Array.<SeriesItem>}
     */
    findSeriesItemsByParent: function(parent) {
        var key = this._makeCacheKey(chartConst.TREEMAP_PARENT_KEY_PREFIX, parent);

        return this._findSeriesItems(key, function(seriesItem) {
            return seriesItem.parent === parent;
        });
    },

    /**
     * Find leaf SeriesItems.
     * @param {number} [group] - tree group
     * @returns {Array.<SeriesItem>}
     */
    findLeafSeriesItems: function(group) {
        var self = this;
        var key = this._makeCacheKey(chartConst.TREEMAP_LEAF_KEY_PREFIX, group);

        return this._findSeriesItems(key, function(seriesItem) {
            return !seriesItem.hasChild && self._isValidGroup(seriesItem.group, group);
        });
    },

    /**
     * Find parent by depth.
     * @param {string} id - id
     * @param {number} depth - depth
     * @returns {SeriesItem|null}
     */
    findParentByDepth: function(id, depth) {
        var seriesItem = this.seriesItemMap[id] || null;

        if (seriesItem && seriesItem.depth !== depth) {
            seriesItem = this.findParentByDepth(seriesItem.parent, depth);
        }

        return seriesItem;
    },

    /**
     * Initialize foundSeriesItemsMap.
     */
    initSeriesItemsMap: function() {
        this.foundSeriesItemsMap = null;
    }
});

module.exports = SeriesDataModelForTreemap;

},{"../const":31,"./seriesDataModel":44,"./seriesItemForTreemap":49}],46:[function(require,module,exports){
/**
 * @fileoverview SeriesGroup is a element of SeriesDataModel.groups.
 * SeriesGroup.items has SeriesItem.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * SeriesItem is a element of SeriesGroup.items.
 * SeriesItem has processed terminal data like value, ratio, etc.
 */

var SeriesGroup = tui.util.defineClass(/** @lends SeriesGroup.prototype */{
    /**
     * SeriesGroup is a element of SeriesDataModel.groups.
     * SeriesGroup.items has SeriesItem.
     * @constructs SeriesGroup
     * @param {Array.<SeriesItem>} seriesItems - series items
     */
    init: function(seriesItems) {
        /**
         * items has SeriesItem
         * @type {Array.<SeriesItem>}
         */
        this.items = seriesItems;

        /**
         * map of values by value type like value, x, y, r.
         * @type {Array.<number>}
         */
        this.valuesMap = {};

        this.valuesMapPerStack = null;
    },

    /**
     * Get series item count.
     * @returns {number}
     */
    getSeriesItemCount: function() {
        return this.items.length;
    },

    /**
     * Get series item.
     * @param {number} index - index of items
     * @returns {SeriesItem}
     */
    getSeriesItem: function(index) {
        return this.items[index];
    },

    /**
     * Get first SeriesItem.
     * @returns {SeriesItem}
     */
    getFirstSeriesItem: function() {
        return this.getSeriesItem(0);
    },

    /**
     * Create values that picked value from SeriesItems.
     * @param {?string} valueType - type of value
     * @returns {Array.<number>}
     * @private
     */
    _createValues: function(valueType) {
        var values = [];

        this.each(function(item) {
            if (!item) {
                return;
            }

            if (tui.util.isExisty(item[valueType])) {
                values.push(item[valueType]);
            }
            if (tui.util.isExisty(item.start)) {
                values.push(item.start);
            }
        });

        return values;
    },

    /**
     * Get values from valuesMap.
     * @param {?string} valueType - type of value
     * @returns {Array}
     */
    getValues: function(valueType) {
        valueType = valueType || 'value';

        if (!this.valuesMap[valueType]) {
            this.valuesMap[valueType] = this._createValues(valueType);
        }

        return this.valuesMap[valueType];
    },

    /**
     * Make values map per stack.
     * @returns {object}
     * @private
     */
    _makeValuesMapPerStack: function() {
        var valuesMap = {};

        this.each(function(item) {
            if (!valuesMap[item.stack]) {
                valuesMap[item.stack] = [];
            }
            valuesMap[item.stack].push(item.value);
        });

        return valuesMap;
    },

    /**
     * Get values map per stack.
     * @returns {*|Object}
     */
    getValuesMapPerStack: function() {
        if (!this.valuesMapPerStack) {
            this.valuesMapPerStack = this._makeValuesMapPerStack();
        }

        return this.valuesMapPerStack;
    },

    /**
     * Make sum map per stack.
     * @returns {object} sum map
     * @private
     */
    _makeSumMapPerStack: function() {
        var valuesMap = this.getValuesMapPerStack(),
            sumMap = {};

        tui.util.forEach(valuesMap, function(values, key) {
            sumMap[key] = tui.util.sum(tui.util.map(values, function(value) {
                return Math.abs(value);
            }));
        });

        return sumMap;
    },

    /**
     * Add start value to all series item.
     * @param {number} start start value
     */
    addStartValueToAllSeriesItem: function(start) {
        this.each(function(item) {
            item.addStart(start);
        });
    },

    /**
     * Add ratios when percent stackType.
     * @param {number} baseRatio - base ratio
     */
    addRatiosWhenPercentStacked: function(baseRatio) {
        var sumMap = this._makeSumMapPerStack();

        this.each(function(item) {
            var dividingNumber = sumMap[item.stack];

            item.addRatio(dividingNumber, 0, baseRatio);
        });
    },

    /**
     * Add ratios when diverging stacked.
     * @param {number} plusSum - sum of plus number
     * @param {number} minusSum - sum of minus number
     */
    addRatiosWhenDivergingStacked: function(plusSum, minusSum) {
        this.each(function(item) {
            var dividingNumber = (item.value >= 0) ? plusSum : minusSum;

            item.addRatio(dividingNumber, 0, 0.5);
        });
    },

    /**
     * Add ratios.
     * @param {number} divNumber dividing number
     * @param {number} subValue subtraction value
     */
    addRatios: function(divNumber, subValue) {
        this.each(function(item) {
            item.addRatio(divNumber, subValue);
        });
    },

    /**
     * Whether has range data or not.
     * @returns {boolean}
     */
    hasRangeData: function() {
        var hasRangeData = false;

        this.each(function(seriesItem) {
            hasRangeData = seriesItem.isRange;

            return !hasRangeData;
        });

        return hasRangeData;
    },

    /**
     * Traverse items, and executes iteratee function.
     * @param {function} iteratee - iteratee function
     */
    each: function(iteratee) {
        tui.util.forEachArray(this.items, iteratee);
    },

    /**
     * Traverse items, and returns to results of execution about iteratee function.
     * @param {function} iteratee - iteratee function
     * @returns {Array}
     */
    map: function(iteratee) {
        return tui.util.map(this.items, iteratee);
    },

    /**
     * Traverse items, and returns to picked result at item.
     * @param {string} key key for pick
     * @returns {Array}
     */
    pluck: function(key) {
        return tui.util.pluck(this.items, key);
    },

    /**
     * Traverse items, and returns to found SeriesItem by condition function.
     * @param {function} condition - condition function
     * @returns {SeriesItem|null}
     */
    find: function(condition) {
        var foundItem;

        this.each(function(seriesItem) {
            if (condition(seriesItem)) {
                foundItem = seriesItem;
            }

            return !foundItem;
        });

        return foundItem || null;
    },

    /**
     * Traverse items, and returns to filter SeriesItems by condition function.
     * @param {function} condition - condition function
     * @returns {Array}
     */
    filter: function(condition) {
        return tui.util.filter(this.items, condition);
    }
});

module.exports = SeriesGroup;

},{}],47:[function(require,module,exports){
/**
 * @fileoverview SeriesItem is a element of SeriesGroup.items.
 * SeriesItem has processed terminal data like value, ratio, etc.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');
var renderUtil = require('../helpers/renderUtil');
var calculator = require('../helpers/calculator');

var SeriesItem = tui.util.defineClass(/** @lends SeriesItem.prototype */{
    /**
     * SeriesItem is a element of SeriesGroup.items.
     * SeriesItem has processed terminal data like value, ratio, etc.
     * @constructs SeriesItem
     * @param {number} value - value
     * @param {?string} stack - stack
     * @param {?Array.<function>} formatFunctions - format functions
     * @param {string} chartType - type of chart
     */
    init: function(value, stack, formatFunctions, chartType) {
        /**
         * type of chart
         * @type {string}
         */
        this.chartType = chartType;

        /**
         * for group stack option.
         * @type {string}
         */
        this.stack = stack || chartConst.DEFAULT_STACK;

        /**
         * format functions
         * @type {Array.<function>}
         */
        this.formatFunctions = formatFunctions;

        /**
         * whether range item or not
         * @type {boolean}
         */
        this.isRange = false;

        /**
         * value of item
         * @type {number}
         */
        this.value = null;

        /**
         * label
         * @type {string}
         */
        this.label = null;

        /**
         * ratio of value about distance of limit
         * @type {number}
         */
        this.ratio = null;

        /**
         * end value of item.
         * @type {number}
         */
        this.end = null;

        /**
         * end label
         * @type {number}
         */
        this.endLabel = null;

        /**
         * ratio of end value
         * @type {number}
         */
        this.endRatio = null;

        /**
         * start value of item.
         * @type {number}
         */
        this.start = null;

        /**
         * start label
         * @type {number}
         */
        this.startLabel = null;

        /**
         * ratio of start value
         * @type {number}
         */
        this.startRatio = null;

        /**
         * distance of start ratio and end ratio
         * @type {null}
         */
        this.ratioDistance = null;

        this._initValues(value);
    },

    /**
     * Initialize values of item.
     * @param {number} value - value
     * @private
     */
    _initValues: function(value) {
        var values = this._createValues(value);
        var areaType = 'makingSeriesLabel';
        var hasStart = values.length > 1;

        this.value = this.end = values[0];
        this.label = renderUtil.formatValue(this.value, this.formatFunctions, this.chartType, areaType);
        this.endLabel = this.label;

        if (hasStart) {
            this.addStart(values[1], true);
            this._updateFormattedValueforRange();
            this.isRange = true;
        }
    },

    /**
     * Crete sorted values.
     * @param {Array.<number>|number} value value
     * @returns {Array.<number>}
     * @private
     */
    _createValues: function(value) {
        var values = tui.util.map([].concat(value), parseFloat);

        values = values.sort(function(a, b) {
            if (a < 0 && b < 0) {
                return a - b;
            }

            return b - a;
        });

        return values;
    },

    /**
     * Add start.
     * @param {number} value - value
     * @private
     */
    addStart: function(value) {
        if (!tui.util.isNull(this.start)) {
            return;
        }

        this.start = value;
        this.startLabel = renderUtil.formatValue(value, this.formatFunctions, this.chartType, 'series');
    },

    /**
     * Update formatted value for range.
     * @private
     */
    _updateFormattedValueforRange: function() {
        this.label = this.startLabel + ' ~ ' + this.endLabel;
    },

    /**
     * Add ratio.
     * @param {number} divNumber - number for division
     * @param {?number} subNumber - number for subtraction
     * @param {?number} baseRatio - base ratio
     */
    addRatio: function(divNumber, subNumber, baseRatio) {
        divNumber = divNumber || 1;
        baseRatio = baseRatio || 1;
        subNumber = subNumber || 0;

        this.ratio = this.endRatio = calculator.calculateRatio(this.value, divNumber, subNumber, baseRatio);

        if (!tui.util.isNull(this.start)) {
            this.startRatio = calculator.calculateRatio(this.start, divNumber, subNumber, baseRatio);
            this.ratioDistance = Math.abs(this.endRatio - this.startRatio);
        }
    },

    /**
     * Pick value map.
     * @returns {{value: number, start: ?number, end: ?number}}
     */
    pickValueMap: function() {
        return {
            value: this.value,
            start: this.start,
            end: this.end
        };
    }
});

module.exports = SeriesItem;

},{"../const":31,"../helpers/calculator":57,"../helpers/renderUtil":63}],48:[function(require,module,exports){
/**
 * @fileoverview SeriesItemForCoordinateType is a element of SeriesGroup.items.
 * SeriesItemForCoordinateType has processed terminal data like x, y, r, xRatio, yRatio, rRatio.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var SeriesItemForCoordinateType = tui.util.defineClass(/** @lends SeriesItemForCoordinateType.prototype */{
    /**
     * SeriesItemForCoordinateType is a element of SeriesGroup.items.
     * SeriesItemForCoordinateType has processed terminal data like x, y, r, xRatio, yRatio, rRatio.
     * @constructs SeriesItemForCoordinateType
     * @param {object} rawSeriesDatum - value
     */
    init: function(rawSeriesDatum) {
        this._initData(rawSeriesDatum);
    },

    /**
     * Initialize data of item.
     * @param {{x: ?number, y: ?number, r: ?number, label: ?string}} rawSeriesDatum - rawSeriesDatum for bubble chart
     * @private
     */
    _initData: function(rawSeriesDatum) {
        this.x = rawSeriesDatum.x;
        this.y = rawSeriesDatum.y;
        this.r = rawSeriesDatum.r;
        this.label = rawSeriesDatum.label || '';

        this.ratioMap = {};
    },

    /**
     * Add ratio.
     * @param {string} valueType - type of value like x, y, r
     * @param {?number} divNumber - number for division
     * @param {?number} subNumber - number for subtraction
     */
    addRatio: function(valueType, divNumber, subNumber) {
        if (!tui.util.isExisty(this.ratioMap[valueType]) && divNumber) {
            this.ratioMap[valueType] = (this[valueType] - subNumber) / divNumber;
        }
    },

    /**
     * Pick value map.
     * @returns {{x: (number | null), y: (number | null), r: (number | null)}}
     */
    pickValueMap: function() {
        return {
            x: this.ratioMap.x ? this.x : null,
            y: this.ratioMap.y ? this.y : null,
            r: this.ratioMap.r ? this.r : null
        };
    }
});

module.exports = SeriesItemForCoordinateType;

},{}],49:[function(require,module,exports){
/**
 * @fileoverview SeriesItem for treemap.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var calculator = require('../helpers/calculator');
var renderUtil = require('../helpers/renderUtil');

var SeriesItemForTreemap = tui.util.defineClass(/** @lends SeriesItemForTreemap.prototype */{
    /**
     * SeriesItem for treemap.
     * @constructs SeriesItemForTreemap
     * @param {object} rawSeriesDatum - value
     * @param {?Array.<function>} formatFunctions - format functions
     * @param {string} chartType - type of chart
     */
    init: function(rawSeriesDatum, formatFunctions, chartType) {
        /**
         * type of chart
         * @type {string}
         */
        this.chartType = chartType;

        /**
         * format functions
         * @type {Array.<function>}
         */
        this.formatFunctions = formatFunctions;
        this.id = rawSeriesDatum.id;
        this.parent = rawSeriesDatum.parent;
        this.value = rawSeriesDatum.value;
        this.colorValue = rawSeriesDatum.colorValue;
        this.depth = rawSeriesDatum.depth;
        this.label = rawSeriesDatum.label || '';
        this.group = rawSeriesDatum.group;
        this.hasChild = !!rawSeriesDatum.hasChild;
    },

    /**
     * Add ratio.
     * @param {number} divNumber - number for division
     * @param {?number} subNumber - number for subtraction
     */
    addRatio: function(divNumber, subNumber) {
        divNumber = divNumber || 1;
        subNumber = subNumber || 0;

        this.ratio = calculator.calculateRatio(this.colorValue, divNumber, subNumber, 1) || -1;
    },

    /**
     * Pick value map.
     * @returns {{value: number, label: string}}
     */
    pickValueMap: function() {
        var areaType = 'makingTooltipLabel';
        var formattedValue = renderUtil.formatValue(this.value, this.formatFunctions, this.chartType, areaType);
        var label = (this.label ? this.label + ': ' : '') + formattedValue;

        return {
            value: this.value,
            label: label
        };
    }
});

module.exports = SeriesItemForTreemap;

},{"../helpers/calculator":57,"../helpers/renderUtil":63}],50:[function(require,module,exports){
/**
 * @fileoverview  Chart factory play role register chart.
 *                Also, you can get chart from this factory.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';
var chartConst = require('../const');
var rawDataHandler = require('../helpers/rawDataHandler');
var predicate = require('../helpers/predicate');

var charts = {};
var factory = {
    /**
     * Find key for getting chart.
     * @param {string} chartType - type of chart
     * @param {{seriesAlias: ?object, series: object.<string, Array>}} rawData - raw data
     * @returns {string}
     * @private
     */
    _findKey: function(chartType, rawData) {
        var key = null;
        var chartTypeMap;

        if (predicate.isComboChart(chartType)) {
            chartTypeMap = rawDataHandler.getChartTypeMap(rawData);

            if (chartTypeMap[chartConst.CHART_TYPE_COLUMN] && chartTypeMap[chartConst.CHART_TYPE_LINE]) {
                key = chartConst.CHART_TYPE_COLUMN_LINE_COMBO;
            } else if (chartTypeMap[chartConst.CHART_TYPE_AREA] && chartTypeMap[chartConst.CHART_TYPE_LINE]) {
                key = chartConst.CHART_TYPE_LINE_AREA_COMBO;
            } else if (chartTypeMap[chartConst.CHART_TYPE_PIE]) {
                key = chartConst.CHART_TYPE_PIE_DONUT_COMBO;
            }
        } else {
            key = chartType;
        }

        return key;
    },

    /**
     * Get chart instance.
     * @param {string} chartType chart type
     * @param {object} rawData chart data
     * @param {object} theme chart options
     * @param {object} options chart options
     * @returns {object} chart instance;
     */
    get: function(chartType, rawData, theme, options) {
        var key = this._findKey(chartType, rawData);
        var Chart = charts[key];
        var chart;

        if (!Chart) {
            throw new Error('Not exist ' + chartType + ' chart.');
        }

        chart = new Chart(rawData, theme, options);

        return chart;
    },

    /**
     * Register chart.
     * @param {string} chartType char type
     * @param {class} ChartClass chart class
     */
    register: function(chartType, ChartClass) {
        charts[chartType] = ChartClass;
    }
};

module.exports = factory;

},{"../const":31,"../helpers/predicate":61,"../helpers/rawDataHandler":62}],51:[function(require,module,exports){
/**
 * @fileoverview  Map factory.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var maps = {};

module.exports = {
    /**
     * Get map data.
     * @param {string} mapName map name
     * @returns {Array} map data
     */
    get: function(mapName) {
        var data = maps[mapName];

        if (!data) {
            throw new Error('Not exist ' + mapName + ' map.');
        }

        return data;
    },

    /**
     * Register Map.
     * @param {string} mapName map name
     * @param {Array} data map data
     */
    register: function(mapName, data) {
        maps[mapName] = data;
    }
};

},{}],52:[function(require,module,exports){
/**
 * @fileoverview  Plugin factory play role register rendering plugin.
 *                Also, you can get plugin from this factory.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var plugins = {},
    factory = {
        /**
         * Get graph renderer.
         * @param {string} libType type of graph library
         * @param {string} chartType chart type
         * @returns {object} renderer instance
         */
        get: function(libType, chartType) {
            var plugin = plugins[libType],
                Renderer, renderer;

            if (!plugin) {
                throw new Error('Not exist ' + libType + ' plugin.');
            }

            Renderer = plugin[chartType];
            if (!Renderer) {
                throw new Error('Not exist ' + chartType + ' chart renderer.');
            }

            renderer = new Renderer();

            return renderer;
        },
        /**
         * Plugin register.
         * @param {string} libType type of graph library
         * @param {object} plugin plugin to control library
         */
        register: function(libType, plugin) {
            plugins[libType] = plugin;
        }
    };

module.exports = factory;

},{}],53:[function(require,module,exports){
/**
 * @fileoverview  Theme factory play role register theme.
 *                Also, you can get theme from this factory.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    defaultTheme = require('../themes/defaultTheme');

var themes = {};

module.exports = {
    /**
     * Get theme.
     * @param {string} themeName theme name
     * @returns {object} theme object
     */
    get: function(themeName) {
        var theme = themes[themeName];

        if (!theme) {
            throw new Error('Not exist ' + themeName + ' theme.');
        }

        return theme;
    },

    /**
     * Theme register.
     * @param {string} themeName theme name
     * @param {object} theme theme
     */
    register: function(themeName, theme) {
        var targetItems;
        theme = JSON.parse(JSON.stringify(theme));

        if (themeName !== chartConst.DEFAULT_THEME_NAME) {
            theme = this._initTheme(theme);
        }

        targetItems = this._getInheritTargetThemeItems(theme);

        this._inheritThemeFont(theme, targetItems);
        this._copyColorInfo(theme);
        themes[themeName] = theme;
    },

    /**
     * Init theme.
     * @param {object} theme theme
     * @returns {object} theme
     * @private
     * @ignore
     */
    _initTheme: function(theme) {
        var cloneTheme = JSON.parse(JSON.stringify(defaultTheme)),
            newTheme;

        this._concatDefaultColors(theme, cloneTheme.series.colors);
        newTheme = this._overwriteTheme(theme, cloneTheme);

        newTheme = this._copyProperty({
            propName: 'yAxis',
            fromTheme: theme,
            toTheme: newTheme,
            rejectionProps: chartConst.YAXIS_PROPS
        });

        newTheme = this._copyProperty({
            propName: 'series',
            fromTheme: theme,
            toTheme: newTheme,
            rejectionProps: chartConst.SERIES_PROPS
        });

        return newTheme;
    },

    /**
     * Filter chart types.
     * @param {object} target target charts
     * @param {Array.<string>} rejectionProps reject property
     * @returns {Object} filtered charts.
     * @private
     */
    _filterChartTypes: function(target, rejectionProps) {
        var result;
        if (!target) {
            return [];
        }

        result = tui.util.filter(target, function(item, name) {
            return tui.util.inArray(name, rejectionProps) === -1;
        });

        return result;
    },

    /**
     * Concat colors.
     * @param {object} theme theme
     * @param {Array.<string>} seriesColors series colors
     * @private
     */
    _concatColors: function(theme, seriesColors) {
        if (theme.colors) {
            theme.colors = theme.colors.concat(seriesColors);
        }

        if (theme.singleColors) {
            theme.singleColors = theme.singleColors.concat(seriesColors);
        }
    },

    /**
     * Concat default colors.
     * @param {object} theme theme
     * @param {Array.<string>} seriesColors series colors
     * @private
     */
    _concatDefaultColors: function(theme, seriesColors) {
        var self = this,
            chartTypes;

        if (!theme.series) {
            return;
        }

        chartTypes = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);

        if (!tui.util.keys(chartTypes).length) {
            this._concatColors(theme.series, seriesColors);
        } else {
            tui.util.forEach(chartTypes, function(item) {
                self._concatColors(item, seriesColors);
            });
        }
    },

    /**
     * Overwrite theme
     * @param {object} from from theme property
     * @param {object} to to theme property
     * @returns {object} result property
     * @private
     */
    _overwriteTheme: function(from, to) {
        var self = this;

        tui.util.forEach(to, function(item, key) {
            var fromItem = from[key];
            if (!fromItem) {
                return;
            }

            if (tui.util.isArray(fromItem)) {
                to[key] = fromItem.slice();
            } else if (tui.util.isObject(fromItem)) {
                self._overwriteTheme(fromItem, item);
            } else {
                to[key] = fromItem;
            }
        });

        return to;
    },

    /**
     * Copy property.
     * @param {object} params parameters
     *      @param {string} params.propName property name
     *      @param {object} params.fromTheme from property
     *      @param {object} params.toTheme tp property
     *      @param {Array.<string>} params.rejectionProps reject property name
     * @returns {object} copied property
     * @private
     */
    _copyProperty: function(params) {
        var self = this,
            chartTypes;

        if (!params.toTheme[params.propName]) {
            return params.toTheme;
        }

        chartTypes = this._filterChartTypes(params.fromTheme[params.propName], params.rejectionProps);
        if (tui.util.keys(chartTypes).length) {
            tui.util.forEach(chartTypes, function(item, key) {
                var cloneTheme = JSON.parse(JSON.stringify(defaultTheme[params.propName]));
                params.fromTheme[params.propName][key] = self._overwriteTheme(item, cloneTheme);
            });

            params.toTheme[params.propName] = params.fromTheme[params.propName];
        }

        return params.toTheme;
    },

    /**
     * Copy color info to legend
     * @param {object} seriesTheme series theme
     * @param {object} legendTheme legend theme
     * @param {Array.<string>} colors colors
     * @private
     */
    _copyColorInfoToOther: function(seriesTheme, legendTheme, colors) {
        legendTheme.colors = colors || seriesTheme.colors;
        if (seriesTheme.singleColors) {
            legendTheme.singleColors = seriesTheme.singleColors;
        }
        if (seriesTheme.borderColor) {
            legendTheme.borderColor = seriesTheme.borderColor;
        }
        if (seriesTheme.selectionColor) {
            legendTheme.selectionColor = seriesTheme.selectionColor;
        }
    },

    /**
     * Get target items about font inherit.
     * @param {object} theme theme
     * @returns {Array.<object>} target items
     * @private
     */
    _getInheritTargetThemeItems: function(theme) {
        var items = [
                theme.title,
                theme.xAxis.title,
                theme.xAxis.label,
                theme.legend.label
            ],
            yAxisChartTypeThems = this._filterChartTypes(theme.yAxis, chartConst.YAXIS_PROPS),
            seriesChartTypeThemes = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);

        if (!tui.util.keys(yAxisChartTypeThems).length) {
            items.push(theme.yAxis.title);
            items.push(theme.yAxis.label);
        } else {
            tui.util.forEach(yAxisChartTypeThems, function(chatTypeTheme) {
                items.push(chatTypeTheme.title);
                items.push(chatTypeTheme.label);
            });
        }

        if (!tui.util.keys(seriesChartTypeThemes).length) {
            items.push(theme.series.label);
        } else {
            tui.util.forEach(seriesChartTypeThemes, function(chatTypeTheme) {
                items.push(chatTypeTheme.label);
            });
        }

        return items;
    },

    /**
     * Inherit theme font.
     * @param {object} theme theme
     * @param {Array.<object>} targetItems target theme items
     * @private
     */
    _inheritThemeFont: function(theme, targetItems) {
        var baseFont = theme.chart.fontFamily;

        tui.util.forEachArray(targetItems, function(item) {
            if (!item.fontFamily) {
                item.fontFamily = baseFont;
            }
        });
    },

    /**
     * Copy color info.
     * @param {object} theme theme
     * @private
     * @ignore
     */
    _copyColorInfo: function(theme) {
        var self = this,
            seriesNames = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);

        if (!tui.util.keys(seriesNames).length) {
            this._copyColorInfoToOther(theme.series, theme.legend);
            this._copyColorInfoToOther(theme.series, theme.tooltip);
        } else {
            tui.util.forEach(seriesNames, function(item, chartType) {
                theme.legend[chartType] = {};
                theme.tooltip[chartType] = {};
                self._copyColorInfoToOther(item, theme.legend[chartType], item.colors || theme.legend.colors);
                self._copyColorInfoToOther(item, theme.tooltip[chartType], item.colors || theme.tooltip.colors);
                delete theme.legend.colors;
                delete theme.tooltip.colors;
            });
        }
    }
};

},{"../const":31,"../themes/defaultTheme":107}],54:[function(require,module,exports){
/**
 * @fileoverview Axis Data Maker
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');
var predicate = require('../helpers/predicate');

/**
 * Axis data maker.
 * @module axisDataMaker
 */
var axisDataMaker = {
    /**
     * Makes labels by labelInterval option.
     * @param {Array.<string>} labels - labels
     * @param {number} labelInterval - label interval option
     * @param {number} [addedDataCount] - added data count
     * @returns {Array.<string>} labels
     * @private
     */
    _makeLabelsByIntervalOption: function(labels, labelInterval, addedDataCount) {
        addedDataCount = addedDataCount || 0;
        labels = tui.util.map(labels, function(label, index) {
            if (((index + addedDataCount) % labelInterval) !== 0) {
                label = chartConst.EMPTY_AXIS_LABEL;
            }

            return label;
        });

        return labels;
    },

    /**
     * Make data about label axis.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {Array.<string>} params.labels - chart labels
     *      @param {boolean} params.isVertical - whether vertical or not
     *      @param {boolean} params.aligned - whether align or not
     *      @param {?boolean} params.addedDataCount - added data count
     * @returns {{
     *      labels: Array.<string>,
     *      tickCount: number,
     *      validTickCount: number,
     *      isLabelAxis: boolean,
     *      isVertical: boolean
     * }} axis data
     */
    makeLabelAxisData: function(params) {
        var tickCount = params.labels.length;
        var options = params.options || {};
        var labels = params.labels;

        if (predicate.isValidLabelInterval(options.labelInterval, options.tickInterval)
                && params.labels.length > options.labelInterval) {
            labels = this._makeLabelsByIntervalOption(params.labels, options.labelInterval, params.addedDataCount);
        }

        if (!params.aligned) {
            tickCount += 1;
        }

        return {
            labels: labels,
            tickCount: tickCount,
            validTickCount: 0,
            isLabelAxis: true,
            options: options,
            isVertical: !!params.isVertical,
            isPositionRight: !!params.isPositionRight,
            aligned: !!params.aligned
        };
    },

    /**
     * Make data about value axis.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {AxisScaleMaker} params.axisScaleMaker chart values
     *      @param {boolean} params.isVertical whether vertical or not
     * @returns {{
     *      labels: Array.<string>,
     *      tickCount: number,
     *      validTickCount: number,
     *      isLabelAxis: boolean,
     *      limit: {min: number, max: number},
     *      isVertical: boolean
     * }} axis data
     */
    makeValueAxisData: function(params) {
        var axisScaleMaker = params.axisScaleMaker,
            rangeValues = axisScaleMaker.getFormattedScaleValues(),
            tickCount = rangeValues.length;

        return {
            labels: rangeValues,
            tickCount: tickCount,
            validTickCount: tickCount,
            limit: axisScaleMaker.getLimit(),
            step: axisScaleMaker.getStep(),
            options: params.options,
            isVertical: !!params.isVertical,
            isPositionRight: !!params.isPositionRight,
            aligned: !!params.aligned
        };
    },

    /**
     * Make adjusting tick interval information.
     * @param {number} beforeBlockCount - before block count
     * @param {number} seriesWidth - width of series area
     * @param {number} blockSize - block size
     * @returns {null | {blockCount: number, beforeRemainBlockCount: number, interval: number}}
     * @private
     */
    _makeAdjustingIntervalInfo: function(beforeBlockCount, seriesWidth, blockSize) {
        var newBlockCount = parseInt(seriesWidth / blockSize, 10);
        // interval : 하나의 새로운 block(tick과 tick 사이의 공간) 영역에 포함되는 이전 block 수
        var interval = parseInt(beforeBlockCount / newBlockCount, 10);
        var intervalInfo = null;
        var remainCount;

        if (interval > 1) {
            // remainCount : 이전 block들 중 새로운 block으로 채우고 남은 이전 block 수
            // | | | | | | | | | | | |  - 이전 block
            // |     |     |     |      - 새로 계산된 block
            //                   |*|*|  - 남은 이전 block 수
            remainCount = beforeBlockCount - (interval * newBlockCount);

            if (remainCount >= interval) {
                newBlockCount += parseInt(remainCount / interval, 0);
                remainCount = remainCount % interval;
            }

            intervalInfo = {
                blockCount: newBlockCount,
                beforeRemainBlockCount: remainCount,
                interval: interval
            };
        }

        return intervalInfo;
    },

    /**
     * Make candidate for adjusting tick interval.
     * @param {number} beforeBlockCount - before block count
     * @param {number} seriesWidth - width of series area
     * @returns {Array.<{newBlockCount: number, remainBlockCount: number, interval: number}>}
     * @private
     */
    _makeCandidatesForAdjustingInterval: function(beforeBlockCount, seriesWidth) {
        var self = this;
        var blockSizeRange = tui.util.range(90, 121, 5); // [90, 95, 100, 105, 110, 115, 120]
        var candidates = tui.util.map(blockSizeRange, function(blockSize) {
            return self._makeAdjustingIntervalInfo(beforeBlockCount, seriesWidth, blockSize);
        });

        return tui.util.filter(candidates, function(info) {
            return !!info;
        });
    },

    /**
     * Calculate adjusting interval information for auto tick interval option.
     * @param {number} curBlockCount - current block count
     * @param {number} seriesWidth - series width
     * @returns {{newBlockCount: number, remainBlockCount: number, interval: number}}
     * @private
     */
    _calculateAdjustingIntervalInfo: function(curBlockCount, seriesWidth) {
        var candidates = this._makeCandidatesForAdjustingInterval(curBlockCount, seriesWidth);
        var intervalInfo = null;

        if (candidates.length) {
            intervalInfo = tui.util.min(candidates, function(candidate) {
                return candidate.blockCount;
            });
        }

        return intervalInfo;
    },

    /**
     * Make filtered labels by interval.
     * @param {Array.<string>} labels - labels
     * @param {number} startIndex - start index
     * @param {numbrer} interval - interval
     * @returns {Array.<string>}
     * @private
     */
    _makeFilteredLabelsByInterval: function(labels, startIndex, interval) {
        return tui.util.filter(labels.slice(startIndex), function(label, index) {
            return index % interval === 0;
        });
    },

    /**
     * Update label type axisData for auto tick interval option.
     * @param {object} axisData - axisData
     * @param {number} seriesWidth - series width
     * @param {number} [addedDataCount] - added data count
     */
    updateLabelAxisDataForAutoTickInterval: function(axisData, seriesWidth, addedDataCount) {
        var beforeBlockCount = axisData.tickCount - 1;
        var intervalInfo = this._calculateAdjustingIntervalInfo(beforeBlockCount, seriesWidth);
        var adjustingBlockCount, interval, beforeRemainBlockCount, startIndex;

        if (!intervalInfo) {
            return;
        }

        adjustingBlockCount = intervalInfo.blockCount;
        interval = intervalInfo.interval;
        beforeRemainBlockCount = intervalInfo.beforeRemainBlockCount;
        axisData.eventTickCount = axisData.tickCount;

        // startIndex는 남은 block수의 반 만큼에서 현재 이동된 tick 수를 뺀 만큼으로 설정함
        // |     |     |     |*|*|*|    - * 영역이 남은 이전 block 수
        // |*|*|O    |     |     |*|    - 현재 이동된 tick이 없을 경우 (O 지점이 startIndex = 2)
        // |*|O    |     |     |*|*|    - tick이 하나 이동 됐을 경우 : O 지점이 startIndex = 1)
        startIndex = Math.round(beforeRemainBlockCount / 2) - (addedDataCount % interval);

        // startIndex가 0보다 작을 경우 interval만큼 증가시킴
        if (startIndex < 0) {
            startIndex += interval;
        }

        axisData.labels = this._makeFilteredLabelsByInterval(axisData.labels, startIndex, interval);

        tui.util.extend(axisData, {
            startIndex: startIndex,
            tickCount: adjustingBlockCount + 1,
            positionRatio: (startIndex / beforeBlockCount),
            sizeRatio: 1 - (beforeRemainBlockCount / beforeBlockCount),
            lineWidth: seriesWidth + chartConst.OVERLAPPING_WIDTH,
            interval: interval
        });
    },

    /**
     * Update label type axisData for stacking dynamic data.
     * @param {object} axisData - axis data
     * @param {object} prevUpdatedData - previous updated axisData
     * @param {number} firstTickCount - calculated first tick count
     */
    updateLabelAxisDataForStackingDynamicData: function(axisData, prevUpdatedData, firstTickCount) {
        var interval = prevUpdatedData.interval;
        var startIndex = prevUpdatedData.startIndex;
        var beforeBlockCount = axisData.tickCount - 1;
        var newBlockCount = beforeBlockCount / interval;
        var firstBlockCount = firstTickCount ? firstTickCount - 1 : 0;
        var beforeRemainBlockCount;

        // 새로 계산된 block의 수가 최초로 계산된 block 수의 두배수 보다 많아지면 interval 숫자를 두배로 늘림
        if (firstBlockCount && ((firstBlockCount * 2) <= newBlockCount)) {
            interval *= 2;
        }

        axisData.labels = this._makeFilteredLabelsByInterval(axisData.labels, startIndex, interval);
        newBlockCount = axisData.labels.length - 1;
        beforeRemainBlockCount = beforeBlockCount - (interval * newBlockCount);

        tui.util.extend(axisData, {
            startIndex: startIndex,
            eventTickCount: axisData.tickCount,
            tickCount: axisData.labels.length,
            positionRatio: startIndex / beforeBlockCount,
            sizeRatio: 1 - (beforeRemainBlockCount / beforeBlockCount),
            lineWidth: prevUpdatedData.lineWidth,
            interval: interval
        });
    }
};

module.exports = axisDataMaker;

},{"../const":31,"../helpers/predicate":61}],55:[function(require,module,exports){
/**
 * @fileoverview AxisScaleMaker calculates the limit and step into values of processed data and returns it.
 * @auth NHN Ent.
 *       FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');
var predicate = require('./predicate');
var calculator = require('./calculator');
var renderUtil = require('./renderUtil');

var abs = Math.abs;

var AxisScaleMaker = tui.util.defineClass(/** @lends AxisScaleMaker.prototype */{
    /**
     * AxisScaleMaker calculates the limit and step into values of processed data and returns it.
     * @param {object} params parameters
     * @constructs AxisScaleMaker
     */
    init: function(params) {
        /**
         * Data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * Chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * type of value like value, x, y, r
         * @type {string}
         */
        this.valueType = params.valueType;

        /**
         * type of area like yAxis, xAxis
         * @type {string}
         */
        this.areaType = params.areaType;

        /**
         * Whether vertical type or not.
         * @type {boolean}
         */
        this.isVertical = !!params.isVertical;

        /**
         * Whether single yAxis or not.
         * @type {boolean}
         */
        this.isSingleYAxis = !!params.isSingleYAxis;
        /**
         * Count of scale values.
         * @type {number}
         */
        this.valueCounts = params.valueCount ? [params.valueCount] : null;

        /**
         * Axis scale
         * @type {{limit: {min: number, max: number}, step: number}}
         */
        this.scale = null;

        /**
         * Formatted scale values.
         * @type {Array.<string | number>}
         */
        this.formattedValues = null;
    },

    /**
     * Get scale.
     * @returns {{limit: {min: number, max: number}, step: number}}
     * @private
     */
    _getScale: function() {
        if (!this.scale) {
            this.scale = this._makeScale();
        }

        return this.scale;
    },

    /**
     * Get limit.
     * @returns {{min: number, max: number}}
     */
    getLimit: function() {
        return this._getScale().limit;
    },

    /**
     * Get step.
     * @returns {number}
     */
    getStep: function() {
        return this._getScale().step;
    },

    /**
     * Whether percent stack chart or not.
     * @returns {boolean}
     * @private
     */
    _isPercentStackChart: function() {
        var isAllowedStackOption = predicate.isAllowedStackOption(this.chartType),
            isPercentStack = predicate.isPercentStack(this.options.stackType);

        return isAllowedStackOption && isPercentStack;
    },

    /**
     * Whether normal stack chart or not.
     * @returns {boolean}
     * @private
     */
    _isNormalStackChart: function() {
        var isAllowedStackOption = predicate.isAllowedStackOption(this.chartType),
            isNormalStack = predicate.isNormalStack(this.options.stackType);

        return isAllowedStackOption && isNormalStack;
    },

    /**
     * Whether diverging chart or not.
     * @returns {boolean|*}
     * @private
     */
    _isDivergingChart: function() {
        return this.options.diverging && predicate.isBarTypeChart(this.chartType);
    },

    /**
     * Get functions for formatting value.
     * @returns {Array.<function>}
     * @private
     */
    _getFormatFunctions: function() {
        var formatFunctions;

        if (this._isPercentStackChart()) {
            formatFunctions = [function(value) {
                return value + '%';
            }];
        } else {
            formatFunctions = this.dataProcessor.getFormatFunctions();
        }

        return formatFunctions;
    },

    /**
     * Get scale values.
     * @returns {Array.<number>}
     * @private
     */
    _getScaleValues: function() {
        var scale = this._getScale(),
            values = calculator.makeLabelsFromLimit(scale.limit, scale.step);

        return this._isDivergingChart() ? tui.util.map(values, abs) : values;
    },

    /**
     * Get formatted scale values.
     * @returns {Array.<string|number>|*}
     */
    getFormattedScaleValues: function() {
        var chartType = this.chartType;
        var areaType = this.areaType;
        var valueType = this.valueType;
        var values, formatFunctions;

        if (!this.formattedValues) {
            values = this._getScaleValues();
            formatFunctions = this._getFormatFunctions();
            this.formattedValues = renderUtil.formatValues(values, formatFunctions, chartType, areaType, valueType);
        }

        return this.formattedValues;
    },

    /**
     * Make base values of normal stackType chart.
     * @returns {Array.<number>}
     * @private
     */
    _makeBaseValuesForNormalStackedChart: function() {
        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType),
            baseValues = [];

        seriesDataModel.each(function(seriesGroup) {
            var valuesMap = seriesGroup._makeValuesMapPerStack();

            tui.util.forEach(valuesMap, function(values) {
                var plusSum = calculator.sumPlusValues(values),
                    minusSum = calculator.sumMinusValues(values);
                baseValues = baseValues.concat([plusSum, minusSum]);
            });
        });

        return baseValues;
    },

    /**
     * Make base values for making axis scale.
     * @returns {Array.<number>} base values
     * @private
     */
    _makeBaseValues: function() {
        var baseValues;

        if (predicate.isTreemapChart(this.chartType)) {
            baseValues = this.dataProcessor.getValues(this.chartType, 'colorValue');
        } else if (predicate.isMapChart(this.chartType) || this.isSingleYAxis) {
            baseValues = this.dataProcessor.getValues();
        } else if (this._isNormalStackChart()) {
            baseValues = this._makeBaseValuesForNormalStackedChart();
        } else {
            baseValues = this.dataProcessor.getValues(this.chartType, this.valueType);
        }

        return baseValues;
    },

    /**
     * Get base size for calculation candidate value counts.
     * @returns {number} base size
     * @private
     */
    _getBaseSize: function() {
        var baseSize;

        if (this.isVertical) {
            baseSize = this.boundsMaker.makeSeriesHeight();
        } else {
            baseSize = this.boundsMaker.makeSeriesWidth();
        }

        return baseSize;
    },

    /**
     * Get candidate counts of value.
     * @memberOf module:axisDataMaker
     * @returns {Array.<number>} value counts
     * @private
     */
    _getCandidateCountsOfValue: function() {
        var minStart = 3,
            valueCounts, baseSize, start, end;

        baseSize = this._getBaseSize();
        start = Math.max(minStart, parseInt(baseSize / chartConst.MAX_PIXEL_TYPE_STEP_SIZE, 10));
        end = Math.max(start, parseInt(baseSize / chartConst.MIN_PIXEL_TYPE_STEP_SIZE, 10)) + 1;
        valueCounts = tui.util.range(start, end);

        return valueCounts;
    },

    /**
     * Make limit for diverging option.
     * @param {{min: number, max: number}} limit limit
     * @returns {{min: number, max: number}} changed limit
     * @private
     */
    _makeLimitForDivergingOption: function(limit) {
        var newMax = Math.max(abs(limit.min), abs(limit.max));

        return {
            min: -newMax,
            max: newMax
        };
    },

    /**
     * Make integer type scale.
     * @memberOf module:axisDataMaker
     * @param {{min: number, max: number}} limit limit
     * @returns {{
     *      limit: {min: number, max: number},
     *      options: {min: number, max: number},
     *      divideNum: number
     * }} integer type info
     * @private
     */
    _makeIntegerTypeScale: function(limit) {
        var options = this.options.limit || {},
            min = limit.min,
            max = limit.max,
            multipleNum, changedOptions;

        if (abs(min) >= 1 || abs(max) >= 1) {
            return {
                limit: limit,
                options: options,
                divideNum: 1
            };
        }

        multipleNum = tui.util.findMultipleNum(min, max);
        changedOptions = {};

        if (!tui.util.isUndefined(options.min)) {
            changedOptions.min = options.min * multipleNum;
        }

        if (!tui.util.isUndefined(options.max)) {
            changedOptions.max = options.max * multipleNum;
        }

        return {
            limit: {
                min: min * multipleNum,
                max: max * multipleNum
            },
            options: changedOptions,
            divideNum: multipleNum
        };
    },

    /**
     * Make limit if equal min and max.
     * @param {{min: number, max: number}} limit limit
     * @returns {{min: number, max: number}} changed limit
     * @private
     */
    _makeLimitIfEqualMinMax: function(limit) {
        var min = limit.min,
            max = limit.max;

        if (min > 0) {
            min = 0;
        } else if (min < 0) {
            max = 0;
        }

        return {
            min: min,
            max: max
        };
    },

    /**
     * Make base limit
     * @memberOf module:axisDataMaker
     * @param {{min: number, max: number}} dataLimit user limit
     * @param {{min: number, max: number}} options axis options
     * @returns {{min: number, max: number}} base limit
     * @private
     */
    _makeBaseLimit: function(dataLimit, options) {
        var isMinusLimit = predicate.isMinusLimit(dataLimit),
            min = dataLimit.min,
            max = dataLimit.max,
            baseLimit, tmpMin;

        if (min === max) {
            baseLimit = this._makeLimitIfEqualMinMax(dataLimit);
        } else {
            if (isMinusLimit) {
                tmpMin = min;
                min = -max;
                max = -tmpMin;
            }

            baseLimit = calculator.calculateLimit(min, max);

            if (isMinusLimit) {
                tmpMin = baseLimit.min;
                baseLimit.min = -baseLimit.max;
                baseLimit.max = -tmpMin;
            }

            baseLimit.min = tui.util.isUndefined(options.min) ? baseLimit.min : options.min;
            baseLimit.max = tui.util.isUndefined(options.max) ? baseLimit.max : options.max;
        }

        return baseLimit;
    },

    /**
     * Normalize min.
     * @memberOf module:axisDataMaker
     * @param {number} min original min
     * @param {number} step scale step
     * @returns {number} normalized min
     * @private
     */
    _normalizeMin: function(min, step) {
        var mod = tui.util.mod(min, step),
            normalized;

        if (mod === 0) {
            normalized = min;
        } else {
            normalized = tui.util.subtraction(min, (min >= 0 ? mod : step + mod));
        }

        return normalized;
    },

    /**
     * Make normalized max.
     * @memberOf module:axisDataMaker
     * @param {{min: number, max: number}} limit limit
     * @param {number} step scale step
     * @param {number} valueCount value count
     * @returns {number} normalized max
     * @private
     */
    _makeNormalizedMax: function(limit, step, valueCount) {
        var minMaxDiff = tui.util.multiplication(step, valueCount - 1),
            normalizedMax = tui.util.addition(limit.min, minMaxDiff),
            maxDiff = limit.max - normalizedMax,
            modDiff, divideDiff;
        // normalize된 max값이 원래의 max값 보다 작을 경우 step을 증가시켜 큰 값으로 만들기
        if (maxDiff > 0) {
            modDiff = maxDiff % step;
            divideDiff = Math.floor(maxDiff / step);
            normalizedMax += step * (modDiff > 0 ? divideDiff + 1 : divideDiff);
        }

        return normalizedMax;
    },

    /**
     * Normalize limit.
     * @param {{min: number, max: number}} limit base limit
     * @param {number} step scale step
     * @param {number} valueCount value count
     * @returns {{min: number, max: number}} normalized limit
     * @private
     */
    _normalizeLimit: function(limit, step, valueCount) {
        limit.min = this._normalizeMin(limit.min, step);
        limit.max = this._makeNormalizedMax(limit, step, valueCount);

        return limit;
    },

    /**
     * Decrease minimum value by step value,
     *  when chart type is line or dataMin is minus, options is undefined, minimum values(min, dataMin) are same.
     * @param {number} min base min
     * @param {number} dataMin minimum value of user data
     * @param {number} step scale step
     * @param {?number} optionMin min option
     * @returns {number} changed min
     * @private
     */
    _decreaseMinByStep: function(min, dataMin, step, optionMin) {
        var isLineChart = predicate.isLineChart(this.chartType),
            isMinusDataMin = dataMin < 0,
            isUndefinedMinOption = tui.util.isUndefined(optionMin),
            isSame = (min === dataMin);

        if ((isLineChart || isMinusDataMin) && isUndefinedMinOption && isSame) {
            min -= step;
        }

        return min;
    },

    /**
     * Increase maximum value by step value,
     *  when chart type is line or dataMin is plus, options is undefined, maximum values(max, dataMax) are same.
     * @param {number} max base max
     * @param {number} dataMax maximum value of user data
     * @param {number} step scale step
     * @param {?number} optionMax max option
     * @returns {number} changed max
     * @private
     */
    _increaseMaxByStep: function(max, dataMax, step, optionMax) {
        var isLineChart = predicate.isLineChart(this.chartType),
            isPlusDataMax = dataMax > 0,
            isUndefinedMaxOption = tui.util.isUndefined(optionMax),
            isSame = (max === dataMax);

        if ((isLineChart || isPlusDataMax) && isUndefinedMaxOption && isSame) {
            max += step;
        }

        return max;
    },

    /**
     * Divide scale step.
     * @param {{min: number, max: number}} limit limit
     * @param {number} step step
     * @param {number} candidateValueCount candidate valueCount
     * @returns {number} scale step
     * @private
     */
    _divideScaleStep: function(limit, step, candidateValueCount) {
        var isEvenStep = ((step % 2) === 0),
            valueCount = calculator.makeLabelsFromLimit(limit, step).length,
            twiceValueCount = (valueCount * 2) - 1,
            diffOrg = abs(candidateValueCount - valueCount),
            diffTwice = abs(candidateValueCount - twiceValueCount);

        // step을 반으로 나누었을 때의 valueCount가 후보로 계산된 candidateValueCount와 인접하면 step을 반으로 나누어 반환합니다.
        if (isEvenStep && diffTwice <= diffOrg) {
            step = step / 2;
        }

        return step;
    },

    /**
     * Minimize scale limit.
     * @param {{min: number, max: number}} limit base limit
     * @param {{min: number, max: number}} dataLimit limit of user data
     * @param {number} step scale step
     * @param {number} valueCount value count
     * @param {{min: number, max:number}} options limit options of axis
     * @returns {{min: number, max: number}} minimized limit
     * @private
     */
    _minimizeScaleLimit: function(limit, dataLimit, step, valueCount, options) {
        var min = limit.max,
            max = limit.min,
            comparisonMin = tui.util.isUndefined(options.min) ? dataLimit.min - 1 : options.min,
            comparisonMax = tui.util.isUndefined(options.max) ? dataLimit.max + 1 : options.max;

        tui.util.forEachArray(tui.util.range(1, valueCount), function(valueIndex) {
            var changingStep = (step * valueIndex),
                changedMin = max + changingStep,
                changedMax = min - changingStep;

            // limit이 dataLimit 범위를 넘어갈 것으로 예상되는 경우에 변경을 중단함
            if (dataLimit.min <= changedMin && dataLimit.max >= changedMax) {
                return false;
            }

            if (comparisonMin >= changedMin) {
                limit.min = changedMin;
            }

            if (comparisonMax <= changedMax) {
                limit.max = changedMax;
            }

            return true;
        });

        return limit;
    },

    /**
     * Adjust limit for bubble chart.
     * @param {{min: number, max: number}} limit - limit
     * @param {number} step - step;
     * @private
     */
    _adjustLimitForBubbleChart: function(limit, step) {
        var valueType = this.valueType;
        var seriesDataModel = this.dataProcessor.getSeriesDataModel(this.chartType);
        var maxRadiusValue = seriesDataModel.getMaxValue('r');
        var isBiggerRatioThanHalfRatio = function(seriesItem) {
            return (seriesItem.r / maxRadiusValue) > chartConst.HALF_RATIO;
        };
        var foundMinItem = seriesDataModel.findMinSeriesItem(valueType, isBiggerRatioThanHalfRatio);
        var foundMaxItem = seriesDataModel.findMaxSeriesItem(valueType, isBiggerRatioThanHalfRatio);

        if (foundMinItem) {
            limit.min -= step;
        }

        if (foundMaxItem) {
            limit.max += step;
        }
    },

    /**
     * Make candidate axis scale.
     * @param {{min: number, max: number}} baseLimit base limit
     * @param {{min: number, max: number}} dataLimit limit of user data
     * @param {number} valueCount value count
     * @param {{min: number, max:number}} options limit options of axis
     * @returns {{
     *      limit: {min: number, max: number},
     *      step: number
     * }} scale
     * @private
     */
    _makeCandidateScale: function(baseLimit, dataLimit, valueCount, options) {
        var limit = tui.util.extend({}, baseLimit),
            step;

        // 01. 기본 limit 정보로 step 얻기
        step = calculator.calculateStepFromLimit(limit, valueCount);

        // 02. step 정규화 시키기 (ex: 0.3 --> 0.5, 7 --> 10)
        step = calculator.normalizeAxisNumber(step);

        // 03. limit 정규화 시키기
        limit = this._normalizeLimit(limit, step, valueCount);

        // 04. line차트의 경우 사용자의 min값이 limit의 min값과 같을 경우, min값을 1 step 감소 시킴
        limit.min = this._decreaseMinByStep(limit.min, dataLimit.min, step, options.min);

        // 04. 사용자의 max값이 scale max와 같을 경우, max값을 1 step 증가 시킴
        limit.max = this._increaseMaxByStep(limit.max, dataLimit.max, step, options.max);

        // 05. axis limit이 사용자 min, max와 거리가 멀 경우 조절
        limit = this._minimizeScaleLimit(limit, dataLimit, step, valueCount, options);

        // 06. 조건에 따라 step값을 반으로 나눔
        step = this._divideScaleStep(limit, step, valueCount);

        if (predicate.isBubbleChart(this.chartType)) {
            this._adjustLimitForBubbleChart(limit, step);
        }

        return {
            limit: limit,
            step: step,
            valueCount: abs(limit.max - limit.min) / step
        };
    },

    /**
     * Make candidates about axis scale.
     * @param {{
     *      limit: {min: number, max: number},
     *      options: {min: number, max: number},
     *      divideNum: number
     * }} integerTypeScale - integer type axis scale
     * @param {Array.<number>} valueCounts - candidate counts of value
     * @returns {Array.<{limit:{min: number, max: number}, stpe: number}>} - candidates scale
     * @private
     */
    _makeCandidateScales: function(integerTypeScale, valueCounts) {
        var self = this,
            dataLimit = integerTypeScale.limit,
            options = integerTypeScale.options,
            baseLimit = this._makeBaseLimit(dataLimit, options);

        return tui.util.map(valueCounts, function(valueCount) {
            return self._makeCandidateScale(baseLimit, dataLimit, valueCount, options);
        });
    },

    /**
     * Get comparing value for selecting axis scale.
     * @param {{min: number, max: number}} baseLimit - limit
     * @param {Array.<number>} valueCounts - candidate counts of value
     * @param {{limit: {min: number, max: number}, step: number}} candidateScale - scale
     * @param {number} index - index
     * @returns {number} comparing value
     * @private
     */
    _getComparingValue: function(baseLimit, valueCounts, candidateScale, index) {
        var diffMax = abs(candidateScale.limit.max - baseLimit.max);
        var diffMin = abs(baseLimit.min - candidateScale.limit.min);
        // 예상 label count와 차이가 많을 수록 후보 제외 가능성이 높음
        var diffCount = Math.max(abs(valueCounts[index] - candidateScale.valueCount), 1);
        // 소수점 이하 길이가 길 수록 후보에서 제외될 가능성이 높음
        var weight = Math.pow(10, tui.util.getDecimalLength(candidateScale.step));

        return (diffMax + diffMin) * diffCount * weight;
    },

    /**
     * Select axis scale.
     * @param {{min: number, max: number}} baseLimit limit
     * @param {Array.<{limit: {min: number, max: number}, step: number}>} candidates scale candidates
     * @param {Array.<number>} valueCounts - label counts
     * @returns {{limit: {min: number, max: number}, step: number}} selected scale
     * @private
     */
    _selectAxisScale: function(baseLimit, candidates, valueCounts) {
        var getComparingValue = tui.util.bind(this._getComparingValue, this, baseLimit, valueCounts);
        var axisScale = tui.util.min(candidates, getComparingValue);

        return axisScale;
    },

    /**
     * Restore number state of scale.
     * @memberOf module:axisDataMaker
     * @param {{limit: {min: number, max: number}, step: number}} scale scale
     * @param {number} divideNum divide num
     * @returns {{limit: {min: number, max: number}, step: number}} restored scale
     * @private
     */
    _restoreNumberState: function(scale, divideNum) {
        if (divideNum === 1) {
            return scale;
        }

        scale.step = tui.util.division(scale.step, divideNum);
        scale.limit.min = tui.util.division(scale.limit.min, divideNum);
        scale.limit.max = tui.util.division(scale.limit.max, divideNum);

        return scale;
    },

    /**
     * Calculate scale.
     * @returns {{limit: {min: number, max: number}, step: number}}
     * @private
     */
    _calculateScale: function() {
        var baseValues = this._makeBaseValues();
        var dataLimit = {
            min: tui.util.min(baseValues),
            max: tui.util.max(baseValues)
        };
        var integerTypeScale, valueCounts, candidates, scale;

        if (dataLimit.min === 0 && dataLimit.max === 0) {
            dataLimit.max = 5;
        }

        if (this._isDivergingChart()) {
            dataLimit = this._makeLimitForDivergingOption(dataLimit);
        }

        // 01. limit, options 정보를 정수형으로 변경
        integerTypeScale = this._makeIntegerTypeScale(dataLimit);

        // 02. value count 후보군 얻기
        valueCounts = this.valueCounts || this._getCandidateCountsOfValue();

        // 03. axis scale 후보군 얻기
        candidates = this._makeCandidateScales(integerTypeScale, valueCounts);

        // 04. axis scale 후보군 중 하나 선택
        scale = this._selectAxisScale(integerTypeScale.limit, candidates, valueCounts);

        // 05. 정수형으로 변경했던 scale를 원래 형태로 변경
        scale = this._restoreNumberState(scale, integerTypeScale.divideNum);

        return scale;
    },

    /**
     * Get values for sum.
     * @returns {Array.<number>}
     * @private
     */
    _getValuesForSum: function() {
        var values;

        if (this.isSingleYAxis) {
            values = this.dataProcessor.getValues();
        } else {
            values = this.dataProcessor.getValues(this.chartType);
        }

        return values;
    },

    /**
     * Calculate minus sum about group values.
     * @returns {number}
     * @private
     */
    _calculateMinusSum: function() {
        var values = this._getValuesForSum();

        return calculator.sumMinusValues(values);
    },

    /**
     * Calculate plus sum about group values.
     * @returns {number}
     * @private
     */
    _calculatePlusSum: function() {
        var values = this._getValuesForSum();

        return calculator.sumPlusValues(values);
    },

    /**
     * Get percent stackType scale.
     * @returns {{limit: {min:number, max:number}, step: number}}
     * @private
     */
    _getPercentStackedScale: function() {
        var scale;

        if (this._calculateMinusSum() === 0) {
            scale = chartConst.PERCENT_STACKED_AXIS_SCALE;
        } else if (this._calculatePlusSum() === 0) {
            scale = chartConst.MINUS_PERCENT_STACKED_AXIS_SCALE;
        } else if (this._isDivergingChart()) {
            scale = chartConst.DIVERGING_PERCENT_STACKED_AXIS_SCALE;
        } else {
            scale = chartConst.DUAL_PERCENT_STACKED_AXIS_SCALE;
        }

        return scale;
    },

    /**
     * Make scale.
     * @returns {{limit: {min:number, max:number}, step: number}}
     * @private
     */
    _makeScale: function() {
        var scale;

        if (this._isPercentStackChart()) {
            scale = this._getPercentStackedScale();
        } else {
            scale = this._calculateScale();
        }

        return scale;
    }
});

module.exports = AxisScaleMaker;

},{"../const":31,"./calculator":57,"./predicate":61,"./renderUtil":63}],56:[function(require,module,exports){
/**
 * @fileoverview Bounds maker.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');
var calculator = require('./calculator');
var predicate = require('./predicate');
var renderUtil = require('./renderUtil');

/**
 * Dimension.
 * @typedef {{width: number, height:number}} dimension
 */

/**
 * Position.
 * @typedef {{left: number, top:number}} position
 */

/**
 * Bound.
 * @typedef {{dimension: dimension, position:position}} bound
 */

var BoundsMaker = tui.util.defineClass(/** @lends BoundsMaker.prototype */{
    /**
     * Bounds maker.
     * @constructs BoundsMaker
     * @param {object} params parameters
     */
    init: function(params) {
        /**
         * options
         * @type {object}
         */
        this.options = params.options || {};
        this.options.legend = this.options.legend || {};
        this.options.yAxis = this.options.yAxis || {};

        /**
         * theme
         * @type {object}
         */
        this.theme = params.theme || {};

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = params.hasAxes;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * chart types for combo.
         */
        this.chartTypes = params.chartTypes || [];

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        this.initBoundsData();
    },

    /**
     * Initialize bounds data.
     * @param {object} chartOption chart option
     */
    initBoundsData: function(chartOption) {
        this.dimensions = {
            legend: {
                width: 0
            },
            yAxis: {
                width: 0
            },
            rightYAxis: {
                width: 0
            },
            xAxis: {
                height: 0
            },
            circleLegend: {
                width: 0
            },
            calculationLegend: {
                width: 0
            }
        };

        this.positions = {};

        this.axesData = {};

        this.xAxisDegree = 0;

        /**
         * chart left padding
         * @type {number}
         */
        this.chartLeftPadding = chartConst.CHART_PADDING;

        if (chartOption) {
            this.options.chart = chartOption;
        }

        this._registerChartDimension();
        this._registerTitleDimension();
    },

    /**
     * Register dimension.
     * @param {string} name component name
     * @param {dimension} dimension component dimension
     * @private
     */
    _registerDimension: function(name, dimension) {
        this.dimensions[name] = tui.util.extend(this.dimensions[name] || {}, dimension);
    },

    /**
     * Register base dimension.
     * @param {string} name component name
     * @param {dimension} dimension component dimension
     */
    registerBaseDimension: function(name, dimension) {
        this._registerDimension(name, dimension);
    },

    /**
     * Register axes data.
     * @param {object} axesData axes data
     */
    registerAxesData: function(axesData) {
        this.axesData = axesData;
    },

    /**
     * Axes data.
     * @returns {{xAxis: object, yAxis: object, rightYAxis: object}}
     */
    getAxesData: function() {
        return this.axesData;
    },

    /**
     * Calculate step of pixel unit.
     * @param {{tickCount: number, isLabel: boolean}} axisData - data for rendering axis
     * @param {number} size - width or height of serise area
     * @returns {number}
     * @private
     */
    _calculatePixelStep: function(axisData, size) {
        var tickCount = axisData.tickCount;
        var pixelStep;

        if (axisData.isLabel) {
            pixelStep = size / tickCount / 2;
        } else {
            pixelStep = size / (tickCount - 1);
        }

        return parseInt(pixelStep, 10);
    },

    /**
     * Get minimum step of pixel unit for axis.
     * @returns {number}
     */
    getMinimumPixelStepForAxis: function() {
        var dimension = this.getDimension('series');
        var yPixelStep = this._calculatePixelStep(this.axesData.yAxis, dimension.height);
        var xPixelStep = this._calculatePixelStep(this.axesData.xAxis, dimension.width);

        return Math.min(yPixelStep, xPixelStep);
    },

    /**
     * Get max radius for bubble chart.
     * @returns {number}
     */
    getMaxRadiusForBubbleChart: function() {
        var maxRadius = this.getMinimumPixelStepForAxis();
        var legendWidth = this.getDimension('calculationLegend').width || chartConst.MIN_LEGEND_WIDTH;
        var circleLegendWidth = this.getDimension('circleLegend').width || legendWidth;

        return Math.min((circleLegendWidth - chartConst.CIRCLE_LEGEND_PADDING) / 2, maxRadius);
    },

    /**
     * Get bound.
     * @param {string} name component name
     * @returns {bound} component bound
     */
    getBound: function(name) {
        return {
            dimension: this.dimensions[name] || {},
            position: this.positions[name] || {}
        };
    },

    /**
     * Set bound.
     * @param {string} name component name
     * @param {bound} bound component bound
     * @private
     */
    _setBound: function(name, bound) {
        this.dimensions[name] = bound.dimension;
        this.positions[name] = bound.position;
    },

    /**
     * Get dimension.
     * @param {string} name component name
     * @returns {dimension} component dimension
     */
    getDimension: function(name) {
        return this.dimensions[name];
    },

    /**
     * Get position.
     * @param {string} name component name
     * @returns {position} component position
     */
    getPosition: function(name) {
        return this.positions[name];
    },

    /**
     * Register chart dimension
     * @private
     */
    _registerChartDimension: function() {
        var chartOptions = this.options.chart || {},
            dimension = {
                width: chartOptions.width || chartConst.CHART_DEFAULT_WIDTH,
                height: chartOptions.height || chartConst.CHART_DEFAULT_HEIGHT
            };

        this._registerDimension('chart', dimension);
    },

    /**
     * Register title dimension
     * @private
     */
    _registerTitleDimension: function() {
        var chartOptions = this.options.chart || {},
            titleHeight = renderUtil.getRenderedLabelHeight(chartOptions.title, this.theme.title),
            dimension = {
                height: titleHeight + chartConst.TITLE_PADDING
            };

        this._registerDimension('title', dimension);
    },

    /**
     * Calculate limit width of x axis.
     * @param {number} labelCount - label count
     * @returns {number} limit width
     * @private
     */
    _calculateXAxisLabelLimitWidth: function(labelCount) {
        var seriesWidth = this.getDimension('series').width;
        var isAlign = predicate.isLineTypeChart(this.chartType);
        var xAxisOptions = this.options.xAxis || {};

        labelCount = labelCount || this.axesData.xAxis.labels.length;

        if (predicate.isValidLabelInterval(xAxisOptions.labelInterval, xAxisOptions.tickInterval)) {
            seriesWidth *= xAxisOptions.labelInterval;
        }

        return seriesWidth / (isAlign ? labelCount - 1 : labelCount);
    },

    /**
     * Find rotation degree.
     * @param {number} limitWidth limit width
     * @param {number} labelWidth label width
     * @param {number} labelHeight label height
     * @returns {number} rotation degree
     * @private
     */
    _findRotationDegree: function(limitWidth, labelWidth, labelHeight) {
        var foundDegree,
            halfWidth = labelWidth / 2,
            halfHeight = labelHeight / 2;

        tui.util.forEachArray(chartConst.DEGREE_CANDIDATES, function(degree) {
            var compareWidth = (calculator.calculateAdjacent(degree, halfWidth) +
                calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, halfHeight)) * 2;

            foundDegree = degree;
            if (compareWidth <= limitWidth + chartConst.XAXIS_LABEL_COMPARE_MARGIN) {
                return false;
            }

            return true;
        });

        return foundDegree;
    },

    /**
     * Make rotation info about horizontal label.
     * @param {number} limitWidth limit width
     * @param {Array.<string>} labels axis labels
     * @param {object} theme axis label theme
     * @returns {?object} rotation info
     * @private
     */
    _makeHorizontalLabelRotationInfo: function(limitWidth) {
        var labels = this.axesData.xAxis.labels,
            theme = this.theme.xAxis.label,
            maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(labels, theme),
            degree, labelHeight;

        if (maxLabelWidth <= limitWidth) {
            return null;
        }

        labelHeight = renderUtil.getRenderedLabelsMaxHeight(labels, theme);
        degree = this._findRotationDegree(limitWidth, maxLabelWidth, labelHeight);

        return {
            maxLabelWidth: maxLabelWidth,
            labelHeight: labelHeight,
            degree: degree
        };
    },


    /**
     * Calculate overflow position left.
     * @param {{degree: number, labelHeight: number}} rotationInfo rotation info
     * @param {string} firstLabel firstLabel
     * @returns {number} overflow position left
     * @private
     */
    _calculateOverflowLeft: function(rotationInfo, firstLabel) {
        var degree = rotationInfo.degree;
        var labelHeight = rotationInfo.labelHeight;
        var firstLabelWidth = renderUtil.getRenderedLabelWidth(firstLabel, this.theme.xAxis.label);
        var newLabelWidth = (calculator.calculateAdjacent(degree, firstLabelWidth / 2)
                + calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, labelHeight / 2)) * 2;
        var yAxisWidth = this.options.yAxis.isCenter ? 0 : this.getDimension('yAxis').width;
        var diffLeft = newLabelWidth - yAxisWidth;

        return diffLeft;
    },

    /**
     * Update width of dimensions.
     * @param {number} overflowLeft overflow left
     * @private
     */
    _updateDimensionsWidth: function(overflowLeft) {
        if (overflowLeft > 0) {
            this.chartLeftPadding += overflowLeft;
            this.dimensions.plot.width -= overflowLeft;
            this.dimensions.series.width -= overflowLeft;
            this.dimensions.customEvent.width -= overflowLeft;
            this.dimensions.xAxis.width -= overflowLeft;
            this.positions.series.left += overflowLeft;
        }
    },

    /**
     * Update degree of rotationInfo.
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo - rotation info
     * @param {number} labelCount - label count
     * @param {number} overflowLeft - overflow left
     * @private
     */
    _updateDegree: function(rotationInfo, labelCount, overflowLeft) {
        var limitWidth, newDegree;
        if (overflowLeft > 0) {
            limitWidth = this._calculateXAxisLabelLimitWidth(labelCount) + chartConst.XAXIS_LABEL_GUTTER;
            newDegree = this._findRotationDegree(limitWidth, rotationInfo.maxLabelWidth, rotationInfo.labelHeight);
            rotationInfo.degree = newDegree;
        }
    },

    /**
     * Calculate rotated height of xAxis.
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @returns {number} xAxis height
     * @private
     */
    _calculateXAxisRotatedHeight: function(rotationInfo) {
        var degree = rotationInfo.degree;
        var maxLabelWidth = rotationInfo.maxLabelWidth;
        var labelHeight = rotationInfo.labelHeight;
        var axisHeight = (calculator.calculateOpposite(degree, maxLabelWidth / 2) +
                calculator.calculateOpposite(chartConst.ANGLE_90 - degree, labelHeight / 2)) * 2;

        return axisHeight;
    },

    /**
     * Calculate height difference between origin category and rotation category.
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @returns {number} height difference
     * @private
     */
    _calculateDiffWithRotatedHeight: function(rotationInfo) {
        var rotatedHeight = this._calculateXAxisRotatedHeight(rotationInfo);

        return rotatedHeight - rotationInfo.labelHeight;
    },

    /**
     * Calculate height difference between origin category and multiline category.
     * @param {Array.<string>} labels labels
     * @param {number} limitWidth limit width
     * @returns {number} calculated height
     * @private
     */
    _calculateDiffWithMultilineHeight: function(labels, limitWidth) {
        var theme = this.theme.xAxis.label,
            multilineLabels = this.dataProcessor.getMultilineCategories(limitWidth, theme, this.axesData.xAxis.labels),
            normalHeight = renderUtil.getRenderedLabelsMaxHeight(labels, theme),
            multilineHeight = renderUtil.getRenderedLabelsMaxHeight(multilineLabels, tui.util.extend({
                cssText: 'line-height:1.2;width:' + limitWidth + 'px'
            }, theme));

        return multilineHeight - normalHeight;
    },

    /**
     * Update height of dimensions.
     * @param {number} diffHeight diff height
     * @private
     */
    _updateDimensionsHeight: function(diffHeight) {
        this.dimensions.plot.height -= diffHeight;
        this.dimensions.series.height -= diffHeight;
        this.dimensions.customEvent.height -= diffHeight;
        this.dimensions.tooltip.height -= diffHeight;
        this.dimensions.yAxis.height -= diffHeight;
        this.dimensions.rightYAxis.height -= diffHeight;
        this.dimensions.xAxis.height += diffHeight;
    },

    /**
     * Update dimensions and degree.
     * @private
     */
    _updateDimensionsAndDegree: function() {
        var xAxisOptions = this.options.xAxis || {};
        var limitWidth = this._calculateXAxisLabelLimitWidth();
        var labels = tui.util.filter(this.axesData.xAxis.labels, function(label) {
            return !!label;
        });
        var rotationInfo, overflowLeft, diffHeight;

        if (xAxisOptions.rotateLabel !== false) {
            rotationInfo = this._makeHorizontalLabelRotationInfo(limitWidth);
        }

        if (rotationInfo) {
            overflowLeft = this._calculateOverflowLeft(rotationInfo, labels[0]);
            this.xAxisDegree = rotationInfo.degree;
            this._updateDimensionsWidth(overflowLeft);
            this._updateDegree(rotationInfo, labels.length, overflowLeft);
            diffHeight = this._calculateDiffWithRotatedHeight(rotationInfo);
        } else {
            diffHeight = this._calculateDiffWithMultilineHeight(labels, limitWidth);
        }

        this._updateDimensionsHeight(diffHeight);
    },

    /**
     * Make plot dimention
     * @returns {{width: number, height: number}} plot dimension
     * @private
     */
    _makePlotDimension: function() {
        var seriesDimension = this.getDimension('series');

        return {
            width: seriesDimension.width,
            height: seriesDimension.height + chartConst.OVERLAPPING_WIDTH
        };
    },

    /**
     * Register axis components dimension.
     * @private
     */
    _registerAxisComponentsDimension: function() {
        var plotDimension = this._makePlotDimension();

        this._registerDimension('plot', plotDimension);

        this._registerDimension('xAxis', {
            width: plotDimension.width
        });

        this._registerDimension('yAxis', {
            height: plotDimension.height
        });

        this._registerDimension('rightYAxis', {
            height: plotDimension.height
        });
    },

    /**
     * Make series width.
     * @returns {number} series width
     */
    makeSeriesWidth: function() {
        var chartWidth = this.getDimension('chart').width;
        var yAxisWidth = this.getDimension('yAxis').width;
        var legendDimension = this.getDimension('calculationLegend');
        var legendWidth, rightAreaWidth;

        if (predicate.hasVerticalLegendWidth(this.options.legend)) {
            legendWidth = legendDimension ? legendDimension.width : 0;
        } else {
            legendWidth = 0;
        }

        rightAreaWidth = legendWidth + this.getDimension('rightYAxis').width;

        return chartWidth - (chartConst.CHART_PADDING * 2) - yAxisWidth - rightAreaWidth;
    },

    /**
     * Make series height
     * @returns {number} series height
     */
    makeSeriesHeight: function() {
        var chartHeight = this.getDimension('chart').height;
        var titleHeight = this.getDimension('title').height;
        var legendOption = this.options.legend;
        var legendHeight, bottomAreaWidth;

        if (predicate.isHorizontalLegend(legendOption.align) && legendOption.visible) {
            legendHeight = this.getDimension('legend').height;
        } else {
            legendHeight = 0;
        }

        bottomAreaWidth = legendHeight + this.dimensions.xAxis.height;

        return chartHeight - (chartConst.CHART_PADDING * 2) - titleHeight - bottomAreaWidth;
    },

    /**
     * Make series dimension.
     * @returns {{width: number, height: number}} series dimension
     * @private
     */
    _makeSeriesDimension: function() {
        return {
            width: this.makeSeriesWidth(),
            height: this.makeSeriesHeight()
        };
    },

    /**
     * Register center componets dimension.
     * @private
     */
    _registerCenterComponentsDimension: function() {
        var seriesDimension = this.getDimension('series');

        this._registerDimension('tooltip', seriesDimension);
        this._registerDimension('customEvent', seriesDimension);
    },

    /**
     * Register axes type component positions.
     * @param {number} leftLegendWidth legend width
     * @private
     */
    _registerAxisComponentsPosition: function(leftLegendWidth) {
        var seriesPosition = this.getPosition('series'),
            seriesDimension = this.getDimension('series'),
            yAxisWidth = this.getDimension('yAxis').width,
            leftAreaWidth = yAxisWidth + seriesDimension.width + leftLegendWidth;

        this.positions.plot = {
            top: seriesPosition.top,
            left: seriesPosition.left
        };

        this.positions.yAxis = {
            top: seriesPosition.top,
            left: this.chartLeftPadding + leftLegendWidth
        };

        this.positions.xAxis = {
            top: seriesPosition.top + seriesDimension.height,
            left: seriesPosition.left
        };

        this.positions.rightYAxis = {
            top: seriesPosition.top,
            left: this.chartLeftPadding + leftAreaWidth - chartConst.OVERLAPPING_WIDTH
        };
    },

    /**
     * Make legend bound.
     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} legend bound
     * @private
     */
    _makeLegendPosition: function() {
        var dimensions = this.dimensions,
            seriesDimension = this.getDimension('series'),
            legendOption = this.options.legend,
            top = dimensions.title.height,
            yAxisAreaWidth, left;

        if (predicate.isLegendAlignBottom(legendOption.align)) {
            top += seriesDimension.height + this.getDimension('xAxis').height + chartConst.LEGEND_AREA_PADDING;
        }

        if (predicate.isHorizontalLegend(legendOption.align)) {
            left = ((this.getDimension('chart').width - this.getDimension('legend').width) / 2)
                - chartConst.LEGEND_AREA_PADDING;
        } else if (predicate.isLegendAlignLeft(legendOption.align)) {
            left = 0;
        } else {
            yAxisAreaWidth = this.getDimension('yAxis').width + this.getDimension('rightYAxis').width;
            left = seriesDimension.width + yAxisAreaWidth + this.chartLeftPadding;
        }

        return {
            top: top,
            left: left
        };
    },

    /**
     * Make CircleLegend position.
     * @returns {{top: number, left: number}}
     * @private
     */
    _makeCircleLegendPosition: function() {
        var seriesPosition = this.getPosition('series');
        var seriesDimension = this.getDimension('series');
        var circleDimension = this.getDimension('circleLegend');
        var legendOption = this.options.legend;
        var left, legendWidth;

        if (predicate.isLegendAlignLeft(legendOption.align)) {
            left = 0;
        } else {
            left = seriesPosition.left + seriesDimension.width;
        }

        if (predicate.hasVerticalLegendWidth(this.options.legend)) {
            legendWidth = this.getDimension('legend').width + chartConst.CHART_PADDING;
            left += (legendWidth - circleDimension.width) / 2;
        }

        return {
            top: seriesPosition.top + seriesDimension.height - circleDimension.height,
            left: left
        };
    },

    /**
     * Whether need expansion series or not.
     * @returns {boolean}
     * @private
     */
    _isNeedExpansionSeries: function() {
        var chartType = this.chartType;

        return !predicate.isMousePositionChart(chartType) && !predicate.isTreemapChart(chartType)
            && !predicate.isPieDonutComboChart(chartType, this.chartTypes);
    },

    /**
     * Register essential components positions.
     * Essential components is all components except components for axis.
     * @private
     */
    _registerEssentialComponentsPositions: function() {
        var seriesPosition = this.getPosition('series');
        var tooltipPosition;

        this.positions.customEvent = tui.util.extend({}, seriesPosition);
        this.positions.legend = this._makeLegendPosition();

        if (this.getDimension('circleLegend').width) {
            this.positions.circleLegend = this._makeCircleLegendPosition();
        }

        if (this._isNeedExpansionSeries()) {
            tooltipPosition = {
                top: seriesPosition.top - chartConst.SERIES_EXPAND_SIZE,
                left: seriesPosition.left - chartConst.SERIES_EXPAND_SIZE
            };
        } else {
            tooltipPosition = seriesPosition;
        }

        this.positions.tooltip = tooltipPosition;
    },

    /**
     * Register positions.
     * @private
     */
    _registerPositions: function() {
        var alignOption = this.options.legend.align;
        var isVisibleLegend = this.options.legend.visible;
        var legendDimension = this.getDimension('legend');
        var topLegendHeight = (predicate.isLegendAlignTop(alignOption) && isVisibleLegend) ? legendDimension.height : 0;
        var leftLegendWidth = (predicate.isLegendAlignLeft(alignOption) && isVisibleLegend) ? legendDimension.width : 0;
        var seriesPosition = {
            top: this.getDimension('title').height + chartConst.CHART_PADDING + topLegendHeight,
            left: this.chartLeftPadding + leftLegendWidth + this.getDimension('yAxis').width
        };

        this.positions.series = seriesPosition;

        if (this.hasAxes) {
            this._updateDimensionsAndDegree();
            this._registerAxisComponentsPosition(leftLegendWidth);
        }

        this._registerEssentialComponentsPositions();
    },

    /**
     * Register bound of extended series for rendering.
     * @private
     */
    _registerExtendedSeriesBound: function() {
        var seriesBound = this.getBound('series');
        if (this._isNeedExpansionSeries()) {
            seriesBound = renderUtil.expandBound(seriesBound);
        }

        this._setBound('extendedSeries', seriesBound);
    },

    /**
     * Update bounds(positions, dimensions) of components for center option of yAxis.
     * @private
     */
    _updateBoundsForYAxisCenterOption: function() {
        var yAxisWidth = this.getDimension('yAxis').width,
            yAxisExtensibleLeft = Math.floor((this.getDimension('series').width / 2)) + chartConst.OVERLAPPING_WIDTH,
            xAxisDecreasingLeft = yAxisWidth - chartConst.OVERLAPPING_WIDTH,
            additionalLeft = renderUtil.isOldBrowser() ? 1 : 0;

        this.dimensions.extendedSeries.width += yAxisWidth;
        this.dimensions.xAxis.width += chartConst.OVERLAPPING_WIDTH;
        this.dimensions.plot.width += yAxisWidth + chartConst.OVERLAPPING_WIDTH;
        this.dimensions.customEvent.width += yAxisWidth;
        this.dimensions.tooltip.width += yAxisWidth;

        this.positions.series.left -= (yAxisWidth - additionalLeft);
        this.positions.extendedSeries.left -= (xAxisDecreasingLeft - additionalLeft);
        this.positions.plot.left -= xAxisDecreasingLeft;
        this.positions.yAxis.left += yAxisExtensibleLeft;
        this.positions.xAxis.left -= xAxisDecreasingLeft;
        this.positions.customEvent.left -= xAxisDecreasingLeft;
        this.positions.tooltip.left -= xAxisDecreasingLeft;
    },

    /**
     * Register series dimension.
     */
    registerSeriesDimension: function() {
        var seriesDimension = this._makeSeriesDimension();

        this._registerDimension('series', seriesDimension);
    },

    /**
     * Register bounds data.
     */
    registerBoundsData: function() {
        this._registerCenterComponentsDimension();

        if (this.hasAxes) {
            this._registerAxisComponentsDimension();
        }

        this._registerPositions();
        this._registerExtendedSeriesBound();

        if (this.options.yAxis.isCenter) {
            this._updateBoundsForYAxisCenterOption();
        }
    }
});

module.exports = BoundsMaker;

},{"../const":31,"./calculator":57,"./predicate":61,"./renderUtil":63}],57:[function(require,module,exports){
/**
 * @fileoverview calculator.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

/*eslint no-magic-numbers: [1, {ignore: [-1, 0, 1, 2, 10, 20, 6, 0.1]}]*/

var chartConst = require('../const');

/**
 * Calculator.
 * @module calculator
 */
var calculator = {
    /**
     * Calculate limit from chart min, max data.
     *  - http://peltiertech.com/how-excel-calculates-automatic-chart-axis-limits/
     * @memberOf module:calculator
     * @param {number} min min minimum value of user data
     * @param {number} max max maximum value of user data
     * @param {number} tickCount tick count
     * @returns {{min: number, max: number}} limit axis limit
     */
    calculateLimit: function(min, max) {
        var saveMin = 0,
            limit = {},
            iodValue; // increase or decrease value;

        if (min < 0) {
            saveMin = min;
            max -= min;
            min = 0;
        }

        iodValue = (max - min) / 20;
        limit.max = max + iodValue + saveMin;

        if (max / 6 > min) {
            limit.min = 0 + saveMin;
        } else {
            limit.min = min - iodValue + saveMin;
        }

        return limit;
    },

    /**
     * Normalize number.
     * @memberOf module:calculator
     * @param {number} value target value
     * @returns {number} normalized number
     */
    normalizeAxisNumber: function(value) {
        var standard = 0,
            flag = 1,
            normalized, mod;

        if (value === 0) {
            return value;
        } else if (value < 0) {
            flag = -1;
        }

        value *= flag;

        tui.util.forEachArray(chartConst.AXIS_STANDARD_MULTIPLE_NUMS, function(num) {
            if (value < num) {
                if (num > 1) {
                    standard = num;
                }

                return false;
            } else if (num === chartConst.AXIS_LAST_STANDARD_MULTIPLE_NUM) {
                standard = num;
            }

            return true;
        });

        if (standard < 1) {
            normalized = this.normalizeAxisNumber(value * 10) * 0.1;
        } else {
            mod = tui.util.mod(value, standard);
            normalized = tui.util.addition(value, (mod > 0 ? standard - mod : 0));
        }

        normalized *= flag;

        return normalized;
    },

    /**
     * Make tick positions of pixel type.
     * @memberOf module:calculator
     * @param {number} size area width or height
     * @param {number} count tick count
     * @param {?number} additionalPosition additional position
     * @returns {Array.<number>} positions
     */
    makeTickPixelPositions: function(size, count, additionalPosition) {
        var positions = [],
            pxLimit, pxStep;

        additionalPosition = additionalPosition || 0;

        if (count > 0) {
            pxLimit = {min: 0, max: size - 1};
            pxStep = this.calculateStepFromLimit(pxLimit, count);
            positions = tui.util.map(tui.util.range(0, size, pxStep), function(position) {
                return Math.round(position + additionalPosition);
            });
            positions[positions.length - 1] = Math.round(size - 1 + additionalPosition);
        }

        return positions;
    },

    /**
     * Make labels from limit.
     * @memberOf module:calculator
     * @param {{min: number, max: number}} limit axis limit
     * @param {number} step step between max and min
     * @returns {string[]} labels
     * @private
     */
    makeLabelsFromLimit: function(limit, step) {
        var multipleNum = tui.util.findMultipleNum(step);
        var min = Math.round(limit.min * multipleNum);
        var max = Math.round(limit.max * multipleNum);
        var labels = tui.util.range(min, max + 1, step * multipleNum);

        return tui.util.map(labels, function(label) {
            return label / multipleNum;
        });
    },

    /**
     * Calculate step from limit.
     * @memberOf module:calculator
     * @param {{min: number, max: number}} limit axis limit
     * @param {number} count value count
     * @returns {number} step
     */
    calculateStepFromLimit: function(limit, count) {
        return (limit.max - limit.min) / (count - 1);
    },

    /**
     * Calculate adjacent.
     * @param {number} degree degree
     * @param {number} hypotenuse hypotenuse
     * @returns {number} adjacent
     *
     *   H : Hypotenuse
     *   A : Adjacent
     *   O : Opposite
     *   D : Degree
     *
     *        /|
     *       / |
     *    H /  | O
     *     /   |
     *    /\ D |
     *    -----
     *       A
     */
    calculateAdjacent: function(degree, hypotenuse) {
        return Math.cos(degree * chartConst.RAD) * hypotenuse;
    },

    /**
     * Calculate opposite.
     * @param {number} degree degree
     * @param {number} hypotenuse hypotenuse
     * @returns {number} opposite
     */
    calculateOpposite: function(degree, hypotenuse) {
        return Math.sin(degree * chartConst.RAD) * hypotenuse;
    },

    /**
     * Sum plus values.
     * @param {Array.<number>} values values
     * @returns {number} sum
     */
    sumPlusValues: function(values) {
        var plusValues = tui.util.filter(values, function(value) {
            return value > 0;
        });

        return tui.util.sum(plusValues);
    },

    /**
     * Sum minus values.
     * @param {Array.<number>} values values
     * @returns {number} sum
     */
    sumMinusValues: function(values) {
        var minusValues = tui.util.filter(values, function(value) {
            return value < 0;
        });

        return tui.util.sum(minusValues);
    },

    /**
     * Make percentage value.
     * @param {number} value - value
     * @param {number} totalValue - total value
     * @returns {number}
     */
    makePercentageValue: function(value, totalValue) {
        return value / totalValue * 100;
    },

    /**
     * Calculate ratio for making bound.
     * @param {number} value - value
     * @param {number} divNumber - number for division
     * @param {number} subNumber - number for subtraction
     * @param {number} baseRatio - base ratio
     * @returns {number}
     */
    calculateRatio: function(value, divNumber, subNumber, baseRatio) {
        return ((value - subNumber) / divNumber) * baseRatio;
    }
};

module.exports = calculator;

},{"../const":31}],58:[function(require,module,exports){
/**
 * @fileoverview Utility methods to manipulate colors
 * @author NHN Ent. FE Development Lab <dl_javascript@nhnent.com>
 */
'use strict';

/*eslint no-magic-numbers: [1, {ignore: [-1, 0, 1, 2, 4, 16]}]*/

var hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;

/**
 * Color map.
 * http://stackoverflow.com/questions/1573053/javascript-function-to-convert-color-names-to-hex-codes
 * http://www.w3schools.com/HTML/html_colornames.asp
 * @type {object}
 */
var colorMap = {
    'aliceblue': '#f0f8ff',
    'antiquewhite': '#faebd7',
    'aqua': '#00ffff',
    'aquamarine': '#7fffd4',
    'azure': '#f0ffff',
    'beige': '#f5f5dc',
    'bisque': '#ffe4c4',
    'black': '#000000',
    'blanchedalmond': '#ffebcd',
    'blue': '#0000ff',
    'blueviolet': '#8a2be2',
    'brown': '#a52a2a',
    'burlywood': '#deb887',
    'cadetblue': '#5f9ea0',
    'chartreuse': '#7fff00',
    'chocolate': '#d2691e',
    'coral': '#ff7f50',
    'cornflowerblue': '#6495ed',
    'cornsilk': '#fff8dc',
    'crimson': '#dc143c',
    'cyan': '#00ffff',
    'darkblue': '#00008b',
    'darkcyan': '#008b8b',
    'darkgoldenrod': '#b8860b',
    'darkgray': '#a9a9a9',
    'darkgreen': '#006400',
    'darkkhaki': '#bdb76b',
    'darkmagenta': '#8b008b',
    'darkolivegreen': '#556b2f',
    'darkorange': '#ff8c00',
    'darkorchid': '#9932cc',
    'darkred': '#8b0000',
    'darksalmon': '#e9967a',
    'darkseagreen': '#8fbc8f',
    'darkslateblue': '#483d8b',
    'darkslategray': '#2f4f4f',
    'darkturquoise': '#00ced1',
    'darkviolet': '#9400d3',
    'deeppink': '#ff1493',
    'deepskyblue': '#00bfff',
    'dimgray': '#696969',
    'dodgerblue': '#1e90ff',
    'firebrick': '#b22222',
    'floralwhite': '#fffaf0',
    'forestgreen': '#228b22',
    'fuchsia': '#ff00ff',
    'gainsboro': '#dcdcdc',
    'ghostwhite': '#f8f8ff',
    'gold': '#ffd700',
    'goldenrod': '#daa520',
    'gray': '#808080',
    'green': '#008000',
    'greenyellow': '#adff2f',
    'honeydew': '#f0fff0',
    'hotpink': '#ff69b4',
    'indianred ': '#cd5c5c',
    'indigo': '#4b0082',
    'ivory': '#fffff0',
    'khaki': '#f0e68c',
    'lavender': '#e6e6fa',
    'lavenderblush': '#fff0f5',
    'lawngreen': '#7cfc00',
    'lemonchiffon': '#fffacd',
    'lightblue': '#add8e6',
    'lightcoral': '#f08080',
    'lightcyan': '#e0ffff',
    'lightgoldenrodyellow': '#fafad2',
    'lightgrey': '#d3d3d3',
    'lightgreen': '#90ee90',
    'lightpink': '#ffb6c1',
    'lightsalmon': '#ffa07a',
    'lightseagreen': '#20b2aa',
    'lightskyblue': '#87cefa',
    'lightslategray': '#778899',
    'lightsteelblue': '#b0c4de',
    'lightyellow': '#ffffe0',
    'lime': '#00ff00',
    'limegreen': '#32cd32',
    'linen': '#faf0e6',
    'magenta': '#ff00ff',
    'maroon': '#800000',
    'mediumaquamarine': '#66cdaa',
    'mediumblue': '#0000cd',
    'mediumorchid': '#ba55d3',
    'mediumpurple': '#9370d8',
    'mediumseagreen': '#3cb371',
    'mediumslateblue': '#7b68ee',
    'mediumspringgreen': '#00fa9a',
    'mediumturquoise': '#48d1cc',
    'mediumvioletred': '#c71585',
    'midnightblue': '#191970',
    'mintcream': '#f5fffa',
    'mistyrose': '#ffe4e1',
    'moccasin': '#ffe4b5',
    'navajowhite': '#ffdead',
    'navy': '#000080',
    'oldlace': '#fdf5e6',
    'olive': '#808000',
    'olivedrab': '#6b8e23',
    'orange': '#ffa500',
    'orangered': '#ff4500',
    'orchid': '#da70d6',
    'palegoldenrod': '#eee8aa',
    'palegreen': '#98fb98',
    'paleturquoise': '#afeeee',
    'palevioletred': '#d87093',
    'papayawhip': '#ffefd5',
    'peachpuff': '#ffdab9',
    'peru': '#cd853f',
    'pink': '#ffc0cb',
    'plum': '#dda0dd',
    'powderblue': '#b0e0e6',
    'purple': '#800080',
    'red': '#ff0000',
    'rosybrown': '#bc8f8f',
    'royalblue': '#4169e1',
    'saddlebrown': '#8b4513',
    'salmon': '#fa8072',
    'sandybrown': '#f4a460',
    'seagreen': '#2e8b57',
    'seashell': '#fff5ee',
    'sienna': '#a0522d',
    'silver': '#c0c0c0',
    'skyblue': '#87ceeb',
    'slateblue': '#6a5acd',
    'slategray': '#708090',
    'snow': '#fffafa',
    'springgreen': '#00ff7f',
    'steelblue': '#4682b4',
    'tan': '#d2b48c',
    'teal': '#008080',
    'thistle': '#d8bfd8',
    'tomato': '#ff6347',
    'turquoise': '#40e0d0',
    'violet': '#ee82ee',
    'wheat': '#f5deb3',
    'white': '#ffffff',
    'whitesmoke': '#f5f5f5',
    'yellow': '#ffff00',
    'yellowgreen': '#9acd32'
};

var colorutil = {
    /**
     * pad left zero characters.
     * @param {number} number number value to pad zero.
     * @param {number} length pad length to want.
     * @returns {string} padded string.
     */
    leadingZero: function(number, length) {
        var zero = '',
            i = 0;

        if (String(number).length > length) {
            return String(number);
        }

        for (; i < (length - 1); i += 1) {
            zero += '0';
        }

        return (zero + number).slice(length * -1);
    },

    /**
     * Check validate of hex string value is RGB
     * @param {string} str - rgb hex string
     * @returns {boolean} return true when supplied str is valid RGB hex string
     */
    isValidRGB: function(str) {
        return hexRX.test(str);
    },

    // @license RGB <-> HSV conversion utilities based off of http://www.cs.rit.edu/~ncs/color/t_convert.html

    /**
     * Convert color hex string to rgb number array
     * @param {string} hexStr - hex string
     * @returns {number[]} rgb numbers
     */
    hexToRGB: function(hexStr) {
        var r, g, b;

        if (!colorutil.isValidRGB(hexStr)) {
            return false;
        }

        hexStr = hexStr.substring(1);

        r = parseInt(hexStr.substr(0, 2), 16);
        g = parseInt(hexStr.substr(2, 2), 16);
        b = parseInt(hexStr.substr(4, 2), 16);

        return [r, g, b];
    },

    /**
     * Convert rgb number to hex string
     * @param {number} r - red
     * @param {number} g - green
     * @param {number} b - blue
     * @returns {string|boolean} return false when supplied rgb number is not valid. otherwise, converted hex string
     */
    rgbToHEX: function(r, g, b) {
        var hexStr = '#' +
            colorutil.leadingZero(r.toString(16), 2) +
            colorutil.leadingZero(g.toString(16), 2) +
            colorutil.leadingZero(b.toString(16), 2);

        if (colorutil.isValidRGB(hexStr)) {
            return hexStr;
        }

        return false;
    },

    /**
     * Color name to hex.
     * @param {string} colorName color name
     * @returns {string} hex
     */
    colorNameToHex: function(colorName) {
        return colorMap[colorName.toLowerCase()] || colorName;
    }
};

tui.util.defineNamespace('tui.chart');
tui.chart.colorutil = colorutil;

module.exports = colorutil;

},{}],59:[function(require,module,exports){
/**
 * @fileoverview DOM Handler.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var aps = Array.prototype.slice;

/**
 * DOM Handler.
 * @module domHandler
 */
var domHandler = {
    /**
     * Create element.
     * @memberOf module:domHandler
     * @param {string} tag html tag
     * @param {string} newClass class name
     * @returns {HTMLElement} created element
     */
    create: function(tag, newClass) {
        var el = document.createElement(tag);

        if (newClass) {
            this.addClass(el, newClass);
        }

        return el;
    },

    /**
     * Get class names.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @returns {Array} names
     * @private
     */
    _getClassNames: function(el) {
        var className, classNames;

        if (el.classList) {
            classNames = aps.call(el.classList);
        } else {
            className = el.className || '';
            classNames = className && tui.util.isString(className) ? className.split(' ') : [];
        }

        return classNames;
    },

    /**
     * Add css class to target element.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} newClass add class name
     */
    addClass: function(el, newClass) {
        var classNames, index;

        if (!el || !newClass) {
            return;
        }

        classNames = this._getClassNames(el);
        index = tui.util.inArray(newClass, classNames);

        if (index > -1) {
            return;
        }

        classNames.push(newClass);
        el.className = classNames.join(' ');
    },

    /**
     * Remove css class from target element.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} rmClass remove class name
     */
    removeClass: function(el, rmClass) {
        var classNames = this._getClassNames(el),
            index = tui.util.inArray(rmClass, classNames);

        if (index === -1) {
            return;
        }

        classNames.splice(index, 1);
        el.className = classNames.join(' ');
    },

    /**
     * Whether class exist or not.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} findClass target css class
     * @returns {boolean} has class
     */
    hasClass: function(el, findClass) {
        var classNames = this._getClassNames(el);
        var index = tui.util.inArray(findClass, classNames);

        return index > -1;
    },

    /**
     * Find parent by class name.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} className target css class
     * @param {string} lastClass last css class
     * @returns {HTMLElement} result element
     */
    findParentByClass: function(el, className, lastClass) {
        var parent = el.parentNode,
            result;

        if (!parent) {
            result = null;
        } else if (this.hasClass(parent, className)) {
            result = parent;
        } else if (parent.nodeName === 'BODY' || this.hasClass(parent, lastClass)) {
            result = null;
        } else {
            result = this.findParentByClass(parent, className, lastClass);
        }

        return result;
    },

    /**
     * Append child element.
     * @memberOf module:domHandler
     * @param {HTMLElement} container container element
     * @param {HTMLElement} children child element
     */
    append: function(container, children) {
        if (!container || !children) {
            return;
        }
        children = tui.util.isArray(children) ? children : [children];

        tui.util.forEachArray(children, function(child) {
            if (!child) {
                return;
            }
            container.appendChild(child);
        });
    }
};

module.exports = domHandler;

},{}],60:[function(require,module,exports){
/**
 * @fileoverview Event listener.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var bindHandlerMap = {};

/**
 * Event listener.
 * @module eventListener
 */
var eventListener = {
    /**
     * Add event listener for IE.
     * @memberOf module:eventListener
     * @param {HTMLElement} target target element
     * @param {string} type event type
     * @param {function} handler callback function
     * @param {?object} context context for callback
     * @private
     */
    _attachEvent: function(target, type, handler, context) {
        var bindHandler;

        if (context) {
            bindHandler = tui.util.bind(handler, context);
        } else {
            bindHandler = handler;
        }

        bindHandlerMap[type + handler] = bindHandler;
        target.attachEvent('on' + type, bindHandler);
    },

    /**
     * Add event listener for other browsers.
     * @memberOf module:eventListener
     * @param {HTMLElement} target - target element
     * @param {string} type - event type
     * @param {function} handler - handler
     * @param {object} [context] - context for handler
     * @private
     */
    _addEventListener: function(target, type, handler, context) {
        var bindHandler;

        if (context) {
            bindHandler = tui.util.bind(handler, context);
        } else {
            bindHandler = handler;
        }

        bindHandlerMap[type + handler] = bindHandler;
        target.addEventListener(type, bindHandler);
    },

    /**
     * Bind DOM event.
     * @memberOf module:eventListener
     * @memberOf module:eventListener
     * @param {HTMLElement} target target element
     * @param {string} type event type
     * @param {function} handler handler function
     * @param {object} [context] - context for handler
     * @private
     */
    _bindEvent: function(target, type, handler, context) {
        var bindEvent;

        if ('addEventListener' in target) {
            bindEvent = this._addEventListener;
        } else if ('attachEvent' in target) {
            bindEvent = this._attachEvent;
        }
        eventListener._bindEvent = bindEvent;

        bindEvent(target, type, handler, context);
    },

    /**
     * Bind DOM events.
     * @memberOf module:eventListener
     * @param {HTMLElement} target - target element
     * @param {string | object} types - type or map of type and handler
     * @param {function | object} [handler] - handler or context
     * @param {object} [context] - context
     */
    on: function(target, types, handler, context) {
        var handlerMap = {};
        if (tui.util.isString(types)) {
            handlerMap[types] = handler;
        } else {
            handlerMap = types;
            context = handler;
        }

        tui.util.forEach(handlerMap, function(_handler, type) {
            eventListener._bindEvent(target, type, _handler, context);
        });
    },

    /**
     * Remove event listener for IE.
     * @memberOf module:eventListener
     * @param {HTMLElement} target - target element
     * @param {string} type - event type
     * @param {function} handler - handler
     * @private
     */
    _detachEvent: function(target, type, handler) {
        if (bindHandlerMap[type + handler]) {
            target.detachEvent('on' + type, bindHandlerMap[type + handler]);
            delete bindHandlerMap[type + handler];
        }
    },

    /**
     * Add event listener for other browsers.
     * @memberOf module:eventListener
     * @param {HTMLElement} target - target element
     * @param {string} type - event type
     * @param {function} handler - handler
     * @private
     */
    _removeEventListener: function(target, type, handler) {
        target.removeEventListener(type, bindHandlerMap[type + handler]);
        delete bindHandlerMap[type + handler];
    },


    /**
     * Unbind DOM event.
     * @memberOf module:eventListener
     * @param {HTMLElement} target - target element
     * @param {string} type - event type
     * @param {function} handler - handler
     * @private
     */
    _unbindEvent: function(target, type, handler) {
        var unbindEvent;
        if ('removeEventListener' in target) {
            unbindEvent = eventListener._removeEventListener;
        } else if ('detachEvent' in target) {
            unbindEvent = eventListener._detachEvent;
        }
        eventListener._unbindEvent = unbindEvent;

        unbindEvent(target, type, handler);
    },

    /**
     * Unbind DOM events.
     * @memberOf module:eventListener
     * @param {HTMLElement} target - target element
     * @param {string | object} types - type or map of type and handler
     * @param {function} [handler] - handler
     */
    off: function(target, types, handler) {
        var handlerMap = {};
        if (tui.util.isString(types)) {
            handlerMap[types] = handler;
        } else {
            handlerMap = types;
        }

        tui.util.forEach(handlerMap, function(_handler, type) {
            eventListener._unbindEvent(target, type, _handler);
        });
    }
};

module.exports = eventListener;

},{}],61:[function(require,module,exports){
/**
 * @fileoverview Predicate.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

/**
 * predicate.
 * @module predicate
 */
var predicate = {
    /**
     * Whether bar chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @returns {boolean}
     */
    isBarChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_BAR;
    },

    /**
     * Whether column chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @returns {boolean}
     */
    isColumnChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_COLUMN;
    },

    /**
     * Whether bar type chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @returns {boolean}
     */
    isBarTypeChart: function(chartType) {
        return predicate.isBarChart(chartType) || predicate.isColumnChart(chartType);
    },

    /**
     * Whether combo chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @returns {boolean}
     */
    isComboChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_COMBO;
    },

    /**
     * Whether pie and donut combo chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @param {Array.<string>} subChartTypes - types of chart
     * @returns {boolean}
     */
    isPieDonutComboChart: function(chartType, subChartTypes) {
        var isAllPieType = tui.util.all(subChartTypes, function(subChartType) {
            return predicate.isPieTypeChart(subChartType);
        });

        return predicate.isComboChart(chartType) && isAllPieType;
    },

    /**
     * Whether line chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @returns {boolean}
     */
    isLineChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_LINE;
    },

    /**
     * Whether area chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @returns {boolean}
     */
    isAreaChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_AREA;
    },

    /**
     * Whether line and area combo chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @param {Array.<string>} subChartTypes - types of chart
     * @returns {boolean}
     */
    isLineAreaComboChart: function(chartType, subChartTypes) {
        var isAllLineType = tui.util.all(subChartTypes || [], function(subChartType) {
            return predicate.isLineChart(subChartType) || predicate.isAreaChart(subChartType);
        });

        return predicate.isComboChart(chartType) && isAllLineType;
    },

    /**
     * Whether line type chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @param {Array.<string>} [subChartTypes] - types of chart
     * @returns {boolean}
     */
    isLineTypeChart: function(chartType, subChartTypes) {
        return predicate.isLineChart(chartType) || predicate.isAreaChart(chartType)
            || predicate.isLineAreaComboChart(chartType, subChartTypes);
    },

    /**
     * Whether bubble chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @returns {boolean}
     */
    isBubbleChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_BUBBLE;
    },

    /**
     * Whether scatter chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - chart type
     * @returns {boolean}
     */
    isScatterChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_SCATTER;
    },

    /**
     * Whether heatmap chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - chart type
     * @returns {boolean}
     */
    isHeatmapChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_HEATMAP;
    },

    /**
     * Whether treemap chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - chart type
     * @returns {boolean}
     */
    isTreemapChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_TREEMAP;
    },

    /**
     * Whether box type chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - chart type
     * @returns {boolean}
     */
    isBoxTypeChart: function(chartType) {
        return predicate.isHeatmapChart(chartType) || predicate.isTreemapChart(chartType);
    },

    /**
     * Whether pie chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - chart type
     * @returns {boolean}
     */
    isPieChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_PIE;
    },

    /**
     * Whether donut chart or not.
     * @memberOf module:predicate
     * @param {string} chartType -chart type
     * @returns {boolean}
     */
    isDonutChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_DONUT;
    },

    /**
     * Whether pie type chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - chart type
     * @returns {boolean}
     */
    isPieTypeChart: function(chartType) {
        return predicate.isPieChart(chartType) || predicate.isDonutChart(chartType);
    },

    /**
     * Whether map chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @returns {boolean}
     */
    isMapChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_MAP;
    },

    /**
     * Whether coordinate type chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - chart type
     * @returns {boolean}
     */
    isCoordinateTypeChart: function(chartType) {
        return predicate.isBubbleChart(chartType) || predicate.isScatterChart(chartType);
    },

    /**
     * Whether allow rendering for minus point in area of series.
     * @memberOf module:predicate
     * @param {string} chartType - chart type
     * @returns {boolean}
     */
    allowMinusPointRender: function(chartType) {
        return predicate.isLineTypeChart(chartType) || predicate.isCoordinateTypeChart(chartType) ||
            predicate.isBoxTypeChart(chartType);
    },

    /**
     * Whether mouse position chart or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @returns {boolean}
     */
    isMousePositionChart: function(chartType) {
        return predicate.isPieTypeChart(chartType) || predicate.isMapChart(chartType)
            || predicate.isCoordinateTypeChart(chartType);
    },

    /**
     * Whether align of label is outer or not.
     * @memberOf module:predicate
     * @param {string} align - align of legend
     * @returns {boolean}
     */
    isLabelAlignOuter: function(align) {
        return align === chartConst.LABEL_ALIGN_OUTER;
    },

    /**
     * Whether show label or not.
     * @param {{showLabel: ?boolean, showLegend: ?boolean}} options - options
     * @returns {boolean}
     */
    isShowLabel: function(options) {
        return options.showLabel || options.showLegend;
    },

    /**
     * Whether show outer label or not.
     * @param {{showLabel: ?boolean, showLegend: ?boolean, labelAlign: string}} options - options
     * @returns {*|boolean}
     */
    isShowOuterLabel: function(options) {
        return predicate.isShowLabel(options) && predicate.isLabelAlignOuter(options.labelAlign);
    },

    /**
     * Whether align of legend is left or not.
     * @memberOf module:predicate
     * @param {string} align - align of legend
     * @returns {boolean}
     */
    isLegendAlignLeft: function(align) {
        return align === chartConst.LEGEND_ALIGN_LEFT;
    },

    /**
     * Whether align of legend is top or not.
     * @memberOf module:predicate
     * @param {string} align - align of legend
     * @returns {boolean}
     */
    isLegendAlignTop: function(align) {
        return align === chartConst.LEGEND_ALIGN_TOP;
    },

    /**
     * Whether align of legend is bottom or not.
     * @memberOf module:predicate
     * @param {string} align - align of legend
     * @returns {boolean}
     */
    isLegendAlignBottom: function(align) {
        return align === chartConst.LEGEND_ALIGN_BOTTOM;
    },

    /**
     * Whether horizontal legend align or not.
     * @memberOf module:predicate
     * @param {string} align - align of legend
     * @returns {boolean}
     */
    isHorizontalLegend: function(align) {
        return predicate.isLegendAlignTop(align) || predicate.isLegendAlignBottom(align);
    },

    /**
     * Whether has width for vertical type legend or not.
     * @param {{align: string, visible: boolean}} legendOption - option for legend component
     * @returns {boolean}
     */
    hasVerticalLegendWidth: function(legendOption) {
        legendOption = legendOption || {};

        return !predicate.isHorizontalLegend(legendOption.align) && legendOption.visible;
    },

    /**
     * Whether allowed stackType option or not.
     * @memberOf module:predicate
     * @param {string} chartType - type of chart
     * @returns {boolean}
     */
    isAllowedStackOption: function(chartType) {
        return predicate.isBarChart(chartType) || predicate.isColumnChart(chartType)
            || predicate.isAreaChart(chartType);
    },

    /**
     * Whether normal stack type or not.
     * @memberOf module:predicate
     * @param {boolean} stackType - stackType option
     * @returns {boolean}
     */
    isNormalStack: function(stackType) {
        return stackType === chartConst.NORMAL_STACK_TYPE;
    },

    /**
     * Whether percent stack type or not.
     * @memberOf module:predicate
     * @param {boolean} stackType - stackType option
     * @returns {boolean}
     */
    isPercentStack: function(stackType) {
        return stackType === chartConst.PERCENT_STACK_TYPE;
    },

    /**
     * Whether valid stackType option or not.
     * @memberOf module:predicate
     * @param {boolean} stackType - stackType option
     * @returns {boolean}
     */
    isValidStackOption: function(stackType) {
        return stackType && (predicate.isNormalStack(stackType) || predicate.isPercentStack(stackType));
    },

    /**
     * Whether allow range data or not.
     * @memberOf module:predicate
     * @param {string} chartType - chart type
     * @returns {boolean}
     */
    isAllowRangeData: function(chartType) {
        return predicate.isBarTypeChart(chartType) || predicate.isAreaChart(chartType);
    },

    /**
     * Whether align of yAxis is center or not.
     * @memberOf module:predicate
     * @param {boolean} hasRightYAxis - whether has right yAxis.
     * @param {string} alignOption - align option of yAxis.
     * @returns {boolean} whether - align center or not.
     */
    isYAxisAlignCenter: function(hasRightYAxis, alignOption) {
        return !hasRightYAxis && (alignOption === chartConst.YAXIS_ALIGN_CENTER);
    },

    /**
     * Whether minus limit or not.
     * @memberOf module:predicate
     * @param {{min: number, max: number}} limit - limit
     * @returns {boolean}
     */
    isMinusLimit: function(limit) {
        return limit.min <= 0 && limit.max <= 0;
    },

    /**
     * Whether auto tick interval or not.
     * @param {string} [tickInterval] - tick interval option
     * @returns {boolean}
     */
    isAutoTickInterval: function(tickInterval) {
        return tickInterval === chartConst.TICK_INTERVAL_AUTO;
    },

    /**
     * Whether valid label interval or not.
     * @param {number} [labelInterval] - label interval option
     * @param {string} [tickInterval] - tick interval option
     * @returns {*|boolean}
     */
    isValidLabelInterval: function(labelInterval, tickInterval) {
        return labelInterval && labelInterval > 1 && !tickInterval;
    }
};

module.exports = predicate;

},{"../const":31}],62:[function(require,module,exports){
/**
 * @fileoverview Raw data handler.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

/**
 * Raw data Handler.
 * @module rawDataHandler
 */
var rawDataHandler = {
    /**
     * Pick stacks.
     * @param {Array.<{stack: string}>} seriesData - raw series data
     * @param {boolean} [divergingOption] - diverging option
     * @returns {Array.<string>} stacks
     */
    pickStacks: function(seriesData, divergingOption) {
        var stacks, uniqStacks, filteredStack;

        stacks = tui.util.map(seriesData, function(seriesDatum) {
            return seriesDatum.stack;
        });

        uniqStacks = tui.util.unique(stacks);

        if (divergingOption) {
            uniqStacks = uniqStacks.slice(0, 2);
        }

        filteredStack = tui.util.filter(uniqStacks, function(stack) {
            return !!stack;
        });

        if (filteredStack.length < uniqStacks.length) {
            filteredStack.push(chartConst.DEFAULT_STACK);
        }

        return filteredStack;
    },

    /**
     * Sort series data from stacks.
     * @param {Array.<{stack: ?string}>} seriesData series data
     * @param {Array.<string>} stacks stacks
     * @returns {Array}
     */
    sortSeriesData: function(seriesData, stacks) {
        var newSeriesData = [];

        tui.util.forEachArray(stacks, function(stack) {
            var filtered = tui.util.filter(seriesData, function(datum) {
                return (datum.stack || chartConst.DEFAULT_STACK) === stack;
            });
            newSeriesData = newSeriesData.concat(filtered);
        });

        return newSeriesData;
    },

    /**
     * Remove stack of series data.
     * @param {Array.<{stack: ?string}>} seriesData series data
     */
    removeSeriesStack: function(seriesData) {
        tui.util.forEachArray(seriesData, function(datum) {
            delete datum.stack;
        });
    },

    /**
     * Find char type from chart name.
     * @param {object.<string, string>} seriesAlias - alias map
     * @param {string} seriesName - series name
     * @returns {*}
     */
    findChartType: function(seriesAlias, seriesName) {
        var chartType;

        if (seriesAlias) {
            chartType = seriesAlias[seriesName];
        }

        return chartType || seriesName;
    },

    /**
     * Get chart type map.
     * @param {{series: (Array | object)}} rawData - raw data
     * @returns {object.<string, string>}
     */
    getChartTypeMap: function(rawData) {
        var self = this;
        var chartTypeMap = {};

        if (tui.util.isObject(rawData.series)) {
            tui.util.forEach(rawData.series, function(data, seriesName) {
                chartTypeMap[self.findChartType(rawData.seriesAlias, seriesName)] = true;
            });
        }

        return chartTypeMap;
    }
};

module.exports = rawDataHandler;

},{"../const":31}],63:[function(require,module,exports){
/**
 * @fileoverview Util for rendering.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

/*eslint no-magic-numbers: [1, {ignore: [-1, 0, 1, 2, 7, 8]}]*/

var dom = require('./domHandler'),
    chartConst = require('./../const');

var concat = Array.prototype.concat;

var browser = tui.util.browser,
    isIE7 = browser.msie && browser.version === 7,
    isOldBrowser = browser.msie && browser.version <= 8;

/**
 * Util for rendering.
 * @module renderUtil
 */
var renderUtil = {
    /**
     * Concat string.
     * @memberOf module:renderUtil
     * @params {...string} target strings
     * @returns {string} concat string
     */
    concatStr: function() {
        return String.prototype.concat.apply('', arguments);
    },

    /**
     * Make cssText for font.
     * @memberOf module:renderUtil
     * @param {{fontSize: number, fontFamily: string, color: string}} theme font theme
     * @returns {string} cssText
     */
    makeFontCssText: function(theme) {
        var cssTexts = [];

        if (!theme) {
            return '';
        }

        if (theme.fontSize) {
            cssTexts.push(this.concatStr('font-size:', theme.fontSize, 'px'));
        }

        if (theme.fontFamily) {
            cssTexts.push(this.concatStr('font-family:', theme.fontFamily));
        }

        if (theme.color) {
            cssTexts.push(this.concatStr('color:', theme.color));
        }

        return cssTexts.join(';');
    },

    checkEl: null,
    /**
     * Create element for size check.
     * @memberOf module:renderUtil
     * @returns {HTMLElement} element
     * @private
     */
    _createSizeCheckEl: function() {
        var div, span;
        if (!this.checkEl) {
            div = dom.create('DIV', 'tui-chart-size-check-element');
            span = dom.create('SPAN');
            div.appendChild(span);
            this.checkEl = div;
        } else {
            this.checkEl.style.cssText = '';
        }

        return this.checkEl;
    },

    /**
     * Make caching key.
     * @param {string} label labek
     * @param {{fontSize: number, fontFamily: string}} theme theme
     * @param {string} offsetType offset type (offsetWidth or offsetHeight)
     * @returns {string} key
     * @private
     */
    _makeCachingKey: function(label, theme, offsetType) {
        var keys = [label, offsetType];

        tui.util.forEach(theme, function(key, value) {
            keys.push(key + value);
        });

        return keys.join('-');
    },

    /**
     * Size cache.
     * @type {object}
     */
    sizeCache: {},

    /**
     * Add css style.
     * @param {HTMLElement} div div element
     * @param {{fontSize: number, fontFamily: string, cssText: string}} theme theme
     * @private
     */
    _addCssStyle: function(div, theme) {
        div.style.fontSize = (theme.fontSize || chartConst.DEFAULT_LABEL_FONT_SIZE) + 'px';

        if (theme.fontFamily) {
            div.style.fontFamily = theme.fontFamily;
        }

        if (theme.cssText) {
            div.style.cssText += theme.cssText;
        }
    },

    /**
     * Get rendered label size (width or height).
     * @memberOf module:renderUtil
     * @param {string | number} label label
     * @param {object} theme theme
     * @param {string} offsetType offset type (offsetWidth or offsetHeight)
     * @returns {number} size
     * @private
     */
    _getRenderedLabelSize: function(label, theme, offsetType) {
        var key, div, span, labelSize;

        theme = theme || {};

        label = tui.util.isExisty(label) ? String(label) : '';

        if (!label) {
            return 0;
        }

        key = this._makeCachingKey(label, theme, offsetType);
        labelSize = this.sizeCache[key];

        if (!labelSize) {
            div = this._createSizeCheckEl();
            span = div.firstChild;

            span.innerHTML = label;

            this._addCssStyle(div, theme);

            document.body.appendChild(div);
            labelSize = span[offsetType];
            document.body.removeChild(div);

            this.sizeCache[key] = labelSize;
        }

        return labelSize;
    },

    /**
     * Get rendered label width.
     * @memberOf module:renderUtil
     * @param {string} label label
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} width
     */
    getRenderedLabelWidth: function(label, theme) {
        var labelWidth = this._getRenderedLabelSize(label, theme, 'offsetWidth');

        return labelWidth;
    },

    /**
     * Get rendered label height.
     * @memberOf module:renderUtil
     * @param {string} label label
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} height
     */
    getRenderedLabelHeight: function(label, theme) {
        var labelHeight = this._getRenderedLabelSize(label, theme, 'offsetHeight');

        return labelHeight;
    },

    /**
     * Get Rendered Labels Max Size(width or height).
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @param {function} iteratee iteratee
     * @returns {number} max size (width or height)
     * @private
     */
    _getRenderedLabelsMaxSize: function(labels, theme, iteratee) {
        var maxSize = 0,
            sizes;

        if (labels && labels.length) {
            sizes = tui.util.map(labels, function(label) {
                return iteratee(label, theme);
            });
            maxSize = tui.util.max(sizes);
        }

        return maxSize;
    },

    /**
     * Get rendered labels max width.
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} max width
     * @private
     */
    getRenderedLabelsMaxWidth: function(labels, theme) {
        var iteratee = tui.util.bind(this.getRenderedLabelWidth, this);
        var maxWidth = this._getRenderedLabelsMaxSize(labels, theme, iteratee);

        return maxWidth;
    },

    /**
     * Get rendered labels max height.
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} max height
     */
    getRenderedLabelsMaxHeight: function(labels, theme) {
        var iteratee = tui.util.bind(this.getRenderedLabelHeight, this);
        var maxHeight = this._getRenderedLabelsMaxSize(labels, theme, iteratee);

        return maxHeight;
    },

    /**
     * Render dimension.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {{width: number, height: number}} dimension dimension
     */
    renderDimension: function(el, dimension) {
        el.style.cssText = [
            this.concatStr('width:', dimension.width, 'px'),
            this.concatStr('height:', dimension.height, 'px')
        ].join(';');
    },

    /**
     * Render position(top, right).
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {{top: number, left: number, right: number}} position position
     */
    renderPosition: function(el, position) {
        if (tui.util.isUndefined(position)) {
            return;
        }

        if (!tui.util.isUndefined(position.top)) {
            el.style.top = position.top + 'px';
        }

        if (!tui.util.isUndefined(position.left)) {
            el.style.left = position.left + 'px';
        }

        if (!tui.util.isUndefined(position.right)) {
            el.style.right = position.right + 'px';
        }
    },

    /**
     * Render background.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {string} background background option
     */
    renderBackground: function(el, background) {
        if (!background) {
            return;
        }

        el.style.background = background;
    },

    /**
     * Render font family.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {string} fontFamily font family option
     */
    renderFontFamily: function(el, fontFamily) {
        if (!fontFamily) {
            return;
        }

        el.style.fontFamily = fontFamily;
    },

    /**
     * Render title.
     * @memberOf module:renderUtil
     * @param {string} title title
     * @param {{fontSize: number, color: string, background: string}} theme title theme
     * @param {string} className css class name
     * @returns {HTMLElement} title element
     */
    renderTitle: function(title, theme, className) {
        var elTitle, cssText;

        if (!title) {
            return null;
        }

        elTitle = dom.create('DIV', className);
        elTitle.innerHTML = title;

        cssText = renderUtil.makeFontCssText(theme);

        if (theme.background) {
            cssText += ';' + this.concatStr('background:', theme.background);
        }

        elTitle.style.cssText = cssText;

        return elTitle;
    },

    /**
     * Expand dimension.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound series bound
     * @returns {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} expended bound
     */
    expandBound: function(bound) {
        var dimension = bound.dimension;
        var position = bound.position;

        return {
            dimension: {
                width: dimension.width + chartConst.SERIES_EXPAND_SIZE * 2,
                height: dimension.height + chartConst.SERIES_EXPAND_SIZE * 2
            },
            position: {
                left: position.left - chartConst.SERIES_EXPAND_SIZE,
                top: position.top - chartConst.SERIES_EXPAND_SIZE
            }
        };
    },

    /**
     * Make custom event name.
     * @param {string} prefix prefix
     * @param {string} value value
     * @param {string} suffix suffix
     * @returns {string} custom event name
     */
    makeCustomEventName: function(prefix, value, suffix) {
        return prefix + tui.util.properCase(value) + tui.util.properCase(suffix);
    },

    /**
     * Format value.
     * @param {number} value value
     * @param {Array.<function>} formatFunctions - functions for format
     * @param {string} chartType - type of chart
     * @param {string} areaType - type of area like yAxis, xAxis, series, circleLegend
     * @param {string} [valueType] - type of value
     * @returns {string} formatted value
     */
    formatValue: function(value, formatFunctions, chartType, areaType, valueType) {
        var fns = [String(value)].concat(formatFunctions || []);

        valueType = valueType || 'value';

        return tui.util.reduce(fns, function(stored, fn) {
            return fn(stored, chartType, areaType, valueType);
        });
    },

    /**
     * Format values.
     * @param {Array.<number>} values values
     * @param {Array.<function>} formatFunctions functions for format
     * @param {string} chartType - type of chart
     * @param {string} areaType - type of area like yAxis, xAxis, series, circleLegend
     * @param {string} valueType - type of value
     * @returns {Array.<string>}
     */
    formatValues: function(values, formatFunctions, chartType, areaType, valueType) {
        var formatedValues;

        if (!formatFunctions || !formatFunctions.length) {
            return values;
        }
        formatedValues = tui.util.map(values, function(label) {
            return renderUtil.formatValue(label, formatFunctions, chartType, areaType, valueType);
        });

        return formatedValues;
    },

    /**
     * Cancel animation
     * @param {{id: number}} animation animaion object
     */
    cancelAnimation: function(animation) {
        if (animation && animation.id) {
            cancelAnimationFrame(animation.id);
            delete animation.id;
        }
    },

    /**
     * Start animation.
     * @param {number} animationTime - animation time
     * @param {function} onAnimation - animation callback function
     * @param {function} onCompleted - completed callback function
     * @returns {{id: number}} requestAnimationFrame id
     */
    startAnimation: function(animationTime, onAnimation, onCompleted) {
        var animation = {},
            startTime;

        /**
         * Animate.
         */
        function animate() {
            var diffTime = (new Date()).getTime() - startTime,
                ratio = Math.min((diffTime / animationTime), 1);

            onAnimation(ratio);

            if (ratio === 1) {
                delete animation.id;
                if (onCompleted) {
                    onCompleted();
                }
            } else {
                animation.id = requestAnimationFrame(animate);
            }
        }

        startTime = (new Date()).getTime();
        animation.id = requestAnimationFrame(animate);

        return animation;
    },

    /**
     * Whether IE7 or not.
     * @returns {boolean} result boolean
     */
    isIE7: function() {
        return isIE7;
    },

    /**
     * Whether oldBrowser or not.
     * @memberOf module:renderUtil
     * @returns {boolean} result boolean
     */
    isOldBrowser: function() {
        return isOldBrowser;
    },

    /**
     * Format to zero fill.
     * @param {string} value target value
     * @param {number} len length of result
     * @returns {string} formatted value
     * @private
     */
    formatToZeroFill: function(value, len) {
        var zero = '0';

        value = String(value);

        if (value.length >= len) {
            return value;
        }

        while (value.length < len) {
            value = zero + value;
        }

        return value;
    },

    /**
     * Format to Decimal.
     * @param {string} value target value
     * @param {number} len length of under decimal point
     * @returns {string} formatted value
     */
    formatToDecimal: function(value, len) {
        var pow;

        if (len === 0) {
            return Math.round(value);
        }

        pow = Math.pow(10, len);
        value = Math.round(value * pow) / pow;
        value = parseFloat(value).toFixed(len);

        return value;
    },

    /**
     * Format to Comma.
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    formatToComma: function(value) {
        var comma = ',',
            underPointValue = '',
            betweenLen = 3,
            orgValue = value,
            sign, values, lastIndex, formattedValue;

        value = String(value);
        sign = value.indexOf('-') > -1 ? '-' : '';

        if (value.indexOf('.') > -1) {
            values = value.split('.');
            value = String(Math.abs(values[0]));
            underPointValue = '.' + values[1];
        } else {
            value = String(Math.abs(value));
        }

        if (value.length <= betweenLen) {
            formattedValue = orgValue;
        } else {
            values = (value).split('').reverse();
            lastIndex = values.length - 1;
            values = tui.util.map(values, function(char, index) {
                var result = [char];
                if (index < lastIndex && (index + 1) % betweenLen === 0) {
                    result.push(comma);
                }

                return result;
            });
            formattedValue = sign + concat.apply([], values).reverse().join('') + underPointValue;
        }

        return formattedValue;
    },

    /**
     * Make cssText from map.
     * @param {object} cssMap - css map
     * @returns {string}
     */
    makeCssTextFromMap: function(cssMap) {
        return tui.util.map(cssMap, function(value, name) {
            return renderUtil.concatStr(name, ':', value);
        }).join(';');
    }
};

/**
 * Set css opacity.
 * @param {HTMLElement | Array.<HTMLElement>} elements - elements
 * @param {function} iteratee - iteratee
 */
function setOpacity(elements, iteratee) {
    elements = tui.util.isArray(elements) ? elements : [elements];
    tui.util.forEachArray(elements, iteratee);
}

/**
 * Make filter opacity css string.
 * @param {number} opacity - opacity
 * @returns {string}
 */
function makeCssFilterOpacityString(opacity) {
    return 'alpha(opacity=' + (opacity * chartConst.OLD_BROWSER_OPACITY_100) + ')';
}

if (isOldBrowser) {
    /**
     * Make opacity css text for old browser(IE7, IE8).
     * @param {number} opacity - opacity
     * @returns {string}
     */
    renderUtil.makeOpacityCssText = function(opacity) {
        return ';filter:' + makeCssFilterOpacityString(opacity);
    };

    /**
     * Set css opacity for old browser(IE7, IE8).
     * @param {HTMLElement | Array.<HTMLElement>} elements - elements
     * @param {number} opacity - opacity
     */
    renderUtil.setOpacity = function(elements, opacity) {
        var filter = makeCssFilterOpacityString(opacity);
        setOpacity(elements, function(element) {
            element.style.filter = filter;
        });
    };
} else {
    /**
     * Make opacity css text for browser supporting opacity property of CSS3.
     * @param {number} opacity - opacity
     * @returns {string}
     */
    renderUtil.makeOpacityCssText = function(opacity) {
        return ';opacity:' + opacity;
    };

    /**
     * Set css opacity for browser supporting opacity property of CSS3.
     * @param {HTMLElement | Array.<HTMLElement>} elements - elements
     * @param {number} opacity - opacity
     */
    renderUtil.setOpacity = function(elements, opacity) {
        setOpacity(elements, function(element) {
            element.style.opacity = opacity;
        });
    };
}

tui.util.defineNamespace('tui.chart');
tui.chart.renderUtil = renderUtil;

module.exports = renderUtil;

},{"./../const":31,"./domHandler":59}],64:[function(require,module,exports){
/**
 * @fileoverview This is template maker.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

module.exports = {
    /**
     * This is template maker.
     * @param {string} html html
     * @returns {function} template function
     * @eaxmple
     *
     *   var template = templateMaker.template('<span>{{ name }}</span>'),
     *       result = template({name: 'John');
     *   console.log(result); // <span>John</span>
     *
     */
    template: function(html) {
        return function(data) {
            var result = html;
            tui.util.forEach(data, function(value, key) {
                var regExp = new RegExp('{{\\s*' + key + '\\s*}}', 'g');
                result = result.replace(regExp, String(value).replace('$0', '<span>$</span>0'));
            });

            return result;
        };
    }
};

},{}],65:[function(require,module,exports){
/**
 * @fileoverview UserEventListener is listener of user event.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var UserEventListener = tui.util.defineClass(/** @lends UserEventListener.prototype */ {
    /**
     * Register user event.
     * @param {string} eventName event name
     * @param {function} func event callback
     */
    register: function(eventName, func) {
        this.on(eventName, func);
    }
});

tui.util.CustomEvents.mixin(UserEventListener);

module.exports = UserEventListener;

},{}],66:[function(require,module,exports){
/**
 * @fileoverview  Circle legend component render a legend in the form of overlapping circles
 *                  by representative radius values.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');
var dom = require('../helpers/domHandler');
var renderUtil = require('../helpers/renderUtil');
var pluginFactory = require('../factories/pluginFactory');
var legendTemplate = require('./../legends/legendTemplate');

var CircleLegend = tui.util.defineClass(/** @lends CircleLegend.prototype */ {
    /**
     * css className of circle legend
     * @type {string}
     */
    className: 'tui-chart-circle-legend-area',
    /**
     * ratios for rendering circle
     * @type {Array.<number>}
     */
    circleRatios: [1, 0.5, 0.25],
    /**
     * Circle legend component render a legend in the form of overlapping circles by representative radius values.
     * @constructs CircleLegend
     * @param {object} params parameters
     *      @param {?string} params.libType - library type for graph rendering
     *      @param {string} params.chartType - chart type
     *      @param {DataProcessor} params.dataProcessor - DataProcessor
     *      @param {BoundsMaker} params.boundsMaker - BoundsMaker
     *      @param {string} params.baseFontFamily - base fontFamily of chart
     */
    init: function(params) {
        var libType = params.libType || chartConst.DEFAULT_PLUGIN;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * theme for label of circle legend area
         * @type {{fontSize: number, fontFamily: *}}
         */
        this.labelTheme = {
            fontSize: chartConst.CIRCLE_LEGEND_LABEL_FONT_SIZE,
            fontFamily: params.baseFontFamily
        };

        /**
         * Graph renderer
         * @type {object}
         */
        this.graphRenderer = pluginFactory.get(libType, 'circleLegend');
    },

    /**
     * Format label
     * @param {number} label - label
     * @param {number} decimalLength - decimal length
     * @returns {string}
     * @private
     */
    _formatLabel: function(label, decimalLength) {
        var formatFunctions = this.dataProcessor.getFormatFunctions();

        if (decimalLength === 0) {
            label = String(parseInt(label, 10));
        } else {
            label = String(label);
            label = renderUtil.formatToDecimal(label, decimalLength);
        }

        return renderUtil.formatValue(label, formatFunctions, this.chartType, 'circleLegend', 'r');
    },

    /**
     * Make label html.
     * @returns {string}
     * @private
     */
    _makeLabelHtml: function() {
        var self = this;
        var boundsMaker = this.boundsMaker;
        var dimension = boundsMaker.getDimension('circleLegend');
        var halfWidth = dimension.width / 2;
        var maxRadius = boundsMaker.getMaxRadiusForBubbleChart();
        var maxValueRadius = this.dataProcessor.getMaxValue(this.chartType, 'r');
        var decimalLength = tui.util.getDecimalLength(maxValueRadius);
        var labelHeight = renderUtil.getRenderedLabelHeight(maxValueRadius, this.labelTheme);

        return tui.util.map(this.circleRatios, function(ratio) {
            var diameter = maxRadius * ratio * 2;
            var label = self._formatLabel(maxValueRadius * ratio, decimalLength);
            var labelWidth = renderUtil.getRenderedLabelWidth(label, self.labelTheme);

            return legendTemplate.tplCircleLegendLabel({
                left: halfWidth - (labelWidth / 2),
                top: dimension.height - diameter - labelHeight,
                label: label
            });
        }).join('');
    },

    /**
     * Render label area.
     * @private
     */
    _renderLabelArea: function() {
        var labelContainer = dom.create('DIV', 'tui-chart-circle-legend-label-area');

        labelContainer.innerHTML = this._makeLabelHtml();
        this.container.appendChild(labelContainer);
    },

    /**
     * Render for circle legend area.
     * @private
     */
    _render: function() {
        var circleContainer = dom.create('DIV', 'tui-chart-circle-area');
        var boundsMaker = this.boundsMaker;
        var bound = boundsMaker.getBound('circleLegend');
        var maxRadius = boundsMaker.getMaxRadiusForBubbleChart();

        this.container.appendChild(circleContainer);

        this.graphRenderer.render(circleContainer, bound.dimension, maxRadius, this.circleRatios);

        this._renderLabelArea();
        renderUtil.renderPosition(this.container, bound.position);
    },

    /**
     * Render.
     * @returns {HTMLElement}
     */
    render: function() {
        var container = dom.create('DIV', this.className);

        this.container = container;
        this._render();

        return container;
    },

    /**
     * Rerender.
     */
    rerender: function() {
        this.container.innerHTML = '';
        this._render();
    },

    /**
     * Resize.
     */
    resize: function() {
        this.rerender();
    },

    /**
     * Get max width of label for CircleLegend.
     * @returns {number}
     * @private
     */
    _getCircleLegendLabelMaxWidth: function() {
        var maxLabel = this.dataProcessor.getFormattedMaxValue(this.chartType, 'circleLegend', 'r');
        var maxLabelWidth = renderUtil.getRenderedLabelWidth(maxLabel, {
            fontSize: this.labelTheme.fontSize,
            fontFamily: this.labelTheme.fontFamily
        });

        return maxLabelWidth;
    },

    /**
     * Get circle legend width.
     * @returns {number}
     * @private
     */
    _getCircleLegendWidth: function() {
        var maxRadius = this.boundsMaker.getMinimumPixelStepForAxis();
        var maxLabelWidth = this._getCircleLegendLabelMaxWidth();

        return Math.max((maxRadius * 2), maxLabelWidth) + chartConst.CIRCLE_LEGEND_PADDING;
    },

    /**
     * Register dimension of circle legend.
     * @private
     */
    registerCircleLegendDimension: function() {
        var circleLegendWidth = this._getCircleLegendWidth();
        var legendWidth = this.boundsMaker.getDimension('calculationLegend').width || chartConst.MIN_LEGEND_WIDTH;

        circleLegendWidth = Math.min(circleLegendWidth, legendWidth);

        this.boundsMaker.registerBaseDimension('circleLegend', {
            width: circleLegendWidth,
            height: circleLegendWidth
        });
    }
});

module.exports = CircleLegend;

},{"../const":31,"../factories/pluginFactory":52,"../helpers/domHandler":59,"../helpers/renderUtil":63,"./../legends/legendTemplate":70}],67:[function(require,module,exports){
/**
 * @fileoverview  Legend component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var LegendModel = require('./legendModel'),
    LegendDimensionModel = require('./legendDimensionModel'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    predicate = require('../helpers/predicate'),
    eventListener = require('../helpers/eventListener'),
    renderUtil = require('../helpers/renderUtil'),
    legendTemplate = require('./../legends/legendTemplate');

var Legend = tui.util.defineClass(/** @lends Legend.prototype */ {
    /**
     * Legend component.
     * @constructs Legend
     * @param {object} params parameters
     *      @param {object} params.theme axis theme
     *      @param {?Array.<string>} params.chartTypes chart types
     *      @param {string} params.chart type
     */
    init: function(params) {
        var legendData;

        /**
         * legend theme
         * @type {Object}
         */
        this.theme = params.theme;

        /**
         * options
         * @type {Object}
         */
        this.options = params.options || {};

        /**
         * chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * series names
         * @type {?Array.<string>}
         */
        this.seriesNames = params.seriesNames || [this.chartType];

        /**
         * user event object
         */
        this.userEvent = params.userEvent;

        /**
         * Legend view className
         */
        this.className = 'tui-chart-legend-area';

        /**
         * checked indexes
         * @type {Array}
         */
        this.checkedIndexes = [];

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        this.dataProcessor = params.dataProcessor;

        legendData = params.dataProcessor.getLegendData();
        /**
         * legend model
         */
        this.legendModel = new LegendModel({
            theme: this.theme,
            labels: params.dataProcessor.getLegendLabels(),
            legendData: legendData,
            seriesNames: this.seriesNames,
            chartType: this.chartType
        });

        this.dimensionModel = new LegendDimensionModel({
            legendLabels: tui.util.pluck(legendData, 'label'),
            chartType: this.chartType,
            options: this.options,
            theme: this.theme
        });
    },

    /**
     * Register legend dimension.
     */
    registerDimension: function() {
        var chartWidth = this.boundsMaker.getDimension('chart').width;
        var legendDimension = this.dimensionModel.makeDimension(chartWidth);

        this.boundsMaker.registerBaseDimension('legend', legendDimension);

        if (predicate.hasVerticalLegendWidth(this.options)) {
            this.boundsMaker.registerBaseDimension('calculationLegend', {
                width: legendDimension.width
            });
        }
    },

    /**
     * Render legend area.
     * @param {HTMLElement} legendContainer legend container
     * @private
     */
    _renderLegendArea: function(legendContainer) {
        legendContainer.innerHTML = this._makeLegendHtml(this.legendModel.getData());
        renderUtil.renderPosition(legendContainer, this.boundsMaker.getPosition('legend'));
        legendContainer.style.cssText += ';' + renderUtil.makeFontCssText(this.theme.label);
    },

    /**
     * Render legend component.
     * @returns {HTMLElement} legend element
     */
    render: function() {
        var container = dom.create('DIV', this.className);

        this.legendContainer = container;

        if (predicate.isHorizontalLegend(this.options.align)) {
            dom.addClass(container, 'horizontal');
        }

        this._renderLegendArea(container);
        this._attachEvent(container);

        return container;
    },

    /**
     * Rerender.
     */
    rerender: function() {
        this._renderLegendArea(this.legendContainer);
    },

    /**
     * Resize legend component.
     */
    resize: function() {
        this.rerender();
    },

    /**
     * Make cssText of legend rect.
     * @param {{
     *      chartType: string,
     *      theme: {color: string, borderColor: ?string, singleColor: ?string}
     * }} legendDatum legend datum
     * @param {number} baseMarginTop base margin-top
     * @returns {string} cssText of legend rect
     * @private
     */
    _makeLegendRectCssText: function(legendDatum, baseMarginTop) {
        var theme = legendDatum.theme,
            borderCssText = theme.borderColor ? renderUtil.concatStr(';border:1px solid ', theme.borderColor) : '',
            rectMargin, marginTop;
        if (legendDatum.chartType === 'line') {
            marginTop = baseMarginTop + chartConst.LINE_MARGIN_TOP;
        } else {
            marginTop = baseMarginTop;
        }

        rectMargin = renderUtil.concatStr(';margin-top:', marginTop, 'px');

        return renderUtil.concatStr('background-color:', theme.singleColor || theme.color, borderCssText, rectMargin);
    },


    /**
     * Make labels width.
     * @param {Array.<{chartType: ?string, label: string}>} legendData legend data
     * @returns {Array.<number>} labels width
     * @private
     */
    _makeLabelsWidth: function(legendData) {
        var self = this;

        return tui.util.map(legendData, function(item) {
            var labelWidth = renderUtil.getRenderedLabelWidth(item.label, self.theme.label);

            return labelWidth + chartConst.LEGEND_AREA_PADDING;
        });
    },

    /**
     * Make legend html.
     * @param {Array.<{chartType: ?string, label: string}>} legendData legend data
     * @returns {string} legend html
     * @private
     */
    _makeLegendHtml: function(legendData) {
        var self = this;
        var template = legendTemplate.tplLegend;
        var checkBoxTemplate = legendTemplate.tplCheckbox;
        var labelsWidth = this._makeLabelsWidth(legendData);
        var labelHeight = renderUtil.getRenderedLabelHeight(legendData[0].label, legendData[0].theme);
        var isHorizontalLegend = predicate.isHorizontalLegend(this.options.align);
        var height = labelHeight + (chartConst.LABEL_PADDING_TOP * 2);
        var baseMarginTop = parseInt((height - chartConst.LEGEND_RECT_WIDTH) / 2, 10) - 1;
        var html = tui.util.map(legendData, function(legendDatum, index) {
            var rectCssText = self._makeLegendRectCssText(legendDatum, baseMarginTop);
            var checkbox = self.options.showCheckbox === false ? '' : checkBoxTemplate({
                index: index,
                checked: self.legendModel.isCheckedIndex(index) ? ' checked' : ''
            });
            var data = {
                rectCssText: rectCssText,
                height: height,
                labelHeight: labelHeight,
                unselected: self.legendModel.isUnselectedIndex(index) ? ' unselected' : '',
                labelWidth: isHorizontalLegend ? ';width:' + labelsWidth[index] + 'px' : '',
                iconType: legendDatum.chartType || 'rect',
                label: legendDatum.label,
                checkbox: checkbox,
                index: index
            };

            return template(data);
        }).join('');

        return html;
    },

    /**
     * Find legend element.
     * @param {HTMLElement} elTarget target element
     * @returns {HTMLElement} legend element
     * @private
     */
    _findLegendLabelElement: function(elTarget) {
        var legendContainer;

        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_LEGEND_LABEL)) {
            legendContainer = elTarget;
        } else {
            legendContainer = dom.findParentByClass(elTarget, chartConst.CLASS_NAME_LEGEND_LABEL);
        }

        return legendContainer;
    },

    /**
     * Fire legend checkbox event.
     * @private
     */
    _fireLegendCheckboxEvent: function() {
        this.fire('changeCheckedLegends', this.legendModel.getCheckedIndexes());
    },

    /**
     * Fire legend event.
     * @param {{chartType: string, index: number}} data data
     * @private
     */
    _fireLegendSelectionEvent: function(data) {
        var self = this;
        var seriesNames = this.seriesNames;
        var index = this.legendModel.getSelectedIndex();
        var legendIndex = !tui.util.isNull(index) ? data.seriesIndex : index;

        tui.util.forEachArray(seriesNames, function(seriesName) {
            var chartType = self.dataProcessor.findChartType(seriesName);
            self.fire(renderUtil.makeCustomEventName('select', chartType, 'legend'), data.chartType, legendIndex);
        });
    },

    /**
     * Fire user event.
     * @param {{label: string, chartType: string, index: number}} data data
     * @private
     */
    _fireUserEvent: function(data) {
        this.userEvent.fire('selectLegend', {
            legend: data.label,
            chartType: data.chartType,
            index: data.index
        });
    },

    /**
     * Select legend.
     * @param {number} index index
     * @private
     */
    _selectLegend: function(index) {
        var data = this.legendModel.getDatum(index);

        this.legendModel.toggleSelectedIndex(index);

        if (!tui.util.isNull(this.legendModel.getSelectedIndex()) && !this.legendModel.isCheckedSelectedIndex()) {
            this.legendModel.checkSelectedIndex();
            this._fireLegendCheckboxEvent();
        }

        this._renderLegendArea(this.legendContainer);

        this._fireLegendSelectionEvent(data);
        this._fireUserEvent(data);
    },

    /**
     * Get checked indexes.
     * @returns {Array} checked indexes
     * @private
     */
    _getCheckedIndexes: function() {
        var checkedIndexes = [];

        tui.util.forEachArray(this.legendContainer.getElementsByTagName('input'), function(checkbox, index) {
            if (checkbox.checked) {
                checkedIndexes.push(index);
            }
        });

        return checkedIndexes;
    },

    /**
     * Check legend.
     * @private
     */
    _checkLegend: function() {
        var checkedIndexes = this._getCheckedIndexes();
        var checkedCount = checkedIndexes.length;
        var isPieTypeCharts = tui.util.all(this.seriesNames, predicate.isPieTypeChart);
        var data;

        if ((isPieTypeCharts && checkedCount === 1) || checkedCount === 0) {
            this._renderLegendArea(this.legendContainer);
        } else {
            this.legendModel.updateCheckedData(checkedIndexes);

            data = this.legendModel.getSelectedDatum();

            if (!this.legendModel.isCheckedSelectedIndex()) {
                this.legendModel.updateSelectedIndex(null);
            }

            this._renderLegendArea(this.legendContainer);

            this._fireLegendCheckboxEvent();

            if (data) {
                this._fireLegendSelectionEvent(data, true);
            }
        }
    },

    /**
     * On click event handler.
     * @param {MouseEvent} e mouse event
     * @private
     */
    _onClick: function(e) {
        var elTarget = e.target || e.srcElement,
            legendContainer, index;

        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_LEGEND_CHECKBOX)) {
            this._checkLegend();

            return;
        }

        legendContainer = this._findLegendLabelElement(elTarget);

        if (!legendContainer) {
            return;
        }

        index = parseInt(legendContainer.getAttribute('data-index'), 10);
        this._selectLegend(index);
    },

    /**
     * Attach browser event.
     * @param {HTMLElement} target target element
     * @private
     */
    _attachEvent: function(target) {
        eventListener.on(target, 'click', this._onClick, this);
    }
});

tui.util.CustomEvents.mixin(Legend);

module.exports = Legend;

},{"../const":31,"../helpers/domHandler":59,"../helpers/eventListener":60,"../helpers/predicate":61,"../helpers/renderUtil":63,"./../legends/legendTemplate":70,"./legendDimensionModel":68,"./legendModel":69}],68:[function(require,module,exports){
/**
 * @fileoverview LegendDimensionModel is model for calculating dimension of legend.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');

var LegendDimensionModel = tui.util.defineClass(/** @lends LegendDimensionModel.prototype */ {
    /**
     * LegendDimensionModel is model for calculating dimension of legend.
     * @constructs LegendDimensionModel
     * @param {object} params parameters
     *      @param {string} params.chartType - type of chart
     *      @param {object} params.options - legend options
     *      @param {object} params.theme - legend theme
     *      @param {Array.<string | number>} params.legendLabels - legend labels
     */
    init: function(params) {
        this.chartType = params.chartType;

        this.options = params.options;

        this.theme = params.theme;

        this.legendLabels = params.legendLabels;

        this.legendCheckboxWidth = this.options.showCheckbox === false ? 0 : chartConst.LEGEND_CHECKBOX_WIDTH;
    },

    /**
     * Make legend width.
     * @param {number} labelWidth label width
     * @returns {number}
     * @private
     */
    _makeLegendWidth: function(labelWidth) {
        return labelWidth + this.legendCheckboxWidth + chartConst.LEGEND_RECT_WIDTH +
            chartConst.LEGEND_LABEL_LEFT_PADDING + chartConst.LEGEND_AREA_PADDING;
    },

    /**
     * Calculate sum of legends width.
     * @param {Array.<string>} labels legend labels
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {number}
     * @private
     */
    _calculateLegendsWidthSum: function(labels, labelTheme) {
        var self = this;

        return tui.util.sum(tui.util.map(labels, function(label) {
            return self._makeLegendWidth(renderUtil.getRenderedLabelWidth(label, labelTheme));
        }));
    },

    /**
     * Divide legend labels.
     * @param {Array.<string>} labels legend labels
     * @param {number} count division count
     * @returns {Array.<Array.<string>>}
     * @private
     */
    _divideLegendLabels: function(labels, count) {
        var limitCount = Math.round(labels.length / count),
            results = [],
            temp = [];

        tui.util.forEachArray(labels, function(label) {
            if (temp.length < limitCount) {
                temp.push(label);
            } else {
                results.push(temp);
                temp = [label];
            }
        });

        if (temp.length) {
            results.push(temp);
        }

        return results;
    },

    /**
     * Get max line width.
     * @param {Array.<string>} dividedLabels - divided labels
     * @param {{fontFamily: ?string, fontSize: ?string}} labelTheme - label theme
     * @returns {number}
     * @private
     */
    _getMaxLineWidth: function(dividedLabels, labelTheme) {
        var self = this;
        var lineWidths = tui.util.map(dividedLabels, function(_labels) {
            return self._calculateLegendsWidthSum(_labels, labelTheme);
        });

        return tui.util.max(lineWidths);
    },

    /**
     * Make division labels and max line width.
     * @param {Array.<string>} labels legend labels
     * @param {number} chartWidth chart width
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {{dividedLabels: Array.<Array.<string>>, maxLineWidth: number}}
     * @private
     */
    _makeDividedLabelsAndMaxLineWidth: function(labels, chartWidth, labelTheme) {
        var divideCount = 1,
            maxLineWidth = 0,
            prevMaxWidth = 0,
            dividedLabels, prevLabels;

        do {
            dividedLabels = this._divideLegendLabels(labels, divideCount);
            maxLineWidth = this._getMaxLineWidth(dividedLabels, labelTheme);

            if (prevMaxWidth === maxLineWidth) {
                dividedLabels = prevLabels;
                break;
            }

            prevMaxWidth = maxLineWidth;
            prevLabels = dividedLabels;
            divideCount += 1;
        } while (maxLineWidth >= chartWidth);

        return {
            dividedLabels: dividedLabels,
            maxLineWidth: maxLineWidth
        };
    },

    /**
     * Calculate height of horizontal legend.
     * @param {Array.<Array.<string>>} dividedLabels divided labels
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {number}
     * @private
     */
    _calculateHorizontalLegendHeight: function(dividedLabels, labelTheme) {
        return tui.util.sum(tui.util.map(dividedLabels, function(labels) {
            return renderUtil.getRenderedLabelsMaxHeight(labels, labelTheme);
        }));
    },

    /**
     * Make dimension of horizontal legend.
     * @param {number} chartWidth chart width
     * @returns {{width: number, height: (number)}}
     * @private
     */
    _makeHorizontalDimension: function(chartWidth) {
        var labelTheme = this.theme.label,
            labelsAndMaxWidth = this._makeDividedLabelsAndMaxLineWidth(this.legendLabels, chartWidth, labelTheme),
            horizontalLegendHeight = this._calculateHorizontalLegendHeight(labelsAndMaxWidth.dividedLabels, labelTheme),
            legendHeight = horizontalLegendHeight + (chartConst.LEGEND_AREA_PADDING * 2);

        return {
            width: Math.max(labelsAndMaxWidth.maxLineWidth, chartConst.MIN_LEGEND_WIDTH),
            height: legendHeight
        };
    },

    /**
     * Make dimension of vertical legend.
     * @returns {{width: (number)}}
     * @private
     */
    _makeVerticalDimension: function() {
        var maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(this.legendLabels, this.theme.label);
        var legendWidth = this._makeLegendWidth(maxLabelWidth);

        return {
            width: legendWidth,
            height: 0
        };
    },

    /**
     * Make legend dimension.
     * @param {number} chartWidth chart width
     * @returns {{width: number, height: number}}
     */
    makeDimension: function(chartWidth) {
        var dimension = {};

        if (!this.options.visible) {
            dimension.width = 0;
        } else if (predicate.isHorizontalLegend(this.options.align)) {
            dimension = this._makeHorizontalDimension(chartWidth);
        } else {
            dimension = this._makeVerticalDimension();
        }

        return dimension;
    }
});

module.exports = LegendDimensionModel;

},{"../const":31,"../helpers/predicate":61,"../helpers/renderUtil":63}],69:[function(require,module,exports){
/**
 * @fileoverview LegendModel is legend model.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var defaultTheme = require('../themes/defaultTheme');

var concat = Array.prototype.concat;

var LegendModel = tui.util.defineClass(/** @lends LegendModel.prototype */ {
    /**
     * LegendModel is legend model.
     * @constructs LegendModel
     * @param {object} params parameters
     *      @param {number} params.labels legend labels
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        /**
         * legend theme
         * @type {Object}
         */
        this.theme = params.theme;

        /**
         * legend labels
         * @type {Array.<string> | {column: ?Array.<string>, line: ?Array.<string>}}
         */
        this.labels = params.labels;

        /**
         * label infos
         * @type {Array.<{chartType: string, label: string, index: number}>}
         */
        this.legendData = params.legendData;

        /**
         * chart types
         * @type {?Array.<string>}
         */
        this.seriesNames = params.seriesNames || [];

        /**
         * chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * Legend data
         * @type {?Array}
         */
        this.data = null;

        /**
         * Selected legend index.
         * @type {?number}
         */
        this.selectedIndex = null;

        /**
         * sending data to series
         * @type {object}
         */
        this.checkedIndexesMap = {};

        /**
         * checked indexes
         * @type {Array}
         */
        this.checkedWholeIndexes = [];

        this._initCheckedIndexes();
        this._setData();
    },

    /**
     * Initialize checked data.
     * @private
     */
    _initCheckedIndexes: function() {
        var checkedWholeIndexes = [];
        tui.util.forEachArray(this.legendData, function(legendDatum, index) {
            checkedWholeIndexes[index] = true;
        });
        this.checkedWholeIndexes = checkedWholeIndexes;
    },

    /**
     * Make label info that applied theme.
     * @param {Array.<object>} legendData legend data
     * @param {{colors: Array.<number>, singleColor: ?string, bordercolor: ?string}} theme legend theme
     * @param {Array.<boolean>} checkedIndexes checked indexes
     * @returns {Array.<object>} labels
     * @private
     */
    _makeLabelInfoAppliedTheme: function(legendData, theme, checkedIndexes) {
        var seriesIndex = 0;

        return tui.util.map(legendData, function(datum, index) {
            var itemTheme = {
                color: theme.colors[index]
            };

            if (theme.singleColors && theme.singleColors.length) {
                itemTheme.singleColor = theme.singleColors[index];
            }

            if (theme.borderColor) {
                itemTheme.borderColor = theme.borderColor;
            }

            datum.theme = itemTheme;
            datum.index = index;

            if (!checkedIndexes || !tui.util.isUndefined(checkedIndexes[index])) {
                datum.seriesIndex = seriesIndex;
                seriesIndex += 1;
            } else {
                datum.seriesIndex = -1;
            }

            return datum;
        });
    },

    /**
     * Set legend data.
     * @private
     */
    _setData: function() {
        var self = this;
        var legendData = this.legendData;
        var data, defaultLegendTheme, startIndex, startThemeIndex;

        if (!this.seriesNames || this.seriesNames.length < 2) {
            data = this._makeLabelInfoAppliedTheme(legendData, this.theme, this.checkedIndexesMap[this.chartType]);
        } else {
            startIndex = 0;
            startThemeIndex = 0;
            defaultLegendTheme = {
                colors: defaultTheme.series.colors
            };
            data = concat.apply([], tui.util.map(this.seriesNames, function(seriesName) {
                var chartTheme = self.theme[seriesName];
                var labelLen = self.labels[seriesName].length;
                var endIndex = startIndex + labelLen;
                var slicedLegendData, checkedIndexes, themeEndIndex, datum;

                if (!chartTheme) {
                    themeEndIndex = startThemeIndex + labelLen;
                    chartTheme = JSON.parse(JSON.stringify(defaultLegendTheme));
                    chartTheme.colors = chartTheme.colors.slice(startThemeIndex, themeEndIndex);
                    startThemeIndex = themeEndIndex;
                }

                slicedLegendData = legendData.slice(startIndex, endIndex);
                checkedIndexes = self.checkedIndexesMap[seriesName];
                datum = self._makeLabelInfoAppliedTheme(slicedLegendData, chartTheme, checkedIndexes);
                startIndex = endIndex;

                return datum;
            }));
        }

        this.data = data;
    },

    /**
     * Get legend data.
     * @returns {Array.<{chartType: string, label: string, theme: object}>} legend data
     */
    getData: function() {
        return this.data;
    },

    /**
     * Get legend datum by index.
     * @param {number} index legend index
     * @returns {{chartType: string, label: string, theme: object}} legend datum
     */
    getDatum: function(index) {
        return this.data[index];
    },

    /**
     * Get selected datum.
     * @returns {{chartType: string, label: string, theme: Object}} legend datum
     */
    getSelectedDatum: function() {
        return this.getDatum(this.selectedIndex);
    },

    /**
     * Update selected index.
     * @param {?number} value value
     */
    updateSelectedIndex: function(value) {
        this.selectedIndex = value;
    },

    /**
     * Toggle selected index.
     * @param {number} index legend index
     */
    toggleSelectedIndex: function(index) {
        var selectedIndex;

        if (this.selectedIndex === index) {
            selectedIndex = null;
        } else {
            selectedIndex = index;
        }

        this.updateSelectedIndex(selectedIndex);
    },

    /**
     * Get selected index.
     * @returns {number} selected index
     */
    getSelectedIndex: function() {
        return this.selectedIndex;
    },

    /**
     * Whether unselected index or not.
     * @param {number} index legend index
     * @returns {boolean} true if selected
     */
    isUnselectedIndex: function(index) {
        return !tui.util.isNull(this.selectedIndex) && (this.selectedIndex !== index);
    },

    /**
     * Whether checked selected index or not.
     * @returns {boolean} true if checked
     */
    isCheckedSelectedIndex: function() {
        return this.isCheckedIndex(this.selectedIndex);
    },

    /**
     * Update checked index.
     * @param {number} index legend index
     * @private
     */
    _updateCheckedIndex: function(index) {
        this.checkedWholeIndexes[index] = true;
    },

    /**
     * Whether checked index.
     * @param {number} index legend index
     * @returns {boolean} true if checked
     */
    isCheckedIndex: function(index) {
        return !!this.checkedWholeIndexes[index];
    },


    /**
     * Add sending datum.
     * @param {number} index legend index
     */
    _addSendingDatum: function(index) {
        var legendDatum = this.getDatum(index);
        if (!this.checkedIndexesMap[legendDatum.chartType]) {
            this.checkedIndexesMap[legendDatum.chartType] = [];
        }
        this.checkedIndexesMap[legendDatum.chartType][legendDatum.index] = true;
    },

    /**
     * Check selected index;
     */
    checkSelectedIndex: function() {
        this._updateCheckedIndex(this.selectedIndex);
        this._addSendingDatum(this.selectedIndex);
        this._setData();
    },

    /**
     * Get checked indexes.
     * @returns {{column: ?Array.<boolean>, line: ?Array.<boolean>} | Array.<boolean>} sending data
     */
    getCheckedIndexes: function() {
        return this.checkedIndexesMap[this.chartType] || this.checkedIndexesMap;
    },

    /**
     * Reset checked data.
     * @private
     */
    _resetCheckedData: function() {
        this.checkedWholeIndexes = [];
        this.checkedIndexesMap = {};
    },

    /**
     * Update checked data.
     * @param {Array.<number>} indexes indxes
     */
    updateCheckedData: function(indexes) {
        var self = this;

        this._resetCheckedData();
        tui.util.forEachArray(indexes, function(index) {
            self._updateCheckedIndex(index);
            self._addSendingDatum(index);
        });
        this._setData();
    }
});

module.exports = LegendModel;

},{"../themes/defaultTheme":107}],70:[function(require,module,exports){
/**
 * @fileoverview This is templates of legend view.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var htmls = {
    HTML_CHECKBOX: '<div class="tui-chart-legend-checkbox-area"><input class="tui-chart-legend-checkbox"' +
        ' type="checkbox" value="{{ index }}"{{ checked }} /></div>',
    HTML_LEGEND: '<div class="tui-chart-legend{{ unselected }}" style="height:{{ height }}px">' +
        '{{ checkbox }}<div class="tui-chart-legend-rect {{ iconType }}" style="{{ rectCssText }}"></div>' +
        '<div class="tui-chart-legend-label" style="height:{{ labelHeight }}px{{ labelWidth }}"' +
            ' data-index="{{ index }}">{{ label }}</div></div>',
    HTML_TICK: '<div class="tui-chart-map-legend-tick" style="{{ position }}"></div>' +
        '<div class="tui-chart-map-legend-tick-label" style="{{ labelPosition }}">{{ label }}</div>',
    HTML_CIRCLE_LEGEND_LABEL: '<div class="tui-chart-circle-legend-label"' +
            ' style="left: {{ left }}px;top: {{ top }}px">{{ label }}</div>'
};

module.exports = {
    tplCheckbox: templateMaker.template(htmls.HTML_CHECKBOX),
    tplLegend: templateMaker.template(htmls.HTML_LEGEND),
    tplTick: templateMaker.template(htmls.HTML_TICK),
    tplCircleLegendLabel: templateMaker.template(htmls.HTML_CIRCLE_LEGEND_LABEL)
};

},{"../helpers/templateMaker":64}],71:[function(require,module,exports){
/**
 * @fileoverview  Spectrum Legend component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');
var predicate = require('../helpers/predicate');
var dom = require('../helpers/domHandler');
var renderUtil = require('../helpers/renderUtil');
var pluginFactory = require('../factories/pluginFactory');
var legendTemplate = require('./../legends/legendTemplate');

var SpectrumLegend = tui.util.defineClass(/** @lends SpectrumLegend.prototype */ {
    /**
     * Spectrum Legend component.
     * @constructs SpectrumLegend
     * @param {object} params parameters
     *      @param {object} params.theme axis theme
     *      @param {?Array.<string>} params.options legend options
     *      @param {MapChartDataProcessor} params.dataProcessor data processor
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     */
    init: function(params) {
        var libType = params.libType || chartConst.DEFAULT_PLUGIN;

        /**
         * class name.
         * @type {string}
         */
        this.className = 'tui-chart-legend-area';

        this.chartType = params.chartType;

        /**
         * legend theme
         * @type {Object}
         */
        this.theme = params.theme;

        /**
         * options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Graph renderer
         * @type {object}
         */
        this.graphRenderer = pluginFactory.get(libType, 'mapLegend');

        /**
         * Whether horizontal legend or not.
         * @type {boolean}
         */
        this.isHorizontal = predicate.isHorizontalLegend(this.options.align);
    },

    /**
     * Make vertical legend dimension.
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeVerticalDimension: function() {
        var maxValue = tui.util.max(this.dataProcessor.getValues());
        var formatFunctions = this.dataProcessor.getFormatFunctions();
        var valueStr = renderUtil.formatValue(maxValue, formatFunctions, this.chartType, 'legend');
        var labelWidth = renderUtil.getRenderedLabelWidth(valueStr, this.theme.label);
        var padding = chartConst.LEGEND_AREA_PADDING + chartConst.MAP_LEGEND_LABEL_PADDING;

        return {
            width: chartConst.MAP_LEGEND_GRAPH_SIZE + labelWidth + padding,
            height: chartConst.MAP_LEGEND_SIZE
        };
    },

    /**
     * Make horizontal legend dimension
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeHorizontalDimension: function() {
        var maxValue = tui.util.max(this.dataProcessor.getValues()),
            labelHeight = renderUtil.getRenderedLabelHeight(maxValue, this.theme.label),
            padding = chartConst.LEGEND_AREA_PADDING + chartConst.MAP_LEGEND_LABEL_PADDING;

        return {
            width: chartConst.MAP_LEGEND_SIZE,
            height: chartConst.MAP_LEGEND_GRAPH_SIZE + labelHeight + padding
        };
    },

    /**
     * Register dimension.
     */
    registerDimension: function() {
        var dimension;

        if (this.isHorizontal) {
            dimension = this._makeHorizontalDimension();
        } else {
            dimension = this._makeVerticalDimension();
        }

        this.boundsMaker.registerBaseDimension('legend', dimension);
        this.boundsMaker.registerBaseDimension('calculationLegend', dimension);
    },

    /**
     * Make base data to make tick html.
     * @returns {{startPositionValue: number, step: number, positionType: string, labelSize: ?number}} base data
     * @private
     */
    _makeBaseDataToMakeTickHtml: function() {
        var dimension = this.boundsMaker.getDimension('legend'),
            stepCount = this.axesData.tickCount - 1,
            baseData = {},
            firstLabel;

        if (this.isHorizontal) {
            baseData.startPositionValue = 5;
            baseData.step = dimension.width / stepCount;
            baseData.positionType = 'left:';
        } else {
            baseData.startPositionValue = 0;
            baseData.step = dimension.height / stepCount;
            baseData.positionType = 'top:';
            firstLabel = this.axesData.labels[0];
            baseData.labelSize = parseInt(renderUtil.getRenderedLabelHeight(firstLabel, this.theme.label) / 2, 10) - 1;
        }

        return baseData;
    },
    /**
     * Make tick html.
     * @returns {string} tick html.
     * @private
     */
    _makeTickHtml: function() {
        var self = this,
            baseData = this._makeBaseDataToMakeTickHtml(),
            positionValue = baseData.startPositionValue,
            htmls;

        htmls = tui.util.map(this.axesData.labels, function(label) {
            var labelSize, html;

            if (self.isHorizontal) {
                labelSize = parseInt(renderUtil.getRenderedLabelWidth(label, self.theme.label) / 2, 10);
            } else {
                labelSize = baseData.labelSize;
            }

            html = legendTemplate.tplTick({
                position: baseData.positionType + positionValue + 'px',
                labelPosition: baseData.positionType + (positionValue - labelSize) + 'px',
                label: label
            });

            positionValue += baseData.step;

            return html;
        });

        return htmls.join('');
    },

    /**
     * Render tick area.
     * @returns {HTMLElement} tick countainer
     * @private
     */
    _renderTickArea: function() {
        var tickContainer = dom.create('div', 'tui-chart-legend-tick-area');

        tickContainer.innerHTML = this._makeTickHtml();

        if (this.isHorizontal) {
            dom.addClass(tickContainer, 'horizontal');
        }

        return tickContainer;
    },

    /**
     * Make graph dimension of vertical legend
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeVerticalGraphDimension: function() {
        return {
            width: chartConst.MAP_LEGEND_GRAPH_SIZE,
            height: this.boundsMaker.getDimension('legend').height
        };
    },

    /**
     * Make graph dimension of horizontal legend
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeHorizontalGraphDimension: function() {
        return {
            width: this.boundsMaker.getDimension('legend').width + 10,
            height: chartConst.MAP_LEGEND_GRAPH_SIZE
        };
    },

    /**
     * Render graph.
     * @param {HTMLElement} container container element
     * @private
     */
    _renderGraph: function(container) {
        var dimension;

        if (this.isHorizontal) {
            dimension = this._makeHorizontalGraphDimension();
        } else {
            dimension = this._makeVerticalGraphDimension();
        }

        this.graphRenderer.render(container, dimension, this.colorSpectrum, this.isHorizontal);
    },

    /**
     * Render legend area.
     * @param {HTMLElement} container legend container
     * @private
     */
    _renderLegendArea: function(container) {
        var tickContainer;

        container.innerHTML = '';
        renderUtil.renderPosition(container, this.boundsMaker.getPosition('legend'));
        this._renderGraph(container);
        tickContainer = this._renderTickArea();
        container.appendChild(tickContainer);
        container.style.cssText += ';' + renderUtil.makeFontCssText(this.theme.label);
    },

    /**
     * Render legend component.
     * @param {{colorSpectrum: ColorSpectrum, axesData: object}} data rendering data
     * @returns {HTMLElement} legend element
     */
    render: function(data) {
        var container = dom.create('DIV', this.className);

        this.legendContainer = container;
        this.colorSpectrum = data.colorSpectrum;
        this.axesData = data.axesData;
        this._renderLegendArea(container);

        return container;
    },

    /**
     * Resize legend component.
     */
    resize: function() {
        this._renderLegendArea(this.legendContainer);
    },

    /**
     * On show wedge.
     * @param {number} ratio ratio
     */
    onShowWedge: function(ratio) {
        this.graphRenderer.showWedge(chartConst.MAP_LEGEND_SIZE * ratio);
    },

    /**
     * On hide wedge.
     */
    onHideWedge: function() {
        this.graphRenderer.hideWedge();
    }
});

tui.util.CustomEvents.mixin(SpectrumLegend);

module.exports = SpectrumLegend;

},{"../const":31,"../factories/pluginFactory":52,"../helpers/domHandler":59,"../helpers/predicate":61,"../helpers/renderUtil":63,"./../legends/legendTemplate":70}],72:[function(require,module,exports){
/**
 * @fileoverview Plot component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('../helpers/domHandler'),
    calculator = require('../helpers/calculator'),
    renderUtil = require('../helpers/renderUtil'),
    plotTemplate = require('./plotTemplate');

var Plot = tui.util.defineClass(/** @lends Plot.prototype */ {
    /**
     * Plot component.
     * @constructs Plot
     * @param {object} params parameters
     *      @param {number} params.vTickCount vertical tick count
     *      @param {number} params.hTickCount horizontal tick count
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        /**
         * Plot view className
         * @type {string}
         */
        this.className = 'tui-chart-plot-area';

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Options
         * @type {object}
         */
        this.options = params.options || {};
        this.options.showLine = tui.util.isUndefined(this.options.showLine) ? true : this.options.showLine;

        /**
         * Theme
         * @type {object}
         */
        this.theme = params.theme || {};

        /**
         * Plot data.
         * @type {object}
         */
        this.data = {};
    },

    /**
     * Render plot area.
     * @param {HTMLElement} plotContainer plot area element
     * @param {object} data rendering data
     * @private
     */
    _renderPlotArea: function(plotContainer, data) {
        var dimension = this.boundsMaker.getDimension('plot');
        this.data = data;

        renderUtil.renderDimension(plotContainer, dimension);
        renderUtil.renderPosition(plotContainer, this.boundsMaker.getPosition('plot'));

        if (this.options.showLine) {
            this._renderLines(plotContainer, dimension);
        }
    },

    /**
     * Render plot component.
     * @param {object} data rendering data
     * @returns {HTMLElement} plot element
     */
    render: function(data) {
        var container = dom.create('DIV', this.className);
        this._renderPlotArea(container, data);
        this.plotContainer = container;

        return container;
    },

    /**
     * Rerender.
     * @param {object} data rendering
     */
    rerender: function(data) {
        this.plotContainer.innerHTML = '';
        this._renderPlotArea(this.plotContainer, data);
    },

    /**
     * Resize plot component.
     * @param {object} data rendering data
     */
    resize: function(data) {
        this.rerender(data);
    },

    /**
     * Render plot lines.
     * @param {HTMLElement} el element
     * @param {{width: number, height: number}} dimension plot area dimension
     * @private
     */
    _renderLines: function(el, dimension) {
        var hPositions = this._makeHorizontalPixelPositions(dimension.width),
            vPositions = this._makeVerticalPixelPositions(dimension.height),
            theme = this.theme,
            lineHtml = '';

        lineHtml += this._makeLineHtml({
            positions: hPositions,
            size: dimension.height,
            className: 'vertical',
            positionType: 'left',
            sizeType: 'height',
            lineColor: theme.lineColor
        });
        lineHtml += this._makeLineHtml({
            positions: vPositions,
            size: dimension.width,
            className: 'horizontal',
            positionType: 'bottom',
            sizeType: 'width',
            lineColor: theme.lineColor
        });

        el.innerHTML = lineHtml;

        renderUtil.renderBackground(el, theme.background);
    },

    /**
     * Make html of plot line.
     * @param {object} params parameters
     *      @param {Array.<object>} params.positions positions
     *      @param {number} params.size width or height
     *      @param {string} params.className line className
     *      @param {string} params.positionType position type (left or bottom)
     *      @param {string} params.sizeType size type (size or height)
     *      @param {string} params.lineColor line color
     * @returns {string} html
     * @private
     */
    _makeLineHtml: function(params) {
        var template = plotTemplate.tplPlotLine;
        var lineHtml = tui.util.map(params.positions, function(position) {
            var cssTexts = [
                    renderUtil.concatStr(params.positionType, ':', position, 'px'),
                    renderUtil.concatStr(params.sizeType, ':', params.size, 'px')
                ], data;

            if (params.lineColor) {
                cssTexts.push(renderUtil.concatStr('background-color:', params.lineColor));
            }

            data = {className: params.className, cssText: cssTexts.join(';')};

            return template(data);
        }).join('');

        return lineHtml;
    },

    /**
     * Make pixel value of vertical positions
     * @param {number} height plot height
     * @returns {Array.<number>} positions
     * @private
     */
    _makeVerticalPixelPositions: function(height) {
        var positions = calculator.makeTickPixelPositions(height, this.data.vTickCount);

        positions.shift();

        return positions;
    },

    /**
     * Make divided positions of plot.
     * @param {number} width plot width
     * @returns {Array.<number>}
     * @private
     */
    _makeDividedPlotPositions: function(width) {
        var tickCount = parseInt(this.data.hTickCount / 2, 10) + 1,
            yAxisWidth = this.boundsMaker.getDimension('yAxis').width,
            leftWidth, rightWidth, leftPositions, rightPositions;

        width -= yAxisWidth;
        leftWidth = Math.round((width) / 2);
        rightWidth = width - leftWidth;

        leftPositions = calculator.makeTickPixelPositions(leftWidth, tickCount);
        rightPositions = calculator.makeTickPixelPositions(rightWidth, tickCount, leftWidth + yAxisWidth);

        leftPositions.pop();
        rightPositions.shift();

        return leftPositions.concat(rightPositions);
    },

    /**
     * Make pixel value of horizontal positions.
     * @param {number} width plot width
     * @returns {Array.<number>} positions
     * @private
     */
    _makeHorizontalPixelPositions: function(width) {
        var positions;

        if (this.options.divided) {
            positions = this._makeDividedPlotPositions(width);
        } else {
            positions = calculator.makeTickPixelPositions(width, this.data.hTickCount);
            positions.shift();
        }

        return positions;
    }
});

module.exports = Plot;

},{"../helpers/calculator":57,"../helpers/domHandler":59,"../helpers/renderUtil":63,"./plotTemplate":73}],73:[function(require,module,exports){
/**
 * @fileoverview This is templates of plot view .
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var tags = {
    HTML_PLOT_LINE: '<div class="tui-chart-plot-line {{ className }}" style="{{ cssText }}"></div>'
};

module.exports = {
    tplPlotLine: templateMaker.template(tags.HTML_PLOT_LINE)
};

},{"../helpers/templateMaker":64}],74:[function(require,module,exports){
/**
 * @fileoverview Raphael render plugin.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var BarChart = require('./raphaelBarChart');
var LineChart = require('./raphaelLineChart');
var AreaChart = require('./raphaelAreaChart');
var PieChart = require('./raphaelPieChart');
var CoordinateTypeChart = require('./raphaelCoordinateTypeChart');
var BoxTypeChart = require('./raphaelBoxTypeChart');
var MapChart = require('./raphaelMapChart');
var MapLegend = require('./raphaelMapLegend');
var CircleLegend = require('./raphaelCircleLegend');

var pluginName = 'raphael';
var pluginRaphael = {
    bar: BarChart,
    column: BarChart,
    line: LineChart,
    area: AreaChart,
    pie: PieChart,
    bubble: CoordinateTypeChart,
    scatter: CoordinateTypeChart,
    heatmap: BoxTypeChart,
    treemap: BoxTypeChart,
    map: MapChart,
    mapLegend: MapLegend,
    circleLegend: CircleLegend
};

tui.chart.registerPlugin(pluginName, pluginRaphael);

},{"./raphaelAreaChart":75,"./raphaelBarChart":76,"./raphaelBoxTypeChart":77,"./raphaelCircleLegend":78,"./raphaelCoordinateTypeChart":79,"./raphaelLineChart":80,"./raphaelMapChart":82,"./raphaelMapLegend":83,"./raphaelPieChart":84}],75:[function(require,module,exports){
/**
 * @fileoverview Raphael area chart renderer.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var RaphaelLineBase = require('./raphaelLineTypeBase');
var raphaelRenderUtil = require('./raphaelRenderUtil');

var EMPHASIS_OPACITY = 1;
var DE_EMPHASIS_OPACITY = 0.3;
var LEFT_BAR_WIDTH = 10;

var raphael = window.Raphael;
var concat = Array.prototype.concat;

var RaphaelAreaChart = tui.util.defineClass(RaphaelLineBase, /** @lends RaphaelAreaChart.prototype */ {
    /**
     * RaphaelAreaChart is graph renderer for area chart.
     * @constructs RaphaelAreaChart
     * @extends RaphaelLineTypeBase
     */
    init: function() {
        /**
         * selected legend index
         * @type {?number}
         */
        this.selectedLegendIndex = null;

        /**
         * type of chart
         * @type {string}
         */
        this.chartType = 'area';
    },

    /**
     * Render function of area chart.
     * @param {HTMLElement} container container
     * @param {{groupPositions: Array.<Array>, dimension: object, theme: object, options: object}} data render data
     * @param {object} paper - raphael paper
     * @returns {object}
     */
    render: function(container, data, paper) {
        var dimension = data.dimension;
        var groupPositions = data.groupPositions;
        var theme = data.theme;
        var colors = theme.colors;
        var opacity = data.options.showDot ? 1 : 0;
        var borderStyle = this.makeBorderStyle(theme.borderColor, opacity);
        var outDotStyle = this.makeOutDotStyle(opacity, borderStyle);

        paper = paper || raphael(container, 1, dimension.height);

        this.paper = paper;
        this.isSpline = data.options.spline;
        this.dimension = dimension;
        this.zeroTop = data.zeroTop;
        this.hasRangeData = data.hasRangeData;

        this.groupPaths = this._getAreaChartPath(groupPositions);
        this.groupAreas = this._renderAreas(paper, this.groupPaths, colors);
        this.leftBar = this._renderLeftBar(dimension.height, data.chartBackground);
        this.tooltipLine = this._renderTooltipLine(paper, dimension.height);
        this.groupDots = this._renderDots(paper, groupPositions, colors, opacity);

        if (data.options.allowSelect) {
            this.selectionDot = this._makeSelectionDot(paper);
            this.selectionColor = theme.selectionColor;

            if (this.hasRangeData) {
                this.selectionStartDot = this._makeSelectionDot(paper);
            }
        }

        this.outDotStyle = outDotStyle;
        this.groupPositions = groupPositions;
        this.dotOpacity = opacity;

        this.pivotGroupDots = null;

        return paper;
    },

    /**
     * Get path for area chart.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions - positions
     * @param {boolean} [hasExtraPath] - whether has extra path or not
     * @returns {*}
     * @private
     */
    _getAreaChartPath: function(groupPositions, hasExtraPath) {
        var path;

        if (this.isSpline) {
            path = this._makeSplineAreaChartPath(groupPositions, hasExtraPath);
        } else {
            path = this._makeAreaChartPath(groupPositions, hasExtraPath);
        }

        return path;
    },

    /**
     * Render area graphs.
     * @param {object} paper paper
     * @param {Array.<object>} groupPaths group paths
     * @param {Array.<string>} colors colors
     * @returns {Array} raphael objects
     * @private
     */
    _renderAreas: function(paper, groupPaths, colors) {
        var groupAreas;

        colors = colors.slice(0, groupPaths.length);
        colors.reverse();
        groupPaths.reverse();

        groupAreas = tui.util.map(groupPaths, function(path, groupIndex) {
            var areaColor = colors[groupIndex] || 'transparent',
                lineColor = areaColor,
                polygons = {
                    area: raphaelRenderUtil.renderArea(paper, path.area.join(' '), {
                        fill: areaColor,
                        opacity: 0.5,
                        stroke: areaColor
                    }),
                    line: raphaelRenderUtil.renderLine(paper, path.line.join(' '), lineColor, 1)
                };

            if (path.startLine) {
                polygons.startLine = raphaelRenderUtil.renderLine(paper, path.startLine.join(' '), lineColor, 1);
            }

            return polygons;
        });

        return groupAreas.reverse();
    },

    /**
     * Make height.
     * @param {number} top top
     * @param {number} startTop start top
     * @returns {number} height
     * @private
     */
    _makeHeight: function(top, startTop) {
        return Math.abs(top - startTop);
    },

    /**
     * Make areas path.
     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
     * @param {boolean} [hasExtraPath] - whether has extra path or not
     * @returns {Array.<string | number>} path
     * @private
     */
    _makeAreasPath: function(positions, hasExtraPath) {
        var len = positions.length * 2;
        var path = [];
        var targetIndex;

        tui.util.forEachArray(positions, function(position, index) {
            path[index] = ['L', position.left, position.top];
            path[len - index - 1] = ['L', position.left, position.startTop];
        });

        if (hasExtraPath !== false) {
            targetIndex = positions.length - 1;
            path.splice(targetIndex + 1, 0, path[targetIndex], path[targetIndex + 1]);
        }

        path = concat.apply([], path);
        path[0] = 'M';

        return path;
    },

    /**
     * Make path for area chart.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @param {boolean} [hasExtraPath] - whether has extra path or not
     * @returns {Array.<{area: Array.<string | number>, line: Array.<string | number>}>} path
     * @private
     */
    _makeAreaChartPath: function(groupPositions, hasExtraPath) {
        var self = this;

        return tui.util.map(groupPositions, function(positions) {
            var paths;

            paths = {
                area: self._makeAreasPath(positions, hasExtraPath),
                line: self._makeLinesPath(positions)
            };

            if (self.hasRangeData) {
                paths.startLine = self._makeLinesPath(positions, 'startTop');
            }

            return paths;
        });
    },

    /**
     * Make spline area bottom path.
     * @param {Array.<{left: number, top: number}>} positions positions
     * @returns {Array.<string | number>} spline area path
     * @private
     */
    _makeSplineAreaBottomPath: function(positions) {
        var self = this;

        return tui.util.map(positions, function(position) {
            return ['L', position.left, self.zeroTop];
        }).reverse();
    },

    /**
     * Make spline path for area chart.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @param {boolean} [hasExtraPath] - whether has extra path or not
     * @returns {Array.<{area: Array.<string | number>, line: Array.<string | number>}>} path
     * @private
     */
    _makeSplineAreaChartPath: function(groupPositions, hasExtraPath) {
        var self = this;

        return tui.util.map(groupPositions, function(positions) {
            var linesPath = self._makeSplineLinesPath(positions);
            var areaPath = JSON.parse(JSON.stringify(linesPath));
            var areasBottomPath = self._makeSplineAreaBottomPath(positions);
            var lastPosition;

            if (hasExtraPath !== false) {
                lastPosition = positions[positions.length - 1];
                areaPath.push(['L', lastPosition.left, lastPosition.top]);
                areasBottomPath.unshift(['L', lastPosition.left, self.zeroTop]);
            }

            return {
                area: areaPath.concat(areasBottomPath),
                line: linesPath
            };
        });
    },

    /**
     * Resize graph of area chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {Array.<Array.<{left:number, top:number}>>} params.groupPositions group positions
     */
    resize: function(params) {
        var self = this,
            dimension = params.dimension,
            groupPositions = params.groupPositions;

        this.zeroTop = params.zeroTop;
        this.groupPositions = groupPositions;
        this.groupPaths = this._getAreaChartPath(groupPositions);
        this.paper.setSize(dimension.width, dimension.height);
        this.tooltipLine.attr({top: dimension.height});

        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {
            var area = self.groupAreas[groupIndex];
            area.area.attr({path: path.area.join(' ')});
            area.line.attr({path: path.line.join(' ')});

            if (area.startLine) {
                area.startLine.attr({path: path.startLine.join(' ')});
            }

            tui.util.forEachArray(self.groupDots[groupIndex], function(item, index) {
                var position = groupPositions[groupIndex][index];
                var startPositon;

                self._moveDot(item.endDot.dot, position);
                if (item.startDot) {
                    startPositon = tui.util.extend({}, position);
                    startPositon.top = startPositon.startTop;
                    self._moveDot(item.startDot.dot, startPositon);
                }
            });
        });
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var self = this,
            noneSelected = tui.util.isNull(legendIndex);

        this.selectedLegendIndex = legendIndex;

        tui.util.forEachArray(this.groupAreas, function(area, groupIndex) {
            var opacity = (noneSelected || legendIndex === groupIndex) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            area.area.attr({'fill-opacity': opacity});
            area.line.attr({'stroke-opacity': opacity});

            if (area.startLine) {
                area.startLine.attr({'stroke-opacity': opacity});
            }

            tui.util.forEachArray(self.groupDots[groupIndex], function(item) {
                if (self.dotOpacity) {
                    item.endDot.dot.attr({'fill-opacity': opacity});
                    if (item.startDot) {
                        item.startDot.dot.attr({'fill-opacity': opacity});
                    }
                }
            });
        });
    },

    /**
     * Animate for adding data.
     * @param {object} data - data for graph rendering
     * @param {number} tickSize - tick size
     * @param {Array.<Array.<object>>} groupPositions - group positions
     * @param {boolean} [shiftingOption] - shifting option
     * @param {number} zeroTop - position top value for zero point
     */
    animateForAddingData: function(data, tickSize, groupPositions, shiftingOption, zeroTop) {
        var self = this;
        var additionalIndex = 0;
        var groupPaths;

        if (!groupPositions.length) {
            return;
        }

        this.zeroTop = zeroTop;

        groupPaths = this._getAreaChartPath(groupPositions, false);

        if (shiftingOption) {
            this.leftBar.animate({
                width: tickSize + LEFT_BAR_WIDTH
            }, 300);
            additionalIndex = 1;
        }

        tui.util.forEachArray(this.groupAreas, function(area, groupIndex) {
            var dots = self.groupDots[groupIndex];
            var groupPosition = groupPositions[groupIndex];
            var pathMap = groupPaths[groupIndex];

            if (shiftingOption) {
                self._removeFirstDot(dots);
            }

            tui.util.forEachArray(dots, function(item, index) {
                var position = groupPosition[index + additionalIndex];

                self._animateByPosition(item.endDot.dot, position);

                if (item.startDot) {
                    self._animateByPosition(item.startDot.dot, {
                        left: position.left,
                        top: position.startTop
                    });
                }
            });

            self._animateByPath(area.area, pathMap.area);
            self._animateByPath(area.line, pathMap.line);

            if (area.startLine) {
                self._animateByPath(area.startLine, pathMap.startLine);
            }
        });
    }
});

module.exports = RaphaelAreaChart;

},{"./raphaelLineTypeBase":81,"./raphaelRenderUtil":85}],76:[function(require,module,exports){
/**
 * @fileoverview Raphael bar chart renderer.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';
var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

var ANIMATION_DURATION = 700;
var EMPHASIS_OPACITY = 1;
var DE_EMPHASIS_OPACITY = 0.3;
var DEFAULT_LUMINANC = 0.2;

/**
 * @classdesc RaphaelBarChart is graph renderer for bar, column chart.
 * @class RaphaelBarChart
 */
var RaphaelBarChart = tui.util.defineClass(/** @lends RaphaelBarChart.prototype */ {
    /**
     * Render function of bar chart
     * @param {HTMLElement} container container element
     * @param {{size: object, model: object, options: object, tooltipPosition: string}} data chart data
     * @returns {object} paper raphael paper
     */
    render: function(container, data) {
        var groupBounds = data.groupBounds,
            dimension = data.dimension,
            paper;

        if (!groupBounds) {
            return null;
        }

        this.paper = paper = raphael(container, dimension.width, dimension.height);

        this.theme = data.theme;
        this.seriesDataModel = data.seriesDataModel;
        this.chartType = data.chartType;

        this.groupBars = this._renderBars(groupBounds);
        this.groupBorders = this._renderBarBorders(groupBounds);

        this.overlay = this._renderOverlay();
        this.theme = data.theme;
        this.groupBounds = groupBounds;

        return paper;
    },

    /**
     * Render overlay.
     * @returns {object} raphael object
     * @private
     */
    _renderOverlay: function() {
        var bound = {
            width: 1,
            height: 1,
            left: 0,
            top: 0
        };
        var attributes = {
            'fill-opacity': 0
        };

        return this._renderBar(bound, '#fff', attributes);
    },

    /**
     * Render rect
     * @param {{left: number, top: number, width: number, height: number}} bound bound
     * @param {string} color series color
     * @param {object} [attributes] - attributes
     * @returns {object} bar rect
     * @private
     */
    _renderBar: function(bound, color, attributes) {
        var rect;

        if (bound.width < 0 || bound.height < 0) {
            return null;
        }

        rect = raphaelRenderUtil.renderRect(this.paper, bound, tui.util.extend({
            fill: color,
            stroke: 'none'
        }, attributes));

        return rect;
    },

    /**
     * Render bars.
     * @param {Array.<Array.<{left: number, top:number, width: number, height: number}>>} groupBounds bounds
     * @returns {Array.<Array.<object>>} bars
     * @private
     */
    _renderBars: function(groupBounds) {
        var self = this,
            singleColors = [],
            colors = this.theme.colors,
            groupBars;

        if ((groupBounds[0].length === 1) && this.theme.singleColors) {
            singleColors = this.theme.singleColors;
        }

        groupBars = tui.util.map(groupBounds, function(bounds, groupIndex) {
            var singleColor = singleColors[groupIndex];

            return tui.util.map(bounds, function(bound, index) {
                var color, rect, item;

                if (!bound) {
                    return null;
                }

                item = self.seriesDataModel.getSeriesItem(groupIndex, index);

                color = singleColor || colors[index];
                rect = self._renderBar(bound.start, color);

                return {
                    rect: rect,
                    color: color,
                    bound: bound.end,
                    item: item,
                    groupIndex: groupIndex,
                    index: index,
                    isRange: item.isRange
                };
            });
        });

        return groupBars;
    },

    /**
     * Make rect points.
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @returns {{
     *      leftTop: {left: number, top: number},
     *      rightTop: {left: number, top: number},
     *      rightBottom: {left: number, top: number},
     *      leftBottom: {left: number, top: number}
     * }} rect points
     * @private
     */
    _makeRectPoints: function(bound) {
        return {
            leftTop: {
                left: Math.ceil(bound.left),
                top: Math.ceil(bound.top)
            },
            rightTop: {
                left: Math.ceil(bound.left + bound.width),
                top: Math.ceil(bound.top)
            },
            rightBottom: {
                left: Math.ceil(bound.left + bound.width),
                top: Math.ceil(bound.top + bound.height)
            },
            leftBottom: {
                left: Math.ceil(bound.left),
                top: Math.ceil(bound.top + bound.height)
            }
        };
    },

    /**
     * Make top line path.
     * @param {object} points points
     *      @param {{left: number, top: number}} points.leftTop left top
     *      @param {{left: number, top: number}} points.rightTop right top
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {string} top line path
     * @private
     */
    _makeTopLinePath: function(points, chartType, item) {
        var linePath = null,
            value = item.value,
            cloneLeftTop;

        if (chartType === 'bar' || value >= 0 || item.isRange) {
            cloneLeftTop = tui.util.extend({}, points.leftTop);
            cloneLeftTop.left -= chartType === 'column' || value < 0 ? 1 : 0;
            linePath = raphaelRenderUtil.makeLinePath(cloneLeftTop, points.rightTop).join(' ');
        }

        return linePath;
    },

    /**
     * Make right line path.
     * @param {object} points points
     *      @param {{left: number, top: number}} points.rightTop right top
     *      @param {{left: number, top: number}} points.rightBottom right bottom
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {string} top line path
     * @private
     */
    _makeRightLinePath: function(points, chartType, item) {
        var linePath = null;

        if (chartType === 'column' || item.value >= 0 || item.isRange) {
            linePath = raphaelRenderUtil.makeLinePath(points.rightTop, points.rightBottom).join(' ');
        }

        return linePath;
    },

    /**
     * Make bottom line path.
     * @param {object} points points
     *      @param {{left: number, top: number}} points.lefBottom left bottom
     *      @param {{left: number, top: number}} points.rightBottom right bottom
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {string} top line path
     * @private
     */
    _makeBottomLinePath: function(points, chartType, item) {
        var linePath = null;

        if (chartType === 'bar' || item.value < 0 || item.isRange) {
            linePath = raphaelRenderUtil.makeLinePath(points.leftBottom, points.rightBottom).join(' ');
        }

        return linePath;
    },

    /**
     * Make left line path.
     * @param {object} points points
     *      @param {{left: number, top: number}} points.lefTop left top
     *      @param {{left: number, top: number}} points.leftBottom left bottom
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {string} top line path
     * @private
     */
    _makeLeftLinePath: function(points, chartType, item) {
        var linePath = null;

        if (chartType === 'column' || item.value < 0 || item.isRange) {
            linePath = raphaelRenderUtil.makeLinePath(points.leftTop, points.leftBottom).join(' ');
        }

        return linePath;
    },

    /**
     * Make border lines paths.
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {{top: string, right: string, bottom: string, left: string}} paths
     * @private
     */
    _makeBorderLinesPaths: function(bound, chartType, item) {
        var points = this._makeRectPoints(bound),
            paths = {
                top: this._makeTopLinePath(points, chartType, item),
                right: this._makeRightLinePath(points, chartType, item),
                bottom: this._makeBottomLinePath(points, chartType, item),
                left: this._makeLeftLinePath(points, chartType, item)
            };

        return tui.util.filter(paths, function(path) {
            return path;
        });
    },

    /**
     * Render border lines;
     * @param {{left: number, top:number, width: number, height: number}} bound bar bound
     * @param {string} borderColor border color
     * @param {string} chartType chart type
     * @param {Item} item item
     * @returns {object} raphael object
     * @private
     */
    _renderBorderLines: function(bound, borderColor, chartType, item) {
        var self = this,
            borderLinePaths = this._makeBorderLinesPaths(bound, chartType, item),
            lines = {};

        tui.util.forEach(borderLinePaths, function(path, name) {
            lines[name] = raphaelRenderUtil.renderLine(self.paper, path, borderColor, 1);
        });

        return lines;
    },

    /**
     * Render bar borders.
     * @param {Array.<Array.<{left: number, top:number, width: number, height: number}>>} groupBounds bounds
     * @returns {Array.<Array.<object>>} borders
     * @private
     */
    _renderBarBorders: function(groupBounds) {
        var self = this,
            borderColor = this.theme.borderColor,
            groupBorders;

        if (!borderColor) {
            return null;
        }

        groupBorders = tui.util.map(groupBounds, function(bounds, groupIndex) {
            return tui.util.map(bounds, function(bound, index) {
                var seriesItem;

                if (!bound) {
                    return null;
                }

                seriesItem = self.seriesDataModel.getSeriesItem(groupIndex, index);

                return self._renderBorderLines(bound.start, borderColor, self.chartType, seriesItem);
            });
        });

        return groupBorders;
    },

    /**
     * Animate rect.
     * @param {object} rect raphael object
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @private
     */
    _animateRect: function(rect, bound) {
        rect.animate({
            x: bound.left,
            y: bound.top,
            width: bound.width,
            height: bound.height
        }, ANIMATION_DURATION);
    },

    /**
     * Animate borders.
     * @param {Array.<object>} lines raphael objects
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @param {string} chartType chart type
     * @param {Item} item item
     * @private
     */
    _animateBorders: function(lines, bound, chartType, item) {
        var paths = this._makeBorderLinesPaths(bound, chartType, item);

        tui.util.forEach(lines, function(line, name) {
            line.animate({path: paths[name]}, ANIMATION_DURATION);
        });
    },

    /**
     * Animate.
     * @param {function} onFinish finish callback function
     */
    animate: function(onFinish) {
        var self = this,
            groupBorders = this.groupBorders || [];

        if (this.callbackTimeout) {
            clearTimeout(this.callbackTimeout);
            delete this.callbackTimeout;
        }
        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
            var lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
            if (!bar) {
                return;
            }
            self._animateRect(bar.rect, bar.bound);
            if (lines) {
                self._animateBorders(lines, bar.bound, self.chartType, bar.item);
            }
        });

        if (onFinish) {
            this.callbackTimeout = setTimeout(function() {
                onFinish();
                delete self.callbackTimeout;
            }, ANIMATION_DURATION);
        }
    },

    /**
     * Show animation.
     * @param {{groupIndex: number, index:number}} data show info
     */
    showAnimation: function(data) {
        var bar = this.groupBars[data.groupIndex][data.index],
            bound = bar.bound;
        this.overlay.attr({
            width: bound.width,
            height: bound.height,
            x: bound.left,
            y: bound.top,
            'fill-opacity': 0.3
        });
    },

    /**
     * Hide animation.
     */
    hideAnimation: function() {
        this.overlay.attr({
            width: 1,
            height: 1,
            x: 0,
            y: 0,
            'fill-opacity': 0
        });
    },

    /**
     * Update rect bound
     * @param {object} rect raphael object
     * @param {{left: number, top: number, width: number, height: number}} bound bound
     * @private
     */
    _updateRectBound: function(rect, bound) {
        rect.attr({
            x: bound.left,
            y: bound.top,
            width: bound.width,
            height: bound.height
        });
    },

    /**
     * Resize graph of bar type chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {Array.<Array.<{
     *                  left:number, top:number, width: number, height: number
     *              }>>} params.groupBounds group bounds
     */
    resize: function(params) {
        var self = this,
            groupBorders = this.groupBorders || [],
            dimension = params.dimension,
            groupBounds = params.groupBounds;

        this.groupBounds = groupBounds;
        this.paper.setSize(dimension.width, dimension.height);

        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
            var lines, bound;

            if (!bar) {
                return;
            }

            lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
            bound = groupBounds[groupIndex][index].end;
            bar.bound = bound;
            raphaelRenderUtil.updateRectBound(bar.rect, bound);

            if (lines) {
                self._updateBordersPath(lines, bound, self.chartType, bar.item);
            }
        });
    },

    /**
     * Change borders color.
     * @param {Array.<object>} lines raphael objects
     * @param {borderColor} borderColor border color
     * @private
     */
    _changeBordersColor: function(lines, borderColor) {
        tui.util.forEach(lines, function(line) {
            line.attr({stroke: borderColor});
        });
    },

    /**
     * Change bar color.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} color fill color
     * @param {?string} borderColor stroke color
     * @private
     */
    _changeBarColor: function(indexes, color, borderColor) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            lines;

        bar.rect.attr({
            fill: color
        });

        if (borderColor) {
            lines = this.groupBorders[indexes.groupIndex][indexes.index];
            this._changeBordersColor(lines, borderColor);
        }
    },

    /**
     * Select series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    selectSeries: function(indexes) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            objColor = raphael.color(bar.color),
            selectionColorTheme = this.theme.selectionColor,
            color = selectionColorTheme || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC),
            borderColor = this.theme.borderColor,
            objBorderColor;

        if (borderColor) {
            objBorderColor = raphael.color(borderColor);
            borderColor = raphaelRenderUtil.makeChangedLuminanceColor(objBorderColor.hex, DEFAULT_LUMINANC);
        }

        this._changeBarColor(indexes, color, borderColor);
    },

    /**
     * Unselect series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    unselectSeries: function(indexes) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            borderColor = this.theme.borderColor;
        this._changeBarColor(indexes, bar.color, borderColor);
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var groupBorders = this.groupBorders || [],
            noneSelected = tui.util.isNull(legendIndex);

        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
            var lines, opacity;

            if (!bar) {
                return;
            }

            lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
            opacity = (noneSelected || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            bar.rect.attr({'fill-opacity': opacity});
            if (lines) {
                tui.util.forEach(lines, function(line) {
                    line.attr({'stroke-opacity': opacity});
                });
            }
        });
    }
});

module.exports = RaphaelBarChart;

},{"./raphaelRenderUtil":85}],77:[function(require,module,exports){
/**
 * @fileoverview RaphaelBoxTypeChart is graph renderer for box type chart(heatmap chart, treemap chart).
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';
var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

var ANIMATION_DURATION = 100;
var MIN_BORDER_WIDTH = 1;
var MAX_BORDER_WIDTH = 3;

/**
 * @classdesc RaphaelBoxTypeChart is graph renderer for box type chart(heatmap chart, treemap chart).
 * @class RaphaelBarChart
 */
var RaphaelBoxTypeChart = tui.util.defineClass(/** @lends RaphaelBoxTypeChart.prototype */ {
    /**
     * Render function of bar chart
     * @param {HTMLElement} container container element
     * @param {{
     *      dimension: {width: number, height: number},
     *      colorSpectrum: object,
     *      seriesDataModel: SeriesDataModel,
     *      groupBounds: (Array.<Array.<object>>|object.<string, object>),
     *      theme: object
     * }} seriesData - data for graph rendering
     * @returns {object}
     */
    render: function(container, seriesData) {
        var dimension = seriesData.dimension;

        this.paper = raphael(container, dimension.width, dimension.height);
        /**
         * theme
         * @type {*|{}}
         */
        this.theme = seriesData.theme || {};

        /**
         * color spectrum
         * @type {Object}
         */
        this.colorSpectrum = seriesData.colorSpectrum;

        /**
         *
         */
        this.chartBackground = seriesData.chartBackground;

        /**
         * zoomable option
         */
        this.zoomable = seriesData.zoomable;

        /**
         * border color for rendering box
         * @type {string}
         */
        this.borderColor = this.theme.borderColor || 'none';

        /**
         * group bounds
         * @type {Array.<Array.<object>>|object.<string, object>}
         */
        this.groupBounds = seriesData.groupBounds;

        /**
         * bound map
         * @type {object.<string, {left: number, top: number, width: number, height: number}>}
         */
        this.boundMap = seriesData.boundMap;

        this._bindGetBoundFunction();
        this._bindGetColorFunction();

        /**
         * boxes set
         * @type {Array.<Array.<{rect: Object, color: string}>>}
         */
        this.boxesSet = this._renderBoxes(seriesData.seriesDataModel, seriesData.startDepth, !!seriesData.isPivot);

        return this.paper;
    },

    /**
     * Bind _getBound private function.
     * @private
     */
    _bindGetBoundFunction: function() {
        if (this.boundMap) {
            this._getBound = this._getBoundFromBoundMap;
        } else {
            this._getBound = this._getBoundFromGroupBounds;
        }
    },

    /**
     * Bind _bindGetColorFunction private function.
     * @private
     */
    _bindGetColorFunction: function() {
        if (this.colorSpectrum) {
            this._getColor = this._getColorFromSpectrum;
        } else if (this.zoomable) {
            this._getColor = this._getColorFromColorsWhenZoomable;
        } else {
            this._getColor = this._getColorFromColors;
        }
    },

    /**
     * Get bound from groupBounds by indexes(groupIndex, index) of seriesItem.
     * @param {SeriesItem} seriesItem - seriesItem
     * @returns {{width: number, height: number, left: number, top: number}}
     * @private
     */
    _getBoundFromGroupBounds: function(seriesItem) {
        return this.groupBounds[seriesItem.groupIndex][seriesItem.index].end;
    },

    /**
     * Get bound from boundMap by id of seriesItem.
     * @param {SeriesItem} seriesItem - seriesItem
     * @returns {{width: number, height: number, left: number, top: number}}
     * @private
     */
    _getBoundFromBoundMap: function(seriesItem) {
        return this.boundMap[seriesItem.id];
    },

    /**
     * Get color from colorSpectrum by ratio of seriesItem.
     * @param {SeriesItem} seriesItem - seriesItem
     * @returns {string}
     * @private
     */
    _getColorFromSpectrum: function(seriesItem) {
        var color;

        if (!seriesItem.hasChild) {
            color = this.colorSpectrum.getColor(seriesItem.ratio) || this.chartBackground;
        } else {
            color = 'none';
        }

        return color;
    },

    /**
     * Get color from colors theme by group property of seriesItem.
     * @param {SeriesItem} seriesItem - seriesItem
     * @returns {string}
     * @private
     */
    _getColorFromColors: function(seriesItem) {
        return seriesItem.hasChild ? 'none' : this.theme.colors[seriesItem.group];
    },

    /**
     * Get color from colors theme, when zoomable option.
     * @param {SeriesItem} seriesItem - seriesItem
     * @param {number} startDepth - start depth
     * @returns {string}
     * @private
     */
    _getColorFromColorsWhenZoomable: function(seriesItem, startDepth) {
        return (seriesItem.depth === startDepth) ? this.theme.colors[seriesItem.group] : 'none';
    },

    /**
     * Render rect.
     * @param {{width: number, height: number, left: number, top: number}} bound - bound
     * @param {string} color - color
     * @param {number} strokeWidth - stroke width
     * @returns {object}
     * @private
     */
    _renderRect: function(bound, color, strokeWidth) {
        return raphaelRenderUtil.renderRect(this.paper, bound, {
            fill: color,
            stroke: this.borderColor,
            'stroke-width': strokeWidth
        });
    },

    /**
     * Render boxes.
     * @param {SeriesDataModel} seriesDataModel - seriesDataModel
     * @param {number} startDepth - start depth
     * @param {boolean} isPivot - whether pivot or not
     * @returns {Array.<Array.<{rect: object, color: string}>>}
     * @private
     */
    _renderBoxes: function(seriesDataModel, startDepth, isPivot) {
        var self = this;
        var rectToBack;

        if (this.colorSpectrum || !this.zoomable) {
            rectToBack = function(rect) {
                rect.toBack();
            };
        } else {
            rectToBack = function() {};
        }

        return seriesDataModel.map(function(seriesGroup, groupIndex) {
            return seriesGroup.map(function(seriesItem, index) {
                var result = null;
                var strokeWidth = MIN_BORDER_WIDTH;
                var bound, color;

                if (tui.util.isExisty(seriesItem.depth)) {
                    strokeWidth = Math.max(MIN_BORDER_WIDTH, MAX_BORDER_WIDTH - (seriesItem.depth - startDepth));
                }

                seriesItem.groupIndex = groupIndex;
                seriesItem.index = index;
                bound = self._getBound(seriesItem);

                if (bound) {
                    color = self._getColor(seriesItem, startDepth);
                    result = {
                        rect: self._renderRect(bound, color, strokeWidth),
                        seriesItem: seriesItem,
                        color: color
                    };
                    rectToBack(result.rect);
                }

                return result;
            });
        }, isPivot);
    },

    /**
     * Animate changing color of box.
     * @param {object} rect - raphael object
     * @param {string} [color] - fill color
     * @param {number} [opacity] - fill opacity
     * @private
     */
    _animateChangingColor: function(rect, color, opacity) {
        var properties = {
            'fill-opacity': tui.util.isExisty(opacity) ? opacity : 1
        };

        if (color) {
            properties.fill = color;
        }

        rect.animate(properties, ANIMATION_DURATION);
    },

    /**
     * Show animation.
     * @param {{groupIndex: number, index:number}} indexes - index info
     * @param {boolean} [useSpectrum] - whether use spectrum legend or not
     * @param {number} [opacity] - fill opacity
     */
    showAnimation: function(indexes, useSpectrum, opacity) {
        var box = this.boxesSet[indexes.groupIndex][indexes.index];
        var color;

        if (!box) {
            return;
        }

        useSpectrum = tui.util.isUndefined(useSpectrum) ? true : useSpectrum;
        color = useSpectrum ? this.theme.overColor : box.color;

        if (box.seriesItem.hasChild) {
            if (useSpectrum) {
                box.rect.attr({'fill-opacity': 0});
            }
            box.rect.toFront();
        }

        this._animateChangingColor(box.rect, color, opacity);
    },

    /**
     * Hide animation.
     * @param {{groupIndex: number, index:number}} indexes - index info
     * @param {boolean} [useColorValue] - whether use colorValue or not
     */
    hideAnimation: function(indexes, useColorValue) {
        var colorSpectrum = this.colorSpectrum;
        var box = this.boxesSet[indexes.groupIndex][indexes.index];
        var opacity = 1;
        var color;

        if (!box) {
            return;
        }

        if (box.seriesItem.hasChild) {
            color = null;
            if (useColorValue) {
                opacity = 0;
            }
        } else {
            color = box.color;
        }

        this._animateChangingColor(box.rect, color, opacity);

        setTimeout(function() {
            if (!colorSpectrum && box.seriesItem.hasChild) {
                box.rect.toBack();
            }
        }, ANIMATION_DURATION);
    },

    /**
     * Resize.
     * @param {{
     *      dimension: {width: number, height: number},
     *      groupBounds: (Array.<Array.<object>>|object.<string, object>)
     * }} seriesData - data for graph rendering
     */
    resize: function(seriesData) {
        var self = this;
        var dimension = seriesData.dimension;

        this.boundMap = seriesData.boundMap;
        this.groupBounds = seriesData.groupBounds;
        this.paper.setSize(dimension.width, dimension.height);

        raphaelRenderUtil.forEach2dArray(this.boxesSet, function(box, groupIndex, index) {
            var bound;

            if (!box) {
                return;
            }

            bound = self._getBound(box.seriesItem, groupIndex, index);

            if (bound) {
                raphaelRenderUtil.updateRectBound(box.rect, bound);
            }
        });
    }
});

module.exports = RaphaelBoxTypeChart;

},{"./raphaelRenderUtil":85}],78:[function(require,module,exports){
/**
 * @fileoverview RaphaelCircleLegend is graph renderer for circleLegend.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

/**
 * @classdesc RaphaelCircleLegend is graph renderer for circleLegend.
 * @class RaphaelCircleLegend
 */
var RaphaelCircleLegend = tui.util.defineClass(/** @lends RaphaelCircleLegend.prototype */ {
    /**
     * Render function of map chart legend.
     * @param {HTMLElement} container container
     * @param {{width: number, height: number}} dimension - dimension of circle legend area
     * @param {number} maxRadius - pixel type maximum radius
     * @param {Array.<number>} radiusRatios - radius ratios
     * @returns {object} paper raphael paper
     */
    render: function(container, dimension, maxRadius, radiusRatios) {
        var paper = raphael(container, dimension.width, dimension.height);

        this.paper = paper;

        this._renderCircles(dimension, maxRadius, radiusRatios);

        return paper;
    },

    /**
     * Render circles.
     * @param {{width: number, height: number}} dimension - dimension of circle legend area
     * @param {number} maxRadius - pixel type maximum radius
     * @param {Array.<number>} radiusRatios - radius ratios
     * @private
     */
    _renderCircles: function(dimension, maxRadius, radiusRatios) {
        var paper = this.paper;
        var left = dimension.width / 2;

        tui.util.forEachArray(radiusRatios, function(ratio) {
            var radius = maxRadius * ratio;
            var top = (dimension.height - radius) - 1;

            raphaelRenderUtil.renderCircle(paper, {
                left: left,
                top: top
            }, radius, {
                fill: 'none',
                opacity: 1,
                stroke: '#888',
                'stroke-width': 1
            });
        });
    }
});

module.exports = RaphaelCircleLegend;

},{"./raphaelRenderUtil":85}],79:[function(require,module,exports){
/**
 * @fileoverview Raphael bubble chart renderer.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';
var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

var ANIMATION_DURATION = 700;
var CIRCLE_OPACITY = 0.5;
var STROKE_OPACITY = 0.3;
var EMPHASIS_OPACITY = 0.5;
var DE_EMPHASIS_OPACITY = 0.3;
var DEFAULT_LUMINANC = 0.2;
var OVERLAY_BORDER_WIDTH = 2;

/**
 * bound for circle
 * @typedef {{left: number, top: number, radius: number}} bound
 */

/**
 * Information for rendered circle
 * @typedef {{circle: object, color: string, bound: bound}} circleInfo
 */

/**
 * @classdesc RaphaelBubbleChart is graph renderer for bubble chart.
 * @class RaphaelBubbleChart
 */
var RaphaelBubbleChart = tui.util.defineClass(/** @lends RaphaelBubbleChart.prototype */ {
    /**
     * Render function of bubble chart
     * @param {HTMLElement} container - container element
     * @param {{
     *      dimension: {width: number, height: number},
     *      seriesDataModel: SeriesDataModel,
     *      groupBounds: Array.<Array.<bound>>,
     *      theme: object
     * }} data - data for rendering
     * @param {{showTooltip: function, hideTooltip: function}} callbacks - callbacks for toggle of tooltip.
     * @returns {object}
     */
    render: function(container, data, callbacks) {
        var dimension = data.dimension,
            paper;

        this.paper = paper = raphael(container, dimension.width, dimension.height);

        /**
         * container element
         * @type {HTMLElement}
         */
        this.container = container;

        /**
         * theme
         * @type {object}
         */
        this.theme = data.theme;

        /**
         * seriesDataModel
         * @type {SeriesDataModel}
         */
        this.seriesDataModel = data.seriesDataModel;

        /**
         * group bounds
         * @type {Array.<Array.<bound>>}
         */
        this.groupBounds = data.groupBounds;

        /**
         * callbacks for toggle of tooltip.
         * @type {{showTooltip: Function, hideTooltip: Function}}
         */
        this.callbacks = callbacks;

        /**
         * overlay is circle object of raphael, that using for mouseover.
         * @type {object}
         */
        this.overlay = this._renderOverlay();

        /**
         * two-dimensional array by circleInfo
         * @type {Array.<Array.<circleInfo>>}
         */
        this.groupCircleInfos = this._renderCircles();

        /**
         * previous selected circle
         * @type {?object}
         */
        this.prevCircle = null;

        /**
         * previous over circle
         * @type {?object}
         */
        this.prevOverCircle = null;

        /**
         * animation timeout id
         * @type {?number}
         */
        this.animationTimeoutId = null;

        return paper;
    },

    /**
     * Render overlay.
     * @returns {object}
     * @private
     */
    _renderOverlay: function() {
        var position = {
            left: 0,
            top: 0
        };
        var attribute = {
            fill: 'none',
            stroke: '#fff',
            'stroke-opacity': STROKE_OPACITY,
            'stroke-width': 2
        };
        var circle = raphaelRenderUtil.renderCircle(this.paper, position, 0, attribute);

        return circle;
    },

    /**
     * Render circles.
     * @returns {Array.<Array.<circleInfo>>}
     * @private
     */
    _renderCircles: function() {
        var self = this;
        var colors = this.theme.colors;
        var singleColors = [];

        if ((this.groupBounds[0].length === 1) && this.theme.singleColors) {
            singleColors = this.theme.singleColors;
        }

        return tui.util.map(this.groupBounds, function(bounds, groupIndex) {
            var singleColor = singleColors[groupIndex];

            return tui.util.map(bounds, function(bound, index) {
                var circleInfo = null;
                var color, circle;

                if (bound) {
                    color = singleColor || colors[index];
                    circle = raphaelRenderUtil.renderCircle(self.paper, bound, 0, {
                        fill: color,
                        opacity: 0,
                        stroke: 'none'
                    });

                    circle.data('groupIndex', groupIndex);
                    circle.data('index', index);

                    circleInfo = {
                        circle: circle,
                        color: color,
                        bound: bound
                    };
                }

                return circleInfo;
            });
        });
    },

    /**
     * Animate circle
     * @param {object} circle - raphael object
     * @param {number} radius - radius of circle
     * @private
     */
    _animateCircle: function(circle, radius) {
        circle.animate({
            r: radius,
            opacity: CIRCLE_OPACITY
        }, ANIMATION_DURATION);
    },

    /**
     * Animate.
     * @param {function} onFinish - finish callback function
     */
    animate: function(onFinish) {
        var self = this;

        if (this.animationTimeoutId) {
            clearTimeout(this.animationTimeoutId);
            this.animationTimeoutId = null;
        }

        raphaelRenderUtil.forEach2dArray(this.groupCircleInfos, function(circleInfo) {
            if (!circleInfo) {
                return;
            }
            self._animateCircle(circleInfo.circle, circleInfo.bound.radius);
        });

        if (onFinish) {
            this.animationTimeoutId = setTimeout(function() {
                onFinish();
                this.animationTimeoutId = null;
            }, ANIMATION_DURATION);
        }
    },

    /**
     * Update circle bound
     * @param {object} circle - raphael object
     * @param {{left: number, top: number}} bound - bound
     * @private
     */
    _updatePosition: function(circle, bound) {
        circle.attr({
            cx: bound.left,
            cy: bound.top,
            r: bound.radius
        });
    },

    /**
     * Resize graph of bubble type chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension - dimension
     *      @param {Array.<Array.<bound>>} params.groupBounds - group bounds
     */
    resize: function(params) {
        var self = this;
        var dimension = params.dimension;
        var groupBounds = params.groupBounds;

        this.groupBounds = groupBounds;
        this.paper.setSize(dimension.width, dimension.height);

        raphaelRenderUtil.forEach2dArray(this.groupCircleInfos, function(circleInfo, groupIndex, index) {
            var bound = groupBounds[groupIndex][index];

            circleInfo.bound = bound;
            self._updatePosition(circleInfo.circle, bound);
        });
    },

    /**
     * Click series.
     * @param {{left: number, top: number}} position mouse position
     */
    clickSeries: function(position) {
        var circle = this.paper.getElementByPoint(position.left, position.top);
        var prevCircle = this.prevCircle;

        if (circle && prevCircle) {
            this._unselectSeries(prevCircle.data('groupIndex'), prevCircle.data('index'));
        }

        if (prevCircle === circle) {
            this.prevCircle = null;
        } else if (circle) {
            this._selectSeries(circle.data('groupIndex'), circle.data('index'));
            this.prevCircle = circle;
        }
    },

    /**
     * Get series container bound.
     * @returns {{left: number, top: number, width: number, height: number}}
     * @private
     */
    _getContainerBound: function() {
        if (!this.containerBound) {
            this.containerBound = this.container.getBoundingClientRect();
        }

        return this.containerBound;
    },

    /**
     * Whether changed or not.
     * @param {{left: number, top: number}} prevPosition - previous position
     * @param {{left: number, top: number}} position - position
     * @returns {boolean} result boolean
     * @private
     */
    _isChangedPosition: function(prevPosition, position) {
        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
    },

    /**
     * Show overlay when mouse over a circle.
     * @param {number} groupIndex - index of circles group
     * @param {number} index - index of circles
     * @private
     */
    _showOverlay: function(groupIndex, index) {
        var circleInfo = this.groupCircleInfos[groupIndex][index];
        var bound = circleInfo.bound;

        this.overlay.attr({
            cx: bound.left,
            cy: bound.top,
            r: bound.radius + OVERLAY_BORDER_WIDTH,
            stroke: circleInfo.color,
            opacity: 1
        });
    },

    /**
     * Hide overlay.
     * @private
     */
    _hideOverlay: function() {
        this.overlay.attr({
            cx: 0,
            cy: 0,
            r: 0,
            opacity: 0
        });
    },

    /**
     * Find circle.
     * @param {{left: number, top: number}} position - position
     * @returns {?object}
     * @private
     */
    _findCircle: function(position) {
        var circles = [];
        var paper = this.paper;
        var foundCircle, circle;

        while (tui.util.isUndefined(foundCircle)) {
            circle = paper.getElementByPoint(position.left, position.top);

            if (circle) {
                if (circle.attrs.opacity > DE_EMPHASIS_OPACITY) {
                    foundCircle = circle;
                } else {
                    circles.push(circle);
                    circle.hide();
                }
            } else {
                foundCircle = null;
            }
        }

        if (!foundCircle) {
            foundCircle = circles[0];
        }

        tui.util.forEachArray(circles, function(_circle) {
            _circle.show();
        });

        return foundCircle;
    },

    /**
     * Move mouse on series.
     * @param {{left: number, top: number}} position - mouse position
     */
    moveMouseOnSeries: function(position) {
        var circle = this._findCircle(position);
        var containerBound, isChanged, groupIndex, index, args;

        if (circle && tui.util.isExisty(circle.data('groupIndex'))) {
            containerBound = this._getContainerBound();
            isChanged = (this.prevOverCircle !== circle);
            groupIndex = circle.data('groupIndex');
            index = circle.data('index');
            args = [{}, groupIndex, index, {
                left: position.left - containerBound.left,
                top: position.top - containerBound.top
            }];

            if (isChanged) {
                this._showOverlay(groupIndex, index);
            }

            if (this._isChangedPosition(this.prevPosition, position)) {
                this.callbacks.showTooltip.apply(null, args);
                this.prevOverCircle = circle;
            }
        } else if (this.prevOverCircle) {
            this._hideOverlay();
            this.callbacks.hideTooltip();
            this.prevOverCircle = null;
        }
        this.prevPosition = position;
    },

    /**
     * Select series.
     * @param {number} groupIndex - index of group
     * @param {number} index - index
     */
    _selectSeries: function(groupIndex, index) {
        var circleInfo = this.groupCircleInfos[groupIndex][index];
        var objColor = raphael.color(circleInfo.color);
        var themeColor = this.theme.selectionColor;
        var color = themeColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC);

        circleInfo.circle.attr({
            fill: color
        });
    },

    /**
     * Unselect series.
     * @param {number} groupIndex - index of group
     * @param {number} index - index
     */
    _unselectSeries: function(groupIndex, index) {
        var circleInfo = this.groupCircleInfos[groupIndex][index];

        circleInfo.circle.attr({
            fill: circleInfo.color
        });
    },

    /**
     * Select legend.
     * @param {?number} legendIndex - index of legend
     */
    selectLegend: function(legendIndex) {
        var noneSelected = tui.util.isNull(legendIndex);

        raphaelRenderUtil.forEach2dArray(this.groupCircleInfos, function(circleInfo, groupIndex, index) {
            var opacity;

            if (!circleInfo) {
                return;
            }

            opacity = (noneSelected || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            circleInfo.circle.attr({opacity: opacity});
        });
    }
});

module.exports = RaphaelBubbleChart;

},{"./raphaelRenderUtil":85}],80:[function(require,module,exports){
/**
 * @fileoverview Raphael line chart renderer.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var RaphaelLineBase = require('./raphaelLineTypeBase'),
    raphaelRenderUtil = require('./raphaelRenderUtil');

var EMPHASIS_OPACITY = 1;
var DE_EMPHASIS_OPACITY = 0.3;
var LEFT_BAR_WIDTH = 10;

var raphael = window.Raphael;

var RaphaelLineChart = tui.util.defineClass(RaphaelLineBase, /** @lends RaphaelLineChart.prototype */ {
    /**
     * RaphaelLineCharts is graph renderer for line chart.
     * @constructs RaphaelLineChart
     * @extends RaphaelLineTypeBase
     */
    init: function() {
        /**
         * selected legend index
         * @type {?number}
         */
        this.selectedLegendIndex = null;

        /**
         * type of chart
         * @type {string}
         */
        this.chartType = 'line';
    },

    /**
     * Render function of line chart.
     * @param {HTMLElement} container container
     * @param {{groupPositions: Array.<Array>, dimension: object, theme: object, options: object}} data render data
     * @param {object} [paper] - raphael paper
     * @returns {object} paper raphael paper
     */
    render: function(container, data, paper) {
        var dimension = data.dimension;
        var groupPositions = data.groupPositions;
        var theme = data.theme;
        var colors = theme.colors;
        var opacity = data.options.showDot ? 1 : 0;
        var isSpline = data.options.spline;
        var groupPaths = isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);
        var borderStyle = this.makeBorderStyle(theme.borderColor, opacity);
        var outDotStyle = this.makeOutDotStyle(opacity, borderStyle);

        paper = paper || raphael(container, 1, dimension.height);

        this.paper = paper;
        this.isSpline = isSpline;
        this.dimension = dimension;

        this.groupLines = this._renderLines(paper, groupPaths, colors);
        this.leftBar = this._renderLeftBar(dimension.height, data.chartBackground);
        this.tooltipLine = this._renderTooltipLine(paper, dimension.height);
        this.groupDots = this._renderDots(paper, groupPositions, colors, opacity);

        if (data.options.allowSelect) {
            this.selectionDot = this._makeSelectionDot(paper);
            this.selectionColor = theme.selectionColor;
        }

        this.colors = colors;
        this.borderStyle = borderStyle;
        this.outDotStyle = outDotStyle;
        this.groupPositions = groupPositions;
        this.groupPaths = groupPaths;
        this.dotOpacity = opacity;
        delete this.pivotGroupDots;

        return paper;
    },

    /**
     * Get lines path.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @returns {Array.<Array.<string>>} path
     * @private
     */
    _getLinesPath: function(groupPositions) {
        var self = this;

        return tui.util.map(groupPositions, function(positions) {
            return self._makeLinesPath(positions);
        });
    },

    /**
     * Get spline lines path.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @returns {Array} path
     * @private
     */
    _getSplineLinesPath: function(groupPositions) {
        return tui.util.map(groupPositions, this._makeSplineLinesPath, this);
    },

    /**
     * Render lines.
     * @param {object} paper raphael paper
     * @param {Array.<Array.<string>>} groupPaths paths
     * @param {string[]} colors line colors
     * @param {?number} strokeWidth stroke width
     * @returns {Array.<Array.<object>>} lines
     * @private
     */
    _renderLines: function(paper, groupPaths, colors, strokeWidth) {
        return tui.util.map(groupPaths, function(path, groupIndex) {
            var color = colors[groupIndex] || 'transparent';
            return raphaelRenderUtil.renderLine(paper, path.join(' '), color, strokeWidth);
        });
    },

    /**
     * Resize graph of line chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {Array.<Array.<{left:number, top:number}>>} params.groupPositions group positions
     */
    resize: function(params) {
        var self = this,
            dimension = params.dimension,
            groupPositions = params.groupPositions;

        this.groupPositions = groupPositions;
        this.groupPaths = this.isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);
        this.paper.setSize(dimension.width, dimension.height);
        this.tooltipLine.attr({top: dimension.height});

        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {
            self.groupLines[groupIndex].attr({path: path.join(' ')});

            tui.util.forEachArray(self.groupDots[groupIndex], function(item, index) {
                self._moveDot(item.endDot.dot, groupPositions[groupIndex][index]);
            });
        });
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var self = this,
            noneSelected = tui.util.isNull(legendIndex);

        this.selectedLegendIndex = legendIndex;

        tui.util.forEachArray(this.groupLines, function(line, groupIndex) {
            var opacity = (noneSelected || legendIndex === groupIndex) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            line.attr({'stroke-opacity': opacity});

            tui.util.forEachArray(self.groupDots[groupIndex], function(item) {
                item.opacity = opacity;

                if (self.dotOpacity) {
                    item.endDot.dot.attr({'fill-opacity': opacity});
                }
            });
        });
    },

    /**
     * Animate for adding data.
     * @param {object} data - data for graph rendering
     * @param {number} tickSize - tick size
     * @param {Array.<Array.<object>>} groupPositions - group positions
     * @param {boolean} [shiftingOption] - shifting option
     */
    animateForAddingData: function(data, tickSize, groupPositions, shiftingOption) {
        var self = this;
        var isSpline = data.options.spline;
        var groupPaths = isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);
        var additionalIndex = 0;

        if (!groupPositions.length) {
            return;
        }

        if (shiftingOption) {
            this.leftBar.animate({
                width: tickSize + LEFT_BAR_WIDTH
            }, 300);
            additionalIndex = 1;
        }

        tui.util.forEachArray(this.groupLines, function(line, groupIndex) {
            var dots = self.groupDots[groupIndex];
            var groupPosition = groupPositions[groupIndex];

            if (shiftingOption) {
                self._removeFirstDot(dots);
            }

            tui.util.forEachArray(dots, function(item, index) {
                var position = groupPosition[index + additionalIndex];
                self._animateByPosition(item.endDot.dot, position);
            });

            self._animateByPath(line, groupPaths[groupIndex]);
        });
    }
});

module.exports = RaphaelLineChart;

},{"./raphaelLineTypeBase":81,"./raphaelRenderUtil":85}],81:[function(require,module,exports){
/**
 * @fileoverview RaphaelLineTypeBase is base class for line type renderer.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var ANIMATION_DURATION = 700;
var DEFAULT_DOT_RADIUS = 3;
var HOVER_DOT_RADIUS = 4;
var SELECTION_DOT_RADIUS = 7;
var DE_EMPHASIS_OPACITY = 0.3;
var MOVING_ANIMATION_DURATION = 300;
var LEFT_BAR_WIDTH = 10;

var concat = Array.prototype.concat;

/**
 * @classdesc RaphaelLineTypeBase is base for line type renderer.
 * @class RaphaelLineTypeBase
 */
var RaphaelLineTypeBase = tui.util.defineClass(/** @lends RaphaelLineTypeBase.prototype */ {
    /**
     * Render left bar for hiding overflow graph.
     * @param {number} height - area height
     * @param {string} chartBackground - background style of chart
     * @private
     * @returns {object}
     */
    _renderLeftBar: function(height, chartBackground) {
        var bound = {
            left: 0,
            top: 0,
            width: LEFT_BAR_WIDTH,
            height: height
        };

        return raphaelRenderUtil.renderRect(this.paper, bound, {
            fill: chartBackground,
            stroke: 'none'
        });
    },

    /**
     * Make lines path.
     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
     * @param {?string} posTopType position top type
     * @returns {Array.<string | number>} paths
     * @private
     */
    _makeLinesPath: function(positions, posTopType) {
        var path;

        posTopType = posTopType || 'top';
        path = tui.util.map(positions, function(position) {
            return ['L', position.left, position[posTopType]];
        });

        path = concat.apply([], path);
        path[0] = 'M';

        return path;
    },

    /**
     * Get anchor. (http://raphaeljs.com/analytics.js)
     * @param {{left: number, top: number}} fromPos from position
     * @param {{left: number, top: number}} pos position
     * @param {{left: number, top: number}} nextPos next position
     * @returns {{x1: number, y1: number, x2: number, y2: number}} anchor
     * @private
     */
    _getAnchor: function(fromPos, pos, nextPos) {
        var l1 = (pos.left - fromPos.left) / 2,
            l2 = (nextPos.left - pos.left) / 2,
            a = Math.atan((pos.left - fromPos.left) / Math.abs(pos.top - fromPos.top)),
            b = Math.atan((nextPos.left - pos.left) / Math.abs(pos.top - nextPos.top)),
            alpha, dx1, dy1, dx2, dy2;

        a = fromPos.top < pos.top ? Math.PI - a : a;
        b = nextPos.top < pos.top ? Math.PI - b : b;
        alpha = Math.PI / 2 - ((a + b) % (Math.PI * 2)) / 2;
        dx1 = l1 * Math.sin(alpha + a);
        dy1 = l1 * Math.cos(alpha + a);
        dx2 = l2 * Math.sin(alpha + b);
        dy2 = l2 * Math.cos(alpha + b);

        return {
            x1: pos.left - dx1,
            y1: pos.top + dy1,
            x2: pos.left + dx2,
            y2: pos.top + dy2
        };
    },

    /**
     * Make spline lines path.
     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
     * @returns {Array.<string | number>} paths
     * @private
     */
    _makeSplineLinesPath: function(positions) {
        var self = this;
        var firstPos = positions[0];
        var positionsLen = positions.length;
        var fromPos = firstPos;
        var lastPos = positions[positionsLen - 1];
        var middlePositions = positions.slice(1).slice(0, positionsLen - 2);
        var path = tui.util.map(middlePositions, function(position, index) {
            var nextPos = positions[index + 2];
            var anchor = self._getAnchor(fromPos, position, nextPos);

            fromPos = position;

            return [anchor.x1, anchor.y1, position.left, position.top, anchor.x2, anchor.y2];
        });

        path.push([lastPos.left, lastPos.top, lastPos.left, lastPos.top]);
        path.unshift(['M', firstPos.left, firstPos.top, 'C', firstPos.left, firstPos.top]);

        return path;
    },

    /**
     * Render tooltip line.
     * @param {object} paper raphael paper
     * @param {number} height height
     * @returns {object} raphael object
     * @private
     */
    _renderTooltipLine: function(paper, height) {
        var linePath = raphaelRenderUtil.makeLinePath({
            left: 10,
            top: height
        }, {
            left: 10,
            top: 0
        });

        return raphaelRenderUtil.renderLine(paper, linePath, 'transparent', 1);
    },

    /**
     * Make border style.
     * @param {string} borderColor border color
     * @param {number} opacity opacity
     * @returns {{stroke: string, stroke-width: number, strike-opacity: number}} border style
     */
    makeBorderStyle: function(borderColor, opacity) {
        var borderStyle;

        if (borderColor) {
            borderStyle = {
                stroke: borderColor,
                'stroke-width': 1,
                'stroke-opacity': opacity
            };
        }

        return borderStyle;
    },

    /**
     * Make dot style for mouseout event.
     * @param {number} opacity opacity
     * @param {object} borderStyle border style
     * @returns {{fill-opacity: number, stroke-opacity: number, r: number}} style
     */
    makeOutDotStyle: function(opacity, borderStyle) {
        var outDotStyle = {
            'fill-opacity': opacity,
            'stroke-opacity': 0,
            r: DEFAULT_DOT_RADIUS
        };

        if (borderStyle) {
            tui.util.extend(outDotStyle, borderStyle);
        }

        return outDotStyle;
    },

    /**
     * Render dot.
     * @param {object} paper raphael papaer
     * @param {{left: number, top: number}} position dot position
     * @param {string} color dot color
     * @param {number} opacity opacity
     * @returns {object} raphael dot
     */
    renderDot: function(paper, position, color, opacity) {
        var dot = paper.circle(position.left, position.top, DEFAULT_DOT_RADIUS),
            dotStyle = {
                fill: color,
                'fill-opacity': opacity,
                'stroke-opacity': 0
            };

        dot.attr(dotStyle);

        return {
            dot: dot,
            color: color
        };
    },

    /**
     * Move dots to front.
     * @param {Array.<{startDot: {dot: object}, endDot: {dot: object}}>} dots - dots
     * @private
     */
    _moveDotsToFront: function(dots) {
        raphaelRenderUtil.forEach2dArray(dots, function(dotInfo) {
            dotInfo.endDot.dot.toFront();
            if (dotInfo.startDot) {
                dotInfo.startDot.dot.toFront();
            }
        });
    },

    /**
     * Render dots.
     * @param {object} paper raphael paper
     * @param {Array.<Array.<object>>} groupPositions positions
     * @param {string[]} colors colors
     * @param {number} opacity opacity
     * @returns {Array.<object>} dots
     * @private
     */
    _renderDots: function(paper, groupPositions, colors, opacity) {
        var self = this;
        var dots;

        // 기존에 캐싱된 dot을 다른 도형에 의해 가려지지 않게 하기 위해 제일 앞으로 이동시킴
        if (paper.dots) {
            this._moveDotsToFront(paper.dots);
        }

        dots = tui.util.map(groupPositions, function(positions, groupIndex) {
            var color = colors[groupIndex];

            return tui.util.map(positions, function(position) {
                var dotMap = {
                    endDot: self.renderDot(paper, position, color, opacity)
                };
                var startPosition;

                if (self.hasRangeData) {
                    startPosition = tui.util.extend({}, position);
                    startPosition.top = startPosition.startTop;
                    dotMap.startDot = self.renderDot(paper, startPosition, color, opacity);
                }

                return dotMap;
            });
        });

        if (!paper.dots) {
            paper.dots = [];
        }

        // 다른 그래프 렌더링 시 앞으로 이동시키기 위해 paper에 캐싱함
        paper.dots = paper.dots.concat(dots);

        return dots;
    },

    /**
     * Get center position
     * @param {{left: number, top: number}} fromPos from position
     * @param {{left: number, top: number}} toPos to position
     * @returns {{left: number, top: number}} position
     * @private
     */
    _getCenter: function(fromPos, toPos) {
        return {
            left: (fromPos.left + toPos.left) / 2,
            top: (fromPos.top + toPos.top) / 2
        };
    },

    /**
     * Show dot.
     * @param {object} dot raphael object
     * @private
     */
    _showDot: function(dot) {
        dot.attr({
            'fill-opacity': 1,
            'stroke-opacity': 0.3,
            'stroke-width': 2,
            r: HOVER_DOT_RADIUS
        });
    },

    /**
     * Update line stroke width.
     * @param {object} line raphael object
     * @param {number} strokeWidth stroke width
     * @private
     */
    _updateLineStrokeWidth: function(line, strokeWidth) {
        line.attr({
            'stroke-width': strokeWidth
        });
    },

    /**
     * Show animation.
     * @param {{groupIndex: number, index:number}} data show info
     */
    showAnimation: function(data) {
        var index = data.groupIndex; // Line chart has pivot values.
        var groupIndex = data.index;
        var line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex];
        var item = this.groupDots[groupIndex][index];
        var strokeWidth, startLine;

        if (!item) {
            return;
        }

        if (this.chartType === 'area') {
            strokeWidth = 2;
            startLine = line.startLine;
            line = line.line;
        } else {
            strokeWidth = 3;
        }

        this._updateLineStrokeWidth(line, strokeWidth);

        if (startLine) {
            this._updateLineStrokeWidth(startLine, strokeWidth);
        }

        this._showDot(item.endDot.dot);

        if (item.startDot) {
            this._showDot(item.startDot.dot);
        }
    },

    /**
     * Get pivot group dots.
     * @returns {Array.<Array>} dots
     * @private
     */
    _getPivotGroupDots: function() {
        if (!this.pivotGroupDots) {
            this.pivotGroupDots = tui.util.pivot(this.groupDots);
        }

        return this.pivotGroupDots;
    },

    /**
     * Show group dots.
     * @param {number} index index
     * @private
     */
    _showGroupDots: function(index) {
        var self = this;
        var groupDots = this._getPivotGroupDots();

        if (!groupDots[index]) {
            return;
        }

        tui.util.forEachArray(groupDots[index], function(item) {
            self._showDot(item.endDot.dot);

            if (item.startDot) {
                self._showDot(item.startDot.dot);
            }
        });
    },

    /**
     * Show line for group tooltip.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound bound
     */
    showGroupTooltipLine: function(bound) {
        var linePath = raphaelRenderUtil.makeLinePath({
            left: bound.position.left,
            top: bound.position.top + bound.dimension.height
        }, {
            left: bound.position.left,
            top: bound.position.top
        });

        this.tooltipLine.attr({
            path: linePath,
            stroke: '#999',
            'stroke-opacity': 1
        });
    },

    /**
     * Show group animation.
     * @param {number} index index
     */
    showGroupAnimation: function(index) {
        this._showGroupDots(index);
    },

    /**
     * Hide dot.
     * @param {object} dot raphael object
     * @param {?number} opacity opacity
     * @private
     */
    _hideDot: function(dot, opacity) {
        var outDotStyle = this.outDotStyle;

        if (!tui.util.isUndefined(opacity)) {
            outDotStyle = tui.util.extend({}, this.outDotStyle, {
                'fill-opacity': opacity
            });
        }

        dot.attr(outDotStyle);
    },

    /**
     * Hide animation.
     * @param {{groupIndex: number, index:number}} data hide info
     */
    hideAnimation: function(data) {
        var index = data.groupIndex; // Line chart has pivot values.
        var groupIndex = data.index;
        var opacity = this.dotOpacity;
        var groupDot = this.groupDots[groupIndex];
        var line, item, strokeWidth, startLine;

        if (!groupDot || !groupDot[index]) {
            return;
        }

        line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex];
        item = groupDot[index];

        if (this.chartType === 'area') {
            strokeWidth = 1;
            startLine = line.startLine;
            line = line.line;
        } else {
            strokeWidth = 2;
        }

        if (opacity && !tui.util.isNull(this.selectedLegendIndex) && this.selectedLegendIndex !== groupIndex) {
            opacity = DE_EMPHASIS_OPACITY;
        }

        if (line) {
            this._updateLineStrokeWidth(line, strokeWidth);
        }

        if (startLine) {
            this._updateLineStrokeWidth(startLine, strokeWidth);
        }

        if (item) {
            this._hideDot(item.endDot.dot, opacity);

            if (item.startDot) {
                this._hideDot(item.startDot.dot, opacity);
            }
        }
    },

    /**
     * Hide group dots.
     * @param {number} index index
     * @private
     */
    _hideGroupDots: function(index) {
        var self = this;
        var groupDots = this._getPivotGroupDots();
        var hasSelectedIndex = !tui.util.isNull(this.selectedLegendIndex);
        var baseOpacity = this.dotOpacity;

        if (!groupDots[index]) {
            return;
        }

        tui.util.forEachArray(groupDots[index], function(item, groupIndex) {
            var opacity = baseOpacity;

            if (opacity && hasSelectedIndex && self.selectedLegendIndex !== groupIndex) {
                opacity = DE_EMPHASIS_OPACITY;
            }

            self._hideDot(item.endDot.dot, opacity);

            if (item.startDot) {
                self._hideDot(item.startDot.dot, opacity);
            }
        });
    },

    /**
     * Hide line for group tooltip.
     */
    hideGroupTooltipLine: function() {
        this.tooltipLine.attr({
            'stroke-opacity': 0
        });
    },

    /**
     * Hide group animation.
     * @param {number} index index
     */
    hideGroupAnimation: function(index) {
        this._hideGroupDots(index);
    },

    _moveDot: function(dot, position) {
        var dotAttrs = {
            cx: position.left,
            cy: position.top
        };

        if (this.dotOpacity) {
            dotAttrs = tui.util.extend({'fill-opacity': this.dotOpacity}, dotAttrs, this.borderStyle);
        }

        dot.attr(dotAttrs);
    },

    /**
     * Show graph for zoom.
     */
    showGraph: function() {
        this.paper.setSize(this.dimension.width, this.dimension.height);
    },

    /**
     * Animate.
     * @param {function} onFinish callback
     */
    animate: function(onFinish) {
        var self = this,
            seriesWidth = this.dimension.width,
            seriesHeight = this.dimension.height;

        tui.chart.renderUtil.cancelAnimation(this.animation);

        this.animation = tui.chart.renderUtil.startAnimation(ANIMATION_DURATION, function(ratio) {
            var width = Math.min(seriesWidth * ratio, seriesWidth);

            self.paper.setSize(width, seriesHeight);

            if (ratio === 1) {
                onFinish();
            }
        });
    },

    /**
     * Make selection dot.
     * @param {object} paper raphael paper
     * @returns {object} selection dot
     * @private
     */
    _makeSelectionDot: function(paper) {
        var selectionDot = paper.circle(0, 0, SELECTION_DOT_RADIUS);

        selectionDot.attr({
            'fill': '#ffffff',
            'fill-opacity': 0,
            'stroke-opacity': 0,
            'stroke-width': 2
        });

        return selectionDot;
    },

    /**
     * Select series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    selectSeries: function(indexes) {
        var item = this.groupDots[indexes.index][indexes.groupIndex],
            position = this.groupPositions[indexes.index][indexes.groupIndex];

        this.selectedItem = item;
        this.selectionDot.attr({
            cx: position.left,
            cy: position.top,
            'fill-opacity': 0.5,
            'stroke-opacity': 1,
            stroke: this.selectionColor || item.dot.color
        });

        if (this.selectionStartDot) {
            this.selectionStartDot.attr({
                cx: position.left,
                cy: position.startTop,
                'fill-opacity': 0.5,
                'stroke-opacity': 1,
                stroke: this.selectionColor || item.startDot.color
            });
        }
    },

    /**
     * Unselect series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    unselectSeries: function(indexes) {
        var item = this.groupDots[indexes.index][indexes.groupIndex];

        if (this.selectedItem === item) {
            this.selectionDot.attr({
                'fill-opacity': 0,
                'stroke-opacity': 0
            });
        }

        if (this.selectionStartDot) {
            this.selectionStartDot.attr({
                'fill-opacity': 0,
                'stroke-opacity': 0
            });
        }
    },

    /**
     * Set width or height of paper.
     * @param {number} width - width
     * @param {number} height - height
     */
    setSize: function(width, height) {
        width = width || this.dimension.width;
        height = height || this.dimension.height;
        this.paper.setSize(width, height);
    },

    /**
     * Animate by position.
     * @param {object} raphaelObj - raphael object
     * @param {{left: number, top: number}} position - position
     * @private
     */
    _animateByPosition: function(raphaelObj, position) {
        raphaelObj.animate({
            cx: position.left,
            cy: position.top
        }, MOVING_ANIMATION_DURATION);
    },

    /**
     * Animate by path.
     * @param {object} raphaelObj - raphael object
     * @param {Array.<string | number>} paths - paths
     * @private
     */
    _animateByPath: function(raphaelObj, paths) {
        raphaelObj.animate({
            path: paths.join(' ')
        }, MOVING_ANIMATION_DURATION);
    },

    /**
     * Remove first dot.
     * @param {Array.<object>} dots - dots
     * @private
     */
    _removeFirstDot: function(dots) {
        var firstDot = dots.shift();

        firstDot.endDot.dot.remove();

        if (firstDot.startDot) {
            firstDot.startDot.dot.remove();
        }
    },

    /**
     * Clear paper.
     */
    clear: function() {
        delete this.paper.dots;
        this.paper.clear();
    }
});

module.exports = RaphaelLineTypeBase;

},{"./raphaelRenderUtil":85}],82:[function(require,module,exports){
/**
 * @fileoverview RaphaelPieCharts is graph renderer for map chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

var STROKE_COLOR = 'gray';
var ANIMATION_DURATION = 100;

/**
 * @classdesc RaphaelMapCharts is graph renderer for map chart.
 * @class RaphaelMapChart
 */
var RaphaelMapChart = tui.util.defineClass(/** @lends RaphaelMapChart.prototype */ {
    /**
     * Render function of map chart.
     * @param {HTMLElement} container container
     * @param {object} data data
     *      @param {{width: number, height: number}} data.dimension series dimension
     *      @param {Array.<{code: string, path: string}>} data.map mapData
     *      @param {ColorSpectrum} data.colorSpectrum color model
     * @returns {object} paper raphael paper
     */
    render: function(container, data) {
        var dimension = data.dimension,
            mapDimension = data.mapModel.getMapDimension(),
            paper;

        this.paper = paper = raphael(container, dimension.width, dimension.height);
        this.sectors = this._renderMap(data);
        this.overColor = data.theme.overColor;

        paper.setViewBox(0, 0, mapDimension.width, mapDimension.height, false);

        return paper;
    },

    /**
     * Render map graph.
     * @param {object} data data
     *      @param {{width: number, height: number}} data.dimension series dimension
     *      @param {Array.<{code: string, path: string}>} data.map mapData
     *      @param {ColorSpectrum} data.colorSpectrum color model
     * @returns {Array.<{sector: object, color: string, data: object}>} rendered map information
     * @private
     */
    _renderMap: function(data) {
        var paper = this.paper,
            colorSpectrum = data.colorSpectrum;

        return tui.util.map(data.mapModel.getMapData(), function(datum, index) {
            var ratio = datum.ratio || 0,
                color = colorSpectrum.getColor(ratio),
                sector = raphaelRenderUtil.renderArea(paper, datum.path, {
                    fill: color,
                    opacity: 1,
                    stroke: STROKE_COLOR,
                    'stroke-opacity': 1
                });

            sector.data('index', index);

            return {
                sector: sector,
                color: color,
                ratio: datum.ratio
            };
        });
    },

    /**
     * Find sector index.
     * @param {{left: number, top: number}} position position
     * @returns {?number} found index
     */
    findSectorIndex: function(position) {
        var sector = this.paper.getElementByPoint(position.left, position.top),
            foundIndex = sector && sector.data('index'),
            data = !tui.util.isUndefined(foundIndex) && this.sectors[foundIndex];

        return data && !tui.util.isUndefined(data.ratio) ? foundIndex : null;
    },

    /**
     * Change color.
     * @param {number} index index
     */
    changeColor: function(index) {
        var sector = this.sectors[index];

        sector.sector.animate({
            fill: this.overColor
        }, ANIMATION_DURATION);
    },

    /**
     * Restore color.
     * @param {number} index index
     */
    restoreColor: function(index) {
        var sector = this.sectors[index];

        sector.sector.animate({
            fill: sector.color
        }, ANIMATION_DURATION);
    },

    /**
     * Set size
     * @param {{width: number, height: number}} dimension dimension
     */
    setSize: function(dimension) {
        this.paper.setSize(dimension.width, dimension.height);
    }
});

module.exports = RaphaelMapChart;

},{"./raphaelRenderUtil":85}],83:[function(require,module,exports){
/**
 * @fileoverview RaphaelMapLegend is graph renderer for map chart legend.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

/*eslint no-magic-numbers: 0*/

var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

var PADDING = 10;

/**
 * @classdesc RaphaelMapLegend is graph renderer for map chart legend.
 * @class RaphaelMapLegend
 */
var RaphaelMapLegend = tui.util.defineClass(/** @lends RaphaelMapLegend.prototype */ {
    /**
     * Render function of map chart legend.
     * @param {HTMLElement} container container
     * @param {{width: number, height: number}} dimension legend dimension
     * @param {ColorSpectrum} colorSpectrum map chart color model
     * @param {boolean} isHorizontal whether horizontal legend or not
     * @returns {object} paper raphael paper
     */
    render: function(container, dimension, colorSpectrum, isHorizontal) {
        var paper = raphael(container, dimension.width, dimension.height);

        this._renderGradientBar(paper, dimension, colorSpectrum, isHorizontal);
        this.wedge = this._renderWedge(paper);

        return paper;
    },

    /**
     * Render gradient bar.
     * @param {object} paper raphael object
     * @param {{width: number, height: number}} dimension legend dimension
     * @param {ColorSpectrum} colorSpectrum map chart color model
     * @param {boolean} isHorizontal whether horizontal legend or not
     * @private
     */
    _renderGradientBar: function(paper, dimension, colorSpectrum, isHorizontal) {
        var rectHeight = dimension.height;
        var left = 0;
        var degree, bound;

        if (isHorizontal) {
            rectHeight -= PADDING;
            left = PADDING / 2;
            degree = 360;
            this._makeWedghPath = this._makeHorizontalWedgePath;
        } else {
            degree = 270;
            this._makeWedghPath = this._makeVerticalWedgePath;
        }

        bound = {
            left: left,
            top: 0,
            width: dimension.width - PADDING,
            height: rectHeight
        };

        raphaelRenderUtil.renderRect(paper, bound, {
            fill: degree + '-' + colorSpectrum.start + '-' + colorSpectrum.end,
            stroke: 'none'
        });
    },

    /**
     * Render wedge.
     * @param {object} paper raphael object
     * @returns {object} raphael object
     * @private
     */
    _renderWedge: function(paper) {
        var wedge = paper.path(this.verticalBasePath).attr({
            'fill': 'gray',
            stroke: 'none',
            opacity: 0
        });

        return wedge;
    },

    /**
     * Vertical base path
     * @type {Array}
     */
    verticalBasePath: ['M', 16, 6, 'L', 24, 3, 'L', 24, 9],

    /**
     * Make vertical wedge path.
     * @param {number} top top
     * @returns {Array} path
     * @private
     */
    _makeVerticalWedgePath: function(top) {
        var path = this.verticalBasePath;

        path[2] = top;
        path[5] = top - 3;
        path[8] = top + 3;

        return path;
    },

    /**
     * Horizontal base path
     * @type {Array}
     */
    horizontalBasePath: ['M', 5, 16, 'L', 8, 24, 'L', 2, 24],

    /**
     * Make horizontal wedge path.
     * @param {number} left left
     * @returns {Array} path
     * @private
     */
    _makeHorizontalWedgePath: function(left) {
        var path = this.horizontalBasePath;

        left += PADDING / 2;

        path[1] = left;
        path[4] = left + 3;
        path[7] = left - 3;

        return path;
    },

    /**
     * Show wedge.
     * @param {number} positionValue top
     */
    showWedge: function(positionValue) {
        var path = this._makeWedghPath(positionValue);

        this.wedge.attr({
            path: path,
            opacity: 1
        });
    },

    /**
     * Hide wedge
     */
    hideWedge: function() {
        this.wedge.attr({
            opacity: 0
        });
    }
});

module.exports = RaphaelMapLegend;

},{"./raphaelRenderUtil":85}],84:[function(require,module,exports){
/**
 * @fileoverview RaphaelPieCharts is graph renderer for pie chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

var DEGREE_180 = 180;
var DEGREE_360 = 360;
var MIN_DEGREE = 0.01;
var RAD = Math.PI / DEGREE_180;
var LOADING_ANIMATION_DURATION = 700;
var EMPHASIS_OPACITY = 1;
var DE_EMPHASIS_OPACITY = 0.3;
var DEFAULT_LUMINANC = 0.2;
var OVERLAY_ID = 'overlay';

/**
 * @classdesc RaphaelPieCharts is graph renderer for pie chart.
 * @class RaphaelPieChart
 */
var RaphaelPieChart = tui.util.defineClass(/** @lends RaphaelPieChart.prototype */ {
    /**
     * Render function of pie chart.
     * @param {HTMLElement} container container
     * @param {{
     *      sectorData: Array.<object>,
     *      circleBound: {cx: number, cy: number, r: number},
     *      dimension: object, theme: object, options: object
     * }} data render data
     * @param {object} callbacks callbacks
     *      @param {function} callbacks.showTooltip show tooltip function
     *      @param {function} callbacks.hideTooltip hide tooltip function
     * @returns {object} paper raphael paper
     */
    render: function(container, data, callbacks) {
        var dimension = data.dimension;
        var paper;

        /**
         * raphael object
         * @type {object}
         */
        if (data.paper) {
            this.paper = paper = data.paper;
        } else {
            this.paper = paper = raphael(container, dimension.width, dimension.height);
        }

        /**
         * series container
         * @type {HTMLElement}
         */
        this.container = container;

        /**
         * ratio for hole
         * @type {number}
         */
        this.holeRatio = data.options.radiusRange[0];

        /**
         * base background
         * @type {string}
         */
        this.chartBackground = data.chartBackground;

        /**
         * type of chart
         * @type {string}
         */
        this.chartType = data.chartType;

        /**
         * functions for tooltip control
         * @type {{showTooltip: Function, hideTooltip: Function}}
         */
        this.callbacks = callbacks;

        /**
         * color for selection
         * @type {string}
         */
        this.selectionColor = data.theme.selectionColor;

        /**
         * bound for circle
         * @type {{cx: number, cy: number, r: number}}
         */
        this.circleBound = data.circleBound;

        /**
         * sector attr's name for draw graph
         * @type {string}
         */
        this.sectorName = 'sector_' + this.chartType;

        this._setSectorAttr();

        this.sectorInfos = this._renderPie(data.sectorData, data.theme.colors);
        this.overlay = this._renderOverlay();

        /**
         * bound of container
         * @type {{left: number, top: number}}
         */
        this.containerBound = null;

        /**
         * selected previous sector
         * @type {object}
         */
        this.prevSelectedSector = null;

        /**
         * previous mouse position
         * @type {{left: number, top: number}}
         */
        this.prevPosition = null;

        /**
         * previous hover sector
         * @type {object}
         */
        this.prevHoverSector = null;

        return paper;
    },

    /**
     * Clear paper.
     */
    clear: function() {
        this.legendLines = null;
        this.paper.clear();
    },

    /**
     * Make sector path.
     * @param {number} cx center x
     * @param {number} cy center y
     * @param {number} r radius
     * @param {number} startAngle start angle
     * @param {number} endAngle end angel
     * @returns {{path: Array}} sector path
     * @private
     */
    _makeSectorPath: function(cx, cy, r, startAngle, endAngle) {
        var startRadian = startAngle * RAD;
        var endRadian = endAngle * RAD;
        var x1 = cx + r * Math.sin(startRadian); // 원 호의 시작 x 좌표
        var y1 = cy - r * Math.cos(startRadian); // 원 호의 시작 y 좌표
        var x2 = cx + r * Math.sin(endRadian); // 원 호의 종료 x 좌표
        var y2 = cy - r * Math.cos(endRadian); // 원 호의 종료 y 좌표
        var largeArcFlag = endAngle - startAngle > DEGREE_180 ? 1 : 0;
        var path = ['M', cx, cy,
            'L', x1, y1,
            'A', r, r, 0, largeArcFlag, 1, x2, y2,
            'Z'
        ];

        // path에 대한 자세한 설명은 아래 링크를 참고
        // http://www.w3schools.com/svg/svg_path.asp
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
        return {path: path};
    },

    /**
     * Make sector path for donut chart.
     * @param {number} cx - center x
     * @param {number} cy - center y
     * @param {number} r - radius
     * @param {number} startAngle - start angle
     * @param {number} endAngle - end angel
     * @param {number} [holeRadius] - hole radius
     * @returns {{path: Array}} sector path
     * @private
     */
    _makeDonutSectorPath: function(cx, cy, r, startAngle, endAngle, holeRadius) {
        /*eslint max-params: [2, 6]*/
        var startRadian = startAngle * RAD;
        var endRadian = endAngle * RAD;
        var r2 = holeRadius || (r * this.holeRatio); // 구멍 반지름
        var x1 = cx + r * Math.sin(startRadian);
        var y1 = cy - r * Math.cos(startRadian);
        var x2 = cx + r2 * Math.sin(startRadian);
        var y2 = cy - r2 * Math.cos(startRadian);
        var x3 = cx + r * Math.sin(endRadian);
        var y3 = cy - r * Math.cos(endRadian);
        var x4 = cx + r2 * Math.sin(endRadian);
        var y4 = cy - r2 * Math.cos(endRadian);
        var largeArcFlag = endAngle - startAngle > DEGREE_180 ? 1 : 0;
        var path = [
            'M', x1, y1,
            'A', r, r, 0, largeArcFlag, 1, x3, y3,
            'L', x4, y4,
            'A', r2, r2, 0, largeArcFlag, 0, x2, y2,
            'Z'
        ];

        return {path: path};
    },

    /**
     * Set sector attribute for raphael paper.
     * @private
     */
    _setSectorAttr: function() {
        var makeSectorPath;

        if (this.paper.customAttributes[this.sectorName]) {
            return;
        }

        if (this.holeRatio) {
            makeSectorPath = this._makeDonutSectorPath;
        } else {
            makeSectorPath = this._makeSectorPath;
        }

        this.paper.customAttributes[this.sectorName] = tui.util.bind(makeSectorPath, this);
    },

    /**
     * Render overlay.
     * @returns {object} raphael object
     * @private
     */
    _renderOverlay: function() {
        var params = {
            paper: this.paper,
            circleBound: {
                cx: 0,
                cy: 0,
                r: 0
            },
            angles: {
                startAngle: 0,
                endAngle: 0
            },
            attrs: {
                fill: 'none',
                opacity: 0,
                stroke: this.chartBackground,
                'stroke-width': 1
            }
        };
        var inner = this._renderSector(params);

        inner.data('id', OVERLAY_ID);
        inner.data('chartType', this.chartType);

        return {
            inner: inner,
            outer: this._renderSector(params)
        };
    },

    /**
     * Render sector
     * @param {object} params parameters
     *      @param {object} params.paper raphael paper
     *      @param {{cx: number, cy: number, r:number}} params.circleBound circle bounds
     *      @param {number} params.startAngle start angle
     *      @param {number} params.endAngle end angle
     *      @param {{fill: string, stroke: string, strike-width: string}} params.attrs attrs
     * @returns {object} raphael object
     * @private
     */
    _renderSector: function(params) {
        var circleBound = params.circleBound;
        var angles = params.angles;
        var attrs = params.attrs;

        attrs[this.sectorName] = [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle];

        return params.paper.path().attr(attrs);
    },

    /**
     * Render pie graph.
     * @param {Array.<object>} sectorData - sectorData
     * @param {Array.<string>} colors - sector colors
     * @returns {Array.<object>}
     * @private
     */
    _renderPie: function(sectorData, colors) {
        var self = this;
        var circleBound = this.circleBound;
        var chartBackground = this.chartBackground;
        var sectorInfos = [];

        tui.util.forEachArray(sectorData, function(sectorDatum, index) {
            var ratio = sectorDatum.ratio;
            var color = colors[index];
            var sector = self._renderSector({
                paper: self.paper,
                circleBound: circleBound,
                angles: sectorDatum.angles.start,
                attrs: {
                    fill: chartBackground,
                    stroke: chartBackground,
                    'stroke-width': 1
                }
            });
            sector.data('index', index);
            sector.data('chartType', self.chartType);

            sectorInfos.push({
                sector: sector,
                color: color,
                angles: sectorDatum.angles.end,
                ratio: ratio
            });
        });

        return sectorInfos;
    },

    /**
     * Render legend lines.
     * @param {Array.<object>} outerPositions outer position
     */
    renderLegendLines: function(outerPositions) {
        var paper = this.paper,
            paths;

        if (!this.legendLines) {
            paths = this._makeLinePaths(outerPositions);
            this.legendLines = tui.util.map(paths, function(path) {
                return raphaelRenderUtil.renderLine(paper, path, 'transparent', 1);
            });
        }
    },

    /**
     * Make line paths.
     * @param {Array.<object>} outerPositions outer positions
     * @returns {Array} line paths.
     * @private
     */
    _makeLinePaths: function(outerPositions) {
        var paths = tui.util.map(outerPositions, function(positions) {
            return [
                raphaelRenderUtil.makeLinePath(positions.start, positions.middle),
                raphaelRenderUtil.makeLinePath(positions.middle, positions.end),
                'Z'
            ].join('');
        });

        return paths;
    },

    /**
     * Show overlay.
     * @param {number} index - index
     * @private
     */
    _showOverlay: function(index) {
        var overlay = this.overlay;
        var sectorInfo = this.sectorInfos[index];
        var sa = sectorInfo.angles.startAngle;
        var ea = sectorInfo.angles.endAngle;
        var cb = this.circleBound;
        var innerAttrs;

        innerAttrs = {
            fill: '#fff',
            opacity: 0.3
        };
        innerAttrs[this.sectorName] = [cb.cx, cb.cy, cb.r, sa, ea, cb.r * this.holeRatio];
        overlay.inner.attr(innerAttrs);
        overlay.inner.data('index', index);
        overlay.outer.attr({
            path: this._makeDonutSectorPath(cb.cx, cb.cy, cb.r + 10, sa, ea, cb.r).path,
            fill: sectorInfo.color,
            opacity: 0.3
        });
    },

    /**
     * Hide overlay.
     * @private
     */
    _hideOverlay: function() {
        var overlay = this.overlay;
        var attrs = {
            fill: 'none',
            opacity: 0
        };

        overlay.inner.attr(attrs);
        overlay.outer.attr(attrs);
    },

    /**
     * Animate.
     * @param {function} callback callback
     */
    animate: function(callback) {
        var delayTime = 0;
        var sectorName = this.sectorName;
        var circleBound = this.circleBound;
        var sectorArgs = [circleBound.cx, circleBound.cy, circleBound.r];

        tui.util.forEachArray(this.sectorInfos, function(sectorInfo) {
            var angles = sectorInfo.angles;
            var attrMap = {
                fill: sectorInfo.color
            };
            var animationTime = LOADING_ANIMATION_DURATION * sectorInfo.ratio;
            var anim;

            if ((angles.startAngle === 0) && (angles.endAngle === DEGREE_360)) {
                angles.endAngle = DEGREE_360 - MIN_DEGREE;
            }

            attrMap[sectorName] = sectorArgs.concat([angles.startAngle, angles.endAngle]);
            anim = raphael.animation(attrMap, animationTime);
            sectorInfo.sector.animate(anim.delay(delayTime));
            delayTime += animationTime;
        });

        if (callback) {
            setTimeout(callback, delayTime);
        }
    },

    /**
     * Animate legend lines.
     * @param {?number} legendIndex legend index
     */
    animateLegendLines: function(legendIndex) {
        var isNull;

        if (!this.legendLines) {
            return;
        }

        isNull = tui.util.isNull(legendIndex);

        tui.util.forEachArray(this.legendLines, function(line, index) {
            var opacity = (isNull || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            line.animate({
                'stroke': 'black',
                'stroke-opacity': opacity
            });
        });
    },

    /**
     * Resize graph of pie chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {{cx:number, cy:number, r: number}} params.circleBound circle bound
     */
    resize: function(params) {
        var dimension = params.dimension;
        var circleBound = params.circleBound;
        var sectorName = this.sectorName;

        this.circleBound = circleBound;
        this.paper.setSize(dimension.width, dimension.height);
        this.containerBound = null;

        tui.util.forEachArray(this.sectorInfos, function(sectorInfo) {
            var angles = sectorInfo.angles;
            var attrs = {};
            attrs[sectorName] = [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle];
            sectorInfo.sector.attr(attrs);
        });
    },

    /**
     * Move legend lines.
     * @param {Array.<object>} outerPositions outer positions
     */
    moveLegendLines: function(outerPositions) {
        var paths;

        if (!this.legendLines) {
            return;
        }

        paths = this._makeLinePaths(outerPositions);
        tui.util.forEachArray(this.legendLines, function(line, index) {
            line.attr({path: paths[index]});

            return line;
        });
    },

    /**
     * Whether valid sector or not.
     * @param {object} sector - raphael object
     * @returns {boolean}
     * @private
     */
    _isValidSector: function(sector) {
        return sector && sector.data('chartType') === this.chartType;
    },

    /**
     * Whether detected label element or not.
     * @param {{left: number, top: number}} position - mouse position
     * @returns {boolean}
     * @private
     */
    _isDetectedLabel: function(position) {
        var labelElement = document.elementFromPoint(position.left, position.top);

        return tui.util.isString(labelElement.className);
    },

    /**
     * Click series.
     * @param {{left: number, top: number}} position mouse position
     */
    clickSeries: function(position) {
        var sector = this.paper.getElementByPoint(position.left, position.top);
        var prevSector = this.prevSelectedSector;
        var sectorIndex;

        if ((sector || this._isDetectedLabel(position)) && this.prevSelectedSector) {
            this._unselectSeries(this.prevSelectedSector.data('index'));
            this.prevSelectedSector = null;
        }

        if (!this._isValidSector(sector)) {
            return;
        }

        sectorIndex = sector.data('index');
        sector = this.sectorInfos[sectorIndex].sector;

        if (sector !== prevSector) {
            this._selectSeries(sectorIndex);
            this.prevSelectedSector = sector;
        }
    },


    /**
     * Get series container bound.
     * @returns {{left: number, top: number}} container bound
     * @private
     */
    _getContainerBound: function() {
        if (!this.containerBound) {
            this.containerBound = this.container.getBoundingClientRect();
        }

        return this.containerBound;
    },

    /**
     * Whether changed or not.
     * @param {{left: number, top: number}} prevPosition previous position
     * @param {{left: number, top: number}} position position
     * @returns {boolean} result boolean
     * @private
     */
    _isChangedPosition: function(prevPosition, position) {
        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
    },

    /**
     * Show tooltip.
     * @param {object} sector - raphael object
     * @param {{left: number, top: number}} position - mouse position
     * @private
     */
    _showTooltip: function(sector, position) {
        var containerBound = this._getContainerBound();
        var args = [{}, 0, sector.data('index'), {
            left: position.left - containerBound.left,
            top: position.top - containerBound.top
        }];
        this.callbacks.showTooltip.apply(null, args);
    },

    /**
     * Move mouse on series.
     * @param {{left: number, top: number}} position mouse position
     */
    moveMouseOnSeries: function(position) {
        var sector = this.paper.getElementByPoint(position.left, position.top);

        if (this._isValidSector(sector)) {
            if (this.prevHoverSector !== sector) {
                this._showOverlay(sector.data('index'));
                this.prevHoverSector = sector;
            }

            if (this._isChangedPosition(this.prevPosition, position)) {
                this._showTooltip(sector, position);
            }
        } else if (this.prevHoverSector) {
            this._hideOverlay();
            this.callbacks.hideTooltip();
            this.prevHoverSector = null;
        }

        this.prevPosition = position;
    },

    /**
     * Select series.
     * @param {number} index index
     * @private
     */
    _selectSeries: function(index) {
        var sectorInfo = this.sectorInfos[index];
        var objColor, color;

        if (!sectorInfo) {
            return;
        }

        objColor = raphael.color(sectorInfo.color);
        color = this.selectionColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC);

        sectorInfo.sector.attr({
            fill: color
        });
    },

    /**
     * Unelect series.
     * @param {number} index index
     * @private
     */
    _unselectSeries: function(index) {
        var sectorInfo = this.sectorInfos[index];

        if (!sectorInfo) {
            return;
        }

        sectorInfo.sector.attr({
            fill: sectorInfo.color
        });
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var isNull = tui.util.isNull(legendIndex);
        var legendLines = this.legendLines;

        tui.util.forEachArray(this.sectorInfos, function(sectorInfo, index) {
            var opacity = (isNull || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            sectorInfo.sector.attr({
                'fill-opacity': opacity
            });

            if (legendLines) {
                legendLines[index].attr({
                    'stroke-opacity': opacity
                });
            }
        });
    }
});

module.exports = RaphaelPieChart;

},{"./raphaelRenderUtil":85}],85:[function(require,module,exports){
/**
 * @fileoverview Util for raphael rendering.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * Util for raphael rendering.
 * @module raphaelRenderUtil
 */
var raphaelRenderUtil = {
    /**
     * Make line path.
     * @memberOf module:raphaelRenderUtil
     * @param {{top: number, left: number}} fromPos from position
     * @param {{top: number, left: number}} toPos to position
     * @param {number} width width
     * @returns {string} path
     */
    makeLinePath: function(fromPos, toPos, width) {
        var fromPoint = [fromPos.left, fromPos.top],
            toPoint = [toPos.left, toPos.top];

        width = width || 1;

        tui.util.forEachArray(fromPoint, function(from, index) {
            if (from === toPoint[index]) {
                fromPoint[index] = toPoint[index] = Math.round(from) - (width % 2 / 2);
            }
        });

        return ['M'].concat(fromPoint).concat('L').concat(toPoint);
    },

    /**
     * Render line.
     * @memberOf module:raphaelRenderUtil
     * @param {object} paper raphael paper
     * @param {string} path line path
     * @param {string} color line color
     * @param {number} strokeWidth stroke width
     * @returns {object} raphael line
     */
    renderLine: function(paper, path, color, strokeWidth) {
        var line = paper.path([path]),
            strokeStyle = {
                stroke: color,
                'stroke-width': strokeWidth || 2
            };

        if (color === 'transparent') {
            strokeStyle.stroke = '#fff';
            strokeStyle['stroke-opacity'] = 0;
        }
        line.attr(strokeStyle);

        return line;
    },

    /**
     * Render area graph.
     * @param {object} paper raphael paper
     * @param {string} path path
     * @param {object} fillStyle fill style
     *      @param {string} fillStyle.fill fill color
     *      @param {?number} fillStyle.opacity fill opacity
     *      @param {string} fillStyle.stroke stroke color
     *      @param {?number} fillStyle.stroke-opacity stroke opacity
     * @returns {Array.<object>} raphael object
     */
    renderArea: function(paper, path, fillStyle) {
        var area = paper.path(path);

        fillStyle = tui.util.extend({
            'stroke-opacity': 0
        }, fillStyle);
        area.attr(fillStyle);

        return area;
    },

    /**
     * Render circle.
     * @param {object} paper - raphael object
     * @param {{left: number, top: number}} position - position
     * @param {number} radius - radius
     * @param {object} attributes - attributes
     * @returns {object}
     * @private
     */
    renderCircle: function(paper, position, radius, attributes) {
        var circle = paper.circle(position.left, position.top, radius);

        if (attributes) {
            circle.attr(attributes);
        }

        return circle;
    },

    /**
     * Render rect.
     * @param {object} paper - raphael object
     * @param {{left: number, top: number, width: number, height, number}} bound - bound
     * @param {object} attributes - attributes
     * @returns {*}
     */
    renderRect: function(paper, bound, attributes) {
        var rect = paper.rect(bound.left, bound.top, bound.width, bound.height);

        if (attributes) {
            rect.attr(attributes);
        }

        return rect;
    },

    /**
     * Update rect bound
     * @param {object} rect raphael object
     * @param {{left: number, top: number, width: number, height: number}} bound bound
     */
    updateRectBound: function(rect, bound) {
        rect.attr({
            x: bound.left,
            y: bound.top,
            width: bound.width,
            height: bound.height
        });
    },

    /**
     * Render items of line type chart.
     * @param {Array.<Array.<object>>} groupItems group items
     * @param {function} funcRenderItem function
     */
    forEach2dArray: function(groupItems, funcRenderItem) {
        tui.util.forEachArray(groupItems, function(items, groupIndex) {
            tui.util.forEachArray(items, function(item, index) {
                funcRenderItem(item, groupIndex, index);
            });
        });
    },

    /**
     * Make changed luminance color.
     * @param {string} hex hax color
     * @param {number} lum luminance
     * @returns {string} changed color
     */
    makeChangedLuminanceColor: function(hex, lum) {
        /*eslint no-magic-numbers: 0*/
        var changedHex;

        hex = hex.replace('#', '');
        lum = lum || 0;

        changedHex = tui.util.map(tui.util.range(3), function(index) {
            var hd = parseInt(hex.substr(index * 2, 2), 16);
            var newHd = hd + (hd * lum);

            newHd = Math.round(Math.min(Math.max(0, newHd), 255)).toString(16);

            return tui.chart.renderUtil.formatToZeroFill(newHd, 2);
        }).join('');

        return '#' + changedHex;
    }
};

module.exports = raphaelRenderUtil;

},{}],86:[function(require,module,exports){
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON
// Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
if (!window.JSON) {
    window.JSON = {
        parse: function(sJSON) { return eval('(' + sJSON + ')'); },
        stringify: (function () {
            var toString = Object.prototype.toString;
            var isArray = Array.isArray || function (a) { return toString.call(a) === '[object Array]'; };
            var escMap = {'"': '\\"', '\\': '\\\\', '\b': '\\b', '\f': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'};
            var escFunc = function (m) { return escMap[m] || '\\u' + (m.charCodeAt(0) + 0x10000).toString(16).substr(1); };
            var escRE = /[\\"\u0000-\u001F\u2028\u2029]/g;
            return function stringify(value) {
                if (value == null) {
                    return 'null';
                } else if (typeof value === 'number') {
                    return isFinite(value) ? value.toString() : 'null';
                } else if (typeof value === 'boolean') {
                    return value.toString();
                } else if (typeof value === 'object') {
                    if (typeof value.toJSON === 'function') {
                        return stringify(value.toJSON());
                    } else if (isArray(value)) {
                        var res = '[';
                        for (var i = 0; i < value.length; i++)
                            res += (i ? ', ' : '') + stringify(value[i]);
                        return res + ']';
                    } else if (toString.call(value) === '[object Object]') {
                        var tmp = [];
                        for (var k in value) {
                            if (value.hasOwnProperty(k))
                                tmp.push(stringify(k) + ': ' + stringify(value[k]));
                        }
                        return '{' + tmp.join(', ') + '}';
                    }
                }
                return '"' + value.toString().replace(escRE, escFunc) + '"';
            };
        })()
    };
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
// Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
if (typeof Object.create != 'function') {
    Object.create = (function(undefined) {
        var Temp = function() {};
        return function (prototype, propertiesObject) {
            if(prototype !== Object(prototype) && prototype !== null) {
                throw TypeError('Argument must be an object, or null');
            }
            Temp.prototype = prototype || {};
            if (propertiesObject !== undefined) {
                Object.defineProperties(Temp.prototype, propertiesObject);
            }
            var result = new Temp();
            Temp.prototype = null;
            // to imitate the case of Object.create(null)
            if(prototype === null) {
                result.__proto__ = null;
            }
            return result;
        };
    })();
}

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
// MIT license

(function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function (callback) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () {
                    callback(currTime + timeToCall);
                },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }

    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
    }
}());

},{}],87:[function(require,module,exports){
'use strict';

var chartConst = require('./const');
var chartFactory = require('./factories/chartFactory');
var BarChart = require('./charts/barChart');
var ColumnChart = require('./charts/columnChart');
var LineChart = require('./charts/lineChart');
var AreaChart = require('./charts/areaChart');
var ColumnLineComboChart = require('./charts/columnLineComboChart');
var LineAreaComboChart = require('./charts/lineAreaComboChart');
var PieDonutComboChart = require('./charts/pieDonutComboChart');
var PieChart = require('./charts/pieChart');
var BubbleChart = require('./charts/bubbleChart');
var ScatterChart = require('./charts/scatterChart');
var HeatmapChart = require('./charts/heatmapChart');
var TreemapChart = require('./charts/treemapChart');
var MapChart = require('./charts/mapChart');

chartFactory.register(chartConst.CHART_TYPE_BAR, BarChart);
chartFactory.register(chartConst.CHART_TYPE_COLUMN, ColumnChart);
chartFactory.register(chartConst.CHART_TYPE_LINE, LineChart);
chartFactory.register(chartConst.CHART_TYPE_AREA, AreaChart);
chartFactory.register(chartConst.CHART_TYPE_COLUMN_LINE_COMBO, ColumnLineComboChart);
chartFactory.register(chartConst.CHART_TYPE_LINE_AREA_COMBO, LineAreaComboChart);
chartFactory.register(chartConst.CHART_TYPE_PIE_DONUT_COMBO, PieDonutComboChart);
chartFactory.register(chartConst.CHART_TYPE_PIE, PieChart);
chartFactory.register(chartConst.CHART_TYPE_BUBBLE, BubbleChart);
chartFactory.register(chartConst.CHART_TYPE_SCATTER, ScatterChart);
chartFactory.register(chartConst.CHART_TYPE_HEATMAP, HeatmapChart);
chartFactory.register(chartConst.CHART_TYPE_TREEMAP, TreemapChart);
chartFactory.register(chartConst.CHART_TYPE_MAP, MapChart);

},{"./charts/areaChart":5,"./charts/barChart":8,"./charts/bubbleChart":10,"./charts/columnChart":13,"./charts/columnLineComboChart":14,"./charts/heatmapChart":17,"./charts/lineAreaComboChart":18,"./charts/lineChart":19,"./charts/mapChart":21,"./charts/pieChart":23,"./charts/pieDonutComboChart":24,"./charts/scatterChart":26,"./charts/treemapChart":27,"./const":31,"./factories/chartFactory":50}],88:[function(require,module,exports){
'use strict';

var chartConst = require('./const'),
    themeFactory = require('./factories/themeFactory'),
    defaultTheme = require('./themes/defaultTheme');

themeFactory.register(chartConst.DEFAULT_THEME_NAME, defaultTheme);

},{"./const":31,"./factories/themeFactory":53,"./themes/defaultTheme":107}],89:[function(require,module,exports){
/**
 * @fileoverview Area chart series component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series');
var LineTypeSeriesBase = require('./lineTypeSeriesBase');
var chartConst = require('../const');
var predicate = require('../helpers/predicate');

var AreaChartSeries = tui.util.defineClass(Series, /** @lends AreaChartSeries.prototype */ {
    /**
     * Area chart series component.
     * @constructs AreaChartSeries
     * @extends Series
     * @mixes LineTypeSeriesBase
     */
    init: function() {
        Series.apply(this, arguments);

        /**
         * object for requestAnimationFrame
         * @type {null | {id: number}}
         */
        this.movingAnimation = null;
    },

    /**
     * Make position top of zero point.
     * @returns {number} position top
     * @private
     */
    _makePositionTopOfZeroPoint: function() {
        var dimension = this.boundsMaker.getDimension('series');
        var limit = this.boundsMaker.getAxesData().yAxis.limit;
        var top = this._getLimitDistanceFromZeroPoint(dimension.height, limit).toMax;

        if (limit.min >= 0 && !top) {
            top = dimension.height;
        }

        return top + chartConst.SERIES_EXPAND_SIZE;
    },

    /**
     * Make stackType positions.
     * @param {Array.<Array.<{left: number, top: number}>>} groupPositions group positions
     * @returns {Array.<Array.<{left: number, top: number, startTop: number}>>} stackType positions
     * @private
     */
    _makeStackedPositions: function(groupPositions) {
        var height = this.boundsMaker.getDimension('series').height + chartConst.SERIES_EXPAND_SIZE,
            firstStartTop = this._makePositionTopOfZeroPoint(),
            prevPositionTops = [];

        return tui.util.map(groupPositions, function(positions) {
            return tui.util.map(positions, function(position, index) {
                var prevTop = prevPositionTops[index] || firstStartTop;
                var stackedHeight = height - position.top;
                var top = prevTop - stackedHeight;

                position.startTop = prevTop;
                position.top = top;

                prevPositionTops[index] = top;

                return position;
            });
        });
    },

    /**
     * Make positions.
     * @param {number} seriesWidth - width of series area
     * @returns {Array.<Array.<{left: number, top: number, startTop: number}>>} stackType positions
     * @private
     */
    _makePositions: function(seriesWidth) {
        var groupPositions = this._makeBasicPositions(seriesWidth);

        if (predicate.isValidStackOption(this.options.stackType)) {
            groupPositions = this._makeStackedPositions(groupPositions);
        }

        return groupPositions;
    },

    /**
     * Make series data.
     * @returns {object} series data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        var dimension = this.boundsMaker.getDimension('series'),
            zeroTop = this._getLimitDistanceFromZeroPoint(dimension.height, this.data.limit).toMax;

        return {
            chartBackground: this.chartBackground,
            groupPositions: this._makePositions(),
            hasRangeData: this._getSeriesDataModel().hasRangeData(),
            zeroTop: zeroTop + chartConst.SERIES_EXPAND_SIZE
        };
    },

    /**
     * Rerender.
     * @param {object} data - data for rerendering
     * @override
     */
    rerender: function(data) {
        var paper;

        this._cancelMovingAnimation();

        paper = Series.prototype.rerender.call(this, data);

        return paper;
    }
});

LineTypeSeriesBase.mixin(AreaChartSeries);

module.exports = AreaChartSeries;

},{"../const":31,"../helpers/predicate":61,"./lineTypeSeriesBase":97,"./series":102}],90:[function(require,module,exports){
/**
 * @fileoverview Bar chart series component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series');
var BarTypeSeriesBase = require('./barTypeSeriesBase');
var chartConst = require('../const');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');
var calculator = require('../helpers/calculator');

var BarChartSeries = tui.util.defineClass(Series, /** @lends BarChartSeries.prototype */ {
    /**
     * Bar chart series component.
     * @constructs BarChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make bound of bar chart.
     * @param {number} width width
     * @param {number} height height
     * @param {number} top top position value
     * @param {number} startLeft start left position value
     * @param {number} endLeft end left position value
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeBound: function(width, height, top, startLeft, endLeft) {
        return {
            start: {
                top: top,
                left: startLeft,
                width: 0,
                height: height
            },
            end: {
                top: top,
                left: endLeft,
                width: width,
                height: height
            }
        };
    },

    /**
     * Calculate additional left for divided option.
     * @param {number} value value
     * @returns {number}
     * @private
     */
    _calculateAdditionalLeft: function(value) {
        var additionalLeft = 0;

        if (this.options.divided && value > 0) {
            additionalLeft = this.boundsMaker.getDimension('yAxis').width + chartConst.OVERLAPPING_WIDTH;
        }

        return additionalLeft;
    },

    /**
     * Make bar chart bound.
     * @param {{
     *      baseSize: number,
     *      basePosition: number,
     *      step: number,
     *      additionalPosition: ?number,
     *      barSize: number
     * }} baseData base data for making bound
     * @param {{
     *      baseTop: number,
     *      top: number,
     *      plusLeft: number,
     *      minusLeft: number,
     *      prevStack: ?string
     * }} iterationData iteration data
     * @param {?boolean} isStackType whether stackType option or not.
     * @param {SeriesItem} seriesItem series item
     * @param {number} index index
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }}
     * @private
     */
    _makeBarChartBound: function(baseData, iterationData, isStackType, seriesItem, index) {
        var barWidth = baseData.baseBarSize * seriesItem.ratioDistance,
            additionalLeft = this._calculateAdditionalLeft(seriesItem.value),
            barStartLeft = baseData.baseBarSize * seriesItem.startRatio,
            startLeft = baseData.basePosition + barStartLeft + additionalLeft + chartConst.SERIES_EXPAND_SIZE,
            changedStack = (seriesItem.stack !== iterationData.prevStack),
            stepCount, endLeft, bound;

        if (!isStackType || (!this.options.diverging && changedStack)) {
            stepCount = isStackType ? this.dataProcessor.findStackIndex(seriesItem.stack) : index;
            iterationData.top = (baseData.step * stepCount) + iterationData.baseTop + baseData.additionalPosition;
            iterationData.plusLeft = 0;
            iterationData.minusLeft = 0;
        }

        if (seriesItem.value >= 0) {
            endLeft = startLeft + iterationData.plusLeft;
            iterationData.plusLeft += barWidth;
        } else {
            iterationData.minusLeft -= barWidth;
            endLeft = startLeft + iterationData.minusLeft;
        }

        iterationData.prevStack = seriesItem.stack;

        bound = this._makeBound(barWidth, baseData.barSize, iterationData.top, startLeft, endLeft);

        return bound;
    },

    /**
     * Make bounds of bar chart.
     * @returns {Array.<Array.<object>>} bounds
     * @private
     */
    _makeBounds: function() {
        var self = this,
            seriesDataModel = this._getSeriesDataModel(),
            isStacked = predicate.isValidStackOption(this.options.stackType),
            dimension = this.boundsMaker.getDimension('series'),
            baseData = this._makeBaseDataForMakingBound(dimension.height, dimension.width);

        return seriesDataModel.map(function(seriesGroup, groupIndex) {
            var baseTop = (groupIndex * baseData.groupSize) + baseData.firstAdditionalPosition
                        + chartConst.SERIES_EXPAND_SIZE,
                iterationData = {
                    baseTop: baseTop,
                    top: baseTop,
                    plusLeft: 0,
                    minusLeft: 0,
                    prevStack: null
                },
                iteratee = tui.util.bind(self._makeBarChartBound, self, baseData, iterationData, isStacked);

            return seriesGroup.map(iteratee);
        });
    },

    /**
     * Calculate top position of sum label.
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {number} top position value
     * @private
     */
    _calculateTopPositionOfSumLabel: function(bound, labelHeight) {
        return bound.top + ((bound.height - labelHeight + chartConst.TEXT_PADDING) / 2);
    },

    /**
     * Make html of plus sum label.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {string} plus sum label html
     * @private
     */
    _makePlusSumLabelHtml: function(values, bound, labelHeight) {
        var html = '';
        var sum, formatFunctions, formattedSum;

        if (bound) {
            sum = calculator.sumPlusValues(values);
            formatFunctions = this.dataProcessor.getFormatFunctions();
            formattedSum = renderUtil.formatValue(sum, formatFunctions, this.chartType, 'series');
            html = this._makeSeriesLabelHtml({
                left: bound.left + bound.width + chartConst.SERIES_LABEL_PADDING,
                top: this._calculateTopPositionOfSumLabel(bound, labelHeight)
            }, formattedSum, -1);
        }

        return html;
    },

    /**
     * Make minus sum label html.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {string} plus minus label html
     * @private
     */
    _makeMinusSumLabelHtml: function(values, bound, labelHeight) {
        var html = '';
        var sum, formatFunctions, formattedSum, labelWidth;

        if (bound) {
            sum = calculator.sumMinusValues(values);

            if (this.options.diverging) {
                sum = Math.abs(sum);
            }

            formatFunctions = this.dataProcessor.getFormatFunctions();
            formattedSum = renderUtil.formatValue(sum, formatFunctions, this.chartType, 'series');
            labelWidth = renderUtil.getRenderedLabelWidth(formattedSum, this.theme.label);
            html = this._makeSeriesLabelHtml({
                left: bound.left - labelWidth - chartConst.SERIES_LABEL_PADDING,
                top: this._calculateTopPositionOfSumLabel(bound, labelHeight)
            }, formattedSum, -1);
        }

        return html;
    }
});

BarTypeSeriesBase.mixin(BarChartSeries);

module.exports = BarChartSeries;

},{"../const":31,"../helpers/calculator":57,"../helpers/predicate":61,"../helpers/renderUtil":63,"./barTypeSeriesBase":91,"./series":102}],91:[function(require,module,exports){
/**
 * @fileoverview BarTypeSeriesBase is base class for bar type series.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');
var labelHelper = require('./renderingLabelHelper');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');

var BarTypeSeriesBase = tui.util.defineClass(/** @lends BarTypeSeriesBase.prototype */ {
    /**
     * Make series data.
     * @returns {object} add data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        this.groupBounds = this._makeBounds(this.boundsMaker.getDimension('series'));

        return {
            groupBounds: this.groupBounds,
            seriesDataModel: this._getSeriesDataModel()
        };
    },

    /**
     * Make bar gutter.
     * @param {number} groupSize bar group size
     * @param {number} itemCount group item count
     * @returns {number} bar gutter
     * @private
     */
    _makeBarGutter: function(groupSize, itemCount) {
        var baseSize = groupSize / (itemCount + 1) / 2;
        var standardSize = 6;
        var gutter;

        if (baseSize <= 2) {
            gutter = 0;
        } else if (baseSize <= standardSize) {
            gutter = 2;
        } else {
            gutter = 4;
        }

        return gutter;
    },

    /**
     * Make bar size.
     * @param {number} groupSize bar group size
     * @param {number} barGutter bar padding
     * @param {number} itemCount group item count
     * @returns {number} bar size (width or height)
     * @private
     */
    _makeBarSize: function(groupSize, barGutter, itemCount) {
        return (groupSize - (barGutter * (itemCount - 1))) / (itemCount + 1);
    },

    /**
     * Make option size.
     * @param {number} barSize bar size
     * @param {?number} optionBarWidth barWidth option
     * @returns {number} option size
     * @private
     */
    _makeOptionSize: function(barSize, optionBarWidth) {
        var optionsSize = 0;

        if (optionBarWidth) {
            optionsSize = Math.min(barSize, optionBarWidth);
        }

        return optionsSize;
    },

    /**
     * Calculate difference between optionSize and barSize.
     * @param {number} barSize bar size
     * @param {number} optionSize option size
     * @param {number} itemCount item count
     * @returns {number} addition padding
     * @private
     */
    _calculateAdditionalPosition: function(barSize, optionSize, itemCount) {
        var additionalPosition = 0;

        if (optionSize && optionSize < barSize) {
            additionalPosition = (barSize / 2) + ((barSize - optionSize) * itemCount / 2);
        }

        return additionalPosition;
    },

    /**
     * Make base data for making bound.
     * @param {number} baseGroupSize base group size
     * @param {number} baseBarSize base bar size
     * @returns {{
     *      baseBarSize: number,
     *      groupSize: number,
     *      barSize: number,
     *      step: number,
     *      firstAdditionalPosition: number,
     *      additionalPosition: number,
     *      basePosition: number
     * }}
     * @private
     */
    _makeBaseDataForMakingBound: function(baseGroupSize, baseBarSize) {
        var isStackType = predicate.isValidStackOption(this.options.stackType);
        var seriesDataModel = this._getSeriesDataModel();
        var groupSize = baseGroupSize / seriesDataModel.getGroupCount();
        var firstAdditionalPosition = 0;
        var itemCount, barGutter, barSize, optionSize, additionalPosition, basePosition;

        if (!isStackType) {
            itemCount = seriesDataModel.getFirstSeriesGroup().getSeriesItemCount();
        } else {
            itemCount = this.options.diverging ? 1 : this.dataProcessor.getStackCount();
        }

        barGutter = this._makeBarGutter(groupSize, itemCount);
        barSize = this._makeBarSize(groupSize, barGutter, itemCount);
        optionSize = this._makeOptionSize(barSize, this.options.barWidth);
        additionalPosition = this._calculateAdditionalPosition(barSize, optionSize, itemCount);
        barSize = optionSize || barSize;
        basePosition = this._getLimitDistanceFromZeroPoint(baseBarSize, this.data.limit).toMin;

        if (predicate.isColumnChart(this.chartType)) {
            basePosition = baseBarSize - basePosition;
        }

        if (!this.options.barWidth || barSize < this.options.barWidth) {
            firstAdditionalPosition = (barSize / 2) + additionalPosition;
        }

        return {
            baseBarSize: baseBarSize,
            groupSize: groupSize,
            barSize: barSize,
            step: barGutter + barSize,
            firstAdditionalPosition: firstAdditionalPosition,
            additionalPosition: additionalPosition,
            basePosition: basePosition
        };
    },

    /**
     * Render normal series label.
     * @param {HTMLElement} labelContainer series label area element
     * @private
     */
    _renderNormalSeriesLabel: function(labelContainer) {
        var sdm = this._getSeriesDataModel();
        var boundsSet = this.seriesData.groupBounds;
        var labelTheme = this.theme.label;
        var selectedIndex = this.selectedLegendIndex;
        var positionsSet, html;

        if (predicate.isBarChart(this.chartType)) {
            positionsSet = labelHelper.boundsToLabelPositionsForBarChart(sdm, boundsSet, labelTheme);
        } else {
            positionsSet = labelHelper.boundsToLabelPositionsForColumnChart(sdm, boundsSet, labelTheme);
        }

        html = labelHelper.makeLabelsHtmlForBoundType(sdm, positionsSet, labelTheme, selectedIndex);

        labelContainer.innerHTML = html;
    },

    /**
     * Make sum values.
     * @param {Array.<number>} values values
     * @returns {number} sum result.
     */
    _makeSumValues: function(values) {
        var sum = tui.util.sum(values);

        return renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions(), this.chartType, 'seires');
    },

    /**
     * Make stackType label position.
     * @param {{width: number, height: number, left: number, top: number}} bound element bound
     * @param {string} label label
     * @param {number} labelHeight label height
     * @returns {{left: number, top: number}} position
     * @private
     */
    _makeStackedLabelPosition: function(bound, label, labelHeight) {
        var labelWidth = renderUtil.getRenderedLabelWidth(label, this.theme.label),
            left = bound.left + ((bound.width - labelWidth + chartConst.TEXT_PADDING) / 2),
            top = bound.top + ((bound.height - labelHeight + chartConst.TEXT_PADDING) / 2);

        return {
            left: left,
            top: top
        };
    },

    /**
     * Make stackType labels html.
     * @param {object} params parameters
     *      @param {number} params.groupIndex group index
     *      @param {Array.<object>} params.bounds bounds,
     *      @param {number} params.labelHeight label height
     * @returns {string} labels html
     * @private
     */
    _makeStackedLabelsHtml: function(params) {
        var self = this,
            seriesGroup = params.seriesGroup,
            labelHeight = params.labelHeight,
            htmls, plusBound, minusBound, values;

        htmls = seriesGroup.map(function(seriesItem, index) {
            var bound = params.bounds[index],
                labelHtml = '',
                boundEnd, position;

            if (bound && seriesItem) {
                boundEnd = bound.end;
                position = self._makeStackedLabelPosition(boundEnd, seriesItem.label, params.labelHeight);
                labelHtml = self._makeSeriesLabelHtml(position, seriesItem.label, index);
            }

            if (seriesItem.value > 0) {
                plusBound = boundEnd;
            } else if (seriesItem.value < 0) {
                minusBound = boundEnd;
            }

            return labelHtml;
        });

        if (this.options.stackType === 'normal') {
            values = seriesGroup.pluck('value');
            htmls.push(this._makePlusSumLabelHtml(values, plusBound, labelHeight));
            htmls.push(this._makeMinusSumLabelHtml(values, minusBound, labelHeight));
        }

        return htmls.join('');
    },

    /**
     * Render stackType series label.
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderStackedSeriesLabel: function(elSeriesLabelArea) {
        var self = this;
        var groupBounds = this.seriesData.groupBounds;
        var seriesDataModel = this._getSeriesDataModel();
        var labelHeight = renderUtil.getRenderedLabelHeight(chartConst.MAX_HEIGHT_WORLD, this.theme.label);
        var html = seriesDataModel.map(function(seriesGroup, index) {
            var labelsHtml = self._makeStackedLabelsHtml({
                groupIndex: index,
                seriesGroup: seriesGroup,
                bounds: groupBounds[index],
                labelHeight: labelHeight
            });

            return labelsHtml;
        }).join('');

        elSeriesLabelArea.innerHTML = html;
    },

    /**
     * Render series label.
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderSeriesLabel: function(elSeriesLabelArea) {
        if (this.options.stackType) {
            this._renderStackedSeriesLabel(elSeriesLabelArea);
        } else {
            this._renderNormalSeriesLabel(elSeriesLabelArea);
        }
    }
});

BarTypeSeriesBase.mixin = function(func) {
    tui.util.extend(func.prototype, BarTypeSeriesBase.prototype);
};

module.exports = BarTypeSeriesBase;

},{"../const":31,"../helpers/predicate":61,"../helpers/renderUtil":63,"./renderingLabelHelper":100}],92:[function(require,module,exports){
/**
 * @fileoverview Bubble chart series component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series');
var CoordinateTypeSeriesBase = require('./coordinateTypeSeriesBase');

var BubbleChartSeries = tui.util.defineClass(Series, /** @lends BubbleChartSeries.prototype */ {
    /**
     * Bubble chart series component.
     * @constructs BubbleChartSeries
     * @extends Series
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Calculate step value for label axis.
     * @returns {number}
     * @private
     */
    _calculateStep: function() {
        var step = 0;
        var dimension, seriesDataModel, size, len;

        if (this.dataProcessor.hasCategories(false)) {
            dimension = this.boundsMaker.getDimension('series');
            seriesDataModel = this._getSeriesDataModel();
            len = this.dataProcessor.getCategoryCount(false);

            if (seriesDataModel.isXCountGreaterThanYCount()) {
                size = dimension.height;
            } else {
                size = dimension.width;
            }

            step = size / len;
        }

        return step;
    },

    /**
     * Make bound for bubble chart.
     * @param {{x: number, y: number, r: number}} ratioMap - ratio map
     * @param {number} positionByStep - position value by step
     * @param {number} maxRadius - max radius
     * @returns {{left: number, top: number, radius: number}}
     * @private
     */
    _makeBound: function(ratioMap, positionByStep, maxRadius) {
        var dimension = this.boundsMaker.getDimension('series');
        var left = tui.util.isExisty(ratioMap.x) ? (ratioMap.x * dimension.width) : positionByStep;
        var top = tui.util.isExisty(ratioMap.y) ? (ratioMap.y * dimension.height) : positionByStep;

        return {
            left: left,
            top: dimension.height - top,
            radius: Math.max(maxRadius * ratioMap.r, 2)
        };
    },

    /**
     * Make bounds for bubble chart.
     * @returns {Array.<Array.<{left: number, top: number, radius: number}>>} positions
     * @private
     */
    _makeBounds: function() {
        var self = this;
        var seriesDataModel = this._getSeriesDataModel();
        var maxRadius = this.boundsMaker.getMaxRadiusForBubbleChart();
        var step = this._calculateStep();
        var start = step ? step / 2 : 0;

        return seriesDataModel.map(function(seriesGroup, index) {
            var positionByStep = start + (step * index);

            return seriesGroup.map(function(seriesItem) {
                var hasRationMap = (seriesItem && seriesItem.ratioMap);

                return hasRationMap ? self._makeBound(seriesItem.ratioMap, positionByStep, maxRadius) : null;
            });
        });
    }
});

CoordinateTypeSeriesBase.mixin(BubbleChartSeries);
tui.util.CustomEvents.mixin(BubbleChartSeries);

module.exports = BubbleChartSeries;

},{"./coordinateTypeSeriesBase":94,"./series":102}],93:[function(require,module,exports){
/**
 * @fileoverview Column chart series component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series');
var BarTypeSeriesBase = require('./barTypeSeriesBase');
var chartConst = require('../const');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');
var calculator = require('../helpers/calculator');

var ColumnChartSeries = tui.util.defineClass(Series, /** @lends ColumnChartSeries.prototype */ {
    /**
     * Column chart series component.
     * @constructs ColumnChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make bound of column chart.
     * @param {number} width width
     * @param {number} height height
     * @param {number} left top position value
     * @param {number} startTop start top position value
     * @param {number} endTop end top position value
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeBound: function(width, height, left, startTop, endTop) {
        return {
            start: {
                top: startTop,
                left: left,
                width: width,
                height: 0
            },
            end: {
                top: endTop,
                left: left,
                width: width,
                height: height
            }
        };
    },

    /**
     * Make column chart bound.
     * @param {{
     *      baseSize: number,
     *      basePosition: number,
     *      step: number,
     *      additionalPosition: ?number,
     *      barSize: number
     * }} baseData base data for making bound
     * @param {{
     *      baseLeft: number,
     *      left: number,
     *      plusTop: number,
     *      minusTop: number,
     *      prevStack: ?string
     * }} iterationData iteration data
     * @param {?boolean} isStackType whether stackType option or not.
     * @param {SeriesItem} seriesItem series item
     * @param {number} index index
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }}
     * @private
     */
    _makeColumnChartBound: function(baseData, iterationData, isStackType, seriesItem, index) {
        var barHeight = Math.abs(baseData.baseBarSize * seriesItem.ratioDistance),
            barStartTop = baseData.baseBarSize * seriesItem.startRatio,
            startTop = baseData.basePosition - barStartTop + chartConst.SERIES_EXPAND_SIZE,
            changedStack = (seriesItem.stack !== iterationData.prevStack),
            stepCount, endTop, bound;

        if (!isStackType || (!this.options.diverging && changedStack)) {
            stepCount = isStackType ? this.dataProcessor.findStackIndex(seriesItem.stack) : index;
            iterationData.left = (baseData.step * stepCount) + iterationData.baseLeft + baseData.additionalPosition;
            iterationData.plusTop = 0;
            iterationData.minusTop = 0;
        }

        if (seriesItem.value >= 0) {
            iterationData.plusTop -= barHeight;
            endTop = startTop + iterationData.plusTop;
        } else {
            endTop = startTop + iterationData.minusTop;
            iterationData.minusTop += barHeight;
        }

        iterationData.prevStack = seriesItem.stack;
        bound = this._makeBound(baseData.barSize, barHeight, iterationData.left, startTop, endTop);

        return bound;
    },

    /**
     * Make bounds of column chart.
     * @returns {Array.<Array.<object>>} bounds
     * @private
     */
    _makeBounds: function() {
        var self = this;
        var seriesDataModel = this._getSeriesDataModel();
        var isStackType = predicate.isValidStackOption(this.options.stackType);
        var dimension = this.boundsMaker.getDimension('series');
        var baseData = this._makeBaseDataForMakingBound(dimension.width, dimension.height);

        return seriesDataModel.map(function(seriesGroup, groupIndex) {
            var baseLeft = (groupIndex * baseData.groupSize) + baseData.firstAdditionalPosition
                        + chartConst.SERIES_EXPAND_SIZE,
                iterationData = {
                    baseLeft: baseLeft,
                    left: baseLeft,
                    plusTop: 0,
                    minusTop: 0,
                    prevStack: null
                },
                iteratee = tui.util.bind(self._makeColumnChartBound, self, baseData, iterationData, isStackType);

            return seriesGroup.map(iteratee);
        });
    },

    /**
     * Calculate left position of sum label.
     * @param {{left: number, top: number}} bound bound
     * @param {string} formattedSum formatted sum.
     * @returns {number} left position value
     * @private
     */
    _calculateLeftPositionOfSumLabel: function(bound, formattedSum) {
        var labelWidth = renderUtil.getRenderedLabelWidth(formattedSum, this.theme.label);

        return bound.left + ((bound.width - labelWidth + chartConst.TEXT_PADDING) / 2);
    },

    /**
     * Make plus sum label html.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {string} plus sum label html
     * @private
     */
    _makePlusSumLabelHtml: function(values, bound, labelHeight) {
        var html = '';
        var sum, formatFunctions, formattedSum;

        if (bound) {
            sum = calculator.sumPlusValues(values);
            formatFunctions = this.dataProcessor.getFormatFunctions();
            formattedSum = renderUtil.formatValue(sum, formatFunctions, this.chartType, 'series');
            html = this._makeSeriesLabelHtml({
                left: this._calculateLeftPositionOfSumLabel(bound, formattedSum),
                top: bound.top - labelHeight - chartConst.SERIES_LABEL_PADDING
            }, formattedSum, -1);
        }

        return html;
    },

    /**
     * Make minus sum label html.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @returns {string} plus minus label html
     * @private
     */
    _makeMinusSumLabelHtml: function(values, bound) {
        var html = '';
        var sum, formatFunctions, formattedSum;

        if (bound) {
            sum = calculator.sumMinusValues(values);

            if (this.options.diverging) {
                sum = Math.abs(sum);
            }

            formatFunctions = this.dataProcessor.getFormatFunctions();
            formattedSum = renderUtil.formatValue(sum, formatFunctions, this.chartType, 'series');
            html = this._makeSeriesLabelHtml({
                left: this._calculateLeftPositionOfSumLabel(bound, formattedSum),
                top: bound.top + bound.height + chartConst.SERIES_LABEL_PADDING
            }, formattedSum, -1);
        }

        return html;
    }
});

BarTypeSeriesBase.mixin(ColumnChartSeries);

module.exports = ColumnChartSeries;

},{"../const":31,"../helpers/calculator":57,"../helpers/predicate":61,"../helpers/renderUtil":63,"./barTypeSeriesBase":91,"./series":102}],94:[function(require,module,exports){
/**
 * @fileoverview CoordinateTypeSeriesBase is base class for coordinate type series.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */


'use strict';

var renderUtil = require('../helpers/renderUtil');

var CoordinateTypeSeriesBase = tui.util.defineClass(/** @lends CoordinateTypeSeriesBase.prototype */ {
    /**
     * Make series data.
     * @returns {{
     *      groupBounds: Array.<Array.<{left: number, top: number, radius: number}>>,
     *      seriesDataModel: SeriesDataModel
     * }} series data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        var bounds = this._makeBounds();

        return {
            groupBounds: bounds,
            seriesDataModel: this._getSeriesDataModel()
        };
    },

    /**
     * showTooltip is mouseover event callback on series graph.
     * @param {object} params parameters
     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
     * @param {{top:number, left: number, width: number, height: number}} bound graph bound information
     * @param {number} groupIndex group index
     * @param {number} index index
     * @param {{left: number, top: number}} mousePosition mouse position
     */
    showTooltip: function(params, bound, groupIndex, index, mousePosition) {
        this.fire('showTooltip', tui.util.extend({
            indexes: {
                groupIndex: groupIndex,
                index: index
            },
            mousePosition: mousePosition
        }, params));
    },

    /**
     * hideTooltip is mouseout event callback on series graph.
     */
    hideTooltip: function() {
        this.fire('hideTooltip');
    },

    /**
     * Render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     * @override
     */
    _renderGraph: function(dimension, seriesData) {
        var showTooltip = tui.util.bind(this.showTooltip, this, {
            chartType: this.chartType
        });
        var callbacks = {
            showTooltip: showTooltip,
            hideTooltip: tui.util.bind(this.hideTooltip, this)
        };
        var params = this._makeParamsForGraphRendering(dimension, seriesData);

        this.graphRenderer.render(this.seriesContainer, params, callbacks);
    },

    /**
     * Make html for label of series area.
     * @param {{left: number, top: number}} basePosition - position
     * @param {string} label - label of SeriesItem
     * @param {number} index - index
     * @returns {string}
     * @private
     */
    _makeSeriesLabelsHtml: function(basePosition, label, index) {
        var labelHeight = renderUtil.getRenderedLabelHeight(label, this.theme.label);
        var labelWidth = renderUtil.getRenderedLabelWidth(label, this.theme.label);
        var position = {
            left: basePosition.left - (labelWidth / 2),
            top: basePosition.top - (labelHeight / 2)
        };

        return this._makeSeriesLabelHtml(position, label, index);
    },

    /**
     * Render series label.
     * @param {HTMLElement} labelContainer - container for label area
     * @private
     */
    _renderSeriesLabel: function(labelContainer) {
        var self = this;
        var seriesDataModel = this._getSeriesDataModel();
        var html = seriesDataModel.map(function(seriesGroup, groupIndex) {
            return seriesGroup.map(function(seriesItem, index) {
                var bound = self.seriesData.groupBounds[groupIndex][index];

                return seriesItem ? self._makeSeriesLabelsHtml(bound, seriesItem.label, index) : '';
            }).join('');
        }).join('');

        labelContainer.innerHTML = html;
    },

    /**
     * On click series.
     * @param {{left: number, top: number}} position mouse position
     */
    onClickSeries: function(position) {
        if (this.options.allowSelect) {
            this._executeGraphRenderer(position, 'clickSeries');
        }
    },

    /**
     * On move series.
     * @param {{left: number, top: number}} position mouse position
     */
    onMoveSeries: function(position) {
        this._executeGraphRenderer(position, 'moveMouseOnSeries');
    }
});

CoordinateTypeSeriesBase.mixin = function(func) {
    tui.util.extend(func.prototype, CoordinateTypeSeriesBase.prototype);
};

tui.util.CustomEvents.mixin(CoordinateTypeSeriesBase);

module.exports = CoordinateTypeSeriesBase;

},{"../helpers/renderUtil":63}],95:[function(require,module,exports){
/**
 * @fileoverview Series component for rendering graph of heatmap chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series');
var labelHelper = require('./renderingLabelHelper');
var chartConst = require('../const');

var HeatmapChartSeries = tui.util.defineClass(Series, /** @lends HeatmapChartSeries.prototype */ {
    /**
     * Series component for rendering graph of heatmap chart.
     * @constructs HeatmapChartSeries
     * @extends Series
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make series data.
     * @returns {{
     *      groupBounds: Array.<Array.<{left: number, top: number, radius: number}>>,
     *      seriesDataModel: SeriesDataModel
     * }} series data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        var boundsSet = this._makeBounds();

        return {
            colorSpectrum: this.data.colorSpectrum,
            groupBounds: boundsSet,
            seriesDataModel: this._getSeriesDataModel()
        };
    },

    /**
     * Make bound for graph rendering.
     * @param {number} blockWidth - block width
     * @param {number} blockHeight - block height
     * @param {number} x - x index
     * @param {number} y - y index
     * @returns {{end: {left: number, top: number, width: number, height: number}}}
     * @private
     */
    _makeBound: function(blockWidth, blockHeight, x, y) {
        var height = this.boundsMaker.getDimension('series').height;
        var left = (blockWidth * x) + chartConst.SERIES_EXPAND_SIZE;
        var top = height - (blockHeight * (y + 1)) + chartConst.SERIES_EXPAND_SIZE;

        return {
            end: {
                left: left,
                top: top,
                width: blockWidth,
                height: blockHeight
            }
        };
    },

    /**
     * Make bounds for graph rendering.
     * @returns {Array.<Array.<{left: number, top: number, radius: number}>>} positions
     * @private
     */
    _makeBounds: function() {
        var self = this;
        var seriesDataModel = this._getSeriesDataModel();
        var dimension = this.boundsMaker.getDimension('series');
        var blockWidth = dimension.width / this.dataProcessor.getCategoryCount(false);
        var blockHeight = dimension.height / this.dataProcessor.getCategoryCount(true);

        return seriesDataModel.map(function(seriesGroup, x) {
            return seriesGroup.map(function(seriesItem, y) {
                return self._makeBound(blockWidth, blockHeight, x, y);
            });
        });
    },

    /**
     * On show tooltip for calling showWedge.
     * @param {{indexes: {groupIndex: number, index: number}}} params - parameters
     */
    onShowTooltip: function(params) {
        var seriesDataModel = this._getSeriesDataModel();
        var indexes = params.indexes;
        var ratio = seriesDataModel.getSeriesItem(indexes.groupIndex, indexes.index).ratio;

        this.fire('showWedge', ratio);
    },

    /**
     * Render series label.
     * @param {HTMLElement} labelContainer - series label container
     * @private
     */
    _renderSeriesLabel: function(labelContainer) {
        var sdm = this._getSeriesDataModel();
        var boundsSet = this.seriesData.groupBounds;
        var labelTheme = this.theme.label;
        var selectedIndex = this.selectedLegendIndex;
        var positionsSet = labelHelper.boundsToLabelPositions(sdm, boundsSet, labelTheme);
        var html = labelHelper.makeLabelsHtmlForBoundType(sdm, positionsSet, labelTheme, selectedIndex);

        labelContainer.innerHTML = html;
    },

    /**
     * Make exportation data for series type userEvent.
     * @param {object} seriesData - series data
     * @returns {{x: number, y: number}}
     * @private
     */
    _makeExportationSeriesData: function(seriesData) {
        return {
            x: seriesData.indexes.groupIndex,
            y: seriesData.indexes.index
        };
    }
});

tui.util.CustomEvents.mixin(HeatmapChartSeries);

module.exports = HeatmapChartSeries;

},{"../const":31,"./renderingLabelHelper":100,"./series":102}],96:[function(require,module,exports){
/**
 * @fileoverview Line chart series component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    LineTypeSeriesBase = require('./lineTypeSeriesBase');

var LineChartSeries = tui.util.defineClass(Series, /** @lends LineChartSeries.prototype */ {
    /**
     * Line chart series component.
     * @constructs LineChartSeries
     * @extends Series
     * @mixes LineTypeSeriesBase
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);

        /**
         * object for requestAnimationFrame
         * @type {null | {id: number}}
         */
        this.movingAnimation = null;
    },

    /**
     * Make positions.
     * @param {number} [seriesWidth] - series width
     * @returns {Array.<Array.<{left: number, top: number}>>} positions
     * @private
     */
    _makePositions: function(seriesWidth) {
        return this._makeBasicPositions(seriesWidth);
    },

    /**
     * Make series data.
     * @returns {object} series data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        return {
            chartBackground: this.chartBackground,
            groupPositions: this._makePositions()
        };
    },

    /**
     * Rerender.
     * @param {object} data - data for rerendering
     * @override
     */
    rerender: function(data) {
        var paper;

        this._cancelMovingAnimation();

        paper = Series.prototype.rerender.call(this, data);

        return paper;
    }
});

LineTypeSeriesBase.mixin(LineChartSeries);

module.exports = LineChartSeries;

},{"./lineTypeSeriesBase":97,"./series":102}],97:[function(require,module,exports){
/**
 * @fileoverview LineTypeSeriesBase is base class for line type series.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var seriesTemplate = require('./seriesTemplate');
var chartConst = require('../const');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');

var concat = Array.prototype.concat;

/**
 * @classdesc LineTypeSeriesBase is base class for line type series.
 * @class LineTypeSeriesBase
 * @mixin
 */
var LineTypeSeriesBase = tui.util.defineClass(/** @lends LineTypeSeriesBase.prototype */ {
    /**
     * Make basic positions for rendering line graph.
     * @param {number} [seriesWidth] - width of series area
     * @returns {Array.<Array.<object>>}
     * @private
     */
    _makeBasicPositions: function(seriesWidth) {
        var dimension = this.boundsMaker.getDimension('series'),
            seriesDataModel = this._getSeriesDataModel(),
            width = seriesWidth || dimension.width || 0,
            height = dimension.height,
            len = seriesDataModel.getGroupCount(),
            start = chartConst.SERIES_EXPAND_SIZE,
            step;

        if (this.data.aligned) {
            step = width / (len - 1);
        } else {
            step = width / len;
            start += (step / 2);
        }

        return seriesDataModel.map(function(seriesGroup) {
            return seriesGroup.map(function(seriesItem, index) {
                var position = {
                    left: start + (step * index),
                    top: height - (seriesItem.ratio * height) + chartConst.SERIES_EXPAND_SIZE
                };

                if (tui.util.isExisty(seriesItem.startRatio)) {
                    position.startTop = height - (seriesItem.startRatio * height) + chartConst.SERIES_EXPAND_SIZE;
                }

                return position;
            });
        }, true);
    },

    /**
     * Calculate label position top.
     * @param {{top: number, startTop: number}} basePosition - base position
     * @param {number} value - value of seriesItem
     * @param {number} labelHeight - label height
     * @param {boolean} isStart - whether start value of seriesItem or not
     * @returns {number} position top
     * @private
     */
    _calculateLabelPositionTop: function(basePosition, value, labelHeight, isStart) {
        var baseTop = basePosition.top,
            top;

        if (predicate.isValidStackOption(this.options.stackType)) {
            top = (basePosition.startTop + baseTop - labelHeight) / 2 + 1;
        } else if ((value >= 0 && !isStart) || (value < 0 && isStart)) {
            top = baseTop - labelHeight - chartConst.SERIES_LABEL_PADDING;
        } else {
            top = baseTop + chartConst.SERIES_LABEL_PADDING;
        }

        return top;
    },

    /**
     * Make label position for rendering label of series area.
     * @param {{left: number, top: number, startTop: ?number}} basePosition - base position for calculating
     * @param {number} labelHeight - label height
     * @param {(string | number)} label - label of seriesItem
     * @param {number} value - value of seriesItem
     * @param {boolean} isStart - whether start label position or not
     * @returns {{left: number, top: number}}
     * @private
     */
    _makeLabelPosition: function(basePosition, labelHeight, label, value, isStart) {
        var labelWidth = renderUtil.getRenderedLabelWidth(label, this.theme.label);
        var dimension = this.boundsMaker.getDimension('extendedSeries');

        return {
            left: (basePosition.left - (labelWidth / 2)) / dimension.width * 100,
            top: this._calculateLabelPositionTop(basePosition, value, labelHeight, isStart) / dimension.height * 100
        };
    },

    /**
     * Make html for series label for line type chart.
     * @param {number} groupIndex - index of seriesDataModel.groups
     * @param {number} index - index of seriesGroup.items
     * @param {SeriesItem} seriesItem - series item
     * @param {number} labelHeight - label height
     * @param {boolean} isStart - whether start label position or not
     * @returns {string}
     * @private
     */
    _makeSeriesLabelHtmlForLineType: function(groupIndex, index, seriesItem, labelHeight, isStart) {
        var basePosition = tui.util.extend({}, this.seriesData.groupPositions[groupIndex][index]),
            label, position;

        if (isStart) {
            label = seriesItem.startLabel;
            basePosition.top = basePosition.startTop;
        } else {
            label = seriesItem.endLabel;
        }

        position = this._makeLabelPosition(basePosition, labelHeight, label, seriesItem.value, isStart);

        return this._makeSeriesLabelHtml(position, label, groupIndex, seriesTemplate.tplCssTextForLineType, isStart);
    },

    /**
     * Render series label.
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderSeriesLabel: function(elSeriesLabelArea) {
        var self = this,
            seriesDataModel = this._getSeriesDataModel(),
            firstLabel = seriesDataModel.getFirstItemLabel(),
            labelHeight = renderUtil.getRenderedLabelHeight(firstLabel, this.theme.label),
            htmls;

        htmls = seriesDataModel.map(function(seriesGroup, groupIndex) {
            return seriesGroup.map(function(seriesItem, index) {
                var labelHtml = self._makeSeriesLabelHtmlForLineType(groupIndex, index, seriesItem, labelHeight);

                if (seriesItem.isRange) {
                    labelHtml += self._makeSeriesLabelHtmlForLineType(groupIndex, index, seriesItem, labelHeight, true);
                }

                return labelHtml;
            }).join('');
        }, true);

        elSeriesLabelArea.innerHTML = htmls.join('');
    },

    /**
     * Whether changed or not.
     * @param {number} groupIndex group index
     * @param {number} index index
     * @returns {boolean} whether changed or not
     * @private
     */
    _isChanged: function(groupIndex, index) {
        var prevIndexes = this.prevIndexes;

        this.prevIndexes = {
            groupIndex: groupIndex,
            index: index
        };

        return !prevIndexes || (prevIndexes.groupIndex !== groupIndex) || (prevIndexes.index !== index);
    },

    /**
     * To call showGroupTooltipLine function of graphRenderer.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound bound
     */
    onShowGroupTooltipLine: function(bound) {
        if (!this.graphRenderer.showGroupTooltipLine) {
            return;
        }
        this.graphRenderer.showGroupTooltipLine(bound);
    },

    /**
     * To call hideGroupTooltipLine function of graphRenderer.
     */
    onHideGroupTooltipLine: function() {
        if (!this.graphRenderer.hideGroupTooltipLine) {
            return;
        }
        this.graphRenderer.hideGroupTooltipLine();
    },

    /**
     * Zoom by mouse drag.
     * @param {object} data - data
     * @returns {{container: HTMLElement, paper: object}}
     */
    zoom: function(data) {
        var paper;

        this._cancelMovingAnimation();
        this._clearContainer(data.paper);
        paper = this._renderSeriesArea(this.seriesContainer, data, tui.util.bind(this._renderGraph, this));
        this._showGraphWithoutAnimation();

        if (!tui.util.isNull(this.selectedLegendIndex)) {
            this.graphRenderer.selectLegend(this.selectedLegendIndex);
        }

        return {
            container: this.seriesContainer,
            paper: paper
        };
    },

    /**
     * Whether changed limit(min, max) or not.
     * @returns {boolean}
     * @private
     */
    _isChangedLimit: function() {
        var beforeLimit = this.data.limit;
        var afterLimit = this.boundsMaker.getAxesData().yAxis.limit;

        return beforeLimit.min !== afterLimit.min || beforeLimit.max !== afterLimit.max;
    },

    /**
     * Animate for motion of series area.
     * @param {function} callback - callback function
     * @private
     */
    _animate: function(callback) {
        var self = this;
        var changedLimit = this._isChangedLimit();

        this.movingAnimation = renderUtil.startAnimation(300, function(ratio) {
            if (changedLimit && self.seriesLabelContainer) {
                self.seriesLabelContainer.innerHTML = '';
            }
            callback(ratio);
        }, function() {
            self.movingAnimation = null;
        });
    },

    /**
     * Pick first label elements.
     * @returns {Array.<HTMLElement>}
     * @private
     */
    _pickFirstLabelElements: function() {
        var itemCount = this.dataProcessor.getCategoryCount() - 1;
        var seriesLabelContainer = this.seriesLabelContainer;
        var labelElements = seriesLabelContainer.childNodes;
        var filteredElements = [];
        var firstLabelElements;

        tui.util.forEachArray(labelElements, function(element) {
            if (!element.getAttribute('data-range')) {
                filteredElements.push(element);
            }
        });
        filteredElements = tui.util.filter(filteredElements, function(element, index) {
            return ((parseInt(index, 10) + 1) % itemCount) === 1;
        });
        firstLabelElements = tui.util.map(filteredElements, function(element) {
            var nextElement = element.nextSibling;
            var elements = [element];

            if (nextElement && nextElement.getAttribute('data-range')) {
                elements.push(nextElement);
            }

            return elements;
        });

        return concat.apply([], firstLabelElements);
    },

    /**
     * Hide first labels.
     * @private
     */
    _hideFirstLabels: function() {
        var seriesLabelContainer = this.seriesLabelContainer;
        var firsLabelElements;

        if (!seriesLabelContainer) {
            return;
        }

        firsLabelElements = this._pickFirstLabelElements();
        tui.util.forEachArray(firsLabelElements, function(element) {
            seriesLabelContainer.removeChild(element);
        });
    },

    /**
     * Animate for moving of graph container.
     * @param {number} interval - interval for moving
     * @private
     */
    _animateForMoving: function(interval) {
        var graphRenderer = this.graphRenderer;
        var childrenForMoving = this.seriesContainer.childNodes;
        var areaWidth = this.boundsMaker.getDimension('extendedSeries').width;
        var beforeLeft = 0;

        this._hideFirstLabels();

        if (childrenForMoving.length) {
            beforeLeft = parseInt(childrenForMoving[0].style.left, 10) || 0;
        }

        this._animate(function(ratio) {
            var left = interval * ratio;

            tui.util.forEachArray(childrenForMoving, function(child) {
                child.style.left = (beforeLeft - left) + 'px';
            });

            graphRenderer.setSize(areaWidth + left);
        });
    },

    /**
     * Animate for resizing of label container.
     * @param {number} interval - interval for stacking
     * @private
     */
    _animateForResizing: function(interval) {
        var seriesLabelContainer = this.seriesLabelContainer;
        var areaWidth;

        if (!seriesLabelContainer) {
            return;
        }

        areaWidth = this.boundsMaker.getDimension('extendedSeries').width;

        this._animate(function(ratio) {
            var left = interval * ratio;

            seriesLabelContainer.style.width = (areaWidth - left) + 'px';
        });
    },

    /**
     * Make top of zero point for adding data.
     * @returns {number}
     * @private
     * @override
     */
    _makeZeroTopForAddingData: function() {
        var seriesHeight = this.boundsMaker.getDimension('series').height;
        var limit = this.boundsMaker.getAxesData().yAxis.limit;

        return this._getLimitDistanceFromZeroPoint(seriesHeight, limit).toMax + chartConst.SERIES_EXPAND_SIZE;
    },

    /**
     * Animate for adding data.
     * @param {{tickSize: number}} params - parameters for adding data.
     */
    animateForAddingData: function(params) {
        var seriesData = this._makeSeriesData();
        var dimension = this.boundsMaker.getDimension('extendedSeries');
        var seriesWidth = this.boundsMaker.getDimension('series').width;
        var paramsForRendering = this._makeParamsForGraphRendering(dimension, seriesData);
        var tickSize = params.tickSize;
        var shiftingOption = this.options.shifting;
        var groupPositions, zeroTop;

        if (shiftingOption) {
            seriesWidth += tickSize;
        }

        groupPositions = this._makePositions(seriesWidth);
        zeroTop = this._makeZeroTopForAddingData();

        this.graphRenderer.animateForAddingData(paramsForRendering, tickSize, groupPositions, shiftingOption, zeroTop);

        if (shiftingOption) {
            this._animateForMoving(tickSize);
        } else {
            this._animateForResizing(tickSize);
        }
    },

    /**
     * Cancel moving animation.
     * @private
     */
    _cancelMovingAnimation: function() {
        if (this.movingAnimation) {
            cancelAnimationFrame(this.movingAnimation.id);
            this.movingAnimation = null;
        }
    }
});

LineTypeSeriesBase.mixin = function(func) {
    tui.util.extend(func.prototype, LineTypeSeriesBase.prototype);
};

module.exports = LineTypeSeriesBase;

},{"../const":31,"../helpers/predicate":61,"../helpers/renderUtil":63,"./seriesTemplate":103}],98:[function(require,module,exports){
/**
 * @fileoverview Map chart series component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series');
var dom = require('../helpers/domHandler');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');

var MapChartSeries = tui.util.defineClass(Series, /** @lends MapChartSeries.prototype */ {
    /**
     * Map chart series component.
     * @constructs MapChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     *      @param {MapChartDataProcessor} params.dataProcessor data processor for map chart
     */
    init: function(params) {
        /**
         * Base position.
         * @type {{left: number, top: number}}
         */
        this.basePosition = {
            left: 0,
            top: 0
        };

        /**
         * Zoom magnification.
         * @type {number}
         */
        this.zoomMagn = 1;

        /**
         * Map ratio.
         * @type {number}
         */
        this.mapRatio = 1;

        /**
         * Graph dimension.
         * @type {{}}
         */
        this.graphDimension = {};

        /**
         * Limit position.
         * @type {{}}
         */
        this.limitPosition = {};

        /**
         * Map model.
         * @type {MapChartMapModel}
         */
        this.mapModel = null;

        /**
         * Previous mouse position.
         * @type {?{left: number, top: number}}
         */
        this.prevPosition = null;


        /**
         * Previous moved index.
         * @type {?number}
         */
        this.prevMovedIndex = null;

        /**
         * Whether drag or not.
         * @type {boolean}
         */
        this.isDrag = false;

        /**
         * Start position.
         * @type {?{left: number, top: number}}
         */
        this.startPosition = null;

        Series.call(this, params);
    },

    /**
     * Set map ratio.
     * @private
     */
    _setMapRatio: function() {
        var seriesDimension = this.boundsMaker.getDimension('series'),
            mapDimension = this.mapModel.getMapDimension(),
            widthRatio = seriesDimension.width / mapDimension.width,
            heightRatio = seriesDimension.height / mapDimension.height;

        this.mapRatio = Math.min(widthRatio, heightRatio);
    },

    /**
     * Set graph dimension.
     * @private
     */
    _setGraphDimension: function() {
        var seriesDimension = this.boundsMaker.getDimension('series');

        this.graphDimension = {
            width: seriesDimension.width * this.zoomMagn,
            height: seriesDimension.height * this.zoomMagn
        };
    },

    /**
     * Render series component.
     * @param {object} data data for rendering
     * @returns {HTMLElement} series element
     */
    render: function(data) {
        var container;

        this.mapModel = data.mapModel;
        this._setMapRatio();

        container = Series.prototype.render.call(this, data);

        return container;
    },

    /**
     * Set limit position to move map.
     * @private
     */
    _setLimitPositionToMoveMap: function() {
        var seriesDimension = this.boundsMaker.getDimension('series'),
            graphDimension = this.graphDimension;

        this.limitPosition = {
            left: seriesDimension.width - graphDimension.width,
            top: seriesDimension.height - graphDimension.height
        };
    },

    /**
     * Render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @private
     * @override
     */
    _renderGraph: function() {
        if (!this.graphContainer) {
            this.graphContainer = dom.create('DIV', 'tui-chart-series-graph-area');
            this.seriesContainer.appendChild(this.graphContainer);
        }

        this._setGraphDimension();
        renderUtil.renderDimension(this.graphContainer, this.graphDimension);

        this._setLimitPositionToMoveMap();

        this.graphRenderer.render(this.graphContainer, {
            colorSpectrum: this.data.colorSpectrum,
            mapModel: this.mapModel,
            dimension: this.graphDimension,
            theme: this.theme
        });
    },

    /**
     * Render series label.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderSeriesLabel: function(seriesLabelContainer) {
        var self = this,
            htmls = tui.util.map(this.mapModel.getLabelData(this.zoomMagn * this.mapRatio), function(datum, index) {
                var label = datum.name || datum.code,
                    left = datum.labelPosition.left - (renderUtil.getRenderedLabelWidth(label, self.theme.label) / 2),
                    top = datum.labelPosition.top - (renderUtil.getRenderedLabelHeight(label, self.theme.label) / 2);

                return self._makeSeriesLabelHtml({
                    left: left,
                    top: top
                }, datum.name, index);
            });
        seriesLabelContainer.innerHTML = htmls.join('');
    },

    /**
     * Render series area.
     * @param {HTMLElement} seriesContainer series area element
     * @param {object} data data for rendering
     * @param {function} funcRenderGraph function for graph rendering
     * @private
     */
    _renderSeriesArea: function(seriesContainer, data, funcRenderGraph) {
        Series.prototype._renderSeriesArea.call(this, seriesContainer, data, funcRenderGraph);

        if (predicate.isShowLabel(this.options) && !this.seriesLabelContainer) {
            this.graphContainer.appendChild(this.seriesLabelContainer);
        }
    },

    /**
     * Adjust map position.
     * @param {{left: number, top: number}} targetPosition target position
     * @returns {{left: number, top: number}} adjusted position
     * @private
     */
    _adjustMapPosition: function(targetPosition) {
        return {
            left: Math.max(Math.min(targetPosition.left, 0), this.limitPosition.left),
            top: Math.max(Math.min(targetPosition.top, 0), this.limitPosition.top)
        };
    },

    /**
     * Update base position for zoom.
     * @param {{width: number, height: number}} prevDimension previous dimension
     * @param {{left: number, top: number}} prevLimitPosition previous limit position
     * @param {number} changedRatio changed ratio
     * @private
     */
    _updateBasePositionForZoom: function(prevDimension, prevLimitPosition, changedRatio) {
        var prevBasePosition = this.basePosition,
            prevLeft = prevBasePosition.left - (prevLimitPosition.left / 2),
            prevTop = prevBasePosition.top - (prevLimitPosition.top / 2),
            newBasePosition = {
                left: (prevLeft * changedRatio) + (this.limitPosition.left / 2),
                top: (prevTop * changedRatio) + (this.limitPosition.top / 2)
            };

        this.basePosition = this._adjustMapPosition(newBasePosition);
    },

    /**
     * Zoom.
     * @param {number} changedRatio changed ratio
     * @private
     */
    _zoom: function(changedRatio) {
        var prevDimension = this.graphDimension,
            prevLimitPosition = this.limitPosition;

        this._setGraphDimension();
        renderUtil.renderDimension(this.graphContainer, this.graphDimension);
        this.graphRenderer.setSize(this.graphDimension);

        this._setLimitPositionToMoveMap();
        this._updateBasePositionForZoom(prevDimension, prevLimitPosition, changedRatio);
        renderUtil.renderPosition(this.graphContainer, this.basePosition);

        if (this.seriesLabelContainer) {
            this._renderSeriesLabel(this.seriesLabelContainer);
        }
    },

    /**
     * Update positions to resize.
     * @param {number} prevMapRatio previous ratio
     * @private
     */
    _updatePositionsToResize: function(prevMapRatio) {
        var changedRatio = this.mapRatio / prevMapRatio;

        this.basePosition.left *= changedRatio;
        this.basePosition.top *= changedRatio;

        this.limitPosition.left *= changedRatio;
        this.limitPosition.top *= changedRatio;
    },

    /**
     * Resize graph.
     * @private
     */
    _resizeGraph: function() {
        var prevRatio = this.mapRatio;

        this._setMapRatio();

        this._setGraphDimension();
        renderUtil.renderDimension(this.graphContainer, this.graphDimension);
        this.graphRenderer.setSize(this.graphDimension);

        this._updatePositionsForResizing(prevRatio);
        renderUtil.renderPosition(this.graphContainer, this.basePosition);

        if (this.seriesLabelContainer) {
            this._renderSeriesLabel(this.seriesLabelContainer);
        }
    },

    /**
     * On click series.
     */
    onClickSeries: function() {},

    /**
     * Whether changed or not.
     * @param {?{left: number, top: number}} prevPosition previous position
     * @param {{left: number, top: number}} position position
     * @returns {boolean} result boolean
     * @private
     */
    _isChangedPosition: function(prevPosition, position) {
        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
    },

    /**
     * Show wedge.
     * @param {number} index map data index
     * @private
     */
    _showWedge: function(index) {
        var datum = this.mapModel.getDatum(index);

        if (!tui.util.isUndefined(datum.ratio)) {
            this.fire('showWedge', datum.ratio);
        }
    },

    /**
     * Show tooltip
     * @param {number} index map data index
     * @param {{left: number, top: number}} mousePosition mouse position
     * @private
     */
    _showTooltip: function(index, mousePosition) {
        this.fire('showTooltip', {
            chartType: this.chartType,
            indexes: {
                index: index
            },
            mousePosition: mousePosition
        });
    },

    /**
     * Get series container bound.
     * @returns {{left: number, top: number}} container bound
     * @private
     */
    _getContainerBound: function() {
        if (!this.containerBound) {
            this.containerBound = this.seriesContainer.getBoundingClientRect();
        }

        return this.containerBound;
    },

    /**
     * On move series.
     * @param {{left: number, top: number}} position position
     */
    onMoveSeries: function(position) {
        var foundIndex = this._executeGraphRenderer(position, 'findSectorIndex'),
            containerBound;

        if (!tui.util.isNull(foundIndex)) {
            if (this.prevMovedIndex !== foundIndex) {
                if (!tui.util.isNull(this.prevMovedIndex)) {
                    this.graphRenderer.restoreColor(this.prevMovedIndex);
                    this.fire('hideWedge');
                    this.fire('hideTooltip');
                }

                this.graphRenderer.changeColor(foundIndex);
            }

            if (this._isChangedPosition(this.prevPosition, position)) {
                containerBound = this._getContainerBound();
                this._showTooltip(foundIndex, {
                    left: position.left - containerBound.left,
                    top: position.top - containerBound.top
                });
                this.prevMovedIndex = foundIndex;
            }

            this._showWedge(foundIndex);
        } else if (!tui.util.isNull(this.prevMovedIndex)) {
            this.graphRenderer.restoreColor(this.prevMovedIndex);
            this.fire('hideWedge');
            this.fire('hideTooltip');
            this.prevMovedIndex = null;
        }
        this.prevPosition = position;
    },

    /**
     * On drag start series.
     * @param {{left: number, top: number}} position position
     */
    onDragStartSeries: function(position) {
        this.startPosition = {
            left: position.left,
            top: position.top
        };
    },

    /**
     * Move position.
     * @param {{left: number, top: number}} startPosition start position
     * @param {{left: number, top: number}} endPosition end position
     * @private
     */
    _movePosition: function(startPosition, endPosition) {
        var movementPosition = this._adjustMapPosition({
            left: this.basePosition.left + (endPosition.left - startPosition.left),
            top: this.basePosition.top + (endPosition.top - startPosition.top)
        });

        renderUtil.renderPosition(this.graphContainer, movementPosition);

        this.basePosition = movementPosition;
    },

    /**
     * On drag series.
     * @param {{left: number, top: number}} position position
     */
    onDragSeries: function(position) {
        this._movePosition(this.startPosition, position);

        this.startPosition = position;

        if (!this.isDrag) {
            this.isDrag = true;
            this.fire('hideTooltip');
        }
    },

    /**
     * On drag end series.
     */
    onDragEndSeries: function() {
        this.isDrag = false;
    },

    /**
     * Move position for zoom.
     * @param {{left: number, top: number}} position mouse position
     * @param {number} changedRatio changed ratio
     * @private
     */
    _movePositionForZoom: function(position, changedRatio) {
        var seriesDimension = this.boundsMaker.getDimension('series'),
            containerBound = this._getContainerBound(),
            startPosition = {
                left: (seriesDimension.width / 2) + containerBound.left,
                top: (seriesDimension.height / 2) + containerBound.top
            },
            movementPosition = {
                left: position.left - startPosition.left,
                top: position.top - startPosition.top
            },
            endPosition;

        changedRatio = changedRatio > 1 ? -(changedRatio / 2) : changedRatio;

        endPosition = {
            left: startPosition.left + (movementPosition.left * changedRatio),
            top: startPosition.top + (movementPosition.top * changedRatio)
        };

        this._movePosition(startPosition, endPosition);
    },

    /**
     * On zoom.
     * @param {number} newMagn new zoom magnification
     * @param {?{left: number, top: number}} position mouse position
     */
    onZoom: function(newMagn, position) {
        var changedRatio = newMagn / this.zoomMagn;

        this.zoomMagn = newMagn;

        this._zoom(changedRatio);

        if (position) {
            this._movePositionForZoom(position, changedRatio);
        }

        this.userEvent.fire('zoom', newMagn);
    }
});

tui.util.CustomEvents.mixin(MapChartSeries);

module.exports = MapChartSeries;

},{"../helpers/domHandler":59,"../helpers/predicate":61,"../helpers/renderUtil":63,"./series":102}],99:[function(require,module,exports){
/**
 * @fileoverview Pie chart series component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series');
var chartConst = require('../const');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');

var PieChartSeries = tui.util.defineClass(Series, /** @lends PieChartSeries.prototype */ {
    /**
     * Line chart series component.
     * @constructs PieChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function(params) {
        Series.call(this, params);

        this.isCombo = !!params.isCombo;

        this.isShowOuterLabel = !!params.isShowOuterLabel || predicate.isShowOuterLabel(this.options);

        /**
         * range for quadrant.
         * @type {?number}
         */
        this.quadrantRange = null;

        this._setDefaultOptions();
    },

    /**
     * Make valid angle.
     * @param {number} angle - angle
     * @param {number} defaultAngle - default angle
     * @returns {number}
     * @private
     */
    _makeValidAngle: function(angle, defaultAngle) {
        if (tui.util.isUndefined(angle)) {
            angle = defaultAngle;
        } else if (angle < 0) {
            angle = chartConst.ANGLE_360 - (Math.abs(angle) % chartConst.ANGLE_360);
        } else if (angle > 0) {
            angle = angle % chartConst.ANGLE_360;
        }

        return angle;
    },

    /**
     * Transform radius range.
     * @param {Array.<number>} radiusRange - radius range
     * @returns {Array}
     * @private
     */
    _transformRadiusRange: function(radiusRange) {
        radiusRange = radiusRange || ['0%', '100%'];

        return tui.util.map(radiusRange, function(percent) {
            var ratio = parseInt(percent, 10) * 0.01;

            return Math.max(Math.min(ratio, 1), 0);
        });
    },

    /**
     * Set default options for series of pie type chart.
     * @private
     */
    _setDefaultOptions: function() {
        var options = this.options;

        options.startAngle = this._makeValidAngle(options.startAngle, 0);
        options.endAngle = this._makeValidAngle(options.endAngle, options.startAngle);
        options.radiusRange = this._transformRadiusRange(options.radiusRange);

        if (options.radiusRange.length === 1) {
            options.radiusRange.unshift(0);
        }
    },

    /**
     * Calculate angle for rendering.
     * @returns {number}
     * @private
     */
    _calculateAngleForRendering: function() {
        var startAngle = this.options.startAngle;
        var endAngle = this.options.endAngle;
        var renderingAngle;

        if (startAngle < endAngle) {
            renderingAngle = endAngle - startAngle;
        } else if (startAngle > endAngle) {
            renderingAngle = chartConst.ANGLE_360 - (startAngle - endAngle);
        } else {
            renderingAngle = chartConst.ANGLE_360;
        }

        return renderingAngle;
    },

    /**
     * Make sectors information.
     * @param {{cx: number, cy: number, r: number}} circleBound circle bound
     * @returns {Array.<object>} sectors information
     * @private
     */
    _makeSectorData: function(circleBound) {
        var self = this;
        var seriesGroup = this._getSeriesDataModel().getFirstSeriesGroup();
        var cx = circleBound.cx;
        var cy = circleBound.cy;
        var r = circleBound.r;
        var angle = this.options.startAngle;
        var angleForRendering = this._calculateAngleForRendering();
        var delta = 10;
        var holeRatio = this.options.radiusRange[0];
        var centerR = r * 0.5;
        var paths;

        if (holeRatio) {
            centerR += centerR * holeRatio;
        }

        paths = seriesGroup.map(function(seriesItem) {
            var currentAngle = angleForRendering * seriesItem.ratio;
            var endAngle = angle + currentAngle;
            var popupAngle = angle + (currentAngle / 2);
            var angles = {
                start: {
                    startAngle: angle,
                    endAngle: angle
                },
                end: {
                    startAngle: angle,
                    endAngle: endAngle
                }
            };
            var positionData = {
                cx: cx,
                cy: cy,
                angle: popupAngle
            };

            angle = endAngle;

            return {
                ratio: seriesItem.ratio,
                angles: angles,
                centerPosition: self._getArcPosition(tui.util.extend({
                    r: centerR
                }, positionData)),
                outerPosition: {
                    start: self._getArcPosition(tui.util.extend({
                        r: r
                    }, positionData)),
                    middle: self._getArcPosition(tui.util.extend({
                        r: r + delta
                    }, positionData))
                }
            };
        });

        return paths;
    },

    /**
     * Make series data.
     * @returns {{
     *      chartBackground: string,
     *      circleBound: ({cx: number, cy: number, r: number}),
     *      sectorData: Array.<object>
     * }} add data for graph rendering
     * @private
     * @override
     */
    _makeSeriesData: function() {
        var circleBound = this._makeCircleBound(),
            sectorData = this._makeSectorData(circleBound);

        return {
            chartBackground: this.chartBackground,
            circleBound: circleBound,
            sectorData: sectorData
        };
    },

    /**
     * Get quadrant from angle.
     * @param {number} angle - angle
     * @param {boolean} isEnd whether end quadrant
     * @returns {number}
     * @private
     */
    _getQuadrantFromAngle: function(angle, isEnd) {
        var quadrant = parseInt(angle / chartConst.ANGLE_90, 10) + 1;

        if (isEnd && (angle % chartConst.ANGLE_90 === 0)) {
            quadrant += (quadrant === 1) ? 3 : -1;
        }

        return quadrant;
    },

    /**
     * Get range for quadrant.
     * @returns {{start: number, end: number}}
     * @private
     */
    _getRangeForQuadrant: function() {
        if (!this.quadrantRange) {
            this.quadrantRange = {
                start: this._getQuadrantFromAngle(this.options.startAngle),
                end: this._getQuadrantFromAngle(this.options.endAngle, true)
            };
        }

        return this.quadrantRange;
    },

    /**
     * Whether in range for quadrant.
     * @param {number} start - start quadrant
     * @param {number} end - end quadrant
     * @returns {boolean}
     * @private
     */
    _isInQuadrantRange: function(start, end) {
        var quadrantRange = this._getRangeForQuadrant();

        return quadrantRange.start === start && quadrantRange.end === end;
    },

    /**
     * Calculate base size.
     * @returns {number}
     * @private
     */
    _calculateBaseSize: function() {
        var dimension = this.boundsMaker.getDimension('series');
        var width = dimension.width;
        var height = dimension.height;
        var quadrantRange;

        if (!this.isCombo) {
            quadrantRange = this._getRangeForQuadrant();
            if (this._isInQuadrantRange(2, 3) || this._isInQuadrantRange(4, 1)) {
                height *= 2;
            } else if (this._isInQuadrantRange(1, 2) || this._isInQuadrantRange(3, 4)) {
                width *= 2;
            } else if (quadrantRange.start === quadrantRange.end) {
                width *= 2;
                height *= 2;
            }
        }

        return Math.min(width, height);
    },

    /**
     * Calculate radius.
     * @returns {number}
     * @private
     */
    _calculateRadius: function() {
        var radiusRatio = this.isShowOuterLabel ? chartConst.PIE_GRAPH_SMALL_RATIO : chartConst.PIE_GRAPH_DEFAULT_RATIO;
        var baseSize = this._calculateBaseSize();

        return baseSize * radiusRatio * this.options.radiusRange[1] / 2;
    },

    /**
     * Calculate center x, y.
     * @param {number} radius - radius
     * @returns {{cx: number, cy: number}}
     * @private
     */
    _calculateCenterXY: function(radius) {
        var dimension = this.boundsMaker.getDimension('series');
        var halfRadius = radius / 2;
        var cx = dimension.width / 2;
        var cy = dimension.height / 2;

        if (!this.isCombo) {
            if (this._isInQuadrantRange(1, 1)) {
                cx -= halfRadius;
                cy += halfRadius;
            } else if (this._isInQuadrantRange(1, 2)) {
                cx -= halfRadius;
            } else if (this._isInQuadrantRange(2, 2)) {
                cx -= halfRadius;
                cy -= halfRadius;
            } else if (this._isInQuadrantRange(2, 3)) {
                cy -= halfRadius;
            } else if (this._isInQuadrantRange(3, 3)) {
                cx += halfRadius;
                cy -= halfRadius;
            } else if (this._isInQuadrantRange(3, 4)) {
                cx += halfRadius;
            } else if (this._isInQuadrantRange(4, 1)) {
                cy += halfRadius;
            } else if (this._isInQuadrantRange(4, 4)) {
                cx += halfRadius;
                cy += halfRadius;
            }
        }

        return {
            cx: cx,
            cy: cy
        };
    },

    /**
     * Make circle bound
     * @returns {{cx: number, cy: number, r: number}} circle bounds
     * @private
     */
    _makeCircleBound: function() {
        var radius = this._calculateRadius();
        var centerXY = this._calculateCenterXY(radius);

        return tui.util.extend({
            r: radius
        }, centerXY);
    },

    /**
     * Get arc position.
     * @param {object} params parameters
     *      @param {number} params.cx center x
     *      @param {number} params.cy center y
     *      @param {number} params.r radius
     *      @param {number} params.angle angle(degree)
     * @returns {{left: number, top: number}} arc position
     * @private
     */
    _getArcPosition: function(params) {
        return {
            left: params.cx + (params.r * Math.sin(params.angle * chartConst.RAD)),
            top: params.cy - (params.r * Math.cos(params.angle * chartConst.RAD))
        };
    },

    /**
     * Render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     * @override
     */
    _renderGraph: function(dimension, seriesData, paper) {
        var showTootltip = tui.util.bind(this.showTooltip, this, {
            allowNegativeTooltip: !!this.allowNegativeTooltip,
            seriesName: this.seriesName,
            chartType: this.chartType
        });
        var callbacks = {
            showTooltip: showTootltip,
            hideTooltip: tui.util.bind(this.hideTooltip, this)
        };
        var params = this._makeParamsForGraphRendering(dimension, seriesData);

        params.paper = paper;

        return this.graphRenderer.render(this.seriesContainer, params, callbacks);
    },

    /**
     * Resize.
     * @override
     */
    resize: function() {
        Series.prototype.resize.apply(this, arguments);
        this._moveLegendLines();
    },

    /**
     * showTooltip is mouseover event callback on series graph.
     * @param {object} params parameters
     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
     * @param {{top:number, left: number, width: number, height: number}} bound graph bound information
     * @param {number} groupIndex group index
     * @param {number} index index
     * @param {{left: number, top: number}} mousePosition mouse position
     */
    showTooltip: function(params, bound, groupIndex, index, mousePosition) {
        this.fire('showTooltip', tui.util.extend({
            indexes: {
                groupIndex: groupIndex,
                index: index
            },
            mousePosition: mousePosition
        }, params));
    },

    /**
     * hideTooltip is mouseout event callback on series graph.
     */
    hideTooltip: function() {
        this.fire('hideTooltip');
    },

    /**
     * Make series data by selection.
     * @param {number} index index
     * @returns {{indexes: {index: number, groupIndex: number}}} series data
     * @private
     */
    _makeSeriesDataBySelection: function(index) {
        return {
            indexes: {
                index: index,
                groupIndex: index
            }
        };
    },

    /**
     * Get series label.
     * @param {object} params parameters
     *      @param {string} params.legend legend
     *      @param {string} params.label label
     *      @param {string} params.separator separator
     * @returns {string} series label
     * @private
     */
    _getSeriesLabel: function(params) {
        var seriesLabel = '';

        if (this.options.showLegend) {
            seriesLabel = '<span class="tui-chart-series-legend">' + params.legend + '</span>';
        }

        if (this.options.showLabel) {
            seriesLabel += (seriesLabel ? params.separator : '') + params.label;
        }

        return seriesLabel;
    },

    /**
     * Render center legend.
     * @param {object} params parameters
     *      @param {Array.<object>} params.positions positions
     *      @param {string} params.separator separator
     *      @param {object} params.options options
     *      @param {function} params.funcMoveToPosition function
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderLegendLabel: function(params, seriesLabelContainer) {
        var self = this;
        var dataProcessor = this.dataProcessor;
        var seriesDataModel = this._getSeriesDataModel();
        var positions = params.positions;
        var htmls = tui.util.map(dataProcessor.getLegendLabels(this.seriesName), function(legend, index) {
            var html = '',
                label, position;

            if (positions[index]) {
                label = self._getSeriesLabel({
                    legend: legend,
                    label: seriesDataModel.getSeriesItem(0, index).label,
                    separator: params.separator
                });
                position = params.funcMoveToPosition(positions[index], label);
                html = self._makeSeriesLabelHtml(position, label, index);
            }

            return html;
        });

        seriesLabelContainer.innerHTML = htmls.join('');
    },

    /**
     * Move to center position.
     * @param {{left: number, top: number}} position position
     * @param {string} label label
     * @returns {{left: number, top: number}} center position
     * @private
     */
    _moveToCenterPosition: function(position, label) {
        var left = position.left - (renderUtil.getRenderedLabelWidth(label, this.theme.label) / 2),
            top = position.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);

        return {
            left: left,
            top: top
        };
    },

    /**
     * Pick poistions from sector data.
     * @param {string} positionType position type
     * @returns {Array} positions
     * @private
     */
    _pickPositionsFromSectorData: function(positionType) {
        return tui.util.map(this.seriesData.sectorData, function(datum) {
            return datum.ratio ? datum[positionType] : null;
        });
    },

    /**
     * Render center legend.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderCenterLegend: function(seriesLabelContainer) {
        this._renderLegendLabel({
            positions: this._pickPositionsFromSectorData('centerPosition'),
            funcMoveToPosition: tui.util.bind(this._moveToCenterPosition, this),
            separator: '<br>'
        }, seriesLabelContainer);
    },

    /**
     * Add end position.
     * @param {number} centerLeft center left
     * @param {Array.<object>} positions positions
     * @private
     */
    _addEndPosition: function(centerLeft, positions) {
        tui.util.forEachArray(positions, function(position) {
            var end;

            if (!position) {
                return;
            }

            end = tui.util.extend({}, position.middle);
            if (end.left < centerLeft) {
                end.left -= chartConst.SERIES_OUTER_LABEL_PADDING;
            } else {
                end.left += chartConst.SERIES_OUTER_LABEL_PADDING;
            }
            position.end = end;
        });
    },

    /**
     * Move to outer position.
     * @param {number} centerLeft center left
     * @param {object} position position
     * @param {string} label label
     * @returns {{left: number, top: number}} outer position
     * @private
     */
    _moveToOuterPosition: function(centerLeft, position, label) {
        var positionEnd = position.end,
            left = positionEnd.left,
            top = positionEnd.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);

        if (left < centerLeft) {
            left -= renderUtil.getRenderedLabelWidth(label, this.theme.label) + chartConst.SERIES_LABEL_PADDING;
        } else {
            left += chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: top
        };
    },

    /**
     * Render outer legend.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderOuterLegend: function(seriesLabelContainer) {
        var centerLeft = this.getSeriesData().circleBound.cx;
        var outerPositions = this._pickPositionsFromSectorData('outerPosition');
        var filteredPositions = tui.util.filter(outerPositions, function(position) {
            return position;
        });

        this._addEndPosition(centerLeft, filteredPositions);
        this._renderLegendLabel({
            positions: outerPositions,
            funcMoveToPosition: tui.util.bind(this._moveToOuterPosition, this, centerLeft),
            separator: ':&nbsp;'
        }, seriesLabelContainer);

        this.graphRenderer.renderLegendLines(filteredPositions);
    },

    /**
     * Render series label.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderSeriesLabel: function(seriesLabelContainer) {
        if (predicate.isLabelAlignOuter(this.options.labelAlign)) {
            this._renderOuterLegend(seriesLabelContainer);
        } else {
            this._renderCenterLegend(seriesLabelContainer);
        }
    },

    /**
     * Animate series label area.
     * @override
     */
    animateSeriesLabelArea: function() {
        this.graphRenderer.animateLegendLines(this.selectedLegendIndex);
        Series.prototype.animateSeriesLabelArea.call(this);
    },

    /**
     * Move legend lines.
     * @private
     * @override
     */
    _moveLegendLines: function() {
        var centerLeft = this.boundsMaker.getDimension('chart').width / 2,
            outerPositions = this._pickPositionsFromSectorData('outerPosition'),
            filteredPositions = tui.util.filter(outerPositions, function(position) {
                return position;
            });

        this._addEndPosition(centerLeft, filteredPositions);
        this.graphRenderer.moveLegendLines(filteredPositions);
    },

    /**
     * On click series.
     * @param {{left: number, top: number}} position mouse position
     */
    onClickSeries: function(position) {
        if (this.options.allowSelect) {
            this._executeGraphRenderer(position, 'clickSeries');
        }
    },

    /**
     * On move series.
     * @param {{left: number, top: number}} position mouse position
     */
    onMoveSeries: function(position) {
        this._executeGraphRenderer(position, 'moveMouseOnSeries');
    }
});

tui.util.CustomEvents.mixin(PieChartSeries);

module.exports = PieChartSeries;

},{"../const":31,"../helpers/predicate":61,"../helpers/renderUtil":63,"./series":102}],100:[function(require,module,exports){
/**
 * @fileoverview  renderingLabelHelper is helper for rendering of series label.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');
var renderUtil = require('../helpers/renderUtil');
var seriesTemplate = require('./seriesTemplate');

/**
 * renderingLabelHelper is helper for rendering of series label.
 */
var renderingLabelHelper = {
    /**
     * Calculate left position for center align of series label.
     * @param {{left: number, top: number, width:number, height: number}} bound - bound
     * @param {number} labelWidth - label width
     * @returns {number}
     * @private
     */
    _calculateLeftPositionForCenterAlign: function(bound, labelWidth) {
        return bound.left + ((bound.width - labelWidth) / 2);
    },

    /**
     * Calculate top position for middle align of series label.
     * @param {{left: number, top: number, width:number, height: number}} bound - bound
     * @param {number} labelHeight - label height
     * @returns {number}
     * @private
     */
    _calculateTopPositionForMiddleAlign: function(bound, labelHeight) {
        return bound.top + ((bound.height - labelHeight + chartConst.TEXT_PADDING) / 2);
    },

    /**
     * Make position for type of bound for rendering label.
     * @param {{left: number, top: number, width:number, height: number}} bound - bound
     * @param {number} labelHeight - label height
     * @param {string} label - label
     * @param {object} theme - theme for series label
     * @returns {{left: number, top: number}}
     * @private
     */
    _makePositionForBoundType: function(bound, labelHeight, label, theme) {
        var labelWidth = renderUtil.getRenderedLabelWidth(label, theme);

        return {
            left: this._calculateLeftPositionForCenterAlign(bound, labelWidth),
            top: this._calculateTopPositionForMiddleAlign(bound, labelHeight)
        };
    },

    /**
     * Make position map for rendering label.
     * @param {SeriesItem} seriesItem - series item
     * @param {{left: number, top: number, width: number, height: number}} bound - bound
     * @param {number} labelHeight - label height
     * @param {object} theme - theme for series label
     * @param {function} makePosition - function for making position of label
     * @returns {{end: *}}
     * @private
     */
    _makePositionMap: function(seriesItem, bound, labelHeight, theme, makePosition) {
        var value = seriesItem.value;
        var isOppositeSide = value >= 0;
        var positionMap = {
            end: makePosition(bound, labelHeight, seriesItem.endLabel || seriesItem.label, theme, isOppositeSide)
        };

        if (seriesItem.isRange) {
            isOppositeSide = value < 0;
            positionMap.start = makePosition(bound, labelHeight, seriesItem.startLabel, theme, isOppositeSide);
        }

        return positionMap;
    },

    /**
     * Bounds to label positions.
     * @param {SeriesDataModel} seriesDataModel - series data model
     * @param {Array.<Array.<{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set
     * @param {object} theme - theme for series label
     * @param {function} [makePosition] - function for making position of label
     * @param {boolean} [isPivot] - whether pivot or not
     * @returns {Array.<Object>}
     */
    boundsToLabelPositions: function(seriesDataModel, boundsSet, theme, makePosition, isPivot) {
        var self = this;
        var labelHeight = renderUtil.getRenderedLabelHeight(chartConst.MAX_HEIGHT_WORLD, theme);

        makePosition = makePosition || tui.util.bind(this._makePositionForBoundType, this);
        isPivot = !!isPivot;

        return seriesDataModel.map(function(seriesGroup, groupIndex) {
            var bounds = boundsSet[groupIndex];

            return seriesGroup.map(function(seriesItem, index) {
                var bound = bounds[index].end;

                return self._makePositionMap(seriesItem, bound, labelHeight, theme, makePosition);
            });
        }, isPivot);
    },

    /**
     * Make label position for bar chart.
     * @param {{left: number, top: number, width:number, height: number}} bound - bound
     * @param {number} labelHeight - label height
     * @param {string} label - label
     * @param {object} theme - theme for series label
     * @param {boolean} isOppositeSide - whether opossite side or not
     * @returns {{left: number, top: number}}
     * @private
     */
    _makePositionForBarChart: function(bound, labelHeight, label, theme, isOppositeSide) {
        var labelWidth = renderUtil.getRenderedLabelWidth(label, theme);
        var left = bound.left;

        if (isOppositeSide) {
            left += bound.width + chartConst.SERIES_LABEL_PADDING;
        } else {
            left -= labelWidth + chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: this._calculateTopPositionForMiddleAlign(bound, labelHeight)
        };
    },

    /**
     * Bounds to label positions for bar chart.
     * @param {SeriesDataModel} seriesDataModel - series data model
     * @param {Array.<Array.<{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set
     * @param {object} theme - theme for series label
     * @returns {*|Array.<Object>|Array}
     */
    boundsToLabelPositionsForBarChart: function(seriesDataModel, boundsSet, theme) {
        var makePositionFunction = tui.util.bind(this._makePositionForBarChart, this);

        return this.boundsToLabelPositions(seriesDataModel, boundsSet, theme, makePositionFunction);
    },

    /**
     * Make label position for column chart.
     * @param {{left: number, top: number, width:number, height: number}} bound - bound
     * @param {number} labelHeight - label height
     * @param {string} label - label
     * @param {object} theme - theme for series label
     * @param {boolean} isOppositeSide - whether opossite side or not
     * @returns {{left: number, top: number}}
     * @private
     */
    _makePositionForColumnChart: function(bound, labelHeight, label, theme, isOppositeSide) {
        var labelWidth = renderUtil.getRenderedLabelWidth(label, theme);
        var top = bound.top;

        if (isOppositeSide) {
            top -= labelHeight + chartConst.SERIES_LABEL_PADDING;
        } else {
            top += bound.height + chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: this._calculateLeftPositionForCenterAlign(bound, labelWidth),
            top: top
        };
    },

    /**
     * Bounds to label positions for column chart.
     * @param {SeriesDataModel} seriesDataModel - series data model
     * @param {Array.<Array.<{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set
     * @param {object} theme - theme for series label
     * @returns {*|Array.<Object>|Array}
     */
    boundsToLabelPositionsForColumnChart: function(seriesDataModel, boundsSet, theme) {
        var makePositionFunction = tui.util.bind(this._makePositionForColumnChart, this);

        return this.boundsToLabelPositions(seriesDataModel, boundsSet, theme, makePositionFunction);
    },

    /**
     * Make css text for series label.
     * @param {{left: number, top: number}} position - position for rendering label
     * @param {object} theme - theme for series label
     * @param {number} index - index of legends
     * @param {number} selectedIndex - selected index of legends
     * @param {object} [tplCssText] - cssText template object
     * @returns {*}
     * @private
     */
    _makeLabelCssText: function(position, theme, index, selectedIndex, tplCssText) {
        var cssObj = tui.util.extend(position, theme);

        tplCssText = tplCssText || seriesTemplate.tplCssText;

        if (tui.util.isExisty(selectedIndex) && (selectedIndex !== index)) {
            cssObj.opacity = renderUtil.makeOpacityCssText(chartConst.SERIES_LABEL_OPACITY);
        } else {
            cssObj.opacity = '';
        }

        return tplCssText(cssObj);
    },

    /**
     * Make html for series label.
     * @param {{left: number, top: number}} position - position for rendering label
     * @param {string} label - label of SeriesItem
     * @param {object} theme - theme for series label
     * @param {number} index - index of legends
     * @param {number} selectedIndex - selected index of legends
     * @param {object} [tplCssText] - cssText template object
     * @param {boolean} [isStart] - whether start label or not
     * @returns {string}
     */
    makeSeriesLabelHtml: function(position, label, theme, index, selectedIndex, tplCssText, isStart) {
        /*eslint max-params: [2, 7]*/
        var cssText = this._makeLabelCssText(position, theme, index, selectedIndex, tplCssText);
        var rangeLabelAttribute = '';

        if (isStart) {
            rangeLabelAttribute = ' data-range="true"';
        }

        return seriesTemplate.tplSeriesLabel({
            label: label,
            cssText: cssText,
            rangeLabelAttribute: rangeLabelAttribute
        });
    },

    /**
     * Make labels html for bound type chart.
     * @param {SeriesDataModel} seriesDataModel - series data model
     * @param {Array.<Array.<{left: number, top: number}>>} positionsSet - positions set
     * @param {object} theme - theme for series label
     * @param {number} selectedIndex - selected index of legends
     * @param {boolean} [isPivot] - whether pivot or not
     * @returns {*}
     */
    makeLabelsHtmlForBoundType: function(seriesDataModel, positionsSet, theme, selectedIndex, isPivot) {
        var makeSeriesLabelHtml = tui.util.bind(this.makeSeriesLabelHtml, this);
        var labelsHtml = seriesDataModel.map(function(seriesGroup, groupIndex) {
            return seriesGroup.map(function(seriesItem, index) {
                var positionMap = positionsSet[groupIndex][index];
                var html = makeSeriesLabelHtml(positionMap.end, seriesItem.endLabel, theme, index, selectedIndex);

                if (positionMap.start) {
                    html += makeSeriesLabelHtml(positionMap.start, seriesItem.startLabel, theme, index, selectedIndex);
                }

                return html;
            }).join('');
        }, !!isPivot).join('');

        return labelsHtml;
    },

    /**
     * Make labels html for treemap chart.
     * @param {Array.<SeriesItem>} seriesItems - seriesItems
     * @param {object.<string, {left: number, top: number, width: number, height: number}>} boundMap - bound map
     * @param {object} theme - theme for series label
     * @param {function} shouldDimmed - returns whether should dimmed or not
     * @returns {string}
     */
    makeLabelsHtmlForTreemap: function(seriesItems, boundMap, theme, shouldDimmed) {
        var self = this;
        var labelHeight = renderUtil.getRenderedLabelHeight(chartConst.MAX_HEIGHT_WORLD, theme);
        var makePosition = tui.util.bind(this._makePositionForBoundType, this);

        var labelsHtml = tui.util.map(seriesItems, function(seriesItem, index) {
            var bound = boundMap[seriesItem.id];
            var html = '';
            var position, compareIndex;

            if (bound) {
                position = self._makePositionMap(seriesItem, bound, labelHeight, theme, makePosition).end;
                compareIndex = shouldDimmed(seriesItem) ? -1 : null;

                html = self.makeSeriesLabelHtml(position, seriesItem.label, theme, index, compareIndex);
            }

            return html;
        }).join('');

        return labelsHtml;
    }
};

module.exports = renderingLabelHelper;

},{"../const":31,"../helpers/renderUtil":63,"./seriesTemplate":103}],101:[function(require,module,exports){
/**
 * @fileoverview Scatter chart series component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series');
var CoordinateTypeSeriesBase = require('./coordinateTypeSeriesBase');
var chartConst = require('../const');

var ScatterChartSeries = tui.util.defineClass(Series, /** @lends ScatterChartSeries.prototype */ {
    /**
     * Scatter chart series component.
     * @constructs ScatterChartSeries
     * @extends Series
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make bound for scatter chart.
     * @param {{x: number, y: number, r: number}} ratioMap - ratio map
     * @returns {{left: number, top: number, raius: number}}
     * @private
     */
    _makeBound: function(ratioMap) {
        var dimension = this.boundsMaker.getDimension('series');

        return {
            left: ratioMap.x * dimension.width,
            top: dimension.height - (ratioMap.y * dimension.height),
            radius: chartConst.SCATTER_RADIUS
        };
    },

    /**
     * Make bounds for scatter chart.
     * @returns {Array.<Array.<{left: number, top: number, radius: number}>>} positions
     * @private
     */
    _makeBounds: function() {
        var self = this;
        var seriesDataModel = this._getSeriesDataModel();

        return seriesDataModel.map(function(seriesGroup) {
            return seriesGroup.map(function(seriesItem) {
                var hasRatioMap = (seriesItem && seriesItem.ratioMap);

                return hasRatioMap ? self._makeBound(seriesItem.ratioMap) : null;
            });
        });
    }
});

CoordinateTypeSeriesBase.mixin(ScatterChartSeries);
tui.util.CustomEvents.mixin(ScatterChartSeries);

module.exports = ScatterChartSeries;

},{"../const":31,"./coordinateTypeSeriesBase":94,"./series":102}],102:[function(require,module,exports){
/**
 * @fileoverview Series base component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var labelHelper = require('./renderingLabelHelper');
var chartConst = require('../const');
var dom = require('../helpers/domHandler');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');
var pluginFactory = require('../factories/pluginFactory');

var Series = tui.util.defineClass(/** @lends Series.prototype */ {
    /**
     * Series base component.
     * @constructs Series
     * @param {object} params parameters
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function(params) {
        var libType = params.libType || chartConst.DEFAULT_PLUGIN;

        /**
         * Chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * Series name
         * @tpye {string}
         */
        this.seriesName = params.seriesName || params.chartType;

        /**
         * Component type
         * @type {string}
         */
        this.componentType = params.componentType;

        /**
         * Data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * User event listener
         * @type {UserEventListener}
         */
        this.userEvent = params.userEvent;

        /**
         * chart background.
         * @type {string}
         */
        this.chartBackground = params.chartBackground;

        /**
         * Options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * Theme
         * @type {object}
         */
        this.orgTheme = this.theme = params.theme;

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = !!params.hasAxes;

        /**
         * Graph renderer
         * @type {object}
         */
        this.graphRenderer = pluginFactory.get(libType, params.chartType);

        /**
         * Series view className
         * @type {string}
         */
        this.className = 'tui-chart-series-area';

        /**
         * series container
         * @type {HTMLElement}
         */
        this.seriesContainer = null;

        /**
         * series label container
         * @type {HTMLElement}
         */
        this.seriesLabelContainer = null;

        /**
         * series data
         * @type {Array.<object>}
         */
        this.seriesData = [];

        /**
         * Selected legend index
         * @type {?number}
         */
        this.selectedLegendIndex = null;

        /**
         * effector for show layer
         * @type {object}
         */
        this.labelShowEffector = null;
    },

    /**
     * Get seriesDataModel.
     * @returns {SeriesDataModel}
     * @private
     */
    _getSeriesDataModel: function() {
        return this.dataProcessor.getSeriesDataModel(this.seriesName);
    },

    /**
     * Make series data.
     * @private
     * @abstract
     */
    _makeSeriesData: function() {},

    /**
     * Get seriesData
     * @returns {object} series data
     */
    getSeriesData: function() {
        return this.seriesData;
    },

    /**
     * Render series label.
     * @private
     * @abstract
     */
    _renderSeriesLabel: function() {},

    /**
     * Render series label area
     * @param {?HTMLElement} seriesLabelContainer series label area element
     * @returns {HTMLElement} series label area element
     * @private
     */
    _renderSeriesLabelArea: function(seriesLabelContainer) {
        var extendedDimension;

        if (!seriesLabelContainer) {
            seriesLabelContainer = dom.create('div', 'tui-chart-series-label-area');
            if (!predicate.isMousePositionChart(this.chartType)) {
                extendedDimension = this.boundsMaker.getDimension('extendedSeries');
                renderUtil.renderDimension(seriesLabelContainer, extendedDimension);
            }
        }

        this._renderSeriesLabel(seriesLabelContainer);

        return seriesLabelContainer;
    },

    /**
     * Render series area.
     * @param {HTMLElement} seriesContainer series area element
     * @param {object} data data for rendering
     * @param {function} funcRenderGraph function for graph rendering
     * @returns {object}
     * @private
     */
    _renderSeriesArea: function(seriesContainer, data, funcRenderGraph) {
        var extendedBound = this.boundsMaker.getBound('extendedSeries');
        var seriesData, seriesLabelContainer, paper;

        this.data = data;

        this.seriesData = seriesData = this._makeSeriesData();

        if (!data.paper) {
            renderUtil.renderDimension(seriesContainer, extendedBound.dimension);
        }

        this._renderPosition(seriesContainer, extendedBound.position);

        if (funcRenderGraph) {
            paper = funcRenderGraph(extendedBound.dimension, seriesData, data.paper);
        }

        if (predicate.isShowLabel(this.options)) {
            seriesLabelContainer = this._renderSeriesLabelArea(this.seriesLabelContainer);
            this.seriesLabelContainer = seriesLabelContainer;
            dom.append(seriesContainer, seriesLabelContainer);
        }

        return paper;
    },

    /**
     * Make parameters for graph rendering.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @returns {object} parameters for graph rendering
     * @private
     */
    _makeParamsForGraphRendering: function(dimension, seriesData) {
        return tui.util.extend({
            dimension: dimension,
            chartType: this.seriesName,
            theme: this.theme,
            options: this.options
        }, seriesData);
    },

    /**
     * Render raphael graph.
     * @param {{width: number, height: number}} dimension - dimension
     * @param {object} seriesData - series data
     * @param {object} [paper] - raphael paper
     * @returns {object}
     * @private
     */
    _renderGraph: function(dimension, seriesData, paper) {
        var params = this._makeParamsForGraphRendering(dimension, seriesData);

        paper = this.graphRenderer.render(this.seriesContainer, params, paper);

        return paper;
    },

    /**
     * Render series component.
     * @param {object} data data for rendering
     * @returns {HTMLElement} series element
     */
    render: function(data) {
        var container = dom.create('DIV', this.className);
        var paper;

        this.seriesContainer = container;
        paper = this._renderSeriesArea(container, data, tui.util.bind(this._renderGraph, this));

        return {
            container: container,
            paper: paper
        };
    },

    /**
     * Update theme.
     * @param {object} theme legend theme
     * @param {?Array.<?boolean>} checkedLegends checked legends
     * @returns {object} updated theme
     * @private
     */
    _updateTheme: function(theme, checkedLegends) {
        var cloneTheme;

        if (!checkedLegends.length) {
            return theme;
        }

        cloneTheme = JSON.parse(JSON.stringify(theme));
        cloneTheme.colors = tui.util.filter(cloneTheme.colors, function(color, index) {
            return checkedLegends[index];
        });

        return cloneTheme;
    },

    /**
     * Clear container.
     * @param {object} paper - raphael object
     * @private
     */
    _clearContainer: function(paper) {
        if (this.graphRenderer.clear && !paper) {
            this.graphRenderer.clear();
        }

        this.seriesContainer.innerHTML = '';
        this.seriesLabelContainer = null;
        this.seriesData = [];
    },

    /**
     * Rerender.
     * @param {object} data data for rendering
     * @returns {{container: HTMLElement, paper: object}}
     */
    rerender: function(data) {
        var paper;

        this._clearContainer();

        if (this.dataProcessor.getGroupCount(this.seriesName)) {
            if (data.checkedLegends) {
                this.theme = this._updateTheme(this.orgTheme, data.checkedLegends);
            }

            paper = this._renderSeriesArea(this.seriesContainer, data, tui.util.bind(this._renderGraph, this));

            if (this.labelShowEffector) {
                clearInterval(this.labelShowEffector.timerId);
            }

            if (data.checkedLegends) {
                this.animateComponent(true);
            } else {
                this._showGraphWithoutAnimation();
            }

            if (!tui.util.isNull(this.selectedLegendIndex)) {
                this.graphRenderer.selectLegend(this.selectedLegendIndex);
            }
        }

        return {
            container: this.seriesContainer,
            paper: paper
        };
    },

    /**
     * Whether use label or not.
     * @returns {boolean}
     * @private
     */
    _useLabel: function() {
        return this.seriesLabelContainer && (this.options.showLabel || this.options.showLegend);
    },

    /**
     * Show series label without animation.
     * @private
     */
    _showSeriesLabelWithoutAnimation: function() {
        dom.addClass(this.seriesLabelContainer, 'show opacity');
    },

    /**
     * Show graph without animation.
     * @private
     */
    _showGraphWithoutAnimation: function() {
        this.graphRenderer.showGraph();

        if (this._useLabel()) {
            this._showSeriesLabelWithoutAnimation();
        }
    },

    /**
     * Resize raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     */
    _resizeGraph: function(dimension, seriesData) {
        this.graphRenderer.resize(tui.util.extend({
            dimension: dimension
        }, seriesData));
    },

    /**
     * Resize series component.
     * }} bound series bound
     * @param {object} data data for rendering
     */
    resize: function(data) {
        this._renderSeriesArea(this.seriesContainer, data, tui.util.bind(this._resizeGraph, this));
    },

    /**
     * Render bounds
     * @param {HTMLElement} el series element
     * @param {{top: number, left: number}} position series position
     * @private
     */
    _renderPosition: function(el, position) {
        var hiddenWidth = renderUtil.isOldBrowser() ? 1 : 0;

        renderUtil.renderPosition(el, {
            top: position.top - (hiddenWidth),
            left: position.left - (hiddenWidth * 2)
        });
    },

    /**
     * Get limit distance from zero point.
     * @param {number} size chart size (width or height)
     * @param {{min: number, max: number}} limit limit
     * @returns {{toMax: number, toMin: number}} pixel distance
     * @private
     */
    _getLimitDistanceFromZeroPoint: function(size, limit) {
        var min = limit.min,
            max = limit.max,
            distance = max - min,
            toMax = 0,
            toMin = 0;

        if (min <= 0 && max >= 0) {
            toMax = (distance + min) / distance * size;
            toMin = (distance - max) / distance * size;
        } else if (min > 0) {
            toMax = size;
        }

        return {
            toMax: toMax,
            toMin: toMin
        };
    },

    /**
     * Find label element.
     * @param {HTMLElement} elTarget target element
     * @returns {HTMLElement} label element
     * @private
     */
    _findLabelElement: function(elTarget) {
        var elLabel = null;

        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_SERIES_LABEL)) {
            elLabel = elTarget;
        } else {
            elLabel = dom.findParentByClass(elTarget, chartConst.CLASS_NAME_SERIES_LABEL);
        }

        return elLabel;
    },

    /**
     * To call showAnimation function of graphRenderer.
     * @param {{groupIndex: number, index: number}} data data
     */
    onShowAnimation: function(data) {
        if (!this.graphRenderer.showAnimation) {
            return;
        }
        this.graphRenderer.showAnimation(data);
    },

    /**
     * To call hideAnimation function of graphRenderer.
     * @param {{groupIndex: number, index: number}} data data
     */
    onHideAnimation: function(data) {
        if (!this.graphRenderer.hideAnimation || !data) {
            return;
        }
        this.graphRenderer.hideAnimation(data);
    },

    /**
     * To call showGroupAnimation function of graphRenderer.
     * @param {number} index index
     */
    onShowGroupAnimation: function(index) {
        if (!this.graphRenderer.showGroupAnimation) {
            return;
        }
        this.graphRenderer.showGroupAnimation(index);
    },

    /**
     * To call hideGroupAnimation function of graphRenderer.
     * @param {number} index index
     */
    onHideGroupAnimation: function(index) {
        if (!this.graphRenderer.hideGroupAnimation) {
            return;
        }
        this.graphRenderer.hideGroupAnimation(index);
    },

    /**
     * Animate component.
     * @param {boolean} [isRerendering] - whether rerendering or not
     */
    animateComponent: function(isRerendering) {
        if (this.graphRenderer.animate) {
            this.graphRenderer.animate(tui.util.bind(this.animateSeriesLabelArea, this, isRerendering));
        } else {
            this.animateSeriesLabelArea(isRerendering);
        }
    },

    /**
     * Make html about series label.
     * @param {{left: number, top: number}} position - position for rendering
     * @param {string} label - label of SeriesItem
     * @param {number} index - index of legend
     * @param {object} [tplCssText] - cssText template object
     * @param {boolean} [isStart] - whether start label or not
     * @returns {string}
     * @private
     */
    _makeSeriesLabelHtml: function(position, label, index, tplCssText, isStart) {
        var labelTheme = this.theme.label;
        var selectedIndex = this.selectedLegendIndex;

        return labelHelper.makeSeriesLabelHtml(position, label, labelTheme, index, selectedIndex, tplCssText, isStart);
    },

    /**
     * Fire load event.
     * @param {boolean} [isRerendering] - whether rerendering or not
     * @private
     */
    _fireLoadEvent: function(isRerendering) {
        if (!isRerendering) {
            this.userEvent.fire('load');
        }
    },

    /**
     * Animate series label area.
     * @param {boolean} [isRerendering] - whether rerendering or not
     */
    animateSeriesLabelArea: function(isRerendering) {
        var self = this;

        if (!this._useLabel()) {
            this._fireLoadEvent(isRerendering);

            return;
        }

        if (renderUtil.isIE7()) {
            this._showSeriesLabelWithoutAnimation();
            this._fireLoadEvent(isRerendering);
        } else {
            dom.addClass(this.seriesLabelContainer, 'show');
            this.labelShowEffector = new tui.component.Effects.Fade({
                element: this.seriesLabelContainer,
                duration: 300
            });
            this.labelShowEffector.action({
                start: 0,
                end: 1,
                complete: function() {
                    if (self.labelShowEffector) {
                        clearInterval(self.labelShowEffector.timerId);
                    }
                    self.labelShowEffector = null;
                    dom.addClass(self.seriesLabelContainer, 'opacity');
                    self._fireLoadEvent(isRerendering);
                }
            });
        }
    },

    /**
     * Make exportation data for series type userEvent.
     * @param {object} seriesData series data
     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} export data
     * @private
     */
    _makeExportationSeriesData: function(seriesData) {
        var legendIndex = seriesData.indexes.index;
        var legendData = this.dataProcessor.getLegendItem(legendIndex);

        return {
            chartType: legendData.chartType,
            legend: legendData.label,
            legendIndex: legendIndex,
            index: seriesData.indexes.groupIndex
        };
    },

    /**
     * Execute graph renderer.
     * @param {{left: number, top: number}} position mouse position
     * @param {string} funcName function name
     * @returns {*} result.
     * @private
     */
    _executeGraphRenderer: function(position, funcName) {
        var isShowLabel = false;
        var result;

        this.fire('hideTooltipContainer');

        if (this.seriesLabelContainer && dom.hasClass(this.seriesLabelContainer, 'show')) {
            dom.removeClass(this.seriesLabelContainer, 'show');
            isShowLabel = true;
        }

        result = this.graphRenderer[funcName](position);

        if (isShowLabel) {
            dom.addClass(this.seriesLabelContainer, 'show');
        }

        this.fire('showTooltipContainer');

        return result;
    },

    /**
     * To call selectSeries callback of userEvent.
     * @param {object} seriesData series data
     */
    onSelectSeries: function(seriesData) {
        this.userEvent.fire('selectSeries', this._makeExportationSeriesData(seriesData));
        if (this.options.allowSelect && this.graphRenderer.selectSeries) {
            this.graphRenderer.selectSeries(seriesData.indexes);
        }
    },

    /**
     * To call unselectSeries callback of userEvent.
     * @param {object} seriesData series data.
     */
    onUnselectSeries: function(seriesData) {
        this.userEvent.fire('unselectSeries', this._makeExportationSeriesData(seriesData));
        if (this.options.allowSelect && this.graphRenderer.unselectSeries) {
            this.graphRenderer.unselectSeries(seriesData.indexes);
        }
    },

    /**
     *On select legend.
     * @param {string} seriesName - series name
     * @param {?number} legendIndex - legend index
     */
    onSelectLegend: function(seriesName, legendIndex) {
        if ((this.seriesName !== seriesName) && !tui.util.isNull(legendIndex)) {
            legendIndex = -1;
        }

        this.selectedLegendIndex = legendIndex;

        if (this._getSeriesDataModel().getGroupCount()) {
            this._renderSeriesArea(this.seriesContainer, this.data);
            this.graphRenderer.selectLegend(legendIndex);
        }
    },

    /**
     * Show label.
     */
    showLabel: function() {
        this.options.showLabel = true;
        this._showSeriesLabelWithoutAnimation();
    },

    /**
     * Hide label.
     */
    hideLabel: function() {
        this.options.showLabel = false;
        dom.removeClass(this.seriesLabelContainer, 'show');
        dom.removeClass(this.seriesLabelContainer, 'opacity');
    }
});

module.exports = Series;

},{"../const":31,"../factories/pluginFactory":52,"../helpers/domHandler":59,"../helpers/predicate":61,"../helpers/renderUtil":63,"./renderingLabelHelper":100}],103:[function(require,module,exports){
/**
 * @fileoverview This is templates of series.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var htmls = {
    HTML_SERIES_LABEL: '<div class="tui-chart-series-label" style="{{ cssText }}"{{ rangeLabelAttribute }}>' +
        '{{ label }}</div>',
    TEXT_CSS_TEXT: 'left:{{ left }}px;top:{{ top }}px;font-family:{{ fontFamily }};' +
        'font-size:{{ fontSize }}px{{opacity}}',
    TEXT_CSS_TEXT_FOR_LINE_TYPE: 'left:{{ left }}%;top:{{ top }}%;font-family:{{ fontFamily }};' +
    'font-size:{{ fontSize }}px{{opacity}}',
    HTML_ZOOM_BUTTONS: '<a class="tui-chart-zoom-btn" href="#" data-magn="2">' +
            '<div class="horizontal-line"></div><div class="vertical-line"></div></a>' +
        '<a class="tui-chart-zoom-btn" href="#" data-magn="0.5"><div class="horizontal-line"></div></a>',
    HTML_SERIES_BLOCK: '<div class="tui-chart-series-block" style="{{ cssText }}">{{ label }}</div>'
};

module.exports = {
    tplSeriesLabel: templateMaker.template(htmls.HTML_SERIES_LABEL),
    tplCssText: templateMaker.template(htmls.TEXT_CSS_TEXT),
    tplCssTextForLineType: templateMaker.template(htmls.TEXT_CSS_TEXT_FOR_LINE_TYPE),
    ZOOM_BUTTONS: htmls.HTML_ZOOM_BUTTONS,
    tplSeriesBlock: templateMaker.template(htmls.HTML_SERIES_BLOCK)
};

},{"../helpers/templateMaker":64}],104:[function(require,module,exports){
/**
 * @fileoverview squarifier create squarified bounds for rendering graph of treemap chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var squarifier = {
    /**
     * bound map
     * @type {object.<string, {width: number, height: number, left: number, top: number}>}
     */
    boundMap: {},

    /**
     * Make base bound for calculating bounds.
     * @param {{width: number, height: number}} dimension - dimension
     * @returns {{width: number, height: number, left: number, top: number}}
     * @private
     */
    _makeBaseBound: function(dimension) {
        return tui.util.extend({
            left: 0,
            top: 0
        }, dimension);
    },

    /**
     * Calculate scale for calculating weight.
     * @param {Array.<number>} values - values
     * @param {number} width - width of series area
     * @param {number} height - height of series area
     * @returns {number}
     * @private
     */
    _calculateScale: function(values, width, height) {
        return (width * height) / tui.util.sum(values);
    },

    /**
     * Make base data for creating squarified bounds.
     * @param {Array.<SeriesItem>} seriesItems - SeriesItems
     * @param {number} width - width of series area
     * @param {number} height - height of series area
     * @returns {Array.<{itme: SeriesItem, weight: number}>}
     * @private
     */
    _makeBaseData: function(seriesItems, width, height) {
        var scale = this._calculateScale(tui.util.pluck(seriesItems, 'value'), width, height);
        var data = tui.util.map(seriesItems, function(seriesItem) {
            return {
                id: seriesItem.id,
                weight: seriesItem.value * scale
            };
        }).sort(function(a, b) {
            return b.weight - a.weight;
        });

        return data;
    },

    /**
     * Calculate worst aspect ratio.
     * Referred function worst() in https://www.win.tue.nl/~vanwijk/stm.pdf
     * @param {number} sum - sum for weights
     * @param {number} min - minimum weight
     * @param {number} max - maximum weight
     * @param {number} baseSize - base size (width or height)
     * @returns {number}
     * @private
     */
    _worst: function(sum, min, max, baseSize) {
        var sumSquare = sum * sum;
        var sizeSquare = baseSize * baseSize;

        return Math.max((sizeSquare * max) / sumSquare, sumSquare / (sizeSquare * min));
    },

    /**
     * Whether changed stack direction or not.
     * @param {number} sum - sum for weights
     * @param {Array.<number>} weights - weights
     * @param {number} baseSize - base size
     * @param {number} newWeight - new weight
     * @returns {boolean}
     * @private
     */
    _changedStackDirection: function(sum, weights, baseSize, newWeight) {
        var min = tui.util.min(weights);
        var max = tui.util.max(weights);
        var beforeWorst = this._worst(sum, min, max, baseSize);
        var newWorst = this._worst(sum + newWeight, Math.min(min, newWeight), Math.max(max, newWeight), baseSize);

        return newWorst >= beforeWorst;
    },

    /**
     * Whether type of vertical stack or not.
     * @param {{width: number, height: number}} baseBound - base bound
     * @returns {boolean}
     * @private
     */
    _isVerticalStack: function(baseBound) {
        return baseBound.height < baseBound.width;
    },

    /**
     * Select base size from baseBound.
     * @param {{width: number, height: number}} baseBound - base bound
     * @returns {number}
     * @private
     */
    _selectBaseSize: function(baseBound) {
        return this._isVerticalStack(baseBound) ? baseBound.height : baseBound.width;
    },

    /**
     * Calculate fixed size.
     * @param {number} baseSize - base size
     * @param {number} sum - sum for weights
     * @param {Array.<{weight: number}>} row - row
     * @returns {number}
     * @private
     */
    _calculateFixedSize: function(baseSize, sum, row) {
        var weights;

        if (!sum) {
            weights = tui.util.pluck(row, 'weight');
            sum = tui.util.sum(weights);
        }

        return sum / baseSize;
    },

    /**
     * Add bounds.
     * @param {number} startPosition - start position
     * @param {Array.<{weight: number}>} row - row
     * @param {number} fixedSize - fixed size
     * @param {function} callback - callback function
     * @private
     */
    _addBounds: function(startPosition, row, fixedSize, callback) {
        tui.util.reduce([startPosition].concat(row), function(storedPosition, rowDatum) {
            var dynamicSize = rowDatum.weight / fixedSize;

            callback(dynamicSize, storedPosition, rowDatum.id);

            return storedPosition + dynamicSize;
        });
    },

    /**
     * Add bound.
     * @param {number} left - left position
     * @param {number} top - top position
     * @param {number} width - width
     * @param {number} height - height
     * @param {string | number} id - id of seriesItem
     * @private
     */
    _addBound: function(left, top, width, height, id) {
        this.boundMap[id] = {
            left: left,
            top: top,
            width: width,
            height: height
        };
    },

    /**
     * Add bounds for type of vertical stack.
     * @param {Array.<{weight: number}>} row - row
     * @param {{left: number, top: number, width: number, height: number}} baseBound - base bound
     * @param {number} baseSize - base size
     * @param {number} sum - sum for weights of row
     * @private
     */
    _addBoundsForVerticalStack: function(row, baseBound, baseSize, sum) {
        var self = this;
        var fixedWidth = this._calculateFixedSize(baseSize, sum, row);

        this._addBounds(baseBound.top, row, fixedWidth, function(dynamicHeight, storedTop, id) {
            self._addBound(baseBound.left, storedTop, fixedWidth, dynamicHeight, id);
        });

        baseBound.left += fixedWidth;
        baseBound.width -= fixedWidth;
    },

    /**
     * Add bounds for type of horizontal stack.
     * @param {Array.<{weight: number}>} row - row
     * @param {{left: number, top: number, width: number, height: number}} baseBound - base bound
     * @param {number} baseSize - base size
     * @param {number} sum - sum for weights of row
     * @private
     */
    _addBoundsForHorizontalStack: function(row, baseBound, baseSize, sum) {
        var self = this;
        var fixedHeight = this._calculateFixedSize(baseSize, sum, row);

        this._addBounds(baseBound.left, row, fixedHeight, function(dynamicWidth, storedLeft, id) {
            self._addBound(storedLeft, baseBound.top, dynamicWidth, fixedHeight, id);
        });

        baseBound.top += fixedHeight;
        baseBound.height -= fixedHeight;
    },

    /**
     * Get adding bounds function.
     * @param {{width: number, height: number}} baseBound - base bound
     * @returns {*}
     * @private
     */
    _getAddingBoundsFunction: function(baseBound) {
        var addBound;

        if (this._isVerticalStack(baseBound)) {
            addBound = tui.util.bind(this._addBoundsForVerticalStack, this);
        } else {
            addBound = tui.util.bind(this._addBoundsForHorizontalStack, this);
        }

        return addBound;
    },

    /**
     * Create squarified bound map for graph rendering.
     * @param {{width: number, height: number}} dimension - dimension
     * @param {Array.<SeriesItem>} seriesItems - seriesItems
     * @returns {object.<string, {width: number, height: number, left: number, top: number}>}
     */
    squarify: function(dimension, seriesItems) {
        var self = this;
        var baseBound = this._makeBaseBound(dimension);
        var baseData = this._makeBaseData(seriesItems, baseBound.width, baseBound.height);
        var row = [];
        var baseSize, addBounds;

        this.boundMap = {};

        tui.util.forEachArray(baseData, function(datum) {
            var weights = tui.util.pluck(row, 'weight');
            var sum = tui.util.sum(weights);

            if (row.length && self._changedStackDirection(sum, weights, baseSize, datum.weight)) {
                addBounds(row, baseBound, baseSize, sum);
                row = [];
            }

            if (!row.length) {
                baseSize = self._selectBaseSize(baseBound);
                addBounds = self._getAddingBoundsFunction(baseBound);
            }

            row.push(datum);
        });

        if (row.length) {
            addBounds(row, baseBound, baseSize);
        }

        return this.boundMap;
    }
};

module.exports = squarifier;

},{}],105:[function(require,module,exports){
/**
 * @fileoverview Series component for rendering graph of treemap chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series');
var squarifier = require('./squarifier');
var labelHelper = require('./renderingLabelHelper');
var chartConst = require('../const');
var predicate = require('../helpers/predicate');

var TreemapChartSeries = tui.util.defineClass(Series, /** @lends TreemapChartSeries.prototype */ {
    /**
     * Series component for rendering graph of treemap chart.
     * @constructs TreemapChartSeries
     * @extends Series
     */
    init: function() {
        Series.apply(this, arguments);

        this.theme.borderColor = this.theme.borderColor || chartConst.TREEMAP_DEFAULT_BORDER;

        /**
         * root id
         * @type {string}
         */
        this.rootId = chartConst.TREEMAP_ROOT_ID;

        /**
         * start depth of seriesItem for rendering graph
         * @type {number}
         */
        this.startDepth = 1;

        /**
         * selected group
         * @type {null | number}
         */
        this.selectedGroup = null;

        /**
         * bound map
         * @type {null|object.<string, object>}
         */
        this.boundMap = null;

        this._initOptions();
    },

    /**
     * Initialize options.
     * @private
     */
    _initOptions: function() {
        this.options.useColorValue = !!this.options.useColorValue;

        if (tui.util.isUndefined(this.options.zoomable)) {
            this.options.zoomable = !this.options.useColorValue;
        }

        if (tui.util.isUndefined(this.options.useLeafLabel)) {
            this.options.useLeafLabel = !this.options.zoomable;
        }
    },

    /**
     * Make series data.
     * @returns {{
     *      groupBounds: object.<string, {left: number, top: number, width: number, height: number}>,
     *      seriesDataModel: SeriesDataModel
     * }}
     * @private
     * @override
     */
    _makeSeriesData: function() {
        var boundMap = this._getBoundMap();

        return {
            boundMap: boundMap,
            groupBounds: this._makeBounds(boundMap),
            seriesDataModel: this._getSeriesDataModel(),
            startDepth: this.startDepth,
            isPivot: true,
            colorSpectrum: this.options.useColorValue ? this.data.colorSpectrum : null,
            chartBackground: this.chartBackground,
            zoomable: this.options.zoomable
        };
    },

    /**
     * Make bound map by dimension.
     * @param {string | number} parent - parent id
     * @param {object.<string, {left: number, top: number, width: number, height: number}>} boundMap - bound map
     * @param {{width: number, height: number}} dimension - dimension
     * @returns {object.<string, {left: number, top: number, width: number, height: number}>}
     * @private
     */
    _makeBoundMap: function(parent, boundMap, dimension) {
        var self = this;
        var seriesDataModel = this._getSeriesDataModel();
        var seriesItems;

        dimension = dimension || this.boundsMaker.getDimension('series');
        seriesItems = seriesDataModel.findSeriesItemsByParent(parent);
        boundMap = tui.util.extend(boundMap || {}, squarifier.squarify(dimension, seriesItems));

        tui.util.forEachArray(seriesItems, function(seriesItem) {
            boundMap = self._makeBoundMap(seriesItem.id, boundMap, boundMap[seriesItem.id]);
        });

        return boundMap;
    },

    /**
     * Make bounds for rendering graph.
     * @param {object.<string, {left: number, top: number, width: number, height: number}>} boundMap - bound map
     * @returns {Array.<Array.<{left: number, top: number, width: number, height: number}>>}
     * @private
     */
    _makeBounds: function(boundMap) {
        var startDepth = this.startDepth;
        var seriesDataModel = this._getSeriesDataModel();
        var isValid;

        if (this.options.zoomable) {
            isValid = function(seriesItem) {
                return seriesItem.depth === startDepth;
            };
        } else {
            isValid = function(seriesItem) {
                return !seriesItem.hasChild;
            };
        }

        return seriesDataModel.map(function(seriesGroup) {
            return seriesGroup.map(function(seriesItem) {
                var bound = boundMap[seriesItem.id];
                var result = null;

                if (bound && isValid(seriesItem)) {
                    result = {
                        end: bound
                    };
                }

                return result;
            }, true);
        }, true);
    },

    /**
     * Get bound map for rendering graph.
     * @returns {object.<string, {left: number, top: number, width: number, height: number}>}
     * @private
     */
    _getBoundMap: function() {
        if (!this.boundMap) {
            this.boundMap = this._makeBoundMap(this.rootId);
        }

        return this.boundMap;
    },

    /**
     * Whether should dimmed or not.
     * @param {SeriesDataModel} seriesDataModel - SeriesDataModel for treemap
     * @param {SeriesItem} hoverSeriesItem - hover SeriesItem
     * @param {SeriesItem} seriesItem - target SeriesItem
     * @returns {boolean}
     * @private
     */
    _shouldDimmed: function(seriesDataModel, hoverSeriesItem, seriesItem) {
        var shouldTransparent = false;
        var parent;

        if (hoverSeriesItem && seriesItem.id !== hoverSeriesItem.id && seriesItem.group === hoverSeriesItem.group) {
            parent = seriesDataModel.findParentByDepth(seriesItem.id, hoverSeriesItem.depth + 1);

            if (parent && parent.parent === hoverSeriesItem.id) {
                shouldTransparent = true;
            }
        }

        return shouldTransparent;
    },

    /**
     * Render series label.
     * @param {HTMLElement} labelContainer - series label container
     * @param {SeriesItem} hoverSeriesItem - hover SeriesItem
     * @private
     */
    _renderSeriesLabel: function(labelContainer, hoverSeriesItem) {
        var seriesDataModel = this._getSeriesDataModel();
        var boundMap = this._getBoundMap();
        var seriesItems, shouldDimmed, html;

        if (this.options.useLeafLabel) {
            seriesItems = seriesDataModel.findLeafSeriesItems(this.selectedGroup);
        } else {
            seriesItems = seriesDataModel.findSeriesItemsByDepth(this.startDepth, this.selectedGroup);
        }

        shouldDimmed = tui.util.bind(this._shouldDimmed, this, seriesDataModel, hoverSeriesItem);
        html = labelHelper.makeLabelsHtmlForTreemap(seriesItems, boundMap, this.theme.label, shouldDimmed);

        labelContainer.innerHTML = html;
    },

    /**
     * Resize.
     * @override
     */
    resize: function() {
        this.boundMap = null;
        Series.prototype.resize.apply(this, arguments);
    },

    /**
     * Zoom.
     * @param {string | number} rootId - root id
     * @param {number} startDepth - start depth
     * @param {number} group - group
     * @private
     */
    _zoom: function(rootId, startDepth, group) {
        this._clearContainer();
        this.boundMap = null;
        this.rootId = rootId;
        this.startDepth = startDepth;
        this.selectedGroup = group;
        this._renderSeriesArea(this.seriesContainer, this.data, tui.util.bind(this._renderGraph, this));

        if (predicate.isShowLabel(this.options)) {
            this._showSeriesLabelWithoutAnimation();
        }
    },

    /**
     * Zoom
     * @param {{index: number}} data - data for zoom
     */
    zoom: function(data) {
        var detectedIndex = data.index;
        var seriesDataModel, seriesItem;

        if (detectedIndex === -1) {
            this._zoom(chartConst.TREEMAP_ROOT_ID, 1, null);

            return;
        }

        seriesDataModel = this._getSeriesDataModel();
        seriesItem = seriesDataModel.getSeriesItem(0, detectedIndex, true);

        if (!seriesItem || !seriesItem.hasChild) {
            return;
        }

        this._zoom(seriesItem.id, seriesItem.depth + 1, seriesItem.group);
        this.fire('afterZoom', detectedIndex);
    },

    /**
     * To call showAnimation function of graphRenderer.
     * @param {{groupIndex: number, index: number}} indexes - indexes
     */
    onShowAnimation: function(indexes) {
        var seriesItem;

        if (!predicate.isShowLabel(this.options)) {
            return;
        }

        seriesItem = this._getSeriesDataModel().getSeriesItem(indexes.groupIndex, indexes.index, true);

        this._renderSeriesLabel(this.seriesLabelContainer, seriesItem);
        this.graphRenderer.showAnimation(indexes, this.options.useColorValue, 0.6);
    },

    /**
     * To call hideAnimation function of graphRenderer.
     * @param {{groupIndex: number, index: number}} indexes - indexes
     */
    onHideAnimation: function(indexes) {
        if (!predicate.isShowLabel(this.options) || !indexes) {
            return;
        }

        this._renderSeriesLabel(this.seriesLabelContainer);
        this.graphRenderer.hideAnimation(indexes, this.options.useColorValue);
    },

    /**
     * On show tooltip for calling showWedge.
     * @param {{indexes: {groupIndex: number, index: number}}} params - parameters
     */
    onShowTooltip: function(params) {
        var seriesDataModel = this._getSeriesDataModel();
        var indexes = params.indexes;
        var ratio = seriesDataModel.getSeriesItem(indexes.groupIndex, indexes.index, true).ratio;

        if (ratio > -1) {
            this.fire('showWedge', ratio);
        }
    }
});

tui.util.CustomEvents.mixin(TreemapChartSeries);

module.exports = TreemapChartSeries;

},{"../const":31,"../helpers/predicate":61,"./renderingLabelHelper":100,"./series":102,"./squarifier":104}],106:[function(require,module,exports){
/**
 * @fileoverview Zoom component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var seriesTemplate = require('./seriesTemplate'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    eventListener = require('../helpers/eventListener');

var Zoom = tui.util.defineClass(/** @lends Zoom.prototype */{
    /**
     * Zoom component.
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     * @constructs Zoom
     */
    init: function(params) {
        this.className = 'tui-chart-zoom-area';

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Magnification.
         * @type {number}
         */
        this.magn = 1;

        /**
         * Stacked wheelDelta.
         * @type {number}
         */
        this.stackedWheelDelta = 0;
    },

    /**
     * Render.
     * @returns {HTMLElement} zoom container
     */
    render: function() {
        var container = dom.create('DIV', this.className);

        container.innerHTML += seriesTemplate.ZOOM_BUTTONS;
        renderUtil.renderPosition(container, this.boundsMaker.getPosition('series'));
        this._attachEvent(container);

        return container;
    },

    /**
     * Find button element.
     * @param {HTMLElement} target target element.
     * @returns {?HTMLElement} button element
     * @private
     */
    _findBtnElement: function(target) {
        var btnClassName = 'tui-chart-zoom-btn',
            btnElement = target;

        if (!dom.hasClass(target, btnClassName)) {
            btnElement = dom.findParentByClass(target, btnClassName);
        }

        return btnElement;
    },

    /**
     * Zoom
     * @param {number} magn magnification
     * @param {?{left: number, top: number}} position mouse position
     * @private
     */
    _zoom: function(magn, position) {
        var changedMagn = Math.min(Math.max(1, this.magn * magn), chartConst.MAX_ZOOM_MAGN);

        if (changedMagn !== this.magn) {
            this.magn = changedMagn;
            this.fire('zoom', this.magn, position);
        }
    },

    /**
     * On click.
     * @param {MouseEvent} e mouse event
     * @returns {?boolean} prevent default for ie
     * @private
     */
    _onClick: function(e) {
        var target = e.target || e.srcElement,
            btnElement = this._findBtnElement(target),
            magn;

        if (btnElement) {
            magn = parseFloat(btnElement.getAttribute('data-magn'));
            this._zoom(magn);
        }

        if (e.preventDefault) {
            e.preventDefault();
        }

        return false;
    },

    /**
     * Attach event.
     * @param {HTMLElement} target target element
     * @private
     */
    _attachEvent: function(target) {
        eventListener.on(target, 'click', this._onClick, this);
    },

    /**
     * Calculate magnification from wheelDelta.
     * @param {number} wheelDelta wheelDelta
     * @returns {number} magnification
     * @private
     */
    _calculateMagn: function(wheelDelta) {
        var tick = parseInt(wheelDelta / chartConst.WHEEL_TICK, 10),
            magn;

        if (tick > 0) {
            magn = Math.pow(2, tick);
        } else {
            magn = Math.pow(0.5, Math.abs(tick));
        }

        return magn;
    },

    /**
     * On wheel.
     * @param {number} wheelDelta wheelDelta
     * @param {{left: number, top: number}} position mouse position
     */
    onWheel: function(wheelDelta, position) {
        var magn;

        if (Math.abs(wheelDelta) < chartConst.WHEEL_TICK) {
            this.stackedWheelDelta += wheelDelta;
        } else {
            this.stackedWheelDelta = wheelDelta;
        }

        if (Math.abs(this.stackedWheelDelta) < chartConst.WHEEL_TICK) {
            return;
        }

        magn = this._calculateMagn(this.stackedWheelDelta);

        this._zoom(magn, position);

        this.stackedWheelDelta = this.stackedWheelDelta % chartConst.WHEEL_TICK;
    }
});

tui.util.CustomEvents.mixin(Zoom);

module.exports = Zoom;

},{"../const":31,"../helpers/domHandler":59,"../helpers/eventListener":60,"../helpers/renderUtil":63,"./seriesTemplate":103}],107:[function(require,module,exports){
'use strict';

var DEFAULT_COLOR = '#000000',
    DEFAULT_BACKGROUND = '#ffffff',
    EMPTY = '',
    DEFAULT_AXIS = {
        tickColor: DEFAULT_COLOR,
        title: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        },
        label: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        }
    };

var defaultTheme = {
    chart: {
        background: DEFAULT_BACKGROUND,
        fontFamily: 'Verdana'
    },
    title: {
        fontSize: 18,
        fontFamily: EMPTY,
        color: DEFAULT_COLOR
    },
    yAxis: DEFAULT_AXIS,
    xAxis: DEFAULT_AXIS,
    plot: {
        lineColor: '#dddddd',
        background: '#ffffff'
    },
    series: {
        label: {
            fontSize: 11,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        },
        colors: ['#ac4142', '#d28445', '#f4bf75', '#90a959', '#75b5aa', '#6a9fb5', '#aa759f', '#8f5536'],
        singleColors: [],
        borderColor: EMPTY,
        selectionColor: EMPTY,
        startColor: '#F4F4F4',
        endColor: '#345391',
        overColor: '#F0C952'
    },
    legend: {
        label: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        }
    },
    tooltip: {}
};

module.exports = defaultTheme;

},{}],108:[function(require,module,exports){
/**
 * @fileoverview Group tooltip component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var TooltipBase = require('./tooltipBase'),
    GroupTooltipPositionModel = require('./groupTooltipPositionModel'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    defaultTheme = require('../themes/defaultTheme'),
    tooltipTemplate = require('./tooltipTemplate');

/**
 * @classdesc GroupTooltip component.
 * @class GroupTooltip
 */
var GroupTooltip = tui.util.defineClass(TooltipBase, /** @lends GroupTooltip.prototype */ {
    /**
     * Group tooltip component.
     * @constructs GroupTooltip
     * @override
     */
    init: function() {
        this.prevIndex = null;
        TooltipBase.apply(this, arguments);
    },

    /**
     * Make tooltip html.
     * @param {string} category category
     * @param {Array.<{value: string, legend: string, chartType: string, suffix: ?string}>} items items data
     * @returns {string} tooltip html
     * @private
     */
    _makeTooltipHtml: function(category, items) {
        var template = tooltipTemplate.tplGroupItem,
            cssTextTemplate = tooltipTemplate.tplGroupCssText,
            colors = this._makeColors(this.theme),
            itemsHtml = tui.util.map(items, function(item, index) {
                return template(tui.util.extend({
                    cssText: cssTextTemplate({color: colors[index]})
                }, item));
            }).join('');

        return tooltipTemplate.tplGroup({
            category: category,
            items: itemsHtml
        });
    },

    /**
     * Set default align option of tooltip.
     * @private
     * @override
     */
    _setDefaultTooltipPositionOption: function() {
        if (this.options.align) {
            return;
        }

        if (this.isVertical) {
            this.options.align = chartConst.TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION;
        } else {
            this.options.align = chartConst.TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION;
        }
    },

    /**
     * Render tooltip component.
     * @returns {HTMLElement} tooltip element
     * @override
     */
    render: function() {
        var el = TooltipBase.prototype.render.call(this),
            chartDimension = this.boundsMaker.getDimension('chart'),
            bound = this.boundsMaker.getBound('tooltip');

        this.positionModel = new GroupTooltipPositionModel(chartDimension, bound, this.isVertical, this.options);

        return el;
    },

    /**
     * Rerender.
     * @param {{checkedLegends: Array.<boolean>}} data rendering data
     * @override
     */
    rerender: function(data) {
        TooltipBase.prototype.rerender.call(this, data);
        this.prevIndex = null;

        if (data.checkedLegends) {
            this.theme = this._updateLegendTheme(data.checkedLegends);
        }
    },

    /**
     * Zoom.
     */
    zoom: function() {
        this.prevIndex = null;
        TooltipBase.prototype.zoom.call(this);
    },

    /**
     * Update legend theme.
     * @param {object | Array.<boolean>}checkedLegends checked legends
     * @returns {{colors: Array.<string>}} legend theme
     * @private
     */
    _updateLegendTheme: function(checkedLegends) {
        var colors = [];

        tui.util.forEachArray(this.dataProcessor.getOriginalLegendData(), function(item) {
            var _checkedLegends = checkedLegends[item.chartType] || checkedLegends;
            if (_checkedLegends[item.index]) {
                colors.push(item.theme.color);
            }
        });

        return {
            colors: colors
        };
    },

    /**
     * Make tooltip data.
     * @returns {Array.<object>} tooltip data
     * @override
     */
    _makeTooltipData: function() {
        var self = this;

        return tui.util.map(this.dataProcessor.getSeriesGroups(), function(seriesGroup, index) {
            return {
                category: self.dataProcessor.getCategory(index),
                values: seriesGroup.pluck('label')
            };
        });
    },

    /**
     * Make colors.
     * @param {object} theme tooltip theme
     * @returns {Array.<string>} colors
     * @private
     */
    _makeColors: function(theme) {
        var colorIndex = 0,
            legendLabels = this.dataProcessor.getLegendData(),
            defaultColors, colors, prevChartType;

        if (theme.colors) {
            return theme.colors;
        }

        defaultColors = defaultTheme.series.colors.slice(0, legendLabels.length);

        return tui.util.map(tui.util.pluck(legendLabels, 'chartType'), function(chartType) {
            var color;

            if (prevChartType !== chartType) {
                colors = theme[chartType] ? theme[chartType].colors : defaultColors;
                colorIndex = 0;
            }

            prevChartType = chartType;
            color = colors[colorIndex];
            colorIndex += 1;

            return color;
        });
    },

    /**
     * Make rendering data about legend item.
     * @param {Array.<string>} values values
     * @returns {Array.<{value: string, legend: string, chartType: string, suffix: ?string}>} legend item data.
     * @private
     */
    _makeItemRenderingData: function(values) {
        var dataProcessor = this.dataProcessor,
            suffix = this.suffix;

        return tui.util.map(values, function(value, index) {
            var legendLabel = dataProcessor.getLegendItem(index);

            return {
                value: value,
                legend: legendLabel.label,
                chartType: legendLabel.chartType,
                suffix: suffix
            };
        });
    },

    /**
     * Make tooltip.
     * @param {number} groupIndex group index
     * @returns {string} tooltip html
     * @private
     */
    _makeGroupTooltipHtml: function(groupIndex) {
        var data = this.data[groupIndex],
            items = this._makeItemRenderingData(data.values);

        return this.templateFunc(data.category, items);
    },

    /**
     * Get tooltip sector element.
     * @returns {HTMLElement} sector element
     * @private
     */
    _getTooltipSectorElement: function() {
        var groupTooltipSector;

        if (!this.groupTooltipSector) {
            this.groupTooltipSector = groupTooltipSector = dom.create('DIV', 'tui-chart-group-tooltip-sector');
            dom.append(this.tooltipContainer, groupTooltipSector);
        }

        return this.groupTooltipSector;
    },

    /**
     * Make bound about tooltip sector of vertical type chart.
     * @param {number} height height
     * @param {{start: number, end: number}} range range
     * @param {boolean} isLine whether line or not
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeVerticalTooltipSectorBound: function(height, range, isLine) {
        var width;

        if (isLine) {
            width = 1;
            height += 6;
        } else {
            width = range.end - range.start;
        }

        return {
            dimension: {
                width: width,
                height: height
            },
            position: {
                left: range.start + chartConst.SERIES_EXPAND_SIZE,
                top: chartConst.SERIES_EXPAND_SIZE
            }
        };
    },

    /**
     * Make bound about tooltip sector of horizontal type chart.
     * @param {number} width width
     * @param {{start: number, end:number}} range range
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeHorizontalTooltipSectorBound: function(width, range) {
        return {
            dimension: {
                width: width,
                height: range.end - range.start
            },
            position: {
                left: chartConst.SERIES_EXPAND_SIZE,
                top: range.start + chartConst.SERIES_EXPAND_SIZE
            }
        };
    },

    /**
     * Make bound about tooltip sector.
     * @param {number} size width or height
     * @param {{start: number, end:number}} range range
     * @param {boolean} isVertical whether vertical or not
     * @param {boolean} isLine whether line type or not
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeTooltipSectorBound: function(size, range, isVertical, isLine) {
        var bound;

        if (isVertical) {
            bound = this._makeVerticalTooltipSectorBound(size, range, isLine);
        } else {
            bound = this._makeHorizontalTooltipSectorBound(size, range);
        }

        return bound;
    },

    /**
     * Show tooltip sector.
     * @param {number} size width or height
     * @param {{start: number, end:number}} range range
     * @param {boolean} isVertical whether vertical or not
     * @param {number} index index
     * @param {boolean} [isMoving] whether moving or not
     * @private
     */
    _showTooltipSector: function(size, range, isVertical, index, isMoving) {
        var groupTooltipSector = this._getTooltipSectorElement(),
            isLine = (range.start === range.end),
            bound = this._makeTooltipSectorBound(size, range, isVertical, isLine);

        if (isLine) {
            this.fire('showGroupTooltipLine', bound);
        } else {
            renderUtil.renderDimension(groupTooltipSector, bound.dimension);
            renderUtil.renderPosition(groupTooltipSector, bound.position);
            dom.addClass(groupTooltipSector, 'show');
        }

        if (isMoving) {
            index -= 1;
        }

        this.fire('showGroupAnimation', index);
    },

    /**
     * Hide tooltip sector.
     * @param {number} index index
     * @private
     */
    _hideTooltipSector: function(index) {
        var groupTooltipSector = this._getTooltipSectorElement();

        dom.removeClass(groupTooltipSector, 'show');
        this.fire('hideGroupAnimation', index);
        this.fire('hideGroupTooltipLine');
    },

    /**
     * Show tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{index: number, range: {start: number, end: number},
     *          size: number, direction: string, isVertical: boolean
     *        }} params coordinate event parameters
     * @param {{left: number, top: number}} prevPosition prev position
     * @private
     */
    _showTooltip: function(elTooltip, params, prevPosition) {
        var dimension, position;

        if (!tui.util.isNull(this.prevIndex)) {
            this.fire('hideGroupAnimation', this.prevIndex);
        }

        elTooltip.innerHTML = this._makeGroupTooltipHtml(params.index);

        this._fireBeforeShowTooltip(params.index, params.range);

        dom.addClass(elTooltip, 'show');

        this._showTooltipSector(params.size, params.range, params.isVertical, params.index, params.isMoving);

        dimension = this.getTooltipDimension(elTooltip);
        position = this.positionModel.calculatePosition(dimension, params.range);

        this._moveToPosition(elTooltip, position, prevPosition);

        this._fireAfterShowTooltip(params.index, params.range, {
            element: elTooltip,
            position: position
        });

        this.prevIndex = params.index;
    },

    /**
     * To call beforeShowTooltip callback of userEvent.
     * @param {number} index index
     * @param {{start: number, end: number}} range range
     * @private
     */
    _fireBeforeShowTooltip: function(index, range) {
        this.userEvent.fire('beforeShowTooltip', {
            index: index,
            range: range
        });
    },

    /**
     * To call afterShowTooltip callback of userEvent.
     * @param {number} index index
     * @param {{start: number, end: number}} range range
     * @param {object} additionParams addition parameters
     * @private
     */
    _fireAfterShowTooltip: function(index, range, additionParams) {
        this.userEvent.fire('afterShowTooltip', tui.util.extend({
            index: index,
            range: range
        }, additionParams));
    },

    /**
     * Hide tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {number} index index
     * @private
     */
    _hideTooltip: function(elTooltip, index) {
        this.prevIndex = null;
        this._hideTooltipSector(index);
        dom.removeClass(elTooltip, 'show');
        elTooltip.style.cssText = '';
    }
});

module.exports = GroupTooltip;

},{"../const":31,"../helpers/domHandler":59,"../helpers/renderUtil":63,"../themes/defaultTheme":107,"./groupTooltipPositionModel":109,"./tooltipBase":113,"./tooltipTemplate":114}],109:[function(require,module,exports){
/**
 * @fileoverview GroupTooltipPositionModel is position model for group tooltip..
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

var GroupTooltipPositionModel = tui.util.defineClass(/** @lends GroupTooltipPositionModel.prototype */ {
    /**
     * GroupTooltipPositionModel is position model for group tooltip.
     * @constructs GroupTooltipPositionModel
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {boolean} isVertical whether vertical or not
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     */
    init: function(chartDimension, areaBound, isVertical, options) {
        /**
         * chart dimension
         * @type {{width: number, height: number}}
         */
        this.chartDimension = chartDimension;

        /**
         * tooltip area bound
         * @type {{dimension: {width: number, height: number}, position: {left: number, top: number}}}
         */
        this.areaBound = areaBound;

        /**
         * Whether vertical or not
         * @type {boolean}
         */
        this.isVertical = isVertical;

        /**
         * tooltip options
         * @type {{align: ?string, position: {left: number, top: number}}}
         */
        this.options = options;

        /**
         * For caching
         * @type {object}
         */
        this.positions = {};

        this._setData(chartDimension, areaBound, isVertical, options);
    },

    /**
     * Get horizontal direction.
     * @param {?string} alignOption align option
     * @returns {string} direction
     * @private
     */
    _getHorizontalDirection: function(alignOption) {
        var direction;

        alignOption = alignOption || '';
        if (alignOption.indexOf('left') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_BACKWARD;
        } else if (alignOption.indexOf('center') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_CENTER;
        } else {
            direction = chartConst.TOOLTIP_DIRECTION_FORWARD;
        }

        return direction;
    },

    /**
     * Make vertical data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {?string} alignOption align option
     * @returns {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} vertical data
     * @private
     */
    _makeVerticalData: function(chartDimension, areaBound, alignOption) {
        var hDirection = this._getHorizontalDirection(alignOption);

        return {
            positionType: 'left',
            sizeType: 'width',
            direction: hDirection,
            areaPosition: areaBound.position.left,
            areaSize: areaBound.dimension.width,
            chartSize: chartDimension.width,
            basePosition: chartConst.SERIES_EXPAND_SIZE
        };
    },

    /**
     * Get vertical direction.
     * @param {?string} alignOption align option
     * @returns {string} direction
     * @private
     */
    _getVerticalDirection: function(alignOption) {
        var direction;

        alignOption = alignOption || '';

        if (alignOption.indexOf('top') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_BACKWARD;
        } else if (alignOption.indexOf('bottom') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_FORWARD;
        } else {
            direction = chartConst.TOOLTIP_DIRECTION_CENTER;
        }

        return direction;
    },

    /**
     * Make horizontal data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {?string} alignOption align option
     * @returns {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} horizontal data
     * @private
     */
    _makeHorizontalData: function(chartDimension, areaBound, alignOption) {
        var vDirection = this._getVerticalDirection(alignOption);

        return {
            positionType: 'top',
            sizeType: 'height',
            direction: vDirection,
            areaPosition: areaBound.position.top,
            areaSize: areaBound.dimension.height,
            chartSize: chartDimension.height,
            basePosition: chartConst.SERIES_EXPAND_SIZE
        };
    },

    /**
     * Set data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {boolean} isVertical whether vertical or not
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     * @private
     */
    _setData: function(chartDimension, areaBound, isVertical, options) {
        var verticalData = this._makeVerticalData(chartDimension, areaBound, options.align),
            horizontalData = this._makeHorizontalData(chartDimension, areaBound, options.align);

        if (isVertical) {
            this.mainData = verticalData;
            this.subData = horizontalData;
        } else {
            this.mainData = horizontalData;
            this.subData = verticalData;
        }

        this.positionOption = tui.util.extend({
            left: 0,
            top: 0
        }, options.position);

        this.positions = {};
    },

    /**
     * Calculate main position value.
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {{start: number, end: number}} range range
     * @param {object} data data
     *      @param {string} data.direction direction
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _calculateMainPositionValue: function(tooltipSize, range, data) {
        var isLine = (range.start === range.end),
            lineTypePadding = 9,
            otherTypePadding = 5,
            padding = isLine ? lineTypePadding : otherTypePadding,
            value = data.basePosition;

        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value += range.end + padding;
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value += range.start - tooltipSize - padding;
        } else if (isLine) {
            value += range.start - tooltipSize / 2;
        } else {
            value += range.start + ((range.end - range.start - tooltipSize) / 2);
        }

        return value;
    },

    /**
     * Calculate sub position value.
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.areaSize tooltip area size (width or height)
     *      @param {string} data.direction direction
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _calculateSubPositionValue: function(tooltipSize, data) {
        var middle = data.areaSize / 2,
            value;

        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = middle + data.basePosition;
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value = middle - tooltipSize + data.basePosition;
        } else {
            value = middle - (tooltipSize / 2) + data.basePosition;
        }

        return value;
    },

    /**
     * Make position value diff.
     * @param {number} value positoin value
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     * @returns {number} diff
     * @private
     */
    _makePositionValueDiff: function(value, tooltipSize, data) {
        return value + data.areaPosition + tooltipSize - data.chartSize;
    },

    /**
     * Adjust backward position value.
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustBackwardPositionValue: function(value, range, tooltipSize, data) {
        var changedValue;

        if (value < -data.areaPosition) {
            changedValue = this._calculateMainPositionValue(tooltipSize, range, {
                direction: chartConst.TOOLTIP_DIRECTION_FORWARD,
                basePosition: data.basePosition
            });
            if (this._makePositionValueDiff(changedValue, tooltipSize, data) > 0) {
                value = -data.areaPosition;
            } else {
                value = changedValue;
            }
        }

        return value;
    },

    /**
     * Adjust forward position value.
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustForwardPositionValue: function(value, range, tooltipSize, data) {
        var diff = this._makePositionValueDiff(value, tooltipSize, data),
            changedValue;

        if (diff > 0) {
            changedValue = this._calculateMainPositionValue(tooltipSize, range, {
                direction: chartConst.TOOLTIP_DIRECTION_BACKWARD,
                basePosition: data.basePosition
            });
            if (changedValue < -data.areaPosition) {
                value -= diff;
            } else {
                value = changedValue;
            }
        }

        return value;
    },

    /**
     * Adjust main position value
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     * @returns {number} position value
     * @private
     */
    _adjustMainPositionValue: function(value, range, tooltipSize, data) {
        if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value = this._adjustBackwardPositionValue(value, range, tooltipSize, data);
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = this._adjustForwardPositionValue(value, range, tooltipSize, data);
        } else {
            value = Math.max(value, -data.areaPosition);
            value = Math.min(value, data.chartSize - data.areaPosition - tooltipSize);
        }

        return value;
    },

    /**
     * Adjust sub position value.
     * @param {number} value position value
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustSubPositionValue: function(value, tooltipSize, data) {
        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = Math.min(value, data.chartSize - data.areaPosition - tooltipSize);
        } else {
            value = Math.max(value, -data.areaPosition);
        }

        return value;
    },

    /**
     * Make caching key.
     * @param {{start: number, end: number}} range range
     * @returns {string} key
     * @private
     */
    _makeCachingKey: function(range) {
        return range.start + '-' + range.end;
    },

    /**
     * Add position option.
     * @param {number} position position
     * @param {string} positionType position type (left or top)
     * @returns {number} position
     * @private
     */
    _addPositionOptionValue: function(position, positionType) {
        return position + this.positionOption[positionType];
    },

    /**
     * Make main position value.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{start: number, end: number}} range tooltip sector range
     * @param {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} main main data
     * @returns {number} position value
     * @private
     */
    _makeMainPositionValue: function(tooltipDimension, range, main) {
        var value;

        value = this._calculateMainPositionValue(tooltipDimension[main.sizeType], range, main);
        value = this._addPositionOptionValue(value, main.positionType);
        value = this._adjustMainPositionValue(value, range, tooltipDimension[main.sizeType], main);

        return value;
    },

    /**
     * Make sub position value.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} sub sub data
     * @returns {number} position value
     * @private
     */
    _makeSubPositionValue: function(tooltipDimension, sub) {
        var value;

        value = this._calculateSubPositionValue(tooltipDimension[sub.sizeType], sub);
        value = this._addPositionOptionValue(value, sub.positionType);
        value = this._adjustSubPositionValue(value, tooltipDimension[sub.sizeType], sub);

        return value;
    },

    /**
     * Calculate group tooltip position.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{start: number, end: number}} range tooltip sector range
     * @returns {{left: number, top: number}} group tooltip position
     */
    calculatePosition: function(tooltipDimension, range) {
        var key = this._makeCachingKey(range),
            main = this.mainData,
            sub = this.subData,
            position = this.positions[key];

        if (!position) {
            position = {};
            position[main.positionType] = this._makeMainPositionValue(tooltipDimension, range, main);
            position[sub.positionType] = this._makeSubPositionValue(tooltipDimension, sub);
            this.positions[key] = position;
        }

        return position;
    },

    /**
     * Update tooltip options for position calculation.
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     */
    updateOptions: function(options) {
        this.options = options;
        this._setData(this.chartDimension, this.areaBound, this.isVertical, options);
    },

    /**
     * Update tooltip bound for position calculation.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound tooltip area bound
     */
    updateBound: function(bound) {
        this.areaBound = bound;
        this._setData(this.chartDimension, bound, this.isVertical, this.options);
    }
});

module.exports = GroupTooltipPositionModel;

},{"../const":31}],110:[function(require,module,exports){
/**
 * @fileoverview Tooltip component for map chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    TooltipBase = require('./tooltipBase'),
    singleTooltipMixer = require('./singleTooltipMixer'),
    tooltipTemplate = require('./tooltipTemplate');

/**
 * @classdesc MapChartTooltip component.
 * @class MapChartTooltip
 */
var MapChartTooltip = tui.util.defineClass(TooltipBase, /** @lends MapChartTooltip.prototype */ {
    /**
     * Map chart tooltip component.
     * @constructs MapChartTooltip
     * @override
     */
    init: function() {
        /**
         * Map model
         * @type {MapChartMapModel}
         */
        this.mapModel = null;

        TooltipBase.apply(this, arguments);
    },

    /**
     * Make tooltip html.
     * @param {{name: string, value: number}} datum tooltip datum
     * @returns {string} tooltip html
     * @private
     */
    _makeTooltipHtml: function(datum) {
        return tooltipTemplate.tplMapChartDefault(datum);
    },

    /**
     * Make single tooltip html.
     * @param {string} chartType chart type
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @returns {string} tooltip html
     * @private
     */
    _makeSingleTooltipHtml: function(chartType, indexes) {
        var datum = this.mapModel.getDatum(indexes.index),
            suffix = this.options.suffix ? ' ' + this.options.suffix : '';

        return this.templateFunc({
            name: datum.name || datum.code,
            value: datum.label,
            suffix: suffix
        });
    },

    /**
     * Make parameters for show tooltip user event.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {object} additionParams addition parameters
     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} parameters for show tooltip
     * @private
     */
    _makeShowTooltipParams: function(indexes, additionParams) {
        var datum = this.mapModel.getDatum(indexes.index),
            params;

        params = tui.util.extend({
            chartType: this.chartType,
            code: datum.code,
            name: datum.name,
            value: datum.label,
            index: indexes.index
        }, additionParams);

        return params;
    },


    /**
     * Set default align option of tooltip.
     * @private
     * @override
     */
    _setDefaultTooltipPositionOption: function() {
        if (!this.options.align) {
            this.options.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        }
    },

    /**
     * Render.
     * @param {{mapModel: MapChartMapModel}} data data for rendering
     * @returns {HTMLElement} tooltip element
     */
    render: function(data) {
        this.mapModel = data.mapModel;

        return TooltipBase.prototype.render.call(this);
    }
});

singleTooltipMixer.mixin(MapChartTooltip);
module.exports = MapChartTooltip;

},{"../const":31,"./singleTooltipMixer":111,"./tooltipBase":113,"./tooltipTemplate":114}],111:[function(require,module,exports){
/**
 * @fileoverview singleTooltipMixer is single tooltip mixer of map chart.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

/**
 * singleTooltipMixer is single tooltip mixer of map chart.
 * @mixin
 */
var singleTooltipMixer = {

    /**
     * Fire custom event showAnimation.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} chartType chart type
     * @private
     */
    _fireShowAnimation: function(indexes, chartType) {
        var eventName = renderUtil.makeCustomEventName('show', chartType, 'animation');

        this.fire(eventName, indexes);
    },

    /**
     * Fire custom event hideAnimation.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} chartType chart type
     * @private
     */
    _fireHideAnimation: function(indexes, chartType) {
        var eventName = renderUtil.makeCustomEventName('hide', chartType, 'animation');

        this.fire(eventName, indexes);
    },

    /**
     * Set data indexes.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{groupIndex: number, index:number}} indexes indexes
     * @private
     */
    _setIndexesCustomAttribute: function(elTooltip, indexes) {
        elTooltip.setAttribute('data-groupIndex', indexes.groupIndex);
        elTooltip.setAttribute('data-index', indexes.index);
    },

    /**
     * Get data indexes
     * @param {HTMLElement} elTooltip tooltip element
     * @returns {{groupIndex: number, index: number}} indexes
     * @private
     */
    _getIndexesCustomAttribute: function(elTooltip) {
        var groupIndex = elTooltip.getAttribute('data-groupIndex');
        var index = elTooltip.getAttribute('data-index');
        var indexes = null;

        if (!tui.util.isNull(groupIndex) && !tui.util.isNull(index)) {
            indexes = {
                groupIndex: parseInt(groupIndex, 10),
                index: parseInt(index, 10)
            };
        }

        return indexes;
    },

    /**
     * Set showed custom attribute.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {boolean} status whether showed or not
     * @private
     */
    _setShowedCustomAttribute: function(elTooltip, status) {
        elTooltip.setAttribute('data-showed', status);
    },

    /**
     * Whether showed tooltip or not.
     * @param {HTMLElement} elTooltip tooltip element
     * @returns {boolean} whether showed tooltip or not
     * @private
     */
    _isShowedTooltip: function(elTooltip) {
        var isShowed = elTooltip.getAttribute('data-showed');

        return isShowed === 'true' || isShowed === true; // ie7에서는 boolean형태의 true를 반환함
    },

    /**
     * Make left position of not bar chart.
     * @param {number} baseLeft base left
     * @param {string} alignOption align option
     * @param {number} minusWidth minus width
     * @param {number} lineGap line gap
     * @returns {number} left position value
     * @private
     */
    _makeLeftPositionOfNotBarChart: function(baseLeft, alignOption, minusWidth, lineGap) {
        var left = baseLeft;

        if (alignOption.indexOf('left') > -1) {
            left -= minusWidth + lineGap;
        } else if (alignOption.indexOf('center') > -1) {
            left -= minusWidth / 2;
        } else {
            left += lineGap;
        }

        return left;
    },

    /**
     * Make top position of not bar chart.
     * @param {number} baseTop base top
     * @param {string} alignOption align option
     * @param {number} tooltipHeight tooltip height
     * @param {number} lineGap line gap
     * @returns {number} top position value
     * @private
     */
    _makeTopPositionOfNotBarChart: function(baseTop, alignOption, tooltipHeight, lineGap) {
        var top = baseTop;

        if (alignOption.indexOf('bottom') > -1) {
            top += tooltipHeight + lineGap;
        } else if (alignOption.indexOf('middle') > -1) {
            top += tooltipHeight / 2;
        } else {
            top -= chartConst.TOOLTIP_GAP;
        }

        return top;
    },

    /**
     * Make tooltip position for not bar chart.
     * @param {object} params parameters
     *      @param {{bound: object}} params.data graph information
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _makeTooltipPositionForNotBarChart: function(params) {
        var bound = params.bound,
            positionOption = params.positionOption,
            minusWidth = params.dimension.width - (bound.width || 0),
            lineGap = bound.width ? 0 : chartConst.TOOLTIP_GAP,
            alignOption = params.alignOption || '',
            tooltipHeight = params.dimension.height,
            baseLeft = bound.left + positionOption.left,
            baseTop = bound.top - tooltipHeight + positionOption.top;

        return {
            left: this._makeLeftPositionOfNotBarChart(baseLeft, alignOption, minusWidth, lineGap),
            top: this._makeTopPositionOfNotBarChart(baseTop, alignOption, tooltipHeight, lineGap)
        };
    },

    /**
     * Make tooltip position to event position.
     * @param {object} params parameters
     *      @param {{left: number, top: number}} params.bound bound
     *      @param {{left: number, top: number}} params.mousePosition mouse position
     * @returns {{top: number, left: number}} position
     * @private
     */
    _makeTooltipPositionToMousePosition: function(params) {
        params.bound = params.bound || {};
        tui.util.extend(params.bound, params.mousePosition);

        return this._makeTooltipPositionForNotBarChart(params);
    },

    /**
     * Make left position for bar chart.
     * @param {number} baseLeft base left
     * @param {string} alignOption align option
     * @param {number} tooltipWidth tooltip width
     * @returns {number} left position value
     * @private
     */
    _makeLeftPositionForBarChart: function(baseLeft, alignOption, tooltipWidth) {
        var left = baseLeft;

        if (alignOption.indexOf('left') > -1) {
            left -= tooltipWidth;
        } else if (alignOption.indexOf('center') > -1) {
            left -= tooltipWidth / 2;
        } else {
            left += chartConst.TOOLTIP_GAP;
        }

        return left;
    },

    /**
     * Make top position for bar chart.
     * @param {number} baseTop base top
     * @param {string} alignOption align option
     * @param {number} minusHeight minus width
     * @returns {number} top position value
     * @private
     */
    _makeTopPositionForBarChart: function(baseTop, alignOption, minusHeight) {
        var top = baseTop;

        if (alignOption.indexOf('top') > -1) {
            top -= minusHeight;
        } else if (alignOption.indexOf('middle') > -1) {
            top -= minusHeight / 2;
        }

        return top;
    },

    /**
     * Make tooltip position for bar chart.
     * @param {object} params parameters
     *      @param {{bound: object}} params.data graph information
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _makeTooltipPositionForBarChart: function(params) {
        var bound = params.bound,
            positionOption = params.positionOption,
            minusHeight = params.dimension.height - (bound.height || 0),
            alignOption = params.alignOption || '',
            tooltipWidth = params.dimension.width,
            baseLeft = bound.left + bound.width + positionOption.left,
            baseTop = bound.top + positionOption.top;

        return {
            left: this._makeLeftPositionForBarChart(baseLeft, alignOption, tooltipWidth),
            top: this._makeTopPositionForBarChart(baseTop, alignOption, minusHeight)
        };
    },

    /**
     * Make tooltip position for treemap chart.
     * @param {object} params parameters
     *      @param {{bound: object}} params.data - graph information
     *      @param {{width: number, height: number}} params.dimension - tooltip dimension
     * @returns {{left: number, top: number}}
     * @private
     */
    _makeTooltipPositionForTreemapChart: function(params) {
        var bound = params.bound;
        var positionOption = params.positionOption;
        var labelHeight = renderUtil.getRenderedLabelHeight(chartConst.MAX_HEIGHT_WORLD, this.labelTheme);

        return {
            left: bound.left + ((bound.width - params.dimension.width) / 2) + positionOption.left,
            top: bound.top + ((bound.height - labelHeight) / 2) - params.dimension.height + positionOption.top
        };
    },

    /**
     * Adjust position.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{left: number, top: number}} position position
     * @returns {{left: number, top: number}} adjusted position
     * @private
     */
    _adjustPosition: function(tooltipDimension, position) {
        var chartDimension = this.boundsMaker.getDimension('chart'),
            areaPosition = this.boundsMaker.getPosition('tooltip');

        position.left = Math.max(position.left, -areaPosition.left);
        position.left = Math.min(position.left, chartDimension.width - areaPosition.left - tooltipDimension.width);
        position.top = Math.max(position.top, -areaPosition.top);
        position.top = Math.min(position.top, chartDimension.height - areaPosition.top - tooltipDimension.height);

        return position;
    },

    /**
     * Make tooltip position.
     * @param {object} params parameters
     *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
     *      @param {string} params.chartType chart type
     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _makeTooltipPosition: function(params) {
        var position = {},
            sizeType, positionType, addPadding;

        if (params.mousePosition) {
            position = this._makeTooltipPositionToMousePosition(params);
        } else {
            if (predicate.isBarChart(params.chartType)) {
                position = this._makeTooltipPositionForBarChart(params);
                sizeType = 'width';
                positionType = 'left';
                addPadding = 1;
            } else if (predicate.isTreemapChart(params.chartType)) {
                position = this._makeTooltipPositionForTreemapChart(params);
            } else {
                position = this._makeTooltipPositionForNotBarChart(params);
                sizeType = 'height';
                positionType = 'top';
                addPadding = -1;
            }

            if (params.allowNegativeTooltip) {
                position = this._moveToSymmetry(position, {
                    bound: params.bound,
                    indexes: params.indexes,
                    dimension: params.dimension,
                    chartType: params.chartType,
                    sizeType: sizeType,
                    positionType: positionType,
                    addPadding: addPadding
                });
            }

            position = this._adjustPosition(params.dimension, position);
        }

        return position;
    },

    /**
     * Move to symmetry.
     * @param {{left: number, top: number}} position tooltip position
     * @param {object} params parameters
     *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
     *      @param {string} params.id tooltip id
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.sizeType size type (width or height)
     *      @param {string} params.positionType position type (left or top)
     *      @param {number} params.addPadding add padding
     * @returns {{left: number, top: number}} moved position
     * @private
     */
    _moveToSymmetry: function(position, params) {
        var bound = params.bound;
        var sizeType = params.sizeType;
        var positionType = params.positionType;
        var seriesName = params.seriesName || params.chartType;
        var value = this.dataProcessor.getValue(params.indexes.groupIndex, params.indexes.index, seriesName);
        var tooltipSizeHalf, barPosition, barSizeHalf, movedPositionValue;

        if (value < 0) {
            tooltipSizeHalf = params.dimension[sizeType] / 2;
            barPosition = bound[positionType];
            barSizeHalf = bound[sizeType] / 2;
            movedPositionValue = (barPosition + barSizeHalf - tooltipSizeHalf) * 2 - position[positionType];
            position[positionType] = movedPositionValue;
        }

        return position;
    },

    /**
     * Whether changed indexes or not.
     * @param {{groupIndex: number, index: number}} prevIndexes prev indexes
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @returns {boolean} whether changed or not
     * @private
     */
    _isChangedIndexes: function(prevIndexes, indexes) {
        return !!prevIndexes && (prevIndexes.groupIndex !== indexes.groupIndex || prevIndexes.index !== indexes.index);
    },

    /**
     * Show tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{indexes: {groupIndex: number, index: number}, bound: object}} params tooltip data
     * @param {{left: number, top: number}} prevPosition prev position
     * @private
     */
    _showTooltip: function(elTooltip, params, prevPosition) {
        var indexes = params.indexes,
            prevIndexes = this._getIndexesCustomAttribute(elTooltip),
            prevChartType, position;

        if (this._isChangedIndexes(prevIndexes, indexes)) {
            prevChartType = elTooltip.getAttribute('data-chart-type');
            this._fireHideAnimation(prevIndexes, prevChartType);
        }

        elTooltip.innerHTML = this._makeSingleTooltipHtml(params.seriesName || params.chartType, indexes);

        elTooltip.setAttribute('data-chart-type', params.chartType);
        this._setIndexesCustomAttribute(elTooltip, indexes);
        this._setShowedCustomAttribute(elTooltip, true);

        this._fireBeforeShowTooltip(indexes);

        dom.addClass(elTooltip, 'show');

        position = this._makeTooltipPosition(tui.util.extend({
            dimension: this.getTooltipDimension(elTooltip),
            positionOption: tui.util.extend({
                left: 0,
                top: 0
            }, this.options.position),
            alignOption: this.options.align || ''
        }, params));

        this._moveToPosition(elTooltip, position, prevPosition);
        this._fireShowAnimation(indexes, params.chartType);
        this._fireAfterShowTooltip(indexes, {
            element: elTooltip,
            position: position
        });
    },

    /**
     * To call beforeShowTooltip callback of userEvent.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @private
     */
    _fireBeforeShowTooltip: function(indexes) {
        var params = this._makeShowTooltipParams(indexes);

        this.userEvent.fire('beforeShowTooltip', params);
    },

    /**
     * To call afterShowTooltip callback of userEvent.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {object} additionParams addition parameters
     * @private
     */
    _fireAfterShowTooltip: function(indexes, additionParams) {
        var params = this._makeShowTooltipParams(indexes, additionParams);

        this.userEvent.fire('afterShowTooltip', params);
    },

    /**
     * Execute hiding tooltip.
     * @param {HTMLElement} tooltipElement tooltip element
     * @private
     */
    _executeHidingTooltip: function(tooltipElement) {
        dom.removeClass(tooltipElement, 'show');
        tooltipElement.removeAttribute('data-groupIndex');
        tooltipElement.removeAttribute('data-index');
        tooltipElement.style.cssText = '';
    },

    /**
     * Hide tooltip.
     * @param {HTMLElement} tooltipElement tooltip element
     * @private
     */
    _hideTooltip: function(tooltipElement) {
        var self = this;
        var indexes = this._getIndexesCustomAttribute(tooltipElement);
        var chartType = tooltipElement.getAttribute('data-chart-type');

        if (predicate.isMousePositionChart(chartType)) {
            this._executeHidingTooltip(tooltipElement);
        } else if (chartType) {
            this._setShowedCustomAttribute(tooltipElement, false);
            this._fireHideAnimation(indexes, chartType);

            if (this._isChangedIndexes(this.prevIndexes, indexes)) {
                delete this.prevIndexes;
            }

            setTimeout(function() {
                if (self._isShowedTooltip(tooltipElement)) {
                    return;
                }

                self._executeHidingTooltip(tooltipElement);
            }, chartConst.HIDE_DELAY);
        }
    },

    /**
     * On show tooltip container.
     */
    onShowTooltipContainer: function() {
        this.tooltipContainer.style.zIndex = chartConst.TOOLTIP_ZINDEX;
    },

    /**
     * On hide tooltip container.
     */
    onHideTooltipContainer: function() {
        this.tooltipContainer.style.zIndex = 0;
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = singleTooltipMixer;

},{"../const":31,"../helpers/domHandler":59,"../helpers/predicate":61,"../helpers/renderUtil":63}],112:[function(require,module,exports){
/**
 * @fileoverview Tooltip component.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var TooltipBase = require('./tooltipBase');
var singleTooltipMixer = require('./singleTooltipMixer');
var chartConst = require('../const');
var predicate = require('../helpers/predicate');
var renderUtil = require('../helpers/renderUtil');
var tooltipTemplate = require('./tooltipTemplate');

/**
 * @classdesc Tooltip component.
 * @class Tooltip
 */
var Tooltip = tui.util.defineClass(TooltipBase, /** @lends Tooltip.prototype */ {
    /**
     * Tooltip component.
     * @constructs Tooltip
     * @override
     */
    init: function() {
        TooltipBase.apply(this, arguments);
    },

    /**
     * Make tooltip html.
     * @param {string} category category
     * @param {{value: string, legend: string, chartType: string, suffix: ?string}} item item data
     * @returns {string} tooltip html
     * @private
     */
    _makeTooltipHtml: function(category, item) {
        var template;

        if (predicate.isCoordinateTypeChart(this.chartType)) {
            template = tooltipTemplate.tplCoordinatetypeChart;
        } else {
            template = tooltipTemplate.tplDefault;
        }

        return template(tui.util.extend({
            categoryVisible: category ? 'show' : 'hide',
            category: category
        }, item));
    },

    /**
     * Make html for value types like x, y, r
     * @param {{x: ?number, y: ?number, r: ?number}} data - data
     * @param {Array.<string>} valueTypes - types of value
     * @returns {string}
     * @private
     */
    _makeHtmlForValueTypes: function(data, valueTypes) {
        return tui.util.map(valueTypes, function(type) {
            return (data[type]) ? '<div>' + type + ': ' + data[type] + '</div>' : '';
        }).join('');
    },

    /**
     * Make single tooltip html.
     * @param {string} chartType chart type
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @returns {string} tooltip html
     * @private
     */
    _makeSingleTooltipHtml: function(chartType, indexes) {
        var data = tui.util.pick(this.data, chartType, indexes.groupIndex, indexes.index);

        data = tui.util.extend({
            suffix: this.suffix
        }, data);
        data.valueTypes = this._makeHtmlForValueTypes(data, ['x', 'y', 'r']);

        return this.templateFunc(data.category, data);
    },

    /**
     * Set default align option of tooltip.
     * @private
     * @override
     */
    _setDefaultTooltipPositionOption: function() {
        if (this.options.align) {
            return;
        }

        if (this.isVertical) {
            this.options.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        } else {
            this.options.align = chartConst.TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION;
        }
    },

    /**
     * Make parameters for show tooltip user event.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {object} additionParams addition parameters
     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} parameters for show tooltip
     * @private
     */
    _makeShowTooltipParams: function(indexes, additionParams) {
        var legendIndex = indexes.index;
        var legendData = this.dataProcessor.getLegendItem(legendIndex);
        var params;

        if (!legendData) {
            return null;
        }

        params = tui.util.extend({
            chartType: legendData.chartType,
            legend: legendData.label,
            legendIndex: legendIndex,
            index: indexes.groupIndex
        }, additionParams);

        return params;
    },

    /**
     * Format value of valueMap
     * @param {object} valueMap - map of value like value, x, y, r
     * @returns {{}}
     * @private
     */
    _formatValueMap: function(valueMap) {
        var formatFunctions = this.dataProcessor.getFormatFunctions();
        var chartType = this.chartType;
        var formattedMap = {};

        tui.util.forEach(valueMap, function(value, valueType) {
            formattedMap[valueType] = renderUtil.formatValue(value, formatFunctions, chartType, 'tooltip', valueType);
        });

        return formattedMap;
    },

    /**
     * Make tooltip datum.
     * @param {Array.<string>} legendLabels - legend labels
     * @param {string} category - category
     * @param {string} chartType - chart type
     * @param {SeriesItem} seriesItem - SeriesItem
     * @param {number} index - index
     * @returns {Object}
     * @private
     */
    _makeTooltipDatum: function(legendLabels, category, chartType, seriesItem, index) {
        var legend = legendLabels[chartType][index] || '';

        var labelPrefix = (legend && seriesItem.label) ? ':&nbsp;' : '';
        var label = seriesItem.tooltipLabel || (seriesItem.label ? labelPrefix + seriesItem.label : '');
        var valueMap = this._formatValueMap(seriesItem.pickValueMap());

        return tui.util.extend({
            category: category || '',
            legend: legend,
            label: label
        }, valueMap);
    },

    /**
     * Make tooltip data.
     * @returns {Array.<object>} tooltip data
     * @override
     */
    _makeTooltipData: function() {
        var self = this;
        var orgLegendLabels = this.dataProcessor.getLegendLabels();
        var isPivot = predicate.isTreemapChart(this.chartType);
        var legendLabels = {};
        var tooltipData = {};

        if (tui.util.isArray(orgLegendLabels)) {
            legendLabels[this.chartType] = orgLegendLabels;
        } else {
            legendLabels = orgLegendLabels;
        }

        this.dataProcessor.eachBySeriesGroup(function(seriesGroup, groupIndex, chartType) {
            var data;

            chartType = chartType || self.chartType;

            data = seriesGroup.map(function(seriesItem, index) {
                var category = self.dataProcessor.getTooltipCategory(groupIndex, index, self.isVertical);

                return seriesItem ? self._makeTooltipDatum(legendLabels, category, chartType, seriesItem, index) : null;
            });

            if (!tooltipData[chartType]) {
                tooltipData[chartType] = [];
            }

            tooltipData[chartType].push(data);
        }, isPivot);

        return tooltipData;
    }
});

singleTooltipMixer.mixin(Tooltip);
module.exports = Tooltip;

},{"../const":31,"../helpers/predicate":61,"../helpers/renderUtil":63,"./singleTooltipMixer":111,"./tooltipBase":113,"./tooltipTemplate":114}],113:[function(require,module,exports){
/**
 * @fileoverview TooltipBase is base class of tooltip components.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil');

var TooltipBase = tui.util.defineClass(/** @lends TooltipBase.prototype */ {
    /**
     * TooltipBase is base class of tooltip components.
     * @constructs TooltipBase
     * @param {object} params parameters
     *      @param {Array.<number>} params.values converted values
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        var isPieChart = predicate.isPieChart(params.chartType);

        /**
         * Chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * Data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Options
         * @type {object}
         */
        this.options = params.options;

        /**
         * Theme
         * @type {object}
         */
        this.theme = params.theme;

        /**
         * whether vertical or not
         * @type {boolean}
         */
        this.isVertical = params.isVertical;

        /**
         * User event listener
         * @type {UserEventListener}
         */
        this.userEvent = params.userEvent;

        /**
         * label theme
         * @type {object}
         */
        this.labelTheme = params.labelTheme;

        /**
         * className
         * @type {string}
         */
        this.className = 'tui-chart-tooltip-area';

        /**
         * Tooltip container.
         * @type {HTMLElement}
         */
        this.tooltipContainer = null;

        /**
         * Tooltip suffix.
         * @type {string}
         */
        this.suffix = this.options.suffix ? '&nbsp;' + this.options.suffix : '';

        /**
         * Tooltip template function.
         * @type {function}
         */
        this.templateFunc = this.options.template || tui.util.bind(this._makeTooltipHtml, this);

        /**
         * Tooltip animation time.
         * @type {number}
         */
        this.animationTime = isPieChart ? chartConst.TOOLTIP_PIE_ANIMATION_TIME : chartConst.TOOLTIP_ANIMATION_TIME;

        /**
         * TooltipBase base data.
         * @type {Array.<Array.<object>>}
         */
        this.data = [];

        this._setDefaultTooltipPositionOption();
        this._saveOriginalPositionOptions();
    },

    /**
     * Make tooltip html.
     * @private
     * @abstract
     */
    _makeTooltipHtml: function() {},

    /**
     * Set default align option of tooltip.
     * @private
     * @abstract
     */
    _setDefaultTooltipPositionOption: function() {},

    /**
     * Save position options.
     * @private
     */
    _saveOriginalPositionOptions: function() {
        this.orgPositionOptions = {
            align: this.options.align,
            position: this.options.position
        };
    },

    /**
     * Make tooltip data.
     * @private
     * @abstract
     */
    _makeTooltipData: function() {},

    /**
     * Render tooltip component.
     * @returns {HTMLElement} tooltip element
     */
    render: function() {
        var el = dom.create('DIV', this.className);

        this.data = this._makeTooltipData();

        renderUtil.renderPosition(el, this.boundsMaker.getPosition('tooltip'));

        this.tooltipContainer = el;

        return el;
    },

    /**
     * Rerender.
     */
    rerender: function() {
        this.data = this._makeTooltipData();
        this.resize();
    },

    /**
     * Resize tooltip component.
     * @override
     */
    resize: function() {
        renderUtil.renderPosition(this.tooltipContainer, this.boundsMaker.getPosition('tooltip'));
        if (this.positionModel) {
            this.positionModel.updateBound(this.boundsMaker.getBound('tooltip'));
        }
    },

    /**
     * Zoom.
     */
    zoom: function() {
        this.data = this._makeTooltipData();
    },

    /**
     * Get tooltip element.
     * @returns {HTMLElement} tooltip element
     * @private
     */
    _getTooltipElement: function() {
        var tooltipElement;

        if (!this.tooltipElement) {
            this.tooltipElement = tooltipElement = dom.create('DIV', 'tui-chart-tooltip');
            dom.append(this.tooltipContainer, tooltipElement);
        }

        return this.tooltipElement;
    },

    /**
     * onShow is callback of custom event showTooltip for SeriesView.
     * @param {object} params coordinate event parameters
     */
    onShow: function(params) {
        var tooltipElement = this._getTooltipElement(),
            prevPosition;

        if (!predicate.isMousePositionChart(params.chartType) && tooltipElement.offsetWidth) {
            prevPosition = {
                left: tooltipElement.offsetLeft,
                top: tooltipElement.offsetTop
            };
        }

        this._showTooltip(tooltipElement, params, prevPosition);
    },

    /**
     * Get tooltip dimension
     * @param {HTMLElement} tooltipElement tooltip element
     * @returns {{width: number, height: number}} rendered tooltip dimension
     */
    getTooltipDimension: function(tooltipElement) {
        return {
            width: tooltipElement.offsetWidth,
            height: tooltipElement.offsetHeight
        };
    },

    /**
     * Move to Position.
     * @param {HTMLElement} tooltipElement tooltip element
     * @param {{left: number, top: number}} position position
     * @param {{left: number, top: number}} prevPosition prev position
     * @private
     */
    _moveToPosition: function(tooltipElement, position, prevPosition) {
        if (prevPosition) {
            this._slideTooltip(tooltipElement, prevPosition, position);
        } else {
            renderUtil.renderPosition(tooltipElement, position);
        }
    },

    /**
     * Slide tooltip
     * @param {HTMLElement} tooltipElement tooltip element
     * @param {{left: number, top: number}} prevPosition prev position
     * @param {{left: number, top: number}} position position
     * @private
     */
    _slideTooltip: function(tooltipElement, prevPosition, position) {
        var moveTop = position.top - prevPosition.top,
            moveLeft = position.left - prevPosition.left;

        renderUtil.cancelAnimation(this.slidingAnimation);

        this.slidingAnimation = renderUtil.startAnimation(this.animationTime, function(ratio) {
            var left = moveLeft * ratio,
                top = moveTop * ratio;
            tooltipElement.style.left = (prevPosition.left + left) + 'px';
            tooltipElement.style.top = (prevPosition.top + top) + 'px';
        });
    },

    /**
     * onHide is callback of custom event hideTooltip for SeriesView
     * @param {number} index index
     */
    onHide: function(index) {
        var tooltipElement = this._getTooltipElement();

        this._hideTooltip(tooltipElement, index);
    },

    /**
     * Set tooltip align option.
     * @param {string} align align
     */
    setAlign: function(align) {
        this.options.align = align;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Set position option.
     * @param {{left: number, top: number}} position moving position
     */
    setPosition: function(position) {
        this.options.position = tui.util.extend({}, this.options.position, position);
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Reset tooltip align option.
     */
    resetAlign: function() {
        var align = this.orgPositionOptions.align;

        this.options.align = align;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Reset tooltip position.
     */
    resetPosition: function() {
        var position = this.orgPositionOptions.position;

        this.options.position = position;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    }
});

tui.util.CustomEvents.mixin(TooltipBase);

module.exports = TooltipBase;

},{"../const":31,"../helpers/domHandler":59,"../helpers/predicate":61,"../helpers/renderUtil":63}],114:[function(require,module,exports){
/**
 * @fileoverview This is templates of tooltip.
 * @author NHN Ent.
 *         FE Development Lab <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var htmls = {
    HTML_DEFAULT_TEMPLATE: '<div class="tui-chart-default-tooltip">' +
        '<div class="{{ categoryVisible }}">{{ category }}</div>' +
        '<div>' +
            '<span>{{ legend }}</span>' +
            '<span>{{ label }}</span>' +
            '<span>{{ suffix }}</span>' +
        '</div>' +
    '</div>',
    HTML_COORDINATE_TYPE_CHART_TEMPLATE: '<div class="tui-chart-default-tooltip">' +
        '<div>{{ category }}</div>' +
        '<div>' +
            '<span>{{ legend }}</span>' +
            '<span>{{ label }}</span>' +
        '</div>{{ valueTypes }}' +
    '</div>',
    HTML_GROUP: '<div class="tui-chart-default-tooltip tui-chart-group-tooltip">' +
        '<div>{{ category }}</div>' +
        '{{ items }}' +
    '</div>',
    HTML_GROUP_ITEM: '<div>' +
        '<div class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></div>' +
        '&nbsp;<span>{{ legend }}</span>:&nbsp;<span>{{ value }}</span>' +
        '<span>{{ suffix }}</span>' +
    '</div>',
    GROUP_CSS_TEXT: 'background-color:{{ color }}',
    HTML_MAP_CHART_DEFAULT_TEMPLATE: '<div class="tui-chart-default-tooltip">' +
        '<div>{{ name }}: {{ value }}{{ suffix }}</div>' +
    '</div>'
};

module.exports = {
    tplDefault: templateMaker.template(htmls.HTML_DEFAULT_TEMPLATE),
    tplCoordinatetypeChart: templateMaker.template(htmls.HTML_COORDINATE_TYPE_CHART_TEMPLATE),
    tplGroup: templateMaker.template(htmls.HTML_GROUP),
    tplGroupItem: templateMaker.template(htmls.HTML_GROUP_ITEM),
    tplGroupCssText: templateMaker.template(htmls.GROUP_CSS_TEXT),
    tplMapChartDefault: templateMaker.template(htmls.HTML_MAP_CHART_DEFAULT_TEMPLATE)
};

},{"../helpers/templateMaker":64}]},{},[3,74])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvanMvYXhlcy9heGlzLmpzIiwic3JjL2pzL2F4ZXMvYXhpc1RlbXBsYXRlLmpzIiwic3JjL2pzL2NoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9hZGRpbmdEeW5hbWljRGF0YU1peGVyLmpzIiwic3JjL2pzL2NoYXJ0cy9hcmVhQ2hhcnQuanMiLCJzcmMvanMvY2hhcnRzL2F1dG9UaWNrTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL2F4aXNUeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL2JhckNoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9iYXJUeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL2J1YmJsZUNoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9jaGFydEJhc2UuanMiLCJzcmMvanMvY2hhcnRzL2NvbG9yU3BlY3RydW0uanMiLCJzcmMvanMvY2hhcnRzL2NvbHVtbkNoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9jb2x1bW5MaW5lQ29tYm9DaGFydC5qcyIsInNyYy9qcy9jaGFydHMvY29tYm9UeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL2NvbXBvbmVudE1hbmFnZXIuanMiLCJzcmMvanMvY2hhcnRzL2hlYXRtYXBDaGFydC5qcyIsInNyYy9qcy9jaGFydHMvbGluZUFyZWFDb21ib0NoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9saW5lQ2hhcnQuanMiLCJzcmMvanMvY2hhcnRzL2xpbmVUeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL21hcENoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9tYXBDaGFydE1hcE1vZGVsLmpzIiwic3JjL2pzL2NoYXJ0cy9waWVDaGFydC5qcyIsInNyYy9qcy9jaGFydHMvcGllRG9udXRDb21ib0NoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9waWVUeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL3NjYXR0ZXJDaGFydC5qcyIsInNyYy9qcy9jaGFydHMvdHJlZW1hcENoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy92ZXJ0aWNhbFR5cGVDb21ib01peGVyLmpzIiwic3JjL2pzL2NoYXJ0cy96b29tTWl4ZXIuanMiLCJzcmMvanMvY29kZS1zbmlwcGV0LXV0aWwuanMiLCJzcmMvanMvY29uc3QuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL2FyZWFUeXBlQ3VzdG9tRXZlbnQuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL2FyZWFUeXBlRGF0YU1vZGVsLmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9ib3VuZHNCYXNlQ29vcmRpbmF0ZU1vZGVsLmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9ib3VuZHNUeXBlQ3VzdG9tRXZlbnQuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL2N1c3RvbUV2ZW50QmFzZS5qcyIsInNyYy9qcy9jdXN0b21FdmVudHMvZ3JvdXBUeXBlQ3VzdG9tRXZlbnQuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL21hcENoYXJ0Q3VzdG9tRXZlbnQuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL3NpbXBsZUN1c3RvbUV2ZW50LmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy90aWNrQmFzZUNvb3JkaW5hdGVNb2RlbC5qcyIsInNyYy9qcy9jdXN0b21FdmVudHMvem9vbU1peGVyLmpzIiwic3JjL2pzL2RhdGFNb2RlbHMvZGF0YVByb2Nlc3Nvci5qcyIsInNyYy9qcy9kYXRhTW9kZWxzL21hcENoYXJ0RGF0YVByb2Nlc3Nvci5qcyIsInNyYy9qcy9kYXRhTW9kZWxzL3Nlcmllc0RhdGFNb2RlbC5qcyIsInNyYy9qcy9kYXRhTW9kZWxzL3Nlcmllc0RhdGFNb2RlbEZvclRyZWVtYXAuanMiLCJzcmMvanMvZGF0YU1vZGVscy9zZXJpZXNHcm91cC5qcyIsInNyYy9qcy9kYXRhTW9kZWxzL3Nlcmllc0l0ZW0uanMiLCJzcmMvanMvZGF0YU1vZGVscy9zZXJpZXNJdGVtRm9yQ29vcmRpbmF0ZVR5cGUuanMiLCJzcmMvanMvZGF0YU1vZGVscy9zZXJpZXNJdGVtRm9yVHJlZW1hcC5qcyIsInNyYy9qcy9mYWN0b3JpZXMvY2hhcnRGYWN0b3J5LmpzIiwic3JjL2pzL2ZhY3Rvcmllcy9tYXBGYWN0b3J5LmpzIiwic3JjL2pzL2ZhY3Rvcmllcy9wbHVnaW5GYWN0b3J5LmpzIiwic3JjL2pzL2ZhY3Rvcmllcy90aGVtZUZhY3RvcnkuanMiLCJzcmMvanMvaGVscGVycy9heGlzRGF0YU1ha2VyLmpzIiwic3JjL2pzL2hlbHBlcnMvYXhpc1NjYWxlTWFrZXIuanMiLCJzcmMvanMvaGVscGVycy9ib3VuZHNNYWtlci5qcyIsInNyYy9qcy9oZWxwZXJzL2NhbGN1bGF0b3IuanMiLCJzcmMvanMvaGVscGVycy9jb2xvcnV0aWwuanMiLCJzcmMvanMvaGVscGVycy9kb21IYW5kbGVyLmpzIiwic3JjL2pzL2hlbHBlcnMvZXZlbnRMaXN0ZW5lci5qcyIsInNyYy9qcy9oZWxwZXJzL3ByZWRpY2F0ZS5qcyIsInNyYy9qcy9oZWxwZXJzL3Jhd0RhdGFIYW5kbGVyLmpzIiwic3JjL2pzL2hlbHBlcnMvcmVuZGVyVXRpbC5qcyIsInNyYy9qcy9oZWxwZXJzL3RlbXBsYXRlTWFrZXIuanMiLCJzcmMvanMvaGVscGVycy91c2VyRXZlbnRMaXN0ZW5lci5qcyIsInNyYy9qcy9sZWdlbmRzL2NpcmNsZUxlZ2VuZC5qcyIsInNyYy9qcy9sZWdlbmRzL2xlZ2VuZC5qcyIsInNyYy9qcy9sZWdlbmRzL2xlZ2VuZERpbWVuc2lvbk1vZGVsLmpzIiwic3JjL2pzL2xlZ2VuZHMvbGVnZW5kTW9kZWwuanMiLCJzcmMvanMvbGVnZW5kcy9sZWdlbmRUZW1wbGF0ZS5qcyIsInNyYy9qcy9sZWdlbmRzL3NwZWN0cnVtTGVnZW5kLmpzIiwic3JjL2pzL3Bsb3RzL3Bsb3QuanMiLCJzcmMvanMvcGxvdHMvcGxvdFRlbXBsYXRlLmpzIiwic3JjL2pzL3BsdWdpbnMvcGx1Z2luUmFwaGFlbC5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxBcmVhQ2hhcnQuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsQmFyQ2hhcnQuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsQm94VHlwZUNoYXJ0LmpzIiwic3JjL2pzL3BsdWdpbnMvcmFwaGFlbENpcmNsZUxlZ2VuZC5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxDb29yZGluYXRlVHlwZUNoYXJ0LmpzIiwic3JjL2pzL3BsdWdpbnMvcmFwaGFlbExpbmVDaGFydC5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxMaW5lVHlwZUJhc2UuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsTWFwQ2hhcnQuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsTWFwTGVnZW5kLmpzIiwic3JjL2pzL3BsdWdpbnMvcmFwaGFlbFBpZUNoYXJ0LmpzIiwic3JjL2pzL3BsdWdpbnMvcmFwaGFlbFJlbmRlclV0aWwuanMiLCJzcmMvanMvcG9seWZpbGwuanMiLCJzcmMvanMvcmVnaXN0ZXJDaGFydHMuanMiLCJzcmMvanMvcmVnaXN0ZXJUaGVtZXMuanMiLCJzcmMvanMvc2VyaWVzL2FyZWFDaGFydFNlcmllcy5qcyIsInNyYy9qcy9zZXJpZXMvYmFyQ2hhcnRTZXJpZXMuanMiLCJzcmMvanMvc2VyaWVzL2JhclR5cGVTZXJpZXNCYXNlLmpzIiwic3JjL2pzL3Nlcmllcy9idWJibGVDaGFydFNlcmllcy5qcyIsInNyYy9qcy9zZXJpZXMvY29sdW1uQ2hhcnRTZXJpZXMuanMiLCJzcmMvanMvc2VyaWVzL2Nvb3JkaW5hdGVUeXBlU2VyaWVzQmFzZS5qcyIsInNyYy9qcy9zZXJpZXMvaGVhdG1hcENoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9saW5lQ2hhcnRTZXJpZXMuanMiLCJzcmMvanMvc2VyaWVzL2xpbmVUeXBlU2VyaWVzQmFzZS5qcyIsInNyYy9qcy9zZXJpZXMvbWFwQ2hhcnRTZXJpZXMuanMiLCJzcmMvanMvc2VyaWVzL3BpZUNoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9yZW5kZXJpbmdMYWJlbEhlbHBlci5qcyIsInNyYy9qcy9zZXJpZXMvc2NhdHRlckNoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9zZXJpZXMuanMiLCJzcmMvanMvc2VyaWVzL3Nlcmllc1RlbXBsYXRlLmpzIiwic3JjL2pzL3Nlcmllcy9zcXVhcmlmaWVyLmpzIiwic3JjL2pzL3Nlcmllcy90cmVlbWFwQ2hhcnRTZXJpZXMuanMiLCJzcmMvanMvc2VyaWVzL3pvb20uanMiLCJzcmMvanMvdGhlbWVzL2RlZmF1bHRUaGVtZS5qcyIsInNyYy9qcy90b29sdGlwcy9ncm91cFRvb2x0aXAuanMiLCJzcmMvanMvdG9vbHRpcHMvZ3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbC5qcyIsInNyYy9qcy90b29sdGlwcy9tYXBDaGFydFRvb2x0aXAuanMiLCJzcmMvanMvdG9vbHRpcHMvc2luZ2xlVG9vbHRpcE1peGVyLmpzIiwic3JjL2pzL3Rvb2x0aXBzL3Rvb2x0aXAuanMiLCJzcmMvanMvdG9vbHRpcHMvdG9vbHRpcEJhc2UuanMiLCJzcmMvanMvdG9vbHRpcHMvdG9vbHRpcFRlbXBsYXRlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvb0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1bkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcDBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3eUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2paQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9lQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBBeGlzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcbnZhciBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxjdWxhdG9yJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xudmFyIGF4aXNUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vYXhpc1RlbXBsYXRlJyk7XG5cbnZhciBBeGlzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBBeGlzLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQXhpcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgQXhpc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5ib3VuZCBheGlzIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIGF4aXMgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBheGlzIG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgdmlldyBjbGFzc05hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jaGFydC1heGlzLWFyZWEnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFydCB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IHBhcmFtcy5jaGFydFR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgcHJvY2Vzc29yXG4gICAgICAgICAqIEB0eXBlIHtEYXRhUHJvY2Vzc29yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gcGFyYW1zLmRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlbWVcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGhlbWUgPSBwYXJhbXMudGhlbWUgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgbGFiZWwgdHlwZSBvciBub3QuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0xhYmVsID0gcGFyYW1zLmlzTGFiZWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdmVydGljYWwgdHlwZSBvciBub3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVmVydGljYWwgPSBwYXJhbXMuaXNWZXJ0aWNhbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBoZWlnaHQgb2YgeCBheGlzIGFyZWEuXG4gICAgICogQHJldHVybnMge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVhBeGlzSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgICAgICB2YXIgdGl0bGVIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQodGl0bGUsIHRoaXMudGhlbWUudGl0bGUpO1xuICAgICAgICB2YXIgdGl0bGVBcmVhSGVpZ2h0ID0gdGl0bGVIZWlnaHQgPyAodGl0bGVIZWlnaHQgKyBjaGFydENvbnN0LlRJVExFX1BBRERJTkcpIDogMDtcbiAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGNoYXJ0Q29uc3QuTUFYX0hFSUdIVF9XT1JMRCwgdGhpcy50aGVtZS5sYWJlbCk7XG5cbiAgICAgICAgcmV0dXJuIHRpdGxlQXJlYUhlaWdodCArIGxhYmVsSGVpZ2h0ICsgY2hhcnRDb25zdC5DSEFSVF9QQURESU5HO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHdpZHRoIG9mIHkgYXhpcyBhcmVhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZyB8IG51bWJlcj59IGxhYmVscyBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge3t0aXRsZTogP3N0cmluZywgaXNDZW50ZXI6ID9ib29sZWFuLCByb3RhdGVUaXRsZTogP2Jvb2xlYW59fSBvcHRpb25zIC0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVlBeGlzV2lkdGg6IGZ1bmN0aW9uKGxhYmVscywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGl0bGUgPSBvcHRpb25zLnRpdGxlIHx8ICcnO1xuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnRoZW1lO1xuICAgICAgICB2YXIgdGl0bGVBcmVhV2lkdGggPSAwO1xuICAgICAgICB2YXIgd2lkdGggPSAwO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmlzQ2VudGVyKSB7XG4gICAgICAgICAgICB3aWR0aCArPSBjaGFydENvbnN0LkFYSVNfTEFCRUxfUEFERElORztcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnJvdGF0ZVRpdGxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGl0bGVBcmVhV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aCh0aXRsZSwgdGhlbWUudGl0bGUpICsgY2hhcnRDb25zdC5USVRMRV9QQURESU5HO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGl0bGVBcmVhV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQodGl0bGUsIHRoZW1lLnRpdGxlKSArIGNoYXJ0Q29uc3QuVElUTEVfUEFERElORztcbiAgICAgICAgfVxuXG4gICAgICAgIHdpZHRoICs9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhXaWR0aChsYWJlbHMsIHRoZW1lLmxhYmVsKSArIHRpdGxlQXJlYVdpZHRoICtcbiAgICAgICAgICAgIGNoYXJ0Q29uc3QuQVhJU19MQUJFTF9QQURESU5HO1xuXG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB2YWxpZCBheGlzIG9yIG5vdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB2YWxpZCBheGlzIG9yIG5vdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1ZhbGlkQXhpczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnROYW1lID09PSAncmlnaHRZQXhpcycpIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSB0aGlzLmRhdGFQcm9jZXNzb3IuaXNWYWxpZEFsbFNlcmllc0RhdGFNb2RlbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGxlZ2VuZCBkaW1lbnNpb24gdG8gYm91bmRzTWFrZXIuXG4gICAgICovXG4gICAgcmVnaXN0ZXJEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0ge307XG4gICAgICAgIHZhciBjYXRlZ29yaWVzO1xuXG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZEF4aXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50VHlwZSA9PT0gJ3hBeGlzJykge1xuICAgICAgICAgICAgZGltZW5zaW9uLmhlaWdodCA9IHRoaXMuX21ha2VYQXhpc0hlaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5ib3VuZHNNYWtlci5yZWdpc3RlckJhc2VEaW1lbnNpb24odGhpcy5jb21wb25lbnROYW1lLCBkaW1lbnNpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNMYWJlbCkge1xuICAgICAgICAgICAgY2F0ZWdvcmllcyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRDYXRlZ29yaWVzKHRoaXMuaXNWZXJ0aWNhbCk7XG4gICAgICAgICAgICBkaW1lbnNpb24ud2lkdGggPSB0aGlzLl9tYWtlWUF4aXNXaWR0aChjYXRlZ29yaWVzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5ib3VuZHNNYWtlci5yZWdpc3RlckJhc2VEaW1lbnNpb24odGhpcy5jb21wb25lbnROYW1lLCBkaW1lbnNpb24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGxlZ2VuZCBhZGRpdGlvbmFsIGRpbWVuc2lvbiB0byBib3VuZHNNYWtlci5cbiAgICAgKi9cbiAgICByZWdpc3RlckFkZGl0aW9uYWxEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXhlc0RhdGEgPSB0aGlzLmJvdW5kc01ha2VyLmF4ZXNEYXRhO1xuICAgICAgICB2YXIgZGltZW5zaW9uLCBvcHRpb25zO1xuXG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZEF4aXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh0aGlzLmNvbXBvbmVudFR5cGUgPT09ICd5QXhpcycpICYmICF0aGlzLmlzTGFiZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudE5hbWUgPT09ICdyaWdodFlBeGlzJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBheGVzRGF0YS55QXhpcy5vcHRpb25zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaW1lbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuX21ha2VZQXhpc1dpZHRoKGF4ZXNEYXRhLnlBeGlzLmxhYmVscywgb3B0aW9ucylcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCYXNlRGltZW5zaW9uKHRoaXMuY29tcG9uZW50TmFtZSwgZGltZW5zaW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgb3Bwb3NpdGUgc2lkZSB0aWNrIGFyZWEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRpY2tIdG1sIHRpY2sgaHRtbFxuICAgICAqIEByZXR1cm5zIHs/SFRNTEVsZW1lbnR9IHJpZ2h0IHRpY2sgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyT3Bwb3NpdGVTaWRlVGlja0FyZWE6IGZ1bmN0aW9uKHRpY2tIdG1sKSB7XG4gICAgICAgIHZhciB0aWNrQ29udGFpbmVyO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNDZW50ZXIpIHtcbiAgICAgICAgICAgIHRpY2tDb250YWluZXIgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LXRpY2stYXJlYSBvcHBvc2l0ZS1zaWRlJyk7XG4gICAgICAgICAgICB0aWNrQ29udGFpbmVyLmlubmVySFRNTCA9IHRpY2tIdG1sO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRpY2tDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjc3MgY2xhc3Nlcy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBheGlzQ29udGFpbmVyIGF4aXMgY29udGFpbmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ3NzQ2xhc3NlczogZnVuY3Rpb24oYXhpc0NvbnRhaW5lcikge1xuICAgICAgICBkb20uYWRkQ2xhc3MoYXhpc0NvbnRhaW5lciwgdGhpcy5pc1ZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhheGlzQ29udGFpbmVyLCB0aGlzLm9wdGlvbnMuaXNDZW50ZXIgPyAnY2VudGVyJyA6ICcnKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF4aXNDb250YWluZXIsIHRoaXMub3B0aW9ucy5kaXZpZGVkID8gJ2RpdmlzaW9uJyA6ICcnKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF4aXNDb250YWluZXIsIHRoaXMuZGF0YS5pc1Bvc2l0aW9uUmlnaHQgPyAncmlnaHQnIDogJycpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjaGlsZCBjb250YWluZXJzIGxpa2UgdGl0bGUgYXJlYSwgbGFiZWwgYXJlYSBhbmQgdGljayBhcmVhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHhBeGlzIHdpZHRoIG9yIHlBeGlzIGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBheGlzIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyfHN0cmluZz59IGNhdGVnb3JpZXMgY2F0ZWdvcmllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRpdGlvbmFsV2lkdGggYWRkaXRpb25hbCB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48SFRNTEVsZW1lbnQ+fSBjaGlsZCBjb250YWluZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2hpbGRDb250YWluZXJzOiBmdW5jdGlvbihzaXplLCB3aWR0aCwgdGlja0NvdW50LCBjYXRlZ29yaWVzLCBhZGRpdGlvbmFsV2lkdGgpIHtcbiAgICAgICAgdmFyIHRpdGxlQ29udGFpbmVyID0gdGhpcy5fcmVuZGVyVGl0bGVBcmVhKHNpemUpLFxuICAgICAgICAgICAgbGFiZWxDb250YWluZXIgPSB0aGlzLl9yZW5kZXJMYWJlbEFyZWEoc2l6ZSwgd2lkdGgsIHRpY2tDb3VudCwgY2F0ZWdvcmllcywgYWRkaXRpb25hbFdpZHRoKSxcbiAgICAgICAgICAgIGNoaWxkQ29udGFpbmVycyA9IFt0aXRsZUNvbnRhaW5lciwgbGFiZWxDb250YWluZXJdLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbExpbmVUeXBlID0gdGhpcy5pc1ZlcnRpY2FsICYmIHRoaXMuZGF0YS5hbGlnbmVkLFxuICAgICAgICAgICAgdGlja0NvbnRhaW5lciwgb3Bwb3NpdGVTaWRlVGlja0NvbnRhaW5lcjtcblxuICAgICAgICBpZiAoIWlzVmVydGljYWxMaW5lVHlwZSkge1xuICAgICAgICAgICAgdGlja0NvbnRhaW5lciA9IHRoaXMuX3JlbmRlclRpY2tBcmVhKHNpemUsIHRpY2tDb3VudCwgYWRkaXRpb25hbFdpZHRoKTtcbiAgICAgICAgICAgIG9wcG9zaXRlU2lkZVRpY2tDb250YWluZXIgPSB0aGlzLl9yZW5kZXJPcHBvc2l0ZVNpZGVUaWNrQXJlYSh0aWNrQ29udGFpbmVyLmlubmVySFRNTCk7XG4gICAgICAgICAgICBjaGlsZENvbnRhaW5lcnMgPSBjaGlsZENvbnRhaW5lcnMuY29uY2F0KFt0aWNrQ29udGFpbmVyLCBvcHBvc2l0ZVNpZGVUaWNrQ29udGFpbmVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGRDb250YWluZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZGl2aWRlZCB4QXhpcyBpZiB5QXhpcyByZW5kZXJlZCBpbiB0aGUgY2VudGVyLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGF4aXNDb250YWluZXIgYXhpcyBjb250YWluZXIgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBheGlzIGFyZWEgd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJEaXZpZGVkQXhpczogZnVuY3Rpb24oYXhpc0NvbnRhaW5lciwgd2lkdGgpIHtcbiAgICAgICAgdmFyIGxXaWR0aCA9IE1hdGgucm91bmQod2lkdGggLyAyKTtcbiAgICAgICAgdmFyIHJXaWR0aCA9IHdpZHRoIC0gbFdpZHRoO1xuICAgICAgICB2YXIgdGlja0NvdW50ID0gdGhpcy5kYXRhLnRpY2tDb3VudDtcbiAgICAgICAgdmFyIGhhbGZUaWNrQ291bnQgPSBwYXJzZUludCh0aWNrQ291bnQgLyAyLCAxMCkgKyAxO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IHRoaXMuZGF0YS5sYWJlbHM7XG4gICAgICAgIHZhciBsQ2F0ZWdvcmllcyA9IGNhdGVnb3JpZXMuc2xpY2UoMCwgaGFsZlRpY2tDb3VudCk7XG4gICAgICAgIHZhciByQ2F0ZWdvcmllcyA9IGNhdGVnb3JpZXMuc2xpY2UoaGFsZlRpY2tDb3VudCAtIDEsIHRpY2tDb3VudCk7XG4gICAgICAgIHZhciBhZGRpdGlvbmFsV2lkdGggPSBsV2lkdGggKyB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbigneUF4aXMnKS53aWR0aDtcbiAgICAgICAgdmFyIGxDb250YWluZXJzID0gdGhpcy5fcmVuZGVyQ2hpbGRDb250YWluZXJzKGxXaWR0aCwgbFdpZHRoLCBoYWxmVGlja0NvdW50LCBsQ2F0ZWdvcmllcyk7XG4gICAgICAgIHZhciByQ29udGFpbmVycyA9IHRoaXMuX3JlbmRlckNoaWxkQ29udGFpbmVycyhyV2lkdGgsIHJXaWR0aCwgaGFsZlRpY2tDb3VudCwgckNhdGVnb3JpZXMsIGFkZGl0aW9uYWxXaWR0aCk7XG4gICAgICAgIHZhciByVGl0bGVDb250YWluZXIgPSByQ29udGFpbmVyc1swXTtcblxuICAgICAgICBkb20uYWRkQ2xhc3MoclRpdGxlQ29udGFpbmVyLCAncmlnaHQnKTtcbiAgICAgICAgZG9tLmFwcGVuZChheGlzQ29udGFpbmVyLCBsQ29udGFpbmVycy5jb25jYXQockNvbnRhaW5lcnMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNpbmdsZSBheGlzIGlmIG5vdCBkaXZpZGVkLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGF4aXNDb250YWluZXIgYXhpcyBjb250YWluZXIgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGF4aXMgYXJlYSBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJOb3REaXZpZGVkQXhpczogZnVuY3Rpb24oYXhpc0NvbnRhaW5lciwgZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IHRoaXMuaXNWZXJ0aWNhbDtcbiAgICAgICAgdmFyIHdpZHRoID0gZGltZW5zaW9uLndpZHRoO1xuICAgICAgICB2YXIgc2l6ZSA9IGlzVmVydGljYWwgPyBkaW1lbnNpb24uaGVpZ2h0IDogd2lkdGg7XG4gICAgICAgIHZhciBhZGRpdGlvbmFsU2l6ZSA9IDA7XG4gICAgICAgIHZhciBjaGlsZENvbnRhaW5lcnM7XG5cbiAgICAgICAgaWYgKGRhdGEucG9zaXRpb25SYXRpbykge1xuICAgICAgICAgICAgYWRkaXRpb25hbFNpemUgPSBzaXplICogZGF0YS5wb3NpdGlvblJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRDb250YWluZXJzID0gdGhpcy5fcmVuZGVyQ2hpbGRDb250YWluZXJzKHNpemUsIHdpZHRoLCBkYXRhLnRpY2tDb3VudCwgZGF0YS5sYWJlbHMsIGFkZGl0aW9uYWxTaXplKTtcblxuICAgICAgICBkb20uYXBwZW5kKGF4aXNDb250YWluZXIsIGNoaWxkQ29udGFpbmVycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBheGlzIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYXhpc0NvbnRhaW5lciBheGlzIGFyZWEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2lzVmVydGljYWw6IGJvb2xlYW4sIGlzUG9zaXRpb25SaWdodDogYm9vbGVhbiwgYWxpZ25lZDogYWxpZ25lZH19IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJBeGlzQXJlYTogZnVuY3Rpb24oYXhpc0NvbnRhaW5lcikge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdHVpLnV0aWwuZXh0ZW5kKHt9LCB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbih0aGlzLmNvbXBvbmVudE5hbWUpKTtcblxuICAgICAgICB0aGlzLl9hZGRDc3NDbGFzc2VzKGF4aXNDb250YWluZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGl2aWRlZCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJXaWR0aCA9IGRpbWVuc2lvbi53aWR0aCArIHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCd5QXhpcycpLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyRGl2aWRlZEF4aXMoYXhpc0NvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoKTtcbiAgICAgICAgICAgIGRpbWVuc2lvbi53aWR0aCA9IHRoaXMuY29udGFpbmVyV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJOb3REaXZpZGVkQXhpcyhheGlzQ29udGFpbmVyLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgZGltZW5zaW9uLndpZHRoICs9IHRoaXMub3B0aW9ucy5pc0NlbnRlciA/IDIgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oYXhpc0NvbnRhaW5lciwgZGltZW5zaW9uKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihheGlzQ29udGFpbmVyLCB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKHRoaXMuY29tcG9uZW50TmFtZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYXhpcyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7aXNQb3NpdGlvblJpZ2h0OiBib29sZWFuLCBhbGlnbmVkOiBhbGlnbmVkfX0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gYXhpcyBhcmVhIGJhc2UgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpO1xuXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuX3JlbmRlckF4aXNBcmVhKGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuYXhpc0NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXJlbmRlciBheGlzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGRhdGEgZm9yIHJlbmRlcmluZ1xuICAgICAqL1xuICAgIHJlcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMuYXhpc0NvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICBpZiAodGhpcy5faXNWYWxpZEF4aXMoKSkge1xuICAgICAgICAgICAgaWYgKGRhdGEub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGRhdGEub3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJBeGlzQXJlYSh0aGlzLmF4aXNDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBheGlzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGRhdGEgZm9yIHJlbmRlcmluZ1xuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnJlcmVuZGVyKGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICovXG4gICAgem9vbTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnJlcmVuZGVyKGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGF4aXMgdG8gbGVmdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlja1NpemUgLSB0aWNrIHNpemUgZm9yIG1vdmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdmVUb0xlZnQ6IGZ1bmN0aW9uKHRpY2tTaXplKSB7XG4gICAgICAgIHZhciB0aWNrc0VsZW1lbnQgPSB0aGlzLnRpY2tzRWxlbWVudDtcbiAgICAgICAgdmFyIGZpcnN0VGlja0VsZW1lbnQgPSB0aWNrc0VsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIGxhYmVsQ29udGFpbmVyID0gdGhpcy5sYWJlbENvbnRhaW5lcjtcbiAgICAgICAgdmFyIGZpcnN0TGFiZWxFbGVtZW50ID0gbGFiZWxDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIHRpY2tzQmVmb3JlTGVmdCA9IHBhcnNlSW50KHRpY2tzRWxlbWVudC5zdHlsZS5sZWZ0LCAxMCkgfHwgMDtcbiAgICAgICAgdmFyIGxhYmVsQmVmb3JlTGVmdCA9IHBhcnNlSW50KGxhYmVsQ29udGFpbmVyLnN0eWxlLmxlZnQsIDEwKSB8fCAwO1xuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IHRoaXMuZGF0YS5zdGFydEluZGV4IHx8IDA7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5zdGFydEFuaW1hdGlvbigzMDAsIGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRpY2tTaXplICogcmF0aW87XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IDEgLSByYXRpbztcblxuICAgICAgICAgICAgdGlja3NFbGVtZW50LnN0eWxlLmxlZnQgPSAodGlja3NCZWZvcmVMZWZ0IC0gbGVmdCkgKyAncHgnO1xuICAgICAgICAgICAgbGFiZWxDb250YWluZXIuc3R5bGUubGVmdCA9IChsYWJlbEJlZm9yZUxlZnQgLSBsZWZ0KSArICdweCc7XG5cbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyVXRpbC5zZXRPcGFjaXR5KFtmaXJzdFRpY2tFbGVtZW50LCBmaXJzdExhYmVsRWxlbWVudF0sIG9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIGJ5IHRpY2sgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlja1NpemUgLSB0aWNrIHNpemUgZm9yIHJlc2l6aW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzaXplQnlUaWNrU2l6ZTogZnVuY3Rpb24odGlja1NpemUpIHtcbiAgICAgICAgdmFyIHRpY2tzRWxlbWVudCA9IHRoaXMudGlja3NFbGVtZW50O1xuICAgICAgICB2YXIgbGFiZWxDb250YWluZXIgPSB0aGlzLmxhYmVsQ29udGFpbmVyO1xuICAgICAgICB2YXIgYmVmb3JlV2lkdGggPSBwYXJzZUludCh0aWNrc0VsZW1lbnQuc3R5bGUud2lkdGgsIDEwKSB8fCB0aWNrc0VsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5zdGFydEFuaW1hdGlvbigzMDAsIGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBiZWZvcmVXaWR0aCAtICh0aWNrU2l6ZSAqIHJhdGlvKTtcblxuICAgICAgICAgICAgdGlja3NFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgbGFiZWxDb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGZvciBhZGRpbmcgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3t0aWNrU2l6ZTogbnVtYmVyfX0gZGF0YSAtIGRhdGEgZm9yIGFuaW1hdGVcbiAgICAgKi9cbiAgICBhbmltYXRlRm9yQWRkaW5nRGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5zaGlmdGluZykge1xuICAgICAgICAgICAgdGhpcy5fbW92ZVRvTGVmdChkYXRhLnRpY2tTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUJ5VGlja1NpemUoZGF0YS50aWNrU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjc3NUZXh0IGZyb20gcG9zaXRpb24gbWFwIGZvciBjc3MuXG4gICAgICogQHBhcmFtIHtvYmplY3QuPHN0cmluZywgbnVtYmVyPn0gcG9zaXRpb25NYXAgLSBwb3NpdGlvbiBtYXAgZm9yIGNzc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNzc1RleHRGcm9tUG9zaXRpb25NYXA6IGZ1bmN0aW9uKHBvc2l0aW9uTWFwKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2gocG9zaXRpb25NYXAsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcFtuYW1lXSA9IHZhbHVlICsgJ3B4JztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlclV0aWwubWFrZUNzc1RleHRGcm9tTWFwKHBvc2l0aW9uTWFwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwb3NpdGlvbiBtYXAgZm9yIGNlbnRlciBhbGlnbiBvcHRpb24gb2YgeSBheGlzLlxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBvc2l0aW9uTWFwRm9yQ2VudGVyQWxpZ246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGl0bGVXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKHRoaXMub3B0aW9ucy50aXRsZSwgdGhpcy50aGVtZS50aXRsZSk7XG4gICAgICAgIHZhciB5QXhpc1dpZHRoID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3lBeGlzJykud2lkdGg7XG4gICAgICAgIHZhciB4QXhpc0hlaWdodCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCd4QXhpcycpLmhlaWdodDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogKHlBeGlzV2lkdGggLSB0aXRsZVdpZHRoKSAvIDIsXG4gICAgICAgICAgICBib3R0b206IC14QXhpc0hlaWdodFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJpZ2h0IHBvc2l0aW9uIGZvciByaWdodCB5IGF4aXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSB3aWR0aCBvciBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VSaWdodFBvc2l0aW9uOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHZhciByaWdodFBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChyZW5kZXJVdGlsLmlzSUU3KCkgfHwgdGhpcy5vcHRpb25zLnJvdGF0ZVRpdGxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmlnaHRQb3NpdGlvbiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByaWdodFBvc2l0aW9uID0gLXNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmlnaHRQb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b3AgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSB3aWR0aCBvciBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7P251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9wUG9zaXRpb246IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHRvcFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdmFyIHRpdGxlSGVpZ2h0O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucm90YXRlVGl0bGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aXRsZUhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodCh0aGlzLm9wdGlvbnMudGl0bGUsIHRoaXMudGhlbWUudGl0bGUpO1xuICAgICAgICAgICAgdG9wUG9zaXRpb24gPSAoc2l6ZSAtIHRpdGxlSGVpZ2h0KSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmlzUG9zaXRpb25SaWdodCkge1xuICAgICAgICAgICAgdG9wUG9zaXRpb24gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKCFyZW5kZXJVdGlsLmlzT2xkQnJvd3NlcigpKSB7XG4gICAgICAgICAgICB0b3BQb3NpdGlvbiA9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9wUG9zaXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcG9zaXRpb25NYXAgZm9yIG5vdCBjZW50ZXIgYWxpZ24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSB3aWR0aCBvciBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBvc2l0aW9uTWFwRm9yTm90Q2VudGVyQWxpZ246IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uTWFwID0ge307XG4gICAgICAgIHZhciB0b3BQb3NpdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5kYXRhLmlzUG9zaXRpb25SaWdodCkge1xuICAgICAgICAgICAgcG9zaXRpb25NYXAucmlnaHQgPSB0aGlzLl9tYWtlUmlnaHRQb3NpdGlvbihzaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLmxlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9wUG9zaXRpb24gPSB0aGlzLl9tYWtlVG9wUG9zaXRpb24oc2l6ZSk7XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc051bGwodG9wUG9zaXRpb24pKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC50b3AgPSB0b3BQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbk1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGNzcyBzdHlsZSBvZiB0aXRsZSBhcmVhXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGl0bGVDb250YWluZXIgdGl0bGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHdpZHRoIG9yIGhlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclRpdGxlQXJlYVN0eWxlOiBmdW5jdGlvbih0aXRsZUNvbnRhaW5lciwgc2l6ZSkge1xuICAgICAgICB2YXIgY3NzUG9zaXRpb25NYXA7XG4gICAgICAgIHZhciBjc3NUZXh0O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNDZW50ZXIpIHtcbiAgICAgICAgICAgIGNzc1Bvc2l0aW9uTWFwID0gdGhpcy5fbWFrZVBvc2l0aW9uTWFwRm9yQ2VudGVyQWxpZ24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzc1Bvc2l0aW9uTWFwID0gdGhpcy5fbWFrZVBvc2l0aW9uTWFwRm9yTm90Q2VudGVyQWxpZ24oc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJvdGF0ZVRpdGxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgY3NzUG9zaXRpb25NYXAud2lkdGggPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX21ha2VDc3NUZXh0RnJvbVBvc2l0aW9uTWFwKGNzc1Bvc2l0aW9uTWFwKTtcbiAgICAgICAgdGl0bGVDb250YWluZXIuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBjc3NUZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaXRsZSBhcmVhIHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB0aXRsZSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyVGl0bGVBcmVhOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHZhciB0aXRsZUNvbnRhaW5lciA9IHJlbmRlclV0aWwucmVuZGVyVGl0bGUodGhpcy5vcHRpb25zLnRpdGxlLCB0aGlzLnRoZW1lLnRpdGxlLCAndHVpLWNoYXJ0LXRpdGxlLWFyZWEnKTtcblxuICAgICAgICBpZiAodGl0bGVDb250YWluZXIgJiYgdGhpcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUaXRsZUFyZWFTdHlsZSh0aXRsZUNvbnRhaW5lciwgc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJvdGF0ZVRpdGxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZG9tLmFkZENsYXNzKHRpdGxlQ29udGFpbmVyLCAncm90YXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aXRsZUNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aWNrIGxpbmUgaHRtbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJlYVNpemUgLSBhcmVhIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zVHlwZSAtIHBvc2l0aW9uIHR5cGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTm90RGl2aWRlZFhBeGlzIC0gd2hldGhlciBub3QgZGl2aWRlZCB4QXhpcyBvciBub3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkaXRpb25hbFNpemUgLSBhZGRpdGlvbmFsIHNpemVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUaWNrTGluZUh0bWw6IGZ1bmN0aW9uKGFyZWFTaXplLCBwb3NUeXBlLCBpc05vdERpdmlkZWRYQXhpcywgYWRkaXRpb25hbFNpemUpIHtcbiAgICAgICAgdmFyIHRpY2tMaW5lRXh0ZW5kID0gaXNOb3REaXZpZGVkWEF4aXMgPyBjaGFydENvbnN0Lk9WRVJMQVBQSU5HX1dJRFRIIDogMDtcbiAgICAgICAgdmFyIGxpbmVQb3NpdGlvblZhbHVlID0gLXRpY2tMaW5lRXh0ZW5kO1xuICAgICAgICB2YXIgbGluZVNpemUsIGh0bWw7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgIGxpbmVTaXplID0gdGhpcy5kYXRhLmxpbmVXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVTaXplID0gYXJlYVNpemUgKyB0aWNrTGluZUV4dGVuZDtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblZhbHVlICs9IGFkZGl0aW9uYWxTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaHRtbCA9IGF4aXNUZW1wbGF0ZS50cGxUaWNrTGluZSh7XG4gICAgICAgICAgICBwb3NpdGlvblR5cGU6IHBvc1R5cGUsXG4gICAgICAgICAgICBwb3NpdGlvblZhbHVlOiBsaW5lUG9zaXRpb25WYWx1ZSxcbiAgICAgICAgICAgIHNpemVUeXBlOiB0aGlzLmlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCcsXG4gICAgICAgICAgICBzaXplOiBsaW5lU2l6ZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwZXJjZW50YWdlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvc2l0aW9ucyAtIHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmVhU2l6ZSAtIGFyZWEgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUGVyY2VudGFnZVBvc2l0aW9uczogZnVuY3Rpb24ocG9zaXRpb25zLCBhcmVhU2l6ZSkge1xuICAgICAgICBhcmVhU2l6ZSA9IHRoaXMuY29udGFpbmVyV2lkdGggfHwgYXJlYVNpemU7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRvci5tYWtlUGVyY2VudGFnZVZhbHVlKHBvc2l0aW9uLCBhcmVhU2l6ZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRpY2sgaHRtbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIGFyZWEgc2l6ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgLSB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc05vdERpdmlkZWRYQXhpcyAtIHdoZXRoZXIgbm90IGRpdmlkZWQgeEF4aXMgb3Igbm90XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGl0aW9uYWxTaXplIC0gYWRkaXRpb25hbCBzaXplXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVGlja0h0bWw6IGZ1bmN0aW9uKHNpemUsIHRpY2tDb3VudCwgaXNOb3REaXZpZGVkWEF4aXMsIGFkZGl0aW9uYWxTaXplKSB7XG4gICAgICAgIHZhciB0aWNrQ29sb3IgPSB0aGlzLnRoZW1lLnRpY2tDb2xvcjtcbiAgICAgICAgdmFyIHNpemVSYXRpbyA9IHRoaXMuZGF0YS5zaXplUmF0aW8gfHwgMTtcbiAgICAgICAgdmFyIHBvc1R5cGUgPSB0aGlzLmlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdsZWZ0JztcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGNhbGN1bGF0b3IubWFrZVRpY2tQaXhlbFBvc2l0aW9ucygoc2l6ZSAqIHNpemVSYXRpbyksIHRpY2tDb3VudCk7XG4gICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IHRoaXMuY29udGFpbmVyV2lkdGggfHwgc2l6ZTtcbiAgICAgICAgdmFyIHRlbXBsYXRlLCBodG1sO1xuXG4gICAgICAgIHBvc2l0aW9ucy5sZW5ndGggPSB0aGlzLmRhdGEubGFiZWxzLmxlbmd0aDtcblxuICAgICAgICBhZGRpdGlvbmFsU2l6ZSA9IGNhbGN1bGF0b3IubWFrZVBlcmNlbnRhZ2VWYWx1ZShhZGRpdGlvbmFsU2l6ZSwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICBwb3NpdGlvbnMgPSB0aGlzLl9tYWtlUGVyY2VudGFnZVBvc2l0aW9ucyhwb3NpdGlvbnMsIHNpemUpO1xuXG4gICAgICAgIHRlbXBsYXRlID0gYXhpc1RlbXBsYXRlLnRwbEF4aXNUaWNrO1xuICAgICAgICBodG1sID0gdHVpLnV0aWwubWFwKHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdGlja0h0bWwsIGNzc1RleHRzO1xuXG4gICAgICAgICAgICBwb3NpdGlvbiAtPSAoaW5kZXggPT09IDAgJiYgaXNOb3REaXZpZGVkWEF4aXMpID8gY2FsY3VsYXRvci5tYWtlUGVyY2VudGFnZVZhbHVlKDEsIGNvbnRhaW5lcldpZHRoKSA6IDA7XG5cbiAgICAgICAgICAgIGNzc1RleHRzID0gW1xuICAgICAgICAgICAgICAgIHJlbmRlclV0aWwuY29uY2F0U3RyKCdiYWNrZ3JvdW5kLWNvbG9yOicsIHRpY2tDb2xvciksXG4gICAgICAgICAgICAgICAgcmVuZGVyVXRpbC5jb25jYXRTdHIocG9zVHlwZSwgJzogJywgYWRkaXRpb25hbFNpemUgKyBwb3NpdGlvbiwgJyUnKVxuICAgICAgICAgICAgXS5qb2luKCc7Jyk7XG4gICAgICAgICAgICB0aWNrSHRtbCA9IHRlbXBsYXRlKHtjc3NUZXh0OiBjc3NUZXh0c30pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGlja0h0bWw7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuXG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGljayBsaW5lLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmVhU2l6ZSAtIHdpZHRoIG9yIGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNOb3REaXZpZGVkWEF4aXMgLSB3aGV0aGVyIGlzIG5vdCBkaXZpZGVkIHggYXhpcyBvciBub3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGl0aW9uYWxTaXplIC0gYWRkaXRpb25hbCBzaXplXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclRpY2tMaW5lOiBmdW5jdGlvbihhcmVhU2l6ZSwgaXNOb3REaXZpZGVkWEF4aXMsIGFkZGl0aW9uYWxTaXplKSB7XG4gICAgICAgIHZhciB0aWNrTGluZUVsZW1lbnQgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LXRpY2stbGluZScpO1xuICAgICAgICB2YXIgdGlja0xpbmVFeHRlbmQgPSBpc05vdERpdmlkZWRYQXhpcyA/IGNoYXJ0Q29uc3QuT1ZFUkxBUFBJTkdfV0lEVEggOiAwO1xuICAgICAgICB2YXIgcG9zaXRpb25WYWx1ZSA9IC10aWNrTGluZUV4dGVuZDtcbiAgICAgICAgdmFyIGNzc01hcCA9IHt9O1xuICAgICAgICB2YXIgc2l6ZVR5cGUsIHBvc1R5cGUsIGxpbmVTaXplO1xuXG4gICAgICAgIGlmICh0aGlzLmlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHNpemVUeXBlID0gJ2hlaWdodCc7XG4gICAgICAgICAgICBwb3NUeXBlID0gJ2JvdHRvbSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplVHlwZSA9ICd3aWR0aCc7XG4gICAgICAgICAgICBwb3NUeXBlID0gJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgIGxpbmVTaXplID0gdGhpcy5kYXRhLmxpbmVXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVTaXplID0gYXJlYVNpemUgKyB0aWNrTGluZUV4dGVuZDtcbiAgICAgICAgICAgIHBvc2l0aW9uVmFsdWUgKz0gYWRkaXRpb25hbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBjc3NNYXBbcG9zVHlwZV0gPSBwb3NpdGlvblZhbHVlO1xuICAgICAgICBjc3NNYXBbc2l6ZVR5cGVdID0gbGluZVNpemU7XG5cbiAgICAgICAgdGlja0xpbmVFbGVtZW50LnN0eWxlLmNzc1RleHQgPSB0aGlzLl9tYWtlQ3NzVGV4dEZyb21Qb3NpdGlvbk1hcChjc3NNYXApO1xuXG4gICAgICAgIHJldHVybiB0aWNrTGluZUVsZW1lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aWNrcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJlYVNpemUgLSB3aWR0aCBvciBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlja0NvdW50IC0gdGljayBjb3VudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNOb3REaXZpZGVkWEF4aXMgLSB3aGV0aGVyIGlzIG5vdCBkaXZpZGVkIHggYXhpcyBvciBub3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGl0aW9uYWxTaXplIC0gYWRkaXRpb25hbCBzaXplXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclRpY2tzOiBmdW5jdGlvbihhcmVhU2l6ZSwgdGlja0NvdW50LCBpc05vdERpdmlkZWRYQXhpcywgYWRkaXRpb25hbFNpemUpIHtcbiAgICAgICAgdmFyIHRpY2tzRWxlbWVudCA9IGRvbS5jcmVhdGUoJ0RJVicsICd0dWktY2hhcnQtdGlja3MnKTtcbiAgICAgICAgdmFyIHRpY2tzSHRtbCA9IHRoaXMuX21ha2VUaWNrSHRtbChhcmVhU2l6ZSwgdGlja0NvdW50LCBpc05vdERpdmlkZWRYQXhpcywgYWRkaXRpb25hbFNpemUpO1xuXG4gICAgICAgIHRpY2tzRWxlbWVudC5pbm5lckhUTUwgPSB0aWNrc0h0bWw7XG5cbiAgICAgICAgcmV0dXJuIHRpY2tzRWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRpY2sgYXJlYS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIHdpZHRoIG9yIGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgLSB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBhZGRpdGlvbmFsU2l6ZSAtIGFkZGl0aW9uYWwgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJUaWNrQXJlYTogZnVuY3Rpb24oc2l6ZSwgdGlja0NvdW50LCBhZGRpdGlvbmFsU2l6ZSkge1xuICAgICAgICB2YXIgdGlja0NvbnRhaW5lciA9IGRvbS5jcmVhdGUoJ0RJVicsICd0dWktY2hhcnQtdGljay1hcmVhJyk7XG4gICAgICAgIHZhciBpc05vdERpdmlkZWRYQXhpcyA9ICF0aGlzLmlzVmVydGljYWwgJiYgIXRoaXMub3B0aW9ucy5kaXZpZGVkO1xuICAgICAgICB2YXIgdGlja0xpbmVFbGVtZW50LCB0aWNrc0VsZW1lbnQ7XG5cbiAgICAgICAgYWRkaXRpb25hbFNpemUgPSBhZGRpdGlvbmFsU2l6ZSB8fCAwO1xuICAgICAgICB0aWNrTGluZUVsZW1lbnQgPSB0aGlzLl9yZW5kZXJUaWNrTGluZShzaXplLCBpc05vdERpdmlkZWRYQXhpcywgYWRkaXRpb25hbFNpemUpO1xuICAgICAgICB0aWNrc0VsZW1lbnQgPSB0aGlzLl9yZW5kZXJUaWNrcyhzaXplLCB0aWNrQ291bnQsIGlzTm90RGl2aWRlZFhBeGlzLCBhZGRpdGlvbmFsU2l6ZSk7XG4gICAgICAgIGRvbS5hcHBlbmQodGlja0NvbnRhaW5lciwgdGlja0xpbmVFbGVtZW50KTtcbiAgICAgICAgZG9tLmFwcGVuZCh0aWNrQ29udGFpbmVyLCB0aWNrc0VsZW1lbnQpO1xuXG4gICAgICAgIHRoaXMudGlja3NFbGVtZW50ID0gdGlja3NFbGVtZW50O1xuXG4gICAgICAgIHJldHVybiB0aWNrQ29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNzc1RleHQgb2YgdmVydGljYWwgbGFiZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNXaWR0aCBheGlzIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpdGxlQXJlYVdpZHRoIHRpdGxlIGFyZWEgd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjc3NUZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsTGFiZWxDc3NUZXh0OiBmdW5jdGlvbihheGlzV2lkdGgsIHRpdGxlQXJlYVdpZHRoKSB7XG4gICAgICAgIHJldHVybiAnO3dpZHRoOicgKyAoYXhpc1dpZHRoIC0gdGl0bGVBcmVhV2lkdGggKyBjaGFydENvbnN0LlZfTEFCRUxfUklHSFRfUEFERElORykgKyAncHgnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBjc3Mgc3R5bGUgb2YgbGFiZWwgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBsYWJlbENvbnRhaW5lciBsYWJlbCBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc1dpZHRoIGF4aXMgd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hcHBseUxhYmVsQXJlYVN0eWxlOiBmdW5jdGlvbihsYWJlbENvbnRhaW5lciwgYXhpc1dpZHRoKSB7XG4gICAgICAgIHZhciBjc3NUZXh0ID0gcmVuZGVyVXRpbC5tYWtlRm9udENzc1RleHQodGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICB0aXRsZUFyZWFXaWR0aDtcblxuICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aXRsZUFyZWFXaWR0aCA9IHRoaXMuX2dldFJlbmRlcmVkVGl0bGVIZWlnaHQoKSArIGNoYXJ0Q29uc3QuVElUTEVfQVJFQV9XSURUSF9QQURESU5HO1xuICAgICAgICAgICAgY3NzVGV4dCArPSB0aGlzLl9tYWtlVmVydGljYWxMYWJlbENzc1RleHQoYXhpc1dpZHRoLCB0aXRsZUFyZWFXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbENvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxhYmVsIGFyZWEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgbGFiZWwgYXJlYSBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNXaWR0aCBheGlzIGFyZWEgd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlja0NvdW50IHRpY2sgY291bnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjYXRlZ29yaWVzIGNhdGVnb3JpZXNcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGFkZGl0aW9uYWxTaXplIGFkZGl0aW9uYWwgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTGFiZWxBcmVhOiBmdW5jdGlvbihzaXplLCBheGlzV2lkdGgsIHRpY2tDb3VudCwgY2F0ZWdvcmllcywgYWRkaXRpb25hbFNpemUpIHtcbiAgICAgICAgdmFyIGxhYmVsQ29udGFpbmVyID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1sYWJlbC1hcmVhJyk7XG4gICAgICAgIHZhciBzaXplUmF0aW8gPSB0aGlzLmRhdGEuc2l6ZVJhdGlvIHx8IDE7XG4gICAgICAgIHZhciB0aWNrUGl4ZWxQb3NpdGlvbnMgPSBjYWxjdWxhdG9yLm1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMoKHNpemUgKiBzaXplUmF0aW8pLCB0aWNrQ291bnQpO1xuICAgICAgICB2YXIgbGFiZWxTaXplID0gdGlja1BpeGVsUG9zaXRpb25zWzFdIC0gdGlja1BpeGVsUG9zaXRpb25zWzBdO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gdGhpcy5jb250YWluZXJXaWR0aCB8fCBzaXplO1xuICAgICAgICB2YXIgbGFiZWxzSHRtbDtcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzVmFsaWRMYWJlbEludGVydmFsKG9wdGlvbnMubGFiZWxJbnRlcnZhbCwgb3B0aW9ucy50aWNrSW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICBsYWJlbFNpemUgKj0gb3B0aW9ucy5sYWJlbEludGVydmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkaXRpb25hbFNpemUgPSBhZGRpdGlvbmFsU2l6ZSA/IGNhbGN1bGF0b3IubWFrZVBlcmNlbnRhZ2VWYWx1ZShhZGRpdGlvbmFsU2l6ZSwgY29udGFpbmVyV2lkdGgpIDogMDtcbiAgICAgICAgbGFiZWxzSHRtbCA9IHRoaXMuX21ha2VMYWJlbHNIdG1sKHNpemUsIHRpY2tQaXhlbFBvc2l0aW9ucywgY2F0ZWdvcmllcywgbGFiZWxTaXplLCBhZGRpdGlvbmFsU2l6ZSk7XG4gICAgICAgIGxhYmVsQ29udGFpbmVyLmlubmVySFRNTCA9IGxhYmVsc0h0bWw7XG5cbiAgICAgICAgdGhpcy5fYXBwbHlMYWJlbEFyZWFTdHlsZShsYWJlbENvbnRhaW5lciwgYXhpc1dpZHRoKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlTGFiZWxBcmVhUG9zaXRpb24obGFiZWxDb250YWluZXIsIGxhYmVsU2l6ZSk7XG5cbiAgICAgICAgdGhpcy5sYWJlbENvbnRhaW5lciA9IGxhYmVsQ29udGFpbmVyO1xuXG4gICAgICAgIHJldHVybiBsYWJlbENvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGhlaWdodCBvZiB0aXRsZSBhcmVhIDtcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRSZW5kZXJlZFRpdGxlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlLFxuICAgICAgICAgICAgdGhlbWUgPSB0aGlzLnRoZW1lLnRpdGxlLFxuICAgICAgICAgICAgcmVzdWx0ID0gdGl0bGUgPyByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQodGl0bGUsIHRoZW1lKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjc3NUZXh0IG9mIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbFNpemUgbGFiZWwgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gY3NzVGV4dHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxDc3NUZXh0OiBmdW5jdGlvbihsYWJlbFNpemUpIHtcbiAgICAgICAgdmFyIGlzVmVydGljYWwgPSB0aGlzLmlzVmVydGljYWw7XG4gICAgICAgIHZhciBjc3NUZXh0cyA9IFtdO1xuXG4gICAgICAgIGlmIChpc1ZlcnRpY2FsICYmIHRoaXMuaXNMYWJlbCkge1xuICAgICAgICAgICAgY3NzVGV4dHMucHVzaChyZW5kZXJVdGlsLmNvbmNhdFN0cignaGVpZ2h0OicsIGxhYmVsU2l6ZSwgJ3B4JykpO1xuICAgICAgICAgICAgY3NzVGV4dHMucHVzaChyZW5kZXJVdGlsLmNvbmNhdFN0cignbGluZS1oZWlnaHQ6JywgbGFiZWxTaXplLCAncHgnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIGNzc1RleHRzLnB1c2gocmVuZGVyVXRpbC5jb25jYXRTdHIoJ3dpZHRoOicsIGxhYmVsU2l6ZSwgJ3B4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNzc1RleHRzLmxlbmd0aCA/IGNzc1RleHRzLmpvaW4oJzsnKSArICc7JyA6ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgcm90YXRpb24gbW92aW5nIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGVmdCBub3JtYWwgbGVmdFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tb3ZlTGVmdCBtb3ZlIGxlZnRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudG9wIHRvcFxuICAgICAqIEByZXR1cm5zIHt7dG9wOm51bWJlciwgbGVmdDogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVSb3RhdGlvbk1vdmluZ1Bvc2l0aW9uOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIG1vdmVMZWZ0ID0gcGFyYW1zLm1vdmVMZWZ0O1xuICAgICAgICB2YXIgZGVncmVlID0gdGhpcy5ib3VuZHNNYWtlci54QXhpc0RlZ3JlZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gdGhpcy5jb250YWluZXJXaWR0aCB8fCBwYXJhbXMuc2l6ZTtcblxuICAgICAgICBpZiAoZGVncmVlID09PSBjaGFydENvbnN0LkFOR0xFXzg1KSB7XG4gICAgICAgICAgICBtb3ZlTGVmdCArPSBjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KGNoYXJ0Q29uc3QuQU5HTEVfOTAgLSBkZWdyZWUsIHBhcmFtcy5sYWJlbEhlaWdodCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogcGFyYW1zLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHBhcmFtcy5sZWZ0IC0gY2FsY3VsYXRvci5tYWtlUGVyY2VudGFnZVZhbHVlKG1vdmVMZWZ0LCBjb250YWluZXJXaWR0aClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHJvdGF0aW9uIG1vdmluZyBwb3NpdGlvbiBmb3Igb2xkIGJyb3dzZXIoSUU3LCBJRTgpLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbFdpZHRoIGxhYmVsIHdpZHRoXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sZWZ0IG5vcm1hbCBsZWZ0XG4gICAgICogICAgICBAcGFyYW0geyhzdHJpbmcgfCBudW1iZXIpfSBwYXJhbXMubGFiZWwgbGFiZWxcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBsYWJlbCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHt7dG9wOm51bWJlciwgbGVmdDogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVSb3RhdGlvbk1vdmluZ1Bvc2l0aW9uRm9yT2xkQnJvd3NlcjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgocGFyYW1zLmxhYmVsLCBwYXJhbXMudGhlbWUpO1xuICAgICAgICB2YXIgZGVncmVlID0gdGhpcy5ib3VuZHNNYWtlci54QXhpc0RlZ3JlZTtcbiAgICAgICAgdmFyIHNtYWxsQXJlYVdpZHRoID0gY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudChjaGFydENvbnN0LkFOR0xFXzkwIC0gZGVncmVlLCBwYXJhbXMubGFiZWxIZWlnaHQgLyAyKTtcbiAgICAgICAgdmFyIG5ld0xhYmVsV2lkdGggPSAoY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudChkZWdyZWUsIGxhYmVsV2lkdGggLyAyKSArIHNtYWxsQXJlYVdpZHRoKSAqIDI7XG4gICAgICAgIHZhciBjaGFuZ2VkV2lkdGggPSByZW5kZXJVdGlsLmlzSUU3KCkgPyAwIDogKGxhYmVsV2lkdGggLSBuZXdMYWJlbFdpZHRoKTtcbiAgICAgICAgdmFyIG1vdmVMZWZ0ID0gKHBhcmFtcy5sYWJlbFdpZHRoIC8gMikgLSAoc21hbGxBcmVhV2lkdGggKiAyKTtcbiAgICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gdGhpcy5jb250YWluZXJXaWR0aCB8fCBwYXJhbXMuc2l6ZTtcblxuICAgICAgICBpZiAoZGVncmVlID09PSBjaGFydENvbnN0LkFOR0xFXzg1KSB7XG4gICAgICAgICAgICBtb3ZlTGVmdCArPSBzbWFsbEFyZWFXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IGNoYXJ0Q29uc3QuWEFYSVNfTEFCRUxfVE9QX01BUkdJTixcbiAgICAgICAgICAgIGxlZnQ6IHBhcmFtcy5sZWZ0ICsgY2FsY3VsYXRvci5tYWtlUGVyY2VudGFnZVZhbHVlKGNoYW5nZWRXaWR0aCAtIG1vdmVMZWZ0LCBjb250YWluZXJXaWR0aClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjc3NUZXh0IGZvciByb3RhdGlvbiBtb3ZpbmcuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxhYmVsV2lkdGggbGFiZWwgd2lkdGhcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxlZnQgbm9ybWFsIGxlZnRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubW92ZUxlZnQgbW92ZSBsZWZ0XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnRvcCB0b3BcbiAgICAgKiAgICAgIEBwYXJhbSB7KHN0cmluZyB8IG51bWJlcil9IHBhcmFtcy5sYWJlbCBsYWJlbFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY3NzVGV4dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDc3NUZXh0Rm9yUm90YXRpb25Nb3Zpbmc6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgcG9zaXRpb247XG5cbiAgICAgICAgaWYgKHJlbmRlclV0aWwuaXNPbGRCcm93c2VyKCkpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fY2FsY3VsYXRlUm90YXRpb25Nb3ZpbmdQb3NpdGlvbkZvck9sZEJyb3dzZXIocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fY2FsY3VsYXRlUm90YXRpb25Nb3ZpbmdQb3NpdGlvbihwYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlclV0aWwuY29uY2F0U3RyKCdsZWZ0OicsIHBvc2l0aW9uLmxlZnQsICclJywgJzt0b3A6JywgcG9zaXRpb24udG9wLCAncHgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBodG1sIG9mIHJvdGF0aW9uIGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJlYVNpemUgLSBhcmVhIHNpemUuXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gcG9zaXRpb25zIGxhYmVsIHBvc2l0aW9uIGFycmF5XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY2F0ZWdvcmllcyBjYXRlZ29yaWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsU2l6ZSBsYWJlbCBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGl0aW9uYWxTaXplIGFkZGl0aW9uYWwgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGxhYmVscyBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVJvdGF0aW9uTGFiZWxzSHRtbDogZnVuY3Rpb24oYXJlYVNpemUsIHBvc2l0aW9ucywgY2F0ZWdvcmllcywgbGFiZWxTaXplLCBhZGRpdGlvbmFsU2l6ZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkZWdyZWUgPSB0aGlzLmJvdW5kc01ha2VyLnhBeGlzRGVncmVlO1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBheGlzVGVtcGxhdGUudHBsQXhpc0xhYmVsO1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQoY2F0ZWdvcmllc1swXSwgdGhpcy50aGVtZS5sYWJlbCk7XG4gICAgICAgIHZhciBsYWJlbENzc1RleHQgPSB0aGlzLl9tYWtlTGFiZWxDc3NUZXh0KGxhYmVsU2l6ZSk7XG4gICAgICAgIHZhciBhZGRpdGlvbmFsQ2xhc3MgPSAnIHR1aS1jaGFydC14YXhpcy1yb3RhdGlvbiB0dWktY2hhcnQteGF4aXMtcm90YXRpb24nICsgZGVncmVlO1xuICAgICAgICB2YXIgaGFsZldpZHRoID0gbGFiZWxTaXplIC8gMjtcbiAgICAgICAgdmFyIG1vdmVMZWZ0ID0gY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudChkZWdyZWUsIGhhbGZXaWR0aCk7XG4gICAgICAgIHZhciB0b3AgPSBjYWxjdWxhdG9yLmNhbGN1bGF0ZU9wcG9zaXRlKGRlZ3JlZSwgaGFsZldpZHRoKSArIGNoYXJ0Q29uc3QuWEFYSVNfTEFCRUxfVE9QX01BUkdJTjtcbiAgICAgICAgdmFyIHNwYW5Dc3NUZXh0ID0gKHJlbmRlclV0aWwuaXNJRTcoKSAmJiBkZWdyZWUpID8gY2hhcnRDb25zdC5JRTdfUk9UQVRJT05fRklMVEVSX1NUWUxFX01BUFtkZWdyZWVdIDogJyc7XG4gICAgICAgIHZhciBsYWJlbHNIdG1sO1xuXG4gICAgICAgIGFkZGl0aW9uYWxTaXplID0gYWRkaXRpb25hbFNpemUgfHwgMDtcbiAgICAgICAgbGFiZWxzSHRtbCA9IHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gY2F0ZWdvcmllc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgcm90YXRpb25Dc3NUZXh0ID0gc2VsZi5fbWFrZUNzc1RleHRGb3JSb3RhdGlvbk1vdmluZyh7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGFyZWFTaXplLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbEhlaWdodDogbGFiZWxIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsV2lkdGg6IGxhYmVsU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uICsgYWRkaXRpb25hbFNpemUsXG4gICAgICAgICAgICAgICAgICAgIG1vdmVMZWZ0OiBtb3ZlTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICB0aGVtZTogc2VsZi50aGVtZS5sYWJlbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxDbGFzczogYWRkaXRpb25hbENsYXNzLFxuICAgICAgICAgICAgICAgIGNzc1RleHQ6IGxhYmVsQ3NzVGV4dCArIHJvdGF0aW9uQ3NzVGV4dCxcbiAgICAgICAgICAgICAgICBzcGFuQ3NzVGV4dDogc3BhbkNzc1RleHQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsc0h0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaHRtbCBvZiBub3JtYWwgbGFiZWxzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHBvc2l0aW9ucyBsYWJlbCBwb3NpdGlvbiBhcnJheVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGNhdGVnb3JpZXMgY2F0ZWdvcmllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbFNpemUgbGFiZWwgc2l6ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRpdGlvbmFsU2l6ZSBhZGRpdGlvbmFsIHNpemVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBsYWJlbHMgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VOb3JtYWxMYWJlbHNIdG1sOiBmdW5jdGlvbihwb3NpdGlvbnMsIGNhdGVnb3JpZXMsIGxhYmVsU2l6ZSwgYWRkaXRpb25hbFNpemUpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gYXhpc1RlbXBsYXRlLnRwbEF4aXNMYWJlbCxcbiAgICAgICAgICAgIGxhYmVsQ3NzVGV4dCA9IHRoaXMuX21ha2VMYWJlbENzc1RleHQobGFiZWxTaXplKSxcbiAgICAgICAgICAgIHBvc1R5cGUsIGxhYmVsc0h0bWw7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgcG9zVHlwZSA9IHRoaXMuaXNMYWJlbCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NUeXBlID0gJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWxzSHRtbCA9IHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGFkZENzc1RleHQgPSByZW5kZXJVdGlsLmNvbmNhdFN0cihwb3NUeXBlLCAnOicsIChwb3NpdGlvbiArIGFkZGl0aW9uYWxTaXplKSwgJyUnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQ2xhc3M6ICcnLFxuICAgICAgICAgICAgICAgIGNzc1RleHQ6IGxhYmVsQ3NzVGV4dCArIGFkZENzc1RleHQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGNhdGVnb3JpZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIHNwYW5Dc3NUZXh0OiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuXG4gICAgICAgIHJldHVybiBsYWJlbHNIdG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxhYmVscyBodG1sLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmVhU2l6ZSAtIGFyZWEgc2l6ZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHBvc2l0aW9ucyAtIHBvc2l0aW9ucyBmb3IgbGFiZWxzXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY2F0ZWdvcmllcyAtIGNhdGVnb3JpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxTaXplIGxhYmVsIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkaXRpb25hbFNpemUgYWRkaXRpb25hbCBzaXplXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbGFiZWxzIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxzSHRtbDogZnVuY3Rpb24oYXJlYVNpemUsIHBvc2l0aW9ucywgY2F0ZWdvcmllcywgbGFiZWxTaXplLCBhZGRpdGlvbmFsU2l6ZSkge1xuICAgICAgICB2YXIgaXNSb3RhdGlvbmxlc3NYQXhpcyA9ICF0aGlzLmlzVmVydGljYWwgJiYgdGhpcy5pc0xhYmVsICYmIHRoaXMub3B0aW9ucy5yb3RhdGVMYWJlbCA9PT0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNSb3RhdGVkWEF4aXNMYWJlbCA9IHRoaXMuY29tcG9uZW50TmFtZSA9PT0gJ3hBeGlzJyAmJiB0aGlzLmJvdW5kc01ha2VyLnhBeGlzRGVncmVlO1xuICAgICAgICB2YXIgbGFiZWxzSHRtbDtcblxuICAgICAgICBpZiAoaXNSb3RhdGlvbmxlc3NYQXhpcykge1xuICAgICAgICAgICAgY2F0ZWdvcmllcyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRNdWx0aWxpbmVDYXRlZ29yaWVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2F0ZWdvcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5sZW5ndGggPSBjYXRlZ29yaWVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9ucyA9IHRoaXMuX21ha2VQZXJjZW50YWdlUG9zaXRpb25zKHBvc2l0aW9ucywgYXJlYVNpemUpO1xuXG4gICAgICAgIGlmIChoYXNSb3RhdGVkWEF4aXNMYWJlbCkge1xuICAgICAgICAgICAgbGFiZWxzSHRtbCA9IHRoaXMuX21ha2VSb3RhdGlvbkxhYmVsc0h0bWwoYXJlYVNpemUsIHBvc2l0aW9ucywgY2F0ZWdvcmllcywgbGFiZWxTaXplLCBhZGRpdGlvbmFsU2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYWJlbHNIdG1sID0gdGhpcy5fbWFrZU5vcm1hbExhYmVsc0h0bWwocG9zaXRpb25zLCBjYXRlZ29yaWVzLCBsYWJlbFNpemUsIGFkZGl0aW9uYWxTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYWJlbHNIdG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgcG9zaXRpb24gb2YgbGFiZWwgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBsYWJlbENvbnRhaW5lciBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxTaXplIGxhYmVsIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGFuZ2VMYWJlbEFyZWFQb3NpdGlvbjogZnVuY3Rpb24obGFiZWxDb250YWluZXIsIGxhYmVsU2l6ZSkge1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNMYWJlbCAmJiAhdGhpcy5kYXRhLmFsaWduZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KCdBQkMnLCB0aGlzLnRoZW1lLmxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsQ29udGFpbmVyLnN0eWxlLnRvcCA9IHJlbmRlclV0aWwuY29uY2F0U3RyKHBhcnNlSW50KGxhYmVsSGVpZ2h0IC8gMiwgMTApLCAncHgnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsQ29udGFpbmVyLnN0eWxlLmxlZnQgPSByZW5kZXJVdGlsLmNvbmNhdFN0cignLScsIHBhcnNlSW50KGxhYmVsU2l6ZSAvIDIsIDEwKSwgJ3B4Jyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgaXMgdGVtcGxhdGVzIG9yIGF4aXMgdmlldy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVtcGxhdGVNYWtlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdGVtcGxhdGVNYWtlcicpO1xuXG52YXIgaHRtbHMgPSB7XG4gICAgSFRNTF9BWElTX1RJQ0tfTElORTogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtdGljay1saW5lXCInICtcbiAgICAgICAgJyBzdHlsZT1cInt7IHBvc2l0aW9uVHlwZSB9fTp7eyBwb3NpdGlvblZhbHVlIH19cHg7e3sgc2l6ZVR5cGUgfX06e3sgc2l6ZSB9fXB4XCI+PC9kaXY+JyxcbiAgICBIVE1MX0FYSVNfVElDSzogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtdGlja1wiIHN0eWxlPVwie3sgY3NzVGV4dCB9fVwiPjwvZGl2PicsXG4gICAgSFRNTF9BWElTX0xBQkVMOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1sYWJlbHt7IGFkZGl0aW9uYWxDbGFzcyB9fVwiIHN0eWxlPVwie3sgY3NzVGV4dCB9fVwiPicgK1xuICAgICAgICAnPHNwYW57eyBzcGFuQ3NzVGV4dCB9fT57eyBsYWJlbCB9fTwvc3Bhbj48L2Rpdj4nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0cGxUaWNrTGluZTogdGVtcGxhdGVNYWtlci50ZW1wbGF0ZShodG1scy5IVE1MX0FYSVNfVElDS19MSU5FKSxcbiAgICB0cGxBeGlzVGljazogdGVtcGxhdGVNYWtlci50ZW1wbGF0ZShodG1scy5IVE1MX0FYSVNfVElDSyksXG4gICAgdHBsQXhpc0xhYmVsOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfQVhJU19MQUJFTClcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgY2hhcnQuanMgaXMgZW50cnkgcG9pbnQgb2YgVG9hc3QgVUkgQ2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG52YXIgY2hhcnRGYWN0b3J5ID0gcmVxdWlyZSgnLi9mYWN0b3JpZXMvY2hhcnRGYWN0b3J5Jyk7XG52YXIgcGx1Z2luRmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yaWVzL3BsdWdpbkZhY3RvcnknKTtcbnZhciB0aGVtZUZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3Rvcmllcy90aGVtZUZhY3RvcnknKTtcbnZhciBtYXBGYWN0b3J5ID0gcmVxdWlyZSgnLi9mYWN0b3JpZXMvbWFwRmFjdG9yeScpO1xuXG52YXIgX2NyZWF0ZUNoYXJ0O1xuXG5yZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG5yZXF1aXJlKCcuL2NvZGUtc25pcHBldC11dGlsJyk7XG5yZXF1aXJlKCcuL3JlZ2lzdGVyQ2hhcnRzJyk7XG5yZXF1aXJlKCcuL3JlZ2lzdGVyVGhlbWVzJyk7XG5cbi8qKlxuICogUmF3IHNlcmllcyBkYXR1bS5cbiAqIEB0eXBlZGVmIHt7bmFtZTogP3N0cmluZywgZGF0YTogQXJyYXkuPG51bWJlcj4sIHN0YWNrOiA/c3RyaW5nfX0gcmF3U2VyaWVzRGF0dW1cbiAqL1xuXG4vKipcbiAqIFJhdyBzZXJpZXMgZGF0YS5cbiAqIEB0eXBlZGVmIHtBcnJheS48cmF3U2VyaWVzRGF0dW0+fSByYXdTZXJpZXNEYXRhXG4gKi9cblxuLyoqXG4gKiBSYXcgZGF0YS5cbiAqIEB0eXBlZGVmIHt7XG4gKiAgICAgIGNhdGVnb3JpZXM6ID9BcnJheS48c3RyaW5nPixcbiAqICAgICAgc2VyaWVzOiAocmF3U2VyaWVzRGF0YXx7bGluZTogP3Jhd1Nlcmllc0RhdGEsIGNvbHVtbjogP3Jhd1Nlcmllc0RhdGF9KVxuICogfX0gcmF3RGF0YVxuICovXG5cbi8qKlxuICogTkhOIEVudGVydGFpbm1lbnQgVG9hc3QgVUkgQ2hhcnQuXG4gKiBAbmFtZXNwYWNlIHR1aS5jaGFydFxuICovXG50dWkudXRpbC5kZWZpbmVOYW1lc3BhY2UoJ3R1aS5jaGFydCcpO1xuXG4vKipcbiAqIENyZWF0ZSBjaGFydC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXJcbiAqIEBwYXJhbSB7cmF3RGF0YX0gcmF3RGF0YSAtIHJhdyBkYXRhXG4gKiBAcGFyYW0ge3tcbiAqICAgY2hhcnQ6IHtcbiAqICAgICB3aWR0aDogbnVtYmVyLFxuICogICAgIGhlaWdodDogbnVtYmVyLFxuICogICAgIHRpdGxlOiBzdHJpbmcsXG4gKiAgICAgZm9ybWF0OiBzdHJpbmdcbiAqICAgfSxcbiAqICAgeUF4aXM6IHtcbiAqICAgICB0aXRsZTogc3RyaW5nLFxuICogICAgIG1pbjogbnVtYmVyXG4gKiAgIH0sXG4gKiAgIHhBeGlzOiB7XG4gKiAgICAgdGl0bGU6IHN0cmluZyxcbiAqICAgICBtaW46IG51bWJlclxuICogICB9LFxuICogICB0b29sdGlwOiB7XG4gKiAgICAgc3VmZml4OiBzdHJpbmcsXG4gKiAgICAgdGVtcGxhdGU6IGZ1bmN0aW9uXG4gKiAgIH0sXG4gKiAgIHRoZW1lOiBzdHJpbmdcbiAqIH19IG9wdGlvbnMgLSBjaGFydCBvcHRpb25zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBjaGFydCBpbnN0YW5jZS5cbiAqIEBwcml2YXRlXG4gKiBAaWdub3JlXG4gKi9cbl9jcmVhdGVDaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucykge1xuICAgIHZhciB0aGVtZU5hbWUsIHRoZW1lLCBjaGFydDtcblxuICAgIHJhd0RhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJhd0RhdGEpKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IHR1aS51dGlsLmRlZXBDb3B5KG9wdGlvbnMpIDoge307XG4gICAgdGhlbWVOYW1lID0gb3B0aW9ucy50aGVtZSB8fCBjaGFydENvbnN0LkRFRkFVTFRfVEhFTUVfTkFNRTtcbiAgICB0aGVtZSA9IHRoZW1lRmFjdG9yeS5nZXQodGhlbWVOYW1lKTtcblxuICAgIGNoYXJ0ID0gY2hhcnRGYWN0b3J5LmdldChvcHRpb25zLmNoYXJ0VHlwZSwgcmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGFydC5yZW5kZXIoKSk7XG4gICAgY2hhcnQuYW5pbWF0ZUNoYXJ0KCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG4vKipcbiAqIEJhciBjaGFydCBjcmVhdG9yLlxuICogQG1lbWJlck9mIHR1aS5jaGFydFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge3Jhd0RhdGF9IHJhd0RhdGEgLSByYXcgZGF0YVxuICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSByYXdEYXRhLmNhdGVnb3JpZXMgLSBjYXRlZ29yaWVzXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YS5zZXJpZXMgLSBzZXJpZXMgZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBjaGFydCBvcHRpb25zXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNoYXJ0IC0gYmFzZSBvcHRpb25zIGZvciBjaGFydFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggLSBjaGFydCB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQuaGVpZ2h0IC0gY2hhcnQgaGVpZ2h0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC50aXRsZSAtIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9ufSBvcHRpb25zLmNoYXJ0LmZvcm1hdCAtIGZvcm1hdHRlciBmb3IgdmFsdWVcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueUF4aXMgLSBvcHRpb25zIGZvciB5IGF4aXMgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy55QXhpcy50aXRsZSAtIHRpdGxlIGZvciB5IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnlBeGlzLmFsaWduIC0gYWxpZ24gb3B0aW9uIGZvciBjZW50ZXIgeSBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMueUF4aXMucm90YXRlVGl0bGUgLSB3aGV0aGVyIHJvdGF0ZSB0aXRsZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnhBeGlzIC0gb3B0aW9ucyBmb3IgeCBheGlzIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueEF4aXMudGl0bGUgLSB0aXRsZSBmb3IgeCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy54QXhpcy5taW4gLSBtaW5pbXVtIHZhbHVlIGZvciB4IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnhBeGlzLm1heCAtIG1heGltdW0gdmFsdWUgZm9yIHggYXhpc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMgLSBvcHRpb25zIGZvciBzZXJpZXMgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zZXJpZXMuc3RhY2tUeXBlIC0gdHlwZSBvZiBzdGFja1xuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5zaG93TGFiZWwgLSB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zZXJpZXMuYmFyV2lkdGggLSBiYXIgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuYWxsb3dTZWxlY3QgLSB3aGV0aGVyIGFsbG93IHNlbGVjdCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuZGl2ZXJnaW5nIC0gd2hldGhlciBkaXZlcmdpbmcgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAgLSBvcHRpb25zIGZvciB0b29sdGlwIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5zdWZmaXggLSBzdWZmaXggZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gdGVtcGxhdGUgZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuYWxpZ24gLSBhbGlnbiBvcHRpb24gZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gLSByZWxhdGl2ZSBwb3NpdGlvblxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24ubGVmdCAtIHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCAtIHBvc2l0aW9uIHRvcFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnRvb2x0aXAuZ3JvdXBlZCAtIHdoZXRoZXIgZ3JvdXAgdG9vbHRpcCBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMubGVnZW5kIC0gb3B0aW9ucyBmb3IgbGVnZW5kIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGVnZW5kLmFsaWduIC0gYWxpZ24gb3B0aW9uIGZvciBsZWdlbmQgKHRvcHxib3R0b218bGVmdClcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuc2hvd0NoZWNrYm94IC0gd2hldGhlciBzaG93IGNoZWNrYm94IG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQudmlzaWJsZSAtIHdoZXRoZXIgdmlzaWJsZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnBsb3QgLSBvcHRpb25zIGZvciBwbG90IGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnBsb3Quc2hvd0xpbmUgLSB3aGV0aGVyIHNob3cgbGluZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIC0gdGhlbWUgbmFtZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIC0gdHlwZSBvZiBncmFwaCBsaWJyYXJ5XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBiYXIgY2hhcnRcbiAqIEBhcGlcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lci1pZCcpLFxuICogICAgIHJhd0RhdGEgPSB7XG4gKiAgICAgICBjYXRlZ29yaWVzOiBbJ2NhdGUxJywgJ2NhdGUyJywgJ2NhdGUzJ10sXG4gKiAgICAgICBzZXJpZXM6IFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQxJyxcbiAqICAgICAgICAgICBkYXRhOiBbMjAsIDMwLCA1MF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQyJyxcbiAqICAgICAgICAgICBkYXRhOiBbNDAsIDQwLCA2MF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQzJyxcbiAqICAgICAgICAgICBkYXRhOiBbNjAsIDUwLCAxMF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQ0JyxcbiAqICAgICAgICAgICBkYXRhOiBbODAsIDEwLCA3MF1cbiAqICAgICAgICAgfVxuICogICAgICAgXVxuICogICAgIH0sXG4gKiAgICAgb3B0aW9ucyA9IHtcbiAqICAgICAgIGNoYXJ0OiB7XG4gKiAgICAgICAgIHRpdGxlOiAnQmFyIENoYXJ0J1xuICogICAgICAgfSxcbiAqICAgICAgIHlBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWSBBeGlzJ1xuICogICAgICAgfSxcbiAqICAgICAgIHhBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWCBBeGlzJ1xuICogICAgICAgfVxuICogICAgIH07XG4gKiB0dWkuY2hhcnQuYmFyQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbiAqL1xudHVpLmNoYXJ0LmJhckNoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jaGFydFR5cGUgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfQkFSO1xuICAgIHJldHVybiBfY3JlYXRlQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ29sdW1uIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7cmF3RGF0YX0gcmF3RGF0YSAtIHJhdyBkYXRhXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHJhd0RhdGEuY2F0ZWdvcmllcyAtIGNhdGVnb3JpZXNcbiAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhLnNlcmllcyAtIHNlcmllcyBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2hhcnQgLSBiYXNlIG9wdGlvbnMgZm9yIGNoYXJ0XG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC53aWR0aCAtIGNoYXJ0IHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC5oZWlnaHQgLSBjaGFydCBoZWlnaHRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LnRpdGxlIC0gY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nIHwgZnVuY3Rpb259IG9wdGlvbnMuY2hhcnQuZm9ybWF0IC0gZm9ybWF0dGVyIGZvciB2YWx1ZVxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy55QXhpcyAtIG9wdGlvbnMgZm9yIHkgYXhpcyBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnlBeGlzLnRpdGxlIC0gdGl0bGUgZm9yIHkgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWluIC0gbWluaW11bSB2YWx1ZSBmb3IgeSBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy55QXhpcy5tYXggLSBtYXhpbXVtIHZhbHVlIGZvciB5IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy55QXhpcy5yb3RhdGVUaXRsZSAtIHdoZXRoZXIgcm90YXRlIHRpdGxlIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueEF4aXMgLSBvcHRpb25zIGZvciB4IGF4aXMgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy54QXhpcy50aXRsZSAtIHRpdGxlIGZvciB4IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnhBeGlzLmxhYmVsSW50ZXJ2YWwgLSBsYWJlbCBpbnRlcnZhbCBmb3IgeCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMueEF4aXMucm90YXRlTGFiZWwgLSB3aGV0aGVyIHJvdGF0ZSBsYWJlbCBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyAtIG9wdGlvbnMgZm9yIHNlcmllcyBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnNlcmllcy5zdGFja1R5cGUgLSB0eXBlIG9mIHN0YWNrXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dMYWJlbCAtIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnNlcmllcy5iYXJXaWR0aCAtIGJhciB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5hbGxvd1NlbGVjdCAtIHdoZXRoZXIgYWxsb3cgc2VsZWN0IG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5kaXZlcmdpbmcgLSB3aGV0aGVyIGRpdmVyZ2luZyBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCAtIG9wdGlvbnMgZm9yIHRvb2x0aXAgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLnN1ZmZpeCAtIHN1ZmZpeCBmb3IgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMudG9vbHRpcC50ZW1wbGF0ZV0gLSB0ZW1wbGF0ZSBmb3IgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5hbGlnbiAtIGFsaWduIG9wdGlvbiBmb3IgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbiAtIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IC0gcG9zaXRpb24gbGVmdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24udG9wIC0gcG9zaXRpb24gdG9wXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMudG9vbHRpcC5ncm91cGVkIC0gd2hldGhlciBncm91cCB0b29sdGlwIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgLSBvcHRpb25zIGZvciBsZWdlbmQgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sZWdlbmQuYWxpZ24gLSBhbGlnbiBvcHRpb24gZm9yIGxlZ2VuZCAodG9wfGJvdHRvbXxsZWZ0KVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5zaG93Q2hlY2tib3ggLSB3aGV0aGVyIHNob3cgY2hlY2tib3ggb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC52aXNpYmxlIC0gd2hldGhlciB2aXNpYmxlIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMucGxvdCAtIG9wdGlvbnMgZm9yIHBsb3QgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucGxvdC5zaG93TGluZSAtIHdoZXRoZXIgc2hvdyBsaW5lIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGhlbWUgLSB0aGVtZSBuYW1lXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxpYlR5cGUgLSB0eXBlIG9mIGdyYXBoIGxpYnJhcnlcbiAqIEByZXR1cm5zIHtvYmplY3R9IGNvbHVtbiBjaGFydFxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgcmF3RGF0YSA9IHtcbiAqICAgICAgIGNhdGVnb3JpZXM6IFsnY2F0ZTEnLCAnY2F0ZTInLCAnY2F0ZTMnXSxcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDEnLFxuICogICAgICAgICAgIGRhdGE6IFsyMCwgMzAsIDUwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDInLFxuICogICAgICAgICAgIGRhdGE6IFs0MCwgNDAsIDYwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDMnLFxuICogICAgICAgICAgIGRhdGE6IFs2MCwgNTAsIDEwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDQnLFxuICogICAgICAgICAgIGRhdGE6IFs4MCwgMTAsIDcwXVxuICogICAgICAgICB9XG4gKiAgICAgICBdXG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdDb2x1bW4gQ2hhcnQnXG4gKiAgICAgICB9LFxuICogICAgICAgeUF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdZIEF4aXMnXG4gKiAgICAgICB9LFxuICogICAgICAgeEF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdYIEF4aXMnXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5jb2x1bW5DaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xuICovXG50dWkuY2hhcnQuY29sdW1uQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9DT0xVTU47XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBMaW5lIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7cmF3RGF0YX0gcmF3RGF0YSAtIHJhdyBkYXRhXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHJhd0RhdGEuY2F0ZWdvcmllcyAtIGNhdGVnb3JpZXNcbiAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhLnNlcmllcyAtIHNlcmllcyBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2hhcnQgLSBiYXNlIG9wdGlvbnMgZm9yIGNoYXJ0XG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC53aWR0aCAtIGNoYXJ0IHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC5oZWlnaHQgLSBjaGFydCBoZWlnaHRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LnRpdGxlIC0gY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nIHwgZnVuY3Rpb259IG9wdGlvbnMuY2hhcnQuZm9ybWF0IC0gZm9ybWF0dGVyIGZvciB2YWx1ZVxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy55QXhpcyAtIG9wdGlvbnMgZm9yIHkgYXhpcyBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnlBeGlzLnRpdGxlIC0gdGl0bGUgZm9yIHkgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWluIC0gbWluaW11bSB2YWx1ZSBmb3IgeSBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy55QXhpcy5tYXggLSBtYXhpbXVtIHZhbHVlIGZvciB5IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy55QXhpcy5yb3RhdGVUaXRsZSAtIHdoZXRoZXIgcm90YXRlIHRpdGxlIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueEF4aXMgLSBvcHRpb25zIGZvciB4IGF4aXMgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy54QXhpcy50aXRsZSAtIHRpdGxlIGZvciB4IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnhBeGlzLmxhYmVsSW50ZXJ2YWwgLSBsYWJlbCBpbnRlcnZhbCBmb3IgeCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy54QXhpcy50aWNrSW50ZXJ2YWwgLSB0aWNrIGludGVydmFsIGZvciB4IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy54QXhpcy5yb3RhdGVMYWJlbCAtIHdoZXRoZXIgcm90YXRlIGxhYmVsIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzIC0gb3B0aW9ucyBmb3Igc2VyaWVzIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5zaG93RG90IC0gd2hldGhlciBzaG93IGRvdCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0xhYmVsIC0gd2hldGhlciBzaG93IGxhYmVsIG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5hbGxvd1NlbGVjdCAtIHdoZXRoZXIgYWxsb3cgc2VsZWN0IG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5zcGxpbmUgLSB3aGV0aGVyIHNwbGluZSBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuem9vbWFibGUgLSB3aGV0aGVyIHpvb21hYmxlIG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5zaGlmdGluZyAtIHdoZXRoZXIgc2hpZnRpbmcgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAgLSBvcHRpb25zIGZvciB0b29sdGlwIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5zdWZmaXggLSBzdWZmaXggZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gdGVtcGxhdGUgZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuYWxpZ24gLSBhbGlnbiBvcHRpb24gZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gLSByZWxhdGl2ZSBwb3NpdGlvblxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24ubGVmdCAtIHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCAtIHBvc2l0aW9uIHRvcFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnRvb2x0aXAuZ3JvdXBlZCAtIHdoZXRoZXIgZ3JvdXAgdG9vbHRpcCBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMubGVnZW5kIC0gb3B0aW9ucyBmb3IgbGVnZW5kIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGVnZW5kLmFsaWduIC0gYWxpZ24gb3B0aW9uIGZvciBsZWdlbmQgKHRvcHxib3R0b218bGVmdClcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuc2hvd0NoZWNrYm94IC0gd2hldGhlciBzaG93IGNoZWNrYm94IG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQudmlzaWJsZSAtIHdoZXRoZXIgdmlzaWJsZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnBsb3QgLSBvcHRpb25zIGZvciBwbG90IGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnBsb3Quc2hvd0xpbmUgLSB3aGV0aGVyIHNob3cgbGluZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIC0gdGhlbWUgbmFtZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIC0gdHlwZSBvZiBncmFwaCBsaWJyYXJ5XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBiYXIgY2hhcnRcbiAqIEBhcGlcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lci1pZCcpLFxuICogICAgIHJhd0RhdGEgPSB7XG4gKiAgICAgICBjYXRlZ29yaWVzOiBbJ2NhdGUxJywgJ2NhdGUyJywgJ2NhdGUzJ10sXG4gKiAgICAgICBzZXJpZXM6IFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQxJyxcbiAqICAgICAgICAgICBkYXRhOiBbMjAsIDMwLCA1MF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQyJyxcbiAqICAgICAgICAgICBkYXRhOiBbNDAsIDQwLCA2MF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQzJyxcbiAqICAgICAgICAgICBkYXRhOiBbNjAsIDUwLCAxMF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQ0JyxcbiAqICAgICAgICAgICBkYXRhOiBbODAsIDEwLCA3MF1cbiAqICAgICAgICAgfVxuICogICAgICAgXVxuICogICAgIH0sXG4gKiAgICAgb3B0aW9ucyA9IHtcbiAqICAgICAgIGNoYXJ0OiB7XG4gKiAgICAgICAgIHRpdGxlOiAnTGluZSBDaGFydCdcbiAqICAgICAgIH0sXG4gKiAgICAgICB5QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1kgQXhpcydcbiAqICAgICAgIH0sXG4gKiAgICAgICB4QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1ggQXhpcydcbiAqICAgICAgIH0sXG4gKiAgICAgICBzZXJpZXM6IHtcbiAqICAgICAgICAgc2hvd0RvdDogdHJ1ZVxuICogICAgICAgfVxuICogICAgIH07XG4gKiB0dWkuY2hhcnQubGluZUNoYXJ0KGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucyk7XG4gKi9cbnR1aS5jaGFydC5saW5lQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9MSU5FO1xuICAgIHJldHVybiBfY3JlYXRlQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQXJlYSBjaGFydCBjcmVhdG9yLlxuICogQG1lbWJlck9mIHR1aS5jaGFydFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge3Jhd0RhdGF9IHJhd0RhdGEgLSByYXcgZGF0YVxuICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSByYXdEYXRhLmNhdGVnb3JpZXMgLSBjYXRlZ29yaWVzXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YS5zZXJpZXMgLSBzZXJpZXMgZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBjaGFydCBvcHRpb25zXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNoYXJ0IC0gYmFzZSBvcHRpb25zIGZvciBjaGFydFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggLSBjaGFydCB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQuaGVpZ2h0IC0gY2hhcnQgaGVpZ2h0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC50aXRsZSAtIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9ufSBvcHRpb25zLmNoYXJ0LmZvcm1hdCAtIGZvcm1hdHRlciBmb3IgdmFsdWVcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueUF4aXMgLSBvcHRpb25zIGZvciB5IGF4aXMgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy55QXhpcy50aXRsZSAtIHRpdGxlIGZvciB5IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1pbiAtIG1pbmltdW0gdmFsdWUgZm9yIHkgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWF4IC0gbWF4aW11bSB2YWx1ZSBmb3IgeSBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMueUF4aXMucm90YXRlVGl0bGUgLSB3aGV0aGVyIHJvdGF0ZSB0aXRsZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnhBeGlzIC0gb3B0aW9ucyBmb3IgeCBheGlzIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueEF4aXMudGl0bGUgLSB0aXRsZSBmb3IgeCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy54QXhpcy5sYWJlbEludGVydmFsIC0gbGFiZWwgaW50ZXJ2YWwgZm9yIHggYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnhBeGlzLnJvdGF0ZUxhYmVsIC0gd2hldGhlciByb3RhdGUgbGFiZWwgb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueEF4aXMudGlja0ludGVydmFsIC0gdGljayBpbnRlcnZhbCBmb3IgeCBheGlzXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyAtIG9wdGlvbnMgZm9yIHNlcmllcyBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0RvdCAtIHdoZXRoZXIgc2hvdyBkb3Qgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dMYWJlbCAtIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuYWxsb3dTZWxlY3QgLSB3aGV0aGVyIGFsbG93IHNlbGVjdCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc3BsaW5lIC0gd2hldGhlciBzcGxpbmUgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnpvb21hYmxlIC0gd2hldGhlciB6b29tYWJsZSBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hpZnRpbmcgLSB3aGV0aGVyIHNoaWZ0aW5nIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwIC0gb3B0aW9ucyBmb3IgdG9vbHRpcCBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IC0gc3VmZml4IGZvciB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSAtIHRlbXBsYXRlIGZvciB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIC0gYWxpZ24gb3B0aW9uIGZvciB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIC0gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLmxlZnQgLSBwb3NpdGlvbiBsZWZ0XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi50b3AgLSBwb3NpdGlvbiB0b3BcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy50b29sdGlwLmdyb3VwZWQgLSB3aGV0aGVyIGdyb3VwIHRvb2x0aXAgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmxlZ2VuZCAtIG9wdGlvbnMgZm9yIGxlZ2VuZCBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxlZ2VuZC5hbGlnbiAtIGFsaWduIG9wdGlvbiBmb3IgbGVnZW5kICh0b3B8Ym90dG9tfGxlZnQpXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubGVnZW5kLnNob3dDaGVja2JveCAtIHdoZXRoZXIgc2hvdyBjaGVja2JveCBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubGVnZW5kLnZpc2libGUgLSB3aGV0aGVyIHZpc2libGUgb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5wbG90IC0gb3B0aW9ucyBmb3IgcGxvdCBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5wbG90LnNob3dMaW5lIC0gd2hldGhlciBzaG93IGxpbmUgb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aGVtZSAtIHRoZW1lIG5hbWVcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGliVHlwZSAtIHR5cGUgb2YgZ3JhcGggbGlicmFyeVxuICogQHJldHVybnMge29iamVjdH0gYmFyIGNoYXJ0XG4gKiBAYXBpXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXItaWQnKSxcbiAqICAgICByYXdEYXRhID0ge1xuICogICAgICAgY2F0ZWdvcmllczogWydjYXRlMScsICdjYXRlMicsICdjYXRlMyddLFxuICogICAgICAgc2VyaWVzOiBbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMScsXG4gKiAgICAgICAgICAgZGF0YTogWzIwLCAzMCwgNTBdXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMicsXG4gKiAgICAgICAgICAgZGF0YTogWzQwLCA0MCwgNjBdXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMycsXG4gKiAgICAgICAgICAgZGF0YTogWzYwLCA1MCwgMTBdXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kNCcsXG4gKiAgICAgICAgICAgZGF0YTogWzgwLCAxMCwgNzBdXG4gKiAgICAgICAgIH1cbiAqICAgICAgIF1cbiAqICAgICB9LFxuICogICAgIG9wdGlvbnMgPSB7XG4gKiAgICAgICBjaGFydDoge1xuICogICAgICAgICB0aXRsZTogJ0FyZWEgQ2hhcnQnXG4gKiAgICAgICB9LFxuICogICAgICAgeUF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdZIEF4aXMnXG4gKiAgICAgICB9LFxuICogICAgICAgeEF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdYIEF4aXMnXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5hcmVhQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbiAqL1xudHVpLmNoYXJ0LmFyZWFDaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2hhcnRUeXBlID0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0FSRUE7XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBCdWJibGUgY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIGNoYXJ0IGNvbnRhaW5lclxuICogQHBhcmFtIHtyYXdEYXRhfSByYXdEYXRhIC0gcmF3IGRhdGFcbiAqICAgICAgQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gcmF3RGF0YS5jYXRlZ29yaWVzIC0gY2F0ZWdvcmllc1xuICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEuc2VyaWVzIC0gc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gY2hhcnQgb3B0aW9uc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jaGFydCAtIGJhc2Ugb3B0aW9ucyBmb3IgY2hhcnRcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LndpZHRoIC0gY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCAtIGNoYXJ0IGhlaWdodFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQudGl0bGUgLSBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmcgfCBmdW5jdGlvbn0gb3B0aW9ucy5jaGFydC5mb3JtYXQgLSBmb3JtYXR0ZXIgZm9yIHZhbHVlXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnlBeGlzIC0gb3B0aW9ucyBmb3IgeSBheGlzIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueUF4aXMudGl0bGUgLSB0aXRsZSBmb3IgeSBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy55QXhpcy5taW4gLSBtaW5pbXVtIHZhbHVlIGZvciB5IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1heCAtIG1heGltdW0gdmFsdWUgZm9yIHkgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnlBeGlzLnJvdGF0ZVRpdGxlIC0gd2hldGhlciByb3RhdGUgdGl0bGUgb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy54QXhpcyAtIG9wdGlvbnMgZm9yIHggYXhpcyBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnhBeGlzLnRpdGxlIC0gdGl0bGUgZm9yIHggYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueEF4aXMubGFiZWxJbnRlcnZhbCAtIGxhYmVsIGludGVydmFsIGZvciB4IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy54QXhpcy5yb3RhdGVMYWJlbCAtIHdoZXRoZXIgcm90YXRlIGxhYmVsIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnhBeGlzLm1pbiAtIG1pbmltdW0gdmFsdWUgZm9yIHkgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueEF4aXMubWF4IC0gbWF4aW11bSB2YWx1ZSBmb3IgeSBheGlzXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyAtIG9wdGlvbnMgZm9yIHNlcmllcyBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0xhYmVsIC0gd2hldGhlciBzaG93IGxhYmVsIG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5hbGxvd1NlbGVjdCAtIHdoZXRoZXIgYWxsb3cgc2VsZWN0IG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwIC0gb3B0aW9ucyBmb3IgdG9vbHRpcCBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IC0gc3VmZml4IGZvciB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSAtIHRlbXBsYXRlIGZvciB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIC0gYWxpZ24gb3B0aW9uIGZvciB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIC0gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLmxlZnQgLSBwb3NpdGlvbiBsZWZ0XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi50b3AgLSBwb3NpdGlvbiB0b3BcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMubGVnZW5kIC0gb3B0aW9ucyBmb3IgbGVnZW5kIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGVnZW5kLmFsaWduIC0gYWxpZ24gb3B0aW9uIGZvciBsZWdlbmQgKHRvcHxib3R0b218bGVmdClcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuc2hvd0NoZWNrYm94IC0gd2hldGhlciBzaG93IGNoZWNrYm94IG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQudmlzaWJsZSAtIHdoZXRoZXIgdmlzaWJsZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNpcmNsZUxlZ2VuZCAtIG9wdGlvbnMgZm9yIGNpcmNsZUxlZ2VuZFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNpcmNsZUxlZ2VuZC52aXNpYmxlIC0gd2hldGhlciB2aXNpYmxlIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMucGxvdCAtIG9wdGlvbnMgZm9yIHBsb3QgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucGxvdC5zaG93TGluZSAtIHdoZXRoZXIgc2hvdyBsaW5lIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGhlbWUgLSB0aGVtZSBuYW1lXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxpYlR5cGUgLSB0eXBlIG9mIGdyYXBoIGxpYnJhcnlcbiAqIEByZXR1cm5zIHtvYmplY3R9IGJ1YmJsZSBjaGFydFxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgcmF3RGF0YSA9IHtcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDEnLFxuICogICAgICAgICAgIGRhdGE6IFt7XG4gKiAgICAgICAgICAgICAgeDogMTAsXG4gKiAgICAgICAgICAgICAgeTogMjAsXG4gKiAgICAgICAgICAgICAgcjogMTUsXG4gKiAgICAgICAgICAgICAgbGFiZWw6ICdMYWJsZTEnXG4gKiAgICAgICAgICAgfSwge1xuICogICAgICAgICAgICAgIHg6IDIwLFxuICogICAgICAgICAgICAgIHk6IDQwLFxuICogICAgICAgICAgICAgIHI6IDEwLFxuICogICAgICAgICAgICAgIGxhYmVsOiAnTGFibGUyJ1xuICogICAgICAgICAgIH1dXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMicsXG4gKiAgICAgICAgICAgZGF0YTogW3tcbiAqICAgICAgICAgICAgICB4OiA0MCxcbiAqICAgICAgICAgICAgICB5OiAxMCxcbiAqICAgICAgICAgICAgICByOiA1LFxuICogICAgICAgICAgICAgIGxhYmVsOiAnTGFibGUzJ1xuICogICAgICAgICAgIH0sIHtcbiAqICAgICAgICAgICAgICB4OiAzMCxcbiAqICAgICAgICAgICAgICB5OiA0MCxcbiAqICAgICAgICAgICAgICByOiA4LFxuICogICAgICAgICAgICAgIGxhYmVsOiAnTGFibGU0J1xuICogICAgICAgICAgIH1dXG4gKiAgICAgICAgIH1cbiAqICAgICAgIF1cbiAqICAgICB9LFxuICogICAgIG9wdGlvbnMgPSB7XG4gKiAgICAgICBjaGFydDoge1xuICogICAgICAgICB0aXRsZTogJ0J1YmJsZSBDaGFydCdcbiAqICAgICAgIH0sXG4gKiAgICAgICB5QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1kgQXhpcydcbiAqICAgICAgIH0sXG4gKiAgICAgICB4QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1ggQXhpcydcbiAqICAgICAgIH1cbiAqICAgICB9O1xuICogdHVpLmNoYXJ0LmJ1YmJsZUNoYXJ0KGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucyk7XG4gKi9cbnR1aS5jaGFydC5idWJibGVDaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2hhcnRUeXBlID0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0JVQkJMRTtcbiAgICByZXR1cm4gX2NyZWF0ZUNoYXJ0KGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFNjYXR0ZXIgY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIGNoYXJ0IGNvbnRhaW5lclxuICogQHBhcmFtIHtyYXdEYXRhfSByYXdEYXRhIC0gcmF3IGRhdGFcbiAqICAgICAgQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gcmF3RGF0YS5jYXRlZ29yaWVzIC0gY2F0ZWdvcmllc1xuICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEuc2VyaWVzIC0gc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gY2hhcnQgb3B0aW9uc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jaGFydCAtIGJhc2Ugb3B0aW9ucyBmb3IgY2hhcnRcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LndpZHRoIC0gY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCAtIGNoYXJ0IGhlaWdodFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQudGl0bGUgLSBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmcgfCBmdW5jdGlvbn0gb3B0aW9ucy5jaGFydC5mb3JtYXQgLSBmb3JtYXR0ZXIgZm9yIHZhbHVlXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnlBeGlzIC0gb3B0aW9ucyBmb3IgeSBheGlzIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueUF4aXMudGl0bGUgLSB0aXRsZSBmb3IgeSBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy55QXhpcy5taW4gLSBtaW5pbXVtIHZhbHVlIGZvciB5IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1heCAtIG1heGltdW0gdmFsdWUgZm9yIHkgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnlBeGlzLnJvdGF0ZVRpdGxlIC0gd2hldGhlciByb3RhdGUgdGl0bGUgb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy54QXhpcyAtIG9wdGlvbnMgZm9yIHggYXhpcyBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnhBeGlzLnRpdGxlIC0gdGl0bGUgZm9yIHggYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueEF4aXMubWluIC0gbWluaW11bSB2YWx1ZSBmb3IgeSBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy54QXhpcy5tYXggLSBtYXhpbXVtIHZhbHVlIGZvciB5IGF4aXNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzIC0gb3B0aW9ucyBmb3Igc2VyaWVzIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5zaG93TGFiZWwgLSB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmFsbG93U2VsZWN0IC0gd2hldGhlciBhbGxvdyBzZWxlY3Qgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAgLSBvcHRpb25zIGZvciB0b29sdGlwIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5zdWZmaXggLSBzdWZmaXggZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gdGVtcGxhdGUgZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuYWxpZ24gLSBhbGlnbiBvcHRpb24gZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gLSByZWxhdGl2ZSBwb3NpdGlvblxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24ubGVmdCAtIHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCAtIHBvc2l0aW9uIHRvcFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgLSBvcHRpb25zIGZvciBsZWdlbmQgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sZWdlbmQuYWxpZ24gLSBhbGlnbiBvcHRpb24gZm9yIGxlZ2VuZCAodG9wfGJvdHRvbXxsZWZ0KVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5zaG93Q2hlY2tib3ggLSB3aGV0aGVyIHNob3cgY2hlY2tib3ggb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC52aXNpYmxlIC0gd2hldGhlciB2aXNpYmxlIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMucGxvdCAtIG9wdGlvbnMgZm9yIHBsb3QgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucGxvdC5zaG93TGluZSAtIHdoZXRoZXIgc2hvdyBsaW5lIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGhlbWUgLSB0aGVtZSBuYW1lXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxpYlR5cGUgLSB0eXBlIG9mIGdyYXBoIGxpYnJhcnlcbiAqIEByZXR1cm5zIHtvYmplY3R9IHNjYXR0ZXIgY2hhcnRcbiAqIEBhcGlcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lci1pZCcpLFxuICogICAgIHJhd0RhdGEgPSB7XG4gKiAgICAgICBzZXJpZXM6IFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQxJyxcbiAqICAgICAgICAgICBkYXRhOiBbe1xuICogICAgICAgICAgICAgIHg6IDEwLFxuICogICAgICAgICAgICAgIHk6IDIwXG4gKiAgICAgICAgICAgfSwge1xuICogICAgICAgICAgICAgIHg6IDIwLFxuICogICAgICAgICAgICAgIHk6IDQwXG4gKiAgICAgICAgICAgfV1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQyJyxcbiAqICAgICAgICAgICBkYXRhOiBbe1xuICogICAgICAgICAgICAgIHg6IDQwLFxuICogICAgICAgICAgICAgIHk6IDEwXG4gKiAgICAgICAgICAgfSwge1xuICogICAgICAgICAgICAgIHg6IDMwLFxuICogICAgICAgICAgICAgIHk6IDQwXG4gKiAgICAgICAgICAgfV1cbiAqICAgICAgICAgfVxuICogICAgICAgXVxuICogICAgIH0sXG4gKiAgICAgb3B0aW9ucyA9IHtcbiAqICAgICAgIGNoYXJ0OiB7XG4gKiAgICAgICAgIHRpdGxlOiAnU2NhdHRlciBDaGFydCdcbiAqICAgICAgIH0sXG4gKiAgICAgICB5QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1kgQXhpcydcbiAqICAgICAgIH0sXG4gKiAgICAgICB4QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1ggQXhpcydcbiAqICAgICAgIH1cbiAqICAgICB9O1xuICogdHVpLmNoYXJ0LnNjYXR0ZXJDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xuICovXG50dWkuY2hhcnQuc2NhdHRlckNoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jaGFydFR5cGUgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfU0NBVFRFUjtcbiAgICByZXR1cm4gX2NyZWF0ZUNoYXJ0KGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEhlYXRtYXAgY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIGNoYXJ0IGNvbnRhaW5lclxuICogQHBhcmFtIHtyYXdEYXRhfSByYXdEYXRhIC0gcmF3IGRhdGFcbiAqICAgICAgQHBhcmFtIHt7eDogQXJyYXkuPHN0cmluZyB8IG51bWJlcj4sIHk6IEFycmF5LjxzdHJpbmcgfCBudW1iZXI+fX0gcmF3RGF0YS5jYXRlZ29yaWVzIC0gY2F0ZWdvcmllc1xuICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHJhd0RhdGEuc2VyaWVzIC0gc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gY2hhcnQgb3B0aW9uc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jaGFydCAtIGJhc2Ugb3B0aW9ucyBmb3IgY2hhcnRcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LndpZHRoIC0gY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCAtIGNoYXJ0IGhlaWdodFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQudGl0bGUgLSBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmcgfCBmdW5jdGlvbn0gb3B0aW9ucy5jaGFydC5mb3JtYXQgLSBmb3JtYXR0ZXIgZm9yIHZhbHVlXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnlBeGlzIC0gb3B0aW9ucyBmb3IgeSBheGlzIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueUF4aXMudGl0bGUgLSB0aXRsZSBmb3IgeSBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMueUF4aXMucm90YXRlVGl0bGUgLSB3aGV0aGVyIHJvdGF0ZSB0aXRsZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnhBeGlzIC0gb3B0aW9ucyBmb3IgeCBheGlzIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueEF4aXMudGl0bGUgLSB0aXRsZSBmb3IgeCBheGlzXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyAtIG9wdGlvbnMgZm9yIHNlcmllcyBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0xhYmVsIC0gd2hldGhlciBzaG93IGxhYmVsIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwIC0gb3B0aW9ucyBmb3IgdG9vbHRpcCBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IC0gc3VmZml4IGZvciB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSAtIHRlbXBsYXRlIGZvciB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIC0gYWxpZ24gb3B0aW9uIGZvciB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIC0gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLmxlZnQgLSBwb3NpdGlvbiBsZWZ0XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi50b3AgLSBwb3NpdGlvbiB0b3BcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMubGVnZW5kIC0gb3B0aW9ucyBmb3IgbGVnZW5kIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGVnZW5kLmFsaWduIC0gYWxpZ24gb3B0aW9uIGZvciBsZWdlbmQgKHRvcHxib3R0b218bGVmdClcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQudmlzaWJsZSAtIHdoZXRoZXIgdmlzaWJsZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIC0gdGhlbWUgbmFtZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIC0gdHlwZSBvZiBncmFwaCBsaWJyYXJ5XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBzY2F0dGVyIGNoYXJ0XG4gKiBAYXBpXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXItaWQnKSxcbiAqICAgICByYXdEYXRhID0ge1xuICogICAgICAgY2F0ZWdvcmllczoge1xuICogICAgICAgICAgIHg6IFsxMCwgMjAsIDMwLCA0MCwgNTBdLFxuICogICAgICAgICAgIHk6IFsxLCAyLCAzLCA0LCA1LCA2XVxuICogICAgICAgfSxcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICAgIFsxMCwgMjAsIDMwLCA0MCwgNTBdLFxuICogICAgICAgICAgIFsxLCA0LCA2LCA3LCA4XSxcbiAqICAgICAgICAgICBbMjAsIDQsIDUsIDcwLCA4XSxcbiAqICAgICAgICAgICBbMTAwLCA0MCwgMzAsIDgwLCAzMF0sXG4gKiAgICAgICAgICAgWzIwLCAxMCwgNjAsIDkwLCAyMF0sXG4gKiAgICAgICAgICAgWzUwLCA0MCwgMzAsIDIwLCAxMF1cbiAqICAgICAgIF1cbiAqICAgICB9LFxuICogICAgIG9wdGlvbnMgPSB7XG4gKiAgICAgICBjaGFydDoge1xuICogICAgICAgICB0aXRsZTogJ0hlYXRtYXAgQ2hhcnQnXG4gKiAgICAgICB9LFxuICogICAgICAgeUF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdZIEF4aXMnXG4gKiAgICAgICB9LFxuICogICAgICAgeEF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdYIEF4aXMnXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5oZWF0bWFwQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbiAqL1xudHVpLmNoYXJ0LmhlYXRtYXBDaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2hhcnRUeXBlID0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0hFQVRNQVA7XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBUcmVlbWFwIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7cmF3RGF0YX0gcmF3RGF0YSAtIHJhdyBkYXRhXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gcmF3RGF0YS5zZXJpZXMgLSBzZXJpZXMgZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBjaGFydCBvcHRpb25zXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNoYXJ0IC0gYmFzZSBvcHRpb25zIGZvciBjaGFydFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggLSBjaGFydCB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQuaGVpZ2h0IC0gY2hhcnQgaGVpZ2h0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC50aXRsZSAtIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9ufSBvcHRpb25zLmNoYXJ0LmZvcm1hdCAtIGZvcm1hdHRlciBmb3IgdmFsdWVcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzIC0gb3B0aW9ucyBmb3Igc2VyaWVzIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5zaG93TGFiZWwgLSB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnVzZUNvbG9yVmFsdWUgLSB3aGV0aGVyIHVzZSBjb2xvclZhbHVlIG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy56b29tYWJsZSAtIHdoZXRoZXIgem9vbWFibGUgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnVzZUxlYWZMYWJlbCAtIHdoZXRoZXIgdXNlIGxlYWYgbGFiZWwgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAgLSBvcHRpb25zIGZvciB0b29sdGlwIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5zdWZmaXggLSBzdWZmaXggZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gdGVtcGxhdGUgZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gLSByZWxhdGl2ZSBwb3NpdGlvblxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24ubGVmdCAtIHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCAtIHBvc2l0aW9uIHRvcFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgLSBvcHRpb25zIGZvciBsZWdlbmQgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sZWdlbmQuYWxpZ24gLSBhbGlnbiBvcHRpb24gZm9yIGxlZ2VuZCAodG9wfGJvdHRvbXxsZWZ0KVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC52aXNpYmxlIC0gd2hldGhlciB2aXNpYmxlIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGhlbWUgLSB0aGVtZSBuYW1lXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxpYlR5cGUgLSB0eXBlIG9mIGdyYXBoIGxpYnJhcnlcbiAqIEByZXR1cm5zIHtvYmplY3R9IHNjYXR0ZXIgY2hhcnRcbiAqIEBhcGlcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lci1pZCcpLFxuICogICAgIHJhd0RhdGEgPSB7XG4gKiAgICAgICBzZXJpZXM6IFtcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICBsYWJlbDogJ2xhYmVsMScsXG4gKiAgICAgICAgICAgICAgdmFsdWU6IDZcbiAqICAgICAgICAgIH0sXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgbGFiZWw6ICdsYWJlbDInLFxuICogICAgICAgICAgICAgIHZhbHVlOiA2XG4gKiAgICAgICAgICB9LFxuICogICAgICAgICAge1xuICogICAgICAgICAgICAgIGxhYmVsOiAnbGFiZWwzJyxcbiAqICAgICAgICAgICAgICB2YWx1ZTogNFxuICogICAgICAgICAgfSxcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICBsYWJlbDogJ2xhYmVsNCcsXG4gKiAgICAgICAgICAgICAgdmFsdWU6IDNcbiAqICAgICAgICAgIH0sXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgbGFiZWw6ICdsYWJlbDUnLFxuICogICAgICAgICAgICAgIHZhbHVlOiAyXG4gKiAgICAgICAgICB9LFxuICogICAgICAgICAge1xuICogICAgICAgICAgICAgIGxhYmVsOiAnbGFiZWw2JyxcbiAqICAgICAgICAgICAgICB2YWx1ZTogMlxuICogICAgICAgICAgfSxcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICBsYWJlbDogJ2xhYmVsNycsXG4gKiAgICAgICAgICAgICAgdmFsdWU6IDFcbiAqICAgICAgICAgIH1cbiAqICAgICBdLFxuICogICAgIG9wdGlvbnMgPSB7XG4gKiAgICAgICBjaGFydDoge1xuICogICAgICAgICB0aXRsZTogJ1RyZWVtYXAgQ2hhcnQnXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC50cmVlbWFwQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbiAqL1xudHVpLmNoYXJ0LnRyZWVtYXBDaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2hhcnRUeXBlID0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX1RSRUVNQVA7XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb21ibyBjaGFydCBjcmVhdG9yLlxuICogQG1lbWJlck9mIHR1aS5jaGFydFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge3Jhd0RhdGF9IHJhd0RhdGEgLSByYXcgZGF0YVxuICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSByYXdEYXRhLmNhdGVnb3JpZXMgLSBjYXRlZ29yaWVzXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YS5zZXJpZXMgLSBzZXJpZXMgZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBjaGFydCBvcHRpb25zXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNoYXJ0IC0gYmFzZSBvcHRpb25zIGZvciBjaGFydFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggLSBjaGFydCB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQuaGVpZ2h0IC0gY2hhcnQgaGVpZ2h0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC50aXRsZSAtIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9ufSBvcHRpb25zLmNoYXJ0LmZvcm1hdCAtIGZvcm1hdHRlciBmb3IgdmFsdWVcbiAqICAgICAgQHBhcmFtIHtvYmplY3R8QXJyYXl9IG9wdGlvbnMueUF4aXMgLSBvcHRpb25zIGZvciB5IGF4aXMgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy55QXhpcy50aXRsZSAtIHRpdGxlIGZvciB5IGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1pbiAtIG1pbmltdW0gdmFsdWUgZm9yIHkgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWF4IC0gbWF4aW11bSB2YWx1ZSBmb3IgeSBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMueUF4aXMucm90YXRlVGl0bGUgLSB3aGV0aGVyIHJvdGF0ZSB0aXRsZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnhBeGlzIC0gb3B0aW9ucyBmb3IgeCBheGlzIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueEF4aXMudGl0bGUgLSB0aXRsZSBmb3IgeCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy54QXhpcy5sYWJlbEludGVydmFsIC0gbGFiZWwgaW50ZXJ2YWwgZm9yIHggYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnhBeGlzLnJvdGF0ZUxhYmVsIC0gd2hldGhlciByb3RhdGUgbGFiZWwgb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMgLSBvcHRpb25zIGZvciBzZXJpZXMgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0gez9vYmplY3R9IG9wdGlvbnMuc2VyaWVzLmNvbHVtbiAtIG9wdGlvbnMgZm9yIGNvbHVtbiBzZXJpZXMgY29tcG9uZW50XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc2VyaWVzLmNvbHVtbi5zdGFja1R5cGUgLSB0eXBlIG9mIHN0YWNrXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5jb2x1bW4uc2hvd0xhYmVsIC0gd2hldGhlciBzaG93IGxhYmVsIG9yIG5vdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnNlcmllcy5jb2x1bW4uYmFyV2lkdGggLSBiYXIgd2lkdGhcbiAqICAgICAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmNvbHVtbi5hbGxvd1NlbGVjdCAtIHdoZXRoZXIgYWxsb3cgc2VsZWN0IG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHs/b2JqZWN0fSBvcHRpb25zLnNlcmllcy5saW5lIC0gb3B0aW9ucyBmb3IgbGluZSBzZXJpZXMgY29tcG9uZW50XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5saW5lLnNob3dEb3QgLSB3aGV0aGVyIHNob3cgZG90IG9yIG5vdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMubGluZS5zaG93TGFiZWwgLSB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5saW5lLmFsbG93U2VsZWN0IC0gd2hldGhlciBhbGxvdyBzZWxlY3Qgb3Igbm90XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5saW5lLnNwbGluZSAtIHdoZXRoZXIgc3BsaW5lIG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHs/b2JqZWN0fSBvcHRpb25zLnNlcmllcy5hcmVhIC0gb3B0aW9ucyBmb3IgbGluZSBzZXJpZXMgY29tcG9uZW50XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5hcmVhLnNob3dEb3QgLSB3aGV0aGVyIHNob3cgZG90IG9yIG5vdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuYXJlYS5zaG93TGFiZWwgLSB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5hcmVhLmFsbG93U2VsZWN0IC0gd2hldGhlciBhbGxvdyBzZWxlY3Qgb3Igbm90XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5hcmVhLnNwbGluZSAtIHdoZXRoZXIgc3BsaW5lIG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHs/b2JqZWN0fSBvcHRpb25zLnNlcmllcy5waWUgLSBvcHRpb25zIGZvciBwaWUgc2VyaWVzIGNvbXBvbmVudFxuICogICAgICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMucGllLnNob3dMYWJlbCAtIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zZXJpZXMucGllLnJhZGl1c1JhdGlvIC0gcmF0aW8gb2YgcmFkaXVzIGZvciBwaWUgZ3JhcGhcbiAqICAgICAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnBpZS5hbGxvd1NlbGVjdCAtIHdoZXRoZXIgYWxsb3cgc2VsZWN0IG9yIG5vdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMucGllLnN0YXJ0QW5nbGUgLSBzdGFydCBhbmdsZVxuICogICAgICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMucGllLmVuZEFuZ2xlIC0gZW5kIGFuZ2xlXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dEb3QgLSB3aGV0aGVyIHNob3cgZG90IG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5zaG93TGFiZWwgLSB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmFsbG93U2VsZWN0IC0gd2hldGhlciBhbGxvdyBzZWxlY3Qgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNwbGluZSAtIHdoZXRoZXIgc3BsaW5lIG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy56b29tYWJsZSAtIHdoZXRoZXIgem9vbWFibGUgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNoaWZ0aW5nIC0gd2hldGhlciBzaGlmdGluZyBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCAtIG9wdGlvbnMgZm9yIHRvb2x0aXAgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLmNvbHVtbiAtIG9wdGlvbnMgZm9yIGNvbHVtbiB0b29sdGlwXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4uc3VmZml4IC0gc3VmZml4IGZvciB0b29sdGlwXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMudG9vbHRpcC5jb2x1bW4udGVtcGxhdGVdIHRlbXBsYXRlIG9mIHRvb2x0aXBcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmNvbHVtbi5hbGlnbiAtIGFsaWduIG9wdGlvbiBmb3IgdG9vbHRpcFxuICogICAgICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAuY29sdW1uLnBvc2l0aW9uIC0gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4ucG9zaXRpb24ubGVmdCAtIHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4ucG9zaXRpb24udG9wIC0gcG9zaXRpb24gdG9wXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMudG9vbHRpcC5ncm91cGVkIC0gd2hldGhlciBncm91cCB0b29sdGlwIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgLSBvcHRpb25zIGZvciBsZWdlbmQgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sZWdlbmQuYWxpZ24gLSBhbGlnbiBvcHRpb24gZm9yIGxlZ2VuZCAodG9wfGJvdHRvbXxsZWZ0KVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5zaG93Q2hlY2tib3ggLSB3aGV0aGVyIHNob3cgY2hlY2tib3ggb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC52aXNpYmxlIC0gd2hldGhlciB2aXNpYmxlIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMucGxvdCAtIG9wdGlvbnMgZm9yIHBsb3QgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucGxvdC5zaG93TGluZSAtIHdoZXRoZXIgc2hvdyBsaW5lIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGhlbWUgLSB0aGVtZSBuYW1lXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxpYlR5cGUgLSB0eXBlIG9mIGdyYXBoIGxpYnJhcnlcbiAqIEByZXR1cm5zIHtvYmplY3R9IGJhciBjaGFydFxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgcmF3RGF0YSA9IHtcbiAqICAgICAgIGNhdGVnb3JpZXM6IFsnY2F0ZTEnLCAnY2F0ZTInLCAnY2F0ZTMnXSxcbiAqICAgICAgIHNlcmllczoge1xuICogICAgICAgICBjb2x1bW46IFtcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBuYW1lOiAnTGVnZW5kMScsXG4gKiAgICAgICAgICAgICBkYXRhOiBbMjAsIDMwLCA1MF1dXG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBuYW1lOiAnTGVnZW5kMicsXG4gKiAgICAgICAgICAgICBkYXRhOiBbNDAsIDQwLCA2MF1cbiAqICAgICAgICAgICB9LFxuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICdMZWdlbmQzJyxcbiAqICAgICAgICAgICAgIGRhdGE6IFs2MCwgNTAsIDEwXVxuICogICAgICAgICAgIH0sXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDQnLFxuICogICAgICAgICAgICAgZGF0YTogWzgwLCAxMCwgNzBdXG4gKiAgICAgICAgICAgfVxuICogICAgICAgICB9LFxuICogICAgICAgICBsaW5lOiBbXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDUnLFxuICogICAgICAgICAgICAgZGF0YTogWzEsIDIsIDNdXG4gKiAgICAgICAgICAgfVxuICogICAgICAgICBdXG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdDb21ibyBDaGFydCdcbiAqICAgICAgIH0sXG4gKiAgICAgICB5QXhpczpbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICB0aXRsZTogJ1kgQXhpcycsXG4gKiAgICAgICAgICAgY2hhcnRUeXBlOiAnbGluZSdcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIHRpdGxlOiAnWSBSaWdodCBBeGlzJ1xuICogICAgICAgICB9XG4gKiAgICAgICBdLFxuICogICAgICAgeEF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdYIEF4aXMnXG4gKiAgICAgICB9LFxuICogICAgICAgc2VyaWVzOiB7XG4gKiAgICAgICAgIHNob3dEb3Q6IHRydWVcbiAqICAgICAgIH1cbiAqICAgICB9O1xuICogdHVpLmNoYXJ0LmNvbWJvQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbiAqL1xudHVpLmNoYXJ0LmNvbWJvQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9DT01CTztcbiAgICByZXR1cm4gX2NyZWF0ZUNoYXJ0KGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFBpZSBjaGFydCBjcmVhdG9yLlxuICogQG1lbWJlck9mIHR1aS5jaGFydFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge3Jhd0RhdGF9IHJhd0RhdGEgLSByYXcgZGF0YVxuICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEuc2VyaWVzIC0gc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gY2hhcnQgb3B0aW9uc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jaGFydCAtIGJhc2Ugb3B0aW9ucyBmb3IgY2hhcnRcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LndpZHRoIC0gY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCAtIGNoYXJ0IGhlaWdodFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQudGl0bGUgLSBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmcgfCBmdW5jdGlvbn0gb3B0aW9ucy5jaGFydC5mb3JtYXQgLSBmb3JtYXR0ZXIgZm9yIHZhbHVlXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyAtIG9wdGlvbnMgZm9yIHNlcmllcyBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0xhYmVsIC0gd2hldGhlciBzaG93IGxhYmVsIG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2VyaWVzLnJhZGl1c1JhdGlvIC0gcmF0aW8gb2YgcmFkaXVzIGZvciBwaWUgZ3JhcGhcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuYWxsb3dTZWxlY3QgLSB3aGV0aGVyIGFsbG93IHNlbGVjdCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc3RhcnRBbmdsZSAtIHN0YXJ0IGFuZ2xlXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmVuZEFuZ2xlIC0gZW5kIGFuZ2xlXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAgLSBvcHRpb25zIGZvciB0b29sdGlwIGNvbXBvbmVudFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5zdWZmaXggLSBzdWZmaXggZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gdGVtcGxhdGUgZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuYWxpZ24gLSBhbGlnbiBvcHRpb24gZm9yIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gLSByZWxhdGl2ZSBwb3NpdGlvblxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24ubGVmdCAtIHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCAtIHBvc2l0aW9uIHRvcFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgLSBvcHRpb25zIGZvciBsZWdlbmQgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sZWdlbmQuYWxpZ24gLSBhbGlnbiBvcHRpb24gZm9yIGxlZ2VuZCAodG9wfGJvdHRvbXxsZWZ0fGNlbnRlcnxvdXRlcilcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuc2hvd0NoZWNrYm94IC0gd2hldGhlciBzaG93IGNoZWNrYm94IG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQudmlzaWJsZSAtIHdoZXRoZXIgdmlzaWJsZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIC0gdGhlbWUgbmFtZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIC0gdHlwZSBvZiBncmFwaCBsaWJyYXJ5XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBiYXIgY2hhcnRcbiAqIEBhcGlcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lci1pZCcpLFxuICogICAgIHJhd0RhdGEgPSB7XG4gKiAgICAgICBzZXJpZXM6IFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQxJyxcbiAqICAgICAgICAgICBkYXRhOiAyMFxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDInLFxuICogICAgICAgICAgIGRhdGE6IDQwXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMycsXG4gKiAgICAgICAgICAgZGF0YTogNjBcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQ0JyxcbiAqICAgICAgICAgICBkYXRhOiA4MFxuICogICAgICAgICB9XG4gKiAgICAgICBdXG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdQaWUgQ2hhcnQnXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5waWVDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xuICovXG50dWkuY2hhcnQucGllQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9QSUU7XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIHJhd0RhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBNYXAgY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIGNoYXJ0IGNvbnRhaW5lclxuICogQHBhcmFtIHtyYXdEYXRhfSByYXdEYXRhIGNoYXJ0IGRhdGFcbiAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhLnNlcmllcyAtIHNlcmllcyBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2hhcnQgLSBiYXNlIG9wdGlvbnMgZm9yIGNoYXJ0XG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC53aWR0aCAtIGNoYXJ0IHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC5oZWlnaHQgLSBjaGFydCBoZWlnaHRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LnRpdGxlIC0gY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nIHwgZnVuY3Rpb259IG9wdGlvbnMuY2hhcnQuZm9ybWF0IC0gZm9ybWF0dGVyIGZvciB2YWx1ZVxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMgLSBvcHRpb25zIGZvciBzZXJpZXMgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dMYWJlbCAtIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCAtIG9wdGlvbnMgZm9yIHRvb2x0aXAgY29tcG9uZW50XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLnN1ZmZpeCAtIHN1ZmZpeCBmb3IgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMudG9vbHRpcC50ZW1wbGF0ZV0gLSB0ZW1wbGF0ZSBmb3IgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5hbGlnbiAtIGFsaWduIG9wdGlvbiBmb3IgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbiAtIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IC0gcG9zaXRpb24gbGVmdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24udG9wIC0gcG9zaXRpb24gdG9wXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmxlZ2VuZCAtIG9wdGlvbnMgZm9yIGxlZ2VuZCBjb21wb25lbnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxlZ2VuZC5hbGlnbiAtIGFsaWduIG9wdGlvbiBmb3IgbGVnZW5kICh0b3B8Ym90dG9tfGxlZnR8Y2VudGVyfG91dGVyKVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aGVtZSAtIHRoZW1lIG5hbWVcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWFwIG1hcCB0eXBlXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxpYlR5cGUgLSB0eXBlIG9mIGdyYXBoIGxpYnJhcnlcbiAqIEByZXR1cm5zIHtvYmplY3R9IGJhciBjaGFydFxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgcmF3RGF0YSA9IHtcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgY29kZTogJ0tSJyxcbiAqICAgICAgICAgICBkYXRhOiAxMDAsXG4gKiAgICAgICAgICAgbGFiZWxDb29yZGluYXRlOiB7XG4gKiAgICAgICAgICAgICB4OiAwLjYsXG4gKiAgICAgICAgICAgICB5OiAwLjdcbiAqICAgICAgICAgICB9XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBjb2RlOiAnSlAnLFxuICogICAgICAgICAgIGRhdGE6IDUwXG4gKiAgICAgICAgIH1cbiAqICAgICAgIF1cbiAqICAgICB9LFxuICogICAgIG9wdGlvbnMgPSB7XG4gKiAgICAgICBjaGFydDoge1xuICogICAgICAgICB0aXRsZTogJ01hcCBDaGFydCdcbiAqICAgICAgIH0sXG4gKiAgICAgICBtYXA6ICd3b3JsZCdcbiAqICAgICB9O1xuICogdHVpLmNoYXJ0Lm1hcENoYXJ0KGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucyk7XG4gKi9cbnR1aS5jaGFydC5tYXBDaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcmF3RGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2hhcnRUeXBlID0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX01BUDtcbiAgICBvcHRpb25zLm1hcCA9IG1hcEZhY3RvcnkuZ2V0KG9wdGlvbnMubWFwKTtcblxuICAgIHJldHVybiBfY3JlYXRlQ2hhcnQoY29udGFpbmVyLCByYXdEYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgdGhlbWUuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gdGhlbWVOYW1lIHRoZW1lIG5hbWVcbiAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBhcHBsaWNhdGlvbiBjaGFydCB0aGVtZVxuICogICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUuY2hhcnQgY2hhcnQgdGhlbWVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5jaGFydC5mb250RmFtaWx5IGZvbnQgZmFtaWx5IG9mIGNoYXJ0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUuY2hhcnQuYmFja2dyb3VuZCBiYWNrZ3JvdW5kIG9mIGNoYXJ0XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS50aXRsZSBjaGFydCB0aGVtZVxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IHRoZW1lLnRpdGxlLmZvbnRTaXplIGZvbnQgc2l6ZSBvZiBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnRpdGxlLmZvbnRGYW1pbHkgZm9udCBmYW1pbHkgb2YgY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS50aXRsZS5jb2xvciBmb250IGNvbG9yIG9mIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUudGl0bGUuYmFja2dyb3VuZCBiYWNrZ3JvdW5kIG9mIGNoYXJ0IHRpdGxlXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS55QXhpcyB0aGVtZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUueUF4aXMudGl0bGUgdGhlbWUgb2YgdmVydGljYWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSB0aGVtZS55QXhpcy50aXRsZS5mb250U2l6ZSBmb250IHNpemUgb2YgdmVydGljYWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS55QXhpcy50aXRsZS5mb250RmFtaWx5IGZvbnQgZmFtaWx5IG9mIHZlcnRpY2FsIGF4aXMgdGl0bGVcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUueUF4aXMudGl0bGUuY29sb3IgZm9udCBjb2xvciBvZiB2ZXJ0aWNhbCBheGlzIHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUueUF4aXMubGFiZWwgdGhlbWUgb2YgdmVydGljYWwgYXhpcyBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSB0aGVtZS55QXhpcy5sYWJlbC5mb250U2l6ZSBmb250IHNpemUgb2YgdmVydGljYWwgYXhpcyBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS55QXhpcy5sYWJlbC5mb250RmFtaWx5IGZvbnQgZmFtaWx5IG9mIHZlcnRpY2FsIGF4aXMgbGFiZWxcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUueUF4aXMubGFiZWwuY29sb3IgZm9udCBjb2xvciBvZiB2ZXJ0aWNhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUueUF4aXMudGlja0NvbG9yIGNvbG9yIG9mIHZlcnRpY2FsIGF4aXMgdGlja1xuICogICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUueEF4aXMgdGhlbWUgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUueEF4aXMudGl0bGUgdGhlbWUgb2YgaG9yaXpvbnRhbCBheGlzIHRpdGxlXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IHRoZW1lLnhBeGlzLnRpdGxlLmZvbnRTaXplIGZvbnQgc2l6ZSBvZiBob3Jpem9udGFsIGF4aXMgdGl0bGVcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUueEF4aXMudGl0bGUuZm9udEZhbWlseSBmb250IGZhbWlseSBvZiBob3Jpem9udGFsIGF4aXMgdGl0bGVcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUueEF4aXMudGl0bGUuY29sb3IgZm9udCBjb2xvciBvZiBob3Jpem9udGFsIGF4aXMgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS54QXhpcy5sYWJlbCB0aGVtZSBvZiBob3Jpem9udGFsIGF4aXMgbGFiZWxcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gdGhlbWUueEF4aXMubGFiZWwuZm9udFNpemUgZm9udCBzaXplIG9mIGhvcml6b250YWwgYXhpcyBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS54QXhpcy5sYWJlbC5mb250RmFtaWx5IGZvbnQgZmFtaWx5IG9mIGhvcml6b250YWwgYXhpcyBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS54QXhpcy5sYWJlbC5jb2xvciBmb250IGNvbG9yIG9mIGhvcml6b250YWwgYXhpcyBsYWJlbFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnhBeGlzLnRpY2tDb2xvciBjb2xvciBvZiBob3Jpem9udGFsIGF4aXMgdGlja1xuICogICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUucGxvdCBwbG90IHRoZW1lXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUucGxvdC5saW5lQ29sb3IgcGxvdCBsaW5lIGNvbG9yXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUucGxvdC5iYWNrZ3JvdW5kIHBsb3QgYmFja2dyb3VuZFxuICogICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUuc2VyaWVzIHNlcmllcyB0aGVtZVxuICogICAgICAgICAgQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gdGhlbWUuc2VyaWVzLmNvbG9ycyBzZXJpZXMgY29sb3JzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUuc2VyaWVzLmJvcmRlckNvbG9yIHNlcmllcyBib3JkZXIgY29sb3JcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5zZXJpZXMuc2VsZWN0aW9uQ29sb3Igc2VyaWVzIHNlbGVjdGlvbiBjb2xvclxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnNlcmllcy5zdGFydENvbG9yIHN0YXJ0IGNvbG9yIGZvciBtYXAgY2hhcnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5zZXJpZXMuZW5kQ29sb3IgZW5kIGNvbG9yIGZvciBtYXAgY2hhcnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5zZXJpZXMub3ZlckNvbG9yIGVuZCBjb2xvciBmb3IgbWFwIGNoYXJ0XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS5sZWdlbmQgbGVnZW5kIHRoZW1lXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUubGVnZW5kLmxhYmVsIHRoZW1lIG9mIGxlZ2VuZCBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSB0aGVtZS5sZWdlbmQubGFiZWwuZm9udFNpemUgZm9udCBzaXplIG9mIGxlZ2VuZCBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5sZWdlbmQubGFiZWwuZm9udEZhbWlseSBmb250IGZhbWlseSBvZiBsZWdlbmQgbGFiZWxcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUubGVnZW5kLmxhYmVsLmNvbG9yIGZvbnQgY29sb3Igb2YgbGVnZW5kIGxhYmVsXG4gKiBAYXBpXG4gKiBAZXhhbXBsZVxuICogdmFyIHRoZW1lID0ge1xuICogICB5QXhpczoge1xuICogICAgIHRpY2tDb2xvcjogJyNjY2JkOWEnLFxuICogICAgICAgdGl0bGU6IHtcbiAqICAgICAgICAgY29sb3I6ICcjMzMzMzMzJ1xuICogICAgICAgfSxcbiAqICAgICAgIGxhYmVsOiB7XG4gKiAgICAgICAgIGNvbG9yOiAnIzZmNDkxZCdcbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHhBeGlzOiB7XG4gKiAgICAgICB0aWNrQ29sb3I6ICcjY2NiZDlhJyxcbiAqICAgICAgIHRpdGxlOiB7XG4gKiAgICAgICAgIGNvbG9yOiAnIzMzMzMzMydcbiAqICAgICAgIH0sXG4gKiAgICAgICBsYWJlbDoge1xuICogICAgICAgICBjb2xvcjogJyM2ZjQ5MWQnXG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICBwbG90OiB7XG4gKiAgICAgICBsaW5lQ29sb3I6ICcjZTVkYmM0JyxcbiAqICAgICAgIGJhY2tncm91bmQ6ICcjZjZmMWU1J1xuICogICAgIH0sXG4gKiAgICAgc2VyaWVzOiB7XG4gKiAgICAgICBjb2xvcnM6IFsnIzQwYWJiNCcsICcjZTc4YTMxJywgJyNjMWM0NTInLCAnIzc5NTIyNCcsICcjZjVmNWY1J10sXG4gKiAgICAgICBib3JkZXJDb2xvcjogJyM4ZTY1MzUnLFxuICogICAgICAgc2VsZWN0aW9uQ29sb3I6ICcjY2NjY2NjJyxcbiAqICAgICAgIHN0YXJ0Q29sb3I6ICcjZWZlZmVmJyxcbiAqICAgICAgIGVuZENvbG9yOiAnYmx1ZScsXG4gKiAgICAgICBvdmVyQ29sb3I6ICd5ZWxsb3cnXG4gKiAgICAgfSxcbiAqICAgICBsZWdlbmQ6IHtcbiAqICAgICAgIGxhYmVsOiB7XG4gKiAgICAgICAgIGNvbG9yOiAnIzZmNDkxZCdcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH07XG4gKiB0dWkuY2hhcnQucmVnaXN0ZXJUaGVtZSgnbmV3VGhlbWUnLCB0aGVtZSk7XG4gKi9cbnR1aS5jaGFydC5yZWdpc3RlclRoZW1lID0gZnVuY3Rpb24odGhlbWVOYW1lLCB0aGVtZSkge1xuICAgIHRoZW1lRmFjdG9yeS5yZWdpc3Rlcih0aGVtZU5hbWUsIHRoZW1lKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgbWFwLlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWUgbWFwIG5hbWVcbiAqIEBwYXJhbSB7QXJyYXkuPHtjb2RlOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgcGF0aDogc3RyaW5nfT59IGRhdGEgbWFwIGRhdGFcbiAqIEBhcGlcbiAqIEBleGFtcGxlXG4gKiB2YXIgZGF0YSA9IFtcbiAqICAge1xuICogICAgIGNvZGU6ICdLUicsXG4gKiAgICAgbmFtZTogJ1NvdXRoIEtvcmVhJyxcbiAqICAgICBwYXRoOiAnTTgzNS4xMywzNDYuNTNMODM3LjU1LDM1MC43MS4uLicsXG4gKiAgICAgbGFiZWxDb29yZGluYXRlOiB7XG4gKiAgICAgICB4OiAwLjYsXG4gKiAgICAgICB5OiAwLjdcbiAqICAgICB9XG4gKiAgIH0sXG4gKiAgIC8vLi4uXG4gKiBdO1xuICogdHVpLmNoYXJ0LnJlZ2lzdGVyTWFwKCduZXdNYXAnLCBkYXRhKTtcbiAqL1xudHVpLmNoYXJ0LnJlZ2lzdGVyTWFwID0gZnVuY3Rpb24obWFwTmFtZSwgZGF0YSkge1xuICAgIG1hcEZhY3RvcnkucmVnaXN0ZXIobWFwTmFtZSwgZGF0YSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGdyYXBoIHBsdWdpbi5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaWJUeXBlIHR5cGUgb2YgZ3JhcGggbGlicmFyeVxuICogQHBhcmFtIHtvYmplY3R9IHBsdWdpbiBwbHVnaW4gdG8gY29udHJvbCBsaWJyYXJ5XG4gKiBAZXhhbXBsZVxuICogdmFyIHBsdWdpblJhcGhhZWwgPSB7XG4gKiAgIGJhcjogZnVuY3Rpb24oKSB7fSAvLyBSZW5kZXIgY2xhc3NcbiAqIH07XG4gKiB0dWkuY2hhcnQucmVnaXN0ZXJQbHVnaW4oJ3JhcGhhZWwnLCBwbHVnaW5SYXBoYWVsKTtcbiAqL1xudHVpLmNoYXJ0LnJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24obGliVHlwZSwgcGx1Z2luKSB7XG4gICAgcGx1Z2luRmFjdG9yeS5yZWdpc3RlcihsaWJUeXBlLCBwbHVnaW4pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG4vKipcbiAqIGFkZGluZ0R5bmFtaWNEYXRhIGlzIG1peGVyIGZvciBhZGRpbmcgZHluYW1pYyBkYXRhLlxuICogQG1peGluXG4gKi9cbnZhciBhZGRpbmdEeW5hbWljRGF0YU1peGVyID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZm9yIGFkZGluZyBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRGb3JBZGRpbmdEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgbG9va3VwcGluZyBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvb2t1cHBpbmcgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciBwYXVzZWQgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmVuZGVyaW5nIGRlbGF5IHRpbWVyIGlkXG4gICAgICAgICAqIEB0eXBlIHtudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXJlbmRlcmluZ0RlbGF5VGltZXJJZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFkZGVkIGRhdGEgY291bnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkZWREYXRhQ291bnQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVja2VkIGxlZ2VuZHMuXG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwgQXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja2VkTGVnZW5kcyA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgZm9yIGFkZGluZyBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGVGb3JBZGRpbmdEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYm91bmRzTWFrZXIgPSB0aGlzLmJvdW5kc01ha2VyO1xuICAgICAgICB2YXIgc2hpZnRpbmdPcHRpb24gPSAhIXR1aS51dGlsLnBpY2sodGhpcy5vcHRpb25zLnNlcmllcywgJ3NoaWZ0aW5nJyk7XG4gICAgICAgIHZhciBiZWZvcmVBeGVzRGF0YSA9IGJvdW5kc01ha2VyLmdldEF4ZXNEYXRhKCk7XG4gICAgICAgIHZhciBiZWZvcmVTaXplUmF0aW8gPSBiZWZvcmVBeGVzRGF0YS54QXhpcy5zaXplUmF0aW8gfHwgMTtcblxuICAgICAgICB0aGlzLmFkZGVkRGF0YUNvdW50ICs9IDE7XG4gICAgICAgIHRoaXMuYXhpc1NjYWxlTWFrZXJNYXAgPSBudWxsO1xuICAgICAgICBib3VuZHNNYWtlci5pbml0Qm91bmRzRGF0YSgpO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB4QXhpc1dpZHRoID0gYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCd4QXhpcycpLndpZHRoICogYmVmb3JlU2l6ZVJhdGlvO1xuICAgICAgICAgICAgdmFyIHRpY2tTaXplID0gKHhBeGlzV2lkdGggLyAoc2VsZi5kYXRhUHJvY2Vzc29yLmdldENhdGVnb3J5Q291bnQoZmFsc2UpIC0gMSkpO1xuXG4gICAgICAgICAgICBzZWxmLl9yZW5kZXJDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICB0aWNrU2l6ZTogdGlja1NpemUgKyBjaGFydENvbnN0Lk9WRVJMQVBQSU5HX1dJRFRILFxuICAgICAgICAgICAgICAgIHNoaWZ0aW5nOiBzaGlmdGluZ09wdGlvblxuICAgICAgICAgICAgfSwgJ2FuaW1hdGVGb3JBZGRpbmdEYXRhJyk7XG4gICAgICAgIH0sIGJlZm9yZUF4ZXNEYXRhKTtcblxuICAgICAgICBpZiAoc2hpZnRpbmdPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb2Nlc3Nvci5zaGlmdERhdGEoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXJlbmRlciBmb3IgYWRkaW5nIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVyZW5kZXJGb3JBZGRpbmdEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0dWkudXRpbC5waWNrKHRoaXMub3B0aW9ucy5zZXJpZXMsICdzaGlmdGluZycpKSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kc01ha2VyLmluaXRCb3VuZHNEYXRhKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmF4aXNTY2FsZU1ha2VyTWFwID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9yZW5kZXIoZnVuY3Rpb24ocmVuZGVyaW5nRGF0YSkge1xuICAgICAgICAgICAgcmVuZGVyaW5nRGF0YS5hbmltYXRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLl9yZW5kZXJDb21wb25lbnRzKHJlbmRlcmluZ0RhdGEsICdyZXJlbmRlcicpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGFkZGVkIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tGb3JBZGRlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBhZGRlZCA9IHRoaXMuZGF0YVByb2Nlc3Nvci5hZGREYXRhRnJvbUR5bmFtaWNEYXRhKCk7XG5cbiAgICAgICAgaWYgKCFhZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5sb29rdXBwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZUZvckFkZGluZ0RhdGEoKTtcbiAgICAgICAgdGhpcy5yZXJlbmRlcmluZ0RlbGF5VGltZXJJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnJlcmVuZGVyaW5nRGVsYXlUaW1lcklkID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuX3JlcmVuZGVyRm9yQWRkaW5nRGF0YSgpO1xuICAgICAgICAgICAgc2VsZi5fY2hlY2tGb3JBZGRlZERhdGEoKTtcbiAgICAgICAgfSwgNDAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGF1c2UgYW5pbWF0aW9uIGZvciBhZGRpbmcgZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wYXVzZUFuaW1hdGlvbkZvckFkZGluZ0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2luaXRGb3JBdXRvVGlja0ludGVydmFsKCk7XG5cbiAgICAgICAgaWYgKHRoaXMucmVyZW5kZXJpbmdEZWxheVRpbWVySWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlcmVuZGVyaW5nRGVsYXlUaW1lcklkKTtcbiAgICAgICAgICAgIHRoaXMucmVyZW5kZXJpbmdEZWxheVRpbWVySWQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAodHVpLnV0aWwucGljayh0aGlzLm9wdGlvbnMuc2VyaWVzLCAnc2hpZnRpbmcnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVByb2Nlc3Nvci5zaGlmdERhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0YXJ0IGFuaW1hdGlvbiBmb3IgYWRkaW5nIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzdGFydEFuaW1hdGlvbkZvckFkZGluZ0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvb2t1cHBpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRMb29rdXAoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgbG9va3VwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3N0YXJ0TG9va3VwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubG9va3VwcGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb29rdXBwaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9jaGVja0ZvckFkZGVkRGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnkgLSBjYXRlZ29yeVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIHZhbHVlc1xuICAgICAqL1xuICAgIGFkZERhdGE6IGZ1bmN0aW9uKGNhdGVnb3J5LCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLmFkZER5bmFtaWNEYXRhKGNhdGVnb3J5LCB2YWx1ZXMpO1xuICAgICAgICB0aGlzLl9zdGFydExvb2t1cCgpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBjaGVja2VkIGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljw/Ym9vbGVhbj4gfCB7bGluZTogP0FycmF5Ljxib29sZWFuPiwgY29sdW1uOiA/QXJyYXkuPGJvb2xlYW4+fX0gY2hlY2tlZExlZ2VuZHMgY2hlY2tlZCBsZWdlbmRzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSByYXdEYXRhIHJhd0RhdGFcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IGJvdW5kc1BhcmFtcyBhZGRpdGlvbiBwYXJhbXMgZm9yIGNhbGN1bGF0aW5nIGJvdW5kc1xuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9jaGFuZ2VDaGVja2VkTGVnZW5kczogZnVuY3Rpb24oY2hlY2tlZExlZ2VuZHMsIHJhd0RhdGEsIGJvdW5kc1BhcmFtcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwYXN0UGF1c2VkID0gdGhpcy5wYXVzZWQ7XG5cbiAgICAgICAgaWYgKCFwYXN0UGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZUFuaW1hdGlvbkZvckFkZGluZ0RhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hlY2tlZExlZ2VuZHMgPSBjaGVja2VkTGVnZW5kcztcbiAgICAgICAgdGhpcy5fcmVyZW5kZXIoY2hlY2tlZExlZ2VuZHMsIHJhd0RhdGEsIGJvdW5kc1BhcmFtcyk7XG5cblxuICAgICAgICBpZiAoIXBhc3RQYXVzZWQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVzdGFydEFuaW1hdGlvbkZvckFkZGluZ0RhdGEoKTtcbiAgICAgICAgICAgIH0sIGNoYXJ0Q29uc3QuUkVSRU5ERVJfVElNRSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZGluZ0R5bmFtaWNEYXRhTWl4ZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQXJlYSBjaGFydFxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpO1xudmFyIGxpbmVUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2xpbmVUeXBlTWl4ZXInKTtcbnZhciBhdXRvVGlja01peGVyID0gcmVxdWlyZSgnLi9hdXRvVGlja01peGVyJyk7XG52YXIgem9vbU1peGVyID0gcmVxdWlyZSgnLi96b29tTWl4ZXInKTtcbnZhciBheGlzVHlwZU1peGVyID0gcmVxdWlyZSgnLi9heGlzVHlwZU1peGVyJyk7XG52YXIgYWRkaW5nRHluYW1pY0RhdGFNaXhlciA9IHJlcXVpcmUoJy4vYWRkaW5nRHluYW1pY0RhdGFNaXhlcicpO1xudmFyIHJhd0RhdGFIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGVscGVycy9yYXdEYXRhSGFuZGxlcicpO1xudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4uL3Nlcmllcy9hcmVhQ2hhcnRTZXJpZXMnKTtcblxudmFyIEFyZWFDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKENoYXJ0QmFzZSwgLyoqIEBsZW5kcyBMaW5lQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBjbGFzc05hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogJ3R1aS1hcmVhLWNoYXJ0JyxcblxuICAgIC8qKlxuICAgICAqIFNlcmllcyBjbGFzc1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICBTZXJpZXM6IFNlcmllcyxcblxuICAgIC8qKlxuICAgICAqIEFyZWEgY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgQXJlYUNoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqIEBtaXhlcyBheGlzVHlwZU1peGVyXG4gICAgICogQG1peGVzIGxpbmVUeXBlTWl4ZXJcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICByYXdEYXRhSGFuZGxlci5yZW1vdmVTZXJpZXNTdGFjayhyYXdEYXRhLnNlcmllcyk7XG4gICAgICAgIHRoaXMuX2xpbmVUeXBlSW5pdChyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2luaXRGb3JBdXRvVGlja0ludGVydmFsKCk7XG4gICAgICAgIHRoaXMuX2luaXRGb3JBZGRpbmdEYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGNoYW5nZSBjaGVja2VkIGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljw/Ym9vbGVhbj4gfCB7bGluZTogP0FycmF5Ljxib29sZWFuPiwgY29sdW1uOiA/QXJyYXkuPGJvb2xlYW4+fX0gY2hlY2tlZExlZ2VuZHMgY2hlY2tlZCBsZWdlbmRzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSByYXdEYXRhIHJhd0RhdGFcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IGJvdW5kc1BhcmFtcyBhZGRpdGlvbiBwYXJhbXMgZm9yIGNhbGN1bGF0aW5nIGJvdW5kc1xuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIG9uQ2hhbmdlQ2hlY2tlZExlZ2VuZHM6IGZ1bmN0aW9uKGNoZWNrZWRMZWdlbmRzLCByYXdEYXRhLCBib3VuZHNQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlQ2hlY2tlZExlZ2VuZHMoY2hlY2tlZExlZ2VuZHMsIHJhd0RhdGEsIGJvdW5kc1BhcmFtcyk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLmV4dGVuZChBcmVhQ2hhcnQucHJvdG90eXBlLFxuICAgIGF4aXNUeXBlTWl4ZXIsIGxpbmVUeXBlTWl4ZXIsIGF1dG9UaWNrTWl4ZXIsIHpvb21NaXhlciwgYWRkaW5nRHluYW1pY0RhdGFNaXhlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJlYUNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGF1dG9UaWNrTWl4ZXIgaXMgbWl4ZXIgZm9yIG1ha2luZyBhdXRvIHRpY2suXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF4aXNEYXRhTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2F4aXNEYXRhTWFrZXInKTtcblxuLyoqXG4gKiBhdXRvVGlja01peGVyIGlzIG1peGVyIGZvciBtYWtpbmcgYXV0byB0aWNrLlxuICogQG1peGluXG4gKi9cbnZhciBhdXRvVGlja01peGVyID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZm9yIGF1dG8gdGljayBpbnRlcnZhbCBvcHRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEZvckF1dG9UaWNrSW50ZXJ2YWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogcHJldmlvdXMgdXBkYXRlZCB4QXhpc0RhdGFcbiAgICAgICAgICogQHR5cGUge251bGwgfCBvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZVcGRhdGVkRGF0YSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpcnN0IHVwZGF0ZWQgdGljayBjb3VudFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJzdFRpY2tDb3VudCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBheGVzRGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF91cGRhdGVBeGVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBib3VuZHNNYWtlciA9IHRoaXMuYm91bmRzTWFrZXI7XG4gICAgICAgIHZhciBheGVzRGF0YSA9IGJvdW5kc01ha2VyLmdldEF4ZXNEYXRhKCk7XG4gICAgICAgIHZhciB4QXhpc0RhdGEgPSBheGVzRGF0YS54QXhpcztcbiAgICAgICAgdmFyIHNlcmllc1dpZHRoID0gYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKS53aWR0aDtcbiAgICAgICAgdmFyIHNoaWZ0aW5nT3B0aW9uID0gdHVpLnV0aWwucGljayh0aGlzLm9wdGlvbnMuc2VyaWVzLCAnc2hpZnRpbmcnKTtcbiAgICAgICAgdmFyIHByZXZVcGRhdGVkRGF0YSA9IHRoaXMucHJldlVwZGF0ZWREYXRhO1xuXG4gICAgICAgIGlmIChzaGlmdGluZ09wdGlvbiB8fCAhcHJldlVwZGF0ZWREYXRhKSB7XG4gICAgICAgICAgICBheGlzRGF0YU1ha2VyLnVwZGF0ZUxhYmVsQXhpc0RhdGFGb3JBdXRvVGlja0ludGVydmFsKHhBeGlzRGF0YSwgc2VyaWVzV2lkdGgsIHRoaXMuYWRkZWREYXRhQ291bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXhpc0RhdGFNYWtlci51cGRhdGVMYWJlbEF4aXNEYXRhRm9yU3RhY2tpbmdEeW5hbWljRGF0YSh4QXhpc0RhdGEsIHByZXZVcGRhdGVkRGF0YSwgdGhpcy5maXJzdFRpY2tDb3VudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXZVcGRhdGVkRGF0YSA9IHhBeGlzRGF0YTtcblxuICAgICAgICBpZiAoIXRoaXMuZmlyc3RUaWNrQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RUaWNrQ291bnQgPSB4QXhpc0RhdGEudGlja0NvdW50O1xuICAgICAgICB9XG5cbiAgICAgICAgYm91bmRzTWFrZXIucmVnaXN0ZXJBeGVzRGF0YShheGVzRGF0YSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhdXRvVGlja01peGVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGF4aXNUeXBlTWl4ZXIgaXMgbWl4ZXIgZm9yIGhlbHAgdG8gYXhpcyB0eXBlcyBjaGFydHMgbGlrZSBiYXIsIGNvbHVtbiwgbGluZSwgYXJlYSxcbiAqICAgICAgICAgICAgICAgICAgYnViYmxlLCBjb2x1bW4mbGluZSBjb21iby5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2hhcnRCYXNlID0gcmVxdWlyZSgnLi9jaGFydEJhc2UnKTtcbnZhciBheGlzRGF0YU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9heGlzRGF0YU1ha2VyJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG52YXIgQXhpcyA9IHJlcXVpcmUoJy4uL2F4ZXMvYXhpcycpO1xudmFyIFBsb3QgPSByZXF1aXJlKCcuLi9wbG90cy9wbG90Jyk7XG52YXIgTGVnZW5kID0gcmVxdWlyZSgnLi4vbGVnZW5kcy9sZWdlbmQnKTtcbnZhciBHcm91cFR5cGVDdXN0b21FdmVudCA9IHJlcXVpcmUoJy4uL2N1c3RvbUV2ZW50cy9ncm91cFR5cGVDdXN0b21FdmVudCcpO1xudmFyIEJvdW5kc1R5cGVDdXN0b21FdmVudCA9IHJlcXVpcmUoJy4uL2N1c3RvbUV2ZW50cy9ib3VuZHNUeXBlQ3VzdG9tRXZlbnQnKTtcbnZhciBUb29sdGlwID0gcmVxdWlyZSgnLi4vdG9vbHRpcHMvdG9vbHRpcCcpO1xudmFyIEdyb3VwVG9vbHRpcCA9IHJlcXVpcmUoJy4uL3Rvb2x0aXBzL2dyb3VwVG9vbHRpcCcpO1xuXG4vKipcbiAqIEF4aXMgbGltaXQgdmFsdWUuXG4gKiBAdHlwZWRlZiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGF4aXNMaW1pdFxuICovXG5cbi8qKlxuICogYXhpc1R5cGVNaXhlciBpcyBtaXhlciBmb3IgaGVscCB0byBheGlzIHR5cGVzIGNoYXJ0cyBsaWtlIGJhciwgY29sdW1uLCBsaW5lLCBhcmVhLCBidWJibGUsIGNvbHVtbiZsaW5lIGNvbWJvLlxuICogQG1peGluXG4gKi9cbnZhciBheGlzVHlwZU1peGVyID0ge1xuICAgIC8qKlxuICAgICAqIEFkZCBheGlzIGNvbXBvbmVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gYXhlcyBheGVzIG9wdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxpZ25lZCB3aGV0aGVyIGFsaWduZWQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQXhpc0NvbXBvbmVudHM6IGZ1bmN0aW9uKGF4ZXMsIGFsaWduZWQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGF4ZXMsIGZ1bmN0aW9uKGF4aXMpIHtcbiAgICAgICAgICAgIHZhciBheGlzUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGFsaWduZWQ6IGFsaWduZWQsXG4gICAgICAgICAgICAgICAgaXNMYWJlbDogISFheGlzLmlzTGFiZWwsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogISFheGlzLmlzVmVydGljYWwsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBheGlzLmNoYXJ0VHlwZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGF4aXMubmFtZSA9PT0gJ3JpZ2h0WUF4aXMnKSB7XG4gICAgICAgICAgICAgICAgYXhpc1BhcmFtcy5jb21wb25lbnRUeXBlID0gJ3lBeGlzJztcbiAgICAgICAgICAgICAgICBheGlzUGFyYW1zLmluZGV4ID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKGF4aXMubmFtZSwgQXhpcywgYXhpc1BhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0ge0FycmF5PG9iamVjdD59IHNlcmllc2VzIHNlcmllc2VzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxpZ25lZCB3aGV0aGVyIGFsaWduZWQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkU2VyaWVzQ29tcG9uZW50czogZnVuY3Rpb24oc2VyaWVzZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VyaWVzQmFzZVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBsaWJUeXBlOiBvcHRpb25zLmxpYlR5cGUsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBvcHRpb25zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHRoaXMudXNlckV2ZW50LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6ICdzZXJpZXMnLFxuICAgICAgICAgICAgICAgIGNoYXJ0QmFja2dyb3VuZDogdGhpcy50aGVtZS5jaGFydC5iYWNrZ3JvdW5kXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2goc2VyaWVzZXMsIGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgdmFyIHNlcmllc1BhcmFtcyA9IHR1aS51dGlsLmV4dGVuZChzZXJpZXNCYXNlUGFyYW1zLCBzZXJpZXMuZGF0YSk7XG4gICAgICAgICAgICBzZWxmLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoc2VyaWVzLm5hbWUsIHNlcmllcy5TZXJpZXNDbGFzcywgc2VyaWVzUGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCB0b29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRUb29sdGlwQ29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIFRvb2x0aXBDbGFzcyA9IHRoaXMuaGFzR3JvdXBUb29sdGlwID8gR3JvdXBUb29sdGlwIDogVG9vbHRpcDtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCd0b29sdGlwJywgVG9vbHRpcENsYXNzLCB0aGlzLl9tYWtlVG9vbHRpcERhdGEoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBsZWdlbmQgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7bnVsbCB8IG9iamVjdH0gTGVnZW5kQ2xhc3MgLSBMZWdlbmQgdHlwZSBjbGFzc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHNlcmllc05hbWVzIC0gc2VyaWVzIG5hbWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydFR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRMZWdlbmRDb21wb25lbnQ6IGZ1bmN0aW9uKExlZ2VuZENsYXNzLCBzZXJpZXNOYW1lcywgY2hhcnRUeXBlKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcignbGVnZW5kJywgTGVnZW5kQ2xhc3MgfHwgTGVnZW5kLCB7XG4gICAgICAgICAgICBzZXJpZXNOYW1lczogc2VyaWVzTmFtZXMsXG4gICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgIHVzZXJFdmVudDogdGhpcy51c2VyRXZlbnRcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjb21wb25lbnRzIGZvciBheGlzIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmF4ZXMgYXhlcyBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnBsb3REYXRhIHBsb3QgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gcGFyYW1zLnNlcmllc2VzIHNlcmllc2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ29tcG9uZW50c0ZvckF4aXNUeXBlOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBhbGlnbmVkID0gISFwYXJhbXMuYWxpZ25lZDtcbiAgICAgICAgdmFyIExlZ2VuZENsYXNzO1xuXG4gICAgICAgIGlmIChwYXJhbXMucGxvdCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCdwbG90JywgUGxvdCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hZGRBeGlzQ29tcG9uZW50cyhwYXJhbXMuYXhpcywgYWxpZ25lZCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubGVnZW5kLnZpc2libGUpIHtcbiAgICAgICAgICAgIExlZ2VuZENsYXNzID0gdHVpLnV0aWwuaXNPYmplY3QocGFyYW1zLmxlZ2VuZCkgPyBwYXJhbXMubGVnZW5kLkxlZ2VuZENsYXNzIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FkZExlZ2VuZENvbXBvbmVudChMZWdlbmRDbGFzcywgcGFyYW1zLnNlcmllc05hbWVzLCBwYXJhbXMuY2hhcnRUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FkZFNlcmllc0NvbXBvbmVudHMocGFyYW1zLnNlcmllcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2FkZFRvb2x0aXBDb21wb25lbnQoKTtcbiAgICAgICAgdGhpcy5fYWRkQ3VzdG9tRXZlbnRDb21wb25lbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxpbWl0IG1hcC5cbiAgICAgKiBAcGFyYW0ge3t5QXhpczogb2JqZWN0LCB4QXhpczogb2JqZWN0fX0gYXhlc0RhdGEgYXhlcyBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHt7Y29sdW1uOiA/YXhpc0xpbWl0LCBsaW5lOiA/YXhpc0xpbWl0fX0gbGltaXQgbWFwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGltaXRNYXA6IGZ1bmN0aW9uKGF4ZXNEYXRhLCBjaGFydFR5cGVzKSB7XG4gICAgICAgIHZhciBsaW1pdE1hcCA9IHt9LFxuICAgICAgICAgICAgeUF4aXNMaW1pdCA9IGF4ZXNEYXRhLnlBeGlzID8gYXhlc0RhdGEueUF4aXMubGltaXQgOiBheGVzRGF0YS5yaWdodFlBeGlzLmxpbWl0O1xuXG4gICAgICAgIGxpbWl0TWFwW2NoYXJ0VHlwZXNbMF1dID0gdGhpcy5pc1ZlcnRpY2FsID8geUF4aXNMaW1pdCA6IGF4ZXNEYXRhLnhBeGlzLmxpbWl0O1xuXG4gICAgICAgIGlmIChjaGFydFR5cGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxpbWl0TWFwW2NoYXJ0VHlwZXNbMV1dID0gYXhlc0RhdGEucmlnaHRZQXhpcyA/IGF4ZXNEYXRhLnJpZ2h0WUF4aXMubGltaXQgOiB5QXhpc0xpbWl0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbWl0TWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWFwIGZvciBBeGlzU2NhbGVNYWtlciBvZiBheGVzKHhBeGlzLCB5QXhpcykuXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCBBeGlzU2NhbGVNYWtlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QXhpc1NjYWxlTWFrZXJNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuYXhpc1NjYWxlTWFrZXJNYXApIHtcbiAgICAgICAgICAgIHRoaXMuYXhpc1NjYWxlTWFrZXJNYXAgPSB0aGlzLl9tYWtlQXhpc1NjYWxlTWFrZXJNYXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmF4aXNTY2FsZU1ha2VyTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGF4aXMgZGF0YSBmb3IgcmVuZGVyaW5nIGFyZWEgb2YgYXhpcyBsaWtlIHlBeGlzLCB4QXhpcywgcmlnaHRZQXhpcy5cbiAgICAgKiBAcGFyYW0ge0F4aXNTY2FsZU1ha2VyfSBheGlzU2NhbGVNYWtlciAtIEF4aXNTY2FsZU1ha2VyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBheGlzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNWZXJ0aWNhbF0gLSB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzUG9zaXRpb25SaWdodF0gLSB3aGV0aGVyIHJpZ2h0IHBvc2l0aW9uIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUF4aXNEYXRhOiBmdW5jdGlvbihheGlzU2NhbGVNYWtlciwgb3B0aW9ucywgaXNWZXJ0aWNhbCwgaXNQb3NpdGlvblJpZ2h0KSB7XG4gICAgICAgIHZhciBhbGlnbmVkID0gcHJlZGljYXRlLmlzTGluZVR5cGVDaGFydCh0aGlzLmNoYXJ0VHlwZSwgdGhpcy5jaGFydFR5cGVzKTtcbiAgICAgICAgdmFyIGF4aXNEYXRhO1xuXG4gICAgICAgIGlmIChheGlzU2NhbGVNYWtlcikge1xuICAgICAgICAgICAgYXhpc0RhdGEgPSBheGlzRGF0YU1ha2VyLm1ha2VWYWx1ZUF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICBheGlzU2NhbGVNYWtlcjogYXhpc1NjYWxlTWFrZXIsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiAhIWlzVmVydGljYWwsXG4gICAgICAgICAgICAgICAgaXNQb3NpdGlvblJpZ2h0OiAhIWlzUG9zaXRpb25SaWdodCxcbiAgICAgICAgICAgICAgICBhbGlnbmVkOiAhIWFsaWduZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXhpc0RhdGEgPSBheGlzRGF0YU1ha2VyLm1ha2VMYWJlbEF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICBsYWJlbHM6IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRDYXRlZ29yaWVzKGlzVmVydGljYWwpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogISFpc1ZlcnRpY2FsLFxuICAgICAgICAgICAgICAgIGlzUG9zaXRpb25SaWdodDogISFpc1Bvc2l0aW9uUmlnaHQsXG4gICAgICAgICAgICAgICAgYWxpZ25lZDogISFhbGlnbmVkLFxuICAgICAgICAgICAgICAgIGFkZGVkRGF0YUNvdW50OiB0dWkudXRpbC5waWNrKHRoaXMub3B0aW9ucy5zZXJpZXMsICdzaGlmdGluZycpID8gdGhpcy5hZGRlZERhdGFDb3VudCA6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF4aXNEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGF4ZXMgZGF0YSwgdXNlZCBpbiBhIGF4aXMgY29tcG9uZW50IGxpa2UgeUF4aXMsIHhBeGlzLCByaWdodFlBeGlzLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGF4ZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VBeGVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBheGlzU2NhbGVNYWtlck1hcCA9IHRoaXMuX2dldEF4aXNTY2FsZU1ha2VyTWFwKCk7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgeUF4aXNPcHRpb25zID0gdHVpLnV0aWwuaXNBcnJheShvcHRpb25zLnlBeGlzKSA/IG9wdGlvbnMueUF4aXMgOiBbb3B0aW9ucy55QXhpc107XG4gICAgICAgIHZhciBheGVzRGF0YSA9IHtcbiAgICAgICAgICAgIHhBeGlzOiB0aGlzLl9tYWtlQXhpc0RhdGEoYXhpc1NjYWxlTWFrZXJNYXAueEF4aXMsIG9wdGlvbnMueEF4aXMpLFxuICAgICAgICAgICAgeUF4aXM6IHRoaXMuX21ha2VBeGlzRGF0YShheGlzU2NhbGVNYWtlck1hcC55QXhpcywgeUF4aXNPcHRpb25zWzBdLCB0cnVlKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1JpZ2h0WUF4aXMpIHtcbiAgICAgICAgICAgIGF4ZXNEYXRhLnJpZ2h0WUF4aXMgPSB0aGlzLl9tYWtlQXhpc0RhdGEobnVsbCwgeUF4aXNPcHRpb25zWzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBheGVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YSBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7e3lBeGlzOiBvYmplY3QsIHhBeGlzOiBvYmplY3R9fSBheGVzRGF0YSBheGVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIGNoYXJ0IHR5cGVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YUZvclJlbmRlcmluZzogZnVuY3Rpb24oYXhlc0RhdGEsIGNoYXJ0VHlwZXMpIHtcbiAgICAgICAgdmFyIGxpbWl0TWFwID0gdGhpcy5fZ2V0TGltaXRNYXAoYXhlc0RhdGEsIGNoYXJ0VHlwZXMpO1xuICAgICAgICB2YXIgYWxpZ25lZCA9IGF4ZXNEYXRhLnhBeGlzLmFsaWduZWQ7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhID0ge307XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgc2VyaWVzRGF0YVtjaGFydFR5cGUgKyAnU2VyaWVzJ10gPSB7XG4gICAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0TWFwW2NoYXJ0VHlwZV0sXG4gICAgICAgICAgICAgICAgYWxpZ25lZDogYWxpZ25lZCxcbiAgICAgICAgICAgICAgICBoYXNBeGVzOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2FkZERhdGFSYXRpb3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBheGVzRGF0YSA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0QXhlc0RhdGEoKTtcbiAgICAgICAgdmFyIGNoYXJ0VHlwZXMgPSB0aGlzLmNoYXJ0VHlwZXMgfHwgW3RoaXMuY2hhcnRUeXBlXTtcbiAgICAgICAgdmFyIGxpbWl0TWFwID0gdGhpcy5fZ2V0TGltaXRNYXAoYXhlc0RhdGEsIGNoYXJ0VHlwZXMpO1xuICAgICAgICB2YXIgc3RhY2tUeXBlID0gdHVpLnV0aWwucGljayh0aGlzLm9wdGlvbnMuc2VyaWVzLCAnc3RhY2tUeXBlJyk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgc2VsZi5kYXRhUHJvY2Vzc29yLmFkZERhdGFSYXRpb3MobGltaXRNYXBbY2hhcnRUeXBlXSwgc3RhY2tUeXBlLCBjaGFydFR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSByZW5kZXJpbmcgZGF0YSBmb3IgYXhpcyB0eXBlIGNoYXJ0LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGRhdGEgZm9yIHJlbmRlcmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VSZW5kZXJpbmdEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGF4ZXNEYXRhID0gdGhpcy5ib3VuZHNNYWtlci5nZXRBeGVzRGF0YSgpO1xuICAgICAgICB2YXIgb3B0aW9uQ2hhcnRUeXBlcyA9IHRoaXMuY2hhcnRUeXBlcyB8fCBbdGhpcy5jaGFydFR5cGVdO1xuICAgICAgICB2YXIgc2VyaWVzRGF0YSA9IHRoaXMuX21ha2VTZXJpZXNEYXRhRm9yUmVuZGVyaW5nKGF4ZXNEYXRhLCBvcHRpb25DaGFydFR5cGVzLCB0aGlzLmlzVmVydGljYWwpO1xuICAgICAgICB2YXIgeUF4aXMgPSBheGVzRGF0YS55QXhpcyA/IGF4ZXNEYXRhLnlBeGlzIDogYXhlc0RhdGEucmlnaHRZQXhpcztcbiAgICAgICAgdmFyIHhBeGlzID0gYXhlc0RhdGEueEF4aXM7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBwbG90OiB7XG4gICAgICAgICAgICAgICAgdlRpY2tDb3VudDogeUF4aXMudmFsaWRUaWNrQ291bnQsXG4gICAgICAgICAgICAgICAgaFRpY2tDb3VudDogYXhlc0RhdGEueEF4aXMudmFsaWRUaWNrQ291bnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXN0b21FdmVudDoge1xuICAgICAgICAgICAgICAgIHRpY2tDb3VudDogdGhpcy5pc1ZlcnRpY2FsID8gKHhBeGlzLmV2ZW50VGlja0NvdW50IHx8IHhBeGlzLnRpY2tDb3VudCkgOiB5QXhpcy50aWNrQ291bnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VyaWVzRGF0YSwgYXhlc0RhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZ3JvdXBlZCBldmVudCBoYW5kbGVyIGxheWVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50Rm9yR3JvdXBUb29sdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCdjdXN0b21FdmVudCcsIEdyb3VwVHlwZUN1c3RvbUV2ZW50LCB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgY2hhcnRUeXBlczogdGhpcy5jaGFydFR5cGVzLFxuICAgICAgICAgICAgem9vbWFibGU6IHR1aS51dGlsLnBpY2sodGhpcy5vcHRpb25zLnNlcmllcywgJ3pvb21hYmxlJylcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjdXN0b20gZXZlbnQgY29tcG9uZW50IGZvciBub3JtYWwgdG9vbHRpcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDdXN0b21FdmVudENvbXBvbmVudEZvck5vcm1hbFRvb2x0aXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2N1c3RvbUV2ZW50JywgQm91bmRzVHlwZUN1c3RvbUV2ZW50LCB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDdXN0b21FdmVudENvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0dyb3VwVG9vbHRpcCkge1xuICAgICAgICAgICAgdGhpcy5fYWRkQ3VzdG9tRXZlbnRDb21wb25lbnRGb3JHcm91cFRvb2x0aXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50Rm9yTm9ybWFsVG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBjb29yZGluYXRlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Q3VzdG9tRXZlbnR9IGN1c3RvbUV2ZW50IGN1c3RvbSBldmVudCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1Rvb2x0aXB9IHRvb2x0aXAgdG9vbHRpcCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxTZXJpZXM+fSBzZXJpZXNlcyBzZXJpZXMgY29tcG9uZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50Rm9yR3JvdXBUb29sdGlwOiBmdW5jdGlvbihjdXN0b21FdmVudCwgdG9vbHRpcCwgc2VyaWVzZXMpIHtcbiAgICAgICAgY3VzdG9tRXZlbnQub24oJ3Nob3dHcm91cFRvb2x0aXAnLCB0b29sdGlwLm9uU2hvdywgdG9vbHRpcCk7XG4gICAgICAgIGN1c3RvbUV2ZW50Lm9uKCdoaWRlR3JvdXBUb29sdGlwJywgdG9vbHRpcC5vbkhpZGUsIHRvb2x0aXApO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2goc2VyaWVzZXMsIGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgaWYgKHNlcmllcy5vblNob3dHcm91cFRvb2x0aXBMaW5lKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5vbignc2hvd0dyb3VwVG9vbHRpcExpbmUnLCBzZXJpZXMub25TaG93R3JvdXBUb29sdGlwTGluZSwgc2VyaWVzKTtcbiAgICAgICAgICAgICAgICB0b29sdGlwLm9uKCdoaWRlR3JvdXBUb29sdGlwTGluZScsIHNlcmllcy5vbkhpZGVHcm91cFRvb2x0aXBMaW5lLCBzZXJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9vbHRpcC5vbignc2hvd0dyb3VwQW5pbWF0aW9uJywgc2VyaWVzLm9uU2hvd0dyb3VwQW5pbWF0aW9uLCBzZXJpZXMpO1xuICAgICAgICAgICAgdG9vbHRpcC5vbignaGlkZUdyb3VwQW5pbWF0aW9uJywgc2VyaWVzLm9uSGlkZUdyb3VwQW5pbWF0aW9uLCBzZXJpZXMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGN1c3RvbSBldmVudCBmb3Igbm9ybWFsIHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtDdXN0b21FdmVudH0gY3VzdG9tRXZlbnQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7VG9vbHRpcH0gdG9vbHRpcCB0b29sdGlwIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFNlcmllcz59IHNlcmllc2VzIHNlcmllcyBjb21wb25lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXR0YWNoQ3VzdG9tRXZlbnRGb3JOb3JtYWxUb29sdGlwOiBmdW5jdGlvbihjdXN0b21FdmVudCwgdG9vbHRpcCwgc2VyaWVzZXMpIHtcbiAgICAgICAgY3VzdG9tRXZlbnQub24oJ3Nob3dUb29sdGlwJywgdG9vbHRpcC5vblNob3csIHRvb2x0aXApO1xuICAgICAgICBjdXN0b21FdmVudC5vbignaGlkZVRvb2x0aXAnLCB0b29sdGlwLm9uSGlkZSwgdG9vbHRpcCk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICB2YXIgc2hvd0FuaW1hdGlvbkV2ZW50TmFtZSwgaGlkZUFuaW1hdGlvbkV2ZW50TmFtZTtcblxuICAgICAgICAgICAgaWYgKHNlcmllcy5vblNob3dBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzaG93QW5pbWF0aW9uRXZlbnROYW1lID0gcmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzaG93Jywgc2VyaWVzLmNoYXJ0VHlwZSwgJ2FuaW1hdGlvbicpO1xuICAgICAgICAgICAgICAgIGhpZGVBbmltYXRpb25FdmVudE5hbWUgPSByZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ2hpZGUnLCBzZXJpZXMuY2hhcnRUeXBlLCAnYW5pbWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5vbihzaG93QW5pbWF0aW9uRXZlbnROYW1lLCBzZXJpZXMub25TaG93QW5pbWF0aW9uLCBzZXJpZXMpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAub24oaGlkZUFuaW1hdGlvbkV2ZW50TmFtZSwgc2VyaWVzLm9uSGlkZUFuaW1hdGlvbiwgc2VyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBjdXN0b20gZXZlbnQgZm9yIHNlcmllcyBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtDdXN0b21FdmVudH0gY3VzdG9tRXZlbnQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFNlcmllcz59IHNlcmllc2VzIHNlcmllcyBjb21wb25lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXR0YWNoQ3VzdG9tRXZlbnRGb3JTZXJpZXNTZWxlY3Rpb246IGZ1bmN0aW9uKGN1c3RvbUV2ZW50LCBzZXJpZXNlcykge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHNlcmllc2VzLCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RTZXJpZXNFdmVudE5hbWUgPSByZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ3NlbGVjdCcsIHNlcmllcy5jaGFydFR5cGUsICdzZXJpZXMnKSxcbiAgICAgICAgICAgICAgICB1bnNlbGVjdFNlcmllc0V2ZW50TmFtZSA9IHJlbmRlclV0aWwubWFrZUN1c3RvbUV2ZW50TmFtZSgndW5zZWxlY3QnLCBzZXJpZXMuY2hhcnRUeXBlLCAnc2VyaWVzJyk7XG5cbiAgICAgICAgICAgIGN1c3RvbUV2ZW50Lm9uKHNlbGVjdFNlcmllc0V2ZW50TmFtZSwgc2VyaWVzLm9uU2VsZWN0U2VyaWVzLCBzZXJpZXMpO1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQub24odW5zZWxlY3RTZXJpZXNFdmVudE5hbWUsIHNlcmllcy5vblVuc2VsZWN0U2VyaWVzLCBzZXJpZXMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGN1c3RvbSBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9hdHRhY2hDdXN0b21FdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNlcyA9IHRoaXMuY29tcG9uZW50TWFuYWdlci53aGVyZSh7Y29tcG9uZW50VHlwZTogJ3Nlcmllcyd9KSxcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnY3VzdG9tRXZlbnQnKSxcbiAgICAgICAgICAgIHRvb2x0aXAgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCd0b29sdGlwJyk7XG5cbiAgICAgICAgQ2hhcnRCYXNlLnByb3RvdHlwZS5fYXR0YWNoQ3VzdG9tRXZlbnQuY2FsbCh0aGlzLCBzZXJpZXNlcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzR3JvdXBUb29sdGlwKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hDdXN0b21FdmVudEZvckdyb3VwVG9vbHRpcChjdXN0b21FdmVudCwgdG9vbHRpcCwgc2VyaWVzZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoQ3VzdG9tRXZlbnRGb3JOb3JtYWxUb29sdGlwKGN1c3RvbUV2ZW50LCB0b29sdGlwLCBzZXJpZXNlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hdHRhY2hDdXN0b21FdmVudEZvclNlcmllc1NlbGVjdGlvbihjdXN0b21FdmVudCwgc2VyaWVzZXMpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpc1R5cGVNaXhlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBCYXIgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgYXhpc1R5cGVNaXhlciA9IHJlcXVpcmUoJy4vYXhpc1R5cGVNaXhlcicpO1xudmFyIGJhclR5cGVNaXhlciA9IHJlcXVpcmUoJy4vYmFyVHlwZU1peGVyJyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvYmFyQ2hhcnRTZXJpZXMnKTtcblxudmFyIEJhckNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIEJhckNoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQmFyIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIEJhckNoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQG1peGVzIGF4aXNUeXBlTWl4ZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsYXNzTmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWJhci1jaGFydCc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgaGFzIHJpZ2h0IHkgYXhpcyBvciBub3QuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNSaWdodFlBeGlzID0gZmFsc2U7XG5cbiAgICAgICAgb3B0aW9ucy55QXhpcyA9IG9wdGlvbnMueUF4aXMgfHwge307XG4gICAgICAgIG9wdGlvbnMueEF4aXMgPSBvcHRpb25zLnhBeGlzIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnBsb3QgPSBvcHRpb25zLnBsb3QgfHwge307XG4gICAgICAgIG9wdGlvbnMuc2VyaWVzID0gb3B0aW9ucy5zZXJpZXMgfHwge307XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc1ZhbGlkU3RhY2tPcHRpb24ob3B0aW9ucy5zZXJpZXMuc3RhY2tUeXBlKSkge1xuICAgICAgICAgICAgcmF3RGF0YS5zZXJpZXMgPSB0aGlzLl9zb3J0UmF3U2VyaWVzRGF0YShyYXdEYXRhLnNlcmllcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMuZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICByYXdEYXRhLnNlcmllcyA9IHRoaXMuX21ha2VSYXdTZXJpZXNEYXRhRm9yRGl2ZXJnaW5nKHJhd0RhdGEuc2VyaWVzLCBvcHRpb25zLnNlcmllcy5zdGFja1R5cGUpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGl2ZXJnaW5nT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgQ2hhcnRCYXNlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgcmF3RGF0YTogcmF3RGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBoYXNBeGVzOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHMob3B0aW9ucy5jaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgb3B0aW9ucyBmb3IgZGl2ZXJnaW5nIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlRGl2ZXJnaW5nT3B0aW9uOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBpc0NlbnRlcjtcblxuICAgICAgICBvcHRpb25zLnNlcmllcy5zdGFja1R5cGUgPSBvcHRpb25zLnNlcmllcy5zdGFja1R5cGUgfHwgY2hhcnRDb25zdC5OT1JNQUxfU1RBQ0tfVFlQRTtcbiAgICAgICAgdGhpcy5oYXNSaWdodFlBeGlzID0gdHVpLnV0aWwuaXNBcnJheShvcHRpb25zLnlBeGlzKSAmJiBvcHRpb25zLnlBeGlzLmxlbmd0aCA+IDE7XG5cbiAgICAgICAgaXNDZW50ZXIgPSBwcmVkaWNhdGUuaXNZQXhpc0FsaWduQ2VudGVyKHRoaXMuaGFzUmlnaHRZQXhpcywgb3B0aW9ucy55QXhpcy5hbGlnbik7XG5cbiAgICAgICAgb3B0aW9ucy55QXhpcy5pc0NlbnRlciA9IGlzQ2VudGVyO1xuICAgICAgICBvcHRpb25zLnhBeGlzLmRpdmlkZWQgPSBpc0NlbnRlcjtcbiAgICAgICAgb3B0aW9ucy5zZXJpZXMuZGl2aWRlZCA9IGlzQ2VudGVyO1xuICAgICAgICBvcHRpb25zLnBsb3QuZGl2aWRlZCA9IGlzQ2VudGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG1hcCBmb3IgQXhpc1NjYWxlTWFrZXIgb2YgYXhlcyh4QXhpcywgeUF4aXMpLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgQXhpc1NjYWxlTWFrZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBeGlzU2NhbGVNYWtlck1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4QXhpczogdGhpcy5fY3JlYXRlQXhpc1NjYWxlTWFrZXIodGhpcy5vcHRpb25zLnhBeGlzLCAneEF4aXMnKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENvbXBvbmVudHM6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgYXhlcyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneUF4aXMnLFxuICAgICAgICAgICAgICAgIGlzTGFiZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneEF4aXMnXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzUmlnaHRZQXhpcykge1xuICAgICAgICAgICAgYXhlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAncmlnaHRZQXhpcycsXG4gICAgICAgICAgICAgICAgaXNMYWJlbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzRm9yQXhpc1R5cGUoe1xuICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICBheGlzOiBheGVzLFxuICAgICAgICAgICAgc2VyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYmFyU2VyaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgU2VyaWVzQ2xhc3M6IFNlcmllc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBwbG90OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjaGFuZ2Ugc2VsZWN0ZWQgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fSBjaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKi9cbiAgICBvbkNoYW5nZUNoZWNrZWRMZWdlbmRzOiBmdW5jdGlvbihjaGVja2VkTGVnZW5kcykge1xuICAgICAgICB2YXIgYm91bmRQYXJhbXM7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzUmlnaHRZQXhpcykge1xuICAgICAgICAgICAgYm91bmRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uQ2hhcnRUeXBlczogWydiYXInLCAnYmFyJ11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBDaGFydEJhc2UucHJvdG90eXBlLm9uQ2hhbmdlQ2hlY2tlZExlZ2VuZHMuY2FsbCh0aGlzLCBjaGVja2VkTGVnZW5kcywgbnVsbCwgYm91bmRQYXJhbXMpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5leHRlbmQoQmFyQ2hhcnQucHJvdG90eXBlLCBheGlzVHlwZU1peGVyLCBiYXJUeXBlTWl4ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhckNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGJhclR5cGVNaXhlciBpcyBtaXhlciBvZiBiYXIgdHlwZSBjaGFydChiYXIsIGNvbHVtbikuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHJhd0RhdGFIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGVscGVycy9yYXdEYXRhSGFuZGxlcicpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG5cbi8qKlxuICogYmFyVHlwZU1peGVyIGlzIG1peGVyIG9mIGJhciB0eXBlIGNoYXJ0KGJhciwgY29sdW1uKS5cbiAqIEBtaXhpblxuICovXG52YXIgYmFyVHlwZU1peGVyID0ge1xuICAgIC8qKlxuICAgICAqIE1ha2UgbWludXMgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGEgbnVtYmVyIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IG1pbnVzIHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VNaW51c1ZhbHVlczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGRhdGEsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gMCA6IC12YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcGx1cyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YSBudW1iZXIgZGF0YVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGx1cyB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUGx1c1ZhbHVlczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGRhdGEsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gMCA6IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBub3JtYWwgZGl2ZXJnaW5nIHJhdyBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3tkYXRhOiBBcnJheS48bnVtYmVyPn19IHJhd1Nlcmllc0RhdGEgcmF3IHNlcmllcyBkYXRhXG4gICAgICogQHJldHVybnMge3tkYXRhOiBBcnJheS48bnVtYmVyPn19IGNoYW5nZWQgcmF3IHNlcmllcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU5vcm1hbERpdmVyZ2luZ1Jhd1Nlcmllc0RhdGE6IGZ1bmN0aW9uKHJhd1Nlcmllc0RhdGEpIHtcbiAgICAgICAgcmF3U2VyaWVzRGF0YS5sZW5ndGggPSBNYXRoLm1pbihyYXdTZXJpZXNEYXRhLmxlbmd0aCwgMik7XG5cbiAgICAgICAgcmF3U2VyaWVzRGF0YVswXS5kYXRhID0gdGhpcy5fbWFrZU1pbnVzVmFsdWVzKHJhd1Nlcmllc0RhdGFbMF0uZGF0YSk7XG5cbiAgICAgICAgaWYgKHJhd1Nlcmllc0RhdGFbMV0pIHtcbiAgICAgICAgICAgIHJhd1Nlcmllc0RhdGFbMV0uZGF0YSA9IHRoaXMuX21ha2VQbHVzVmFsdWVzKHJhd1Nlcmllc0RhdGFbMV0uZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmF3U2VyaWVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSByYXcgc2VyaWVzIGRhdGEgZm9yIHN0YWNrZWQgZGl2ZXJnaW5nIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tkYXRhOiBBcnJheS48bnVtYmVyPiwgc3RhY2s6IHN0cmluZ319IHJhd1Nlcmllc0RhdGEgcmF3IHNlcmllcyBkYXRhXG4gICAgICogQHJldHVybnMge3tkYXRhOiBBcnJheS48bnVtYmVyPn19IGNoYW5nZWQgcmF3IHNlcmllcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVJhd1Nlcmllc0RhdGFGb3JTdGFja2VkRGl2ZXJnaW5nOiBmdW5jdGlvbihyYXdTZXJpZXNEYXRhKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHN0YWNrcyA9IHJhd0RhdGFIYW5kbGVyLnBpY2tTdGFja3MocmF3U2VyaWVzRGF0YSwgdHJ1ZSksXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGxlZnRTdGFjayA9IHN0YWNrc1swXSxcbiAgICAgICAgICAgIHJpZ2h0U3RhY2sgPSBzdGFja3NbMV07XG5cbiAgICAgICAgcmF3U2VyaWVzRGF0YSA9IHJhd0RhdGFIYW5kbGVyLnNvcnRTZXJpZXNEYXRhKHJhd1Nlcmllc0RhdGEsIHN0YWNrcyk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHJhd1Nlcmllc0RhdGEsIGZ1bmN0aW9uKHNlcmllc0RhdHVtKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBzZXJpZXNEYXR1bS5zdGFjayB8fCBjaGFydENvbnN0LkRFRkFVTFRfU1RBQ0s7XG4gICAgICAgICAgICBpZiAoc3RhY2sgPT09IGxlZnRTdGFjaykge1xuICAgICAgICAgICAgICAgIHNlcmllc0RhdHVtLmRhdGEgPSBzZWxmLl9tYWtlTWludXNWYWx1ZXMoc2VyaWVzRGF0dW0uZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VyaWVzRGF0dW0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFjayA9PT0gcmlnaHRTdGFjaykge1xuICAgICAgICAgICAgICAgIHNlcmllc0RhdHVtLmRhdGEgPSBzZWxmLl9tYWtlUGx1c1ZhbHVlcyhzZXJpZXNEYXR1bS5kYXRhKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZXJpZXNEYXR1bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcmF3IHNlcmllcyBkYXRhIGZvciBkaXZlcmdpbmcuXG4gICAgICogQHBhcmFtIHt7ZGF0YTogQXJyYXkuPG51bWJlcj4sIHN0YWNrOiBzdHJpbmd9fSByYXdTZXJpZXNEYXRhIHJhdyBzZXJpZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gc3RhY2tUeXBlT3B0aW9uIHN0YWNrVHlwZSBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7e2RhdGE6IEFycmF5LjxudW1iZXI+fX0gY2hhbmdlZCByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUmF3U2VyaWVzRGF0YUZvckRpdmVyZ2luZzogZnVuY3Rpb24ocmF3U2VyaWVzRGF0YSwgc3RhY2tUeXBlT3B0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNWYWxpZFN0YWNrT3B0aW9uKHN0YWNrVHlwZU9wdGlvbikpIHtcbiAgICAgICAgICAgIHJhd1Nlcmllc0RhdGEgPSB0aGlzLl9tYWtlUmF3U2VyaWVzRGF0YUZvclN0YWNrZWREaXZlcmdpbmcocmF3U2VyaWVzRGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYXdTZXJpZXNEYXRhID0gdGhpcy5fbWFrZU5vcm1hbERpdmVyZ2luZ1Jhd1Nlcmllc0RhdGEocmF3U2VyaWVzRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmF3U2VyaWVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU29ydCByYXcgc2VyaWVzIGRhdGEgZnJvbSBzdGFja3MuXG4gICAgICogQHBhcmFtIHtBcnJheS48e2RhdGE6IEFycmF5LjxudW1iZXI+LCBzdGFjazogc3RyaW5nfT59IHJhd1Nlcmllc0RhdGEgcmF3IHNlcmllcyBkYXRhXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7ZGF0YTogQXJyYXkuPG51bWJlcj4sIHN0YWNrOiBzdHJpbmd9Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zb3J0UmF3U2VyaWVzRGF0YTogZnVuY3Rpb24ocmF3U2VyaWVzRGF0YSkge1xuICAgICAgICB2YXIgc3RhY2tzID0gcmF3RGF0YUhhbmRsZXIucGlja1N0YWNrcyhyYXdTZXJpZXNEYXRhKTtcblxuICAgICAgICByZXR1cm4gcmF3RGF0YUhhbmRsZXIuc29ydFNlcmllc0RhdGEocmF3U2VyaWVzRGF0YSwgc3RhY2tzKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhclR5cGVNaXhlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBCdWJibGUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgU2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL2J1YmJsZUNoYXJ0U2VyaWVzJyk7XG52YXIgQ2lyY2xlTGVnZW5kID0gcmVxdWlyZSgnLi4vbGVnZW5kcy9jaXJjbGVMZWdlbmQnKTtcbnZhciBheGlzVHlwZU1peGVyID0gcmVxdWlyZSgnLi9heGlzVHlwZU1peGVyJyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcbnZhciBTaW1wbGVDdXN0b21FdmVudCA9IHJlcXVpcmUoJy4uL2N1c3RvbUV2ZW50cy9zaW1wbGVDdXN0b21FdmVudCcpO1xuXG52YXIgQnViYmxlQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDaGFydEJhc2UsIC8qKiBAbGVuZHMgQnViYmxlQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBjbGFzc05hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogJ3R1aS1idWJibGUtY2hhcnQnLFxuICAgIC8qKlxuICAgICAqIEJ1YmJsZSBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBCdWJibGVDaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBtaXhlcyBheGlzVHlwZU1peGVyXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd0RhdGEsIHRoZW1lLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMudG9vbHRpcCA9IG9wdGlvbnMudG9vbHRpcCB8fCB7fTtcblxuICAgICAgICB0aGlzLmF4aXNTY2FsZU1ha2VyTWFwID0gbnVsbDtcblxuICAgICAgICBpZiAoIW9wdGlvbnMudG9vbHRpcC5hbGlnbikge1xuICAgICAgICAgICAgb3B0aW9ucy50b29sdGlwLmFsaWduID0gY2hhcnRDb25zdC5UT09MVElQX0RFRkFVTFRfQUxJR05fT1BUSU9OO1xuICAgICAgICB9XG5cbiAgICAgICAgQ2hhcnRCYXNlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgcmF3RGF0YTogcmF3RGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBoYXNBeGVzOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHMob3B0aW9ucy5jaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGVmYXVsdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgYnViYmxlIGNoYXJ0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfc2V0RGVmYXVsdE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgQ2hhcnRCYXNlLnByb3RvdHlwZS5fc2V0RGVmYXVsdE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNpcmNsZUxlZ2VuZCA9IHRoaXMub3B0aW9ucy5jaXJjbGVMZWdlbmQgfHwge307XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzVW5kZWZpbmVkKHRoaXMub3B0aW9ucy5jaXJjbGVMZWdlbmQudmlzaWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jaXJjbGVMZWdlbmQudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBtYXAgZm9yIEF4aXNTY2FsZU1ha2VyIG9mIGF4ZXMoeEF4aXMsIHlBeGlzKS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsIEF4aXNTY2FsZU1ha2VyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhpc1NjYWxlTWFrZXJNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGFzQ2F0ZWdvcmllcyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5oYXNDYXRlZ29yaWVzKCk7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzRGF0YU1vZGVsKHRoaXMuY2hhcnRUeXBlKTtcbiAgICAgICAgdmFyIGlzWENvdW50R3JlYXRlclRoYW5ZQ291bnQgPSBzZXJpZXNEYXRhTW9kZWwuaXNYQ291bnRHcmVhdGVyVGhhbllDb3VudCgpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIHNjYWxlTWFrZXJNYXAgPSB7fTtcblxuICAgICAgICBpZiAoaGFzQ2F0ZWdvcmllcykge1xuICAgICAgICAgICAgaWYgKGlzWENvdW50R3JlYXRlclRoYW5ZQ291bnQpIHtcbiAgICAgICAgICAgICAgICBzY2FsZU1ha2VyTWFwLnhBeGlzID0gdGhpcy5fY3JlYXRlQXhpc1NjYWxlTWFrZXIob3B0aW9ucy54QXhpcywgJ3hBeGlzJywgJ3gnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NhbGVNYWtlck1hcC55QXhpcyA9IHRoaXMuX2NyZWF0ZUF4aXNTY2FsZU1ha2VyKG9wdGlvbnMueUF4aXMsICd5QXhpcycsICd5JywgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FsZU1ha2VyTWFwLnhBeGlzID0gdGhpcy5fY3JlYXRlQXhpc1NjYWxlTWFrZXIob3B0aW9ucy54QXhpcywgJ3hBeGlzJywgJ3gnKTtcbiAgICAgICAgICAgIHNjYWxlTWFrZXJNYXAueUF4aXMgPSB0aGlzLl9jcmVhdGVBeGlzU2NhbGVNYWtlcihvcHRpb25zLnlBeGlzLCAneUF4aXMnLCAneScsIG51bGwsIHtcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2FsZU1ha2VyTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENvbXBvbmVudHM6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzRm9yQXhpc1R5cGUoe1xuICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICBheGlzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneUF4aXMnLFxuICAgICAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4QXhpcydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc2VyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYnViYmxlU2VyaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgU2VyaWVzQ2xhc3M6IFNlcmllc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBwbG90OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2lyY2xlTGVnZW5kLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcignY2lyY2xlTGVnZW5kJywgQ2lyY2xlTGVnZW5kLCB7XG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgYmFzZUZvbnRGYW1pbHk6IHRoaXMudGhlbWUuY2hhcnQuZm9udEZhbWlseVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHdpZHRoIG9mIGxlZ2VuZCBhbmQgc2VyaWVzIG9mIGJvdW5kc01ha2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNXaWR0aCAtIHdpZHRoIG9mIHNlcmllcyBhcmVhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZ2VuZFdpZHRoIC0gd2lkdGggb2YgbGVnZW5kIGFyZWFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVMZWdlbmRBbmRTZXJpZXNXaWR0aDogZnVuY3Rpb24oc2VyaWVzV2lkdGgsIGxlZ2VuZFdpZHRoKSB7XG4gICAgICAgIHZhciBjaXJjbGVMZWdlbmRXaWR0aCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdjaXJjbGVMZWdlbmQnKS53aWR0aDtcblxuICAgICAgICBpZiAocHJlZGljYXRlLmhhc1ZlcnRpY2FsTGVnZW5kV2lkdGgodGhpcy5vcHRpb25zLmxlZ2VuZCkpIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCYXNlRGltZW5zaW9uKCdsZWdlbmQnLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGNpcmNsZUxlZ2VuZFdpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCYXNlRGltZW5zaW9uKCdzZXJpZXMnLCB7XG4gICAgICAgICAgICB3aWR0aDogc2VyaWVzV2lkdGggLSAoY2lyY2xlTGVnZW5kV2lkdGggLSBsZWdlbmRXaWR0aClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB3aWR0aCBvZiBsZWdlbmQgYXJlYSBieSB3aWR0aCBvZiBjaXJjbGUgbGVnZW5kIGFyZWEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlTGVnZW5kV2lkdGhCeUNpcmNsZUxlZ2VuZFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJvdW5kc01ha2VyID0gdGhpcy5ib3VuZHNNYWtlcjtcbiAgICAgICAgdmFyIGF4ZXNEYXRhID0gYm91bmRzTWFrZXIuZ2V0QXhlc0RhdGEoKTtcbiAgICAgICAgdmFyIGNpcmNsZUxlZ2VuZFdpZHRoID0gYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdjaXJjbGVMZWdlbmQnKS53aWR0aDtcbiAgICAgICAgdmFyIGxlZ2VuZFdpZHRoID0gYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdjYWxjdWxhdGlvbkxlZ2VuZCcpLndpZHRoO1xuICAgICAgICB2YXIgaXNYQXhpc0xhYmVsLCBzZXJpZXNXaWR0aDtcblxuICAgICAgICBpZiAobGVnZW5kV2lkdGggPj0gY2lyY2xlTGVnZW5kV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzWEF4aXNMYWJlbCA9IGF4ZXNEYXRhLnhBeGlzLmlzTGFiZWw7XG4gICAgICAgIHNlcmllc1dpZHRoID0gYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKS53aWR0aDtcblxuICAgICAgICB0aGlzLl91cGRhdGVMZWdlbmRBbmRTZXJpZXNXaWR0aChzZXJpZXNXaWR0aCwgbGVnZW5kV2lkdGgpO1xuXG4gICAgICAgIGlmICghaXNYQXhpc0xhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLmF4aXNTY2FsZU1ha2VyTWFwID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQXhlc0RhdGEoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZGltZW5zaW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF91cGRhdGVEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY2lyY2xlTGVnZW5kLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ2NpcmNsZUxlZ2VuZCcpLnJlZ2lzdGVyQ2lyY2xlTGVnZW5kRGltZW5zaW9uKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxlZ2VuZFdpZHRoQnlDaXJjbGVMZWdlbmRXaWR0aCgpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5leHRlbmQoQnViYmxlQ2hhcnQucHJvdG90eXBlLCBheGlzVHlwZU1peGVyKTtcblxuLyoqXG4gKiBBZGQgZGF0YSByYXRpb3MuXG4gKiBAcHJpdmF0ZVxuICogQG92ZXJyaWRlXG4gKi9cbkJ1YmJsZUNoYXJ0LnByb3RvdHlwZS5fYWRkRGF0YVJhdGlvcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2FsZU1ha2VyTWFwID0gdGhpcy5fZ2V0QXhpc1NjYWxlTWFrZXJNYXAoKTtcbiAgICB2YXIgbGltaXRNYXAgPSB7fTtcblxuICAgIGlmIChzY2FsZU1ha2VyTWFwLnhBeGlzKSB7XG4gICAgICAgIGxpbWl0TWFwLnggPSBzY2FsZU1ha2VyTWFwLnhBeGlzLmdldExpbWl0KCk7XG4gICAgfVxuXG4gICAgaWYgKHNjYWxlTWFrZXJNYXAueUF4aXMpIHtcbiAgICAgICAgbGltaXRNYXAueSA9IHNjYWxlTWFrZXJNYXAueUF4aXMuZ2V0TGltaXQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFQcm9jZXNzb3IuYWRkRGF0YVJhdGlvc0ZvckNvb3JkaW5hdGVUeXBlKHRoaXMuY2hhcnRUeXBlLCBsaW1pdE1hcCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBjdXN0b20gZXZlbnQgY29tcG9uZW50IGZvciBub3JtYWwgdG9vbHRpcC5cbiAqIEBwcml2YXRlXG4gKi9cbkJ1YmJsZUNoYXJ0LnByb3RvdHlwZS5fYXR0YWNoQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuY29tcG9uZW50TWFuYWdlcjtcbiAgICB2YXIgY3VzdG9tRXZlbnQgPSBjb21wb25lbnRNYW5hZ2VyLmdldCgnY3VzdG9tRXZlbnQnKTtcbiAgICB2YXIgYnViYmxlU2VyaWVzID0gY29tcG9uZW50TWFuYWdlci5nZXQoJ2J1YmJsZVNlcmllcycpO1xuICAgIHZhciB0b29sdGlwID0gY29tcG9uZW50TWFuYWdlci5nZXQoJ3Rvb2x0aXAnKTtcblxuICAgIGF4aXNUeXBlTWl4ZXIuX2F0dGFjaEN1c3RvbUV2ZW50LmNhbGwodGhpcyk7XG5cbiAgICBjdXN0b21FdmVudC5vbih7XG4gICAgICAgIGNsaWNrQnViYmxlU2VyaWVzOiBidWJibGVTZXJpZXMub25DbGlja1NlcmllcyxcbiAgICAgICAgbW92ZUJ1YmJsZVNlcmllczogYnViYmxlU2VyaWVzLm9uTW92ZVNlcmllc1xuICAgIH0sIGJ1YmJsZVNlcmllcyk7XG5cbiAgICBidWJibGVTZXJpZXMub24oe1xuICAgICAgICBzaG93VG9vbHRpcDogdG9vbHRpcC5vblNob3csXG4gICAgICAgIGhpZGVUb29sdGlwOiB0b29sdGlwLm9uSGlkZSxcbiAgICAgICAgc2hvd1Rvb2x0aXBDb250YWluZXI6IHRvb2x0aXAub25TaG93VG9vbHRpcENvbnRhaW5lcixcbiAgICAgICAgaGlkZVRvb2x0aXBDb250YWluZXI6IHRvb2x0aXAub25IaWRlVG9vbHRpcENvbnRhaW5lclxuICAgIH0sIHRvb2x0aXApO1xufTtcblxuLyoqXG4gKiBBZGQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbkJ1YmJsZUNoYXJ0LnByb3RvdHlwZS5fYWRkQ3VzdG9tRXZlbnRDb21wb25lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2N1c3RvbUV2ZW50JywgU2ltcGxlQ3VzdG9tRXZlbnQsIHtcbiAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZVxuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWJibGVDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDaGFydEJhc2VcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29tcG9uZW50TWFuYWdlciA9IHJlcXVpcmUoJy4vY29tcG9uZW50TWFuYWdlcicpO1xudmFyIERlZmF1bHREYXRhUHJvY2Vzc29yID0gcmVxdWlyZSgnLi4vZGF0YU1vZGVscy9kYXRhUHJvY2Vzc29yJyk7XG52YXIgQm91bmRzTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2JvdW5kc01ha2VyJyk7XG52YXIgQXhpc1NjYWxlTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2F4aXNTY2FsZU1ha2VyJyk7XG52YXIgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcbnZhciByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG52YXIgVXNlckV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3VzZXJFdmVudExpc3RlbmVyJyk7XG5cbnZhciBDaGFydEJhc2UgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIENoYXJ0QmFzZS5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIENoYXJ0IGJhc2UuXG4gICAgICogQGNvbnN0cnVjdHMgQ2hhcnRCYXNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5oYXNBeGVzIHdoZXRoZXIgaGFzIGF4ZXMgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge0RhdGFQcm9jZXNzb3J9IHBhcmFtcy5EYXRhUHJvY2Vzc29yIERhdGFQcm9jZXNzb3JcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZW1lXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRoZW1lID0gcGFyYW1zLnRoZW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZXREZWZhdWx0T3B0aW9ucyhwYXJhbXMub3B0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gdGhpcy5vcHRpb25zLmNoYXJ0VHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciBjaGFydCBoYXMgYXhlcyBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0F4ZXMgPSBwYXJhbXMuaGFzQXhlcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVmVydGljYWwgPSAhIXBhcmFtcy5pc1ZlcnRpY2FsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aGV0aGVyIGNoYXJ0IGhhcyBncm91cCB0b29sdGlwIG9yIG5vdFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzR3JvdXBUb29sdGlwID0gISF0dWkudXRpbC5waWNrKHRoaXMub3B0aW9ucywgJ3Rvb2x0aXAnLCAnZ3JvdXBlZCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkYXRhIHByb2Nlc3NvclxuICAgICAgICAgKiBAdHlwZSB7RGF0YVByb2Nlc3Nvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IHRoaXMuX2NyZWF0ZURhdGFQcm9jZXNzb3IocGFyYW1zKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYm91bmRzIG1ha2VyXG4gICAgICAgICAqIEB0eXBlIHtCb3VuZHNNYWtlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBuZXcgQm91bmRzTWFrZXIoe1xuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXG4gICAgICAgICAgICBkYXRhUHJvY2Vzc29yOiB0aGlzLmRhdGFQcm9jZXNzb3IsXG4gICAgICAgICAgICBoYXNBeGVzOiB0aGlzLmhhc0F4ZXMsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0aGlzLmlzVmVydGljYWwsXG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgY2hhcnRUeXBlczogcGFyYW1zLnNlcmllc05hbWVzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb21wb25lbnQgbWFuYWdlclxuICAgICAgICAgKiBAdHlwZSB7Q29tcG9uZW50TWFuYWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlciA9IG5ldyBDb21wb25lbnRNYW5hZ2VyKHtcbiAgICAgICAgICAgIGRhdGFQcm9jZXNzb3I6IHRoaXMuZGF0YVByb2Nlc3NvcixcbiAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIHRoZW1lOiB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgYm91bmRzTWFrZXI6IHRoaXMuYm91bmRzTWFrZXIsXG4gICAgICAgICAgICBoYXNBeGVzOiB0aGlzLmhhc0F4ZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVzZXIgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlckV2ZW50ID0gbmV3IFVzZXJFdmVudExpc3RlbmVyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBjaGFydFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldERlZmF1bHRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMubGVnZW5kID0gb3B0aW9ucy5sZWdlbmQgfHwge307XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubGVnZW5kLnZpc2libGUpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmxlZ2VuZC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBkYXRhUHJvY2Vzc29yIGZvciBwcm9jZXNzaW5nIHJhdyBkYXRhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5yYXdEYXRhIC0gcmF3IGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7RGF0YVByb2Nlc3Nvcn0gcGFyYW1zLkRhdGFQcm9jZXNzb3IgLSBEYXRhUHJvY2Vzc29yIGNsYXNzXG4gICAgICogICAgICBAcGFyYW0ge3tjaGFydDogb2JqZWN0LCBjaGFydFR5cGU6IHN0cmluZ319IHBhcmFtcy5vcHRpb25zIC0gY2hhcnQgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtBcnJheX0gcGFyYW1zLnNlcmllc05hbWVzIHNlcmllcyAtIGNoYXJ0IHR5cGVzIGZvciByZW5kZXJpbmcgc2VyaWVzXG4gICAgICogQHJldHVybnMge29iamVjdH0gZGF0YSBwcm9jZXNzb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVEYXRhUHJvY2Vzc29yOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIERhdGFQcm9jZXNzb3IsIGRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgRGF0YVByb2Nlc3NvciA9IHBhcmFtcy5EYXRhUHJvY2Vzc29yIHx8IERlZmF1bHREYXRhUHJvY2Vzc29yO1xuICAgICAgICBkYXRhUHJvY2Vzc29yID0gbmV3IERhdGFQcm9jZXNzb3IocGFyYW1zLnJhd0RhdGEsIHRoaXMuY2hhcnRUeXBlLCBwYXJhbXMub3B0aW9ucywgcGFyYW1zLnNlcmllc05hbWVzKTtcblxuICAgICAgICByZXR1cm4gZGF0YVByb2Nlc3NvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGljayBsaW1pdCBmcm9tIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyLCB0aXRsZTogc3RyaW5nfX0gb3B0aW9ucyAtIGF4aXMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHt7bWluOiA/bnVtYmVyLCBtYXg6ID9udW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BpY2tMaW1pdEZyb21PcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IG9wdGlvbnMubWluLFxuICAgICAgICAgICAgbWF4OiBvcHRpb25zLm1heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgQXhpc1NjYWxlTWFrZXIuXG4gICAgICogQXhpc1NjYWxlTWFrZXIgY2FsY3VsYXRlcyB0aGUgbGltaXQgYW5kIHN0ZXAgaW50byB2YWx1ZXMgb2YgcHJvY2Vzc2VkIGRhdGEgYW5kIHJldHVybnMgaXQuXG4gICAgICogQHBhcmFtIHt7dGl0bGU6IHN0cmluZywgbWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gYXhpc09wdGlvbnMgLSBvcHRpb25zIGZvciBheGlzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZWFUeXBlIC0gdHlwZSBvZiBhcmVhIGxpa2Ugc2VyaWVzLCB4QXhpcywgeUF4aXMsIGNpcmNsZUxlZ2VuZCwgbGVnZW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlVHlwZSAtIHR5cGUgb2YgdmFsdWUgbGlrZSB2YWx1ZSwgeCwgeSwgclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSB0eXBlIG9mIGNoYXJ0XG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBhZGRpdGlvbmFsUGFyYW1zIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHtBeGlzU2NhbGVNYWtlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVBeGlzU2NhbGVNYWtlcjogZnVuY3Rpb24oYXhpc09wdGlvbnMsIGFyZWFUeXBlLCB2YWx1ZVR5cGUsIGNoYXJ0VHlwZSwgYWRkaXRpb25hbFBhcmFtcykge1xuICAgICAgICB2YXIgbGltaXQgPSB0aGlzLl9waWNrTGltaXRGcm9tT3B0aW9ucyhheGlzT3B0aW9ucyk7XG4gICAgICAgIHZhciBzZXJpZXNPcHRpb25zID0gdGhpcy5vcHRpb25zLnNlcmllcyB8fCB7fTtcblxuICAgICAgICBjaGFydFR5cGUgPSBjaGFydFR5cGUgfHwgdGhpcy5jaGFydFR5cGU7XG4gICAgICAgIHNlcmllc09wdGlvbnMgPSBzZXJpZXNPcHRpb25zW2NoYXJ0VHlwZV0gfHwgc2VyaWVzT3B0aW9ucztcblxuICAgICAgICByZXR1cm4gbmV3IEF4aXNTY2FsZU1ha2VyKHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBkYXRhUHJvY2Vzc29yOiB0aGlzLmRhdGFQcm9jZXNzb3IsXG4gICAgICAgICAgICBib3VuZHNNYWtlcjogdGhpcy5ib3VuZHNNYWtlcixcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzdGFja1R5cGU6IHNlcmllc09wdGlvbnMuc3RhY2tUeXBlLFxuICAgICAgICAgICAgICAgIGRpdmVyZ2luZzogc2VyaWVzT3B0aW9ucy5kaXZlcmdpbmcsXG4gICAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgYXJlYVR5cGU6IGFyZWFUeXBlLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiB2YWx1ZVR5cGUsXG4gICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZVxuICAgICAgICB9LCBhZGRpdGlvbmFsUGFyYW1zKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZGF0YSBmb3IgdG9vbHRpcCBjb21wb25lbnQuXG4gICAgICogQHJldHVybnMge29iamVjdH0gdG9vbHRpcCBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRoaXMuaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgIHVzZXJFdmVudDogdGhpcy51c2VyRXZlbnQsXG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcmVuZGVyaW5nIGRhdGEgZm9yIGF4aXMgdHlwZSBjaGFydC5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByZW5kZXJpbmcgZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUmVuZGVyaW5nRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGN1c3RvbSBldmVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBzZXJpZXNlcyBzZXJpZXNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50OiBmdW5jdGlvbihzZXJpZXNlcykge1xuICAgICAgICB2YXIgbGVnZW5kID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnbGVnZW5kJyk7XG4gICAgICAgIHZhciBjdXN0b21FdmVudCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ2N1c3RvbUV2ZW50Jyk7XG5cbiAgICAgICAgc2VyaWVzZXMgPSBzZXJpZXNlcyB8fCB0aGlzLmNvbXBvbmVudE1hbmFnZXIud2hlcmUoe2NvbXBvbmVudFR5cGU6ICdzZXJpZXMnfSk7XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLnBpY2sodGhpcy5vcHRpb25zLnNlcmllcywgJ3pvb21hYmxlJykpIHtcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50Lm9uKCd6b29tJywgdGhpcy5vblpvb20sIHRoaXMpO1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQub24oJ3Jlc2V0Wm9vbScsIHRoaXMub25SZXNldFpvb20sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICAgICAgbGVnZW5kLm9uKCdjaGFuZ2VDaGVja2VkTGVnZW5kcycsIHRoaXMub25DaGFuZ2VDaGVja2VkTGVnZW5kcywgdGhpcyk7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHNlcmllc2VzLCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0TGVnZW5kRXZlbnROYW1lID0gcmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzZWxlY3QnLCBzZXJpZXMuY2hhcnRUeXBlLCAnbGVnZW5kJyk7XG4gICAgICAgICAgICAgICAgbGVnZW5kLm9uKHNlbGVjdExlZ2VuZEV2ZW50TmFtZSwgc2VyaWVzLm9uU2VsZWN0TGVnZW5kLCBzZXJpZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBheGVzIGRhdGEsIHVzZWQgaW4gYSBheGlzIGNvbXBvbmVudCBsaWtlIHlBeGlzLCB4QXhpcywgcmlnaHRZQXhpcy5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhlc0RhdGE6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZGltZW5zaW9ucy5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVEaW1lbnNpb25zOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX2FkZERhdGFSYXRpb3M6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGNvbXBvbmVudCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY05hbWUgZnVuY3Rpb24gbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V4ZWN1dGVDb21wb25lbnRGdW5jOiBmdW5jdGlvbihmdW5jTmFtZSkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZWFjaChmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRbZnVuY05hbWVdKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50W2Z1bmNOYW1lXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYXhlcyBkYXRhLCB1c2VkIGluIGEgYXhpcyBjb21wb25lbnQgbGlrZSB5QXhpcywgeEF4aXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJBeGVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBheGVzRGF0YSA9IHRoaXMuX21ha2VBeGVzRGF0YSgpO1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyLnJlZ2lzdGVyQXhlc0RhdGEoYXhlc0RhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYXhlc0RhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfdXBkYXRlQXhlc0RhdGE6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25SZW5kZXIgcmVuZGVyIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihvblJlbmRlcikge1xuICAgICAgICB2YXIgbGFiZWxBeGlzT3B0aW9ucyA9ICh0aGlzLmlzVmVydGljYWwgPyB0aGlzLm9wdGlvbnMueEF4aXMgOiB0aGlzLm9wdGlvbnMueUF4aXMpIHx8IHt9O1xuICAgICAgICB2YXIgcmVuZGVyaW5nRGF0YTtcblxuICAgICAgICB0aGlzLl9leGVjdXRlQ29tcG9uZW50RnVuYygncmVnaXN0ZXJEaW1lbnNpb24nKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJBeGVzRGF0YSgpO1xuICAgICAgICB0aGlzLl9leGVjdXRlQ29tcG9uZW50RnVuYygncmVnaXN0ZXJBZGRpdGlvbmFsRGltZW5zaW9uJyk7XG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJTZXJpZXNEaW1lbnNpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5oYXNBeGVzICYmIHByZWRpY2F0ZS5pc0F1dG9UaWNrSW50ZXJ2YWwobGFiZWxBeGlzT3B0aW9ucy50aWNrSW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBeGVzRGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCb3VuZHNEYXRhKCk7XG4gICAgICAgIHRoaXMuX2FkZERhdGFSYXRpb3MoKTtcblxuICAgICAgICByZW5kZXJpbmdEYXRhID0gdGhpcy5fbWFrZVJlbmRlcmluZ0RhdGEoKTtcblxuICAgICAgICBvblJlbmRlcihyZW5kZXJpbmdEYXRhKTtcblxuICAgICAgICB0aGlzLl9zZW5kU2VyaWVzRGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgY2hhcnQuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBjaGFydCBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZG9tLmFkZENsYXNzKGVsLCAndHVpLWNoYXJ0Jyk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRpdGxlKGVsKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oZWwsIHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdjaGFydCcpKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJCYWNrZ3JvdW5kKGVsLCB0aGlzLnRoZW1lLmNoYXJ0LmJhY2tncm91bmQpO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckZvbnRGYW1pbHkoZWwsIHRoaXMudGhlbWUuY2hhcnQuZm9udEZhbWlseSk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyKGZ1bmN0aW9uKHJlbmRlcmluZ0RhdGEpIHtcbiAgICAgICAgICAgIHNlbGYuX3JlbmRlckNvbXBvbmVudHMocmVuZGVyaW5nRGF0YSwgJ3JlbmRlcicsIGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYXR0YWNoQ3VzdG9tRXZlbnQoKTtcbiAgICAgICAgdGhpcy5jaGFydENvbnRhaW5lciA9IGVsO1xuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHJhdyBkYXRhIGJlbG9uZyB0byBjaGVja2VkIGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fSBjaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByYXdEYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlsdGVyQ2hlY2tlZFJhd0RhdGE6IGZ1bmN0aW9uKHJhd0RhdGEsIGNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgIHZhciBjbG9uZURhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJhd0RhdGEpKTtcblxuICAgICAgICBpZiAodHVpLnV0aWwuaXNBcnJheShjbG9uZURhdGEuc2VyaWVzKSkge1xuICAgICAgICAgICAgY2xvbmVEYXRhLnNlcmllcyA9IHR1aS51dGlsLmZpbHRlcihjbG9uZURhdGEuc2VyaWVzLCBmdW5jdGlvbihzZXJpZXMsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrZWRMZWdlbmRzW2luZGV4XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChjbG9uZURhdGEuc2VyaWVzLCBmdW5jdGlvbihzZXJpZXNlcywgY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja2VkTGVnZW5kc1tjaGFydFR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lRGF0YS5zZXJpZXNbY2hhcnRUeXBlXSA9IFtdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hlY2tlZExlZ2VuZHNbY2hhcnRUeXBlXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVEYXRhLnNlcmllc1tjaGFydFR5cGVdID0gdHVpLnV0aWwuZmlsdGVyKHNlcmllc2VzLCBmdW5jdGlvbihzZXJpZXMsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tlZExlZ2VuZHNbY2hhcnRUeXBlXVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb25lRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSByZXJlbmRlcmluZyBkYXRhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZW5kZXJpbmdEYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48P2Jvb2xlYW4+IHwge2xpbmU6ID9BcnJheS48Ym9vbGVhbj4sIGNvbHVtbjogP0FycmF5Ljxib29sZWFuPn19IGNoZWNrZWRMZWdlbmRzIGNoZWNrZWQgbGVnZW5kc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJlbmRlcmluZyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVJlcmVuZGVyaW5nRGF0YTogZnVuY3Rpb24ocmVuZGVyaW5nRGF0YSwgY2hlY2tlZExlZ2VuZHMpIHtcbiAgICAgICAgdmFyIHRvb2x0aXBEYXRhID0gdGhpcy5fbWFrZVRvb2x0aXBEYXRhKCk7XG4gICAgICAgIHZhciBzZXJpZXNlcyA9IHRoaXMuY29tcG9uZW50TWFuYWdlci53aGVyZSh7Y29tcG9uZW50VHlwZTogJ3Nlcmllcyd9KTtcblxuICAgICAgICByZW5kZXJpbmdEYXRhLnRvb2x0aXAgPSB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgY2hlY2tlZExlZ2VuZHM6IGNoZWNrZWRMZWdlbmRzXG4gICAgICAgIH0sIHRvb2x0aXBEYXRhLCByZW5kZXJpbmdEYXRhLnRvb2x0aXApO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2goc2VyaWVzZXMsIGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgcmVuZGVyaW5nRGF0YVtzZXJpZXMuY29tcG9uZW50TmFtZV0gPSB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGNoZWNrZWRMZWdlbmRzOiBjaGVja2VkTGVnZW5kc1tzZXJpZXMuc2VyaWVzTmFtZV0gfHwgY2hlY2tlZExlZ2VuZHNcbiAgICAgICAgICAgIH0sIHJlbmRlcmluZ0RhdGFbc2VyaWVzLmNvbXBvbmVudE5hbWVdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmluZ0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcmVuZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fSBjaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHJhd0RhdGEgcmF3RGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlcmVuZGVyOiBmdW5jdGlvbihjaGVja2VkTGVnZW5kcywgcmF3RGF0YSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhUHJvY2Vzc29yID0gdGhpcy5kYXRhUHJvY2Vzc29yO1xuXG4gICAgICAgIGlmICghcmF3RGF0YSkge1xuICAgICAgICAgICAgcmF3RGF0YSA9IHRoaXMuX2ZpbHRlckNoZWNrZWRSYXdEYXRhKGRhdGFQcm9jZXNzb3IuZ2V0Wm9vbWVkUmF3RGF0YSgpLCBjaGVja2VkTGVnZW5kcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmF4aXNTY2FsZU1ha2VyTWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLmluaXREYXRhKHJhd0RhdGEpO1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyLmluaXRCb3VuZHNEYXRhKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcihmdW5jdGlvbihyZW5kZXJpbmdEYXRhKSB7XG4gICAgICAgICAgICByZW5kZXJpbmdEYXRhID0gc2VsZi5fbWFrZVJlcmVuZGVyaW5nRGF0YShyZW5kZXJpbmdEYXRhLCBjaGVja2VkTGVnZW5kcyk7XG4gICAgICAgICAgICBzZWxmLl9yZW5kZXJDb21wb25lbnRzKHJlbmRlcmluZ0RhdGEsICdyZXJlbmRlcicpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2hhbmdlIGNoZWNrZWQgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fSBjaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHJhd0RhdGEgcmF3RGF0YVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gYm91bmRzUGFyYW1zIGFkZGl0aW9uIHBhcmFtcyBmb3IgY2FsY3VsYXRpbmcgYm91bmRzXG4gICAgICovXG4gICAgb25DaGFuZ2VDaGVja2VkTGVnZW5kczogZnVuY3Rpb24oY2hlY2tlZExlZ2VuZHMsIHJhd0RhdGEsIGJvdW5kc1BhcmFtcykge1xuICAgICAgICB0aGlzLl9yZXJlbmRlcihjaGVja2VkTGVnZW5kcywgcmF3RGF0YSwgYm91bmRzUGFyYW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gem9vbS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBvblpvb206IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBPbiByZXNldCB6b29tLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIG9uUmVzZXRab29tOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRpdGxlLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIGNvbnRhaW5lclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclRpdGxlOiBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGNoYXJ0T3B0aW9ucyA9IHRoaXMub3B0aW9ucy5jaGFydCB8fCB7fTtcbiAgICAgICAgdmFyIHRpdGxlRWxlbWVudCA9IHJlbmRlclV0aWwucmVuZGVyVGl0bGUoY2hhcnRPcHRpb25zLnRpdGxlLCB0aGlzLnRoZW1lLnRpdGxlLCAndHVpLWNoYXJ0LXRpdGxlJyk7XG5cbiAgICAgICAgZG9tLmFwcGVuZChjb250YWluZXIsIHRpdGxlRWxlbWVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjb21wb25lbnRzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZW5kZXJpbmdEYXRhIGRhdGEgZm9yIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jTmFtZSBmdW5jdGlvbiBuYW1lIGZvciBleGVjdXRpb25cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJDb21wb25lbnRzOiBmdW5jdGlvbihyZW5kZXJpbmdEYXRhLCBmdW5jTmFtZSwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBwYXBlcjtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLm1hcChmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBkYXRhLCByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnRbZnVuY05hbWVdKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHJlbmRlcmluZ0RhdGFbY29tcG9uZW50LmNvbXBvbmVudE5hbWVdIHx8IHJlbmRlcmluZ0RhdGEgfHwge307XG4gICAgICAgICAgICAgICAgZGF0YS5wYXBlciA9IHBhcGVyO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBvbmVudFtmdW5jTmFtZV0oZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IHJlc3VsdC5jb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIHBhcGVyID0gcmVzdWx0LnBhcGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgZG9tLmFwcGVuZChjb250YWluZXIsIGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIHNlcmllcyBkYXRhIHRvIGN1c3RvbSBldmVudCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIHR5cGUgb2YgY2hhcnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZW5kU2VyaWVzRGF0YTogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnY3VzdG9tRXZlbnQnKSxcbiAgICAgICAgICAgIHNlcmllc0luZm9zLCBjaGFydFR5cGVzO1xuXG4gICAgICAgIGlmICghY3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJ0VHlwZXMgPSB0aGlzLmNoYXJ0VHlwZXMgfHwgW2NoYXJ0VHlwZSB8fCB0aGlzLmNoYXJ0VHlwZV07XG4gICAgICAgIHNlcmllc0luZm9zID0gdHVpLnV0aWwubWFwKGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKHNlcmllc05hbWUpIHtcbiAgICAgICAgICAgIHZhciBfY2hhcnRUeXBlID0gc2VsZi5kYXRhUHJvY2Vzc29yLmZpbmRDaGFydFR5cGUoc2VyaWVzTmFtZSk7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IChzZXJpZXNOYW1lIHx8IF9jaGFydFR5cGUpICsgJ1Nlcmllcyc7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gc2VsZi5jb21wb25lbnRNYW5hZ2VyLmdldChjb21wb25lbnROYW1lKSB8fCBzZWxmLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCdzZXJpZXMnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IF9jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogY29tcG9uZW50LmdldFNlcmllc0RhdGEoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3VzdG9tRXZlbnQuaW5pdEN1c3RvbUV2ZW50RGF0YShzZXJpZXNJbmZvcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZXZlbnQgbmFtZSBmb3IgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggcHJlZml4XG4gICAgICogQHJldHVybnMge3N0cmluZ30gZXZlbnQgbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBbmltYXRpb25FdmVudE5hbWU6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyBjaGFydFR5cGUuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBjaGFydFR5cGUuc3Vic3RyaW5nKDEpICsgJ0FuaW1hdGlvbic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgY2hhcnQuXG4gICAgICovXG4gICAgYW5pbWF0ZUNoYXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmVhY2goZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmFuaW1hdGVDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuYW5pbWF0ZUNvbXBvbmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgb2YgdXNlciBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIGV2ZW50IGNhbGxiYWNrXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZnVuYykge1xuICAgICAgICB0aGlzLnVzZXJFdmVudC5yZWdpc3RlcihldmVudE5hbWUsIGZ1bmMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZGltZW5zaW9uIG9mIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHVwZGF0ZWQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2hhcnREaW1lbnNpb246IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xuICAgICAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgY2hhcnRPcHRpb25zID0gdGhpcy5vcHRpb25zLmNoYXJ0O1xuXG4gICAgICAgIGlmIChkaW1lbnNpb24ud2lkdGggJiYgY2hhcnRPcHRpb25zLndpZHRoICE9PSBkaW1lbnNpb24ud2lkdGgpIHtcbiAgICAgICAgICAgIGNoYXJ0T3B0aW9ucy53aWR0aCA9IGRpbWVuc2lvbi53aWR0aDtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpbWVuc2lvbi5oZWlnaHQgJiYgY2hhcnRPcHRpb25zLmhlaWdodCAhPT0gZGltZW5zaW9uLmhlaWdodCkge1xuICAgICAgICAgICAgY2hhcnRPcHRpb25zLmhlaWdodCA9IGRpbWVuc2lvbi5oZWlnaHQ7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJIGZvciByZXNpemFibGUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkaW1lbnNpb24ud2lkdGggd2lkdGhcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkaW1lbnNpb24uaGVpZ2h0IGhlaWdodFxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB1cGRhdGVkO1xuXG4gICAgICAgIGlmICghZGltZW5zaW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVkID0gdGhpcy5fdXBkYXRlQ2hhcnREaW1lbnNpb24oZGltZW5zaW9uKTtcblxuICAgICAgICBpZiAoIXVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIuaW5pdEJvdW5kc0RhdGEodGhpcy5vcHRpb25zLmNoYXJ0KTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24odGhpcy5jaGFydENvbnRhaW5lciwgdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2NoYXJ0JykpO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlcihmdW5jdGlvbihyZW5kZXJpbmdEYXRhKSB7XG4gICAgICAgICAgICBzZWxmLl9yZW5kZXJDb21wb25lbnRzKHJlbmRlcmluZ0RhdGEsICdyZXNpemUnKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0b29sdGlwIGFsaWduIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gYWxpZ24gKGxlZnR8Y2VudGVyfHJpZ2h0LCB0b3B8bWlkZGxlfGJvdHRvbSlcbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgc2V0VG9vbHRpcEFsaWduOiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCd0b29sdGlwJykuc2V0QWxpZ24oYWxpZ24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgcG9zaXRpb24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb3NpdGlvbiBtb3ZpbmcgcG9zaXRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbi5sZWZ0IGxlZnRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbi50b3AgdG9wXG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHNldFRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgndG9vbHRpcCcpLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdG9vbHRpcCBhbGlnbiBvcHRpb24uXG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHJlc2V0VG9vbHRpcEFsaWduOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgndG9vbHRpcCcpLnJlc2V0QWxpZ24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdG9vbHRpcCBwb3NpdGlvbi5cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgcmVzZXRUb29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCd0b29sdGlwJykucmVzZXRQb3NpdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHNlcmllcyBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgc2hvd1Nlcmllc0xhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc2VzID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLndoZXJlKHtjb21wb25lbnRUeXBlOiAnc2VyaWVzJ30pO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICBzZXJpZXMuc2hvd0xhYmVsKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgaGlkZVNlcmllc0xhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc2VzID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLndoZXJlKHtjb21wb25lbnRUeXBlOiAnc2VyaWVzJ30pO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICBzZXJpZXMuaGlkZUxhYmVsKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGREYXRhOiBmdW5jdGlvbigpIHt9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFydEJhc2U7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29sb3JTcGVjdHJ1bSBjcmVhdGUgYSBjb2xvciBzcGVjdHJ1bSBhbmQgcHJvdmlkZSBjb2xvciB2YWx1ZS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29sb3J1dGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb2xvcnV0aWwnKTtcblxudmFyIENvbG9yU3BlY3RydW0gPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIENvbG9yU3BlY3RydW0ucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBDb2xvclNwZWN0cnVtIGNyZWF0ZSBhIGNvbG9yIHNwZWN0cnVtIGFuZCBwcm92aWRlIGNvbG9yIHZhbHVlLlxuICAgICAqIEBjb25zdHJ1Y3RzIENvbG9yU3BlY3RydW1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRDb2xvciBoZXggY29sb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kQ29sb3IgaGV4IGNvbG9yXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oc3RhcnRDb2xvciwgZW5kQ29sb3IpIHtcbiAgICAgICAgdmFyIGVuZFJHQjtcblxuICAgICAgICB0aGlzLnN0YXJ0ID0gY29sb3J1dGlsLmNvbG9yTmFtZVRvSGV4KHN0YXJ0Q29sb3IpO1xuICAgICAgICB0aGlzLnN0YXJ0UkdCID0gY29sb3J1dGlsLmhleFRvUkdCKHRoaXMuc3RhcnQpO1xuICAgICAgICB0aGlzLmVuZCA9IGNvbG9ydXRpbC5jb2xvck5hbWVUb0hleChlbmRDb2xvcik7XG5cbiAgICAgICAgZW5kUkdCID0gY29sb3J1dGlsLmhleFRvUkdCKHRoaXMuZW5kKTtcbiAgICAgICAgdGhpcy5kaXN0YW5jZXMgPSB0aGlzLl9tYWtlRGlzdGFuY2VzKHRoaXMuc3RhcnRSR0IsIGVuZFJHQik7XG4gICAgICAgIHRoaXMuY29sb3JNYXAgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBkaXN0YW5jZXMgc3RhcnQgUkdCIHRvIGVuZCBSR0IuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gc3RhcnRSR0Igc3RhcnQgUkdCXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZW5kUkdCIGVuZCBSR0JcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IGRpc3RhbmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VEaXN0YW5jZXM6IGZ1bmN0aW9uKHN0YXJ0UkdCLCBlbmRSR0IpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChzdGFydFJHQiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kUkdCW2luZGV4XSAtIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGhleCBjb2xvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gcmF0aW9cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBoZXggY29sb3JcbiAgICAgKi9cbiAgICBnZXRDb2xvcjogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgdmFyIGhleENvbG9yID0gdGhpcy5jb2xvck1hcFtyYXRpb107XG4gICAgICAgIHZhciBkaXN0YW5jZXMsIHJnYkNvbG9yO1xuXG4gICAgICAgIGlmICghaGV4Q29sb3IpIHtcbiAgICAgICAgICAgIGRpc3RhbmNlcyA9IHRoaXMuZGlzdGFuY2VzO1xuICAgICAgICAgICAgcmdiQ29sb3IgPSB0dWkudXRpbC5tYXAodGhpcy5zdGFydFJHQiwgZnVuY3Rpb24oc3RhcnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgcGFyc2VJbnQoZGlzdGFuY2VzW2luZGV4XSAqIHJhdGlvLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhleENvbG9yID0gY29sb3J1dGlsLnJnYlRvSEVYLmFwcGx5KG51bGwsIHJnYkNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZXhDb2xvciB8fCBudWxsO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yU3BlY3RydW07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29sdW1uIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpO1xudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIGF4aXNUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2F4aXNUeXBlTWl4ZXInKTtcbnZhciBiYXJUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2JhclR5cGVNaXhlcicpO1xudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG52YXIgU2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL2NvbHVtbkNoYXJ0U2VyaWVzJyk7XG5cbnZhciBDb2x1bW5DaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKENoYXJ0QmFzZSwgLyoqIEBsZW5kcyBDb2x1bW5DaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIENvbHVtbiBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBDb2x1bW5DaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBtaXhlcyBheGlzVHlwZU1peGVyXG4gICAgICogQG1peGVzIHZlcnRpY2FsVHlwZU1peGVyXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbml0ZWREYXRhIGluaXRpYWxpemVkIGRhdGEgZnJvbSBjb21ibyBjaGFydFxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd0RhdGEsIHRoZW1lLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbGFzc05hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jb2x1bW4tY2hhcnQnO1xuXG4gICAgICAgIG9wdGlvbnMuc2VyaWVzID0gb3B0aW9ucy5zZXJpZXMgfHwge307XG4gICAgICAgIG9wdGlvbnMueUF4aXMgPSBvcHRpb25zLnlBeGlzIHx8IHt9O1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNWYWxpZFN0YWNrT3B0aW9uKG9wdGlvbnMuc2VyaWVzLnN0YWNrVHlwZSkpIHtcbiAgICAgICAgICAgIHJhd0RhdGEuc2VyaWVzID0gdGhpcy5fc29ydFJhd1Nlcmllc0RhdGEocmF3RGF0YS5zZXJpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWVzLmRpdmVyZ2luZykge1xuICAgICAgICAgICAgcmF3RGF0YS5zZXJpZXMgPSB0aGlzLl9tYWtlUmF3U2VyaWVzRGF0YUZvckRpdmVyZ2luZyhyYXdEYXRhLnNlcmllcywgb3B0aW9ucy5zZXJpZXMuc3RhY2tUeXBlKTtcbiAgICAgICAgICAgIG9wdGlvbnMuc2VyaWVzLnN0YWNrVHlwZSA9IG9wdGlvbnMuc2VyaWVzLnN0YWNrVHlwZSB8fCBjaGFydENvbnN0Lk5PUk1BTF9TVEFDS19UWVBFO1xuICAgICAgICB9XG5cbiAgICAgICAgQ2hhcnRCYXNlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgcmF3RGF0YTogcmF3RGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBoYXNBeGVzOiB0cnVlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzKG9wdGlvbnMuY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBtYXAgZm9yIEF4aXNTY2FsZU1ha2VyIG9mIGF4ZXMoeEF4aXMsIHlBeGlzKS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsIEF4aXNTY2FsZU1ha2VyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhpc1NjYWxlTWFrZXJNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeUF4aXM6IHRoaXMuX2NyZWF0ZUF4aXNTY2FsZU1ha2VyKHRoaXMub3B0aW9ucy55QXhpcywgJ3lBeGlzJylcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50c0ZvckF4aXNUeXBlKHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgYXhpczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3lBeGlzJyxcbiAgICAgICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneEF4aXMnLFxuICAgICAgICAgICAgICAgICAgICBpc0xhYmVsOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHNlcmllczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvbHVtblNlcmllcycsXG4gICAgICAgICAgICAgICAgICAgIFNlcmllc0NsYXNzOiBTZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93TmVnYXRpdmVUb29sdGlwOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcGxvdDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudHVpLnV0aWwuZXh0ZW5kKENvbHVtbkNoYXJ0LnByb3RvdHlwZSwgYXhpc1R5cGVNaXhlciwgYmFyVHlwZU1peGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5DaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb2x1bW4gYW5kIExpbmUgQ29tYm8gY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyk7XG52YXIgYXhpc1R5cGVNaXhlciA9IHJlcXVpcmUoJy4vYXhpc1R5cGVNaXhlcicpO1xudmFyIGNvbWJvVHlwZU1peGVyID0gcmVxdWlyZSgnLi9jb21ib1R5cGVNaXhlcicpO1xudmFyIHZlcnRpY2FsVHlwZUNvbWJvTWl4ZXIgPSByZXF1aXJlKCcuL3ZlcnRpY2FsVHlwZUNvbWJvTWl4ZXInKTtcblxudmFyIENvbHVtbkxpbmVDb21ib0NoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIENvbHVtbkxpbmVDb21ib0NoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQ29sdW1uIGFuZCBMaW5lIENvbWJvIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIENvbHVtbkxpbmVDb21ib0NoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd0RhdGEsIHRoZW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2luaXRGb3JWZXJ0aWNhbFR5cGVDb21ibyhyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGNoYW5nZSBzZWxlY3RlZCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtBcnJheS48P2Jvb2xlYW4+IHwge2xpbmU6ID9BcnJheS48Ym9vbGVhbj4sIGNvbHVtbjogP0FycmF5Ljxib29sZWFuPn19IGNoZWNrZWRMZWdlbmRzIGNoZWNrZWQgbGVnZW5kc1xuICAgICAqL1xuICAgIG9uQ2hhbmdlQ2hlY2tlZExlZ2VuZHM6IGZ1bmN0aW9uKGNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFJhd0RhdGEgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0T3JpZ2luYWxSYXdEYXRhKCk7XG4gICAgICAgIHZhciByYXdEYXRhID0gdGhpcy5fZmlsdGVyQ2hlY2tlZFJhd0RhdGEob3JpZ2luYWxSYXdEYXRhLCBjaGVja2VkTGVnZW5kcyk7XG4gICAgICAgIHZhciBjaGFydFR5cGVzTWFwID0gdGhpcy5fbWFrZUNoYXJ0VHlwZXNNYXAocmF3RGF0YS5zZXJpZXMsIHRoaXMub3B0aW9ucy55QXhpcyk7XG5cbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKHRoaXMsIGNoYXJ0VHlwZXNNYXApO1xuXG4gICAgICAgIENoYXJ0QmFzZS5wcm90b3R5cGUub25DaGFuZ2VDaGVja2VkTGVnZW5kcy5jYWxsKHRoaXMsIGNoZWNrZWRMZWdlbmRzLCByYXdEYXRhLCBjaGFydFR5cGVzTWFwKTtcbiAgICB9XG59KTtcblxudHVpLnV0aWwuZXh0ZW5kKENvbHVtbkxpbmVDb21ib0NoYXJ0LnByb3RvdHlwZSwgYXhpc1R5cGVNaXhlciwgY29tYm9UeXBlTWl4ZXIsIHZlcnRpY2FsVHlwZUNvbWJvTWl4ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbkxpbmVDb21ib0NoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGNvbWJvVHlwZU1peGVyIGlzIG1peGVyIG9mIGNvbWJvIHR5cGUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRUaGVtZSA9IHJlcXVpcmUoJy4uL3RoZW1lcy9kZWZhdWx0VGhlbWUnKTtcblxuLyoqXG4gKiBjb21ib1R5cGVNaXhlciBpcyBtaXhlciBvZiBjb21ibyB0eXBlIGNoYXJ0LlxuICogQG1peGluXG4gKi9cbnZhciBjb21ib1R5cGVNaXhlciA9IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYmFzZSBzZXJpZXMgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge29iamVjdC48c3RyaW5nLCBvYmplY3Q+fSBzZXJpZXNPcHRpb25zIC0gc2VyaWVzIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIC0gY2hhcnQgdHlwZXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEJhc2VTZXJpZXNPcHRpb25zOiBmdW5jdGlvbihzZXJpZXNPcHRpb25zLCBjaGFydFR5cGVzKSB7XG4gICAgICAgIHZhciBiYXNlU2VyaWVzT3B0aW9ucyA9IHR1aS51dGlsLmV4dGVuZCh7fSwgc2VyaWVzT3B0aW9ucyk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgZGVsZXRlIGJhc2VTZXJpZXNPcHRpb25zW2NoYXJ0VHlwZV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBiYXNlU2VyaWVzT3B0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBvcHRpb25zIG1hcFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNoYXJ0VHlwZXMgLSBjaGFydCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU9wdGlvbnNNYXA6IGZ1bmN0aW9uKGNoYXJ0VHlwZXMpIHtcbiAgICAgICAgdmFyIHNlcmllc09wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2VyaWVzO1xuICAgICAgICB2YXIgYmFzZVNlcmllc09wdGlvbnMgPSB0aGlzLl9nZXRCYXNlU2VyaWVzT3B0aW9ucyhzZXJpZXNPcHRpb25zLCBjaGFydFR5cGVzKTtcbiAgICAgICAgdmFyIG9wdGlvbnNNYXAgPSB7fTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zTWFwW2NoYXJ0VHlwZV0gPSB0dWkudXRpbC5leHRlbmQoe30sIGJhc2VTZXJpZXNPcHRpb25zLCBzZXJpZXNPcHRpb25zW2NoYXJ0VHlwZV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3B0aW9uc01hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aGVtZSBtYXBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzTmFtZXMgLSBzZXJpZXMgbmFtZXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGVtZSBtYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVGhlbWVNYXA6IGZ1bmN0aW9uKHNlcmllc05hbWVzKSB7XG4gICAgICAgIHZhciBkYXRhUHJvY2Vzc29yID0gdGhpcy5kYXRhUHJvY2Vzc29yO1xuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnRoZW1lO1xuICAgICAgICB2YXIgdGhlbWVNYXAgPSB7fTtcbiAgICAgICAgdmFyIGNvbG9yQ291bnQgPSAwO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZXJpZXNOYW1lcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgY2hhcnRUaGVtZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhlbWUpKTtcbiAgICAgICAgICAgIHZhciByZW1vdmVkQ29sb3JzO1xuXG4gICAgICAgICAgICBpZiAoY2hhcnRUaGVtZS5zZXJpZXNbY2hhcnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIHRoZW1lTWFwW2NoYXJ0VHlwZV0gPSBjaGFydFRoZW1lLnNlcmllc1tjaGFydFR5cGVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghY2hhcnRUaGVtZS5zZXJpZXMuY29sb3JzKSB7XG4gICAgICAgICAgICAgICAgdGhlbWVNYXBbY2hhcnRUeXBlXSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGVmYXVsdFRoZW1lLnNlcmllcykpO1xuICAgICAgICAgICAgICAgIHRoZW1lTWFwW2NoYXJ0VHlwZV0ubGFiZWwuZm9udEZhbWlseSA9IGNoYXJ0VGhlbWUuY2hhcnQuZm9udEZhbWlseTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZENvbG9ycyA9IGNoYXJ0VGhlbWUuc2VyaWVzLmNvbG9ycy5zcGxpY2UoMCwgY29sb3JDb3VudCk7XG4gICAgICAgICAgICAgICAgY2hhcnRUaGVtZS5zZXJpZXMuY29sb3JzID0gY2hhcnRUaGVtZS5zZXJpZXMuY29sb3JzLmNvbmNhdChyZW1vdmVkQ29sb3JzKTtcbiAgICAgICAgICAgICAgICB0aGVtZU1hcFtjaGFydFR5cGVdID0gY2hhcnRUaGVtZS5zZXJpZXM7XG4gICAgICAgICAgICAgICAgY29sb3JDb3VudCArPSBkYXRhUHJvY2Vzc29yLmdldExlZ2VuZExhYmVscyhjaGFydFR5cGUpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoZW1lTWFwO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29tYm9UeXBlTWl4ZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29tcG9uZW50TWFuYWdlciBtYW5hZ2VzIGNvbXBvbmVudHMgb2YgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbXBvbmVudE1hbmFnZXIgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIENvbXBvbmVudE1hbmFnZXIucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBDb21wb25lbnRNYW5hZ2VyIG1hbmFnZXMgY29tcG9uZW50cyBvZiBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge0RhdGFQcm9jZXNzb3J9IHBhcmFtcy5kYXRhUHJvY2Vzc29yIGRhdGEgcHJvY2Vzc29yXG4gICAgICogICAgICBAcGFyYW0ge0JvdW5kc01ha2VyfSBwYXJhbXMuYm91bmRzTWFrZXIgYm91bmRzIG1ha2VyXG4gICAgICogQGNvbnN0cnVjdHMgQ29tcG9uZW50TWFuYWdlclxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50c1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50IG1hcC5cbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZW1lXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRoZW1lID0gcGFyYW1zLnRoZW1lIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZGF0YSBwcm9jZXNzb3JcbiAgICAgICAgICogQHR5cGUge0RhdGFQcm9jZXNzb3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IgPSBwYXJhbXMuZGF0YVByb2Nlc3NvcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYm91bmRzIG1ha2VyXG4gICAgICAgICAqIEB0eXBlIHtCb3VuZHNNYWtlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBwYXJhbXMuYm91bmRzTWFrZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgY2hhcnQgaGFzIGF4ZXMgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNBeGVzID0gcGFyYW1zLmhhc0F4ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRUeXBlIGNvbXBvbmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGNvbXBvbmVudCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ29tcG9uZW50T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucywgY29tcG9uZW50VHlwZSwgaW5kZXgpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zW2NvbXBvbmVudFR5cGVdO1xuICAgICAgICBvcHRpb25zID0gdHVpLnV0aWwuaXNBcnJheShvcHRpb25zKSA/IG9wdGlvbnNbaW5kZXhdIDogb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgY29tcG9uZW50LlxuICAgICAqIFRoZSBjb21wb25lbnQgcmVmZXJzIHRvIGEgY29tcG9uZW50IG9mIHRoZSBjaGFydC5cbiAgICAgKiBUaGUgY29tcG9uZW50IHR5cGVzIGFyZSBheGlzLCBsZWdlbmQsIHBsb3QsIHNlcmllcyBhbmQgY3VzdG9tRXZlbnQuXG4gICAgICogQ2hhcnQgQ29tcG9uZW50IERlc2NyaXB0aW9uIDogaHR0cHM6Ly9pLW1zZG4uc2VjLnMtbXNmdC5jb20vZHluaW1nL0lDMjY3OTk3LmdpZlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgY29tcG9uZW50IHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24obmFtZSwgQ29tcG9uZW50LCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIGluZGV4LFxuICAgICAgICAgICAgY29tcG9uZW50LCBjb21wb25lbnRUeXBlO1xuXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyYW1zLmNvbXBvbmVudFR5cGUgfHwgbmFtZTtcbiAgICAgICAgaW5kZXggPSBwYXJhbXMuaW5kZXggfHwgMDtcblxuICAgICAgICBwYXJhbXMudGhlbWUgPSBwYXJhbXMudGhlbWUgfHwgdGhpcy50aGVtZVtjb21wb25lbnRUeXBlXTtcbiAgICAgICAgcGFyYW1zLm9wdGlvbnMgPSB0aGlzLl9tYWtlQ29tcG9uZW50T3B0aW9ucyhwYXJhbXMub3B0aW9ucywgY29tcG9uZW50VHlwZSwgaW5kZXgpO1xuXG4gICAgICAgIHBhcmFtcy5kYXRhUHJvY2Vzc29yID0gdGhpcy5kYXRhUHJvY2Vzc29yO1xuICAgICAgICBwYXJhbXMuYm91bmRzTWFrZXIgPSB0aGlzLmJvdW5kc01ha2VyO1xuICAgICAgICBwYXJhbXMuaGFzQXhlcyA9IHRoaXMuaGFzQXhlcztcblxuICAgICAgICBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KHBhcmFtcyk7XG4gICAgICAgIGNvbXBvbmVudC5jb21wb25lbnROYW1lID0gbmFtZTtcbiAgICAgICAgY29tcG9uZW50LmNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFwW25hbWVdID0gY29tcG9uZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlIGVhY2ggY29tcG9uZW50cy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBpdGVyYXRlZVxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmNvbXBvbmVudHMsIGl0ZXJhdGVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGNvbXBvbmVudHMuXG4gICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIGl0ZXJhdGVlXG4gICAgICogQHJldHVybnMge0FycmF5LjxvYmplY3Q+fSBjb21wb25lbnRzXG4gICAgICovXG4gICAgbWFwOiBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHRoaXMuY29tcG9uZW50cywgaXRlcmF0ZWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGNvbXBvbmVudHMgdG8gY29uZGl0aW9uTWFwLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25kaXRpb25NYXAgY29uZGl0aW9uIG1hcFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gZmlsdGVyZWQgY29tcG9uZW50c1xuICAgICAqL1xuICAgIHdoZXJlOiBmdW5jdGlvbihjb25kaXRpb25NYXApIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmZpbHRlcih0aGlzLmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goY29uZGl0aW9uTWFwLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudFtrZXldICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBjb250YWluZWQ7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHJldHVybnMge29iamVjdH0gY29tcG9uZW50IGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudE1hcFtuYW1lXTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnRNYW5hZ2VyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEhlYXRtYXAgY2hhcnQgaXMgYSBncmFwaGljYWwgcmVwcmVzZW50YXRpb24gb2YgZGF0YSB3aGVyZSB0aGUgaW5kaXZpZHVhbCB2YWx1ZXMgY29udGFpbmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICBpbiBhIG1hdHJpeCBhcmUgcmVwcmVzZW50ZWQgYXMgY29sb3JzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpO1xudmFyIENvbG9yU3BlY3RydW0gPSByZXF1aXJlKCcuL2NvbG9yU3BlY3RydW0nKTtcbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvaGVhdG1hcENoYXJ0U2VyaWVzJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgYXhpc1R5cGVNaXhlciA9IHJlcXVpcmUoJy4vYXhpc1R5cGVNaXhlcicpO1xudmFyIGF4aXNEYXRhTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2F4aXNEYXRhTWFrZXInKTtcbnZhciBMZWdlbmQgPSByZXF1aXJlKCcuLi9sZWdlbmRzL3NwZWN0cnVtTGVnZW5kJyk7XG5cbnZhciBIZWF0bWFwQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDaGFydEJhc2UsIC8qKiBAbGVuZHMgSGVhdG1hcENoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBjbGFzc05hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogJ3R1aS1oZWF0bWFwLWNoYXJ0JyxcbiAgICAvKipcbiAgICAgKiBIZWF0bWFwIGNoYXJ0IGlzIGEgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGRhdGEgd2hlcmUgdGhlIGluZGl2aWR1YWwgdmFsdWVzIGNvbnRhaW5lZFxuICAgICAqICAgICAgaW4gYSBtYXRyaXggYXJlIHJlcHJlc2VudGVkIGFzIGNvbG9ycy5cbiAgICAgKiBAY29uc3RydWN0cyBIZWF0bWFwQ2hhcnRcbiAgICAgKiBAZXh0ZW5kcyBDaGFydEJhc2VcbiAgICAgKiBAbWl4ZXMgYXhpc1R5cGVNaXhlclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLnRvb2x0aXAgPSBvcHRpb25zLnRvb2x0aXAgfHwge307XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnRvb2x0aXAuYWxpZ24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMudG9vbHRpcC5hbGlnbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ERUZBVUxUX0FMSUdOX09QVElPTjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMudG9vbHRpcC5ncm91cGVkID0gZmFsc2U7XG5cbiAgICAgICAgQ2hhcnRCYXNlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgcmF3RGF0YTogcmF3RGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBoYXNBeGVzOiB0cnVlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzKG9wdGlvbnMuY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBtYXAgZm9yIEF4aXNTY2FsZU1ha2VyIG9mIGF4ZXMoeEF4aXMsIHlBeGlzKS5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBeGlzU2NhbGVNYWtlck1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHRoaXMuX2NyZWF0ZUF4aXNTY2FsZU1ha2VyKHt9LCAnbGVnZW5kJywgbnVsbCwgdGhpcy5jaGFydFR5cGUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZUNvdW50OiBjaGFydENvbnN0LlNQRUNUUlVNX0xFR0VORF9USUNLX0NPVU5UXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50c0ZvckF4aXNUeXBlKHtcbiAgICAgICAgICAgIGF4aXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd5QXhpcycsXG4gICAgICAgICAgICAgICAgICAgIGlzTGFiZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hBeGlzJyxcbiAgICAgICAgICAgICAgICAgICAgaXNMYWJlbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICBMZWdlbmRDbGFzczogTGVnZW5kXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaGVhdG1hcFNlcmllcycsXG4gICAgICAgICAgICAgICAgICAgIFNlcmllc0NsYXNzOiBTZXJpZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdG9vbHRpcDogdHJ1ZSxcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5leHRlbmQoSGVhdG1hcENoYXJ0LnByb3RvdHlwZSwgYXhpc1R5cGVNaXhlcik7XG5cbi8qKlxuICogQWRkIGRhdGEgcmF0aW9zIGZvciByZW5kZXJpbmcgZ3JhcGguXG4gKiBAcHJpdmF0ZVxuICogQG92ZXJyaWRlXG4gKi9cbkhlYXRtYXBDaGFydC5wcm90b3R5cGUuX2FkZERhdGFSYXRpb3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGltaXQgPSB0aGlzLl9nZXRBeGlzU2NhbGVNYWtlck1hcCgpLmxlZ2VuZC5nZXRMaW1pdCgpO1xuXG4gICAgdGhpcy5kYXRhUHJvY2Vzc29yLmFkZERhdGFSYXRpb3MobGltaXQsIG51bGwsIHRoaXMuY2hhcnRUeXBlKTtcbn07XG5cbi8qKlxuICogTWFrZSByZW5kZXJpbmcgZGF0YSBmb3IgZGVsaXZlcnkgdG8gZWFjaCBjb21wb25lbnQuXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICogQHByaXZhdGVcbiAqIEBvdmVycmlkZVxuICovXG5IZWF0bWFwQ2hhcnQucHJvdG90eXBlLl9tYWtlUmVuZGVyaW5nRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gYXhpc1R5cGVNaXhlci5fbWFrZVJlbmRlcmluZ0RhdGEuY2FsbCh0aGlzKTtcbiAgICB2YXIgc2VyaWVzVGhlbWUgPSB0aGlzLnRoZW1lLnNlcmllcztcbiAgICB2YXIgY29sb3JTcGVjdHJ1bSA9IG5ldyBDb2xvclNwZWN0cnVtKHNlcmllc1RoZW1lLnN0YXJ0Q29sb3IsIHNlcmllc1RoZW1lLmVuZENvbG9yKTtcblxuICAgIGRhdGEubGVnZW5kID0ge1xuICAgICAgICBjb2xvclNwZWN0cnVtOiBjb2xvclNwZWN0cnVtLFxuICAgICAgICBheGVzRGF0YTogYXhpc0RhdGFNYWtlci5tYWtlVmFsdWVBeGlzRGF0YSh7XG4gICAgICAgICAgICBheGlzU2NhbGVNYWtlcjogdGhpcy5fZ2V0QXhpc1NjYWxlTWFrZXJNYXAoKS5sZWdlbmQsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXG4gICAgICAgIH0pXG4gICAgfTtcbiAgICBkYXRhLmhlYXRtYXBTZXJpZXMuY29sb3JTcGVjdHJ1bSA9IGNvbG9yU3BlY3RydW07XG5cbiAgICByZXR1cm4gZGF0YTtcbn07XG5cbi8qKlxuICogQXR0YWNoIGN1c3RvbSBldmVudCBiZXR3ZWVuIGNvbXBvbmVudHMuXG4gKiBAcHJpdmF0ZVxuICogQG92ZXJyaWRlXG4gKi9cbkhlYXRtYXBDaGFydC5wcm90b3R5cGUuX2F0dGFjaEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1c3RvbUV2ZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnY3VzdG9tRXZlbnQnKTtcbiAgICB2YXIgaGVhdG1hcFNlcmllcyA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ2hlYXRtYXBTZXJpZXMnKTtcbiAgICB2YXIgbGVnZW5kID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnbGVnZW5kJyk7XG5cbiAgICBheGlzVHlwZU1peGVyLl9hdHRhY2hDdXN0b21FdmVudC5jYWxsKHRoaXMpO1xuXG4gICAgY3VzdG9tRXZlbnQub24oJ3Nob3dUb29sdGlwJywgaGVhdG1hcFNlcmllcy5vblNob3dUb29sdGlwLCBoZWF0bWFwU2VyaWVzKTtcbiAgICBjdXN0b21FdmVudC5vbignaGlkZVRvb2x0aXAnLCBsZWdlbmQub25IaWRlV2VkZ2UsIGxlZ2VuZCk7XG5cbiAgICBoZWF0bWFwU2VyaWVzLm9uKCdzaG93V2VkZ2UnLCBsZWdlbmQub25TaG93V2VkZ2UsIGxlZ2VuZCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYXRtYXBDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBMaW5lIGFuZCBBcmVhIENvbWJvIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpO1xudmFyIGF4aXNUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2F4aXNUeXBlTWl4ZXInKTtcbnZhciBhdXRvVGlja01peGVyID0gcmVxdWlyZSgnLi9hdXRvVGlja01peGVyJyk7XG52YXIgem9vbU1peGVyID0gcmVxdWlyZSgnLi96b29tTWl4ZXInKTtcbnZhciBhZGRpbmdEeW5hbWljRGF0YU1peGVyID0gcmVxdWlyZSgnLi9hZGRpbmdEeW5hbWljRGF0YU1peGVyJyk7XG52YXIgY29tYm9UeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2NvbWJvVHlwZU1peGVyJyk7XG52YXIgdmVydGljYWxUeXBlQ29tYm9NaXhlciA9IHJlcXVpcmUoJy4vdmVydGljYWxUeXBlQ29tYm9NaXhlcicpO1xuXG52YXIgTGluZUFyZWFDb21ib0NoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIExpbmVBcmVhQ29tYm9DaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIGNsYXNzTmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgY2xhc3NOYW1lOiAndHVpLWNvbWJvLWNoYXJ0JyxcbiAgICAvKipcbiAgICAgKiBMaW5lIGFuZCBBcmVhIENvbWJvIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIExpbmVBcmVhQ29tYm9DaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YSAtIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIC0gY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGNoYXJ0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9pbml0Rm9yVmVydGljYWxUeXBlQ29tYm8ocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbml0Rm9yQXV0b1RpY2tJbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLl9pbml0Rm9yQWRkaW5nRGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjaGFuZ2Ugc2VsZWN0ZWQgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fSBjaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKi9cbiAgICBvbkNoYW5nZUNoZWNrZWRMZWdlbmRzOiBmdW5jdGlvbihjaGVja2VkTGVnZW5kcykge1xuICAgICAgICB2YXIgem9vbWVkUmF3RGF0YSA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRab29tZWRSYXdEYXRhKCk7XG4gICAgICAgIHZhciByYXdEYXRhID0gdGhpcy5fZmlsdGVyQ2hlY2tlZFJhd0RhdGEoem9vbWVkUmF3RGF0YSwgY2hlY2tlZExlZ2VuZHMpO1xuICAgICAgICB2YXIgY2hhcnRUeXBlc01hcCA9IHRoaXMuX21ha2VDaGFydFR5cGVzTWFwKHJhd0RhdGEuc2VyaWVzLCB0aGlzLm9wdGlvbnMueUF4aXMpO1xuXG4gICAgICAgIHR1aS51dGlsLmV4dGVuZCh0aGlzLCBjaGFydFR5cGVzTWFwKTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VDaGVja2VkTGVnZW5kcyhjaGVja2VkTGVnZW5kcywgcmF3RGF0YSwgY2hhcnRUeXBlc01hcCk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLmV4dGVuZChMaW5lQXJlYUNvbWJvQ2hhcnQucHJvdG90eXBlLFxuICAgIGF4aXNUeXBlTWl4ZXIsIGF1dG9UaWNrTWl4ZXIsIHpvb21NaXhlciwgYWRkaW5nRHluYW1pY0RhdGFNaXhlciwgY29tYm9UeXBlTWl4ZXIsIHZlcnRpY2FsVHlwZUNvbWJvTWl4ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVBcmVhQ29tYm9DaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBMaW5lIGNoYXJ0XG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyk7XG52YXIgbGluZVR5cGVNaXhlciA9IHJlcXVpcmUoJy4vbGluZVR5cGVNaXhlcicpO1xudmFyIGF1dG9UaWNrTWl4ZXIgPSByZXF1aXJlKCcuL2F1dG9UaWNrTWl4ZXInKTtcbnZhciB6b29tTWl4ZXIgPSByZXF1aXJlKCcuL3pvb21NaXhlcicpO1xudmFyIGF4aXNUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2F4aXNUeXBlTWl4ZXInKTtcbnZhciBhZGRpbmdEeW5hbWljRGF0YU1peGVyID0gcmVxdWlyZSgnLi9hZGRpbmdEeW5hbWljRGF0YU1peGVyJyk7XG52YXIgU2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL2xpbmVDaGFydFNlcmllcycpO1xuXG52YXIgTGluZUNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIExpbmVDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIGNsYXNzTmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgY2xhc3NOYW1lOiAndHVpLWxpbmUtY2hhcnQnLFxuXG4gICAgLyoqXG4gICAgICogU2VyaWVzIGNsYXNzXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIFNlcmllczogU2VyaWVzLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBMaW5lQ2hhcnRcbiAgICAgKiBAZXh0ZW5kcyBDaGFydEJhc2VcbiAgICAgKiBAbWl4ZXMgYXhpc1R5cGVNaXhlclxuICAgICAqIEBtaXhlcyBsaW5lVHlwZU1peGVyXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xpbmVUeXBlSW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9pbml0Rm9yQXV0b1RpY2tJbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLl9pbml0Rm9yQWRkaW5nRGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjaGFuZ2UgY2hlY2tlZCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtBcnJheS48P2Jvb2xlYW4+IHwge2xpbmU6ID9BcnJheS48Ym9vbGVhbj4sIGNvbHVtbjogP0FycmF5Ljxib29sZWFuPn19IGNoZWNrZWRMZWdlbmRzIGNoZWNrZWQgbGVnZW5kc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gcmF3RGF0YSByYXdEYXRhXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBib3VuZHNQYXJhbXMgYWRkaXRpb24gcGFyYW1zIGZvciBjYWxjdWxhdGluZyBib3VuZHNcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBvbkNoYW5nZUNoZWNrZWRMZWdlbmRzOiBmdW5jdGlvbihjaGVja2VkTGVnZW5kcywgcmF3RGF0YSwgYm91bmRzUGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZUNoZWNrZWRMZWdlbmRzKGNoZWNrZWRMZWdlbmRzLCByYXdEYXRhLCBib3VuZHNQYXJhbXMpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5leHRlbmQoTGluZUNoYXJ0LnByb3RvdHlwZSxcbiAgICBheGlzVHlwZU1peGVyLCBsaW5lVHlwZU1peGVyLCBhdXRvVGlja01peGVyLCB6b29tTWl4ZXIsIGFkZGluZ0R5bmFtaWNEYXRhTWl4ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBsaW5lVHlwZU1peGVyIGlzIG1peGVyIG9mIGxpbmUgdHlwZSBjaGFydChsaW5lLCBhcmVhKS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2hhcnRCYXNlID0gcmVxdWlyZSgnLi9jaGFydEJhc2UnKTtcbnZhciBBcmVhVHlwZUN1c3RvbUV2ZW50ID0gcmVxdWlyZSgnLi4vY3VzdG9tRXZlbnRzL2FyZWFUeXBlQ3VzdG9tRXZlbnQnKTtcblxuLyoqXG4gKiBsaW5lVHlwZU1peGVyIGlzIG1peGVyIG9mIGxpbmUgdHlwZSBjaGFydChsaW5lLCBhcmVhKS5cbiAqIEBtaXhpblxuICovXG52YXIgbGluZVR5cGVNaXhlciA9IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGxpbmUgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbGluZVR5cGVJbml0OiBmdW5jdGlvbihyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICBDaGFydEJhc2UuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICByYXdEYXRhOiByYXdEYXRhLFxuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGhhc0F4ZXM6IHRydWUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHMob3B0aW9ucy5jaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG1hcCBmb3IgQXhpc1NjYWxlTWFrZXIgb2YgYXhlcyh4QXhpcywgeUF4aXMpLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgQXhpc1NjYWxlTWFrZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBeGlzU2NhbGVNYWtlck1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5QXhpczogdGhpcy5fY3JlYXRlQXhpc1NjYWxlTWFrZXIodGhpcy5vcHRpb25zLnlBeGlzLCAneUF4aXMnKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudCBmb3Igbm9ybWFsIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ3VzdG9tRXZlbnRDb21wb25lbnRGb3JOb3JtYWxUb29sdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCdjdXN0b21FdmVudCcsIEFyZWFUeXBlQ3VzdG9tRXZlbnQsIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0aGlzLmlzVmVydGljYWwsXG4gICAgICAgICAgICB6b29tYWJsZTogdHVpLnV0aWwucGljayh0aGlzLm9wdGlvbnMuc2VyaWVzLCAnem9vbWFibGUnKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50c0ZvckF4aXNUeXBlKHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgYXhpczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3lBeGlzJyxcbiAgICAgICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneEF4aXMnLFxuICAgICAgICAgICAgICAgICAgICBpc0xhYmVsOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHNlcmllczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5vcHRpb25zLmNoYXJ0VHlwZSArICdTZXJpZXMnLFxuICAgICAgICAgICAgICAgICAgICBTZXJpZXNDbGFzczogdGhpcy5TZXJpZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcGxvdDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVUeXBlTWl4ZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFwIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpO1xudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIE1hcENoYXJ0TWFwTW9kZWwgPSByZXF1aXJlKCcuL21hcENoYXJ0TWFwTW9kZWwnKTtcbnZhciBDb2xvclNwZWN0cnVtID0gcmVxdWlyZSgnLi9jb2xvclNwZWN0cnVtJyk7XG52YXIgTWFwQ2hhcnREYXRhUHJvY2Vzc29yID0gcmVxdWlyZSgnLi4vZGF0YU1vZGVscy9tYXBDaGFydERhdGFQcm9jZXNzb3InKTtcbnZhciBheGlzRGF0YU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9heGlzRGF0YU1ha2VyJyk7XG52YXIgU2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL21hcENoYXJ0U2VyaWVzJyk7XG52YXIgWm9vbSA9IHJlcXVpcmUoJy4uL3Nlcmllcy96b29tJyk7XG52YXIgTGVnZW5kID0gcmVxdWlyZSgnLi4vbGVnZW5kcy9zcGVjdHJ1bUxlZ2VuZCcpO1xudmFyIE1hcENoYXJ0VG9vbHRpcCA9IHJlcXVpcmUoJy4uL3Rvb2x0aXBzL21hcENoYXJ0VG9vbHRpcCcpO1xudmFyIG1hcENoYXJ0Q3VzdG9tRXZlbnQgPSByZXF1aXJlKCcuLi9jdXN0b21FdmVudHMvbWFwQ2hhcnRDdXN0b21FdmVudCcpO1xuXG52YXIgTWFwQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDaGFydEJhc2UsIC8qKiBAbGVuZHMgTWFwQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBNYXAgY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgTWFwQ2hhcnRcbiAgICAgKiBAZXh0ZW5kcyBDaGFydEJhc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsYXNzIG5hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1tYXAtY2hhcnQnO1xuXG4gICAgICAgIG9wdGlvbnMudG9vbHRpcCA9IG9wdGlvbnMudG9vbHRpcCB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5sZWdlbmQgPSBvcHRpb25zLmxlZ2VuZCB8fCB7fTtcblxuICAgICAgICBDaGFydEJhc2UuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICByYXdEYXRhOiByYXdEYXRhLFxuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIERhdGFQcm9jZXNzb3I6IE1hcENoYXJ0RGF0YVByb2Nlc3NvclxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMubGVnZW5kID0gb3B0aW9ucy5sZWdlbmQgfHwge307XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCdsZWdlbmQnLCBMZWdlbmQpO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcigndG9vbHRpcCcsIE1hcENoYXJ0VG9vbHRpcCwgdGhpcy5fbWFrZVRvb2x0aXBEYXRhKCkpO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcignbWFwU2VyaWVzJywgU2VyaWVzLCB7XG4gICAgICAgICAgICBsaWJUeXBlOiBvcHRpb25zLmxpYlR5cGUsXG4gICAgICAgICAgICBjaGFydFR5cGU6IG9wdGlvbnMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50VHlwZTogJ3NlcmllcycsXG4gICAgICAgICAgICB1c2VyRXZlbnQ6IHRoaXMudXNlckV2ZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3Rlcignem9vbScsIFpvb20pO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcignY3VzdG9tRXZlbnQnLCBtYXBDaGFydEN1c3RvbUV2ZW50LCB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGF4ZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGF4ZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBeGVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBheGlzU2NhbGVNYWtlciA9IHRoaXMuX2NyZWF0ZUF4aXNTY2FsZU1ha2VyKHt9LCAnbGVnZW5kJywgbnVsbCwgdGhpcy5jaGFydFR5cGUsIHtcbiAgICAgICAgICAgIHZhbHVlQ291bnQ6IGNoYXJ0Q29uc3QuU1BFQ1RSVU1fTEVHRU5EX1RJQ0tfQ09VTlRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGF4aXNEYXRhTWFrZXIubWFrZVZhbHVlQXhpc0RhdGEoe1xuICAgICAgICAgICAgYXhpc1NjYWxlTWFrZXI6IGF4aXNTY2FsZU1ha2VyLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2FkZERhdGFSYXRpb3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXhlc0RhdGEgPSB0aGlzLmJvdW5kc01ha2VyLmdldEF4ZXNEYXRhKCk7XG5cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLmFkZERhdGFSYXRpb3MoYXhlc0RhdGEubGltaXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJlbmRlcmluZyBkYXRhIGZvciBtYXAgY2hhcnQuXG4gICAgICogQHJldHVybnMge29iamVjdH0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZVJlbmRlcmluZ0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXhlc0RhdGEgPSB0aGlzLmJvdW5kc01ha2VyLmdldEF4ZXNEYXRhKCk7XG4gICAgICAgIHZhciBzZXJpZXNUaGVtZSA9IHRoaXMudGhlbWUuc2VyaWVzO1xuICAgICAgICB2YXIgY29sb3JTcGVjdHJ1bSA9IG5ldyBDb2xvclNwZWN0cnVtKHNlcmllc1RoZW1lLnN0YXJ0Q29sb3IsIHNlcmllc1RoZW1lLmVuZENvbG9yKTtcbiAgICAgICAgdmFyIG1hcE1vZGVsID0gbmV3IE1hcENoYXJ0TWFwTW9kZWwodGhpcy5kYXRhUHJvY2Vzc29yLCB0aGlzLm9wdGlvbnMubWFwKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgICAgY29sb3JTcGVjdHJ1bTogY29sb3JTcGVjdHJ1bSxcbiAgICAgICAgICAgICAgICBheGVzRGF0YTogYXhlc0RhdGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXBTZXJpZXM6IHtcbiAgICAgICAgICAgICAgICBtYXBNb2RlbDogbWFwTW9kZWwsXG4gICAgICAgICAgICAgICAgY29sb3JTcGVjdHJ1bTogY29sb3JTcGVjdHJ1bVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgICAgICBtYXBNb2RlbDogbWFwTW9kZWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGN1c3RvbSBldm5ldC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9hdHRhY2hDdXN0b21FdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXN0b21FdmVudCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ2N1c3RvbUV2ZW50JyksXG4gICAgICAgICAgICBtYXBTZXJpZXMgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCdtYXBTZXJpZXMnKSxcbiAgICAgICAgICAgIGxlZ2VuZCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ2xlZ2VuZCcpLFxuICAgICAgICAgICAgdG9vbHRpcCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ3Rvb2x0aXAnKSxcbiAgICAgICAgICAgIHpvb20gPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCd6b29tJyk7XG5cbiAgICAgICAgY3VzdG9tRXZlbnQub24oe1xuICAgICAgICAgICAgY2xpY2tNYXBTZXJpZXM6IG1hcFNlcmllcy5vbkNsaWNrU2VyaWVzLFxuICAgICAgICAgICAgbW92ZU1hcFNlcmllczogbWFwU2VyaWVzLm9uTW92ZVNlcmllcyxcbiAgICAgICAgICAgIGRyYWdTdGFydE1hcFNlcmllczogbWFwU2VyaWVzLm9uRHJhZ1N0YXJ0U2VyaWVzLFxuICAgICAgICAgICAgZHJhZ01hcFNlcmllczogbWFwU2VyaWVzLm9uRHJhZ1NlcmllcyxcbiAgICAgICAgICAgIGRyYWdFbmRNYXBTZXJpZXM6IG1hcFNlcmllcy5vbkRyYWdFbmRTZXJpZXMsXG4gICAgICAgICAgICB3aGVlbDogdHVpLnV0aWwuYmluZCh6b29tLm9uV2hlZWwsIHpvb20pXG4gICAgICAgIH0sIG1hcFNlcmllcyk7XG5cbiAgICAgICAgbWFwU2VyaWVzLm9uKHtcbiAgICAgICAgICAgIHNob3dXZWRnZTogbGVnZW5kLm9uU2hvd1dlZGdlLFxuICAgICAgICAgICAgaGlkZVdlZGdlOiBsZWdlbmQub25IaWRlV2VkZ2VcbiAgICAgICAgfSwgbGVnZW5kKTtcblxuICAgICAgICBtYXBTZXJpZXMub24oe1xuICAgICAgICAgICAgc2hvd1Rvb2x0aXA6IHRvb2x0aXAub25TaG93LFxuICAgICAgICAgICAgaGlkZVRvb2x0aXA6IHRvb2x0aXAub25IaWRlLFxuICAgICAgICAgICAgc2hvd1Rvb2x0aXBDb250YWluZXI6IHRvb2x0aXAub25TaG93VG9vbHRpcENvbnRhaW5lcixcbiAgICAgICAgICAgIGhpZGVUb29sdGlwQ29udGFpbmVyOiB0b29sdGlwLm9uSGlkZVRvb2x0aXBDb250YWluZXJcbiAgICAgICAgfSwgdG9vbHRpcCk7XG5cbiAgICAgICAgem9vbS5vbignem9vbScsIG1hcFNlcmllcy5vblpvb20sIG1hcFNlcmllcywgbWFwU2VyaWVzKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNYXBDaGFydE1hcE1vZGVsIGlzIG1hcCBtb2RlbCBvZiBtYXAgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgTWFwQ2hhcnRNYXBNb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgTWFwQ2hhcnRNYXBNb2RlbC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIE1hcENoYXJ0TWFwTW9kZWwgaXMgbWFwIG1vZGVsIG9mIG1hcCBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBNYXBDaGFydE1hcE1vZGVsXG4gICAgICogQHBhcmFtIHtNYXBDaGFydERhdGFQcm9jZXNzb3J9IGRhdGFQcm9jZXNzb3IgTWFwIGNoYXJ0IGRhdGEgcHJvY2Vzc29yXG4gICAgICogQHBhcmFtIHtBcnJheS48e25hbWU6IHN0cmluZywgcGF0aDogc3RyaW5nLCBsYWJlbENvb3JkaW5hdGU6ID97eDogbnVtYmVyLCB5Om51bWJlcn19Pn0gcmF3TWFwRGF0YSByYXcgbWFwIGRhdGFcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihkYXRhUHJvY2Vzc29yLCByYXdNYXBEYXRhKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21tYW5kIGZ1bmN0aW9uIG1hcC5cbiAgICAgICAgICogQHR5cGUge3tcbiAgICAgICAgICogICAgICBNOiBNYXBDaGFydE1hcE1vZGVsLl9tYWtlQ29vcmRpbmF0ZSwgbTogTWFwQ2hhcnRNYXBNb2RlbC5fbWFrZUNvb3JkaW5hdGVGcm9tUmVsYXRpdmVDb29yZGluYXRlLFxuICAgICAgICAgKiAgICAgIEw6IE1hcENoYXJ0TWFwTW9kZWwuX21ha2VDb29yZGluYXRlLCBsOiBNYXBDaGFydE1hcE1vZGVsLl9tYWtlQ29vcmRpbmF0ZUZyb21SZWxhdGl2ZUNvb3JkaW5hdGUsXG4gICAgICAgICAqICAgICAgSDogTWFwQ2hhcnRNYXBNb2RlbC5fbWFrZVhDb29yZGluYXRlLCBoOiBNYXBDaGFydE1hcE1vZGVsLl9tYWtlWENvb3JkaW5hdGVGcm9SZWxhdGl2ZUNvb3JkaW5hdGUsXG4gICAgICAgICAqICAgICAgVjogTWFwQ2hhcnRNYXBNb2RlbC5fbWFrZVlDb29yZGluYXRlLCB2OiBNYXBDaGFydE1hcE1vZGVsLl9tYWtlWUNvb3JkaW5hdGVGcm9tUmVsYXRpdmVDb29yZGluYXRlXG4gICAgICAgICAqIH19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbW1hbmRGdW5jTWFwID0ge1xuICAgICAgICAgICAgTTogdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlQ29vcmRpbmF0ZSwgdGhpcyksXG4gICAgICAgICAgICBtOiB0dWkudXRpbC5iaW5kKHRoaXMuX21ha2VDb29yZGluYXRlRnJvbVJlbGF0aXZlQ29vcmRpbmF0ZSwgdGhpcyksXG4gICAgICAgICAgICBMOiB0dWkudXRpbC5iaW5kKHRoaXMuX21ha2VDb29yZGluYXRlLCB0aGlzKSxcbiAgICAgICAgICAgIGw6IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZUNvb3JkaW5hdGVGcm9tUmVsYXRpdmVDb29yZGluYXRlLCB0aGlzKSxcbiAgICAgICAgICAgIEg6IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZVhDb29yZGluYXRlLCB0aGlzKSxcbiAgICAgICAgICAgIGg6IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZVhDb29yZGluYXRlRnJvUmVsYXRpdmVDb29yZGluYXRlLCB0aGlzKSxcbiAgICAgICAgICAgIFY6IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZVlDb29yZGluYXRlLCB0aGlzKSxcbiAgICAgICAgICAgIHY6IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZVlDb29yZGluYXRlRnJvbVJlbGF0aXZlQ29vcmRpbmF0ZSwgdGhpcylcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWdub3JlIGNvbW1hbmQgbWFwLlxuICAgICAgICAgKiBAdHlwZSB7e1o6IGJvb2xlYW4sIHo6IGJvb2xlYW59fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZ25vcmVDb21tYW5kTWFwID0ge1xuICAgICAgICAgICAgWjogdHJ1ZSxcbiAgICAgICAgICAgIHo6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIGRhdGEuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFwRGF0YSA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgZGltZW5zaW9uXG4gICAgICAgICAqIEB0eXBlIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBEaW1lbnNpb24gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgY2hhcnQgZGF0YSBwcm9jZXNzb3IuXG4gICAgICAgICAqIEB0eXBlIHtNYXBDaGFydERhdGFQcm9jZXNzb3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IgPSBkYXRhUHJvY2Vzc29yO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZU1hcERhdGEocmF3TWFwRGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNwbGl0IGNvb3JkaW5hdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZGluYXRlU3RyIGNvb3JkaW5hdGUgc3RyaW5nXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IGNvb3JkaW5hdGUgbWFwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc3BsaXRDb29yZGluYXRlOiBmdW5jdGlvbihjb29yZGluYXRlU3RyKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IGNvb3JkaW5hdGVTdHIuc3BsaXQoJywnKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBwYXJzZUZsb2F0KGNvb3JkaW5hdGVzWzBdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29vcmRpbmF0ZXNbMV0pIHtcbiAgICAgICAgICAgIHJlc3VsdC55ID0gcGFyc2VGbG9hdChjb29yZGluYXRlc1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29vcmRpbmF0ZVN0ciBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ29vcmRpbmF0ZTogZnVuY3Rpb24oY29vcmRpbmF0ZVN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3BsaXRDb29yZGluYXRlKGNvb3JkaW5hdGVTdHIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNvb3JkaW5hdGUgZnJvbSByZWxhdGl2ZSBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZGluYXRlU3RyIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHByZXZDb29yZGluYXRlIHByZXZpb3VzIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDb29yZGluYXRlRnJvbVJlbGF0aXZlQ29vcmRpbmF0ZTogZnVuY3Rpb24oY29vcmRpbmF0ZVN0ciwgcHJldkNvb3JkaW5hdGUpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSB0aGlzLl9zcGxpdENvb3JkaW5hdGUoY29vcmRpbmF0ZVN0cik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNvb3JkaW5hdGUueCArIHByZXZDb29yZGluYXRlLngsXG4gICAgICAgICAgICB5OiBjb29yZGluYXRlLnkgKyBwcmV2Q29vcmRpbmF0ZS55XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgeCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZGluYXRlU3RyIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlcn19IHggY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VYQ29vcmRpbmF0ZTogZnVuY3Rpb24oY29vcmRpbmF0ZVN0cikge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IHRoaXMuX3NwbGl0Q29vcmRpbmF0ZShjb29yZGluYXRlU3RyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY29vcmRpbmF0ZS54XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgeCBjb29yZGluYXRlIGZyb20gcmVsYXRpdmUgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29vcmRpbmF0ZVN0ciBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwcmV2Q29vcmRpbmF0ZSBwcmV2aW91cyBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXJ9fSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlWENvb3JkaW5hdGVGcm9SZWxhdGl2ZUNvb3JkaW5hdGU6IGZ1bmN0aW9uKGNvb3JkaW5hdGVTdHIsIHByZXZDb29yZGluYXRlKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlID0gdGhpcy5fc3BsaXRDb29yZGluYXRlKGNvb3JkaW5hdGVTdHIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjb29yZGluYXRlLnggKyBwcmV2Q29vcmRpbmF0ZS54XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgeSBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZGluYXRlU3RyIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7e3k6IG51bWJlcn19IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VZQ29vcmRpbmF0ZTogZnVuY3Rpb24oY29vcmRpbmF0ZVN0cikge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IHRoaXMuX3NwbGl0Q29vcmRpbmF0ZShjb29yZGluYXRlU3RyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeTogY29vcmRpbmF0ZS54XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgeSBjb29yZGluYXRlIGZyb20gcmVsYXRpdmUgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29vcmRpbmF0ZVN0ciBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwcmV2Q29vcmRpbmF0ZSBwcmV2aW91cyBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge3t5OiBudW1iZXJ9fSB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlWUNvb3JkaW5hdGVGcm9tUmVsYXRpdmVDb29yZGluYXRlOiBmdW5jdGlvbihjb29yZGluYXRlU3RyLCBwcmV2Q29vcmRpbmF0ZSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IHRoaXMuX3NwbGl0Q29vcmRpbmF0ZShjb29yZGluYXRlU3RyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeTogY29vcmRpbmF0ZS54ICsgcHJldkNvb3JkaW5hdGUueVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTcGxpdCBwYXRoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHt0eXBlOiBzdHJpbmcsIGNvb3JkaW5hdGU6IHN0cmluZ30+fSBzcGxpdHRlZCBwYXRoIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zcGxpdFBhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBwYXRoRGF0YSA9IFtdLFxuICAgICAgICAgICAgY29vcmRpbmF0ZSA9ICcnLFxuICAgICAgICAgICAgY2hyLCBjb21tYW5kVHlwZTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjaHIgPSBwYXRoLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbW1hbmRGdW5jTWFwW2Nocl0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZFR5cGUgJiYgY29vcmRpbmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbW1hbmRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZTogY29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tbWFuZFR5cGUgPSBjaHI7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZSA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pZ25vcmVDb21tYW5kTWFwW2Nocl0pIHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlICs9IGNocjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tYW5kVHlwZSAmJiBjb29yZGluYXRlKSB7XG4gICAgICAgICAgICBwYXRoRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBjb21tYW5kVHlwZSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlOiBjb29yZGluYXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjb29yZGluYXRlcyBmcm9tIHBhdGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e3g6IG51bWJlciwgeTogbnVtYmVyfT59IGNvb3JkaW5hdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNvb3JkaW5hdGVzRnJvbVBhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgcGF0aERhdGEgPSB0aGlzLl9zcGxpdFBhdGgocGF0aCksXG4gICAgICAgICAgICBwcmV2Q29vcmRpbmF0ZSA9IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwYXRoRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgIHZhciBjb21tYW5kRnVuYyA9IHNlbGYuY29tbWFuZEZ1bmNNYXBbZGF0dW0udHlwZV0sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZSA9IGNvbW1hbmRGdW5jKGRhdHVtLmNvb3JkaW5hdGUsIHByZXZDb29yZGluYXRlKTtcblxuICAgICAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKHByZXZDb29yZGluYXRlLCBjb29yZGluYXRlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGJvdW5kIGZyb20gY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9Pn0gY29vcmRpbmF0ZXMgY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHt0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX19IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZEJvdW5kRnJvbUNvb3JkaW5hdGVzOiBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgICAgICB2YXIgeHMgPSB0dWkudXRpbC5maWx0ZXIodHVpLnV0aWwucGx1Y2soY29vcmRpbmF0ZXMsICd4JyksIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXR1aS51dGlsLmlzVW5kZWZpbmVkKHgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB5cyA9IHR1aS51dGlsLmZpbHRlcih0dWkudXRpbC5wbHVjayhjb29yZGluYXRlcywgJ3knKSwgZnVuY3Rpb24oeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdHVpLnV0aWwuaXNVbmRlZmluZWQoeSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1heExlZnQgPSB0dWkudXRpbC5tYXgoeHMpLFxuICAgICAgICAgICAgbWluTGVmdCA9IHR1aS51dGlsLm1pbih4cyksXG4gICAgICAgICAgICBtYXhUb3AgPSB0dWkudXRpbC5tYXgoeXMpLFxuICAgICAgICAgICAgbWluVG9wID0gdHVpLnV0aWwubWluKHlzKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGltZW5zaW9uOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IG1heExlZnQgLSBtaW5MZWZ0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogbWF4VG9wIC0gbWluVG9wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBtaW5MZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogbWluVG9wXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGFiZWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fX0gYm91bmQgYm91bmRcbiAgICAgKiBAcGFyYW0gez97bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uUmF0aW8gcG9zaXRpb24gcmF0aW9cbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBsYWJlbCBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMYWJlbFBvc2l0aW9uOiBmdW5jdGlvbihib3VuZCwgcG9zaXRpb25SYXRpbykge1xuICAgICAgICBwb3NpdGlvblJhdGlvID0gcG9zaXRpb25SYXRpbyB8fCBjaGFydENvbnN0Lk1BUF9DSEFSVF9MQUJFTF9ERUZBVUxUX1BPU0lUSU9OX1JBVElPO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBib3VuZC5wb3NpdGlvbi5sZWZ0ICsgKGJvdW5kLmRpbWVuc2lvbi53aWR0aCAqIHBvc2l0aW9uUmF0aW8ueCksXG4gICAgICAgICAgICB0b3A6IGJvdW5kLnBvc2l0aW9uLnRvcCArIChib3VuZC5kaW1lbnNpb24uaGVpZ2h0ICogcG9zaXRpb25SYXRpby55KVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbWFwIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheS48e25hbWU6IHN0cmluZywgcGF0aDogc3RyaW5nLCBsYWJlbENvb3JkaW5hdGU6ID97eDogbnVtYmVyLCB5Om51bWJlcn19Pn0gcmF3TWFwRGF0YSByYXcgbWFwIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVNYXBEYXRhOiBmdW5jdGlvbihyYXdNYXBEYXRhKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLm1hcERhdGEgPSB0dWkudXRpbC5tYXAocmF3TWFwRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlID0gc2VsZi5fbWFrZUNvb3JkaW5hdGVzRnJvbVBhdGgoZGF0dW0ucGF0aCksXG4gICAgICAgICAgICAgICAgYm91bmQgPSBzZWxmLl9maW5kQm91bmRGcm9tQ29vcmRpbmF0ZXMoY29vcmRpbmF0ZSksXG4gICAgICAgICAgICAgICAgdXNlckRhdGEgPSBzZWxmLmRhdGFQcm9jZXNzb3IuZ2V0VmFsdWVNYXBEYXR1bShkYXR1bS5jb2RlKSxcbiAgICAgICAgICAgICAgICBuYW1lLCBsYWJlbENvb3JkaW5hdGUsIGxhYmVsLCByYXRpbywgcmVzdWx0RGF0YTtcblxuICAgICAgICAgICAgaWYgKHVzZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSB1c2VyRGF0YS5sYWJlbDtcbiAgICAgICAgICAgICAgICByYXRpbyA9IHVzZXJEYXRhLnJhdGlvO1xuICAgICAgICAgICAgICAgIG5hbWUgPSB1c2VyRGF0YS5uYW1lIHx8IGRhdHVtLm5hbWU7XG4gICAgICAgICAgICAgICAgbGFiZWxDb29yZGluYXRlID0gdXNlckRhdGEubGFiZWxDb29yZGluYXRlIHx8IGRhdHVtLmxhYmVsQ29vcmRpbmF0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBkYXR1bS5jb2RlLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgcGF0aDogZGF0dW0ucGF0aCxcbiAgICAgICAgICAgICAgICBib3VuZDogYm91bmQsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogc2VsZi5fbWFrZUxhYmVsUG9zaXRpb24oYm91bmQsIGxhYmVsQ29vcmRpbmF0ZSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdERhdGEubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJhdGlvKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0RGF0YS5yYXRpbyA9IHJhdGlvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0RGF0YTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldE1hcERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBEYXRhO1xuICAgIH0sXG5cbiAgICBnZXREYXR1bTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRGF0YVtpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBsYWJlbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyByYXRpb1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48e25hbWU6IHN0cmluZywgYm91bmQ6IHtkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICAgICAgcG9zaXRpb246IHt0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0sIGxhYmVsUG9zaXRpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19Pn0gbWFwIGRhdGFcbiAgICAgKi9cbiAgICBnZXRMYWJlbERhdGE6IGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGxhYmVsRGF0YSA9IHR1aS51dGlsLmZpbHRlcih0aGlzLm1hcERhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZU1hcERhdHVtKGRhdHVtLmNvZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChsYWJlbERhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGRhdHVtLm5hbWUsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBkYXR1bS5sYWJlbFBvc2l0aW9uLmxlZnQgKiByYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBkYXR1bS5sYWJlbFBvc2l0aW9uLnRvcCAqIHJhdGlvXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbWFwIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBtYXAgZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU1hcERpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYXBEYXRhID0gdGhpcy5tYXBEYXRhLFxuICAgICAgICAgICAgbGVmdHMgPSB0dWkudXRpbC5tYXAobWFwRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW0uYm91bmQucG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmlnaHRzID0gdHVpLnV0aWwubWFwKG1hcERhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdHVtLmJvdW5kLnBvc2l0aW9uLmxlZnQgKyBkYXR1bS5ib3VuZC5kaW1lbnNpb24ud2lkdGg7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRvcHMgPSB0dWkudXRpbC5tYXAobWFwRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW0uYm91bmQucG9zaXRpb24udG9wO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBib3R0b21zID0gdHVpLnV0aWwubWFwKG1hcERhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdHVtLmJvdW5kLnBvc2l0aW9uLnRvcCArIGRhdHVtLmJvdW5kLmRpbWVuc2lvbi5oZWlnaHQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHR1aS51dGlsLm1heChyaWdodHMpIC0gdHVpLnV0aWwubWluKGxlZnRzKSxcbiAgICAgICAgICAgIGhlaWdodDogdHVpLnV0aWwubWF4KGJvdHRvbXMpIC0gdHVpLnV0aWwubWluKHRvcHMpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBtYXAgZGltZW5zaW9uLlxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBtYXAgZGltZW5zaW9uXG4gICAgICovXG4gICAgZ2V0TWFwRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcERpbWVuc2lvbikge1xuICAgICAgICAgICAgdGhpcy5tYXBEaW1lbnNpb24gPSB0aGlzLl9tYWtlTWFwRGltZW5zaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tYXBEaW1lbnNpb247XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2hhcnRNYXBNb2RlbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBQaWUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyk7XG52YXIgcGllVHlwZU1peGVyID0gcmVxdWlyZSgnLi9waWVUeXBlTWl4ZXInKTtcbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxudmFyIFBpZUNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIFBpZUNoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogY2xhc3NOYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBjbGFzc05hbWU6ICd0dWktcGllLWNoYXJ0JyxcblxuICAgIC8qKlxuICAgICAqIFBpZSBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBQaWVDaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLnRvb2x0aXAgPSBvcHRpb25zLnRvb2x0aXAgfHwge307XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnRvb2x0aXAuYWxpZ24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMudG9vbHRpcC5hbGlnbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ERUZBVUxUX0FMSUdOX09QVElPTjtcbiAgICAgICAgfVxuXG4gICAgICAgIENoYXJ0QmFzZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIHJhd0RhdGE6IHJhd0RhdGEsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYWRkTGVnZW5kQ29tcG9uZW50KCk7XG4gICAgICAgIHRoaXMuX2FkZFRvb2x0aXBDb21wb25lbnQoKTtcbiAgICAgICAgdGhpcy5fYWRkU2VyaWVzQ29tcG9uZW50cyhbe1xuICAgICAgICAgICAgbmFtZTogJ3BpZVNlcmllcycsXG4gICAgICAgICAgICBhZGRpdGlvbmFsUGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICAgIHRoaXMuX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhIHJhdGlvcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9hZGREYXRhUmF0aW9zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLmFkZERhdGFSYXRpb3NPZlBpZUNoYXJ0KHRoaXMuY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZW5kU2VyaWVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIENoYXJ0QmFzZS5wcm90b3R5cGUuX3NlbmRTZXJpZXNEYXRhLmNhbGwodGhpcywgY2hhcnRDb25zdC5DSEFSVF9UWVBFX1BJRSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBjdXN0b20gZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfYXR0YWNoQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGllU2VyaWVzID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgncGllU2VyaWVzJyk7XG5cbiAgICAgICAgdGhpcy5fYXR0YWNoQ3VzdG9tRXZlbnRGb3JQaWVUeXBlQ2hhcnQoW3BpZVNlcmllc10pO1xuICAgICAgICBDaGFydEJhc2UucHJvdG90eXBlLl9hdHRhY2hDdXN0b21FdmVudC5jYWxsKHRoaXMpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5leHRlbmQoUGllQ2hhcnQucHJvdG90eXBlLCBwaWVUeXBlTWl4ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBpZUNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFBpZSBhbmQgRG9udXQgQ29tYm8gY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyk7XG52YXIgcGllVHlwZU1peGVyID0gcmVxdWlyZSgnLi9waWVUeXBlTWl4ZXInKTtcbnZhciBjb21ib1R5cGVNaXhlciA9IHJlcXVpcmUoJy4vY29tYm9UeXBlTWl4ZXInKTtcbnZhciBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpO1xuXG52YXIgUGllRG9udXRDb21ib0NoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIFBpZURvbnV0Q29tYm9DaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIGNsYXNzTmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgY2xhc3NOYW1lOiAndHVpLWNvbWJvLWNoYXJ0JyxcblxuICAgIC8qKlxuICAgICAqIFBpZSBhbmQgRG9udXQgQ29tYm8gY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgUGllRG9udXRDb21ib0NoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd0RhdGEsIHRoZW1lLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCB0eXBlcy5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGVzID0gdHVpLnV0aWwua2V5cyhyYXdEYXRhLnNlcmllcykuc29ydCgpO1xuXG4gICAgICAgIENoYXJ0QmFzZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIHJhd0RhdGE6IHJhd0RhdGEsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZSxcbiAgICAgICAgICAgIHNlcmllc05hbWVzOiB0aGlzLmNoYXJ0VHlwZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50cygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRhdGEgZm9yIGFkZGluZyBzZXJpZXMgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlRGF0YUZvckFkZGluZ1Nlcmllc0NvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNOYW1lcyA9IHRoaXMuY2hhcnRUeXBlcztcbiAgICAgICAgdmFyIG9wdGlvbnNNYXAgPSB0aGlzLl9tYWtlT3B0aW9uc01hcCh0aGlzLmNoYXJ0VHlwZXMpO1xuICAgICAgICB2YXIgdGhlbWVNYXAgPSB0aGlzLl9tYWtlVGhlbWVNYXAoc2VyaWVzTmFtZXMpO1xuICAgICAgICB2YXIgZGF0YVByb2Nlc3NvciA9IHRoaXMuZGF0YVByb2Nlc3NvcjtcbiAgICAgICAgdmFyIGlzU2hvd091dGVyTGFiZWwgPSB0dWkudXRpbC5hbnkob3B0aW9uc01hcCwgcHJlZGljYXRlLmlzU2hvd091dGVyTGFiZWwpO1xuICAgICAgICB2YXIgc2VyaWVzRGF0YSA9IHR1aS51dGlsLm1hcChzZXJpZXNOYW1lcywgZnVuY3Rpb24oc2VyaWVzTmFtZSkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0VHlwZSA9IGRhdGFQcm9jZXNzb3IuZmluZENoYXJ0VHlwZShzZXJpZXNOYW1lKTtcbiAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc05hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc01hcFtzZXJpZXNOYW1lXSxcbiAgICAgICAgICAgICAgICBpc1Nob3dPdXRlckxhYmVsOiBpc1Nob3dPdXRlckxhYmVsLFxuICAgICAgICAgICAgICAgIGlzQ29tYm86IHRydWUsXG4gICAgICAgICAgICAgICAgdGhlbWU6IHRoZW1lTWFwW3Nlcmllc05hbWVdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHNlcmllc05hbWUgKyAnU2VyaWVzJyxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUGFyYW1zOiBhZGRpdGlvbmFsUGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYWRkTGVnZW5kQ29tcG9uZW50KHRoaXMuY2hhcnRUeXBlcyk7XG4gICAgICAgIHRoaXMuX2FkZFRvb2x0aXBDb21wb25lbnQoKTtcbiAgICAgICAgdGhpcy5fYWRkU2VyaWVzQ29tcG9uZW50cyh0aGlzLl9tYWtlRGF0YUZvckFkZGluZ1Nlcmllc0NvbXBvbmVudCgpKTtcbiAgICAgICAgdGhpcy5fYWRkQ3VzdG9tRXZlbnRDb21wb25lbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2FkZERhdGFSYXRpb3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjaGFydFR5cGVzID0gdGhpcy5jaGFydFR5cGVzIHx8IFt0aGlzLmNoYXJ0VHlwZV07XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgc2VsZi5kYXRhUHJvY2Vzc29yLmFkZERhdGFSYXRpb3NPZlBpZUNoYXJ0KGNoYXJ0VHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY3VzdG9tIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXI7XG4gICAgICAgIHZhciBzZXJpZXNlcztcblxuICAgICAgICBDaGFydEJhc2UucHJvdG90eXBlLl9hdHRhY2hDdXN0b21FdmVudC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHNlcmllc2VzID0gdHVpLnV0aWwubWFwKHRoaXMuY2hhcnRUeXBlcywgZnVuY3Rpb24oc2VyaWVzTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudE1hbmFnZXIuZ2V0KHNlcmllc05hbWUgKyAnU2VyaWVzJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hdHRhY2hDdXN0b21FdmVudEZvclBpZVR5cGVDaGFydChzZXJpZXNlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGNoYW5nZSBzZWxlY3RlZCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtBcnJheS48P2Jvb2xlYW4+IHwge2xpbmU6ID9BcnJheS48Ym9vbGVhbj4sIGNvbHVtbjogP0FycmF5Ljxib29sZWFuPn19IGNoZWNrZWRMZWdlbmRzIGNoZWNrZWQgbGVnZW5kc1xuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIG9uQ2hhbmdlQ2hlY2tlZExlZ2VuZHM6IGZ1bmN0aW9uKGNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFJhd0RhdGEgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0T3JpZ2luYWxSYXdEYXRhKCk7XG4gICAgICAgIHZhciByYXdEYXRhID0gdGhpcy5fZmlsdGVyQ2hlY2tlZFJhd0RhdGEob3JpZ2luYWxSYXdEYXRhLCBjaGVja2VkTGVnZW5kcyk7XG5cbiAgICAgICAgQ2hhcnRCYXNlLnByb3RvdHlwZS5vbkNoYW5nZUNoZWNrZWRMZWdlbmRzLmNhbGwodGhpcywgY2hlY2tlZExlZ2VuZHMsIHJhd0RhdGEsIHtcbiAgICAgICAgICAgIHNlcmllc05hbWVzOiB0aGlzLmNoYXJ0VHlwZXNcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLmV4dGVuZChQaWVEb251dENvbWJvQ2hhcnQucHJvdG90eXBlLCBwaWVUeXBlTWl4ZXIsIGNvbWJvVHlwZU1peGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaWVEb251dENvbWJvQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgcGllVHlwZU1peGVyIGlzIG1peGVyIG9mIHBpZSB0eXBlIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG52YXIgTGVnZW5kID0gcmVxdWlyZSgnLi4vbGVnZW5kcy9sZWdlbmQnKTtcbnZhciBUb29sdGlwID0gcmVxdWlyZSgnLi4vdG9vbHRpcHMvdG9vbHRpcCcpO1xudmFyIFBpZUNoYXJ0U2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL3BpZUNoYXJ0U2VyaWVzJyk7XG52YXIgU2ltcGxlQ3VzdG9tRXZlbnQgPSByZXF1aXJlKCcuLi9jdXN0b21FdmVudHMvc2ltcGxlQ3VzdG9tRXZlbnQnKTtcblxuLyoqXG4gKiBwaWVUeXBlTWl4ZXIgaXMgbWl4ZXIgb2YgcGllIHR5cGUgY2hhcnQuXG4gKiBAbWl4aW5cbiAqL1xudmFyIHBpZVR5cGVNaXhlciA9IHtcbiAgICAvKipcbiAgICAgKiBBZGQgbGVnZW5kIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbY2hhcnRUeXBlc10gLSBjaGFydCB0eXBlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZExlZ2VuZENvbXBvbmVudDogZnVuY3Rpb24oY2hhcnRUeXBlcykge1xuICAgICAgICB2YXIgbGVnZW5kT3B0aW9uID0gdGhpcy5vcHRpb25zLmxlZ2VuZCB8fCB7fTtcblxuICAgICAgICBpZiAobGVnZW5kT3B0aW9uLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcignbGVnZW5kJywgTGVnZW5kLCB7XG4gICAgICAgICAgICAgICAgc2VyaWVzTmFtZXM6IGNoYXJ0VHlwZXMsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHRoaXMudXNlckV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgdG9vbHRpcCBjb21wb25lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkVG9vbHRpcENvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcigndG9vbHRpcCcsIFRvb2x0aXAsIHRoaXMuX21ha2VUb29sdGlwRGF0YSgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHNlcmllcyBjb21wb25lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHtuYW1lOiBzdHJpbmcsIGFkZGl0aW9uYWxQYXJhbXM6ID9vYmplY3R9Pn0gc2VyaWVzRGF0YSAtIGRhdGEgZm9yIGFkZGluZyBzZXJpZXMgY29tcG9uZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkU2VyaWVzQ29tcG9uZW50czogZnVuY3Rpb24oc2VyaWVzRGF0YSkge1xuICAgICAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuY29tcG9uZW50TWFuYWdlcjtcbiAgICAgICAgdmFyIHNlcmllc0Jhc2VQYXJhbXMgPSB7XG4gICAgICAgICAgICBsaWJUeXBlOiB0aGlzLm9wdGlvbnMubGliVHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6ICdzZXJpZXMnLFxuICAgICAgICAgICAgY2hhcnRCYWNrZ3JvdW5kOiB0aGlzLnRoZW1lLmNoYXJ0LmJhY2tncm91bmQsXG4gICAgICAgICAgICB1c2VyRXZlbnQ6IHRoaXMudXNlckV2ZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNEYXRhLCBmdW5jdGlvbihzZXJpZXNEYXR1bSkge1xuICAgICAgICAgICAgdmFyIHNlcmllc1BhcmFtcyA9IHR1aS51dGlsLmV4dGVuZChzZXJpZXNCYXNlUGFyYW1zLCBzZXJpZXNEYXR1bS5hZGRpdGlvbmFsUGFyYW1zKTtcblxuICAgICAgICAgICAgY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcihzZXJpZXNEYXR1bS5uYW1lLCBQaWVDaGFydFNlcmllcywgc2VyaWVzUGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjdXN0b20gZXZlbnQgY29tcG9uZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCdjdXN0b21FdmVudCcsIFNpbXBsZUN1c3RvbUV2ZW50LCB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY3VzdG9tIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHNlcmllc0NvbXBvbmVudHMgLSBzZXJpZXMgY29tcG9uZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50Rm9yUGllVHlwZUNoYXJ0OiBmdW5jdGlvbihzZXJpZXNDb21wb25lbnRzKSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50TmFtZSA9IHJlbmRlclV0aWwubWFrZUN1c3RvbUV2ZW50TmFtZSgnY2xpY2snLCB0aGlzLmNoYXJ0VHlwZSwgJ3NlcmllcycpO1xuICAgICAgICB2YXIgbW92ZUV2ZW50TmFtZSA9IHJlbmRlclV0aWwubWFrZUN1c3RvbUV2ZW50TmFtZSgnbW92ZScsIHRoaXMuY2hhcnRUeXBlLCAnc2VyaWVzJyk7XG4gICAgICAgIHZhciBjdXN0b21FdmVudCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ2N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIHZhciB0b29sdGlwID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgndG9vbHRpcCcpO1xuICAgICAgICB2YXIgZXZlbnRNYXAgPSB7fTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoc2VyaWVzQ29tcG9uZW50cywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICBldmVudE1hcFtjbGlja0V2ZW50TmFtZV0gPSBzZXJpZXMub25DbGlja1NlcmllcztcbiAgICAgICAgICAgIGV2ZW50TWFwW21vdmVFdmVudE5hbWVdID0gc2VyaWVzLm9uTW92ZVNlcmllcztcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50Lm9uKGV2ZW50TWFwLCBzZXJpZXMpO1xuXG4gICAgICAgICAgICBzZXJpZXMub24oe1xuICAgICAgICAgICAgICAgIHNob3dUb29sdGlwOiB0b29sdGlwLm9uU2hvdyxcbiAgICAgICAgICAgICAgICBoaWRlVG9vbHRpcDogdG9vbHRpcC5vbkhpZGUsXG4gICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXBDb250YWluZXI6IHRvb2x0aXAub25TaG93VG9vbHRpcENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBoaWRlVG9vbHRpcENvbnRhaW5lcjogdG9vbHRpcC5vbkhpZGVUb29sdGlwQ29udGFpbmVyXG4gICAgICAgICAgICB9LCB0b29sdGlwKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWVUeXBlTWl4ZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2NhdHRlciBjaGFydCBpcyBhIHR5cGUgb2YgcGxvdCBvciBtYXRoZW1hdGljYWwgZGlhZ3JhbSB1c2luZyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXNcbiAqICAgICAgICAgICAgICAgICAgdG8gZGlzcGxheSB2YWx1ZXMgZm9yIHR5cGljYWxseSB0d28gdmFyaWFibGVzIGZvciBhIHNldCBvZiBkYXRhLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpO1xudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4uL3Nlcmllcy9zY2F0dGVyQ2hhcnRTZXJpZXMnKTtcbnZhciBheGlzVHlwZU1peGVyID0gcmVxdWlyZSgnLi9heGlzVHlwZU1peGVyJyk7XG52YXIgU2ltcGxlQ3VzdG9tRXZlbnQgPSByZXF1aXJlKCcuLi9jdXN0b21FdmVudHMvc2ltcGxlQ3VzdG9tRXZlbnQnKTtcblxudmFyIFNjYXR0ZXJDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKENoYXJ0QmFzZSwgLyoqIEBsZW5kcyBTY2F0dGVyQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBjbGFzc05hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogJ3R1aS1zY2F0dGVyLWNoYXJ0JyxcbiAgICAvKipcbiAgICAgKiBTY2F0dGVyIGNoYXJ0IGlzIGEgdHlwZSBvZiBwbG90IG9yIG1hdGhlbWF0aWNhbCBkaWFncmFtIHVzaW5nIENhcnRlc2lhbiBjb29yZGluYXRlc1xuICAgICAqICB0byBkaXNwbGF5IHZhbHVlcyBmb3IgdHlwaWNhbGx5IHR3byB2YXJpYWJsZXMgZm9yIGEgc2V0IG9mIGRhdGEuXG4gICAgICogQGNvbnN0cnVjdHMgU2NhdHRlckNoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQG1peGVzIGF4aXNUeXBlTWl4ZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy50b29sdGlwID0gb3B0aW9ucy50b29sdGlwIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuYXhpc1NjYWxlTWFrZXJNYXAgPSBudWxsO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy50b29sdGlwLmFsaWduKSB7XG4gICAgICAgICAgICBvcHRpb25zLnRvb2x0aXAuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9BTElHTl9PUFRJT047XG4gICAgICAgIH1cblxuICAgICAgICBDaGFydEJhc2UuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICByYXdEYXRhOiByYXdEYXRhLFxuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGhhc0F4ZXM6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50cyhvcHRpb25zLmNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbWFwIGZvciBBeGlzU2NhbGVNYWtlciBvZiBheGVzKHhBeGlzLCB5QXhpcykuXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCBBeGlzU2NhbGVNYWtlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUF4aXNTY2FsZU1ha2VyTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHhBeGlzOiB0aGlzLl9jcmVhdGVBeGlzU2NhbGVNYWtlcihvcHRpb25zLnhBeGlzLCAneEF4aXMnLCAneCcpLFxuICAgICAgICAgICAgeUF4aXM6IHRoaXMuX2NyZWF0ZUF4aXNTY2FsZU1ha2VyKG9wdGlvbnMueUF4aXMsICd5QXhpcycsICd5JylcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50c0ZvckF4aXNUeXBlKHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgYXhpczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3lBeGlzJyxcbiAgICAgICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneEF4aXMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHNlcmllczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NjYXR0ZXJTZXJpZXMnLFxuICAgICAgICAgICAgICAgICAgICBTZXJpZXNDbGFzczogU2VyaWVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHBsb3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLmV4dGVuZChTY2F0dGVyQ2hhcnQucHJvdG90eXBlLCBheGlzVHlwZU1peGVyKTtcblxuLyoqXG4gKiBBZGQgZGF0YSByYXRpb3MuXG4gKiBAcHJpdmF0ZVxuICogQG92ZXJyaWRlXG4gKi9cblNjYXR0ZXJDaGFydC5wcm90b3R5cGUuX2FkZERhdGFSYXRpb3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NhbGVNYWtlck1hcCA9IHRoaXMuX2dldEF4aXNTY2FsZU1ha2VyTWFwKCk7XG5cbiAgICB0aGlzLmRhdGFQcm9jZXNzb3IuYWRkRGF0YVJhdGlvc0ZvckNvb3JkaW5hdGVUeXBlKHRoaXMuY2hhcnRUeXBlLCB7XG4gICAgICAgIHg6IHNjYWxlTWFrZXJNYXAueEF4aXMuZ2V0TGltaXQoKSxcbiAgICAgICAgeTogc2NhbGVNYWtlck1hcC55QXhpcy5nZXRMaW1pdCgpXG4gICAgfSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudCBmb3Igbm9ybWFsIHRvb2x0aXAuXG4gKiBAcHJpdmF0ZVxuICovXG5TY2F0dGVyQ2hhcnQucHJvdG90eXBlLl9hdHRhY2hDdXN0b21FdmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyO1xuICAgIHZhciBjdXN0b21FdmVudCA9IGNvbXBvbmVudE1hbmFnZXIuZ2V0KCdjdXN0b21FdmVudCcpO1xuICAgIHZhciBzY2F0dGVyU2VyaWVzID0gY29tcG9uZW50TWFuYWdlci5nZXQoJ3NjYXR0ZXJTZXJpZXMnKTtcbiAgICB2YXIgdG9vbHRpcCA9IGNvbXBvbmVudE1hbmFnZXIuZ2V0KCd0b29sdGlwJyk7XG5cbiAgICBheGlzVHlwZU1peGVyLl9hdHRhY2hDdXN0b21FdmVudC5jYWxsKHRoaXMpO1xuXG4gICAgY3VzdG9tRXZlbnQub24oe1xuICAgICAgICBjbGlja1NjYXR0ZXJTZXJpZXM6IHNjYXR0ZXJTZXJpZXMub25DbGlja1NlcmllcyxcbiAgICAgICAgbW92ZVNjYXR0ZXJTZXJpZXM6IHNjYXR0ZXJTZXJpZXMub25Nb3ZlU2VyaWVzXG4gICAgfSwgc2NhdHRlclNlcmllcyk7XG5cbiAgICBzY2F0dGVyU2VyaWVzLm9uKHtcbiAgICAgICAgc2hvd1Rvb2x0aXA6IHRvb2x0aXAub25TaG93LFxuICAgICAgICBoaWRlVG9vbHRpcDogdG9vbHRpcC5vbkhpZGUsXG4gICAgICAgIHNob3dUb29sdGlwQ29udGFpbmVyOiB0b29sdGlwLm9uU2hvd1Rvb2x0aXBDb250YWluZXIsXG4gICAgICAgIGhpZGVUb29sdGlwQ29udGFpbmVyOiB0b29sdGlwLm9uSGlkZVRvb2x0aXBDb250YWluZXJcbiAgICB9LCB0b29sdGlwKTtcbn07XG5cbi8qKlxuICogQWRkIGN1c3RvbSBldmVudCBjb21wb25lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5TY2F0dGVyQ2hhcnQucHJvdG90eXBlLl9hZGRDdXN0b21FdmVudENvbXBvbmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcignY3VzdG9tRXZlbnQnLCBTaW1wbGVDdXN0b21FdmVudCwge1xuICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlXG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYXR0ZXJDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUcmVlbWFwIGNoYXJ0IGlzIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiBoaWVyYXJjaGljYWwgZGF0YSBieSB1c2luZyByZWN0YW5nbGVzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpO1xudmFyIENvbG9yU3BlY3RydW0gPSByZXF1aXJlKCcuL2NvbG9yU3BlY3RydW0nKTtcbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvdHJlZW1hcENoYXJ0U2VyaWVzJyk7XG52YXIgVG9vbHRpcCA9IHJlcXVpcmUoJy4uL3Rvb2x0aXBzL3Rvb2x0aXAnKTtcbnZhciBMZWdlbmQgPSByZXF1aXJlKCcuLi9sZWdlbmRzL3NwZWN0cnVtTGVnZW5kJyk7XG52YXIgYXhpc0RhdGFNYWtlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYXhpc0RhdGFNYWtlcicpO1xudmFyIEJvdW5kc1R5cGVDdXN0b21FdmVudCA9IHJlcXVpcmUoJy4uL2N1c3RvbUV2ZW50cy9ib3VuZHNUeXBlQ3VzdG9tRXZlbnQnKTtcbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxudmFyIFRyZWVtYXBDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKENoYXJ0QmFzZSwgLyoqIEBsZW5kcyBUcmVlbWFwQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBjbGFzc05hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogJ3R1aS10cmVlbWFwLWNoYXJ0JyxcbiAgICAvKipcbiAgICAgKiBUcmVlbWFwIGNoYXJ0IGlzIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiBoaWVyYXJjaGljYWwgZGF0YSBieSB1c2luZyByZWN0YW5nbGVzLlxuICAgICAqIEBjb25zdHJ1Y3RzIFRyZWVtYXBDaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLnNlcmllcyA9IG9wdGlvbnMuc2VyaWVzIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnRvb2x0aXAgPSBvcHRpb25zLnRvb2x0aXAgfHwge307XG4gICAgICAgIG9wdGlvbnMudG9vbHRpcC5ncm91cGVkID0gZmFsc2U7XG5cbiAgICAgICAgQ2hhcnRCYXNlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgcmF3RGF0YTogcmF3RGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBoYXNBeGVzOiBmYWxzZSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNjYWxlIGluZm9ybWF0aW9uIGxpa2UgbGltaXQsIHN0ZXAgZm9yIHJlbmRlcmluZyBsZWdlbmRcbiAgICAgICAgICogQHR5cGUge3tsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHN0ZXA6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlbmdlZFNjYWxlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzKG9wdGlvbnMuY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ29tcG9uZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1c2VDb2xvclZhbHVlID0gdHVpLnV0aWwucGljayh0aGlzLm9wdGlvbnMsICdzZXJpZXMnLCAndXNlQ29sb3JWYWx1ZScpO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3Rlcignc2VyaWVzJywgU2VyaWVzLCB7XG4gICAgICAgICAgICBjaGFydEJhY2tncm91bmQ6IHRoaXMudGhlbWUuY2hhcnQuYmFja2dyb3VuZCxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICAgICAgICB1c2VyRXZlbnQ6IHRoaXMudXNlckV2ZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcigndG9vbHRpcCcsIFRvb2x0aXAsIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBsYWJlbFRoZW1lOiB0dWkudXRpbC5waWNrKHRoaXMudGhlbWUsICdzZXJpZXMnLCAnbGFiZWwnKVxuICAgICAgICB9LCB0aGlzLl9tYWtlVG9vbHRpcERhdGEoKSkpO1xuXG4gICAgICAgIGlmICh1c2VDb2xvclZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2xlZ2VuZCcsIExlZ2VuZCwge1xuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiB0aGlzLnVzZXJFdmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2N1c3RvbUV2ZW50JywgQm91bmRzVHlwZUN1c3RvbUV2ZW50LCB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGVnZW5kIHNjYWxlXG4gICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCBBeGlzU2NhbGVNYWtlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGVnZW5kU2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMubGVuZ2VkU2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ2VkU2NhbGUgPSB0aGlzLl9jcmVhdGVBeGlzU2NhbGVNYWtlcih7fSwgJ2xlZ2VuZCcsIG51bGwsIHRoaXMuY2hhcnRUeXBlLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVDb3VudDogY2hhcnRDb25zdC5TUEVDVFJVTV9MRUdFTkRfVElDS19DT1VOVFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sZW5nZWRTY2FsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zIHRvIGRhdGFQcm9jZXNzb3IgZm9yIHJlbmRlcmluZyBncmFwaC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9hZGREYXRhUmF0aW9zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpbWl0ID0gdGhpcy5fZ2V0TGVnZW5kU2NhbGUoKS5nZXRMaW1pdCgpO1xuXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3Nvci5hZGREYXRhUmF0aW9zRm9yVHJlZW1hcENoYXJ0KGxpbWl0LCB0aGlzLmNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcmVuZGVyaW5nIGRhdGEgZm9yIGRlbGl2ZXJ5IHRvIGVhY2ggY29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZVJlbmRlcmluZ0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgc2VyaWVzVGhlbWUgPSB0aGlzLnRoZW1lLnNlcmllcztcbiAgICAgICAgdmFyIHVzZUNvbG9yVmFsdWUgPSB0dWkudXRpbC5waWNrKHRoaXMub3B0aW9ucywgJ3NlcmllcycsICd1c2VDb2xvclZhbHVlJyk7XG4gICAgICAgIHZhciBjb2xvclNwZWN0cnVtID0gdXNlQ29sb3JWYWx1ZSA/IChuZXcgQ29sb3JTcGVjdHJ1bShzZXJpZXNUaGVtZS5zdGFydENvbG9yLCBzZXJpZXNUaGVtZS5lbmRDb2xvcikpIDogbnVsbDtcblxuICAgICAgICBkYXRhLmxlZ2VuZCA9IHtcbiAgICAgICAgICAgIGNvbG9yU3BlY3RydW06IGNvbG9yU3BlY3RydW0sXG4gICAgICAgICAgICBheGVzRGF0YTogYXhpc0RhdGFNYWtlci5tYWtlVmFsdWVBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgYXhpc1NjYWxlTWFrZXI6IHRoaXMuX2dldExlZ2VuZFNjYWxlKCksXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgICAgZGF0YS5zZXJpZXMgPSB7XG4gICAgICAgICAgICBjb2xvclNwZWN0cnVtOiBjb2xvclNwZWN0cnVtXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBjdXN0b20gZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfYXR0YWNoQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnc2VyaWVzJyk7XG4gICAgICAgIHZhciBjdXN0b21FdmVudCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ2N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIHZhciB0b29sdGlwID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgndG9vbHRpcCcpO1xuICAgICAgICB2YXIgbGVnZW5kID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnbGVnZW5kJyk7XG5cbiAgICAgICAgQ2hhcnRCYXNlLnByb3RvdHlwZS5fYXR0YWNoQ3VzdG9tRXZlbnQuY2FsbCh0aGlzKTtcblxuICAgICAgICBjdXN0b21FdmVudC5vbignc2hvd1Rvb2x0aXAnLCB0b29sdGlwLm9uU2hvdywgdG9vbHRpcCk7XG4gICAgICAgIGN1c3RvbUV2ZW50Lm9uKCdoaWRlVG9vbHRpcCcsIHRvb2x0aXAub25IaWRlLCB0b29sdGlwKTtcblxuICAgICAgICB0b29sdGlwLm9uKCdzaG93VHJlZW1hcEFuaW1hdGlvbicsIHNlcmllcy5vblNob3dBbmltYXRpb24sIHNlcmllcyk7XG4gICAgICAgIHRvb2x0aXAub24oJ2hpZGVUcmVlbWFwQW5pbWF0aW9uJywgc2VyaWVzLm9uSGlkZUFuaW1hdGlvbiwgc2VyaWVzKTtcblxuICAgICAgICBzZXJpZXMub24oJ2FmdGVyWm9vbScsIGN1c3RvbUV2ZW50Lm9uQWZ0ZXJab29tLCBjdXN0b21FdmVudCk7XG5cbiAgICAgICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQub24oJ3Nob3dUb29sdGlwJywgc2VyaWVzLm9uU2hvd1Rvb2x0aXAsIHNlcmllcyk7XG4gICAgICAgICAgICBjdXN0b21FdmVudC5vbignaGlkZVRvb2x0aXAnLCBsZWdlbmQub25IaWRlV2VkZ2UsIGxlZ2VuZCk7XG5cbiAgICAgICAgICAgIHNlcmllcy5vbignc2hvd1dlZGdlJywgbGVnZW5kLm9uU2hvd1dlZGdlLCBsZWdlbmQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIHpvb20uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2YgdGFyZ2V0IHNlcmllc0l0ZW1cbiAgICAgKi9cbiAgICBvblpvb206IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckNvbXBvbmVudHMoe1xuICAgICAgICAgICAgJ3Nlcmllcyc6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgJ3pvb20nKTtcbiAgICAgICAgdGhpcy5fc2VuZFNlcmllc0RhdGEoKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlbWFwQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29sdW1uIGFuZCBMaW5lIENvbWJvIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxjdWxhdG9yJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyk7XG52YXIgQ29sdW1uQ2hhcnRTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvY29sdW1uQ2hhcnRTZXJpZXMnKTtcbnZhciBMaW5lQ2hhcnRTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvbGluZUNoYXJ0U2VyaWVzJyk7XG52YXIgQXJlYUNoYXJ0U2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL2FyZWFDaGFydFNlcmllcycpO1xuXG52YXIgdmVydGljYWxUeXBlQ29tYm9NaXhlciA9IHtcbiAgICAvKipcbiAgICAgKiBDb2x1bW4gYW5kIExpbmUgQ29tYm8gY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgdmVydGljYWxUeXBlQ29tYm9NaXhlclxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBfaW5pdEZvclZlcnRpY2FsVHlwZUNvbWJvOiBmdW5jdGlvbihyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY2hhcnRUeXBlc01hcDtcblxuICAgICAgICBjaGFydFR5cGVzTWFwID0gdGhpcy5fbWFrZUNoYXJ0VHlwZXNNYXAocmF3RGF0YS5zZXJpZXMsIG9wdGlvbnMueUF4aXMsIG9wdGlvbnMuY2hhcnRUeXBlKTtcblxuICAgICAgICB0dWkudXRpbC5leHRlbmQodGhpcywgY2hhcnRUeXBlc01hcCk7XG5cbiAgICAgICAgb3B0aW9ucy50b29sdGlwID0gb3B0aW9ucy50b29sdGlwIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnRvb2x0aXAuZ3JvdXBlZCA9IHRydWU7XG5cbiAgICAgICAgQ2hhcnRCYXNlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgcmF3RGF0YTogcmF3RGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBoYXNBeGVzOiB0cnVlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZSxcbiAgICAgICAgICAgIHNlcmllc05hbWVzOiBjaGFydFR5cGVzTWFwLnNlcmllc05hbWVzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB5QXhpcyBvcHRpb25zIG1hcFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55QXhpc09wdGlvbnNNYXAgPSB0aGlzLl9tYWtlWUF4aXNPcHRpb25zTWFwKGNoYXJ0VHlwZXNNYXAuY2hhcnRUeXBlcywgb3B0aW9ucy55QXhpcyk7XG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHMoY2hhcnRUeXBlc01hcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgeUF4aXMgb3B0aW9ucyBtYXAuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0geUF4aXNPcHRpb25zIHlBeGlzIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7e2NvbHVtbjogP29iamVjdCwgbGluZTogP29iamVjdH19IG9wdGlvbnMgbWFwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVlBeGlzT3B0aW9uc01hcDogZnVuY3Rpb24oY2hhcnRUeXBlcywgeUF4aXNPcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRpb25zTWFwID0ge307XG4gICAgICAgIHlBeGlzT3B0aW9ucyA9IHlBeGlzT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIG9wdGlvbnNNYXBbY2hhcnRUeXBlXSA9IHlBeGlzT3B0aW9uc1tpbmRleF0gfHwgeUF4aXNPcHRpb25zO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3B0aW9uc01hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjaGFydCB0eXBlcyBtYXAuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJhd1Nlcmllc0RhdGEgcmF3IHNlcmllcyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHlBeGlzT3B0aW9uIG9wdGlvbiBmb3IgeSBheGlzXG4gICAgICogQHJldHVybnMge29iamVjdH0gY2hhcnQgdHlwZXMgbWFwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNoYXJ0VHlwZXNNYXA6IGZ1bmN0aW9uKHJhd1Nlcmllc0RhdGEsIHlBeGlzT3B0aW9uKSB7XG4gICAgICAgIHZhciBzZXJpZXNOYW1lcyA9IHR1aS51dGlsLmtleXMocmF3U2VyaWVzRGF0YSkuc29ydCgpO1xuICAgICAgICB2YXIgb3B0aW9uQ2hhcnRUeXBlcyA9IHRoaXMuX2dldFlBeGlzT3B0aW9uQ2hhcnRUeXBlcyhzZXJpZXNOYW1lcywgeUF4aXNPcHRpb24pO1xuICAgICAgICB2YXIgY2hhcnRUeXBlcyA9IG9wdGlvbkNoYXJ0VHlwZXMubGVuZ3RoID8gb3B0aW9uQ2hhcnRUeXBlcyA6IHNlcmllc05hbWVzO1xuICAgICAgICB2YXIgdmFsaWRDaGFydFR5cGVzID0gdHVpLnV0aWwuZmlsdGVyKG9wdGlvbkNoYXJ0VHlwZXMsIGZ1bmN0aW9uKF9jaGFydFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiByYXdTZXJpZXNEYXRhW19jaGFydFR5cGVdLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjaGFydFR5cGVzTWFwO1xuXG4gICAgICAgIGlmICh2YWxpZENoYXJ0VHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjaGFydFR5cGVzTWFwID0ge1xuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZXM6IHZhbGlkQ2hhcnRUeXBlcyxcbiAgICAgICAgICAgICAgICBzZXJpZXNOYW1lczogdmFsaWRDaGFydFR5cGVzLFxuICAgICAgICAgICAgICAgIG9wdGlvbkNoYXJ0VHlwZXM6ICFvcHRpb25DaGFydFR5cGVzLmxlbmd0aCA/IG9wdGlvbkNoYXJ0VHlwZXMgOiB2YWxpZENoYXJ0VHlwZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFydFR5cGVzTWFwID0ge1xuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZXM6IGNoYXJ0VHlwZXMsXG4gICAgICAgICAgICAgICAgc2VyaWVzTmFtZXM6IHNlcmllc05hbWVzLFxuICAgICAgICAgICAgICAgIG9wdGlvbkNoYXJ0VHlwZXM6IG9wdGlvbkNoYXJ0VHlwZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hhcnRUeXBlc01hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBkYXRhIGZvciBhZGRpbmcgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzZXJpZXNOYW1lcyAtIHNlcmllcyBuYW1lc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlRGF0YUZvckFkZGluZ1Nlcmllc0NvbXBvbmVudDogZnVuY3Rpb24oc2VyaWVzTmFtZXMpIHtcbiAgICAgICAgdmFyIHNlcmllc0NsYXNzZXMgPSB7XG4gICAgICAgICAgICBjb2x1bW46IENvbHVtbkNoYXJ0U2VyaWVzLFxuICAgICAgICAgICAgbGluZTogTGluZUNoYXJ0U2VyaWVzLFxuICAgICAgICAgICAgYXJlYTogQXJlYUNoYXJ0U2VyaWVzXG4gICAgICAgIH07XG4gICAgICAgIHZhciBvcHRpb25zTWFwID0gdGhpcy5fbWFrZU9wdGlvbnNNYXAoc2VyaWVzTmFtZXMpO1xuICAgICAgICB2YXIgdGhlbWVNYXAgPSB0aGlzLl9tYWtlVGhlbWVNYXAoc2VyaWVzTmFtZXMpO1xuICAgICAgICB2YXIgZGF0YVByb2Nlc3NvciA9IHRoaXMuZGF0YVByb2Nlc3NvcjtcbiAgICAgICAgdmFyIHNlcmllc2VzID0gdHVpLnV0aWwubWFwKHNlcmllc05hbWVzLCBmdW5jdGlvbihzZXJpZXNOYW1lKSB7XG4gICAgICAgICAgICB2YXIgY2hhcnRUeXBlID0gZGF0YVByb2Nlc3Nvci5maW5kQ2hhcnRUeXBlKHNlcmllc05hbWUpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZVRvb2x0aXA6IHRydWUsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTmFtZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zTWFwW3Nlcmllc05hbWVdLFxuICAgICAgICAgICAgICAgIHRoZW1lOiB0aGVtZU1hcFtzZXJpZXNOYW1lXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBzZXJpZXNOYW1lICsgJ1NlcmllcycsXG4gICAgICAgICAgICAgICAgU2VyaWVzQ2xhc3M6IHNlcmllc0NsYXNzZXNbY2hhcnRUeXBlXSxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjb21wb25lbnRzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0VHlwZXNNYXAgY2hhcnQgdHlwZXMgbWFwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ29tcG9uZW50czogZnVuY3Rpb24oY2hhcnRUeXBlc01hcCkge1xuICAgICAgICB2YXIgYXhlcyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAneUF4aXMnLFxuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlc01hcC5jaGFydFR5cGVzWzBdLFxuICAgICAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3hBeGlzJyxcbiAgICAgICAgICAgICAgICBpc0xhYmVsOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICAgIHZhciBzZXJpZXNlcyA9IHRoaXMuX21ha2VEYXRhRm9yQWRkaW5nU2VyaWVzQ29tcG9uZW50KGNoYXJ0VHlwZXNNYXAuc2VyaWVzTmFtZXMpO1xuXG4gICAgICAgIGlmIChjaGFydFR5cGVzTWFwLm9wdGlvbkNoYXJ0VHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBheGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdyaWdodFlBeGlzJyxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZXNNYXAuY2hhcnRUeXBlc1sxXSxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHNGb3JBeGlzVHlwZSh7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMub3B0aW9ucy5jaGFydFR5cGUsXG4gICAgICAgICAgICBzZXJpZXNOYW1lczogY2hhcnRUeXBlc01hcC5zZXJpZXNOYW1lcyxcbiAgICAgICAgICAgIGF4aXM6IGF4ZXMsXG4gICAgICAgICAgICBzZXJpZXM6IHNlcmllc2VzLFxuICAgICAgICAgICAgcGxvdDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHkgYXhpcyBvcHRpb24gY2hhcnQgdHlwZXMuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB5QXhpc09wdGlvbnMgeSBheGlzIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IGNoYXJ0IHR5cGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0WUF4aXNPcHRpb25DaGFydFR5cGVzOiBmdW5jdGlvbihjaGFydFR5cGVzLCB5QXhpc09wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdENoYXJ0VHlwZXMgPSBjaGFydFR5cGVzLnNsaWNlKCksXG4gICAgICAgICAgICBpc1JldmVyc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIG9wdGlvbkNoYXJ0VHlwZXM7XG5cbiAgICAgICAgeUF4aXNPcHRpb25zID0geUF4aXNPcHRpb25zID8gW10uY29uY2F0KHlBeGlzT3B0aW9ucykgOiBbXTtcblxuICAgICAgICBpZiAoeUF4aXNPcHRpb25zLmxlbmd0aCA9PT0gMSAmJiAheUF4aXNPcHRpb25zWzBdLmNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgcmVzdWx0Q2hhcnRUeXBlcyA9IFtdO1xuICAgICAgICB9IGVsc2UgaWYgKHlBeGlzT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9wdGlvbkNoYXJ0VHlwZXMgPSB0dWkudXRpbC5tYXAoeUF4aXNPcHRpb25zLCBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uLmNoYXJ0VHlwZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkob3B0aW9uQ2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlzUmV2ZXJzZSA9IGlzUmV2ZXJzZSB8fCAoY2hhcnRUeXBlICYmIHJlc3VsdENoYXJ0VHlwZXNbaW5kZXhdICE9PSBjaGFydFR5cGUgfHwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChpc1JldmVyc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRDaGFydFR5cGVzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRDaGFydFR5cGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgQXhpc1NjYWxlTWFrZSBmb3IgeSBheGlzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIHRoaXMuY2hhcnRUeXBlc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTaW5nbGVZQXhpcyAtIHdoZXRoZXIgc2luZ2xlIHkgYXhpcyBvciBub3QuXG4gICAgICogQHJldHVybnMge0F4aXNTY2FsZU1ha2VyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVlBeGlzU2NhbGVNYWtlcjogZnVuY3Rpb24oaW5kZXgsIGlzU2luZ2xlWUF4aXMpIHtcbiAgICAgICAgdmFyIGNoYXJ0VHlwZSA9IHRoaXMuY2hhcnRUeXBlc1tpbmRleF07XG4gICAgICAgIHZhciB5QXhpc09wdGlvbiA9IHRoaXMueUF4aXNPcHRpb25zTWFwW2NoYXJ0VHlwZV07XG4gICAgICAgIHZhciBhZGRpdGlvbmFsUGFyYW1zID0ge1xuICAgICAgICAgICAgaXNTaW5nbGVZQXhpczogISFpc1NpbmdsZVlBeGlzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUF4aXNTY2FsZU1ha2VyKHlBeGlzT3B0aW9uLCAneUF4aXMnLCBudWxsLCBjaGFydFR5cGUsIGFkZGl0aW9uYWxQYXJhbXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG1hcCBmb3IgQXhpc1NjYWxlTWFrZXIgb2YgYXhlcyh4QXhpcywgeUF4aXMpLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgQXhpc1NjYWxlTWFrZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBeGlzU2NhbGVNYWtlck1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpc1NpbmdsZVlBeGlzID0gdGhpcy5vcHRpb25DaGFydFR5cGVzLmxlbmd0aCA8IDI7XG4gICAgICAgIHZhciBheGlzU2NhbGVNYWtlck1hcCA9IHtcbiAgICAgICAgICAgIHlBeGlzOiB0aGlzLl9jcmVhdGVZQXhpc1NjYWxlTWFrZXIoMCwgaXNTaW5nbGVZQXhpcylcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWlzU2luZ2xlWUF4aXMpIHtcbiAgICAgICAgICAgIGF4aXNTY2FsZU1ha2VyTWFwLnJpZ2h0WUF4aXMgPSB0aGlzLl9jcmVhdGVZQXhpc1NjYWxlTWFrZXIoMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXhpc1NjYWxlTWFrZXJNYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluY3JlYXNlIHlBeGlzIHRpY2sgY291bnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluY3JlYXNlVGlja0NvdW50IGluY3JlYXNlIHRpY2sgY291bnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0geUF4aXNEYXRhIHlBeGlzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbmNyZWFzZVlBeGlzVGlja0NvdW50OiBmdW5jdGlvbihpbmNyZWFzZVRpY2tDb3VudCwgeUF4aXNEYXRhKSB7XG4gICAgICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0RnVuY3Rpb25zKCk7XG4gICAgICAgIHZhciBsYWJlbHM7XG5cbiAgICAgICAgeUF4aXNEYXRhLmxpbWl0Lm1heCArPSB5QXhpc0RhdGEuc3RlcCAqIGluY3JlYXNlVGlja0NvdW50O1xuICAgICAgICBsYWJlbHMgPSBjYWxjdWxhdG9yLm1ha2VMYWJlbHNGcm9tTGltaXQoeUF4aXNEYXRhLmxpbWl0LCB5QXhpc0RhdGEuc3RlcCk7XG4gICAgICAgIHlBeGlzRGF0YS5sYWJlbHMgPSByZW5kZXJVdGlsLmZvcm1hdFZhbHVlcyhsYWJlbHMsIGZvcm1hdEZ1bmN0aW9ucywgdGhpcy5jaGFydFR5cGUsICd5QXhpcycpO1xuICAgICAgICB5QXhpc0RhdGEudGlja0NvdW50ICs9IGluY3JlYXNlVGlja0NvdW50O1xuICAgICAgICB5QXhpc0RhdGEudmFsaWRUaWNrQ291bnQgKz0gaW5jcmVhc2VUaWNrQ291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aWNrIGNvdW50IHRvIG1ha2UgdGhlIHNhbWUgdGljayBjb3VudCBvZiB5IEF4ZXMoeUF4aXMsIHJpZ2h0WUF4aXMpLlxuICAgICAqIEBwYXJhbSB7e3lBeGlzOiBvYmplY3QsIHJpZ2h0WUF4aXM6IG9iamVjdH19IGF4ZXNEYXRhIC0gYXhlc0RhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVZQXhpc1RpY2tDb3VudDogZnVuY3Rpb24oYXhlc0RhdGEpIHtcbiAgICAgICAgdmFyIHlBeGlzRGF0YSA9IGF4ZXNEYXRhLnlBeGlzO1xuICAgICAgICB2YXIgcmlnaHRZQXhpc0RhdGEgPSBheGVzRGF0YS5yaWdodFlBeGlzO1xuICAgICAgICB2YXIgdGlja0NvdW50RGlmZiA9IHJpZ2h0WUF4aXNEYXRhLnRpY2tDb3VudCAtIHlBeGlzRGF0YS50aWNrQ291bnQ7XG5cbiAgICAgICAgaWYgKHRpY2tDb3VudERpZmYgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmNyZWFzZVlBeGlzVGlja0NvdW50KHRpY2tDb3VudERpZmYsIHlBeGlzRGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGlja0NvdW50RGlmZiA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2luY3JlYXNlWUF4aXNUaWNrQ291bnQoLXRpY2tDb3VudERpZmYsIHJpZ2h0WUF4aXNEYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGF4ZXMgZGF0YSwgdXNlZCBpbiBhIGF4aXMgY29tcG9uZW50IGxpa2UgeUF4aXMsIHhBeGlzLCByaWdodFlBeGlzLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGF4ZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VBeGVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBheGlzU2NhbGVNYWtlck1hcCA9IHRoaXMuX2dldEF4aXNTY2FsZU1ha2VyTWFwKCk7XG4gICAgICAgIHZhciB5QXhpc09wdGlvbnNNYXAgPSB0aGlzLnlBeGlzT3B0aW9uc01hcDtcbiAgICAgICAgdmFyIHlBeGlzT3B0aW9ucyA9IHlBeGlzT3B0aW9uc01hcFt0aGlzLmNoYXJ0VHlwZXNbMF1dO1xuICAgICAgICB2YXIgYXhlc0RhdGEgPSB7XG4gICAgICAgICAgICB4QXhpczogdGhpcy5fbWFrZUF4aXNEYXRhKG51bGwsIHRoaXMub3B0aW9ucy54QXhpcyksXG4gICAgICAgICAgICB5QXhpczogdGhpcy5fbWFrZUF4aXNEYXRhKGF4aXNTY2FsZU1ha2VyTWFwLnlBeGlzLCB5QXhpc09wdGlvbnMsIHRydWUpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGF4aXNTY2FsZU1ha2VyTWFwLnJpZ2h0WUF4aXMpIHtcbiAgICAgICAgICAgIHlBeGlzT3B0aW9ucyA9IHlBeGlzT3B0aW9uc01hcFt0aGlzLmNoYXJ0VHlwZXNbMV1dO1xuICAgICAgICAgICAgYXhlc0RhdGEucmlnaHRZQXhpcyA9IHRoaXMuX21ha2VBeGlzRGF0YShheGlzU2NhbGVNYWtlck1hcC5yaWdodFlBeGlzLCB5QXhpc09wdGlvbnMsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgYXhlc0RhdGEucmlnaHRZQXhpcy5hbGlnbmVkID0gYXhlc0RhdGEueEF4aXMuYWxpZ25lZDtcblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlWUF4aXNUaWNrQ291bnQoYXhlc0RhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF4ZXNEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXggaW4uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyB0YXJnZXQgZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgbWl4aW46IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKGZ1bmMucHJvdG90eXBlLCB0aGlzKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gdmVydGljYWxUeXBlQ29tYm9NaXhlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyB6b29tTWl4ZXIgaXMgbWl4ZXIgb2YgbGluZSB0eXBlIGNoYXJ0KGxpbmUsIGFyZWEpLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogem9vbU1peGVyIGlzIG1peGVyIG9mIGxpbmUgdHlwZSBjaGFydChsaW5lLCBhcmVhKS5cbiAqIEBtaXhpblxuICovXG52YXIgem9vbU1peGVyID0ge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBmb3Igem9vbS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmVzZXRab29tIC0gd2hldGhlciByZXNldCB6b29tIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckZvclpvb206IGZ1bmN0aW9uKGlzUmVzZXRab29tKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLmJvdW5kc01ha2VyLmluaXRCb3VuZHNEYXRhKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcihmdW5jdGlvbihyZW5kZXJpbmdEYXRhKSB7XG4gICAgICAgICAgICByZW5kZXJpbmdEYXRhLmN1c3RvbUV2ZW50LmlzUmVzZXRab29tID0gaXNSZXNldFpvb207XG4gICAgICAgICAgICBzZWxmLl9yZW5kZXJDb21wb25lbnRzKHJlbmRlcmluZ0RhdGEsICd6b29tJyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiB6b29tLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGluZGV4UmFuZ2UgLSBpbmRleCByYW5nZSBmb3Igem9vbVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIG9uWm9vbTogZnVuY3Rpb24oaW5kZXhSYW5nZSkge1xuICAgICAgICB0aGlzLl9wYXVzZUFuaW1hdGlvbkZvckFkZGluZ0RhdGEoKTtcbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLnVwZGF0ZVJhd0RhdGFGb3Jab29tKGluZGV4UmFuZ2UpO1xuICAgICAgICB0aGlzLmF4aXNTY2FsZU1ha2VyTWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVuZGVyRm9yWm9vbShmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIHJlc2V0IHpvb20uXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgb25SZXNldFpvb206IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmF3RGF0YSA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRPcmlnaW5hbFJhd0RhdGEoKTtcblxuICAgICAgICBpZiAodGhpcy5jaGVja2VkTGVnZW5kcykge1xuICAgICAgICAgICAgcmF3RGF0YSA9IHRoaXMuX2ZpbHRlckNoZWNrZWRSYXdEYXRhKHJhd0RhdGEsIHRoaXMuY2hlY2tlZExlZ2VuZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5heGlzU2NhbGVNYWtlck1hcCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldlVwZGF0ZWREYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5maXJzdFRpY2tDb3VudCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLmluaXREYXRhKHJhd0RhdGEpO1xuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IuaW5pdFpvb21lZFJhd0RhdGEoKTtcbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLmFkZERhdGFGcm9tUmVtYWluRHluYW1pY0RhdGEodHVpLnV0aWwucGljayh0aGlzLm9wdGlvbnMuc2VyaWVzLCAnc2hpZnRpbmcnKSk7XG4gICAgICAgIHRoaXMuX3JlbmRlckZvclpvb20odHJ1ZSk7XG4gICAgICAgIHRoaXMuX3Jlc3RhcnRBbmltYXRpb25Gb3JBZGRpbmdEYXRhKCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB6b29tTWl4ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUGljayBtaW5pbXVtIHZhbHVlIGZyb20gdmFsdWUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgdmFsdWUgYXJyYXlcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjb25kaXRpb24gY29uZGl0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgdGFyZ2V0IGNvbnRleHRcbiAqIEByZXR1cm5zIHsqfSBtaW5pbXVtIHZhbHVlXG4gKi9cbnZhciBtaW4gPSBmdW5jdGlvbihhcnIsIGNvbmRpdGlvbiwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQsIG1pblZhbHVlLCByZXN0O1xuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gIE1hdGgubWluLmFwcGx5KG51bGwsIGFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYXJyWzBdO1xuICAgICAgICBtaW5WYWx1ZSA9IGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIHJlc3VsdCwgMCk7XG4gICAgICAgIHJlc3QgPSBhcnIuc2xpY2UoMSk7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShyZXN0LCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGNvbXBhcmVWYWx1ZSA9IGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIGl0ZW0sIGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyZVZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IGNvbXBhcmVWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQaWNrIG1heGltdW0gdmFsdWUgZnJvbSB2YWx1ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyciB2YWx1ZSBhcnJheVxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNvbmRpdGlvbiBjb25kaXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCB0YXJnZXQgY29udGV4dFxuICogQHJldHVybnMgeyp9IG1heGltdW0gdmFsdWVcbiAqL1xudmFyIG1heCA9IGZ1bmN0aW9uKGFyciwgY29uZGl0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCwgbWF4VmFsdWUsIHJlc3Q7XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICByZXN1bHQgPSBNYXRoLm1heC5hcHBseShudWxsLCBhcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGFyclswXTtcbiAgICAgICAgbWF4VmFsdWUgPSBjb25kaXRpb24uY2FsbChjb250ZXh0LCByZXN1bHQsIDApO1xuICAgICAgICByZXN0ID0gYXJyLnNsaWNlKDEpO1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkocmVzdCwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb21wYXJlVmFsdWUgPSBjb25kaXRpb24uY2FsbChjb250ZXh0LCBpdGVtLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVWYWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBjb21wYXJlVmFsdWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogV2hldGhlciBvbmUgb2YgdGhlbSBpcyB0cnVlIG9yIG5vdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbGxlY3Rpb24gdGFyZ2V0IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBjb25kaXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCB0YXJnZXQgY29udGV4dFxuICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gKi9cbnZhciBhbnkgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBjb25kaXRpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgdHVpLnV0aWwuZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbihpdGVtLCBrZXkpIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIGl0ZW0sIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBbGwgb2YgdGhlbSBpcyB0cnVlIG9yIG5vdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbGxlY3Rpb24gdGFyZ2V0IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBjb25kaXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSB7W29iamVjdF19IGNvbnRleHQgdGFyZ2V0IGNvbnRleHRcbiAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICovXG52YXIgYWxsID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgY29uZGl0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9ICEhKGNvbGxlY3Rpb24gfHwgW10pLmxlbmd0aDtcbiAgICB0dWkudXRpbC5mb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKGl0ZW0sIGtleSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIGl0ZW0sIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogTWFrZSB1bmlxdWUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheX0gYXJyIHRhcmdldCBhcnJheVxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc29ydGVkIHdoZXRoZXIgc29ydGVkIG9yIG5vdC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBpdGVyYXRlZSBpdGVyYXRlZSBmdW5jdGlvblxuICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IHRhcmdldCBjb250ZXh0XG4gKiBAcmV0dXJucyB7QXJyYXl9IHVuaXF1ZSB2YWx1ZXNcbiAqL1xudmFyIHVuaXF1ZSA9IGZ1bmN0aW9uKGFyciwgc29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgcHJldlZhbHVlO1xuXG4gICAgaWYgKCF0dWkudXRpbC5pc0Jvb2xlYW4oc29ydGVkKSkge1xuICAgICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICAgIGl0ZXJhdGVlID0gc29ydGVkO1xuICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpdGVyYXRlZSA9IGl0ZXJhdGVlIHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoYXJyLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZXJhdGVlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBhcnIpO1xuICAgICAgICAgICAgaWYgKCFpbmRleCB8fCBwcmV2VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShhcnIsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFsdWUgPSBpdGVyYXRlZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgYXJyKTtcbiAgICAgICAgICAgIGlmICh0dWkudXRpbC5pbkFycmF5KHZhbHVlLCByZXN1bHQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQXJyYXkgcGl2b3QuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmNhbGN1bGF0b3JcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gYXJyMmQgdGFyZ2V0IDJkIGFycmF5XG4gKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5Pn0gcGl2b3RlZCAyZCBhcnJheVxuICovXG52YXIgcGl2b3QgPSBmdW5jdGlvbihhcnIyZCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbGVuID0gdHVpLnV0aWwubWF4KHR1aS51dGlsLm1hcChhcnIyZCwgZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnIubGVuZ3RoO1xuICAgIH0pKTtcbiAgICB2YXIgaW5kZXg7XG5cbiAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoYXJyMmQsIGZ1bmN0aW9uKGFycikge1xuICAgICAgICBmb3IoaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2luZGV4XS5wdXNoKGFycltpbmRleF0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IGxlbmd0aCBhZnRlciBkZWNpbWFsIHBvaW50LlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IHZhbHVlIHRhcmdldCB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gcmVzdWx0IGxlbmd0aFxuICovXG52YXIgZ2V0RGVjaW1hbExlbmd0aCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHZhbHVlQXJyID0gU3RyaW5nKHZhbHVlKS5zcGxpdCgnLicpO1xuICAgIHJldHVybiB2YWx1ZUFyci5sZW5ndGggPT09IDIgPyB2YWx1ZUFyclsxXS5sZW5ndGggOiAwO1xufTtcblxuLyoqXG4gKiBGaW5kIG11bHRpcGxlIG51bS5cbiAqIEBwYXJhbSB7Li4uQXJyYXl9IHRhcmdldCB2YWx1ZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG11bHRpcGxlIG51bVxuICovXG52YXIgZmluZE11bHRpcGxlTnVtID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgIHVuZGVyUG9pbnRMZW5zID0gdHVpLnV0aWwubWFwKGFyZ3MsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwuZ2V0RGVjaW1hbExlbmd0aCh2YWx1ZSk7XG4gICAgICAgIH0pLFxuICAgICAgICB1bmRlclBvaW50TGVuID0gdHVpLnV0aWwubWF4KHVuZGVyUG9pbnRMZW5zKSxcbiAgICAgICAgbXVsdGlwbGVOdW0gPSBNYXRoLnBvdygxMCwgdW5kZXJQb2ludExlbik7XG4gICAgcmV0dXJuIG11bHRpcGxlTnVtO1xufTtcblxuLyoqXG4gKiBNb2R1bG8gb3BlcmF0aW9uIGZvciBmbG9hdGluZyBwb2ludCBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0IHRhcmdldCB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2ROdW0gbW9kIG51bVxuICogQHJldHVybnMge251bWJlcn0gcmVzdWx0IG1vZFxuICovXG52YXIgbW9kID0gZnVuY3Rpb24odGFyZ2V0LCBtb2ROdW0pIHtcbiAgICB2YXIgbXVsdGlwbGVOdW0gPSB0dWkudXRpbC5maW5kTXVsdGlwbGVOdW0obW9kTnVtKTtcbiAgICByZXR1cm4gKCh0YXJnZXQgKiBtdWx0aXBsZU51bSkgJSAobW9kTnVtICogbXVsdGlwbGVOdW0pKSAvIG11bHRpcGxlTnVtO1xufTtcblxuLyoqXG4gKiBBZGRpdGlvbiBmb3IgZmxvYXRpbmcgcG9pbnQgb3BlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGEgdGFyZ2V0IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIHRhcmdldCBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhZGRpdGlvbiByZXN1bHRcbiAqL1xudmFyIGFkZGl0aW9uID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBtdWx0aXBsZU51bSA9IGZpbmRNdWx0aXBsZU51bShhLCBiKTtcbiAgICByZXR1cm4gKChhICogbXVsdGlwbGVOdW0pICsgKGIgKiBtdWx0aXBsZU51bSkpIC8gbXVsdGlwbGVOdW07XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0aW9uIGZvciBmbG9hdGluZyBwb2ludCBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gYSB0YXJnZXQgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgdGFyZ2V0IGJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHN1YnRyYWN0aW9uIHJlc3VsdFxuICovXG52YXIgc3VidHJhY3Rpb24gPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIG11bHRpcGxlTnVtID0gZmluZE11bHRpcGxlTnVtKGEsIGIpO1xuICAgIHJldHVybiAoKGEgKiBtdWx0aXBsZU51bSkgLSAoYiAqIG11bHRpcGxlTnVtKSkgLyBtdWx0aXBsZU51bTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGljYXRpb24gZm9yIGZsb2F0aW5nIHBvaW50IG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhIHRhcmdldCBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiB0YXJnZXQgYlxuICogQHJldHVybnMge251bWJlcn0gbXVsdGlwbGljYXRpb24gcmVzdWx0XG4gKi9cbnZhciBtdWx0aXBsaWNhdGlvbiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgbXVsdGlwbGVOdW0gPSBmaW5kTXVsdGlwbGVOdW0oYSwgYik7XG4gICAgcmV0dXJuICgoYSAqIG11bHRpcGxlTnVtKSAqIChiICogbXVsdGlwbGVOdW0pKSAvIChtdWx0aXBsZU51bSAqIG11bHRpcGxlTnVtKTtcbn07XG5cbi8qKlxuICogRGl2aXNpb24gZm9yIGZsb2F0aW5nIHBvaW50IG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhIHRhcmdldCBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiB0YXJnZXQgYlxuICogQHJldHVybnMge251bWJlcn0gZGl2aXNpb24gcmVzdWx0XG4gKi9cbnZhciBkaXZpc2lvbiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgbXVsdGlwbGVOdW0gPSBmaW5kTXVsdGlwbGVOdW0oYSwgYik7XG4gICAgcmV0dXJuIChhICogbXVsdGlwbGVOdW0pIC8gKGIgKiBtdWx0aXBsZU51bSk7XG59O1xuXG4vKipcbiAqIFN1bS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlcyB0YXJnZXQgdmFsdWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByZXN1bHQgdmFsdWVcbiAqL1xudmFyIHN1bSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHZhciBjb3B5QXJyID0gdmFsdWVzLnNsaWNlKCk7XG4gICAgY29weUFyci51bnNoaWZ0KDApO1xuICAgIHJldHVybiB0dWkudXRpbC5yZWR1Y2UoY29weUFyciwgZnVuY3Rpb24oYmFzZSwgYWRkKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5hZGRpdGlvbihwYXJzZUZsb2F0KGJhc2UpLCBwYXJzZUZsb2F0KGFkZCkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBQcm9wZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHN0cmluZyB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xudmFyIHByb3BlckNhc2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSArIHZhbHVlLnN1YnN0cmluZygxKTtcbn07XG5cbi8qKlxuICogRGVlcCBjb3B5LlxuICogQHBhcmFtIHtvYmplY3R8QXJyYXl8Kn0gb3JpZ2luIC0gb3JpZ2luYWwgZGF0YVxuICogQHJldHVybnMgeyp9XG4gKi9cbnZhciBkZWVwQ29weSA9IGZ1bmN0aW9uKG9yaWdpbikge1xuICAgIHZhciBjbG9uZTtcblxuICAgIGlmICh0dWkudXRpbC5pc0FycmF5KG9yaWdpbikpIHtcbiAgICAgICAgY2xvbmUgPSBbXTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KG9yaWdpbiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgY2xvbmVbaW5kZXhdID0gZGVlcENvcHkodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR1aS51dGlsLmlzRnVuY3Rpb24ob3JpZ2luKSkge1xuICAgICAgICBjbG9uZSA9IG9yaWdpbjtcbiAgICB9IGVsc2UgaWYgKHR1aS51dGlsLmlzT2JqZWN0KG9yaWdpbikpIHtcbiAgICAgICAgY2xvbmUgPSB7fTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChvcmlnaW4sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGNsb25lW2tleV0gPSBkZWVwQ29weSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb25lID0gb3JpZ2luO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbn07XG5cbnR1aS51dGlsLm1pbiA9IG1pbjtcbnR1aS51dGlsLm1heCA9IG1heDtcbnR1aS51dGlsLmFueSA9IGFueTtcbnR1aS51dGlsLmFsbCA9IGFsbDtcbnR1aS51dGlsLnVuaXF1ZSA9IHVuaXF1ZTtcbnR1aS51dGlsLnBpdm90ID0gcGl2b3Q7XG50dWkudXRpbC5nZXREZWNpbWFsTGVuZ3RoID0gZ2V0RGVjaW1hbExlbmd0aDtcbnR1aS51dGlsLm1vZCA9IG1vZDtcbnR1aS51dGlsLmZpbmRNdWx0aXBsZU51bSA9IGZpbmRNdWx0aXBsZU51bTtcbnR1aS51dGlsLmFkZGl0aW9uID0gYWRkaXRpb247XG50dWkudXRpbC5zdWJ0cmFjdGlvbiA9IHN1YnRyYWN0aW9uO1xudHVpLnV0aWwubXVsdGlwbGljYXRpb24gPSBtdWx0aXBsaWNhdGlvbjtcbnR1aS51dGlsLmRpdmlzaW9uID0gZGl2aXNpb247XG50dWkudXRpbC5zdW0gPSBzdW07XG50dWkudXRpbC5wcm9wZXJDYXNlID0gcHJvcGVyQ2FzZTtcbnR1aS51dGlsLmRlZXBDb3B5ID0gZGVlcENvcHk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hhcnQgY29uc3RcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBuby1tYWdpYy1udW1iZXJzOiAwKi9cblxuLyoqXG4gKiBDaGFydCBjb25zdFxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG52YXIgY2hhcnRDb25zdCA9IHtcbiAgICAvKiogdHVpIGNsYXNzIG5hbWVzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBDTEFTU19OQU1FX0xFR0VORF9MQUJFTDogJ3R1aS1jaGFydC1sZWdlbmQtbGFiZWwnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENMQVNTX05BTUVfTEVHRU5EX0NIRUNLQk9YOiAndHVpLWNoYXJ0LWxlZ2VuZC1jaGVja2JveCcsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0xBU1NfTkFNRV9TRVJJRVNfTEFCRUw6ICd0dWktY2hhcnQtc2VyaWVzLWxhYmVsJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDTEFTU19OQU1FX1NFUklFU19MRUdFTkQ6ICd0dWktY2hhcnQtc2VyaWVzLWxlZ2VuZCcsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0xBU1NfTkFNRV9SRVNFVF9aT09NX0JUTjogJ3R1aS1jaGFydC1yZXNldC16b29tLWJ0bicsXG4gICAgLyoqIGNoYXJ0IHR5cGVzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBDSEFSVF9UWVBFX0JBUjogJ2JhcicsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0hBUlRfVFlQRV9DT0xVTU46ICdjb2x1bW4nLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENIQVJUX1RZUEVfTElORTogJ2xpbmUnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENIQVJUX1RZUEVfQVJFQTogJ2FyZWEnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENIQVJUX1RZUEVfQ09NQk86ICdjb21ibycsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0hBUlRfVFlQRV9DT0xVTU5fTElORV9DT01CTzogJ2NvbHVtbkxpbmVDb21ibycsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0hBUlRfVFlQRV9MSU5FX0FSRUFfQ09NQk86ICdsaW5lQXJlYUNvbWJvJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX1BJRV9ET05VVF9DT01CTzogJ3BpZURvbnV0Q29tYm8nLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENIQVJUX1RZUEVfUElFOiAncGllJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX0JVQkJMRTogJ2J1YmJsZScsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0hBUlRfVFlQRV9TQ0FUVEVSOiAnc2NhdHRlcicsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0hBUlRfVFlQRV9IRUFUTUFQOiAnaGVhdG1hcCcsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0hBUlRfVFlQRV9UUkVFTUFQOiAndHJlZW1hcCcsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0hBUlRfVFlQRV9NQVA6ICdtYXAnLFxuICAgIC8qKiBjaGFydCBwYWRkaW5nICovXG4gICAgQ0hBUlRfUEFERElORzogMTAsXG4gICAgLyoqIGNoYXJ0IGRlZmF1bHQgd2lkdGggKi9cbiAgICBDSEFSVF9ERUZBVUxUX1dJRFRIOiA1MDAsXG4gICAgLyoqIGNoYXJ0IGRlZmF1bHQgaGVpZ2h0ICovXG4gICAgQ0hBUlRfREVGQVVMVF9IRUlHSFQ6IDQwMCxcbiAgICAvKiogb3ZlcmxhcHBpbmcgd2lkdGggb2YgeEF4aXMgYW5kIHlBeGlzICovXG4gICAgT1ZFUkxBUFBJTkdfV0lEVEg6IDEsXG4gICAgLyoqIHJlbmRlcmVkIHRleHQgcGFkZGluZyAqL1xuICAgIFRFWFRfUEFERElORzogMixcbiAgICAvKiogc2VyaWVzIGV4cGFuZCBzaXplICovXG4gICAgU0VSSUVTX0VYUEFORF9TSVpFOiAxMCxcbiAgICAvKiogc2VyaWVzIGxhYmVsIHBhZGRpbmcgKi9cbiAgICBTRVJJRVNfTEFCRUxfUEFERElORzogNSxcbiAgICAvKiogZGVmYXVsdCBmb250IHNpemUgb2YgdGl0bGUgKi9cbiAgICBERUZBVUxUX1RJVExFX0ZPTlRfU0laRTogMTQsXG4gICAgLyoqIGRlZmF1bHQgZm9udCBzaXplIG9mIGF4aXMgdGl0bGUgKi9cbiAgICBERUZBVUxUX0FYSVNfVElUTEVfRk9OVF9TSVpFOiAxMCxcbiAgICAvKiogZGVmYXVsdCBmb250IHNpemUgb2YgbGFiZWwgKi9cbiAgICBERUZBVUxUX0xBQkVMX0ZPTlRfU0laRTogMTIsXG4gICAgLyoqIGRlZmF1bHQgZm9udCBzaXplIG9mIHNlcmllcyBsYWJlbCAqL1xuICAgIERFRkFVTFRfU0VSSUVTX0xBQkVMX0ZPTlRfU0laRTogMTEsXG4gICAgLyoqIGRlZmF1bHQgZ3JhcGggcGx1Z2luXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBERUZBVUxUX1BMVUdJTjogJ3JhcGhhZWwnLFxuICAgIC8qKiBkZWZhdWx0IHRpY2sgY29sb3JcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIERFRkFVTFRfVElDS19DT0xPUjogJ2JsYWNrJyxcbiAgICAvKiogZGVmYXVsdCB0aGVtZSBuYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBERUZBVUxUX1RIRU1FX05BTUU6ICdkZWZhdWx0JyxcbiAgICBNQVhfSEVJR0hUX1dPUkxEOiAnQScsXG4gICAgLyoqIHN0YWNrIHR5cGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIE5PUk1BTF9TVEFDS19UWVBFOiAnbm9ybWFsJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBQRVJDRU5UX1NUQUNLX1RZUEU6ICdwZXJjZW50JyxcbiAgICAvKiogZGVmYXVsdCBzdGFja1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgREVGQVVMVF9TVEFDSzogJ19fX0RFRkFVTFRfX19TVEFDS19fXycsXG4gICAgLyoqIGR1bW15IGtleVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgRFVNTVlfS0VZOiAnX19fRFVNTVlfX19LRVlfX18nLFxuICAgIC8qKiByb290IGlkIG9mIHRyZWVtYXBcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIFRSRUVNQVBfUk9PVF9JRDogJ19fX1RVSV9UUkVFTUFQX1JPT1RfX18nLFxuICAgIC8qKiBpZCBwcmVmaXggb2YgdHJlZW1hcFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgVFJFRU1BUF9JRF9QUkVGSVg6ICdfX19UVUlfVFJFRU1BUF9JRF9fXycsXG4gICAgLyoqIHByZWZpeCBmb3IgY2FjaGluZyBzZXJpZXNJdGVtc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgVFJFRU1BUF9ERVBUSF9LRVlfUFJFRklYOiAnX19fVFVJX1RSRUVNQVBfREVQVEhfX18nLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIFRSRUVNQVBfUEFSRU5UX0tFWV9QUkVGSVg6ICdfX19UVUlfVFJFRU1BUF9QQVJFTlRfX18nLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIFRSRUVNQVBfTEVBRl9LRVlfUFJFRklYOiAnX19fVFVJX1RSRUVNQVBfTEVBRl9fXycsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgVFJFRU1BUF9MSU1JVF9ERVBUSF9LRVlfUFJFRklYOiAnX19fVFVJX1RSRUVNQVBfTElNSVRfREVQVEhfX18nLFxuICAgIC8qKiBkZWZhdWx0IGJvcmRlciBjb2xvciBmb3IgdHJlZW1hcCBjaGFydFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgVFJFRU1BUF9ERUZBVUxUX0JPUkRFUjogJyNjY2MnLFxuICAgIC8qKiBlbXB0eSBheGlzIGxhYmVsICovXG4gICAgRU1QVFlfQVhJU19MQUJFTDogJycsXG4gICAgLyoqIGFuZ2VsICovXG4gICAgQU5HTEVfODU6IDg1LFxuICAgIEFOR0xFXzkwOiA5MCxcbiAgICBBTkdMRV8zNjA6IDM2MCxcbiAgICAvKiogcmFkaWFuICovXG4gICAgUkFEOiBNYXRoLlBJIC8gMTgwLFxuICAgIFJFUkVOREVSX1RJTUU6IDcwMCxcbiAgICAvKiogc2VyaWVzIGxhYmVsIGFsaWduIG91dGVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBMQUJFTF9BTElHTl9PVVRFUjogJ291dGVyJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBMRUdFTkRfQUxJR05fVE9QOiAndG9wJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBMRUdFTkRfQUxJR05fQk9UVE9NOiAnYm90dG9tJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBMRUdFTkRfQUxJR05fTEVGVDogJ2xlZnQnLFxuICAgIC8qKiBzZXJpZXMgb3V0ZXIgbGFiZWwgcGFkZGluZyAqL1xuICAgIFNFUklFU19PVVRFUl9MQUJFTF9QQURESU5HOiAyMCxcbiAgICAvKiogZGVmYXVsdCByYXRpbyBmb3IgcGllIGdyYXBoICovXG4gICAgUElFX0dSQVBIX0RFRkFVTFRfUkFUSU86IDAuOCxcbiAgICAvKiogc21hbGwgcmF0aW8gZm9yIHBpZSBncmFwaCAqL1xuICAgIFBJRV9HUkFQSF9TTUFMTF9SQVRJTzogMC42NSxcbiAgICAvKiogdGljayBjb3VudCBmb3Igc3BlY3RydW0gbGVnZW5kICovXG4gICAgU1BFQ1RSVU1fTEVHRU5EX1RJQ0tfQ09VTlQ6IDQsXG4gICAgLyoqIGRlZmF1bHQgcG9zaXRpb24gcmF0aW8gb2YgbWFwIGNoYXJ0IGxhYmVsXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICBNQVBfQ0hBUlRfTEFCRUxfREVGQVVMVF9QT1NJVElPTl9SQVRJTzoge1xuICAgICAgICB4OiAwLjUsXG4gICAgICAgIHk6IDAuNVxuICAgIH0sXG4gICAgLyoqIGRvdCByYWRpdXMgKi9cbiAgICBET1RfUkFESVVTOiA0LFxuICAgIC8qKiByYWRpdXMgZm9yIGNpcmNsZSBvZiBzY2F0dGVyIGNoYXJ0Ki9cbiAgICBTQ0FUVEVSX1JBRElVUzogNSxcbiAgICAvKiogeUF4aXMgcHJvcGVydGllc1xuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBZQVhJU19QUk9QUzogWyd0aWNrQ29sb3InLCAndGl0bGUnLCAnbGFiZWwnXSwgLy8geWF4aXMgdGhlbWXsnZgg7IaN7ISxIC0gY2hhcnQgdHlwZSBmaWx0ZXJpbmftlaAg65WMIOyCrOyaqeuQqFxuICAgIC8qKiBzZXJpZXMgcHJvcGVydGllc1xuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBTRVJJRVNfUFJPUFM6IFsnbGFiZWwnLCAnY29sb3JzJywgJ2JvcmRlckNvbG9yJywgJ3NpbmdsZUNvbG9ycycsXG4gICAgICAgICdzZWxlY3Rpb25Db2xvcicsICdzdGFydENvbG9yJywgJ2VuZENvbG9yJywgJ292ZXJDb2xvciddLCAvLyBzZXJpZXMgdGhlbWXsnZgg7IaN7ISxIC0gY2hhcnQgdHlwZSBmaWx0ZXJpbmftlaAg65WMIOyCrOyaqeuQqFxuICAgIC8qKiB0aXRsZSBhcmVhIHdpZHRoIHBhZGRpbmcgKi9cbiAgICBUSVRMRV9BUkVBX1dJRFRIX1BBRERJTkc6IDIwLFxuICAgIC8qKiB0b3AgbWFyZ2luIG9mIHggYXhpcyBsYWJlbCAqL1xuICAgIFhBWElTX0xBQkVMX1RPUF9NQVJHSU46IDEwLFxuICAgIC8qKiByaWdodCBwYWRkaW5nIG9mIHZlcnRpY2FsIGxhYmVsICovXG4gICAgVl9MQUJFTF9SSUdIVF9QQURESU5HOiAxMCxcbiAgICAvKiogdG9vbHRpcCBwcmVmaXhcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIFRPT0xUSVBfUFJFRklYOiAndHVpLWNoYXJ0LXRvb2x0aXAnLFxuICAgIC8qKiB0b29sdGlwIHotaW5kZXggKiovXG4gICAgVE9PTFRJUF9aSU5ERVg6IDUwMCxcbiAgICAvKiogdG9vbHRpcCBhbmltYXRpb24gdGltZSAqL1xuICAgIFRPT0xUSVBfQU5JTUFUSU9OX1RJTUU6IDEwMCxcbiAgICAvKiogdG9vbHRpcCBhbmltYXRpb24gdGltZSBmb3IgcGllIGNoYXJ0ICovXG4gICAgVE9PTFRJUF9QSUVfQU5JTUFUSU9OX1RJTUU6IDUwLFxuICAgIC8qKiBtaW5pbXVtIHBpeGVsIHR5cGUgc3RlcCBzaXplICovXG4gICAgTUlOX1BJWEVMX1RZUEVfU1RFUF9TSVpFOiA0NSxcbiAgICAvKiogbWF4aW11bSBwaXhlbCB0eXBlIHN0ZXAgc2l6ZSAqL1xuICAgIE1BWF9QSVhFTF9UWVBFX1NURVBfU0laRTogNjUsXG4gICAgLyoqIGF4aXMgc2NhbGUgZm9yIHBlcmNlbnQgc3RhY2sgb3B0aW9uXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICBQRVJDRU5UX1NUQUNLRURfQVhJU19TQ0FMRToge1xuICAgICAgICBsaW1pdDoge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAxMDBcbiAgICAgICAgfSxcbiAgICAgICAgc3RlcDogMjUsXG4gICAgICAgIGxhYmVsczogWzAsIDI1LCA1MCwgNzUsIDEwMF1cbiAgICB9LFxuICAgIC8qKiBheGlzIHNjYWxlIGZvciBtaW51cyBwZXJjZW50IHN0YWNrIG9wdGlvblxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgTUlOVVNfUEVSQ0VOVF9TVEFDS0VEX0FYSVNfU0NBTEU6IHtcbiAgICAgICAgbGltaXQ6IHtcbiAgICAgICAgICAgIG1pbjogLTEwMCxcbiAgICAgICAgICAgIG1heDogMFxuICAgICAgICB9LFxuICAgICAgICBzdGVwOiAyNSxcbiAgICAgICAgbGFiZWxzOiBbMCwgLTI1LCAtNTAsIC03NSwgLTEwMF1cbiAgICB9LFxuICAgIC8qKiBheGlzIHNjYWxlIG9mIGR1YWwgcGVyY2VudCBzdGFjayBvcHRpb25cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIERVQUxfUEVSQ0VOVF9TVEFDS0VEX0FYSVNfU0NBTEU6IHtcbiAgICAgICAgbGltaXQ6IHtcbiAgICAgICAgICAgIG1pbjogLTEwMCxcbiAgICAgICAgICAgIG1heDogMTAwXG4gICAgICAgIH0sXG4gICAgICAgIHN0ZXA6IDI1LFxuICAgICAgICBsYWJlbHM6IFstMTAwLCAtNzUsIC01MCwgLTI1LCAwLCAyNSwgNTAsIDc1LCAxMDBdXG4gICAgfSxcbiAgICAvKiogYXhpcyBzY2FsZSBvZiBkaXZlcmdpbmcgcGVyY2VudCBzdGFjayBvcHRpb25cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIERJVkVSR0lOR19QRVJDRU5UX1NUQUNLRURfQVhJU19TQ0FMRToge1xuICAgICAgICBsaW1pdDoge1xuICAgICAgICAgICAgbWluOiAtMTAwLFxuICAgICAgICAgICAgbWF4OiAxMDBcbiAgICAgICAgfSxcbiAgICAgICAgc3RlcDogMjUsXG4gICAgICAgIGxhYmVsczogWzEwMCwgNzUsIDUwLCAyNSwgMCwgMjUsIDUwLCA3NSwgMTAwXVxuICAgIH0sXG4gICAgLyoqIHRpdGxlIGFkZCBwYWRkaW5nICovXG4gICAgVElUTEVfUEFERElORzogMTAsXG4gICAgLyoqIGxlZ2VuZCBhcmVhIHBhZGRpbmcgKi9cbiAgICBMRUdFTkRfQVJFQV9QQURESU5HOiAxMCxcbiAgICAvKiogbGVnZW5kIGNoZWNrYm94IHdpZHRoICovXG4gICAgTEVHRU5EX0NIRUNLQk9YX1dJRFRIOiAyMCxcbiAgICAvKiogbGVnZW5kIHJlY3Qgd2lkdGggKi9cbiAgICBMRUdFTkRfUkVDVF9XSURUSDogMTIsXG4gICAgLyoqIGxnZW5kIGxhYmVsIGxlZnQgcGFkZGluZyAqL1xuICAgIExFR0VORF9MQUJFTF9MRUZUX1BBRERJTkc6IDUsXG4gICAgTUlOX0xFR0VORF9XSURUSDogMTAwLFxuICAgIC8qKiBtYXAgbGVnZW5kIGhlaWdodCAqL1xuICAgIE1BUF9MRUdFTkRfU0laRTogMjAwLFxuICAgIC8qKiBtYXAgbGVnZW5kIGdyYXBoIHNpemUgKi9cbiAgICBNQVBfTEVHRU5EX0dSQVBIX1NJWkU6IDI1LFxuICAgIC8qKiBtYXAgbGVnZW5kIGxhYmVsIHBhZGRpbmcgKi9cbiAgICBNQVBfTEVHRU5EX0xBQkVMX1BBRERJTkc6IDUsXG4gICAgQ0lSQ0xFX0xFR0VORF9MQUJFTF9GT05UX1NJWkU6IDksXG4gICAgQ0lSQ0xFX0xFR0VORF9QQURESU5HOiAxMCxcbiAgICBIQUxGX1JBVElPOiAwLjUsXG4gICAgLyoqIEFYSVMgTEFCRUwgUEFERElORyAqL1xuICAgIEFYSVNfTEFCRUxfUEFERElORzogNyxcbiAgICAvKiogcm90YXRpb25zIGRlZ3JlZSBjYW5kaWRhdGVzICovXG4gICAgREVHUkVFX0NBTkRJREFURVM6IFsyNSwgNDUsIDY1LCA4NV0sXG4gICAgLyoqXG4gICAgICogYXV0byB0aWNrIGludGVydmFsXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBUSUNLX0lOVEVSVkFMX0FVVE86ICdhdXRvJyxcbiAgICAvKiogeUF4aXMgYWxpZ24gb3B0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBZQVhJU19BTElHTl9DRU5URVI6ICdjZW50ZXInLFxuICAgIC8qKiB4QXhpcyBsYWJlbCBjb21wYXJlIG1hcmdpbiAqL1xuICAgIFhBWElTX0xBQkVMX0NPTVBBUkVfTUFSR0lOOiAyMCxcbiAgICAvKiogeEF4aXMgbGFiZWwgZ3V0dGVyICovXG4gICAgWEFYSVNfTEFCRUxfR1VUVEVSOiAyLFxuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIG11bHRpcGxlIG51bXMgb2YgYXhpc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBBWElTX1NUQU5EQVJEX01VTFRJUExFX05VTVM6IFsxLCAyLCA1LCAxMCwgMjAsIDUwLCAxMDBdLFxuICAgIC8qKlxuICAgICAqIExhc3Qgc3RhbmRhcmQgbXVsdGlwbGUgbnVtIG9mIGF4aXNcbiAgICAgKi9cbiAgICBBWElTX0xBU1RfU1RBTkRBUkRfTVVMVElQTEVfTlVNOiAxMDAsXG4gICAgLyoqIGxhYmVsIHBhZGRpbmcgdG9wICovXG4gICAgTEFCRUxfUEFERElOR19UT1A6IDIsXG4gICAgLyoqIGxpbmUgbWFyZ2luIHRvcCAqL1xuICAgIExJTkVfTUFSR0lOX1RPUDogNSxcbiAgICAvKiogdG9vbHRpcCBnYXAgKi9cbiAgICBUT09MVElQX0dBUDogNSxcbiAgICAvKiogdG9vbHRpcCBkaXJlY3Rpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIFRPT0xUSVBfRElSRUNUSU9OX0ZPUldBUkQ6ICdmb3J3b3JkJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBUT09MVElQX0RJUkVDVElPTl9DRU5URVI6ICdjZW50ZXInLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIFRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJEOiAnYmFja3dvcmQnLFxuICAgIC8qKiB0b29sdGlwIGFsaWduIG9wdGlvbnNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIFRPT0xUSVBfREVGQVVMVF9BTElHTl9PUFRJT046ICdjZW50ZXIgdG9wJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBUT09MVElQX0RFRkFVTFRfSE9SSVpPTlRBTF9BTElHTl9PUFRJT046ICdyaWdodCBtaWRkbGUnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIFRPT0xUSVBfREVGQVVMVF9HUk9VUF9BTElHTl9PUFRJT046ICdyaWdodCBtaWRkbGUnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIFRPT0xUSVBfREVGQVVMVF9HUk9VUF9IT1JJWk9OVEFMX0FMSUdOX09QVElPTjogJ2NlbnRlciBib3R0b20nLFxuICAgIC8qKiBoaWRlIGRlbGF5ICovXG4gICAgSElERV9ERUxBWTogMjAwLFxuICAgIE9MRF9CUk9XU0VSX09QQUNJVFlfMTAwOiAxMDAsXG4gICAgU0VSSUVTX0xBQkVMX09QQUNJVFk6IDAuMyxcbiAgICBXSEVFTF9USUNLOiAxMjAsXG4gICAgTUFYX1pPT01fTUFHTjogMzIsXG4gICAgRkZfV0hFRUxERUxUQV9BREpVU1RJTkdfVkFMVUU6IC00MCxcbiAgICBJRTdfUk9UQVRJT05fRklMVEVSX1NUWUxFX01BUDoge1xuICAgICAgICAyNTogJyBzdHlsZT1cImZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChTaXppbmdNZXRob2Q9XFwnYXV0byBleHBhbmRcXCcsJyArXG4gICAgICAgICAgICAgICAgJyBNMTE9MC45MDYzMDc3ODcwMzY2NDk5LCBNMTI9MC40MjI2MTgyNjE3NDA2OTk0NCwgTTIxPS0wLjQyMjYxODI2MTc0MDY5OTQ0LCBNMjI9MC45MDYzMDc3ODcwMzY2NDk5KVwiJyxcbiAgICAgICAgNDU6ICcgc3R5bGU9XCJmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoU2l6aW5nTWV0aG9kPVxcJ2F1dG8gZXhwYW5kXFwnLCcgK1xuICAgICAgICAgICAgICAgICcgTTExPTAuNzA3MTA2NzgxMTg2NTQ3NiwgTTEyPTAuNzA3MTA2NzgxMTg2NTQ3NSwgTTIxPS0wLjcwNzEwNjc4MTE4NjU0NzUsIE0yMj0wLjcwNzEwNjc4MTE4NjU0NzYpXCInLFxuICAgICAgICA2NTogJyBzdHlsZT1cImZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChTaXppbmdNZXRob2Q9XFwnYXV0byBleHBhbmRcXCcsJyArXG4gICAgICAgICAgICAgICAgJyBNMTE9MC40MjI2MTgyNjE3NDA2OTk0NCwgTTEyPTAuOTA2MzA3Nzg3MDM2NjQ5OSwgTTIxPS0wLjkwNjMwNzc4NzAzNjY0OTksIE0yMj0wLjQyMjYxODI2MTc0MDY5OTQ0KVwiJyxcbiAgICAgICAgODU6ICcgc3R5bGU9XCJmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoU2l6aW5nTWV0aG9kPVxcJ2F1dG8gZXhwYW5kXFwnLCcgK1xuICAgICAgICAgICAgICAgICcgTTExPTAuMDg3MTU1NzQyNzQ3NjU4MTQsIE0xMj0wLjk5NjE5NDY5ODA5MTc0NTUsIE0yMT0tMC45OTYxOTQ2OTgwOTE3NDU1LCBNMjI9MC4wODcxNTU3NDI3NDc2NTgxNClcIidcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBjaGFydENvbnN0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFyZWFUeXBlQ3VzdG9tRXZlbnQgaXMgZXZlbnQgaGFuZGxlIGxheWVyIGZvciBsaW5lIHR5cGUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEN1c3RvbUV2ZW50QmFzZSA9IHJlcXVpcmUoJy4vY3VzdG9tRXZlbnRCYXNlJyk7XG52YXIgem9vbU1peGVyID0gcmVxdWlyZSgnLi96b29tTWl4ZXInKTtcbnZhciBBcmVhVHlwZURhdGFNb2RlbCA9IHJlcXVpcmUoJy4vYXJlYVR5cGVEYXRhTW9kZWwnKTtcblxudmFyIEFyZWFUeXBlQ3VzdG9tRXZlbnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDdXN0b21FdmVudEJhc2UsIC8qKiBAbGVuZHMgQXJlYVR5cGVDdXN0b21FdmVudC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEFyZWFUeXBlQ3VzdG9tRXZlbnQgaXMgY3VzdG9tIGV2ZW50IGZvciBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogQGNvbnN0cnVjdHMgQXJlYVR5cGVDdXN0b21FdmVudFxuICAgICAqIEBleHRlbmRzIEN1c3RvbUV2ZW50QmFzZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBDdXN0b21FdmVudEJhc2UuY2FsbCh0aGlzLCBwYXJhbXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmV2aW91cyBmb3VuZCBkYXRhXG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwgb2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2Rm91bmREYXRhID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9pbml0Rm9yWm9vbShwYXJhbXMuem9vbWFibGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGRhdGEgb2YgY3VzdG9tIGV2ZW50XG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gc2VyaWVzSW5mb3Mgc2VyaWVzIGluZm9zXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgaW5pdEN1c3RvbUV2ZW50RGF0YTogZnVuY3Rpb24oc2VyaWVzSW5mb3MpIHtcbiAgICAgICAgdmFyIHNlcmllc0luZm8gPSBzZXJpZXNJbmZvc1swXTtcblxuICAgICAgICB0aGlzLmRhdGFNb2RlbCA9IG5ldyBBcmVhVHlwZURhdGFNb2RlbChzZXJpZXNJbmZvKTtcbiAgICAgICAgQ3VzdG9tRXZlbnRCYXNlLnByb3RvdHlwZS5pbml0Q3VzdG9tRXZlbnREYXRhLmNhbGwodGhpcywgc2VyaWVzSW5mb3MpO1xuXG4gICAgICAgIHRoaXMuX3Nob3dUb29sdGlwQWZ0ZXJab29tKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgZGF0YSBieSBjbGllbnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFggLSBjbGllbnRYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFkgLSBjbGllbnRZXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kRGF0YTogZnVuY3Rpb24oY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgICB2YXIgbGF5ZXJQb3NpdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZUxheWVyUG9zaXRpb24oY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgIHZhciBncm91cEluZGV4ID0gdGhpcy50aWNrQmFzZUNvb3JkaW5hdGVNb2RlbC5maW5kSW5kZXgobGF5ZXJQb3NpdGlvbi54KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZmluZERhdGEoZ3JvdXBJbmRleCwgbGF5ZXJQb3NpdGlvbi55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGZpcnN0IG1vZGVsIGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEZpcnN0RGF0YTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEZpcnN0RGF0YShpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBsYXN0IG1vZGVsIGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExhc3REYXRhOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0TGFzdERhdGEoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZvdW5kRGF0YSAtIG1vZGVsIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93VG9vbHRpcDogZnVuY3Rpb24oZm91bmREYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd1Rvb2x0aXAnLCBmb3VuZERhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlkZVRvb2x0aXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2hpZGVUb29sdGlwJywgdGhpcy5wcmV2Rm91bmREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2Vtb3ZlLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGZvdW5kRGF0YTtcblxuICAgICAgICBDdXN0b21FdmVudEJhc2UucHJvdG90eXBlLl9vbk1vdXNlbW92ZS5jYWxsKHRoaXMsIGUpO1xuXG4gICAgICAgIGZvdW5kRGF0YSA9IHRoaXMuX2ZpbmREYXRhKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgICAgICBpZiAodGhpcy5faXNBZnRlckRyYWdNb3VzZXVwKCkgfHwgIXRoaXMuX2lzQ2hhbmdlZFNlbGVjdERhdGEodGhpcy5wcmV2Rm91bmREYXRhLCBmb3VuZERhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91bmREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9zaG93VG9vbHRpcChmb3VuZERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldkZvdW5kRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5faGlkZVRvb2x0aXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJldkZvdW5kRGF0YSA9IGZvdW5kRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2VvdXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXZGb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGVUb29sdGlwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBDdXN0b21FdmVudEJhc2UucHJvdG90eXBlLl9vbk1vdXNlb3V0LmNhbGwodGhpcyk7XG4gICAgfVxufSk7XG5cbnpvb21NaXhlci5taXhpbihBcmVhVHlwZUN1c3RvbUV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcmVhVHlwZUN1c3RvbUV2ZW50O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFyZWFUeXBlRGF0YU1vZGVsIGlzIGRhdGEgbW9kZWwgZm9yIGN1c3RvbSBldmVudCBvZiBhcmVhIHR5cGUuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEFyZWFUeXBlRGF0YU1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBBcmVhVHlwZURhdGFNb2RlbC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEFyZWFUeXBlRGF0YU1vZGVsIGlzIGRhdGEgbW9kZSBmb3IgY3VzdG9tIGV2ZW50IG9mIGFyZWEgdHlwZS5cbiAgICAgKiBAY29uc3RydWN0cyBBcmVhVHlwZURhdGFNb2RlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNJbmZvIHNlcmllcyBpbmZvXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oc2VyaWVzSW5mbykge1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLl9tYWtlRGF0YShzZXJpZXNJbmZvLmRhdGEuZ3JvdXBQb3NpdGlvbnMsIHNlcmllc0luZm8uY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBhcmVhIHR5cGUgZGF0YSBmb3IgY3VzdG9tIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gZ3JvdXBQb3NpdGlvbnMgLSBncm91cCBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlRGF0YTogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMsIGNoYXJ0VHlwZSkge1xuICAgICAgICBncm91cFBvc2l0aW9ucyA9IHR1aS51dGlsLnBpdm90KGdyb3VwUG9zaXRpb25zKTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGdyb3VwUG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbnMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAocG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRleDogZ3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib3VuZDogcG9zaXRpb25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIERhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggLSBncm91cCBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllclkgLSBtb3VzZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZmluZERhdGE6IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGxheWVyWSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCxcbiAgICAgICAgICAgIG1pbiA9IDEwMDAwO1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHRoaXMuZGF0YVtncm91cEluZGV4XSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhsYXllclkgLSBkYXRhLmJvdW5kLnRvcCk7XG4gICAgICAgICAgICBpZiAobWluID4gZGlmZikge1xuICAgICAgICAgICAgICAgIG1pbiA9IGRpZmY7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGZpcnN0IGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldEZpcnN0RGF0YTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVswXVtpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBsYXN0IGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldExhc3REYXRhOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgbGFzdEdyb3VwSW5kZXggPSB0aGlzLmRhdGEubGVuZ3RoIC0gMTtcblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2xhc3RHcm91cEluZGV4XVtpbmRleF07XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJlYVR5cGVEYXRhTW9kZWw7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQm91bmRzQmFzZUNvb3JkaW5hdGVNb2RlbCBpcyBkYXRhIG1vZGUgZm9yIGN1c3RvbSBldmVudCBvZiBwb2ludCB0eXBlLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogcG9zaXRpb25cbiAqIEB0eXBlZGVmIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBib3VuZFxuICogQHR5cGVkZWYge3tcbiAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICogICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAqfX0gYm91bmRcbiAqL1xuXG4vKipcbiAqIGdyb3VwIGJvdW5kXG4gKiAgQHR5cGVkZWYge0FycmF5LjxBcnJheS48Ym91bmQ+Pn0gZ3JvdXBCb3VuZFxuICovXG5cbi8qKlxuICogZ3JvdXAgcG9zaXRpb25cbiAqICBAdHlwZWRlZiB7QXJyYXkuPEFycmF5Ljxwb3NpdGlvbj4+fSBncm91cFBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBzZXJpZXMgaW5mb1xuICogQHR5cGVkZWYge3tcbiAqICAgICAgY2hhcnRUeXBlOiB7c3RyaW5nfSxcbiAqICAgICAgZGF0YToge1xuICogICAgICAgICAgZ3JvdXBCb3VuZHM6ID9ncm91cEJvdW5kLFxuICogICAgICAgICAgZ3JvdXBWYWx1ZXM6ID9BcnJheS48QXJyYXkuPG51bWJlcj4+LFxuICogICAgICAgICAgZ3JvdXBQb3NpdGlvbnM6ID9ncm91cFBvc2l0aW9uXG4gKiAgICAgIH1cbiAqfX0gc2VyaWVzSW5mb1xuICovXG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpO1xuXG52YXIgQm91bmRzQmFzZUNvb3JkaW5hdGVNb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgQm91bmRzQmFzZUNvb3JkaW5hdGVNb2RlbC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEJvdW5kc0Jhc2VDb29yZGluYXRlTW9kZWwgaXMgZGF0YSBtb2RlIGZvciBjdXN0b20gZXZlbnQgb2YgcG9pbnQgdHlwZS5cbiAgICAgKiBAY29uc3RydWN0cyBCb3VuZHNCYXNlQ29vcmRpbmF0ZU1vZGVsXG4gICAgICogQHBhcmFtIHtBcnJheS48c2VyaWVzSW5mbz59IHNlcmllc0luZm9zIHNlcmllcyBpbmZvc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHNlcmllc0luZm9zKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuX21ha2VEYXRhKHNlcmllc0luZm9zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjb29yZGluYXRlIGRhdGEgYWJvdXQgYmFyIHR5cGUgZ3JhcGhcbiAgICAgKiBAcGFyYW0ge2dyb3VwQm91bmR9IGdyb3VwQm91bmRzIGdyb3VwIGJvdW5kc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY29vcmRpbmF0ZSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVJlY3RUeXBlQ29vcmRpbmF0ZURhdGE6IGZ1bmN0aW9uKGdyb3VwQm91bmRzLCBjaGFydFR5cGUpIHtcbiAgICAgICAgdmFyIGFsbG93TmVnYXRpdmVUb29sdGlwID0gIXByZWRpY2F0ZS5pc0JveFR5cGVDaGFydChjaGFydFR5cGUpO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoZ3JvdXBCb3VuZHMsIGZ1bmN0aW9uKGJvdW5kcywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChib3VuZHMsIGZ1bmN0aW9uKF9ib3VuZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFfYm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYm91bmQgPSBfYm91bmQuZW5kO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZERhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZVRvb2x0aXA6IGFsbG93TmVnYXRpdmVUb29sdGlwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQ6IGJvdW5kXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBib3VuZC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogYm91bmQubGVmdCArIGJvdW5kLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBib3VuZC50b3AgKyBib3VuZC5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY29vcmRpbmF0ZSBkYXRhIGFib3V0IGRvdCB0eXBlIGdyYXBoXG4gICAgICogQHBhcmFtIHtncm91cFBvc2l0aW9uc30gZ3JvdXBQb3NpdGlvbnMgZ3JvdXAgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGNvb3JkaW5hdGUgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VEb3RUeXBlQ29vcmRpbmF0ZURhdGE6IGZ1bmN0aW9uKGdyb3VwUG9zaXRpb25zLCBjaGFydFR5cGUpIHtcbiAgICAgICAgaWYgKCFncm91cFBvc2l0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0dWkudXRpbC5waXZvdChncm91cFBvc2l0aW9ucyksIGZ1bmN0aW9uKHBvc2l0aW9ucywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmREYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib3VuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGNoYXJ0Q29uc3QuRE9UX1JBRElVUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wIC0gY2hhcnRDb25zdC5ET1RfUkFESVVTLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHBvc2l0aW9uLmxlZnQgKyBjaGFydENvbnN0LkRPVF9SQURJVVMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHBvc2l0aW9uLnRvcCArIGNoYXJ0Q29uc3QuRE9UX1JBRElVU1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSm9pbiBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxBcnJheS48b2JqZWN0Pj4+fSBncm91cERhdGEgZ3JvdXAgZGF0YVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBqb2luZWQgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2pvaW5EYXRhOiBmdW5jdGlvbihncm91cERhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGdyb3VwRGF0YSwgZnVuY3Rpb24oY29vcmREYXRhKSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY29vcmREYXRhLCBmdW5jdGlvbihkYXRhLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0c1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHRzW2luZGV4XS5jb25jYXQoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY29vcmRpbmF0ZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHNlcmllc0luZm8+fSBzZXJpZXNJbmZvcyBzZXJpZXMgaW5mb3NcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gY29vcmRpbmF0ZSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZURhdGE6IGZ1bmN0aW9uKHNlcmllc0luZm9zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVEYXRhO1xuXG4gICAgICAgIHNlcmllc0luZm9zLnJldmVyc2UoKTtcbiAgICAgICAgY29vcmRpbmF0ZURhdGEgPSB0dWkudXRpbC5tYXAoc2VyaWVzSW5mb3MsIGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLmlzTGluZVR5cGVDaGFydChpbmZvLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLl9tYWtlRG90VHlwZUNvb3JkaW5hdGVEYXRhKGluZm8uZGF0YS5ncm91cFBvc2l0aW9ucywgaW5mby5jaGFydFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLl9tYWtlUmVjdFR5cGVDb29yZGluYXRlRGF0YShpbmZvLmRhdGEuZ3JvdXBCb3VuZHMsIGluZm8uY2hhcnRUeXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5EYXRhKGNvb3JkaW5hdGVEYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBjYW5kaWRhdGVzLlxuICAgICAqIEBwYXJhbSB7e2JvdW5kOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXJ9fX0gZGF0YSBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxheWVyWCBsYXllclhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXJZIGxheWVyWVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e3NlbmREYXRhOiBvYmplY3R9Pn0gY2FuZGlkYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRDYW5kaWRhdGVzOiBmdW5jdGlvbihkYXRhLCBsYXllclgsIGxheWVyWSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwuZmlsdGVyKGRhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICB2YXIgYm91bmQgPSBkYXR1bSAmJiBkYXR1bS5ib3VuZCxcbiAgICAgICAgICAgICAgICBpbmNsdWRlZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVkWCwgaW5jbHVkZWRZO1xuXG4gICAgICAgICAgICBpZiAoYm91bmQpIHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlZFggPSBib3VuZC5sZWZ0IDw9IGxheWVyWCAmJiBib3VuZC5yaWdodCA+PSBsYXllclg7XG4gICAgICAgICAgICAgICAgaW5jbHVkZWRZID0gYm91bmQudG9wIDw9IGxheWVyWSAmJiBib3VuZC5ib3R0b20gPj0gbGF5ZXJZO1xuICAgICAgICAgICAgICAgIGluY2x1ZGVkID0gaW5jbHVkZWRYICYmIGluY2x1ZGVkWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGVkO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0b29sdGlwIGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggZ3JvdXAgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXJYIG1vdXNlIHBvc2l0aW9uIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXJZIG1vdXNlIHBvc2l0aW9uIHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0b29sdGlwIGRhdGFcbiAgICAgKi9cbiAgICBmaW5kRGF0YTogZnVuY3Rpb24oZ3JvdXBJbmRleCwgbGF5ZXJYLCBsYXllclkpIHtcbiAgICAgICAgdmFyIG1pbiA9IDEwMDAwLFxuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbCxcbiAgICAgICAgICAgIGNhbmRpZGF0ZXM7XG5cbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgLy8gbGF5ZXJYLCBsYXllclnrpbwg7Y+s7ZWo7ZWY64qUIGRhdGEg7LaU7LacXG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gdGhpcy5fZmluZENhbmRpZGF0ZXModGhpcy5kYXRhW2dyb3VwSW5kZXhdLCBsYXllclgsIGxheWVyWSk7XG5cbiAgICAgICAgICAgIC8vIOy2lOy2nOuQnCBkYXRhIOykkSB0b3DsnbQgbGF5ZXJZ7JmAIOqwgOyepSDqsIDquYzsmrQgZGF0YSDssL7slYTrgrTquLBcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjYW5kaWRhdGVzLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhsYXllclkgLSBkYXRhLnNlbmREYXRhLmJvdW5kLnRvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA+IGRpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGF0YS5zZW5kRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQm91bmRzQmFzZUNvb3JkaW5hdGVNb2RlbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBCb3VuZHNUeXBlQ3VzdG9tRXZlbnQgaXMgZXZlbnQgaGFuZGxlIGxheWVyIGZvciBib3VuZHMuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEN1c3RvbUV2ZW50QmFzZSA9IHJlcXVpcmUoJy4vY3VzdG9tRXZlbnRCYXNlJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcbnZhciBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKTtcblxudmFyIEJvdW5kc1R5cGVDdXN0b21FdmVudCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKEN1c3RvbUV2ZW50QmFzZSwgLyoqIEBsZW5kcyBCb3VuZHNUeXBlQ3VzdG9tRXZlbnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBCb3VuZHNUeXBlQ3VzdG9tRXZlbnQgaXMgZXZlbnQgaGFuZGxlIGxheWVyIGZvciBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgQm91bmRzVHlwZUN1c3RvbUV2ZW50XG4gICAgICogQGV4dGVuZHMgQ3VzdG9tRXZlbnRCYXNlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIEN1c3RvbUV2ZW50QmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmV2aW91cyBmb3VuZCBkYXRhXG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwgb2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2Rm91bmREYXRhID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogaGlzdG9yeSBhcnJheSBmb3IgdHJlZW1hcCBjaGFydC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuem9vbUhpc3RvcnkgPSBbLTFdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBidXR0b24gZm9yIHpvb20gaGlzdG9yeSBiYWNrXG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwgSFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhpc3RvcnlCYWNrQnRuID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSB0b29sdGlwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hpZGVUb29sdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcsIHRoaXMucHJldkZvdW5kRGF0YSk7XG4gICAgICAgIHRoaXMucHJldkZvdW5kRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3R5bGVDdXJzb3IoZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdHlsZSBjc3MgY3Vyc29yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzQ2hpbGQgLSB3aGV0aGVyIGhhcyBjaGlsZCBvciBub3RcbiAgICAgKi9cbiAgICBzdHlsZUN1cnNvcjogZnVuY3Rpb24oaGFzQ2hpbGQpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY3VzdG9tRXZlbnRDb250YWluZXI7XG4gICAgICAgIGlmIChoYXNDaGlsZCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2Vtb3ZlLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGZvdW5kRGF0YSA9IHRoaXMuX2ZpbmREYXRhRnJvbUJvdW5kc0Nvb3JkaW5hdGVNb2RlbCh0aGlzLmN1c3RvbUV2ZW50Q29udGFpbmVyLCBlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgIHZhciBzZXJpZXNJdGVtO1xuXG4gICAgICAgIGlmICghdGhpcy5faXNDaGFuZ2VkU2VsZWN0RGF0YSh0aGlzLnByZXZGb3VuZERhdGEsIGZvdW5kRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByZXZGb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGVUb29sdGlwKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXZGb3VuZERhdGEgPSBmb3VuZERhdGE7XG5cbiAgICAgICAgaWYgKCFmb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNUcmVlbWFwQ2hhcnQodGhpcy5jaGFydFR5cGUpKSB7XG4gICAgICAgICAgICBzZXJpZXNJdGVtID0gdGhpcy5fZ2V0U2VyaWVzSXRlbUJ5SW5kZXhlcyhmb3VuZERhdGEuaW5kZXhlcyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlQ3Vyc29yKHNlcmllc0l0ZW0uaGFzQ2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCdzaG93VG9vbHRpcCcsIGZvdW5kRGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb20gaGlzdG9yeSBiYWNrLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3pvb21IaXN0b3J5QmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuem9vbUhpc3RvcnlbdGhpcy56b29tSGlzdG9yeS5sZW5ndGggLSAyXTtcblxuICAgICAgICB0aGlzLnpvb21IaXN0b3J5LnBvcCgpO1xuICAgICAgICB0aGlzLmZpcmUoJ3pvb20nLCBpbmRleCk7XG5cbiAgICAgICAgaWYgKHRoaXMuem9vbUhpc3RvcnkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbUV2ZW50Q29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuaGlzdG9yeUJhY2tCdG4pO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5QmFja0J0biA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlcmllc0l0ZW0gYnkgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgLSBpbmRleGVzXG4gICAgICogQHJldHVybnMge1Nlcmllc0l0ZW19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U2VyaWVzSXRlbUJ5SW5kZXhlczogZnVuY3Rpb24oaW5kZXhlcykge1xuICAgICAgICB2YXIgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFNlcmllc0RhdGFNb2RlbChjaGFydENvbnN0LkNIQVJUX1RZUEVfVFJFRU1BUCk7XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc0RhdGFNb2RlbC5nZXRTZXJpZXNJdGVtKGluZGV4ZXMuZ3JvdXBJbmRleCwgaW5kZXhlcy5pbmRleCwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlbW92ZS5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICAgICAgdmFyIGZvdW5kRGF0YSwgc2VyaWVzSXRlbTtcblxuICAgICAgICBpZiAoIXByZWRpY2F0ZS5pc1RyZWVtYXBDaGFydCh0aGlzLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb20uaGFzQ2xhc3ModGFyZ2V0LCBjaGFydENvbnN0LkNMQVNTX05BTUVfUkVTRVRfWk9PTV9CVE4pKSB7XG4gICAgICAgICAgICB0aGlzLl9oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgdGhpcy5fem9vbUhpc3RvcnlCYWNrKCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvdW5kRGF0YSA9IHRoaXMuX2ZpbmREYXRhRnJvbUJvdW5kc0Nvb3JkaW5hdGVNb2RlbCh0YXJnZXQsIGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgICAgICBpZiAoZm91bmREYXRhKSB7XG4gICAgICAgICAgICBzZXJpZXNJdGVtID0gdGhpcy5fZ2V0U2VyaWVzSXRlbUJ5SW5kZXhlcyhmb3VuZERhdGEuaW5kZXhlcyk7XG5cbiAgICAgICAgICAgIGlmICghc2VyaWVzSXRlbS5oYXNDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnem9vbScsIGZvdW5kRGF0YS5pbmRleGVzLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZW91dC5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW91dDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgYm91bmQgPSB0aGlzLl9nZXRDb250YWluZXJCb3VuZCgpO1xuICAgICAgICB2YXIgY2xpZW50WCA9IGUuY2xpZW50WDtcbiAgICAgICAgdmFyIGNsaWVudFkgPSBlLmNsaWVudFk7XG5cbiAgICAgICAgaWYgKChib3VuZC5sZWZ0IDw9IGNsaWVudFgpICYmIChib3VuZC50b3AgPD0gY2xpZW50WSkgJiZcbiAgICAgICAgICAgIChib3VuZC5yaWdodCA+PSBjbGllbnRYKSAmJiAoYm91bmQuYm90dG9tID49IGNsaWVudFkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcmV2Rm91bmREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9oaWRlVG9vbHRpcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgQ3VzdG9tRXZlbnRCYXNlLnByb3RvdHlwZS5fb25Nb3VzZW91dC5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBhZnRlciB6b29tLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIHRhcmdldCBzZXJpZXNJdGVtXG4gICAgICovXG4gICAgb25BZnRlclpvb206IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5oaXN0b3J5QmFja0J0bikge1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5QmFja0J0biA9IGRvbS5jcmVhdGUoJ0RJVicsIGNoYXJ0Q29uc3QuQ0xBU1NfTkFNRV9SRVNFVF9aT09NX0JUTik7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlCYWNrQnRuLmlubmVySFRNTCA9ICc8IEJhY2snO1xuICAgICAgICAgICAgZG9tLmFwcGVuZCh0aGlzLmN1c3RvbUV2ZW50Q29udGFpbmVyLCB0aGlzLmhpc3RvcnlCYWNrQnRuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnpvb21IaXN0b3J5W3RoaXMuem9vbUhpc3RvcnkubGVuZ3RoIC0gMV0gIT09IGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnpvb21IaXN0b3J5LnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQm91bmRzVHlwZUN1c3RvbUV2ZW50O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEN1c3RvbUV2ZW50QmFzZSBpcyBiYXNlIGNsYXNzIGZvciBldmVudCBoYW5kbGUgbGF5ZXJzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUaWNrQmFzZUNvb3JkaW5hdGVNb2RlbCA9IHJlcXVpcmUoJy4vdGlja0Jhc2VDb29yZGluYXRlTW9kZWwnKTtcbnZhciBCb3VuZHNCYXNlQ29vcmRpbmF0ZU1vZGVsID0gcmVxdWlyZSgnLi9ib3VuZHNCYXNlQ29vcmRpbmF0ZU1vZGVsJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgZXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZXZlbnRMaXN0ZW5lcicpO1xudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG52YXIgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgQ3VzdG9tRXZlbnRCYXNlID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBDdXN0b21FdmVudEJhc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBDdXN0b21FdmVudEJhc2UgaXMgYmFzZSBjbGFzcyBmb3IgY3VzdG9tIGV2ZW50IGNvbXBvbmVudHMuXG4gICAgICogQGNvbnN0cnVjdHMgQ3VzdG9tRXZlbnRCYXNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tcbiAgICAgKiAgICAgICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqICAgICAgfX0gcGFyYW1zLmJvdW5kIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpc0xpbmVUeXBlQ2hhcnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHR5cGUgb2YgY2hhcnRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gcGFyYW1zLmNoYXJ0VHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhcnRUeXBlcyBpcyBhdmFpbGFibGUgaW4gY29tYm8gY2hhcnRcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGVzID0gcGFyYW1zLmNoYXJ0VHlwZXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1ZlcnRpY2FsID0gcGFyYW1zLmlzVmVydGljYWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcHJvY2Vzc29yXG4gICAgICAgICAqIEB0eXBlIHtEYXRhUHJvY2Vzc29yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gcGFyYW1zLmRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZWxlY3RlZCBzZXJpZXMgaXRlbS5cbiAgICAgICAgICogQHR5cGUge251bGwgfCBvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0YSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZXZpb3VzIGNsaWVudCBwb3NpdGlvbiBvZiBtb3VzZSBldmVudCAoY2xpZW50WCwgY2xpZW50WSlcbiAgICAgICAgICogQHR5cGUge251bGwgfCBvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZDbGllbnRQb3NpdGlvbiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZXZpb3VzIGZvdW5kIGRhdGFcbiAgICAgICAgICogQHR5cGUge251bGwgfCBvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZGb3VuZERhdGEgPSBudWxsO1xuXG5cbiAgICAgICAgaXNMaW5lVHlwZUNoYXJ0ID0gcHJlZGljYXRlLmlzTGluZVR5cGVDaGFydCh0aGlzLmNoYXJ0VHlwZSwgdGhpcy5jaGFydFR5cGVzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZXhwYW5kIHNpemVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kU2l6ZSA9IGlzTGluZVR5cGVDaGFydCA/IGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFIDogMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY29udGFpbmVyIGJvdW5kXG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmQgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYm91bmQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0UmVuZGVyaW5nQm91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVuZGVyaW5nQm91bmQ7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0xpbmVUeXBlQ2hhcnQodGhpcy5jaGFydFR5cGUsIHRoaXMuY2hhcnRUeXBlcykpIHtcbiAgICAgICAgICAgIHJlbmRlcmluZ0JvdW5kID0gcmVuZGVyVXRpbC5leHBhbmRCb3VuZCh0aGlzLmJvdW5kc01ha2VyLmdldEJvdW5kKCdjdXN0b21FdmVudCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmluZ0JvdW5kID0gdGhpcy5ib3VuZHNNYWtlci5nZXRCb3VuZCgnY3VzdG9tRXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJpbmdCb3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGV2ZW50IGhhbmRsZSBsYXllciBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGN1c3RvbUV2ZW50Q29udGFpbmVyIC0gY29udGFpbmVyIGVsZW1lbnQgZm9yIGN1c3RvbSBldmVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ3VzdG9tRXZlbnRBcmVhOiBmdW5jdGlvbihjdXN0b21FdmVudENvbnRhaW5lciwgZGF0YSkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIHZhciByZW5kZXJpbmdCb3VuZCwgdGJjbTtcblxuICAgICAgICB0aGlzLmRpbWVuc2lvbiA9IGRpbWVuc2lvbjtcbiAgICAgICAgdGJjbSA9IG5ldyBUaWNrQmFzZUNvb3JkaW5hdGVNb2RlbChkaW1lbnNpb24sIGRhdGEudGlja0NvdW50LCB0aGlzLmNoYXJ0VHlwZSwgdGhpcy5pc1ZlcnRpY2FsLCB0aGlzLmNoYXJ0VHlwZXMpO1xuICAgICAgICB0aGlzLnRpY2tCYXNlQ29vcmRpbmF0ZU1vZGVsID0gdGJjbTtcbiAgICAgICAgcmVuZGVyaW5nQm91bmQgPSB0aGlzLl9nZXRSZW5kZXJpbmdCb3VuZCgpO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckRpbWVuc2lvbihjdXN0b21FdmVudENvbnRhaW5lciwgcmVuZGVyaW5nQm91bmQuZGltZW5zaW9uKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihjdXN0b21FdmVudENvbnRhaW5lciwgcmVuZGVyaW5nQm91bmQucG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZm9yIGN1c3RvbUV2ZW50IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGRhdGEgZm9yIHJlbmRlcmluZ1xuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGZvciBjdXN0b20gZXZlbnRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvbS5jcmVhdGUoJ0RJVicsICd0dWktY2hhcnQtc2VyaWVzLWN1c3RvbS1ldmVudC1hcmVhJyk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyQ3VzdG9tRXZlbnRBcmVhKGNvbnRhaW5lciwgZGF0YSk7XG4gICAgICAgIHRoaXMuYXR0YWNoRXZlbnQoY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5jdXN0b21FdmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29udGFpbmVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtDbGllbnRSZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENvbnRhaW5lckJvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lckJvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kID0gdGhpcy5jdXN0b21FdmVudENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckJvdW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgQm91bmRzQmFzZUNvb3JkaW5hdGVNb2RlbCBmcm9tIHNlcmllc0JvdW5kcyBmb3IgY3VzdG9tIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHNlcmllc0JvdW5kcyAtIHNlcmllcyBib3VuZHNcbiAgICAgKi9cbiAgICBpbml0Q3VzdG9tRXZlbnREYXRhOiBmdW5jdGlvbihzZXJpZXNCb3VuZHMpIHtcbiAgICAgICAgdGhpcy5ib3VuZHNCYXNlQ29vcmRpbmF0ZU1vZGVsID0gbmV3IEJvdW5kc0Jhc2VDb29yZGluYXRlTW9kZWwoc2VyaWVzQm91bmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVyZW5kZXIgZm9yIGN1c3RvbUV2ZW50IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3t0aWNrQ291bnQ6IG51bWJlcn19IGRhdGEgLSBkYXRhIGZvciByZXJlbmRlcmluZ1xuICAgICAqL1xuICAgIHJlcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckN1c3RvbUV2ZW50QXJlYSh0aGlzLmN1c3RvbUV2ZW50Q29udGFpbmVyLCBkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIGZvciBjdXN0b21FdmVudCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7dGlja0NvdW50OiBudW1iZXJ9fSBkYXRhIC0gZGF0YSBmb3IgcmVzaXppbmdcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJCb3VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVyZW5kZXIoZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBzZWxlY3QgZGF0YSBvciBub3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByZXYgLSBwcmV2aW91cyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGN1ciAtIGN1cnJlbnQgZGF0YVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2hhbmdlZFNlbGVjdERhdGE6IGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgICAgICByZXR1cm4gIXByZXYgfHwgIWN1ciB8fCBwcmV2LmNoYXJ0VHlwZSAhPT0gY3VyLmNoYXJ0VHlwZSB8fFxuICAgICAgICAgICAgcHJldi5pbmRleGVzLmdyb3VwSW5kZXggIT09IGN1ci5pbmRleGVzLmdyb3VwSW5kZXggfHwgcHJldi5pbmRleGVzLmluZGV4ICE9PSBjdXIuaW5kZXhlcy5pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBjb29yZGluYXRlIGRhdGEgZnJvbSBib3VuZHNDb29yZGluYXRlTW9kZWwuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50WCBtb3VzZSAtIHBvc2l0aW9uIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50WSBtb3VzZSAtIHBvc2l0aW9uIHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmREYXRhRnJvbUJvdW5kc0Nvb3JkaW5hdGVNb2RlbDogZnVuY3Rpb24odGFyZ2V0LCBjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGxheWVyWCA9IGNsaWVudFggLSBib3VuZC5sZWZ0O1xuICAgICAgICB2YXIgbGF5ZXJZID0gY2xpZW50WSAtIGJvdW5kLnRvcDtcbiAgICAgICAgdmFyIGdyb3VwSW5kZXg7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc1RyZWVtYXBDaGFydCh0aGlzLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXBJbmRleCA9IHRoaXMudGlja0Jhc2VDb29yZGluYXRlTW9kZWwuZmluZEluZGV4KHRoaXMuaXNWZXJ0aWNhbCA/IGxheWVyWCA6IGxheWVyWSk7XG4gICAgICAgICAgICBsYXllclggKz0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkU7XG4gICAgICAgICAgICBsYXllclkgKz0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHNCYXNlQ29vcmRpbmF0ZU1vZGVsLmZpbmREYXRhKGdyb3VwSW5kZXgsIGxheWVyWCwgbGF5ZXJZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5zZWxlY3Qgc2VsZWN0ZWQgZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bnNlbGVjdFNlbGVjdGVkRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSByZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ3Vuc2VsZWN0JywgdGhpcy5zZWxlY3RlZERhdGEuY2hhcnRUeXBlLCAnc2VyaWVzJyk7XG4gICAgICAgIHRoaXMuZmlyZShldmVudE5hbWUsIHRoaXMuc2VsZWN0ZWREYXRhKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGEgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfZmluZERhdGE6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9zaG93VG9vbHRpcDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgZm9yIGFkZGluZyBkYXRhLlxuICAgICAqL1xuICAgIGFuaW1hdGVGb3JBZGRpbmdEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZvdW5kRGF0YSwgaXNNb3Zpbmc7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZXZDbGllbnRQb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm91bmREYXRhID0gdGhpcy5fZmluZERhdGEodGhpcy5wcmV2Q2xpZW50UG9zaXRpb24ueCwgdGhpcy5wcmV2Q2xpZW50UG9zaXRpb24ueSk7XG5cbiAgICAgICAgaWYgKGZvdW5kRGF0YSkge1xuICAgICAgICAgICAgaXNNb3ZpbmcgPSB0aGlzLnByZXZGb3VuZERhdGEgJiYgKHRoaXMucHJldkZvdW5kRGF0YS5pbmRleGVzLmdyb3VwSW5kZXggPT09IGZvdW5kRGF0YS5pbmRleGVzLmdyb3VwSW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXAoZm91bmREYXRhLCBpc01vdmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXZGb3VuZERhdGEgPSBmb3VuZERhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBjdXN0b20gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZUV2ZW50OiBmdW5jdGlvbihldmVudFR5cGUsIGUpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHJlbmRlclV0aWwubWFrZUN1c3RvbUV2ZW50TmFtZShldmVudFR5cGUsIHRoaXMuY2hhcnRUeXBlLCAnc2VyaWVzJyk7XG5cbiAgICAgICAgZG9tLmFkZENsYXNzKHRoaXMuY3VzdG9tRXZlbnRDb250YWluZXIsICdoaWRlJyk7XG4gICAgICAgIHRoaXMuZmlyZShldmVudE5hbWUsIHtcbiAgICAgICAgICAgIGxlZnQ6IGUuY2xpZW50WCxcbiAgICAgICAgICAgIHRvcDogZS5jbGllbnRZXG4gICAgICAgIH0pO1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3ModGhpcy5jdXN0b21FdmVudENvbnRhaW5lciwgJ2hpZGUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2tcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICAgICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFggLSB0aGlzLmV4cGFuZFNpemU7XG4gICAgICAgIHZhciBmb3VuZERhdGEgPSB0aGlzLl9maW5kRGF0YUZyb21Cb3VuZHNDb29yZGluYXRlTW9kZWwodGFyZ2V0LCBjbGllbnRYLCBlLmNsaWVudFkpO1xuXG4gICAgICAgIGlmICghdGhpcy5faXNDaGFuZ2VkU2VsZWN0RGF0YSh0aGlzLnNlbGVjdGVkRGF0YSwgZm91bmREYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zZWxlY3RTZWxlY3RlZERhdGEoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZERhdGEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vuc2VsZWN0U2VsZWN0ZWREYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpcmUocmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzZWxlY3QnLCBmb3VuZERhdGEuY2hhcnRUeXBlLCAnc2VyaWVzJyksIGZvdW5kRGF0YSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0YSA9IGZvdW5kRGF0YTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZSBkb3duXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfb25Nb3VzZWRvd246IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZSB1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX29uTW91c2V1cDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIG1vdmVcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uTW91c2Vtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMucHJldkNsaWVudFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICAgICAgeTogZS5jbGllbnRZXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIG91dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uTW91c2VvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByZXZDbGllbnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldkZvdW5kRGF0YSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBldmVudFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIHRhcmdldCBlbGVtZW50XG4gICAgICovXG4gICAgYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBldmVudExpc3RlbmVyLm9uKHRhcmdldCwge1xuICAgICAgICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2ssXG4gICAgICAgICAgICBtb3VzZWRvd246IHRoaXMuX29uTW91c2Vkb3duLFxuICAgICAgICAgICAgbW91c2V1cDogdGhpcy5fb25Nb3VzZXVwLFxuICAgICAgICAgICAgbW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlbW92ZSxcbiAgICAgICAgICAgIG1vdXNlb3V0OiB0aGlzLl9vbk1vdXNlb3V0XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oQ3VzdG9tRXZlbnRCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDdXN0b21FdmVudEJhc2U7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgR3JvdXBUeXBlQ3VzdG9tRXZlbnQgaXMgZXZlbnQgaGFuZGxlIGxheWVyIGZvciBncm91cGVkIHRvb2x0aXAgb3B0aW9uLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDdXN0b21FdmVudEJhc2UgPSByZXF1aXJlKCcuL2N1c3RvbUV2ZW50QmFzZScpO1xudmFyIHpvb21NaXhlciA9IHJlcXVpcmUoJy4vem9vbU1peGVyJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbnZhciBHcm91cFR5cGVDdXN0b21FdmVudCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKEN1c3RvbUV2ZW50QmFzZSwgLyoqIEBsZW5kcyBHcm91cFR5cGVDdXN0b21FdmVudC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEdyb3VwVHlwZUN1c3RvbUV2ZW50IGlzIGV2ZW50IGhhbmRsZSBsYXllciBmb3IgZ3JvdXBlZCB0b29sdGlwIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiBAY29uc3RydWN0cyBHcm91cFR5cGVDdXN0b21FdmVudFxuICAgICAqIEBleHRlbmRzIEN1c3RvbUV2ZW50QmFzZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBDdXN0b21FdmVudEJhc2UuY2FsbCh0aGlzLCBwYXJhbXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmV2aW91cyBpbmRleCBvZiBncm91cCBkYXRhXG4gICAgICAgICAqIEB0eXBlIHtudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0eXBlIG9mIHNpemVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZVR5cGUgPSB0aGlzLmlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICAgICAgdGhpcy5faW5pdEZvclpvb20ocGFyYW1zLnpvb21hYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBkYXRhIG9mIGN1c3RvbSBldmVudFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHNlcmllc0luZm9zIHNlcmllcyBpbmZvc1xuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGluaXRDdXN0b21FdmVudERhdGE6IGZ1bmN0aW9uKHNlcmllc0luZm9zKSB7XG4gICAgICAgIEN1c3RvbUV2ZW50QmFzZS5wcm90b3R5cGUuaW5pdEN1c3RvbUV2ZW50RGF0YS5jYWxsKHRoaXMsIHNlcmllc0luZm9zKTtcblxuICAgICAgICB0aGlzLl9zaG93VG9vbHRpcEFmdGVyWm9vbSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGRhdGEgYnkgY2xpZW50IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRYIC0gY2xpZW50WFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRZIC0gY2xpZW50WVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZERhdGE6IGZ1bmN0aW9uKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgdmFyIGxheWVyUG9zaXRpb24gPSB0aGlzLl9jYWxjdWxhdGVMYXllclBvc2l0aW9uKGNsaWVudFgsIGNsaWVudFksIHRydWUpO1xuICAgICAgICB2YXIgcG9pbnRWYWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICBwb2ludFZhbHVlID0gbGF5ZXJQb3NpdGlvbi54IC0gdGhpcy5leHBhbmRTaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRWYWx1ZSA9IGxheWVyUG9zaXRpb24ueSAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiB0aGlzLnRpY2tCYXNlQ29vcmRpbmF0ZU1vZGVsLmZpbmRJbmRleChwb2ludFZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlyc3QgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7e2luZGV4ZXM6IHtncm91cEluZGV4OiBudW1iZXJ9fX0gLSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Rmlyc3REYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBsYXN0IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7e2luZGV4ZXM6IHtncm91cEluZGV4OiBudW1iZXJ9fX0gLSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGFzdERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IHRoaXMudGlja0Jhc2VDb29yZGluYXRlTW9kZWwuZ2V0TGFzdEluZGV4KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvdXQgcG9zaXRpb24gb3Igbm90LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllclggbGF5ZXJYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxheWVyWSBsYXllcllcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc091dFBvc2l0aW9uOiBmdW5jdGlvbihsYXllclgsIGxheWVyWSkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb247XG5cbiAgICAgICAgcmV0dXJuIGxheWVyWCA8IDAgfHwgbGF5ZXJYID4gZGltZW5zaW9uLndpZHRoIHx8IGxheWVyWSA8IDAgfHwgbGF5ZXJZID4gZGltZW5zaW9uLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7e2luZGV4ZXM6IHtncm91cEluZGV4OiBudW1iZXJ9fX0gZm91bmREYXRhIC0gZGF0YVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW92aW5nXSAtIHdoZXRoZXIgbW92aW5nIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3dUb29sdGlwOiBmdW5jdGlvbihmb3VuZERhdGEsIGlzTW92aW5nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGZvdW5kRGF0YS5pbmRleGVzLmdyb3VwSW5kZXg7XG5cbiAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5maXJlKCdzaG93R3JvdXBUb29sdGlwJywge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IHRoaXMudGlja0Jhc2VDb29yZGluYXRlTW9kZWwubWFrZVJhbmdlKGluZGV4KSxcbiAgICAgICAgICAgIHNpemU6IHRoaXMuZGltZW5zaW9uW3RoaXMuc2l6ZVR5cGVdLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgaXNNb3Zpbmc6IGlzTW92aW5nXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRvb2x0aXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlVG9vbHRpcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnaGlkZUdyb3VwVG9vbHRpcCcsIHRoaXMucHJldkluZGV4KTtcbiAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZW1vdmUuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIG1vdXNlIGV2ZW50IG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2Vtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBmb3VuZERhdGEsIGluZGV4O1xuXG4gICAgICAgIEN1c3RvbUV2ZW50QmFzZS5wcm90b3R5cGUuX29uTW91c2Vtb3ZlLmNhbGwodGhpcywgZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzQWZ0ZXJEcmFnTW91c2V1cCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3VuZERhdGEgPSB0aGlzLl9maW5kRGF0YShlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgIGluZGV4ID0gZm91bmREYXRhLmluZGV4ZXMuZ3JvdXBJbmRleDtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlb3V0KGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldkluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXAoZm91bmREYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZW91dC5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW91dDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgbGF5ZXJQb3NpdGlvbjtcblxuICAgICAgICBsYXllclBvc2l0aW9uID0gdGhpcy5fY2FsY3VsYXRlTGF5ZXJQb3NpdGlvbihlLmNsaWVudFgsIGUuY2xpZW50WSwgZmFsc2UpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc091dFBvc2l0aW9uKGxheWVyUG9zaXRpb24ueCwgbGF5ZXJQb3NpdGlvbi55KSAmJiAhdHVpLnV0aWwuaXNOdWxsKHRoaXMucHJldkluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5faGlkZVRvb2x0aXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEN1c3RvbUV2ZW50QmFzZS5wcm90b3R5cGUuX29uTW91c2VvdXQuY2FsbCh0aGlzKTtcbiAgICB9XG59KTtcblxuem9vbU1peGVyLm1peGluKEdyb3VwVHlwZUN1c3RvbUV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cFR5cGVDdXN0b21FdmVudDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNYXBDaGFydEN1c3RvbUV2ZW50IGlzIGV2ZW50IGhhbmRsZSBsYXllciBmb3IgbWFwIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDdXN0b21FdmVudEJhc2UgPSByZXF1aXJlKCcuL2N1c3RvbUV2ZW50QmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2V2ZW50TGlzdGVuZXInKSxcbiAgICBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbnZhciBNYXBDaGFydEN1c3RvbUV2ZW50ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ3VzdG9tRXZlbnRCYXNlLCAvKiogQGxlbmRzIE1hcENoYXJ0Q3VzdG9tRXZlbnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBNYXBDaGFydEN1c3RvbUV2ZW50IGlzIGV2ZW50IGhhbmRsZSBsYXllciBmb3IgbWFwIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtCb3VuZHNNYWtlcn0gcGFyYW1zLmJvdW5kc01ha2VyIGJvdW5kc01ha2VyIGluc3RhbmNlXG4gICAgICogQGNvbnN0cnVjdHMgTWFwQ2hhcnRDdXN0b21FdmVudFxuICAgICAqIEBleHRlbmRzIEN1c3RvbUV2ZW50QmFzZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IHBhcmFtcy5jaGFydFR5cGU7XG4gICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZXZlbnQgaGFuZGxlIGxheWVyIGFyZWFcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjdXN0b21FdmVudENvbnRhaW5lciBjdXN0b20gZXZlbnQgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJDdXN0b21FdmVudEFyZWE6IGZ1bmN0aW9uKGN1c3RvbUV2ZW50Q29udGFpbmVyKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0Qm91bmQoJ2N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKGN1c3RvbUV2ZW50Q29udGFpbmVyLCBib3VuZC5kaW1lbnNpb24pO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGN1c3RvbUV2ZW50Q29udGFpbmVyLCBib3VuZC5wb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZGF0YSBvZiBjdXN0b20gZXZlbnRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBpbml0Q3VzdG9tRXZlbnREYXRhOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2suXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25DbGljazogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIGRvd25cbiAgICAgKiBAcGFyYW0ge21vdXNlZXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9vbk1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmlzRG93biA9IHRydWU7XG4gICAgICAgIHRoaXMuZmlyZSgnZHJhZ1N0YXJ0TWFwU2VyaWVzJywge1xuICAgICAgICAgICAgbGVmdDogZS5jbGllbnRYLFxuICAgICAgICAgICAgdG9wOiBlLmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYWcgZW5kLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RyYWdFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlzRHJhZyA9IGZhbHNlO1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3ModGhpcy5jdXN0b21FdmVudENvbnRhaW5lciwgJ2RyYWcnKTtcbiAgICAgICAgdGhpcy5maXJlKCdkcmFnRW5kTWFwU2VyaWVzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIHVwXG4gICAgICogQHBhcmFtIHttb3VzZWV2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZXVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZykge1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0VuZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzTW92ZSkge1xuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZUV2ZW50KCdjbGljaycsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNNb3ZlID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIG1vdmUuXG4gICAgICogQHBhcmFtIHttb3VzZWV2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEb3duKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnKSB7XG4gICAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKHRoaXMuY3VzdG9tRXZlbnRDb250YWluZXIsICdkcmFnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzRHJhZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2RyYWdNYXBTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogZS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHRvcDogZS5jbGllbnRZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX29uTW91c2VFdmVudCgnbW92ZScsIGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIG91dFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2VvdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmFnRW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlRXZlbnQoJ21vdmUnLCBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZSB3aGVlbC5cbiAgICAgKiBAcGFyYW0ge21vdXNlZXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7P2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZXdoZWVsOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB3aGVlbERlbHRhID0gZS53aGVlbERlbHRhIHx8IGUuZGV0YWlsICogY2hhcnRDb25zdC5GRl9XSEVFTERFTFRBX0FESlVTVElOR19WQUxVRTtcblxuICAgICAgICB0aGlzLmZpcmUoJ3doZWVsJywgd2hlZWxEZWx0YSwge1xuICAgICAgICAgICAgbGVmdDogZS5jbGllbnRYLFxuICAgICAgICAgICAgdG9wOiBlLmNsaWVudFlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGV2ZW50XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IHRhcmdldCBlbGVtZW50XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBDdXN0b21FdmVudEJhc2UucHJvdG90eXBlLmF0dGFjaEV2ZW50LmNhbGwodGhpcywgdGFyZ2V0KTtcblxuICAgICAgICBpZiAodHVpLnV0aWwuYnJvd3Nlci5maXJlZm94KSB7XG4gICAgICAgICAgICBldmVudExpc3RlbmVyLm9uKHRhcmdldCwgJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5fb25Nb3VzZXdoZWVsLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50TGlzdGVuZXIub24odGFyZ2V0LCAnbW91c2V3aGVlbCcsIHRoaXMuX29uTW91c2V3aGVlbCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKE1hcENoYXJ0Q3VzdG9tRXZlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENoYXJ0Q3VzdG9tRXZlbnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2ltcGxlQ3VzdG9tRXZlbnQgaXMgZXZlbnQgaGFuZGxlIGxheWVyIGZvciBzaW1wbHkgc2VuZGluZyBjbGllbnRYLCBjbGllbnRZLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDdXN0b21FdmVudEJhc2UgPSByZXF1aXJlKCcuL2N1c3RvbUV2ZW50QmFzZScpO1xudmFyIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcblxudmFyIFNpbXBsZUN1c3RvbUV2ZW50ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ3VzdG9tRXZlbnRCYXNlLCAvKiogQGxlbmRzIFNpbXBsZUN1c3RvbUV2ZW50LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogU2ltcGxlQ3VzdG9tRXZlbnQgaXMgZXZlbnQgaGFuZGxlIGxheWVyIGZvciBzaW1wbHkgc2VuZGluZyBjbGllbnRYLCBjbGllbnRZLlxuICAgICAqIEBjb25zdHJ1Y3RzIFNpbXBsZUN1c3RvbUV2ZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0JvdW5kc01ha2VyfSBwYXJhbXMuYm91bmRzTWFrZXIgLSBib3VuZHMgbWFrZXIgaW5zdGFuY2VcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhcnRUeXBlIC0gY2hhcnQgdHlwZVxuICAgICAqIEBleHRlbmRzIEN1c3RvbUV2ZW50QmFzZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IHBhcmFtcy5jaGFydFR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBldmVudCBoYW5kbGUgbGF5ZXIgYXJlYVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGN1c3RvbUV2ZW50Q29udGFpbmVyIC0gY29udGFpbmVyIGVsZW1lbnQgZm9yIGN1c3RvbSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckN1c3RvbUV2ZW50QXJlYTogZnVuY3Rpb24oY3VzdG9tRXZlbnRDb250YWluZXIpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gdGhpcy5ib3VuZHNNYWtlci5nZXRCb3VuZCgnY3VzdG9tRXZlbnQnKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oY3VzdG9tRXZlbnRDb250YWluZXIsIGJvdW5kLmRpbWVuc2lvbik7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24oY3VzdG9tRXZlbnRDb250YWluZXIsIGJvdW5kLnBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBkYXRhIG9mIGN1c3RvbSBldmVudFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGluaXRDdXN0b21FdmVudERhdGE6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGljay5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZUV2ZW50KCdjbGljaycsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZSBtb3ZlLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZUV2ZW50KCdtb3ZlJywgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIG91dC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2VvdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZUV2ZW50KCdtb3ZlJywgZSk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihTaW1wbGVDdXN0b21FdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlQ3VzdG9tRXZlbnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGlja0Jhc2VEYXRhTW9kZWwgaXMgdGljayBiYXNlIGRhdGEgbW9kZWwuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG5cbnZhciBUaWNrQmFzZURhdGFNb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgVGlja0Jhc2VEYXRhTW9kZWwucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBUaWNrQmFzZURhdGFNb2RlbCBpcyB0aWNrIGJhc2UgZGF0YSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlja0NvdW50IHRpY2sgY291bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbY2hhcnRUeXBlc10gLSBjaGFydCB0eXBlcyBvZiBjb21ibyBjaGFydFxuICAgICAqIEBjb25zdHJ1Y3RzIFRpY2tCYXNlRGF0YU1vZGVsXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oZGltZW5zaW9uLCB0aWNrQ291bnQsIGNoYXJ0VHlwZSwgaXNWZXJ0aWNhbCwgY2hhcnRUeXBlcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciBsaW5lIHR5cGUgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0xpbmVUeXBlID0gcHJlZGljYXRlLmlzTGluZVR5cGVDaGFydChjaGFydFR5cGUsIGNoYXJ0VHlwZXMpO1xuXG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuX21ha2VEYXRhKGRpbWVuc2lvbiwgdGlja0NvdW50LCBpc1ZlcnRpY2FsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aWNrIGJhc2UgZGF0YSBhYm91dCBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCB0aWNrIGNvdW50XG4gICAgICogQHJldHVybnMge0FycmF5fSB0aWNrIGJhc2UgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMaW5lVHlwZURhdGE6IGZ1bmN0aW9uKHdpZHRoLCB0aWNrQ291bnQpIHtcbiAgICAgICAgdmFyIHRpY2tJbnRlcnZhbCA9ICh3aWR0aCArIDEpIC8gKHRpY2tDb3VudCAtIDEpLFxuICAgICAgICAgICAgaGFsZkludGVydmFsID0gdGlja0ludGVydmFsIC8gMixcbiAgICAgICAgICAgIHJhbmdlcyA9IHR1aS51dGlsLm1hcCh0dWkudXRpbC5yYW5nZSgwLCB0aWNrQ291bnQpLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbjogaW5kZXggKiB0aWNrSW50ZXJ2YWwgLSBoYWxmSW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICAgIG1heDogaW5kZXggKiB0aWNrSW50ZXJ2YWwgKyBoYWxmSW50ZXJ2YWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJhbmdlc1t0aWNrQ291bnQgLSAxXS5tYXggLT0gMTtcblxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRpY2sgYmFzZSBkYXRhIGFib3V0IG5vbiBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgd2lkdGggb3IgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCB0aWNrIGNvdW50XG4gICAgICogQHJldHVybnMge0FycmF5fSB0aWNrIGJhc2UgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VOb3JtYWxEYXRhOiBmdW5jdGlvbihzaXplLCB0aWNrQ291bnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRpY2tDb3VudCAtIDE7XG4gICAgICAgIHZhciB0aWNrSW50ZXJ2YWwgPSBzaXplIC8gbGVuO1xuICAgICAgICB2YXIgcHJldiA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0dWkudXRpbC5yYW5nZSgwLCBsZW4pLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgdmFyIG1heCA9IHR1aS51dGlsLm1pbihbc2l6ZSwgKGluZGV4ICsgMSkgKiB0aWNrSW50ZXJ2YWxdKTtcbiAgICAgICAgICAgIHZhciBsaW1pdCA9IHtcbiAgICAgICAgICAgICAgICBtaW46IHByZXYsXG4gICAgICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmV2ID0gbWF4O1xuXG4gICAgICAgICAgICByZXR1cm4gbGltaXQ7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRpY2sgYmFzZSBkYXRhIGZvciBjdXN0b20gZXZlbnQuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHJldHVybnMge0FycmF5LjxvYmplY3Q+fSB0aWNrIGJhc2UgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VEYXRhOiBmdW5jdGlvbihkaW1lbnNpb24sIHRpY2tDb3VudCwgaXNWZXJ0aWNhbCkge1xuICAgICAgICB2YXIgc2l6ZVR5cGUgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICB2YXIgZGF0YTtcblxuICAgICAgICBpZiAodGhpcy5pc0xpbmVUeXBlKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fbWFrZUxpbmVUeXBlRGF0YShkaW1lbnNpb25bc2l6ZVR5cGVdLCB0aWNrQ291bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX21ha2VOb3JtYWxEYXRhKGRpbWVuc2lvbltzaXplVHlwZV0sIHRpY2tDb3VudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9pbnRWYWx1ZSBtb3VzZSBwb3NpdGlvbiBwb2ludCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGdyb3VwIGluZGV4XG4gICAgICovXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbihwb2ludFZhbHVlKSB7XG4gICAgICAgIHZhciBmb3VuZEluZGV4ID0gLTE7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuZGF0YSwgZnVuY3Rpb24obGltaXQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAobGltaXQubWluIDwgcG9pbnRWYWx1ZSAmJiBsaW1pdC5tYXggPj0gcG9pbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZvdW5kSW5kZXggPSBpbmRleDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmb3VuZEluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGFzdCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldExhc3RJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSByYW5nZSBvZiB0b29sdGlwIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSB0eXBlIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtYWtlUmFuZ2U6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBsaW1pdCA9IHRoaXMuZGF0YVtpbmRleF0sXG4gICAgICAgICAgICByYW5nZSwgY2VudGVyO1xuICAgICAgICBpZiAodGhpcy5pc0xpbmVUeXBlKSB7XG4gICAgICAgICAgICBjZW50ZXIgPSBwYXJzZUludChsaW1pdC5tYXggLSAobGltaXQubWF4IC0gbGltaXQubWluKSAvIDIsIDEwKTtcbiAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBjZW50ZXIsXG4gICAgICAgICAgICAgICAgZW5kOiBjZW50ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogbGltaXQubWluLFxuICAgICAgICAgICAgICAgIGVuZDogbGltaXQubWF4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpY2tCYXNlRGF0YU1vZGVsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBNaXhlciBmb3Igem9vbSBldmVudCBvZiBhcmVhIHR5cGUgY3VzdG9tIGV2ZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDdXN0b21FdmVudEJhc2UgPSByZXF1aXJlKCcuL2N1c3RvbUV2ZW50QmFzZScpO1xudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpO1xudmFyIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcbnZhciBldmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi4vaGVscGVycy9ldmVudExpc3RlbmVyJyk7XG5cbi8qKlxuICogTWl4ZXIgZm9yIHpvb20gZXZlbnQgb2YgYXJlYSB0eXBlIGN1c3RvbSBldmVudC5cbiAqIEBtaXhpblxuICovXG52YXIgem9vbU1peGVyID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZm9yIHpvb20uXG4gICAgICogQHBhcmFtIHtib29sZWFufSB6b29tYWJsZSAtIHdoZXRoZXIgem9vbWFibGUgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEZvclpvb206IGZ1bmN0aW9uKHpvb21hYmxlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aGV0aGVyIHpvb21hYmxlIG9yIG5vdFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuem9vbWFibGUgPSB6b29tYWJsZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhZyBzdGFydCBpbmRleC5cbiAgICAgICAgICogQHR5cGUge251bGwgfCBvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdTdGFydEluZGV4ZXMgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdGFydCBjbGllbnQgcG9zaXRpb24oY2xpZW50WCwgY2xpZW50WSkgb2YgbW91c2UgZXZlbnQuXG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwge3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRDbGllbnRQb3NpdGlvbiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0YXJ0IGxheWVyWCBwb3NpdGlvblxuICAgICAgICAgKiBAdHlwZSB7bnVsbCB8IG51bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRMYXllclggPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnIHNlbGVjdGlvbiBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwgSFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdTZWxlY3Rpb25FbGVtZW50ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY29udGFpbmVyIGJvdW5kXG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwge2xlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250YWluZXJCb3VuZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgc2hvdyB0b29sdGlwIGFmdGVyIHpvb20gb3Igbm90LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNTaG93VG9vbHRpcEFmdGVyWm9vbSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aGV0aGVyIGFmdGVyIG1vdXNldXAgb3Igbm90LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWZ0ZXJNb3VzZXVwID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZXZpb3VzZSBkaXN0YW5jZSBvZiByYW5nZVxuICAgICAgICAgKiBAdHlwZSB7bnVsbCB8IG51bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldkRpc3RhbmNlT2ZSYW5nZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgcmV2ZXJzZSBtb3ZlIG9yIG5vdC5cbiAgICAgICAgICogQHR5cGUge251bGwgfCBudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJldmVyc2VNb3ZlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmVzZXQgem9vbSBidXR0b24gZWxlbWVudC5cbiAgICAgICAgICogQHR5cGUge251bGwgfCBIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzZXRab29tQnRuID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwIGFmdGVyIHpvb20uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd1Rvb2x0aXBBZnRlclpvb206IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXNTaG93VG9vbHRpcEFmdGVyWm9vbSA9IHRoaXMuaXNTaG93VG9vbHRpcEFmdGVyWm9vbTtcbiAgICAgICAgdmFyIGxhc3REYXRhQmVmb3JlWm9vbTtcblxuICAgICAgICB0aGlzLmlzU2hvd1Rvb2x0aXBBZnRlclpvb20gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIWlzU2hvd1Rvb2x0aXBBZnRlclpvb20gfHwgIXRoaXMuZHJhZ1N0YXJ0SW5kZXhlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucmV2ZXJzZU1vdmUpIHtcbiAgICAgICAgICAgIGxhc3REYXRhQmVmb3JlWm9vbSA9IHRoaXMuX2dldEZpcnN0RGF0YSh0aGlzLmRyYWdTdGFydEluZGV4ZXMuaW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdERhdGFCZWZvcmVab29tID0gdGhpcy5fZ2V0TGFzdERhdGEodGhpcy5kcmFnRW5kSW5kZXhlcy5pbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaG93VG9vbHRpcChsYXN0RGF0YUJlZm9yZVpvb20pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZGltZW5zaW9uIGZvciBkcmFnIHNlbGVjdGlvbiBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNlbGVjdGlvbkVsZW1lbnQgLSBkcmFnIHNlbGVjdGlvbiBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlRGltZW5zaW9uRm9yRHJhZ1NlbGVjdGlvbjogZnVuY3Rpb24oc2VsZWN0aW9uRWxlbWVudCkge1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckRpbWVuc2lvbihzZWxlY3Rpb25FbGVtZW50LCB7XG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdjdXN0b21FdmVudCcpLmhlaWdodFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGRyYWcgc2VsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJEcmFnU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkVsZW1lbnQgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LWRyYWctc2VsZWN0aW9uJyk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uRm9yRHJhZ1NlbGVjdGlvbihzZWxlY3Rpb25FbGVtZW50KTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uRWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gQ3VzdG9tRXZlbnRCYXNlLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkVsZW1lbnQgPSB0aGlzLl9yZW5kZXJEcmFnU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZG9tLmFwcGVuZChjb250YWluZXIsIHNlbGVjdGlvbkVsZW1lbnQpO1xuICAgICAgICB0aGlzLmRyYWdTZWxlY3Rpb25FbGVtZW50ID0gc2VsZWN0aW9uRWxlbWVudDtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbGF5ZXIgcG9zaXRpb24gYnkgY2xpZW50IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRYIC0gY2xpZW50WFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY2xpZW50WV0gLSBjbGllbnRZXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hlY2tMaW1pdF0gLSB3aGV0aGVyIGNoZWNrIGxpbWl0IG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiA/bnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVMYXllclBvc2l0aW9uOiBmdW5jdGlvbihjbGllbnRYLCBjbGllbnRZLCBjaGVja0xpbWl0KSB7XG4gICAgICAgIHZhciBib3VuZCA9IHRoaXMuX2dldENvbnRhaW5lckJvdW5kKCk7XG4gICAgICAgIHZhciBsYXllclBvc2l0aW9uID0ge307XG4gICAgICAgIHZhciBleHBhbmRTaXplID0gdGhpcy5leHBhbmRTaXplO1xuICAgICAgICB2YXIgbWF4TGVmdCwgbWluTGVmdDtcblxuICAgICAgICBjaGVja0xpbWl0ID0gdHVpLnV0aWwuaXNVbmRlZmluZWQoY2hlY2tMaW1pdCkgPyB0cnVlIDogY2hlY2tMaW1pdDtcblxuICAgICAgICBpZiAoY2hlY2tMaW1pdCkge1xuICAgICAgICAgICAgbWF4TGVmdCA9IGJvdW5kLnJpZ2h0IC0gZXhwYW5kU2l6ZTtcbiAgICAgICAgICAgIG1pbkxlZnQgPSBib3VuZC5sZWZ0ICsgZXhwYW5kU2l6ZTtcbiAgICAgICAgICAgIGNsaWVudFggPSBNYXRoLm1pbihNYXRoLm1heChjbGllbnRYLCBtaW5MZWZ0KSwgbWF4TGVmdCk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXllclBvc2l0aW9uLnggPSBjbGllbnRYIC0gYm91bmQubGVmdDtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKGNsaWVudFkpKSB7XG4gICAgICAgICAgICBsYXllclBvc2l0aW9uLnkgPSBjbGllbnRZIC0gYm91bmQudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVyUG9zaXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZS5cbiAgICAgKiBAcGFyYW0ge3t0aWNrQ291bnQ6IG51bWJlcn19IGRhdGEgLSBkYXRhIGZvciByZXNpemluZ1xuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kID0gbnVsbDtcbiAgICAgICAgQ3VzdG9tRXZlbnRCYXNlLnByb3RvdHlwZS5yZXNpemUuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uRm9yRHJhZ1NlbGVjdGlvbih0aGlzLmRyYWdTZWxlY3Rpb25FbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9vbkNsaWNrOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhZnRlciBkcmFnIG1vdXNldXAgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQWZ0ZXJEcmFnTW91c2V1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhZnRlck1vdXNldXAgPSB0aGlzLmFmdGVyTW91c2V1cDtcblxuICAgICAgICBpZiAoYWZ0ZXJNb3VzZXVwKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyTW91c2V1cCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFmdGVyTW91c2V1cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmluZCBkcmFnIGV2ZW50IGZvciB6b29tLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIHRhcmdldCBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYmluZERyYWdFdmVudDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQuc2V0Q2FwdHVyZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnNldENhcHR1cmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50TGlzdGVuZXIub24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vbkRyYWcsIHRoaXMpO1xuICAgICAgICBldmVudExpc3RlbmVyLm9mZih0aGlzLmN1c3RvbUV2ZW50Q29udGFpbmVyLCAnbW91c2V1cCcsIHRoaXMuX29uTW91c2V1cCwgdGhpcyk7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIub24oZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZXVwQWZ0ZXJEcmFnLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kIGRyYWcgZXZlbnQgZm9yIHpvb20uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5iaW5kRHJhZ0V2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZG93blRhcmdldCAmJiB0aGlzLmRvd25UYXJnZXQucmVsZWFzZUNhcHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuZG93blRhcmdldC5yZWxlYXNlQ2FwdHVyZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnRMaXN0ZW5lci5vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vbkRyYWcsIHRoaXMpO1xuICAgICAgICBldmVudExpc3RlbmVyLm9mZihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNldXBBZnRlckRyYWcsIHRoaXMpO1xuICAgICAgICBldmVudExpc3RlbmVyLm9uKHRoaXMuY3VzdG9tRXZlbnRDb250YWluZXIsICdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZXVwLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2UgZG93bi5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0YXJnZXQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLnpvb21hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cbiAgICAgICAgdGhpcy5zdGFydENsaWVudFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICAgICAgeTogZS5jbGllbnRZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRMYXllclggPSB0aGlzLl9jYWxjdWxhdGVMYXllclBvc2l0aW9uKGUuY2xpZW50WCkueDtcbiAgICAgICAgdGhpcy5kb3duVGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICAgIHRoaXMuX2JpbmREcmFnRXZlbnQodGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBkcmFnIHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50WCAtIGNsaWVudFhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93RHJhZ1NlbGVjdGlvbjogZnVuY3Rpb24oY2xpZW50WCkge1xuICAgICAgICB2YXIgbGF5ZXJYID0gdGhpcy5fY2FsY3VsYXRlTGF5ZXJQb3NpdGlvbihjbGllbnRYKS54O1xuICAgICAgICB2YXIgbGVmdCA9IE1hdGgubWluKGxheWVyWCwgdGhpcy5zdGFydExheWVyWCk7XG4gICAgICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKGxheWVyWCAtIHRoaXMuc3RhcnRMYXllclgpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZHJhZ1NlbGVjdGlvbkVsZW1lbnQ7XG5cbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFICsgJ3B4JztcbiAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcblxuICAgICAgICBkb20uYWRkQ2xhc3MoZWxlbWVudCwgJ3Nob3cnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBkcmFnIHNlbGVjdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlRHJhZ1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyh0aGlzLmRyYWdTZWxlY3Rpb25FbGVtZW50LCAnc2hvdycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZSBkcmFnLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25EcmFnOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBjbGllbnRQb3MgPSB0aGlzLnN0YXJ0Q2xpZW50UG9zaXRpb247XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzTnVsbCh0aGlzLmRyYWdTdGFydEluZGV4ZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydEluZGV4ZXMgPSB0aGlzLl9maW5kRGF0YShjbGllbnRQb3MueCwgY2xpZW50UG9zLnkpLmluZGV4ZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zaG93RHJhZ1NlbGVjdGlvbihlLmNsaWVudFgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBpbmRleCByYW5nZSBmb3IgZW5zdXJlIHRocmVlIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSBzdGFydCBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleCAtIGVuZCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGp1c3RJbmRleFJhbmdlOiBmdW5jdGlvbihzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICB2YXIgaW5kZXhSYW5nZSA9IFtzdGFydEluZGV4LCBlbmRJbmRleF0uc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGlzdGFuY2VPZlJhbmdlID0gaW5kZXhSYW5nZVsxXSAtIGluZGV4UmFuZ2VbMF07XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlT2ZSYW5nZSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGluZGV4UmFuZ2VbMF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleFJhbmdlWzFdICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4UmFuZ2VbMF0gLT0gMTtcbiAgICAgICAgICAgICAgICBpbmRleFJhbmdlWzFdICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2VPZlJhbmdlID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhSYW5nZVswXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGluZGV4UmFuZ2VbMV0gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZXhSYW5nZVswXSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4UmFuZ2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmUgem9vbSBjdXN0b20gZXZlbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSBzdGFydCBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleCAtIGVuZCBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVab29tOiBmdW5jdGlvbihzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICB2YXIgcmV2ZXJzZU1vdmUgPSBzdGFydEluZGV4ID4gZW5kSW5kZXg7XG4gICAgICAgIHZhciBpbmRleFJhbmdlID0gdGhpcy5fYWRqdXN0SW5kZXhSYW5nZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgIHZhciBkaXN0YW5jZU9mUmFuZ2UgPSBpbmRleFJhbmdlWzFdIC0gaW5kZXhSYW5nZVswXTtcblxuICAgICAgICBpZiAodGhpcy5wcmV2RGlzdGFuY2VPZlJhbmdlID09PSBkaXN0YW5jZU9mUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJldkRpc3RhbmNlT2ZSYW5nZSA9IGRpc3RhbmNlT2ZSYW5nZTtcbiAgICAgICAgdGhpcy5yZXZlcnNlTW92ZSA9IHJldmVyc2VNb3ZlO1xuICAgICAgICB0aGlzLmZpcmUoJ3pvb20nLCBpbmRleFJhbmdlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGZsYWcgYWJvdXQgd2hldGhlciBzaG93IHRvb2x0aXAgYWZ0ZXIgem9vbSBvciBub3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFggLSBjbGllbnRYIG9mIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFkgLSBjbGllbnRZIG9mIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0SXNTaG93VG9vbHRpcEFmdGVyWm9vbUZsYWc6IGZ1bmN0aW9uKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgdmFyIGxheWVyWCA9IHRoaXMuX2NhbGN1bGF0ZUxheWVyUG9zaXRpb24oY2xpZW50WCwgY2xpZW50WSwgZmFsc2UpLng7XG4gICAgICAgIHZhciBsaW1pdExheWVyWCA9IHRoaXMuX2NhbGN1bGF0ZUxheWVyUG9zaXRpb24oY2xpZW50WCwgY2xpZW50WSkueDtcblxuICAgICAgICB0aGlzLmlzU2hvd1Rvb2x0aXBBZnRlclpvb20gPSAobGF5ZXJYID09PSBsaW1pdExheWVyWCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNldXAgYWZ0ZXIgZHJhZyBldmVudC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uTW91c2V1cEFmdGVyRHJhZzogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdGFyZ2V0O1xuXG4gICAgICAgIHRoaXMuX3VuYmluZERyYWdFdmVudCgpO1xuXG4gICAgICAgIGlmICh0dWkudXRpbC5pc051bGwodGhpcy5kcmFnU3RhcnRJbmRleGVzKSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGRvbS5oYXNDbGFzcyh0YXJnZXQsIGNoYXJ0Q29uc3QuQ0xBU1NfTkFNRV9SRVNFVF9aT09NX0JUTikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkRpc3RhbmNlT2ZSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdyZXNldFpvb20nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQ3VzdG9tRXZlbnRCYXNlLnByb3RvdHlwZS5fb25DbGljay5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmFnRW5kSW5kZXhlcyA9IHRoaXMuX2ZpbmREYXRhKGUuY2xpZW50WCwgZS5jbGllbnRZKS5pbmRleGVzO1xuICAgICAgICAgICAgdGhpcy5fc2V0SXNTaG93VG9vbHRpcEFmdGVyWm9vbUZsYWcoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICAgICAgdGhpcy5faGlkZURyYWdTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVab29tKHRoaXMuZHJhZ1N0YXJ0SW5kZXhlcy5ncm91cEluZGV4LCB0aGlzLmRyYWdFbmRJbmRleGVzLmdyb3VwSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFydENsaWVudFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnU3RhcnRJbmRleGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydExheWVyWCA9IG51bGw7XG4gICAgICAgIHRoaXMuYWZ0ZXJNb3VzZXVwID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHJlc2V0IHpvb20gYnV0dG9uIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclJlc2V0Wm9vbUJ0bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXNldEJ0biA9IGRvbS5jcmVhdGUoJ0RJVicsIGNoYXJ0Q29uc3QuQ0xBU1NfTkFNRV9SRVNFVF9aT09NX0JUTik7XG4gICAgICAgIHJlc2V0QnRuLmlubmVySFRNTCA9ICdSZXNldCBab29tJztcblxuICAgICAgICByZXR1cm4gcmVzZXRCdG47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb20uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKi9cbiAgICB6b29tOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucHJldkZvdW5kRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVyZW5kZXIoZGF0YSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbkZvckRyYWdTZWxlY3Rpb24odGhpcy5kcmFnU2VsZWN0aW9uRWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnJlc2V0Wm9vbUJ0bikge1xuICAgICAgICAgICAgdGhpcy5yZXNldFpvb21CdG4gPSB0aGlzLl9yZW5kZXJSZXNldFpvb21CdG4oKTtcbiAgICAgICAgICAgIGRvbS5hcHBlbmQodGhpcy5jdXN0b21FdmVudENvbnRhaW5lciwgdGhpcy5yZXNldFpvb21CdG4pO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuaXNSZXNldFpvb20pIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRXZlbnRDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5yZXNldFpvb21CdG4pO1xuICAgICAgICAgICAgdGhpcy5yZXNldFpvb21CdG4gPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peCBpbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIHRhcmdldCBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBtaXhpbjogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB0dWkudXRpbC5leHRlbmQoZnVuYy5wcm90b3R5cGUsIHRoaXMpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gem9vbU1peGVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERhdGFQcm9jZXNzb3IgcHJvY2VzcyByYXdEYXRhLlxuICogcmF3RGF0YS5jYXRlZ29yaWVzIC0tPiBjYXRlZ29yaWVzXG4gKiByYXdEYXRhLnNlcmllcyAtLT4gU2VyaWVzRGF0YU1vZGVsLCBsZWdlbmRMYWJlbHMsIGxlZ2VuZERhdGFcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgU2VyaWVzRGF0YU1vZGVsID0gcmVxdWlyZSgnLi4vZGF0YU1vZGVscy9zZXJpZXNEYXRhTW9kZWwnKTtcbnZhciBTZXJpZXNEYXRhTW9kZWxGb3JUcmVlbWFwID0gcmVxdWlyZSgnLi4vZGF0YU1vZGVscy9zZXJpZXNEYXRhTW9kZWxGb3JUcmVlbWFwJyk7XG52YXIgU2VyaWVzR3JvdXAgPSByZXF1aXJlKCcuL3Nlcmllc0dyb3VwJyk7XG52YXIgcmF3RGF0YUhhbmRsZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3Jhd0RhdGFIYW5kbGVyJyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcbnZhciByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG4vKipcbiAqIFJhdyBzZXJpZXMgZGF0dW0uXG4gKiBAdHlwZWRlZiB7e25hbWU6ID9zdHJpbmcsIGRhdGE6IEFycmF5LjxudW1iZXI+LCBzdGFjazogP3N0cmluZ319IHJhd1Nlcmllc0RhdHVtXG4gKi9cblxuLyoqXG4gKiBSYXcgc2VyaWVzIGRhdGEuXG4gKiBAdHlwZWRlZiB7QXJyYXkuPHJhd1Nlcmllc0RhdHVtPn0gcmF3U2VyaWVzRGF0YVxuICovXG5cbi8qKlxuICogUmF3IGRhdGEgYnkgdXNlci5cbiAqIEB0eXBlZGVmIHt7XG4gKiAgICAgIGNhdGVnb3JpZXM6ID9BcnJheS48c3RyaW5nPixcbiAqICAgICAgc2VyaWVzOiAocmF3U2VyaWVzRGF0YXx7bGluZTogP3Jhd1Nlcmllc0RhdGEsIGNvbHVtbjogP3Jhd1Nlcmllc0RhdGF9KVxuICogfX0gcmF3RGF0YVxuICovXG5cbi8qKlxuICogU2VyaWVzRGF0YU1vZGVsIGlzIGJhc2UgbW9kZWwgZm9yIGRyYXdpbmcgZ3JhcGggb2YgY2hhcnQgc2VyaWVzIGFyZWEsXG4gKiAgICAgIGFuZCBjcmVhdGUgZnJvbSByYXdTZXJpZXNEYXRhIGJ5IHVzZXIsXG4gKiBTZXJpZXNEYXRhTW9kZWwuZ3JvdXBzIGhhcyBTZXJpZXNHcm91cHMuXG4gKi9cblxuLyoqXG4gKiBTZXJpZXNHcm91cCBpcyBhIGVsZW1lbnQgb2YgU2VyaWVzRGF0YU1vZGVsLmdyb3Vwcy5cbiAqIFNlcmllc0dyb3VwLml0ZW1zIGhhcyBTZXJpZXNJdGVtLlxuICovXG5cbnZhciBEYXRhUHJvY2Vzc29yID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBEYXRhUHJvY2Vzc29yLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBEYXRhIHByb2Nlc3Nvci5cbiAgICAgKiBAY29uc3RydWN0cyBEYXRhUHJvY2Vzc29yXG4gICAgICogQHBhcmFtIHtyYXdEYXRhfSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHNlcmllc05hbWVzIGNoYXJ0IHR5cGVzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3RGF0YSwgY2hhcnRUeXBlLCBvcHRpb25zLCBzZXJpZXNOYW1lcykge1xuICAgICAgICB2YXIgc2VyaWVzT3B0aW9uID0gb3B0aW9ucy5zZXJpZXMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9yaWdpbmFsIHJhdyBkYXRhLlxuICAgICAgICAgKiBAdHlwZSB7e2NhdGVnb3JpZXM6ID9BcnJheS48c3RyaW5nPiwgc2VyaWVzOiBBcnJheS48b2JqZWN0Pn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWdpbmFsUmF3RGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmF3RGF0YSkpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IGNoYXJ0VHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhcnQgb3B0aW9uc1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2VyaWVzTmFtZXMgaXMgc29ydGVkIGNoYXJ0IHR5cGVzIGZvciByZW5kZXJpbmcgc2VyaWVzIGFyZWEgb2YgY29tYm8gY2hhcnQuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VyaWVzTmFtZXMgPSBzZXJpZXNOYW1lcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogZGl2ZXJnaW5nIG9wdGlvblxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGl2ZXJnaW5nT3B0aW9uID0gcHJlZGljYXRlLmlzQmFyVHlwZUNoYXJ0KG9wdGlvbnMuY2hhcnRUeXBlKSAmJiBzZXJpZXNPcHRpb24uZGl2ZXJnaW5nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsZWdlbmQgZGF0YSBmb3IgcmVuZGVyaW5nIGxlZ2VuZCBvZiBncm91cCB0b29sdGlwXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48e2NoYXJ0VHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nfT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWdpbmFsTGVnZW5kRGF0YSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGR5bmFtaWMgZGF0YSBhcnJheSBmb3IgYWRkaW5nIGRhdGEuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48e2NhdGVnb3J5OiBzdHJpbmcgfCBudW1iZXIsIHZhbHVlczogQXJyYXkuPG51bWJlcj59Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHluYW1pY0RhdGEgPSBbXTtcblxuICAgICAgICB0aGlzLmluaXREYXRhKHJhd0RhdGEpO1xuICAgICAgICB0aGlzLmluaXRab29tZWRSYXdEYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBvcmlnaW5hbCByYXcgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7cmF3RGF0YX0gcmF3IGRhdGFcbiAgICAgKi9cbiAgICBnZXRPcmlnaW5hbFJhd0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLm9yaWdpbmFsUmF3RGF0YSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgem9vbWVkIHJhdyBkYXRhLlxuICAgICAqIEByZXR1cm5zIHsqfG51bGx9XG4gICAgICovXG4gICAgZ2V0Wm9vbWVkUmF3RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB6b29tZWRSYXdEYXRhID0gdGhpcy56b29tZWRSYXdEYXRhO1xuICAgICAgICBpZiAoem9vbWVkUmF3RGF0YSkge1xuICAgICAgICAgICAgem9vbWVkUmF3RGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoem9vbWVkUmF3RGF0YSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgem9vbWVkUmF3RGF0YSA9IHRoaXMuZ2V0T3JpZ2luYWxSYXdEYXRhKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gem9vbWVkUmF3RGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHNlcmllc0RhdGEgYnkgaW5kZXggcmFuZ2UuXG4gICAgICogQHBhcmFtIHtBcnJheS48e2RhdGE6IEFycmF5fT59IHNlcmllc0RhdGEgLSBzZXJpZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IC0gc3RhcnQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kSW5kZXggLSBlbmQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maWx0ZXJTZXJpZXNEYXRhQnlJbmRleFJhbmdlOiBmdW5jdGlvbihzZXJpZXNEYXRhLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoc2VyaWVzRGF0YSwgZnVuY3Rpb24oc2VyaWVzRGF0dW0pIHtcbiAgICAgICAgICAgIHNlcmllc0RhdHVtLmRhdGEgPSBzZXJpZXNEYXR1bS5kYXRhLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4ICsgMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZXJpZXNEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgcmF3IGRhdGEgYnkgaW5kZXggcmFuZ2UuXG4gICAgICogQHBhcmFtIHt7c2VyaWVzOiBBcnJheS48b2JqZWN0PiwgY2F0ZWdvcmllczogQXJyYXkuPHN0cmluZz59fSByYXdEYXRhIC0gcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBpbmRleFJhbmdlIC0gaW5kZXggcmFuZ2UgZm9yIHpvb21cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maWx0ZXJSYXdEYXRhQnlJbmRleFJhbmdlOiBmdW5jdGlvbihyYXdEYXRhLCBpbmRleFJhbmdlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBpbmRleFJhbmdlWzBdO1xuICAgICAgICB2YXIgZW5kSW5kZXggPSBpbmRleFJhbmdlWzFdO1xuXG4gICAgICAgIGlmICh0dWkudXRpbC5pc0FycmF5KHJhd0RhdGEuc2VyaWVzKSkge1xuICAgICAgICAgICAgcmF3RGF0YS5zZXJpZXMgPSB0aGlzLl9maWx0ZXJTZXJpZXNEYXRhQnlJbmRleFJhbmdlKHJhd0RhdGEuc2VyaWVzLCBzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHJhd0RhdGEuc2VyaWVzLCBmdW5jdGlvbihzZXJpZXNEYXRhU2V0LCBzZXJpZXNOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmF3RGF0YS5zZXJpZXNbc2VyaWVzTmFtZV0gPSBzZWxmLl9maWx0ZXJTZXJpZXNEYXRhQnlJbmRleFJhbmdlKHNlcmllc0RhdGFTZXQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmF3RGF0YS5jYXRlZ29yaWVzID0gcmF3RGF0YS5jYXRlZ29yaWVzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4ICsgMSk7XG5cbiAgICAgICAgcmV0dXJuIHJhd0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSByYXcgZGF0YSBmb3Igem9vbVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGluZGV4UmFuZ2UgLSBpbmRleCByYW5nZSBmb3Igem9vbVxuICAgICAqL1xuICAgIHVwZGF0ZVJhd0RhdGFGb3Jab29tOiBmdW5jdGlvbihpbmRleFJhbmdlKSB7XG4gICAgICAgIHZhciByYXdEYXRhID0gdGhpcy5nZXRSYXdEYXRhKCk7XG4gICAgICAgIHZhciB6b29tZWRSYXdEYXRhID0gdGhpcy5nZXRab29tZWRSYXdEYXRhKCk7XG5cbiAgICAgICAgdGhpcy56b29tZWRSYXdEYXRhID0gdGhpcy5fZmlsdGVyUmF3RGF0YUJ5SW5kZXhSYW5nZSh6b29tZWRSYXdEYXRhLCBpbmRleFJhbmdlKTtcbiAgICAgICAgcmF3RGF0YSA9IHRoaXMuX2ZpbHRlclJhd0RhdGFCeUluZGV4UmFuZ2UocmF3RGF0YSwgaW5kZXhSYW5nZSk7XG4gICAgICAgIHRoaXMuaW5pdERhdGEocmF3RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXQgem9vbWVkIHJhdyBkYXRhLlxuICAgICAqL1xuICAgIGluaXRab29tZWRSYXdEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy56b29tZWRSYXdEYXRhID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7cmF3RGF0YX0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqL1xuICAgIGluaXREYXRhOiBmdW5jdGlvbihyYXdEYXRhKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByYXcgZGF0YVxuICAgICAgICAgKiBAdHlwZSB7cmF3RGF0YX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmF3RGF0YSA9IHJhd0RhdGE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhdGVnb3JpZXNcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYXRlZ29yaWVzTWFwID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3RhY2tzXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhY2tzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2VyaWVzRGF0YU1vZGVsIG1hcFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0LjxzdHJpbmcsIFNlcmllc0RhdGFNb2RlbD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcmllc0RhdGFNb2RlbE1hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXJpZXNHcm91cHNcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxTZXJpZXNHcm91cD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcmllc0dyb3VwcyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1hcCBvZiB2YWx1ZXMgb2YgU2VyaWVzSXRlbXNcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBBcnJheS48bnVtYmVyPj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlc01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsZWdlbmQgbGFiZWxzIGZvciByZW5kZXJpbmcgbGVnZW5kIGFyZWFcbiAgICAgICAgICogQHR5cGUge3tjb2x1bW46IEFycmF5LjxzdHJpbmc+LCBsaW5lOiBBcnJheS48c3RyaW5nPiB8IEFycmF5LjxzdHJpbmc+fX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVnZW5kTGFiZWxzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbGVnZW5kIGRhdGEgZm9yIHJlbmRlcmluZyBsZWdlbmRcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljx7Y2hhcnRUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmd9Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVnZW5kRGF0YSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZ1bmN0aW9ucyBmb3IgZm9ybWF0dGluZ1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPGZ1bmN0aW9uPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9ybWF0RnVuY3Rpb25zID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbXVsdGlsaW5lIGNhdGVnb3JpZXNcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdWx0aWxpbmVDYXRlZ29yaWVzID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJhdyBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtyYXdEYXRhfVxuICAgICAqL1xuICAgIGdldFJhd0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGNoYXJ0IHR5cGUgZnJvbSBzZXJpZXMgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWVzTmFtZSAtIHNlcmllcyBuYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZmluZENoYXJ0VHlwZTogZnVuY3Rpb24oc2VyaWVzTmFtZSkge1xuICAgICAgICByZXR1cm4gcmF3RGF0YUhhbmRsZXIuZmluZENoYXJ0VHlwZSh0aGlzLnJhd0RhdGEuc2VyaWVzQWxpYXMsIHNlcmllc05hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGUgY2F0ZWdvcmllc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZywgbnVtYmVyPn0gY2F0ZWdvcmllcyAtIGNldGVnb3JpZXNcbiAgICAgKiBAcmV0dXJucyB7KnxBcnJheS48T2JqZWN0PnxBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9lc2NhcGVDYXRlZ29yaWVzOiBmdW5jdGlvbihjYXRlZ29yaWVzKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoY2F0ZWdvcmllcywgZnVuY3Rpb24oY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5lbmNvZGVIVE1MRW50aXR5KFN0cmluZyhjYXRlZ29yeSkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBjYXRlZ29yaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBjYXRlZ29yeSB0eXBlICh4IG9yIHkpXG4gICAgICogQHJldHVybnMge251bGwgfCBBcnJheS48c3RyaW5nPn0gcHJvY2Vzc2VkIGNhdGVnb3JpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9jZXNzQ2F0ZWdvcmllczogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgcmF3Q2F0ZWdvcmllcyA9IHRoaXMucmF3RGF0YS5jYXRlZ29yaWVzO1xuICAgICAgICB2YXIgY2F0ZWdvcmllc01hcCA9IHt9O1xuXG4gICAgICAgIGlmICh0dWkudXRpbC5pc0FycmF5KHJhd0NhdGVnb3JpZXMpKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzTWFwW3R5cGVdID0gdGhpcy5fZXNjYXBlQ2F0ZWdvcmllcyhyYXdDYXRlZ29yaWVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChyYXdDYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICBpZiAocmF3Q2F0ZWdvcmllcy54KSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcmllc01hcC54ID0gdGhpcy5fZXNjYXBlQ2F0ZWdvcmllcyhyYXdDYXRlZ29yaWVzLngpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmF3Q2F0ZWdvcmllcy55KSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcmllc01hcC55ID0gdGhpcy5fZXNjYXBlQ2F0ZWdvcmllcyhyYXdDYXRlZ29yaWVzLnkpLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYXRlZ29yaWVzTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgQ2F0ZWdvcmllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWZXJ0aWNhbCAtIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fX1cbiAgICAgKi9cbiAgICBnZXRDYXRlZ29yaWVzOiBmdW5jdGlvbihpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHZhciB0eXBlID0gaXNWZXJ0aWNhbCA/ICd5JyA6ICd4JztcbiAgICAgICAgdmFyIGZvdW5kQ2F0ZWdvcmllcyA9IFtdO1xuXG4gICAgICAgIGlmICghdGhpcy5jYXRlZ29yaWVzTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmNhdGVnb3JpZXNNYXAgPSB0aGlzLl9wcm9jZXNzQ2F0ZWdvcmllcyh0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0dWkudXRpbC5pc0V4aXN0eShpc1ZlcnRpY2FsKSkge1xuICAgICAgICAgICAgZm91bmRDYXRlZ29yaWVzID0gdGhpcy5jYXRlZ29yaWVzTWFwW3R5cGVdIHx8IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh0aGlzLmNhdGVnb3JpZXNNYXAsIGZ1bmN0aW9uKGNhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3VuZENhdGVnb3JpZXMgPSBjYXRlZ29yaWVzO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm91bmRDYXRlZ29yaWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2F0ZWdvcnkgY291bnQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIC0gd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRDYXRlZ29yeUNvdW50OiBmdW5jdGlvbihpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gdGhpcy5nZXRDYXRlZ29yaWVzKGlzVmVydGljYWwpO1xuXG4gICAgICAgIHJldHVybiBjYXRlZ29yaWVzID8gY2F0ZWdvcmllcy5sZW5ndGggOiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGhhcyBjYXRlZ29yaWVzIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmVydGljYWwgLSB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0NhdGVnb3JpZXM6IGZ1bmN0aW9uKGlzVmVydGljYWwpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRDYXRlZ29yeUNvdW50KGlzVmVydGljYWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2F0ZWdvcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIC0gd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjYXRlZ29yeVxuICAgICAqL1xuICAgIGdldENhdGVnb3J5OiBmdW5jdGlvbihpbmRleCwgaXNWZXJ0aWNhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYXRlZ29yaWVzKGlzVmVydGljYWwpW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNhdGVnb3J5IGZvciB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaXJzdEluZGV4IC0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3Bwb3NpdGVJbmRleCAtIG9wcG9zaXRlIGluZGV4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsQ2hhcnQgLSB3aGV0aGVyIHZlcnRpY2FsIGNoYXJ0IG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0VG9vbHRpcENhdGVnb3J5OiBmdW5jdGlvbihmaXJzdEluZGV4LCBvcHBvc2l0ZUluZGV4LCBpc1ZlcnRpY2FsQ2hhcnQpIHtcbiAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9ICFpc1ZlcnRpY2FsQ2hhcnQ7XG4gICAgICAgIHZhciBjYXRlZ29yeSA9IHRoaXMuZ2V0Q2F0ZWdvcnkoZmlyc3RJbmRleCwgaXNIb3Jpem9udGFsKTtcbiAgICAgICAgdmFyIGNhdGVnb3J5Q291bnQgPSB0aGlzLmdldENhdGVnb3J5Q291bnQoIWlzSG9yaXpvbnRhbCk7XG5cbiAgICAgICAgaWYgKGNhdGVnb3J5Q291bnQpIHtcbiAgICAgICAgICAgIGNhdGVnb3J5ICs9ICcsICcgKyB0aGlzLmdldENhdGVnb3J5KGNhdGVnb3J5Q291bnQgLSBvcHBvc2l0ZUluZGV4IC0gMSwgaXNWZXJ0aWNhbENoYXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYXRlZ29yeTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHN0YWNrcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgZ2V0U3RhY2tzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YWNrcykge1xuICAgICAgICAgICAgdGhpcy5zdGFja3MgPSByYXdEYXRhSGFuZGxlci5waWNrU3RhY2tzKHRoaXMucmF3RGF0YS5zZXJpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3RhY2sgY291bnQuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRTdGFja0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2tzKCkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHN0YWNrIGluZGV4LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFjayBzdGFja1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZmluZFN0YWNrSW5kZXg6IGZ1bmN0aW9uKHN0YWNrKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5pbkFycmF5KHN0YWNrLCB0aGlzLmdldFN0YWNrcygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IFNlcmllc0RhdGFNb2RlbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWVzTmFtZSAtIHNlcmllcyBuYW1lXG4gICAgICogQHJldHVybnMge1Nlcmllc0RhdGFNb2RlbH1cbiAgICAgKi9cbiAgICBnZXRTZXJpZXNEYXRhTW9kZWw6IGZ1bmN0aW9uKHNlcmllc05hbWUpIHtcbiAgICAgICAgdmFyIHJhd1Nlcmllc0RhdGEsIGNoYXJ0VHlwZSwgU2VyaWVzRGF0YU1vZGVsQ2xhc3M7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlcmllc0RhdGFNb2RlbE1hcFtzZXJpZXNOYW1lXSkge1xuICAgICAgICAgICAgY2hhcnRUeXBlID0gdGhpcy5maW5kQ2hhcnRUeXBlKHNlcmllc05hbWUpO1xuICAgICAgICAgICAgcmF3U2VyaWVzRGF0YSA9IHRoaXMucmF3RGF0YS5zZXJpZXNbc2VyaWVzTmFtZV0gfHwgdGhpcy5yYXdEYXRhLnNlcmllcztcblxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5pc1RyZWVtYXBDaGFydCh0aGlzLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICBTZXJpZXNEYXRhTW9kZWxDbGFzcyA9IFNlcmllc0RhdGFNb2RlbEZvclRyZWVtYXA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNlcmllc0RhdGFNb2RlbENsYXNzID0gU2VyaWVzRGF0YU1vZGVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNlcmllc0RhdGFNb2RlbE1hcFtzZXJpZXNOYW1lXSA9IG5ldyBTZXJpZXNEYXRhTW9kZWxDbGFzcyhyYXdTZXJpZXNEYXRhLCBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLCB0aGlzLmdldEZvcm1hdEZ1bmN0aW9ucygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllc0RhdGFNb2RlbE1hcFtzZXJpZXNOYW1lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGdyb3VwIGNvdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0R3JvdXBDb3VudDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlcmllc0RhdGFNb2RlbChjaGFydFR5cGUpLmdldEdyb3VwQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHVzaCBjYXRlZ29yeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnkgLSBjYXRlZ29yeVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3B1c2hDYXRlZ29yeTogZnVuY3Rpb24oY2F0ZWdvcnkpIHtcbiAgICAgICAgdGhpcy5yYXdEYXRhLmNhdGVnb3JpZXMucHVzaChjYXRlZ29yeSk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxSYXdEYXRhLmNhdGVnb3JpZXMucHVzaChjYXRlZ29yeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNoaWZ0IGNhdGVnb3J5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NoaWZ0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJhd0RhdGEuY2F0ZWdvcmllcy5zaGlmdCgpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsUmF3RGF0YS5jYXRlZ29yaWVzLnNoaWZ0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgcmF3IHNlcmllcyBkYXR1bSBieSBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gbGVnZW5kIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Nlcmllc05hbWVdIC0gc2VyaWVzIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRSYXdTZXJpZXNEYXR1bUJ5TmFtZTogZnVuY3Rpb24obmFtZSwgc2VyaWVzTmFtZSkge1xuICAgICAgICB2YXIgZm91bmRTZXJpZXNEYXR1bSA9IG51bGw7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTmFtZSA/IHRoaXMucmF3RGF0YS5zZXJpZXNbc2VyaWVzTmFtZV0gOiB0aGlzLnJhd0RhdGEuc2VyaWVzO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZXJpZXNEYXRhLCBmdW5jdGlvbihzZXJpZXNEYXR1bSkge1xuICAgICAgICAgICAgdmFyIGlzRXF1YWwgPSBzZXJpZXNEYXR1bS5uYW1lID09PSBuYW1lO1xuXG4gICAgICAgICAgICBpZiAoaXNFcXVhbCkge1xuICAgICAgICAgICAgICAgIGZvdW5kU2VyaWVzRGF0dW0gPSBzZXJpZXNEYXR1bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICFpc0VxdWFsO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm91bmRTZXJpZXNEYXR1bTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHVzaCB2YWx1ZXMgdG8gc2VyaWVzIG9mIG9yaWdpbmFsUmF3RGF0YSBhbmQgc2VyaWVzIG9mIHJhd0RhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheS48e25hbWU6IHN0cmluZywgZGF0YTogQXJyYXl9Pn0gc2VyaWVzRGF0YSAtIHNlcmllcyBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIC0gdmFsdWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXJpZXNOYW1lXSAtIHNlcmllcyBuYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcHVzaFZhbHVlczogZnVuY3Rpb24oc2VyaWVzRGF0YSwgdmFsdWVzLCBzZXJpZXNOYW1lKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoc2VyaWVzRGF0YSwgZnVuY3Rpb24oc2VyaWVzRGF0dW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIHJhd1Nlcmllc0RhdHVtID0gc2VsZi5fZmluZFJhd1Nlcmllc0RhdHVtQnlOYW1lKHNlcmllc0RhdHVtLm5hbWUsIHNlcmllc05hbWUpO1xuXG4gICAgICAgICAgICBzZXJpZXNEYXR1bS5kYXRhLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJhd1Nlcmllc0RhdHVtKSB7XG4gICAgICAgICAgICAgICAgcmF3U2VyaWVzRGF0dW0uZGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFB1c2ggc2VyaWVzIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVzIC0gdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcHVzaFNlcmllc0RhdGE6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzQXJyYXkodGhpcy5vcmlnaW5hbFJhd0RhdGEuc2VyaWVzKSkge1xuICAgICAgICAgICAgdGhpcy5fcHVzaFZhbHVlcyh0aGlzLm9yaWdpbmFsUmF3RGF0YS5zZXJpZXMsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHRoaXMub3JpZ2luYWxSYXdEYXRhLnNlcmllcywgZnVuY3Rpb24oc2VyaWVzRGF0YSwgc2VyaWVzTmFtZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX3B1c2hWYWx1ZXMoc2VyaWVzRGF0YSwgdmFsdWVzW3Nlcmllc05hbWVdLCBzZXJpZXNOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNoaWZ0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bmFtZTogc3RyaW5nLCBkYXRhOiBBcnJheX0+fSBzZXJpZXNEYXRhIC0gc2VyaWVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWVzTmFtZSAtIHNlcmllcyBuYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hpZnRWYWx1ZXM6IGZ1bmN0aW9uKHNlcmllc0RhdGEsIHNlcmllc05hbWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZXJpZXNEYXRhLCBmdW5jdGlvbihzZXJpZXNEYXR1bSkge1xuICAgICAgICAgICAgdmFyIHJhd1Nlcmllc0RhdHVtID0gc2VsZi5fZmluZFJhd1Nlcmllc0RhdHVtQnlOYW1lKHNlcmllc0RhdHVtLm5hbWUsIHNlcmllc05hbWUpO1xuXG4gICAgICAgICAgICBzZXJpZXNEYXR1bS5kYXRhLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAocmF3U2VyaWVzRGF0dW0pIHtcbiAgICAgICAgICAgICAgICByYXdTZXJpZXNEYXR1bS5kYXRhLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaGlmdCBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaGlmdFNlcmllc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzQXJyYXkodGhpcy5vcmlnaW5hbFJhd0RhdGEuc2VyaWVzKSkge1xuICAgICAgICAgICAgdGhpcy5fc2hpZnRWYWx1ZXModGhpcy5vcmlnaW5hbFJhd0RhdGEuc2VyaWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2godGhpcy5vcmlnaW5hbFJhd0RhdGEuc2VyaWVzLCBmdW5jdGlvbihzZXJpZXNEYXRhLCBzZXJpZXNOYW1lKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2hpZnRWYWx1ZXMoc2VyaWVzRGF0YSwgc2VyaWVzTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZHluYW1pYyBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSAtIGNhdGVnb3J5XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVzIC0gdmFsdWVzXG4gICAgICovXG4gICAgYWRkRHluYW1pY0RhdGE6IGZ1bmN0aW9uKGNhdGVnb3J5LCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5keW5hbWljRGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yeSxcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSBmcm9tIGR5bmFwbWljIGRhdGEuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgYWRkRGF0YUZyb21EeW5hbWljRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXR1bSA9IHRoaXMuZHluYW1pY0RhdGEuc2hpZnQoKTtcblxuICAgICAgICBpZiAoIWRhdHVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wdXNoQ2F0ZWdvcnkoZGF0dW0uY2F0ZWdvcnkpO1xuICAgICAgICB0aGlzLl9wdXNoU2VyaWVzRGF0YShkYXR1bS52YWx1ZXMpO1xuXG4gICAgICAgIHRoaXMuaW5pdERhdGEodGhpcy5yYXdEYXRhKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hpZnQgZGF0YS5cbiAgICAgKi9cbiAgICBzaGlmdERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zaGlmdENhdGVnb3J5KCk7XG4gICAgICAgIHRoaXMuX3NoaWZ0U2VyaWVzRGF0YSgpO1xuXG4gICAgICAgIHRoaXMuaW5pdERhdGEodGhpcy5yYXdEYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgZnJvbSByZW1haW4gZHluYW1pYyBkYXRhLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hpZnRpbmdPcHRpb24gLSB3aGV0aGVyIGhhcyBzaGlmdGluZyBvcHRpb24gb3Igbm90LlxuICAgICAqL1xuICAgIGFkZERhdGFGcm9tUmVtYWluRHluYW1pY0RhdGE6IGZ1bmN0aW9uKHNoaWZ0aW5nT3B0aW9uKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGR5bmFtaWNEYXRhID0gdGhpcy5keW5hbWljRGF0YTtcblxuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhID0gW107XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChkeW5hbWljRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgIHNlbGYuX3B1c2hDYXRlZ29yeShkYXR1bS5jYXRlZ29yeSk7XG4gICAgICAgICAgICBzZWxmLl9wdXNoU2VyaWVzRGF0YShkYXR1bS52YWx1ZXMpO1xuICAgICAgICAgICAgaWYgKHNoaWZ0aW5nT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2hpZnRDYXRlZ29yeSgpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3NoaWZ0U2VyaWVzRGF0YSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmluaXREYXRhKHRoaXMucmF3RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIGFsbCBTZXJpZXNEYXRhTW9kZWwgYnkgc2VyaWVzTmFtZXMsIGFuZCBleGVjdXRlcyBpdGVyYXRlZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2VhY2hCeUFsbFNlcmllc0RhdGFNb2RlbDogZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VyaWVzTmFtZXMgPSB0aGlzLnNlcmllc05hbWVzIHx8IFt0aGlzLmNoYXJ0VHlwZV07XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHNlcmllc05hbWVzLCBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRlZShzZWxmLmdldFNlcmllc0RhdGFNb2RlbChjaGFydFR5cGUpLCBjaGFydFR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB2YWxpZCBhbGwgU2VyaWVzRGF0YU1vZGVsIG9yIG5vdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZhbGlkQWxsU2VyaWVzRGF0YU1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2VhY2hCeUFsbFNlcmllc0RhdGFNb2RlbChmdW5jdGlvbihzZXJpZXNEYXRhTW9kZWwpIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSAhIXNlcmllc0RhdGFNb2RlbC5nZXRHcm91cENvdW50KCk7XG5cbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBTZXJpZXNHcm91cHMuXG4gICAgICogQHJldHVybnMge0FycmF5LjxTZXJpZXNHcm91cD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc0dyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBqb2luZWRHcm91cHMgPSBbXSxcbiAgICAgICAgICAgIHNlcmllc0dyb3VwcztcblxuICAgICAgICB0aGlzLl9lYWNoQnlBbGxTZXJpZXNEYXRhTW9kZWwoZnVuY3Rpb24oc2VyaWVzRGF0YU1vZGVsKSB7XG4gICAgICAgICAgICBzZXJpZXNEYXRhTW9kZWwuZWFjaChmdW5jdGlvbihzZXJpZXNHcm91cCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWpvaW5lZEdyb3Vwc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkR3JvdXBzW2luZGV4XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqb2luZWRHcm91cHNbaW5kZXhdID0gam9pbmVkR3JvdXBzW2luZGV4XS5jb25jYXQoc2VyaWVzR3JvdXAuaXRlbXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlcmllc0dyb3VwcyA9IHR1aS51dGlsLm1hcChqb2luZWRHcm91cHMsIGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlcmllc0dyb3VwKGl0ZW1zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IFNlcmllc0dyb3Vwcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFNlcmllc0dyb3VwPn1cbiAgICAgKi9cbiAgICBnZXRTZXJpZXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VyaWVzR3JvdXBzKSB7XG4gICAgICAgICAgICB0aGlzLnNlcmllc0dyb3VwcyA9IHRoaXMuX21ha2VTZXJpZXNHcm91cHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllc0dyb3VwcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGluZGV4LCBjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VyaWVzRGF0YU1vZGVsKGNoYXJ0VHlwZSkuZ2V0VmFsdWUoZ3JvdXBJbmRleCwgaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdmFsdWVzIHRoYXQgcGlja2VkIHZhbHVlIGZyb20gU2VyaWVzSXRlbXMgb2Ygc3BlY2lmaWMgU2VyaWVzRGF0YU1vZGVsLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVUeXBlIC0gdHlwZSBvZiB2YWx1ZSBsaWtlIHZhbHVlLCB4LCB5LCByLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVWYWx1ZXM6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgdmFsdWVUeXBlKSB7XG4gICAgICAgIHZhciB2YWx1ZXM7XG5cbiAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gY2hhcnRDb25zdC5EVU1NWV9LRVkpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZWFjaEJ5QWxsU2VyaWVzRGF0YU1vZGVsKGZ1bmN0aW9uKHNlcmllc0RhdGFNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoc2VyaWVzRGF0YU1vZGVsLmdldFZhbHVlcyh2YWx1ZVR5cGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzID0gdGhpcy5nZXRTZXJpZXNEYXRhTW9kZWwoY2hhcnRUeXBlKS5nZXRWYWx1ZXModmFsdWVUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB2YWx1ZXMgZnJvbSB2YWx1ZXNNYXAuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBjaGFydFR5cGUgLSB0eXBlIG9mIGNoYXJ0XG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZVR5cGUgLSB0eXBlIG9mIHZhbHVlIGxpa2UgdmFsdWUsIHgsIHksIHIuXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIGdldFZhbHVlczogZnVuY3Rpb24oY2hhcnRUeXBlLCB2YWx1ZVR5cGUpIHtcbiAgICAgICAgdmFyIG1hcEtleTtcblxuICAgICAgICBjaGFydFR5cGUgPSBjaGFydFR5cGUgfHwgY2hhcnRDb25zdC5EVU1NWV9LRVk7XG5cbiAgICAgICAgbWFwS2V5ID0gY2hhcnRUeXBlICsgdmFsdWVUeXBlO1xuXG4gICAgICAgIGlmICghdGhpcy52YWx1ZXNNYXBbbWFwS2V5XSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXNNYXBbbWFwS2V5XSA9IHRoaXMuX2NyZWF0ZVZhbHVlcyhjaGFydFR5cGUsIHZhbHVlVHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNNYXBbbWFwS2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IG1heCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IGNoYXJ0VHlwZSAtIHR5cGUgb2YgY2hhcnRcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlVHlwZSAtIHR5cGUgb2YgdmFsdWUgbGlrZSB2YWx1ZSwgeCwgeSwgclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0TWF4VmFsdWU6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgdmFsdWVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXgodGhpcy5nZXRWYWx1ZXMoY2hhcnRUeXBlLCB2YWx1ZVR5cGUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGZvcm1hdHRlZCBtYXggdmFsdWUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBjaGFydFR5cGUgLSB0eXBlIG9mIGNoYXJ0XG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBhcmVhVHlwZSAtIHR5cGUgb2YgYXJlYSBsaWtlIGNpcmNsZUxlZ2VuZFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVUeXBlIC0gdHlwZSBvZiB2YWx1ZSBsaWtlIHZhbHVlLCB4LCB5LCByXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IG51bWJlcn1cbiAgICAgKi9cbiAgICBnZXRGb3JtYXR0ZWRNYXhWYWx1ZTogZnVuY3Rpb24oY2hhcnRUeXBlLCBhcmVhVHlwZSwgdmFsdWVUeXBlKSB7XG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IHRoaXMuZ2V0TWF4VmFsdWUoY2hhcnRUeXBlLCB2YWx1ZVR5cGUpO1xuICAgICAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5nZXRGb3JtYXRGdW5jdGlvbnMoKTtcblxuICAgICAgICByZXR1cm4gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZShtYXhWYWx1ZSwgZm9ybWF0RnVuY3Rpb25zLCBjaGFydFR5cGUsIGFyZWFUeXBlLCB2YWx1ZVR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZSBTZXJpZXNHcm91cCBvZiBhbGwgU2VyaWVzRGF0YU1vZGVsLCBhbmQgZXhlY3V0ZXMgaXRlcmF0ZWUgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgaXRlcmF0ZWUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1Bpdm90XSAtIHdoZXRoZXIgcGl2b3Qgb3Igbm90XG4gICAgICovXG4gICAgZWFjaEJ5U2VyaWVzR3JvdXA6IGZ1bmN0aW9uKGl0ZXJhdGVlLCBpc1Bpdm90KSB7XG4gICAgICAgIHRoaXMuX2VhY2hCeUFsbFNlcmllc0RhdGFNb2RlbChmdW5jdGlvbihzZXJpZXNEYXRhTW9kZWwsIGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgc2VyaWVzRGF0YU1vZGVsLmVhY2goZnVuY3Rpb24oc2VyaWVzR3JvdXAsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZShzZXJpZXNHcm91cCwgZ3JvdXBJbmRleCwgY2hhcnRUeXBlKTtcbiAgICAgICAgICAgIH0sIGlzUGl2b3QpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGljayBsZWdlbmQgbGFiZWwuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGxhYmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGlja0xlZ2VuZExhYmVsOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm5hbWUgPyB0dWkudXRpbC5lbmNvZGVIVE1MRW50aXR5KGl0ZW0ubmFtZSkgOiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIGxlZ2VuZCBsYWJlbHMgZnJvbSByYXcgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IGxhYmVsc1xuICAgICAqL1xuICAgIF9waWNrTGVnZW5kTGFiZWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VyaWVzRGF0YSA9IHRoaXMucmF3RGF0YS5zZXJpZXM7XG4gICAgICAgIHZhciBsZWdlbmRMYWJlbHM7XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzQXJyYXkoc2VyaWVzRGF0YSkpIHtcbiAgICAgICAgICAgIGxlZ2VuZExhYmVscyA9IHR1aS51dGlsLm1hcChzZXJpZXNEYXRhLCB0aGlzLl9waWNrTGVnZW5kTGFiZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVnZW5kTGFiZWxzID0ge307XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHNlcmllc0RhdGEsIGZ1bmN0aW9uKHNlcmllc0RhdHVtLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kTGFiZWxzW3R5cGVdID0gdHVpLnV0aWwubWFwKHNlcmllc0RhdHVtLCBzZWxmLl9waWNrTGVnZW5kTGFiZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZWdlbmRMYWJlbHMgPSB0dWkudXRpbC5maWx0ZXIobGVnZW5kTGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLmlzRXhpc3R5KGxhYmVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGxlZ2VuZExhYmVscztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxlZ2VuZCBsYWJlbHMuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPiB8IHtjb2x1bW46ID9BcnJheS48c3RyaW5nPiwgbGluZTogP0FycmF5LjxzdHJpbmc+fX0gbGVnZW5kIGxhYmVsc1xuICAgICAqL1xuICAgIGdldExlZ2VuZExhYmVsczogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIGlmICghdGhpcy5sZWdlbmRMYWJlbHMpIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kTGFiZWxzID0gdGhpcy5fcGlja0xlZ2VuZExhYmVscygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kTGFiZWxzW2NoYXJ0VHlwZV0gfHwgdGhpcy5sZWdlbmRMYWJlbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGVnZW5kIGRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBsYWJlbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGVnZW5kRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsZWdlbmRMYWJlbHMgPSB0aGlzLmdldExlZ2VuZExhYmVscygpLFxuICAgICAgICAgICAgc2VyaWVzTmFtZXMgPSB0aGlzLnNlcmllc05hbWVzIHx8IFt0aGlzLmNoYXJ0VHlwZV0sXG4gICAgICAgICAgICBsZWdlbmRMYWJlbHNNYXAsIGxlZ2VuZERhdGE7XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzQXJyYXkobGVnZW5kTGFiZWxzKSkge1xuICAgICAgICAgICAgbGVnZW5kTGFiZWxzTWFwID0gW3RoaXMuY2hhcnRUeXBlXTtcbiAgICAgICAgICAgIGxlZ2VuZExhYmVsc01hcFt0aGlzLmNoYXJ0VHlwZV0gPSBsZWdlbmRMYWJlbHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXJpZXNOYW1lcyA9IHRoaXMuc2VyaWVzTmFtZXM7XG4gICAgICAgICAgICBsZWdlbmRMYWJlbHNNYXAgPSBsZWdlbmRMYWJlbHM7XG4gICAgICAgIH1cblxuICAgICAgICBsZWdlbmREYXRhID0gdHVpLnV0aWwubWFwKHNlcmllc05hbWVzLCBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAobGVnZW5kTGFiZWxzTWFwW2NoYXJ0VHlwZV0sIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgbGVnZW5kRGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBsZWdlbmQgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHtjaGFydFR5cGU6IHN0cmluZywgbGFiZWw6IHN0cmluZ30+fSBsZWdlbmQgZGF0YVxuICAgICAqL1xuICAgIGdldExlZ2VuZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMubGVnZW5kRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5sZWdlbmREYXRhID0gdGhpcy5fbWFrZUxlZ2VuZERhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5vcmlnaW5hbExlZ2VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxMZWdlbmREYXRhID0gdGhpcy5sZWdlbmREYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IG9yaWdpbmFsIGxlZ2VuZCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e2NoYXJ0VHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nfT59XG4gICAgICovXG4gICAgZ2V0T3JpZ2luYWxMZWdlbmREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxMZWdlbmREYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGVnZW5kIGl0ZW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHJldHVybnMge3tjaGFydFR5cGU6IHN0cmluZywgbGFiZWw6IHN0cmluZ319IGxlZ2VuZCBkYXRhXG4gICAgICovXG4gICAgZ2V0TGVnZW5kSXRlbTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGVnZW5kRGF0YSgpW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGZvcm1hdCBmdW5jdGlvbnMuXG4gICAgICogQHJldHVybnMge0FycmF5LjxmdW5jdGlvbj59IGZ1bmN0aW9uc1xuICAgICAqL1xuICAgIGdldEZvcm1hdEZ1bmN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5mb3JtYXRGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5fZmluZEZvcm1hdEZ1bmN0aW9ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0RnVuY3Rpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlyc3QgbGFiZWwgb2YgU2VyaWVzSXRlbS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IGNoYXJ0VHlwZSBjaGFydFR5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRGaXJzdEl0ZW1MYWJlbDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlcmllc0RhdGFNb2RlbChjaGFydFR5cGUpLmdldEZpcnN0SXRlbUxhYmVsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgbWF4IGxlbmd0aCB1bmRlciBwb2ludC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB2YWx1ZXMgY2hhcnQgdmFsdWVzXG4gICAgICogQHJldHVybnMge251bWJlcn0gbWF4IGxlbmd0aCB1bmRlciBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BpY2tNYXhMZW5VbmRlclBvaW50OiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgdmFyIG1heCA9IDA7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0dWkudXRpbC5nZXREZWNpbWFsTGVuZ3RoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChsZW4gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgemVybyBmaWxsIGZvcm1hdCBvciBub3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1plcm9GaWxsOiBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdC5sZW5ndGggPiAyICYmIGZvcm1hdC5jaGFyQXQoMCkgPT09ICcwJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBkZWNpbWFsIGZvcm1hdCBvciBub3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0RlY2ltYWw6IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgaW5kZXhPZiA9IGZvcm1hdC5pbmRleE9mKCcuJyk7XG5cbiAgICAgICAgcmV0dXJuIGluZGV4T2YgPiAtMSAmJiBpbmRleE9mIDwgZm9ybWF0Lmxlbmd0aCAtIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY29tbWEgZm9ybWF0IG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IGZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ29tbWE6IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0LmluZGV4T2YoJywnKSA+IC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdG8gemVybyBmaWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gbGVuZ3RoIG9mIHJlc3VsdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb3JtYXRUb1plcm9GaWxsOiBmdW5jdGlvbihsZW4sIHZhbHVlKSB7XG4gICAgICAgIHZhciBpc01pbnVzID0gdmFsdWUgPCAwO1xuXG4gICAgICAgIHZhbHVlID0gcmVuZGVyVXRpbC5mb3JtYXRUb1plcm9GaWxsKE1hdGguYWJzKHZhbHVlKSwgbGVuKTtcblxuICAgICAgICByZXR1cm4gKGlzTWludXMgPyAnLScgOiAnJykgKyB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRvIERlY2ltYWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbiBsZW5ndGggb2YgdW5kZXIgZGVjaW1hbCBwb2ludFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb3JtYXRUb0RlY2ltYWw6IGZ1bmN0aW9uKGxlbiwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclV0aWwuZm9ybWF0VG9EZWNpbWFsKHZhbHVlLCBsZW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHNpbXBsZSB0eXBlIGZvcm1hdCBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIHNpbXBsZSBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPGZ1bmN0aW9uPn1cbiAgICAgKi9cbiAgICBfZmluZFNpbXBsZVR5cGVGb3JtYXRGdW5jdGlvbnM6IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgZnVuY3MgPSBbXTtcbiAgICAgICAgdmFyIGxlbjtcblxuICAgICAgICBpZiAodGhpcy5faXNEZWNpbWFsKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGxlbiA9IHRoaXMuX3BpY2tNYXhMZW5VbmRlclBvaW50KFtmb3JtYXRdKTtcbiAgICAgICAgICAgIGZ1bmNzID0gW3R1aS51dGlsLmJpbmQodGhpcy5fZm9ybWF0VG9EZWNpbWFsLCB0aGlzLCBsZW4pXTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc1plcm9GaWxsKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGxlbiA9IGZvcm1hdC5sZW5ndGg7XG4gICAgICAgICAgICBmdW5jcyA9IFt0dWkudXRpbC5iaW5kKHRoaXMuX2Zvcm1hdFRvWmVyb0ZpbGwsIHRoaXMsIGxlbildO1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faXNDb21tYShmb3JtYXQpKSB7XG4gICAgICAgICAgICBmdW5jcy5wdXNoKHJlbmRlclV0aWwuZm9ybWF0VG9Db21tYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgZm9ybWF0IGZ1bmN0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb25bXX0gZnVuY3Rpb25zXG4gICAgICovXG4gICAgX2ZpbmRGb3JtYXRGdW5jdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdHVpLnV0aWwucGljayh0aGlzLm9wdGlvbnMsICdjaGFydCcsICdmb3JtYXQnKTtcbiAgICAgICAgdmFyIGZ1bmNzID0gW107XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzRnVuY3Rpb24oZm9ybWF0KSkge1xuICAgICAgICAgICAgZnVuY3MgPSBbZm9ybWF0XTtcbiAgICAgICAgfSBlbHNlIGlmICh0dWkudXRpbC5pc1N0cmluZyhmb3JtYXQpKSB7XG4gICAgICAgICAgICBmdW5jcyA9IHRoaXMuX2ZpbmRTaW1wbGVUeXBlRm9ybWF0RnVuY3Rpb25zKGZvcm1hdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbXVsdGlsaW5lIGNhdGVnb3J5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSBjYXRlZ29yeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFdpZHRoIGxpbWl0IHdpZHRoXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbXVsdGlsaW5lIGNhdGVnb3J5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU11bHRpbGluZUNhdGVnb3J5OiBmdW5jdGlvbihjYXRlZ29yeSwgbGltaXRXaWR0aCwgdGhlbWUpIHtcbiAgICAgICAgdmFyIHdvcmRzID0gU3RyaW5nKGNhdGVnb3J5KS5zcGxpdCgvXFxzKy8pLFxuICAgICAgICAgICAgbGluZVdvcmRzID0gd29yZHNbMF0sXG4gICAgICAgICAgICBsaW5lcyA9IFtdO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh3b3Jkcy5zbGljZSgxKSwgZnVuY3Rpb24od29yZCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGluZVdvcmRzICsgJyAnICsgd29yZCwgdGhlbWUpO1xuXG4gICAgICAgICAgICBpZiAod2lkdGggPiBsaW1pdFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChsaW5lV29yZHMpO1xuICAgICAgICAgICAgICAgIGxpbmVXb3JkcyA9IHdvcmQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmVXb3JkcyArPSAnICcgKyB3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobGluZVdvcmRzKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmVXb3Jkcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZXMuam9pbignPGJyPicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbXVsdGlsaW5lIGNhdGVnb3JpZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0V2lkdGggbGltaXQgd2lkdGhcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjwobnVtYmVyIHwgc3RyaW5nKT59IHhBeGlzTGFiZWxzIGxhYmVscyBvZiB4QXhpc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gbXVsdGlsaW5lIGNhdGVnb3JpZXNcbiAgICAgKi9cbiAgICBnZXRNdWx0aWxpbmVDYXRlZ29yaWVzOiBmdW5jdGlvbihsaW1pdFdpZHRoLCB0aGVtZSwgeEF4aXNMYWJlbHMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5tdWx0aWxpbmVDYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICB0aGlzLm11bHRpbGluZUNhdGVnb3JpZXMgPSB0dWkudXRpbC5tYXAoeEF4aXNMYWJlbHMsIGZ1bmN0aW9uKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX21ha2VNdWx0aWxpbmVDYXRlZ29yeShjYXRlZ29yeSwgbGltaXRXaWR0aCwgdGhlbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aWxpbmVDYXRlZ29yaWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSByYXRpb3Mgb2YgcGllIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSB0eXBlIG9mIGNoYXJ0LlxuICAgICAqL1xuICAgIGFkZERhdGFSYXRpb3NPZlBpZUNoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgdGhpcy5nZXRTZXJpZXNEYXRhTW9kZWwoY2hhcnRUeXBlKS5hZGREYXRhUmF0aW9zT2ZQaWVDaGFydCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSByYXRpb3MgZm9yIGNoYXJ0IG9mIGNvb3JkaW5hdGUgdHlwZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydC5cbiAgICAgKiBAcGFyYW0ge3t4OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgeToge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19fSBsaW1pdE1hcCAtIGxpbWl0IG1hcFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hhc1JhZGl1c10gLSB3aGV0aGVyIGhhcyByYWRpdXMgb3Igbm90XG4gICAgICovXG4gICAgYWRkRGF0YVJhdGlvc0ZvckNvb3JkaW5hdGVUeXBlOiBmdW5jdGlvbihjaGFydFR5cGUsIGxpbWl0TWFwLCBoYXNSYWRpdXMpIHtcbiAgICAgICAgdGhpcy5nZXRTZXJpZXNEYXRhTW9kZWwoY2hhcnRUeXBlKS5hZGREYXRhUmF0aW9zRm9yQ29vcmRpbmF0ZVR5cGUobGltaXRNYXAsIGhhc1JhZGl1cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBzdGFydCB2YWx1ZSB0byBhbGwgc2VyaWVzIGl0ZW0uXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgLSBsaW1pdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSBjaGFydCB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkU3RhcnRWYWx1ZVRvQWxsU2VyaWVzSXRlbTogZnVuY3Rpb24obGltaXQsIGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgICAgIGlmIChsaW1pdC5taW4gPj0gMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBsaW1pdC5taW47XG4gICAgICAgIH0gZWxzZSBpZiAobGltaXQubWF4IDw9IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gbGltaXQubWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZXRTZXJpZXNEYXRhTW9kZWwoY2hhcnRUeXBlKS5hZGRTdGFydFZhbHVlVG9BbGxTZXJpZXNJdGVtKHN0YXJ0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgcGVyY2VudCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgYXhpcyBsaW1pdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja1R5cGUgc3RhY2tUeXBlIG9wdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkRGF0YVJhdGlvczogZnVuY3Rpb24obGltaXQsIHN0YWNrVHlwZSwgY2hhcnRUeXBlKSB7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLmdldFNlcmllc0RhdGFNb2RlbChjaGFydFR5cGUpO1xuXG4gICAgICAgIHRoaXMuX2FkZFN0YXJ0VmFsdWVUb0FsbFNlcmllc0l0ZW0obGltaXQsIGNoYXJ0VHlwZSk7XG4gICAgICAgIHNlcmllc0RhdGFNb2RlbC5hZGREYXRhUmF0aW9zKGxpbWl0LCBzdGFja1R5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSByYXRpb3MgZm9yIHRyZWVtYXAgY2hhcnQuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgLSBsaW1pdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSBjaGFydCB0eXBlXG4gICAgICovXG4gICAgYWRkRGF0YVJhdGlvc0ZvclRyZWVtYXBDaGFydDogZnVuY3Rpb24obGltaXQsIGNoYXJ0VHlwZSkge1xuICAgICAgICB0aGlzLmdldFNlcmllc0RhdGFNb2RlbChjaGFydFR5cGUpLmFkZERhdGFSYXRpb3MobGltaXQpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFQcm9jZXNzb3I7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YSBwcm9jZXNzb3IgZm9yIG1hcCBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YVByb2Nlc3NvciA9IHJlcXVpcmUoJy4vZGF0YVByb2Nlc3NvcicpO1xudmFyIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcblxuLyoqXG4gKiBSYXcgc2VyaWVzIGRhdGEuXG4gKiBAdHlwZWRlZiB7QXJyYXkuPHtjb2RlOiBzdHJpbmcsIG5hbWU6ID9zdHJpbmcsIGRhdGE6IG51bWJlcn0+fSByYXdTZXJpZXNEYXRhXG4gKi9cblxuLyoqXG4gKiBWYWx1ZSBtYXAuXG4gKiBAdHlwZWRlZiB7e3ZhbHVlOiBudW1iZXIsIGxhYmVsOiBzdHJpbmcsIG5hbWU6ID9zdHJpbmd9fSB2YWx1ZU1hcFxuICovXG5cbnZhciBNYXBDaGFydERhdGFQcm9jZXNzb3IgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhEYXRhUHJvY2Vzc29yLCAvKiogQGxlbmRzIE1hcENoYXJ0RGF0YVByb2Nlc3Nvci5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogRGF0YSBwcm9jZXNzb3IgZm9yIG1hcCBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBNYXBDaGFydERhdGFQcm9jZXNzb3JcbiAgICAgKiBAZXh0ZW5kcyBEYXRhUHJvY2Vzc29yXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIERhdGFQcm9jZXNzb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHJhdyBkYXRhLlxuICAgICAqIEBwYXJhbSB7e3NlcmllczogcmF3U2VyaWVzRGF0YX19IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKi9cbiAgICBpbml0RGF0YTogZnVuY3Rpb24ocmF3RGF0YSkge1xuICAgICAgICB0aGlzLnJhd0RhdGEgPSByYXdEYXRhO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YWx1ZSBtYXBcbiAgICAgICAgICogQHR5cGUge3ZhbHVlTWFwfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZU1hcCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdmFsdWUgbWFwLlxuICAgICAqIEByZXR1cm5zIHt2YWx1ZU1hcH0gdmFsdWUgbWFwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZhbHVlTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJhd1Nlcmllc0RhdGEgPSB0aGlzLnJhd0RhdGEuc2VyaWVzO1xuICAgICAgICB2YXIgdmFsdWVNYXAgPSB7fTtcbiAgICAgICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHRoaXMuX2ZpbmRGb3JtYXRGdW5jdGlvbnMoKTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkocmF3U2VyaWVzRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdHVtLmRhdGEsXG4gICAgICAgICAgICAgICAgbGFiZWw6IHJlbmRlclV0aWwuZm9ybWF0VmFsdWUoZGF0dW0uZGF0YSwgZm9ybWF0RnVuY3Rpb25zLCAnbWFwJywgJ3NlcmllcycpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZGF0dW0ubmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5uYW1lID0gZGF0dW0ubmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdHVtLmxhYmVsQ29vcmRpbmF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5sYWJlbENvb3JkaW5hdGUgPSBkYXR1bS5sYWJlbENvb3JkaW5hdGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlTWFwW2RhdHVtLmNvZGVdID0gcmVzdWx0O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmFsdWVNYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB2YWx1ZSBtYXAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZU1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZU1hcCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZU1hcCA9IHRoaXMuX21ha2VWYWx1ZU1hcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVNYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSBwaWNrZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldFZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5wbHVjayh0aGlzLmdldFZhbHVlTWFwKCksICd2YWx1ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWVNYXAgZGF0dW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgbWFwIGNvZGVcbiAgICAgKiBAcmV0dXJucyB7e2NvZGU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsYWJlbDogbnVtYmVyLFxuICAgICAqICAgICAgICAgICAgICBsYWJlbENvb3JkaW5hdGU6IHt4OiBudW1iZXIsIHk6IG51bWJlcn19fSB2YWx1ZU1hcCBkYXR1bVxuICAgICAqL1xuICAgIGdldFZhbHVlTWFwRGF0dW06IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVNYXAoKVtjb2RlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zIG9mIG1hcCBjaGFydC5cbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBheGlzIGxpbWl0XG4gICAgICovXG4gICAgYWRkRGF0YVJhdGlvczogZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgdmFyIG1pbiA9IGxpbWl0Lm1pbixcbiAgICAgICAgICAgIG1heCA9IGxpbWl0Lm1heCAtIG1pbjtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh0aGlzLmdldFZhbHVlTWFwKCksIGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgbWFwLnJhdGlvID0gKG1hcC52YWx1ZSAtIG1pbikgLyBtYXg7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENoYXJ0RGF0YVByb2Nlc3NvcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBTZXJpZXNEYXRhTW9kZWwgaXMgYmFzZSBtb2RlbCBmb3IgZHJhd2luZyBncmFwaCBvZiBjaGFydCBzZXJpZXMgYXJlYSxcbiAqICAgICAgICAgICAgICAgICAgYW5kIGNyZWF0ZSBmcm9tIHJhd1Nlcmllc0RhdGEgYnkgdXNlcixcbiAqIFNlcmllc0RhdGFNb2RlbC5ncm91cHMgaGFzIFNlcmllc0dyb3Vwcy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJhdyBzZXJpZXMgZGF0dW0uXG4gKiBAdHlwZWRlZiB7e25hbWU6ID9zdHJpbmcsIGRhdGE6IEFycmF5LjxudW1iZXI+LCBzdGFjazogP3N0cmluZ319IHJhd1Nlcmllc0RhdHVtXG4gKi9cblxuLyoqXG4gKiBSYXcgc2VyaWVzIGRhdGEuXG4gKiBAdHlwZWRlZiB7QXJyYXkuPHJhd1Nlcmllc0RhdHVtPn0gcmF3U2VyaWVzRGF0YVxuICovXG5cbi8qKlxuICogR3JvdXBzLlxuICogQHR5cGVkZWYge0FycmF5LjxTZXJpZXNHcm91cD59IGdyb3Vwc1xuICovXG5cbi8qKlxuICogU2VyaWVzR3JvdXAgaXMgYSBlbGVtZW50IG9mIFNlcmllc0RhdGFNb2RlbC5ncm91cHMuXG4gKiBTZXJpZXNHcm91cC5pdGVtcyBoYXMgU2VyaWVzSXRlbS5cbiAqL1xuXG4vKipcbiAqIFNlcmllc0l0ZW0gaXMgYSBlbGVtZW50IG9mIFNlcmllc0dyb3VwLml0ZW1zLlxuICogU2VyaWVzSXRlbSBoYXMgcHJvY2Vzc2VkIHRlcm1pbmFsIGRhdGEgbGlrZSB2YWx1ZSwgcmF0aW8sIGV0Yy5cbiAqL1xuXG52YXIgU2VyaWVzR3JvdXAgPSByZXF1aXJlKCcuL3Nlcmllc0dyb3VwJyk7XG52YXIgU2VyaWVzSXRlbSA9IHJlcXVpcmUoJy4vc2VyaWVzSXRlbScpO1xudmFyIFNlcmllc0l0ZW1Gb3JDb29yZGluYXRlVHlwZSA9IHJlcXVpcmUoJy4vc2VyaWVzSXRlbUZvckNvb3JkaW5hdGVUeXBlJyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcbnZhciBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxjdWxhdG9yJyk7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG52YXIgU2VyaWVzRGF0YU1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBTZXJpZXNEYXRhTW9kZWwucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIFNlcmllc0RhdGFNb2RlbCBpcyBiYXNlIG1vZGVsIGZvciBkcmF3aW5nIGdyYXBoIG9mIGNoYXJ0IHNlcmllcyBhcmVhLFxuICAgICAqICAgICAgYW5kIGNyZWF0ZSBmcm9tIHJhd1Nlcmllc0RhdGEgYnkgdXNlci5cbiAgICAgKiBTZXJpZXNEYXRhTW9kZWwuZ3JvdXBzIGhhcyBTZXJpZXNHcm91cHMuXG4gICAgICogQGNvbnN0cnVjdHMgU2VyaWVzRGF0YU1vZGVsXG4gICAgICogQHBhcmFtIHtyYXdTZXJpZXNEYXRhfSByYXdTZXJpZXNEYXRhIHJhdyBzZXJpZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxmdW5jdGlvbj59IGZvcm1hdEZ1bmN0aW9ucyBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3U2VyaWVzRGF0YSwgY2hhcnRUeXBlLCBvcHRpb25zLCBmb3JtYXRGdW5jdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCBvcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmdW5jdGlvbnMgZm9yIGZvcm1hdHRpbmdcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxmdW5jdGlvbj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvcm1hdEZ1bmN0aW9ucyA9IGZvcm1hdEZ1bmN0aW9ucztcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmF3RGF0YS5zZXJpZXNcbiAgICAgICAgICogQHR5cGUge3Jhd1Nlcmllc0RhdGF9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhd1Nlcmllc0RhdGEgPSByYXdTZXJpZXNEYXRhIHx8IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiYXNlR3JvdXBzIGlzIGJhc2UgZGF0YSBmb3IgbWFraW5nIFNlcmllc0dyb3Vwcy5cbiAgICAgICAgICogU2VyaWVzR3JvdXBzIGlzIG1hZGUgYnkgcGl2b3RlZCBiYXNlR3JvdXBzLCBsZiBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS5BcnJheTxTZXJpZXNJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmFzZUdyb3VwcyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdyb3VwcyBoYXMgU2VyaWVzR3JvdXBzLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPFNlcmllc0dyb3VwPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWFwIG9mIHZhbHVlcyBieSB2YWx1ZSB0eXBlIGxpa2UgdmFsdWUsIHgsIHksIHIuXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3QuPHN0cmluZywgQXJyYXkuPG51bWJlcj4+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZXNNYXAgPSB7fTtcblxuICAgICAgICB0aGlzLl9yZW1vdmVSYW5nZVZhbHVlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSByYW5nZSB2YWx1ZSBvZiBpdGVtLCBpZiBoYXMgc3RhY2tUeXBlIG9wdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVSYW5nZVZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc09wdGlvbiA9IHR1aS51dGlsLnBpY2sodGhpcy5vcHRpb25zLCAnc2VyaWVzJykgfHwge307XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0FsbG93UmFuZ2VEYXRhKHRoaXMuY2hhcnRUeXBlKSAmJlxuICAgICAgICAgICAgIXByZWRpY2F0ZS5pc1ZhbGlkU3RhY2tPcHRpb24oc2VyaWVzT3B0aW9uLnN0YWNrVHlwZSkgJiYgIXNlcmllc09wdGlvbi5zcGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLnJhd1Nlcmllc0RhdGEsIGZ1bmN0aW9uKHJhd0l0ZW0pIHtcbiAgICAgICAgICAgIGlmICghdHVpLnV0aWwuaXNBcnJheShyYXdJdGVtLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHJhd0l0ZW0uZGF0YSwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmF3SXRlbS5kYXRhW2luZGV4XSA9IGNvbmNhdC5hcHBseSh2YWx1ZSlbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBiYXNlIGdyb3Vwcy5cbiAgICAgKiBCYXNlIGdyb3VwcyBpcyB0d28tZGltZW5zaW9uYWwgYXJyYXkgYnkgc2VyaWVzSXRlbXMuXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48KFNlcmllc0l0ZW0gfCBTZXJpZXNJdGVtRm9yQ29vcmRpbmF0ZVR5cGUpPj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQmFzZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIFNlcmllc0l0ZW1DbGFzcztcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzQ29vcmRpbmF0ZVR5cGVDaGFydCh0aGlzLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIFNlcmllc0l0ZW1DbGFzcyA9IFNlcmllc0l0ZW1Gb3JDb29yZGluYXRlVHlwZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFNlcmllc0l0ZW1DbGFzcyA9IFNlcmllc0l0ZW07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHRoaXMucmF3U2VyaWVzRGF0YSwgZnVuY3Rpb24ocmF3RGF0dW0pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXM7XG5cbiAgICAgICAgICAgIGlmICh0dWkudXRpbC5pc0FycmF5KHJhd0RhdHVtKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHJhd0RhdHVtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBjb25jYXQuYXBwbHkocmF3RGF0dW0uZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2VyaWVzSXRlbUNsYXNzKHZhbHVlLCByYXdEYXR1bS5zdGFjaywgc2VsZi5mb3JtYXRGdW5jdGlvbnMsIHNlbGYuY2hhcnRUeXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJhc2UgZ3JvdXBzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS5BcnJheS48U2VyaWVzSXRlbT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QmFzZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5iYXNlR3JvdXBzKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VHcm91cHMgPSB0aGlzLl9jcmVhdGVCYXNlR3JvdXBzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlR3JvdXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgU2VyaWVzR3JvdXBzIGZyb20gcmF3RGF0YS5zZXJpZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1Bpdm90IC0gd2hldGhlciBwaXZvdCBvciBub3QuXG4gICAgICogQHJldHVybnMge0FycmF5LjxTZXJpZXNHcm91cD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlU2VyaWVzR3JvdXBzRnJvbVJhd0RhdGE6IGZ1bmN0aW9uKGlzUGl2b3QpIHtcbiAgICAgICAgdmFyIGJhc2VHcm91cHMgPSB0aGlzLl9nZXRCYXNlR3JvdXBzKCk7XG5cbiAgICAgICAgaWYgKGlzUGl2b3QpIHtcbiAgICAgICAgICAgIGJhc2VHcm91cHMgPSB0dWkudXRpbC5waXZvdChiYXNlR3JvdXBzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoYmFzZUdyb3VwcywgZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VyaWVzR3JvdXAoaXRlbXMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IFNlcmllc0dyb3Vwcy5cbiAgICAgKiBAcmV0dXJucyB7KEFycmF5LjxTZXJpZXNHcm91cD58b2JqZWN0KX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTZXJpZXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JvdXBzKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwcyA9IHRoaXMuX2NyZWF0ZVNlcmllc0dyb3Vwc0Zyb21SYXdEYXRhKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZ3JvdXAgY291bnQuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRHcm91cENvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNlcmllc0dyb3VwcygpLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHBpdm90IGdyb3Vwcy5cbiAgICAgKiBAcmV0dXJucyB7KEFycmF5LjxTZXJpZXNHcm91cD58b2JqZWN0KX1cbiAgICAgKi9cbiAgICBfZ2V0UGl2b3RHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucGl2b3RHcm91cHMpIHtcbiAgICAgICAgICAgIHRoaXMucGl2b3RHcm91cHMgPSB0aGlzLl9jcmVhdGVTZXJpZXNHcm91cHNGcm9tUmF3RGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGl2b3RHcm91cHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBTZXJpZXNHcm91cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzUGl2b3RdIC0gd2hldGhlciBwaXZvdCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7U2VyaWVzR3JvdXB9XG4gICAgICovXG4gICAgZ2V0U2VyaWVzR3JvdXA6IGZ1bmN0aW9uKGluZGV4LCBpc1Bpdm90KSB7XG4gICAgICAgIHJldHVybiBpc1Bpdm90ID8gdGhpcy5fZ2V0UGl2b3RHcm91cHMoKVtpbmRleF0gOiB0aGlzLl9nZXRTZXJpZXNHcm91cHMoKVtpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmaXJzdCBTZXJpZXNHcm91cC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1Bpdm90XSAtIHdoZXRoZXIgcGl2b3Qgb3Igbm90XG4gICAgICogQHJldHVybnMge1Nlcmllc0dyb3VwfVxuICAgICAqL1xuICAgIGdldEZpcnN0U2VyaWVzR3JvdXA6IGZ1bmN0aW9uKGlzUGl2b3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VyaWVzR3JvdXAoMCwgaXNQaXZvdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmaXJzdCBsYWJlbCBvZiBTZXJpZXNJdGVtLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqL1xuICAgIGdldEZpcnN0SXRlbUxhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rmlyc3RTZXJpZXNHcm91cCgpLmdldEZpcnN0U2VyaWVzSXRlbSgpLmxhYmVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VyaWVzIGl0ZW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggLSBpbmRleCBvZiBzZXJpZXMgZ3JvdXBzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygc2VyaWVzIGl0ZW1zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNQaXZvdF0gLSB3aGV0aGVyIHBpdm90IG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtTZXJpZXNJdGVtfVxuICAgICAqL1xuICAgIGdldFNlcmllc0l0ZW06IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGluZGV4LCBpc1Bpdm90KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlcmllc0dyb3VwKGdyb3VwSW5kZXgsIGlzUGl2b3QpLmdldFNlcmllc0l0ZW0oaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlyc3Qgc2VyaWVzIGl0ZW0uXG4gICAgICogQHJldHVybnMge1Nlcmllc0l0ZW19XG4gICAgICovXG4gICAgZ2V0Rmlyc3RTZXJpZXNJdGVtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VyaWVzSXRlbSgwLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IC0gaW5kZXggb2Ygc2VyaWVzIGdyb3Vwc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIHNlcmllcyBpdGVtc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlcmllc0l0ZW0oZ3JvdXBJbmRleCwgaW5kZXgpLnZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVUeXBlIC0gdmFsdWUgdHlwZSBsaWtlIHZhbHVlLCB4LCB5LCByLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0TWluVmFsdWU6IGZ1bmN0aW9uKHZhbHVlVHlwZSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWluKHRoaXMuZ2V0VmFsdWVzKHZhbHVlVHlwZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVUeXBlIC0gdmFsdWUgdHlwZSBsaWtlIHZhbHVlLCB4LCB5LCByLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0TWF4VmFsdWU6IGZ1bmN0aW9uKHZhbHVlVHlwZSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWF4KHRoaXMuZ2V0VmFsdWVzKHZhbHVlVHlwZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZSBzZXJpZXNHcm91cHMsIGFuZCByZXR1cm5zIHRvIGZvdW5kIFNlcmllc0l0ZW0gYnkgcmVzdWx0IG9mIGV4ZWN1dGlvbiBzZXJpZXNHcm91cC5maW5kIHdpdGggY29uZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiAtIGNvbmRpdGlvbiBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtTZXJpZXNJdGVtfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRTZXJpZXNJdGVtOiBmdW5jdGlvbihjb25kaXRpb24pIHtcbiAgICAgICAgdmFyIGZvdW5kSXRlbTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICAgIGZvdW5kSXRlbSA9IHNlcmllc0dyb3VwLmZpbmQoY29uZGl0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuICFmb3VuZEl0ZW07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmb3VuZEl0ZW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgU2VyaWVzSXRlbSBieSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVUeXBlIC0gdmFsdWUgdHlwZSBsaWtlIHZhbHVlLCB4LCB5LCByLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIGNvbXBhcmluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiAtIGNvbmRpdGlvbiBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtTZXJpZXNJdGVtfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRTZXJpZXNJdGVtQnlWYWx1ZTogZnVuY3Rpb24odmFsdWVUeXBlLCB2YWx1ZSwgY29uZGl0aW9uKSB7XG4gICAgICAgIGNvbmRpdGlvbiA9IGNvbmRpdGlvbiB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZFNlcmllc0l0ZW0oZnVuY3Rpb24oc2VyaWVzSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmllc0l0ZW0gJiYgKHNlcmllc0l0ZW1bdmFsdWVUeXBlXSA9PT0gdmFsdWUpICYmIGNvbmRpdGlvbihzZXJpZXNJdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbWluaW11bSBTZXJpZXNJdGVtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVR5cGUgLSB2YWx1ZSB0eXBlIGxpa2UgdmFsdWUsIHgsIHksIHIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZGl0aW9uIC0gY29uZGl0aW9uIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1Nlcmllc0l0ZW19XG4gICAgICovXG4gICAgZmluZE1pblNlcmllc0l0ZW06IGZ1bmN0aW9uKHZhbHVlVHlwZSwgY29uZGl0aW9uKSB7XG4gICAgICAgIHZhciBtaW5WYWx1ZSA9IHRoaXMuZ2V0TWluVmFsdWUodmFsdWVUeXBlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZFNlcmllc0l0ZW1CeVZhbHVlKHZhbHVlVHlwZSwgbWluVmFsdWUsIGNvbmRpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbWF4aW11bSBTZXJpZXNJdGVtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVR5cGUgLSB2YWx1ZSB0eXBlIGxpa2UgdmFsdWUsIHgsIHksIHIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZGl0aW9uIC0gY29uZGl0aW9uIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMgeyp8U2VyaWVzSXRlbX1cbiAgICAgKi9cbiAgICBmaW5kTWF4U2VyaWVzSXRlbTogZnVuY3Rpb24odmFsdWVUeXBlLCBjb25kaXRpb24pIHtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gdGhpcy5nZXRNYXhWYWx1ZSh2YWx1ZVR5cGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kU2VyaWVzSXRlbUJ5VmFsdWUodmFsdWVUeXBlLCBtYXhWYWx1ZSwgY29uZGl0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHZhbHVlcyB0aGF0IHBpY2tlZCB2YWx1ZSBmcm9tIFNlcmllc0l0ZW1zIG9mIFNlcmllc0dyb3Vwcy5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlVHlwZSAtIHR5cGUgb2YgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlVmFsdWVzOiBmdW5jdGlvbih2YWx1ZVR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMubWFwKGZ1bmN0aW9uKHNlcmllc0dyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAuZ2V0VmFsdWVzKHZhbHVlVHlwZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbHVlcyA9IGNvbmNhdC5hcHBseShbXSwgdmFsdWVzKTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwuZmlsdGVyKHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNOYU4odmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlcyBmb3JtIHZhbHVlc01hcC5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlVHlwZSAtIHR5cGUgb2YgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgZ2V0VmFsdWVzOiBmdW5jdGlvbih2YWx1ZVR5cGUpIHtcbiAgICAgICAgdmFsdWVUeXBlID0gdmFsdWVUeXBlIHx8ICd2YWx1ZSc7XG5cbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlc01hcFt2YWx1ZVR5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlc01hcFt2YWx1ZVR5cGVdID0gdGhpcy5fY3JlYXRlVmFsdWVzKHZhbHVlVHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNNYXBbdmFsdWVUeXBlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjb3VudCBvZiB4IHZhbHVlcyBncmVhdGVyIHRoYW4gY291bnQgb2YgeSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNYQ291bnRHcmVhdGVyVGhhbllDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygneCcpLmxlbmd0aCA+IHRoaXMuZ2V0VmFsdWVzKCd5JykubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgcmF0aW9zLCB3aGVuIGhhcyBub3JtYWwgc3RhY2tUeXBlIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCAtIGF4aXMgbGltaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRSYXRpb3NXaGVuTm9ybWFsU3RhY2tlZDogZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMobGltaXQubWF4IC0gbGltaXQubWluKTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICAgIHNlcmllc0dyb3VwLmFkZFJhdGlvcyhkaXN0YW5jZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYmFzZSByYXRpbyBmb3IgY2FsY3VsYXRpbmcgcmF0aW8gb2YgaXRlbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZUJhc2VSYXRpbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpLFxuICAgICAgICAgICAgcGx1c1N1bSA9IGNhbGN1bGF0b3Iuc3VtUGx1c1ZhbHVlcyh2YWx1ZXMpLFxuICAgICAgICAgICAgbWludXNTdW0gPSBNYXRoLmFicyhjYWxjdWxhdG9yLnN1bU1pbnVzVmFsdWVzKHZhbHVlcykpLFxuICAgICAgICAgICAgcmF0aW8gPSAocGx1c1N1bSA+IDAgJiYgbWludXNTdW0gPiAwKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgcmV0dXJuIHJhdGlvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgcmF0aW9zLCB3aGVuIGhhcyBwZXJjZW50IHN0YWNrVHlwZSBvcHRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkUmF0aW9zV2hlblBlcmNlbnRTdGFja2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJhc2VSYXRpbyA9IHRoaXMuX2NhbGN1bGF0ZUJhc2VSYXRpbygpO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihzZXJpZXNHcm91cCkge1xuICAgICAgICAgICAgc2VyaWVzR3JvdXAuYWRkUmF0aW9zV2hlblBlcmNlbnRTdGFja2VkKGJhc2VSYXRpbyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgcmF0aW9zLCB3aGVuIGhhcyBkaXZlcmdpbmcgc3RhY2tUeXBlIG9wdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRSYXRpb3NXaGVuRGl2ZXJnaW5nU3RhY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihzZXJpZXNHcm91cCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHNlcmllc0dyb3VwLnBsdWNrKCd2YWx1ZScpLFxuICAgICAgICAgICAgICAgIHBsdXNTdW0gPSBjYWxjdWxhdG9yLnN1bVBsdXNWYWx1ZXModmFsdWVzKSxcbiAgICAgICAgICAgICAgICBtaW51c1N1bSA9IE1hdGguYWJzKGNhbGN1bGF0b3Iuc3VtTWludXNWYWx1ZXModmFsdWVzKSk7XG5cbiAgICAgICAgICAgIHNlcmllc0dyb3VwLmFkZFJhdGlvc1doZW5EaXZlcmdpbmdTdGFja2VkKHBsdXNTdW0sIG1pbnVzU3VtKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VidHJhY3Rpb24gdmFsdWUgZm9yIG1ha2luZyByYXRpbyBvZiBubyBvcHRpb24gY2hhcnQuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgLSBsaW1pdFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVN1YnRyYWN0aW9uVmFsdWU6IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHZhciBhbGxvd01pbnVzUG9pbnRSZW5kZXIgPSBwcmVkaWNhdGUuYWxsb3dNaW51c1BvaW50UmVuZGVyKHRoaXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIHN1YlZhbHVlID0gMDtcblxuICAgICAgICBpZiAoIWFsbG93TWludXNQb2ludFJlbmRlciAmJiBwcmVkaWNhdGUuaXNNaW51c0xpbWl0KGxpbWl0KSkge1xuICAgICAgICAgICAgc3ViVmFsdWUgPSBsaW1pdC5tYXg7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsb3dNaW51c1BvaW50UmVuZGVyIHx8IGxpbWl0Lm1pbiA+PSAwKSB7XG4gICAgICAgICAgICBzdWJWYWx1ZSA9IGxpbWl0Lm1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHJhdGlvcywgd2hlbiBoYXMgbm90IG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCAtIGF4aXMgbGltaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRSYXRpb3M6IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKGxpbWl0Lm1heCAtIGxpbWl0Lm1pbiksXG4gICAgICAgICAgICBzdWJWYWx1ZSA9IHRoaXMuX21ha2VTdWJ0cmFjdGlvblZhbHVlKGxpbWl0KTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICAgIHNlcmllc0dyb3VwLmFkZFJhdGlvcyhkaXN0YW5jZSwgc3ViVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgcmF0aW9zLlxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGxpbWl0IC0gYXhpcyBsaW1pdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja1R5cGUgLSBzdGFja1R5cGUgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGREYXRhUmF0aW9zOiBmdW5jdGlvbihsaW1pdCwgc3RhY2tUeXBlKSB7XG4gICAgICAgIHZhciBpc0FsbG93ZWRTdGFja09wdGlvbiA9IHByZWRpY2F0ZS5pc0FsbG93ZWRTdGFja09wdGlvbih0aGlzLmNoYXJ0VHlwZSk7XG5cbiAgICAgICAgaWYgKGlzQWxsb3dlZFN0YWNrT3B0aW9uICYmIHByZWRpY2F0ZS5pc05vcm1hbFN0YWNrKHN0YWNrVHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFJhdGlvc1doZW5Ob3JtYWxTdGFja2VkKGxpbWl0KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FsbG93ZWRTdGFja09wdGlvbiAmJiBwcmVkaWNhdGUuaXNQZXJjZW50U3RhY2soc3RhY2tUeXBlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGl2ZXJnaW5nT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUmF0aW9zV2hlbkRpdmVyZ2luZ1N0YWNrZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUmF0aW9zV2hlblBlcmNlbnRTdGFja2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRSYXRpb3MobGltaXQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhIHJhdGlvcyBvZiBwaWUgY2hhcnQuXG4gICAgICovXG4gICAgYWRkRGF0YVJhdGlvc09mUGllQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSB0dWkudXRpbC5zdW0oc2VyaWVzR3JvdXAucGx1Y2soJ3ZhbHVlJykpO1xuXG4gICAgICAgICAgICBzZXJpZXNHcm91cC5hZGRSYXRpb3Moc3VtKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCByYXRpb3Mgb2YgZGF0YSBmb3IgY2hhcnQgb2YgY29vcmRpbmF0ZSB0eXBlLlxuICAgICAqIEBwYXJhbSB7e3g6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9LCB5OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX19IGxpbWl0TWFwIC0gbGltaXQgbWFwXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGFzUmFkaXVzXSAtIHdoZXRoZXIgaGFzIHJhZGl1cyBvciBub3RcbiAgICAgKi9cbiAgICBhZGREYXRhUmF0aW9zRm9yQ29vcmRpbmF0ZVR5cGU6IGZ1bmN0aW9uKGxpbWl0TWFwLCBoYXNSYWRpdXMpIHtcbiAgICAgICAgdmFyIHhMaW1pdCA9IGxpbWl0TWFwLng7XG4gICAgICAgIHZhciB5TGltaXQgPSBsaW1pdE1hcC55O1xuICAgICAgICB2YXIgbWF4UmFkaXVzID0gaGFzUmFkaXVzID8gdHVpLnV0aWwubWF4KHRoaXMuZ2V0VmFsdWVzKCdyJykpIDogMDtcbiAgICAgICAgdmFyIHhEaXN0YW5jZSwgeFN1YlZhbHVlLCB5RGlzdGFuY2UsIHlTdWJWYWx1ZTtcblxuICAgICAgICBpZiAoeExpbWl0KSB7XG4gICAgICAgICAgICB4RGlzdGFuY2UgPSBNYXRoLmFicyh4TGltaXQubWF4IC0geExpbWl0Lm1pbik7XG4gICAgICAgICAgICB4U3ViVmFsdWUgPSB0aGlzLl9tYWtlU3VidHJhY3Rpb25WYWx1ZSh4TGltaXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHlMaW1pdCkge1xuICAgICAgICAgICAgeURpc3RhbmNlID0gTWF0aC5hYnMoeUxpbWl0Lm1heCAtIHlMaW1pdC5taW4pO1xuICAgICAgICAgICAgeVN1YlZhbHVlID0gdGhpcy5fbWFrZVN1YnRyYWN0aW9uVmFsdWUoeUxpbWl0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihzZXJpZXNHcm91cCkge1xuICAgICAgICAgICAgc2VyaWVzR3JvdXAuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS5hZGRSYXRpbygneCcsIHhEaXN0YW5jZSwgeFN1YlZhbHVlKTtcbiAgICAgICAgICAgICAgICBpdGVtLmFkZFJhdGlvKCd5JywgeURpc3RhbmNlLCB5U3ViVmFsdWUpO1xuICAgICAgICAgICAgICAgIGl0ZW0uYWRkUmF0aW8oJ3InLCBtYXhSYWRpdXMsIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgc3RhcnQgdG8gYWxsIHNlcmllcyBpdGVtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IHZhbHVlXG4gICAgICovXG4gICAgYWRkU3RhcnRWYWx1ZVRvQWxsU2VyaWVzSXRlbTogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKHNlcmllc0dyb3VwKSB7XG4gICAgICAgICAgICBzZXJpZXNHcm91cC5hZGRTdGFydFZhbHVlVG9BbGxTZXJpZXNJdGVtKHN0YXJ0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaGFzIHJhbmdlIGRhdGEgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1JhbmdlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYXNSYW5nZURhdGEgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICAgIGhhc1JhbmdlRGF0YSA9IHNlcmllc0dyb3VwLmhhc1JhbmdlRGF0YSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gIWhhc1JhbmdlRGF0YTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhhc1JhbmdlRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhdmVyc2UgZ3JvdXBzLCBhbmQgZXhlY3V0ZXMgaXRlcmF0ZWUgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQaXZvdCAtIHdoZXRoZXIgcGl2b3Qgb3Igbm90XG4gICAgICovXG4gICAgZWFjaDogZnVuY3Rpb24oaXRlcmF0ZWUsIGlzUGl2b3QpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IGlzUGl2b3QgPyB0aGlzLl9nZXRQaXZvdEdyb3VwcygpIDogdGhpcy5fZ2V0U2VyaWVzR3JvdXBzKCk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGdyb3VwcywgZnVuY3Rpb24oc2VyaWVzR3JvdXAsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUoc2VyaWVzR3JvdXAsIGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIGdyb3VwcywgYW5kIHJldHVybnMgdG8gcmVzdWx0IG9mIGV4ZWN1dGlvbiBhYm91dCBpdGVyYXRlZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1Bpdm90IC0gd2hldGhlciBwaXZvdCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgbWFwOiBmdW5jdGlvbihpdGVyYXRlZSwgaXNQaXZvdCkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihzZXJpZXNHcm91cCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVyYXRlZShzZXJpZXNHcm91cCwgaW5kZXgpKTtcbiAgICAgICAgfSwgaXNQaXZvdCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VyaWVzRGF0YU1vZGVsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlcmllc0RhdGFNb2RlbEZvclRyZWVtYXAgaXMgYmFzZSBtb2RlbCBmb3IgZHJhd2luZyBncmFwaCBvZiB0cmVlbWFwIGNoYXJ0IHNlcmllcyBhcmVhLlxuICogU2VyaWVzRGF0YU1vZGVsLmdyb3VwcyBoYXMgU2VyaWVzR3JvdXBzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXNEYXRhTW9kZWwgPSByZXF1aXJlKCcuL3Nlcmllc0RhdGFNb2RlbCcpO1xudmFyIFNlcmllc0l0ZW0gPSByZXF1aXJlKCcuL3Nlcmllc0l0ZW1Gb3JUcmVlbWFwJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbnZhciBhcHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbnZhciBTZXJpZXNEYXRhTW9kZWxGb3JUcmVlbWFwID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoU2VyaWVzRGF0YU1vZGVsLCB7XG4gICAgLyoqXG4gICAgICogU2VyaWVzRGF0YU1vZGVsRm9yVHJlZW1hcCBpcyBiYXNlIG1vZGVsIGZvciBkcmF3aW5nIGdyYXBoIG9mIHRyZWVtYXAgY2hhcnQgc2VyaWVzIGFyZWEuXG4gICAgICogQGNvbnN0cnVjdHMgU2VyaWVzRGF0YU1vZGVsRm9yVHJlZW1hcFxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBTZXJpZXNEYXRhTW9kZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2FjaGVkIGZvdW5kIHNlcmllc0l0ZW1zIG1hcFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0LjxzdHJpbmcsIEFycmF5LjxTZXJpZXNJdGVtPj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvdW5kU2VyaWVzSXRlbXNNYXAgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2FjaGVkIHNlcmllc0l0ZW0gbWFwXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3Q8c3RyaW5nLCBTZXJpZXNJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VyaWVzSXRlbU1hcCA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVuIGhpZXJhcmNoaWNhbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHJhd1Nlcmllc0RhdGEgLSByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gcGFyZW50IC0gcGFyZW50IGlkXG4gICAgICogQHJldHVybnMge0FycmF5LjxvYmplY3Q+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZsYXR0ZW5IaWVyYXJjaGljYWxEYXRhOiBmdW5jdGlvbihyYXdTZXJpZXNEYXRhLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZmxhdERhdGEgPSBbXTtcbiAgICAgICAgdmFyIGlkUHJlZml4O1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlkUHJlZml4ID0gcGFyZW50ICsgJ18nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWRQcmVmaXggPSBjaGFydENvbnN0LlRSRUVNQVBfSURfUFJFRklYO1xuICAgICAgICAgICAgcGFyZW50ID0gY2hhcnRDb25zdC5UUkVFTUFQX1JPT1RfSUQ7XG4gICAgICAgIH1cblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkocmF3U2VyaWVzRGF0YSwgZnVuY3Rpb24oZGF0dW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBpZFByZWZpeCArIGluZGV4O1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZGF0dW0uY2hpbGRyZW47XG5cbiAgICAgICAgICAgIGZsYXREYXRhLnB1c2goZGF0dW0pO1xuXG4gICAgICAgICAgICBpZiAoIWRhdHVtLmlkKSB7XG4gICAgICAgICAgICAgICAgZGF0dW0uaWQgPSBpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkYXR1bS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBkYXR1bS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGZsYXREYXRhID0gZmxhdERhdGEuY29uY2F0KHNlbGYuX2ZsYXR0ZW5IaWVyYXJjaGljYWxEYXRhKGNoaWxkcmVuLCBpZCkpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXR1bS5jaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZsYXREYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJ0aXRpb24gcmF3IHNlcmllcyBkYXRhIGJ5IHBhcmVudCBpZFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHJhd1Nlcmllc0RhdGEgLSByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gcGFyZW50IC0gcGFyZW50IGlkXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGFydGl0aW9uUmF3U2VyaWVzRGF0YUJ5UGFyZW50OiBmdW5jdGlvbihyYXdTZXJpZXNEYXRhLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkID0gW107XG4gICAgICAgIHZhciByZWplY3RlZCA9IFtdO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShyYXdTZXJpZXNEYXRhLCBmdW5jdGlvbihkYXR1bSkge1xuICAgICAgICAgICAgaWYgKGRhdHVtLnBhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaChkYXR1bSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdGVkLnB1c2goZGF0dW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gW2ZpbHRlcmVkLCByZWplY3RlZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0cmVlIHByb3BlcnRpZXMgbGlrZSBkZXB0aCwgZ3JvdXAgaW4gcmF3IHNlcmllcyBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHJhd1Nlcmllc0RhdGEgLSByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggLSB0cmVlIGRlcHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmVudCAtIHBhcmVudCBpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cCAtIHRyZWUgZ3JvdXBcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0VHJlZVByb3BlcnRpZXM6IGZ1bmN0aW9uKHJhd1Nlcmllc0RhdGEsIGRlcHRoLCBwYXJlbnQsIGdyb3VwKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBhcnRlZCA9IHRoaXMuX3BhcnRpdGlvblJhd1Nlcmllc0RhdGFCeVBhcmVudChyYXdTZXJpZXNEYXRhLCBwYXJlbnQpO1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSBwYXJ0ZWRbMF07XG4gICAgICAgIHZhciByZWplY3RlZCA9IHBhcnRlZFsxXTtcbiAgICAgICAgdmFyIGNoaWxkRGVwdGggPSBkZXB0aCArIDE7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGZpbHRlcmVkLCBmdW5jdGlvbihkYXR1bSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBkZXNjZW5kYW50cywgY2hpbGRyZW47XG5cbiAgICAgICAgICAgIGRhdHVtLmRlcHRoID0gZGVwdGg7XG4gICAgICAgICAgICBkYXR1bS5ncm91cCA9IHR1aS51dGlsLmlzVW5kZWZpbmVkKGdyb3VwKSA/IGluZGV4IDogZ3JvdXA7XG5cbiAgICAgICAgICAgIGRlc2NlbmRhbnRzID0gc2VsZi5fc2V0VHJlZVByb3BlcnRpZXMocmVqZWN0ZWQsIGNoaWxkRGVwdGgsIGRhdHVtLmlkLCBkYXR1bS5ncm91cCk7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IHR1aS51dGlsLmZpbHRlcihkZXNjZW5kYW50cywgZnVuY3Rpb24oZGVzY2VuZGFudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjZW5kYW50LmRlcHRoID09PSBjaGlsZERlcHRoO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkYXR1bS52YWx1ZSA9IHR1aS51dGlsLnN1bSh0dWkudXRpbC5wbHVjayhjaGlsZHJlbiwgJ3ZhbHVlJykpO1xuICAgICAgICAgICAgICAgIGRhdHVtLmhhc0NoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0dW0uaGFzQ2hpbGQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5jb25jYXQoZGVzY2VuZGFudHMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBiYXNlIGdyb3Vwcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxTZXJpZXNJdGVtPj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQmFzZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFydFR5cGUgPSB0aGlzLmNoYXJ0VHlwZTtcbiAgICAgICAgdmFyIHJhd1Nlcmllc0RhdGEgPSB0aGlzLnJhd1Nlcmllc0RhdGE7XG4gICAgICAgIHZhciBzZXJpZXNJdGVtTWFwID0gdGhpcy5zZXJpZXNJdGVtTWFwO1xuICAgICAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5mb3JtYXRGdW5jdGlvbnM7XG5cbiAgICAgICAgcmF3U2VyaWVzRGF0YSA9IHRoaXMuX2ZsYXR0ZW5IaWVyYXJjaGljYWxEYXRhKHJhd1Nlcmllc0RhdGEpO1xuICAgICAgICByYXdTZXJpZXNEYXRhID0gdGhpcy5fc2V0VHJlZVByb3BlcnRpZXMocmF3U2VyaWVzRGF0YSwgMSwgY2hhcnRDb25zdC5UUkVFTUFQX1JPT1RfSUQpO1xuXG4gICAgICAgIHJldHVybiBbdHVpLnV0aWwubWFwKHJhd1Nlcmllc0RhdGEsIGZ1bmN0aW9uKHJhd0RhdHVtKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzSXRlbSA9IG5ldyBTZXJpZXNJdGVtKHJhd0RhdHVtLCBmb3JtYXRGdW5jdGlvbnMsIGNoYXJ0VHlwZSk7XG5cbiAgICAgICAgICAgIHNlcmllc0l0ZW1NYXBbc2VyaWVzSXRlbS5pZF0gPSBzZXJpZXNJdGVtO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzSXRlbTtcbiAgICAgICAgfSldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIFNlcmllc0l0ZW1zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBrZXlcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gLSBjb25kaXRpb24gZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFNlcmllc0l0ZW0+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRTZXJpZXNJdGVtczogZnVuY3Rpb24oa2V5LCBjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmZvdW5kU2VyaWVzSXRlbXNNYXBba2V5XSkge1xuICAgICAgICAgICAgdGhpcy5mb3VuZFNlcmllc0l0ZW1zTWFwW2tleV0gPSB0aGlzLmdldEZpcnN0U2VyaWVzR3JvdXAodHJ1ZSkuZmlsdGVyKGNvbmRpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mb3VuZFNlcmllc0l0ZW1zTWFwW2tleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY2FjaGUga2V5IGZvciBjYWNoaW5nIGZvdW5kIFNlcmllc0l0ZW1zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggLSBwcmVmaXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDYWNoZUtleTogZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICAgIHZhciBrZXkgPSBwcmVmaXg7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBrZXkgKz0gYXBzLmNhbGwoYXJndW1lbnRzLCAxKS5qb2luKCdfJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHZhbGlkIGdyb3VwIG9yIG5vdC5cbiAgICAgKiBJZiBjb21wYXJpbmdHcm91cCBpcyB1bmRlZmluZWQgb3IgZ3JvdXAgYW5kIGNvbXBhcmluZ0dyb3VwIGFyZSBlcXVhbCwgdGhpcyBncm91cCBpcyB2YWxpZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXAgLSBncm91cFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29tcGFyaW5nR3JvdXBdIC0gY29tcGFyaW5nIGdyb3VwXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNWYWxpZEdyb3VwOiBmdW5jdGlvbihncm91cCwgY29tcGFyaW5nR3JvdXApIHtcbiAgICAgICAgcmV0dXJuICF0dWkudXRpbC5pc0V4aXN0eShjb21wYXJpbmdHcm91cCkgfHwgKGdyb3VwID09PSBjb21wYXJpbmdHcm91cCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgU2VyaWVzSXRlbXMgYnkgZGVwdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIC0gdHJlZSBkZXB0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZ3JvdXBdIC0gdHJlZSBncm91cFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48U2VyaWVzSXRlbT59XG4gICAgICovXG4gICAgZmluZFNlcmllc0l0ZW1zQnlEZXB0aDogZnVuY3Rpb24oZGVwdGgsIGdyb3VwKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX21ha2VDYWNoZUtleShjaGFydENvbnN0LlRSRUVNQVBfREVQVEhfS0VZX1BSRUZJWCwgZGVwdGgsIGdyb3VwKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZFNlcmllc0l0ZW1zKGtleSwgZnVuY3Rpb24oc2VyaWVzSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIChzZXJpZXNJdGVtLmRlcHRoID09PSBkZXB0aCkgJiYgc2VsZi5faXNWYWxpZEdyb3VwKHNlcmllc0l0ZW0uZ3JvdXAsIGdyb3VwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgU2VyaWVzSXRlbXMgYnkgcGFyZW50IGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBwYXJlbnQgLSBwYXJlbnQgaWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFNlcmllc0l0ZW0+fVxuICAgICAqL1xuICAgIGZpbmRTZXJpZXNJdGVtc0J5UGFyZW50OiBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX21ha2VDYWNoZUtleShjaGFydENvbnN0LlRSRUVNQVBfUEFSRU5UX0tFWV9QUkVGSVgsIHBhcmVudCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRTZXJpZXNJdGVtcyhrZXksIGZ1bmN0aW9uKHNlcmllc0l0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNJdGVtLnBhcmVudCA9PT0gcGFyZW50O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBsZWFmIFNlcmllc0l0ZW1zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZ3JvdXBdIC0gdHJlZSBncm91cFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48U2VyaWVzSXRlbT59XG4gICAgICovXG4gICAgZmluZExlYWZTZXJpZXNJdGVtczogZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5fbWFrZUNhY2hlS2V5KGNoYXJ0Q29uc3QuVFJFRU1BUF9MRUFGX0tFWV9QUkVGSVgsIGdyb3VwKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZFNlcmllc0l0ZW1zKGtleSwgZnVuY3Rpb24oc2VyaWVzSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuICFzZXJpZXNJdGVtLmhhc0NoaWxkICYmIHNlbGYuX2lzVmFsaWRHcm91cChzZXJpZXNJdGVtLmdyb3VwLCBncm91cCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHBhcmVudCBieSBkZXB0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCAtIGRlcHRoXG4gICAgICogQHJldHVybnMge1Nlcmllc0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICBmaW5kUGFyZW50QnlEZXB0aDogZnVuY3Rpb24oaWQsIGRlcHRoKSB7XG4gICAgICAgIHZhciBzZXJpZXNJdGVtID0gdGhpcy5zZXJpZXNJdGVtTWFwW2lkXSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChzZXJpZXNJdGVtICYmIHNlcmllc0l0ZW0uZGVwdGggIT09IGRlcHRoKSB7XG4gICAgICAgICAgICBzZXJpZXNJdGVtID0gdGhpcy5maW5kUGFyZW50QnlEZXB0aChzZXJpZXNJdGVtLnBhcmVudCwgZGVwdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc0l0ZW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZm91bmRTZXJpZXNJdGVtc01hcC5cbiAgICAgKi9cbiAgICBpbml0U2VyaWVzSXRlbXNNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZvdW5kU2VyaWVzSXRlbXNNYXAgPSBudWxsO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcmllc0RhdGFNb2RlbEZvclRyZWVtYXA7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2VyaWVzR3JvdXAgaXMgYSBlbGVtZW50IG9mIFNlcmllc0RhdGFNb2RlbC5ncm91cHMuXG4gKiBTZXJpZXNHcm91cC5pdGVtcyBoYXMgU2VyaWVzSXRlbS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNlcmllc0l0ZW0gaXMgYSBlbGVtZW50IG9mIFNlcmllc0dyb3VwLml0ZW1zLlxuICogU2VyaWVzSXRlbSBoYXMgcHJvY2Vzc2VkIHRlcm1pbmFsIGRhdGEgbGlrZSB2YWx1ZSwgcmF0aW8sIGV0Yy5cbiAqL1xuXG52YXIgU2VyaWVzR3JvdXAgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFNlcmllc0dyb3VwLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBTZXJpZXNHcm91cCBpcyBhIGVsZW1lbnQgb2YgU2VyaWVzRGF0YU1vZGVsLmdyb3Vwcy5cbiAgICAgKiBTZXJpZXNHcm91cC5pdGVtcyBoYXMgU2VyaWVzSXRlbS5cbiAgICAgKiBAY29uc3RydWN0cyBTZXJpZXNHcm91cFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFNlcmllc0l0ZW0+fSBzZXJpZXNJdGVtcyAtIHNlcmllcyBpdGVtc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHNlcmllc0l0ZW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpdGVtcyBoYXMgU2VyaWVzSXRlbVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPFNlcmllc0l0ZW0+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pdGVtcyA9IHNlcmllc0l0ZW1zO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXAgb2YgdmFsdWVzIGJ5IHZhbHVlIHR5cGUgbGlrZSB2YWx1ZSwgeCwgeSwgci5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZXNNYXAgPSB7fTtcblxuICAgICAgICB0aGlzLnZhbHVlc01hcFBlclN0YWNrID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlcmllcyBpdGVtIGNvdW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0U2VyaWVzSXRlbUNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VyaWVzIGl0ZW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2YgaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7U2VyaWVzSXRlbX1cbiAgICAgKi9cbiAgICBnZXRTZXJpZXNJdGVtOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmaXJzdCBTZXJpZXNJdGVtLlxuICAgICAqIEByZXR1cm5zIHtTZXJpZXNJdGVtfVxuICAgICAqL1xuICAgIGdldEZpcnN0U2VyaWVzSXRlbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlcmllc0l0ZW0oMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB2YWx1ZXMgdGhhdCBwaWNrZWQgdmFsdWUgZnJvbSBTZXJpZXNJdGVtcy5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlVHlwZSAtIHR5cGUgb2YgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlVmFsdWVzOiBmdW5jdGlvbih2YWx1ZVR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0dWkudXRpbC5pc0V4aXN0eShpdGVtW3ZhbHVlVHlwZV0pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goaXRlbVt2YWx1ZVR5cGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0dWkudXRpbC5pc0V4aXN0eShpdGVtLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGl0ZW0uc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWVzIGZyb20gdmFsdWVzTWFwLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVUeXBlIC0gdHlwZSBvZiB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlVHlwZSkge1xuICAgICAgICB2YWx1ZVR5cGUgPSB2YWx1ZVR5cGUgfHwgJ3ZhbHVlJztcblxuICAgICAgICBpZiAoIXRoaXMudmFsdWVzTWFwW3ZhbHVlVHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzTWFwW3ZhbHVlVHlwZV0gPSB0aGlzLl9jcmVhdGVWYWx1ZXModmFsdWVUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc01hcFt2YWx1ZVR5cGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHZhbHVlcyBtYXAgcGVyIHN0YWNrLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZhbHVlc01hcFBlclN0YWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlc01hcCA9IHt9O1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlc01hcFtpdGVtLnN0YWNrXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlc01hcFtpdGVtLnN0YWNrXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzTWFwW2l0ZW0uc3RhY2tdLnB1c2goaXRlbS52YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZXNNYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB2YWx1ZXMgbWFwIHBlciBzdGFjay5cbiAgICAgKiBAcmV0dXJucyB7KnxPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VmFsdWVzTWFwUGVyU3RhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWVzTWFwUGVyU3RhY2spIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzTWFwUGVyU3RhY2sgPSB0aGlzLl9tYWtlVmFsdWVzTWFwUGVyU3RhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc01hcFBlclN0YWNrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1bSBtYXAgcGVyIHN0YWNrLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHN1bSBtYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3VtTWFwUGVyU3RhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzTWFwID0gdGhpcy5nZXRWYWx1ZXNNYXBQZXJTdGFjaygpLFxuICAgICAgICAgICAgc3VtTWFwID0ge307XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh2YWx1ZXNNYXAsIGZ1bmN0aW9uKHZhbHVlcywga2V5KSB7XG4gICAgICAgICAgICBzdW1NYXBba2V5XSA9IHR1aS51dGlsLnN1bSh0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdW1NYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBzdGFydCB2YWx1ZSB0byBhbGwgc2VyaWVzIGl0ZW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHN0YXJ0IHZhbHVlXG4gICAgICovXG4gICAgYWRkU3RhcnRWYWx1ZVRvQWxsU2VyaWVzSXRlbTogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0uYWRkU3RhcnQoc3RhcnQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHJhdGlvcyB3aGVuIHBlcmNlbnQgc3RhY2tUeXBlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlUmF0aW8gLSBiYXNlIHJhdGlvXG4gICAgICovXG4gICAgYWRkUmF0aW9zV2hlblBlcmNlbnRTdGFja2VkOiBmdW5jdGlvbihiYXNlUmF0aW8pIHtcbiAgICAgICAgdmFyIHN1bU1hcCA9IHRoaXMuX21ha2VTdW1NYXBQZXJTdGFjaygpO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB2YXIgZGl2aWRpbmdOdW1iZXIgPSBzdW1NYXBbaXRlbS5zdGFja107XG5cbiAgICAgICAgICAgIGl0ZW0uYWRkUmF0aW8oZGl2aWRpbmdOdW1iZXIsIDAsIGJhc2VSYXRpbyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgcmF0aW9zIHdoZW4gZGl2ZXJnaW5nIHN0YWNrZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBsdXNTdW0gLSBzdW0gb2YgcGx1cyBudW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludXNTdW0gLSBzdW0gb2YgbWludXMgbnVtYmVyXG4gICAgICovXG4gICAgYWRkUmF0aW9zV2hlbkRpdmVyZ2luZ1N0YWNrZWQ6IGZ1bmN0aW9uKHBsdXNTdW0sIG1pbnVzU3VtKSB7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB2YXIgZGl2aWRpbmdOdW1iZXIgPSAoaXRlbS52YWx1ZSA+PSAwKSA/IHBsdXNTdW0gOiBtaW51c1N1bTtcblxuICAgICAgICAgICAgaXRlbS5hZGRSYXRpbyhkaXZpZGluZ051bWJlciwgMCwgMC41KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCByYXRpb3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdk51bWJlciBkaXZpZGluZyBudW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3ViVmFsdWUgc3VidHJhY3Rpb24gdmFsdWVcbiAgICAgKi9cbiAgICBhZGRSYXRpb3M6IGZ1bmN0aW9uKGRpdk51bWJlciwgc3ViVmFsdWUpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0uYWRkUmF0aW8oZGl2TnVtYmVyLCBzdWJWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGhhcyByYW5nZSBkYXRhIG9yIG5vdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSYW5nZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGFzUmFuZ2VEYXRhID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKHNlcmllc0l0ZW0pIHtcbiAgICAgICAgICAgIGhhc1JhbmdlRGF0YSA9IHNlcmllc0l0ZW0uaXNSYW5nZTtcblxuICAgICAgICAgICAgcmV0dXJuICFoYXNSYW5nZURhdGE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBoYXNSYW5nZURhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIGl0ZW1zLCBhbmQgZXhlY3V0ZXMgaXRlcmF0ZWUgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLml0ZW1zLCBpdGVyYXRlZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIGl0ZW1zLCBhbmQgcmV0dXJucyB0byByZXN1bHRzIG9mIGV4ZWN1dGlvbiBhYm91dCBpdGVyYXRlZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIG1hcDogZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0aGlzLml0ZW1zLCBpdGVyYXRlZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIGl0ZW1zLCBhbmQgcmV0dXJucyB0byBwaWNrZWQgcmVzdWx0IGF0IGl0ZW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBrZXkgZm9yIHBpY2tcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgcGx1Y2s6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwucGx1Y2sodGhpcy5pdGVtcywga2V5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhdmVyc2UgaXRlbXMsIGFuZCByZXR1cm5zIHRvIGZvdW5kIFNlcmllc0l0ZW0gYnkgY29uZGl0aW9uIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiAtIGNvbmRpdGlvbiBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtTZXJpZXNJdGVtfG51bGx9XG4gICAgICovXG4gICAgZmluZDogZnVuY3Rpb24oY29uZGl0aW9uKSB7XG4gICAgICAgIHZhciBmb3VuZEl0ZW07XG5cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKHNlcmllc0l0ZW0pIHtcbiAgICAgICAgICAgIGlmIChjb25kaXRpb24oc2VyaWVzSXRlbSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZEl0ZW0gPSBzZXJpZXNJdGVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gIWZvdW5kSXRlbTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kSXRlbSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZSBpdGVtcywgYW5kIHJldHVybnMgdG8gZmlsdGVyIFNlcmllc0l0ZW1zIGJ5IGNvbmRpdGlvbiBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gLSBjb25kaXRpb24gZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZmlsdGVyOiBmdW5jdGlvbihjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmZpbHRlcih0aGlzLml0ZW1zLCBjb25kaXRpb24pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcmllc0dyb3VwO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlcmllc0l0ZW0gaXMgYSBlbGVtZW50IG9mIFNlcmllc0dyb3VwLml0ZW1zLlxuICogU2VyaWVzSXRlbSBoYXMgcHJvY2Vzc2VkIHRlcm1pbmFsIGRhdGEgbGlrZSB2YWx1ZSwgcmF0aW8sIGV0Yy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xudmFyIGNhbGN1bGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGN1bGF0b3InKTtcblxudmFyIFNlcmllc0l0ZW0gPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFNlcmllc0l0ZW0ucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIFNlcmllc0l0ZW0gaXMgYSBlbGVtZW50IG9mIFNlcmllc0dyb3VwLml0ZW1zLlxuICAgICAqIFNlcmllc0l0ZW0gaGFzIHByb2Nlc3NlZCB0ZXJtaW5hbCBkYXRhIGxpa2UgdmFsdWUsIHJhdGlvLCBldGMuXG4gICAgICogQGNvbnN0cnVjdHMgU2VyaWVzSXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBzdGFjayAtIHN0YWNrXG4gICAgICogQHBhcmFtIHs/QXJyYXkuPGZ1bmN0aW9uPn0gZm9ybWF0RnVuY3Rpb25zIC0gZm9ybWF0IGZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSB0eXBlIG9mIGNoYXJ0XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24odmFsdWUsIHN0YWNrLCBmb3JtYXRGdW5jdGlvbnMsIGNoYXJ0VHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogdHlwZSBvZiBjaGFydFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBjaGFydFR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZvciBncm91cCBzdGFjayBvcHRpb24uXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2sgfHwgY2hhcnRDb25zdC5ERUZBVUxUX1NUQUNLO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48ZnVuY3Rpb24+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXRGdW5jdGlvbnMgPSBmb3JtYXRGdW5jdGlvbnM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgcmFuZ2UgaXRlbSBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzUmFuZ2UgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWUgb2YgaXRlbVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxhYmVsXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhYmVsID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmF0aW8gb2YgdmFsdWUgYWJvdXQgZGlzdGFuY2Ugb2YgbGltaXRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmF0aW8gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBlbmQgdmFsdWUgb2YgaXRlbS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5kID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZW5kIGxhYmVsXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuZExhYmVsID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmF0aW8gb2YgZW5kIHZhbHVlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuZFJhdGlvID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3RhcnQgdmFsdWUgb2YgaXRlbS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdGFydCBsYWJlbFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydExhYmVsID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmF0aW8gb2Ygc3RhcnQgdmFsdWVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRSYXRpbyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRpc3RhbmNlIG9mIHN0YXJ0IHJhdGlvIGFuZCBlbmQgcmF0aW9cbiAgICAgICAgICogQHR5cGUge251bGx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhdGlvRGlzdGFuY2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2luaXRWYWx1ZXModmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHZhbHVlcyBvZiBpdGVtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFZhbHVlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuX2NyZWF0ZVZhbHVlcyh2YWx1ZSk7XG4gICAgICAgIHZhciBhcmVhVHlwZSA9ICdtYWtpbmdTZXJpZXNMYWJlbCc7XG4gICAgICAgIHZhciBoYXNTdGFydCA9IHZhbHVlcy5sZW5ndGggPiAxO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmVuZCA9IHZhbHVlc1swXTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHJlbmRlclV0aWwuZm9ybWF0VmFsdWUodGhpcy52YWx1ZSwgdGhpcy5mb3JtYXRGdW5jdGlvbnMsIHRoaXMuY2hhcnRUeXBlLCBhcmVhVHlwZSk7XG4gICAgICAgIHRoaXMuZW5kTGFiZWwgPSB0aGlzLmxhYmVsO1xuXG4gICAgICAgIGlmIChoYXNTdGFydCkge1xuICAgICAgICAgICAgdGhpcy5hZGRTdGFydCh2YWx1ZXNbMV0sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9ybWF0dGVkVmFsdWVmb3JSYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5pc1JhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmV0ZSBzb3J0ZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj58bnVtYmVyfSB2YWx1ZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVWYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0dWkudXRpbC5tYXAoW10uY29uY2F0KHZhbHVlKSwgcGFyc2VGbG9hdCk7XG5cbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPCAwICYmIGIgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYiAtIGE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBzdGFydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkU3RhcnQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNOdWxsKHRoaXMuc3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXJ0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc3RhcnRMYWJlbCA9IHJlbmRlclV0aWwuZm9ybWF0VmFsdWUodmFsdWUsIHRoaXMuZm9ybWF0RnVuY3Rpb25zLCB0aGlzLmNoYXJ0VHlwZSwgJ3NlcmllcycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZm9ybWF0dGVkIHZhbHVlIGZvciByYW5nZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVGb3JtYXR0ZWRWYWx1ZWZvclJhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHRoaXMuc3RhcnRMYWJlbCArICcgfiAnICsgdGhpcy5lbmRMYWJlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHJhdGlvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZOdW1iZXIgLSBudW1iZXIgZm9yIGRpdmlzaW9uXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBzdWJOdW1iZXIgLSBudW1iZXIgZm9yIHN1YnRyYWN0aW9uXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBiYXNlUmF0aW8gLSBiYXNlIHJhdGlvXG4gICAgICovXG4gICAgYWRkUmF0aW86IGZ1bmN0aW9uKGRpdk51bWJlciwgc3ViTnVtYmVyLCBiYXNlUmF0aW8pIHtcbiAgICAgICAgZGl2TnVtYmVyID0gZGl2TnVtYmVyIHx8IDE7XG4gICAgICAgIGJhc2VSYXRpbyA9IGJhc2VSYXRpbyB8fCAxO1xuICAgICAgICBzdWJOdW1iZXIgPSBzdWJOdW1iZXIgfHwgMDtcblxuICAgICAgICB0aGlzLnJhdGlvID0gdGhpcy5lbmRSYXRpbyA9IGNhbGN1bGF0b3IuY2FsY3VsYXRlUmF0aW8odGhpcy52YWx1ZSwgZGl2TnVtYmVyLCBzdWJOdW1iZXIsIGJhc2VSYXRpbyk7XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc051bGwodGhpcy5zdGFydCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSYXRpbyA9IGNhbGN1bGF0b3IuY2FsY3VsYXRlUmF0aW8odGhpcy5zdGFydCwgZGl2TnVtYmVyLCBzdWJOdW1iZXIsIGJhc2VSYXRpbyk7XG4gICAgICAgICAgICB0aGlzLnJhdGlvRGlzdGFuY2UgPSBNYXRoLmFicyh0aGlzLmVuZFJhdGlvIC0gdGhpcy5zdGFydFJhdGlvKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIHZhbHVlIG1hcC5cbiAgICAgKiBAcmV0dXJucyB7e3ZhbHVlOiBudW1iZXIsIHN0YXJ0OiA/bnVtYmVyLCBlbmQ6ID9udW1iZXJ9fVxuICAgICAqL1xuICAgIHBpY2tWYWx1ZU1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiB0aGlzLmVuZFxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcmllc0l0ZW07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2VyaWVzSXRlbUZvckNvb3JkaW5hdGVUeXBlIGlzIGEgZWxlbWVudCBvZiBTZXJpZXNHcm91cC5pdGVtcy5cbiAqIFNlcmllc0l0ZW1Gb3JDb29yZGluYXRlVHlwZSBoYXMgcHJvY2Vzc2VkIHRlcm1pbmFsIGRhdGEgbGlrZSB4LCB5LCByLCB4UmF0aW8sIHlSYXRpbywgclJhdGlvLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXNJdGVtRm9yQ29vcmRpbmF0ZVR5cGUgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFNlcmllc0l0ZW1Gb3JDb29yZGluYXRlVHlwZS5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogU2VyaWVzSXRlbUZvckNvb3JkaW5hdGVUeXBlIGlzIGEgZWxlbWVudCBvZiBTZXJpZXNHcm91cC5pdGVtcy5cbiAgICAgKiBTZXJpZXNJdGVtRm9yQ29vcmRpbmF0ZVR5cGUgaGFzIHByb2Nlc3NlZCB0ZXJtaW5hbCBkYXRhIGxpa2UgeCwgeSwgciwgeFJhdGlvLCB5UmF0aW8sIHJSYXRpby5cbiAgICAgKiBAY29uc3RydWN0cyBTZXJpZXNJdGVtRm9yQ29vcmRpbmF0ZVR5cGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmF3U2VyaWVzRGF0dW0gLSB2YWx1ZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd1Nlcmllc0RhdHVtKSB7XG4gICAgICAgIHRoaXMuX2luaXREYXRhKHJhd1Nlcmllc0RhdHVtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBkYXRhIG9mIGl0ZW0uXG4gICAgICogQHBhcmFtIHt7eDogP251bWJlciwgeTogP251bWJlciwgcjogP251bWJlciwgbGFiZWw6ID9zdHJpbmd9fSByYXdTZXJpZXNEYXR1bSAtIHJhd1Nlcmllc0RhdHVtIGZvciBidWJibGUgY2hhcnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0RGF0YTogZnVuY3Rpb24ocmF3U2VyaWVzRGF0dW0pIHtcbiAgICAgICAgdGhpcy54ID0gcmF3U2VyaWVzRGF0dW0ueDtcbiAgICAgICAgdGhpcy55ID0gcmF3U2VyaWVzRGF0dW0ueTtcbiAgICAgICAgdGhpcy5yID0gcmF3U2VyaWVzRGF0dW0ucjtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHJhd1Nlcmllc0RhdHVtLmxhYmVsIHx8ICcnO1xuXG4gICAgICAgIHRoaXMucmF0aW9NYXAgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHJhdGlvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVR5cGUgLSB0eXBlIG9mIHZhbHVlIGxpa2UgeCwgeSwgclxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gZGl2TnVtYmVyIC0gbnVtYmVyIGZvciBkaXZpc2lvblxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gc3ViTnVtYmVyIC0gbnVtYmVyIGZvciBzdWJ0cmFjdGlvblxuICAgICAqL1xuICAgIGFkZFJhdGlvOiBmdW5jdGlvbih2YWx1ZVR5cGUsIGRpdk51bWJlciwgc3ViTnVtYmVyKSB7XG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNFeGlzdHkodGhpcy5yYXRpb01hcFt2YWx1ZVR5cGVdKSAmJiBkaXZOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmF0aW9NYXBbdmFsdWVUeXBlXSA9ICh0aGlzW3ZhbHVlVHlwZV0gLSBzdWJOdW1iZXIpIC8gZGl2TnVtYmVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgdmFsdWUgbWFwLlxuICAgICAqIEByZXR1cm5zIHt7eDogKG51bWJlciB8IG51bGwpLCB5OiAobnVtYmVyIHwgbnVsbCksIHI6IChudW1iZXIgfCBudWxsKX19XG4gICAgICovXG4gICAgcGlja1ZhbHVlTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMucmF0aW9NYXAueCA/IHRoaXMueCA6IG51bGwsXG4gICAgICAgICAgICB5OiB0aGlzLnJhdGlvTWFwLnkgPyB0aGlzLnkgOiBudWxsLFxuICAgICAgICAgICAgcjogdGhpcy5yYXRpb01hcC5yID8gdGhpcy5yIDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcmllc0l0ZW1Gb3JDb29yZGluYXRlVHlwZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBTZXJpZXNJdGVtIGZvciB0cmVlbWFwLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxjdWxhdG9yJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgU2VyaWVzSXRlbUZvclRyZWVtYXAgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFNlcmllc0l0ZW1Gb3JUcmVlbWFwLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBTZXJpZXNJdGVtIGZvciB0cmVlbWFwLlxuICAgICAqIEBjb25zdHJ1Y3RzIFNlcmllc0l0ZW1Gb3JUcmVlbWFwXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJhd1Nlcmllc0RhdHVtIC0gdmFsdWVcbiAgICAgKiBAcGFyYW0gez9BcnJheS48ZnVuY3Rpb24+fSBmb3JtYXRGdW5jdGlvbnMgLSBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIHR5cGUgb2YgY2hhcnRcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihyYXdTZXJpZXNEYXR1bSwgZm9ybWF0RnVuY3Rpb25zLCBjaGFydFR5cGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHR5cGUgb2YgY2hhcnRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48ZnVuY3Rpb24+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXRGdW5jdGlvbnMgPSBmb3JtYXRGdW5jdGlvbnM7XG4gICAgICAgIHRoaXMuaWQgPSByYXdTZXJpZXNEYXR1bS5pZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSByYXdTZXJpZXNEYXR1bS5wYXJlbnQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSByYXdTZXJpZXNEYXR1bS52YWx1ZTtcbiAgICAgICAgdGhpcy5jb2xvclZhbHVlID0gcmF3U2VyaWVzRGF0dW0uY29sb3JWYWx1ZTtcbiAgICAgICAgdGhpcy5kZXB0aCA9IHJhd1Nlcmllc0RhdHVtLmRlcHRoO1xuICAgICAgICB0aGlzLmxhYmVsID0gcmF3U2VyaWVzRGF0dW0ubGFiZWwgfHwgJyc7XG4gICAgICAgIHRoaXMuZ3JvdXAgPSByYXdTZXJpZXNEYXR1bS5ncm91cDtcbiAgICAgICAgdGhpcy5oYXNDaGlsZCA9ICEhcmF3U2VyaWVzRGF0dW0uaGFzQ2hpbGQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCByYXRpby5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2TnVtYmVyIC0gbnVtYmVyIGZvciBkaXZpc2lvblxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gc3ViTnVtYmVyIC0gbnVtYmVyIGZvciBzdWJ0cmFjdGlvblxuICAgICAqL1xuICAgIGFkZFJhdGlvOiBmdW5jdGlvbihkaXZOdW1iZXIsIHN1Yk51bWJlcikge1xuICAgICAgICBkaXZOdW1iZXIgPSBkaXZOdW1iZXIgfHwgMTtcbiAgICAgICAgc3ViTnVtYmVyID0gc3ViTnVtYmVyIHx8IDA7XG5cbiAgICAgICAgdGhpcy5yYXRpbyA9IGNhbGN1bGF0b3IuY2FsY3VsYXRlUmF0aW8odGhpcy5jb2xvclZhbHVlLCBkaXZOdW1iZXIsIHN1Yk51bWJlciwgMSkgfHwgLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgdmFsdWUgbWFwLlxuICAgICAqIEByZXR1cm5zIHt7dmFsdWU6IG51bWJlciwgbGFiZWw6IHN0cmluZ319XG4gICAgICovXG4gICAgcGlja1ZhbHVlTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZWFUeXBlID0gJ21ha2luZ1Rvb2x0aXBMYWJlbCc7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHJlbmRlclV0aWwuZm9ybWF0VmFsdWUodGhpcy52YWx1ZSwgdGhpcy5mb3JtYXRGdW5jdGlvbnMsIHRoaXMuY2hhcnRUeXBlLCBhcmVhVHlwZSk7XG4gICAgICAgIHZhciBsYWJlbCA9ICh0aGlzLmxhYmVsID8gdGhpcy5sYWJlbCArICc6ICcgOiAnJykgKyBmb3JtYXR0ZWRWYWx1ZTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBsYWJlbDogbGFiZWxcbiAgICAgICAgfTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJpZXNJdGVtRm9yVHJlZW1hcDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgQ2hhcnQgZmFjdG9yeSBwbGF5IHJvbGUgcmVnaXN0ZXIgY2hhcnQuXG4gKiAgICAgICAgICAgICAgICBBbHNvLCB5b3UgY2FuIGdldCBjaGFydCBmcm9tIHRoaXMgZmFjdG9yeS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIHJhd0RhdGFIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGVscGVycy9yYXdEYXRhSGFuZGxlcicpO1xudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG5cbnZhciBjaGFydHMgPSB7fTtcbnZhciBmYWN0b3J5ID0ge1xuICAgIC8qKlxuICAgICAqIEZpbmQga2V5IGZvciBnZXR0aW5nIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSB0eXBlIG9mIGNoYXJ0XG4gICAgICogQHBhcmFtIHt7c2VyaWVzQWxpYXM6ID9vYmplY3QsIHNlcmllczogb2JqZWN0LjxzdHJpbmcsIEFycmF5Pn19IHJhd0RhdGEgLSByYXcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZEtleTogZnVuY3Rpb24oY2hhcnRUeXBlLCByYXdEYXRhKSB7XG4gICAgICAgIHZhciBrZXkgPSBudWxsO1xuICAgICAgICB2YXIgY2hhcnRUeXBlTWFwO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNDb21ib0NoYXJ0KGNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZU1hcCA9IHJhd0RhdGFIYW5kbGVyLmdldENoYXJ0VHlwZU1hcChyYXdEYXRhKTtcblxuICAgICAgICAgICAgaWYgKGNoYXJ0VHlwZU1hcFtjaGFydENvbnN0LkNIQVJUX1RZUEVfQ09MVU1OXSAmJiBjaGFydFR5cGVNYXBbY2hhcnRDb25zdC5DSEFSVF9UWVBFX0xJTkVdKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0NPTFVNTl9MSU5FX0NPTUJPO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFydFR5cGVNYXBbY2hhcnRDb25zdC5DSEFSVF9UWVBFX0FSRUFdICYmIGNoYXJ0VHlwZU1hcFtjaGFydENvbnN0LkNIQVJUX1RZUEVfTElORV0pIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfTElORV9BUkVBX0NPTUJPO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFydFR5cGVNYXBbY2hhcnRDb25zdC5DSEFSVF9UWVBFX1BJRV0pIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfUElFX0RPTlVUX0NPTUJPO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gY2hhcnRUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNoYXJ0IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByYXdEYXRhIGNoYXJ0IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBjaGFydCBpbnN0YW5jZTtcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgcmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX2ZpbmRLZXkoY2hhcnRUeXBlLCByYXdEYXRhKTtcbiAgICAgICAgdmFyIENoYXJ0ID0gY2hhcnRzW2tleV07XG4gICAgICAgIHZhciBjaGFydDtcblxuICAgICAgICBpZiAoIUNoYXJ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBleGlzdCAnICsgY2hhcnRUeXBlICsgJyBjaGFydC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJ0ID0gbmV3IENoYXJ0KHJhd0RhdGEsIHRoZW1lLCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhciB0eXBlXG4gICAgICogQHBhcmFtIHtjbGFzc30gQ2hhcnRDbGFzcyBjaGFydCBjbGFzc1xuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihjaGFydFR5cGUsIENoYXJ0Q2xhc3MpIHtcbiAgICAgICAgY2hhcnRzW2NoYXJ0VHlwZV0gPSBDaGFydENsYXNzO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgTWFwIGZhY3RvcnkuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hcHMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogR2V0IG1hcCBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lIG1hcCBuYW1lXG4gICAgICogQHJldHVybnMge0FycmF5fSBtYXAgZGF0YVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24obWFwTmFtZSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hcHNbbWFwTmFtZV07XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBleGlzdCAnICsgbWFwTmFtZSArICcgbWFwLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIE1hcC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFwTmFtZSBtYXAgbmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgbWFwIGRhdGFcbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24obWFwTmFtZSwgZGF0YSkge1xuICAgICAgICBtYXBzW21hcE5hbWVdID0gZGF0YTtcbiAgICB9XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBQbHVnaW4gZmFjdG9yeSBwbGF5IHJvbGUgcmVnaXN0ZXIgcmVuZGVyaW5nIHBsdWdpbi5cbiAqICAgICAgICAgICAgICAgIEFsc28sIHlvdSBjYW4gZ2V0IHBsdWdpbiBmcm9tIHRoaXMgZmFjdG9yeS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGx1Z2lucyA9IHt9LFxuICAgIGZhY3RvcnkgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZ3JhcGggcmVuZGVyZXIuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaWJUeXBlIHR5cGUgb2YgZ3JhcGggbGlicmFyeVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gcmVuZGVyZXIgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24obGliVHlwZSwgY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gcGx1Z2luc1tsaWJUeXBlXSxcbiAgICAgICAgICAgICAgICBSZW5kZXJlciwgcmVuZGVyZXI7XG5cbiAgICAgICAgICAgIGlmICghcGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZXhpc3QgJyArIGxpYlR5cGUgKyAnIHBsdWdpbi4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUmVuZGVyZXIgPSBwbHVnaW5bY2hhcnRUeXBlXTtcbiAgICAgICAgICAgIGlmICghUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBleGlzdCAnICsgY2hhcnRUeXBlICsgJyBjaGFydCByZW5kZXJlci4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUGx1Z2luIHJlZ2lzdGVyLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGliVHlwZSB0eXBlIG9mIGdyYXBoIGxpYnJhcnlcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHBsdWdpbiBwbHVnaW4gdG8gY29udHJvbCBsaWJyYXJ5XG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24obGliVHlwZSwgcGx1Z2luKSB7XG4gICAgICAgICAgICBwbHVnaW5zW2xpYlR5cGVdID0gcGx1Z2luO1xuICAgICAgICB9XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBUaGVtZSBmYWN0b3J5IHBsYXkgcm9sZSByZWdpc3RlciB0aGVtZS5cbiAqICAgICAgICAgICAgICAgIEFsc28sIHlvdSBjYW4gZ2V0IHRoZW1lIGZyb20gdGhpcyBmYWN0b3J5LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBkZWZhdWx0VGhlbWUgPSByZXF1aXJlKCcuLi90aGVtZXMvZGVmYXVsdFRoZW1lJyk7XG5cbnZhciB0aGVtZXMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aGVtZU5hbWUgdGhlbWUgbmFtZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZW1lIG9iamVjdFxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24odGhlbWVOYW1lKSB7XG4gICAgICAgIHZhciB0aGVtZSA9IHRoZW1lc1t0aGVtZU5hbWVdO1xuXG4gICAgICAgIGlmICghdGhlbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGV4aXN0ICcgKyB0aGVtZU5hbWUgKyAnIHRoZW1lLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoZW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGVtZSByZWdpc3Rlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGhlbWVOYW1lIHRoZW1lIG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgdGhlbWVcbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24odGhlbWVOYW1lLCB0aGVtZSkge1xuICAgICAgICB2YXIgdGFyZ2V0SXRlbXM7XG4gICAgICAgIHRoZW1lID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGVtZSkpO1xuXG4gICAgICAgIGlmICh0aGVtZU5hbWUgIT09IGNoYXJ0Q29uc3QuREVGQVVMVF9USEVNRV9OQU1FKSB7XG4gICAgICAgICAgICB0aGVtZSA9IHRoaXMuX2luaXRUaGVtZSh0aGVtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRJdGVtcyA9IHRoaXMuX2dldEluaGVyaXRUYXJnZXRUaGVtZUl0ZW1zKHRoZW1lKTtcblxuICAgICAgICB0aGlzLl9pbmhlcml0VGhlbWVGb250KHRoZW1lLCB0YXJnZXRJdGVtcyk7XG4gICAgICAgIHRoaXMuX2NvcHlDb2xvckluZm8odGhlbWUpO1xuICAgICAgICB0aGVtZXNbdGhlbWVOYW1lXSA9IHRoZW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0IHRoZW1lLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgX2luaXRUaGVtZTogZnVuY3Rpb24odGhlbWUpIHtcbiAgICAgICAgdmFyIGNsb25lVGhlbWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZmF1bHRUaGVtZSkpLFxuICAgICAgICAgICAgbmV3VGhlbWU7XG5cbiAgICAgICAgdGhpcy5fY29uY2F0RGVmYXVsdENvbG9ycyh0aGVtZSwgY2xvbmVUaGVtZS5zZXJpZXMuY29sb3JzKTtcbiAgICAgICAgbmV3VGhlbWUgPSB0aGlzLl9vdmVyd3JpdGVUaGVtZSh0aGVtZSwgY2xvbmVUaGVtZSk7XG5cbiAgICAgICAgbmV3VGhlbWUgPSB0aGlzLl9jb3B5UHJvcGVydHkoe1xuICAgICAgICAgICAgcHJvcE5hbWU6ICd5QXhpcycsXG4gICAgICAgICAgICBmcm9tVGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgdG9UaGVtZTogbmV3VGhlbWUsXG4gICAgICAgICAgICByZWplY3Rpb25Qcm9wczogY2hhcnRDb25zdC5ZQVhJU19QUk9QU1xuICAgICAgICB9KTtcblxuICAgICAgICBuZXdUaGVtZSA9IHRoaXMuX2NvcHlQcm9wZXJ0eSh7XG4gICAgICAgICAgICBwcm9wTmFtZTogJ3NlcmllcycsXG4gICAgICAgICAgICBmcm9tVGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgdG9UaGVtZTogbmV3VGhlbWUsXG4gICAgICAgICAgICByZWplY3Rpb25Qcm9wczogY2hhcnRDb25zdC5TRVJJRVNfUFJPUFNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1RoZW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgY2hhcnQgdHlwZXMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCB0YXJnZXQgY2hhcnRzXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gcmVqZWN0aW9uUHJvcHMgcmVqZWN0IHByb3BlcnR5XG4gICAgICogQHJldHVybnMge09iamVjdH0gZmlsdGVyZWQgY2hhcnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbHRlckNoYXJ0VHlwZXM6IGZ1bmN0aW9uKHRhcmdldCwgcmVqZWN0aW9uUHJvcHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHR1aS51dGlsLmZpbHRlcih0YXJnZXQsIGZ1bmN0aW9uKGl0ZW0sIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5pbkFycmF5KG5hbWUsIHJlamVjdGlvblByb3BzKSA9PT0gLTE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbmNhdCBjb2xvcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRoZW1lXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc2VyaWVzQ29sb3JzIHNlcmllcyBjb2xvcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb25jYXRDb2xvcnM6IGZ1bmN0aW9uKHRoZW1lLCBzZXJpZXNDb2xvcnMpIHtcbiAgICAgICAgaWYgKHRoZW1lLmNvbG9ycykge1xuICAgICAgICAgICAgdGhlbWUuY29sb3JzID0gdGhlbWUuY29sb3JzLmNvbmNhdChzZXJpZXNDb2xvcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoZW1lLnNpbmdsZUNvbG9ycykge1xuICAgICAgICAgICAgdGhlbWUuc2luZ2xlQ29sb3JzID0gdGhlbWUuc2luZ2xlQ29sb3JzLmNvbmNhdChzZXJpZXNDb2xvcnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbmNhdCBkZWZhdWx0IGNvbG9ycy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgdGhlbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzZXJpZXNDb2xvcnMgc2VyaWVzIGNvbG9yc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NvbmNhdERlZmF1bHRDb2xvcnM6IGZ1bmN0aW9uKHRoZW1lLCBzZXJpZXNDb2xvcnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgY2hhcnRUeXBlcztcblxuICAgICAgICBpZiAoIXRoZW1lLnNlcmllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnRUeXBlcyA9IHRoaXMuX2ZpbHRlckNoYXJ0VHlwZXModGhlbWUuc2VyaWVzLCBjaGFydENvbnN0LlNFUklFU19QUk9QUyk7XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5rZXlzKGNoYXJ0VHlwZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fY29uY2F0Q29sb3JzKHRoZW1lLnNlcmllcywgc2VyaWVzQ29sb3JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goY2hhcnRUeXBlcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2NvbmNhdENvbG9ycyhpdGVtLCBzZXJpZXNDb2xvcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRlIHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZyb20gZnJvbSB0aGVtZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0byB0byB0aGVtZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJlc3VsdCBwcm9wZXJ0eVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX292ZXJ3cml0ZVRoZW1lOiBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh0bywgZnVuY3Rpb24oaXRlbSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgZnJvbUl0ZW0gPSBmcm9tW2tleV07XG4gICAgICAgICAgICBpZiAoIWZyb21JdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHVpLnV0aWwuaXNBcnJheShmcm9tSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0b1trZXldID0gZnJvbUl0ZW0uc2xpY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHVpLnV0aWwuaXNPYmplY3QoZnJvbUl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fb3ZlcndyaXRlVGhlbWUoZnJvbUl0ZW0sIGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b1trZXldID0gZnJvbUl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29weSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucHJvcE5hbWUgcHJvcGVydHkgbmFtZVxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5mcm9tVGhlbWUgZnJvbSBwcm9wZXJ0eVxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50b1RoZW1lIHRwIHByb3BlcnR5XG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXJhbXMucmVqZWN0aW9uUHJvcHMgcmVqZWN0IHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBjb3BpZWQgcHJvcGVydHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb3B5UHJvcGVydHk6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBjaGFydFR5cGVzO1xuXG4gICAgICAgIGlmICghcGFyYW1zLnRvVGhlbWVbcGFyYW1zLnByb3BOYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy50b1RoZW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnRUeXBlcyA9IHRoaXMuX2ZpbHRlckNoYXJ0VHlwZXMocGFyYW1zLmZyb21UaGVtZVtwYXJhbXMucHJvcE5hbWVdLCBwYXJhbXMucmVqZWN0aW9uUHJvcHMpO1xuICAgICAgICBpZiAodHVpLnV0aWwua2V5cyhjaGFydFR5cGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goY2hhcnRUeXBlcywgZnVuY3Rpb24oaXRlbSwga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lVGhlbWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZmF1bHRUaGVtZVtwYXJhbXMucHJvcE5hbWVdKSk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZyb21UaGVtZVtwYXJhbXMucHJvcE5hbWVdW2tleV0gPSBzZWxmLl9vdmVyd3JpdGVUaGVtZShpdGVtLCBjbG9uZVRoZW1lKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwYXJhbXMudG9UaGVtZVtwYXJhbXMucHJvcE5hbWVdID0gcGFyYW1zLmZyb21UaGVtZVtwYXJhbXMucHJvcE5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcy50b1RoZW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGNvbG9yIGluZm8gdG8gbGVnZW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc1RoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsZWdlbmRUaGVtZSBsZWdlbmQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgY29sb3JzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29weUNvbG9ySW5mb1RvT3RoZXI6IGZ1bmN0aW9uKHNlcmllc1RoZW1lLCBsZWdlbmRUaGVtZSwgY29sb3JzKSB7XG4gICAgICAgIGxlZ2VuZFRoZW1lLmNvbG9ycyA9IGNvbG9ycyB8fCBzZXJpZXNUaGVtZS5jb2xvcnM7XG4gICAgICAgIGlmIChzZXJpZXNUaGVtZS5zaW5nbGVDb2xvcnMpIHtcbiAgICAgICAgICAgIGxlZ2VuZFRoZW1lLnNpbmdsZUNvbG9ycyA9IHNlcmllc1RoZW1lLnNpbmdsZUNvbG9ycztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VyaWVzVGhlbWUuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIGxlZ2VuZFRoZW1lLmJvcmRlckNvbG9yID0gc2VyaWVzVGhlbWUuYm9yZGVyQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcmllc1RoZW1lLnNlbGVjdGlvbkNvbG9yKSB7XG4gICAgICAgICAgICBsZWdlbmRUaGVtZS5zZWxlY3Rpb25Db2xvciA9IHNlcmllc1RoZW1lLnNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0YXJnZXQgaXRlbXMgYWJvdXQgZm9udCBpbmhlcml0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gdGFyZ2V0IGl0ZW1zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0SW5oZXJpdFRhcmdldFRoZW1lSXRlbXM6IGZ1bmN0aW9uKHRoZW1lKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IFtcbiAgICAgICAgICAgICAgICB0aGVtZS50aXRsZSxcbiAgICAgICAgICAgICAgICB0aGVtZS54QXhpcy50aXRsZSxcbiAgICAgICAgICAgICAgICB0aGVtZS54QXhpcy5sYWJlbCxcbiAgICAgICAgICAgICAgICB0aGVtZS5sZWdlbmQubGFiZWxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB5QXhpc0NoYXJ0VHlwZVRoZW1zID0gdGhpcy5fZmlsdGVyQ2hhcnRUeXBlcyh0aGVtZS55QXhpcywgY2hhcnRDb25zdC5ZQVhJU19QUk9QUyksXG4gICAgICAgICAgICBzZXJpZXNDaGFydFR5cGVUaGVtZXMgPSB0aGlzLl9maWx0ZXJDaGFydFR5cGVzKHRoZW1lLnNlcmllcywgY2hhcnRDb25zdC5TRVJJRVNfUFJPUFMpO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwua2V5cyh5QXhpc0NoYXJ0VHlwZVRoZW1zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2godGhlbWUueUF4aXMudGl0bGUpO1xuICAgICAgICAgICAgaXRlbXMucHVzaCh0aGVtZS55QXhpcy5sYWJlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHlBeGlzQ2hhcnRUeXBlVGhlbXMsIGZ1bmN0aW9uKGNoYXRUeXBlVGhlbWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNoYXRUeXBlVGhlbWUudGl0bGUpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goY2hhdFR5cGVUaGVtZS5sYWJlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHVpLnV0aWwua2V5cyhzZXJpZXNDaGFydFR5cGVUaGVtZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh0aGVtZS5zZXJpZXMubGFiZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNDaGFydFR5cGVUaGVtZXMsIGZ1bmN0aW9uKGNoYXRUeXBlVGhlbWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNoYXRUeXBlVGhlbWUubGFiZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaGVyaXQgdGhlbWUgZm9udC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgdGhlbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSB0YXJnZXRJdGVtcyB0YXJnZXQgdGhlbWUgaXRlbXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbmhlcml0VGhlbWVGb250OiBmdW5jdGlvbih0aGVtZSwgdGFyZ2V0SXRlbXMpIHtcbiAgICAgICAgdmFyIGJhc2VGb250ID0gdGhlbWUuY2hhcnQuZm9udEZhbWlseTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGFyZ2V0SXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICghaXRlbS5mb250RmFtaWx5KSB7XG4gICAgICAgICAgICAgICAgaXRlbS5mb250RmFtaWx5ID0gYmFzZUZvbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGNvbG9yIGluZm8uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRoZW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgX2NvcHlDb2xvckluZm86IGZ1bmN0aW9uKHRoZW1lKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNlcmllc05hbWVzID0gdGhpcy5fZmlsdGVyQ2hhcnRUeXBlcyh0aGVtZS5zZXJpZXMsIGNoYXJ0Q29uc3QuU0VSSUVTX1BST1BTKTtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmtleXMoc2VyaWVzTmFtZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fY29weUNvbG9ySW5mb1RvT3RoZXIodGhlbWUuc2VyaWVzLCB0aGVtZS5sZWdlbmQpO1xuICAgICAgICAgICAgdGhpcy5fY29weUNvbG9ySW5mb1RvT3RoZXIodGhlbWUuc2VyaWVzLCB0aGVtZS50b29sdGlwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goc2VyaWVzTmFtZXMsIGZ1bmN0aW9uKGl0ZW0sIGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgICAgIHRoZW1lLmxlZ2VuZFtjaGFydFR5cGVdID0ge307XG4gICAgICAgICAgICAgICAgdGhlbWUudG9vbHRpcFtjaGFydFR5cGVdID0ge307XG4gICAgICAgICAgICAgICAgc2VsZi5fY29weUNvbG9ySW5mb1RvT3RoZXIoaXRlbSwgdGhlbWUubGVnZW5kW2NoYXJ0VHlwZV0sIGl0ZW0uY29sb3JzIHx8IHRoZW1lLmxlZ2VuZC5jb2xvcnMpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2NvcHlDb2xvckluZm9Ub090aGVyKGl0ZW0sIHRoZW1lLnRvb2x0aXBbY2hhcnRUeXBlXSwgaXRlbS5jb2xvcnMgfHwgdGhlbWUudG9vbHRpcC5jb2xvcnMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGVtZS5sZWdlbmQuY29sb3JzO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGVtZS50b29sdGlwLmNvbG9ycztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBBeGlzIERhdGEgTWFrZXJcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcblxuLyoqXG4gKiBBeGlzIGRhdGEgbWFrZXIuXG4gKiBAbW9kdWxlIGF4aXNEYXRhTWFrZXJcbiAqL1xudmFyIGF4aXNEYXRhTWFrZXIgPSB7XG4gICAgLyoqXG4gICAgICogTWFrZXMgbGFiZWxzIGJ5IGxhYmVsSW50ZXJ2YWwgb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVscyAtIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEludGVydmFsIC0gbGFiZWwgaW50ZXJ2YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthZGRlZERhdGFDb3VudF0gLSBhZGRlZCBkYXRhIGNvdW50XG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSBsYWJlbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxzQnlJbnRlcnZhbE9wdGlvbjogZnVuY3Rpb24obGFiZWxzLCBsYWJlbEludGVydmFsLCBhZGRlZERhdGFDb3VudCkge1xuICAgICAgICBhZGRlZERhdGFDb3VudCA9IGFkZGVkRGF0YUNvdW50IHx8IDA7XG4gICAgICAgIGxhYmVscyA9IHR1aS51dGlsLm1hcChsYWJlbHMsIGZ1bmN0aW9uKGxhYmVsLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCgoaW5kZXggKyBhZGRlZERhdGFDb3VudCkgJSBsYWJlbEludGVydmFsKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gY2hhcnRDb25zdC5FTVBUWV9BWElTX0xBQkVMO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZGF0YSBhYm91dCBsYWJlbCBheGlzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gcGFyYW1zLmxhYmVscyAtIGNoYXJ0IGxhYmVsc1xuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaXNWZXJ0aWNhbCAtIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5hbGlnbmVkIC0gd2hldGhlciBhbGlnbiBvciBub3RcbiAgICAgKiAgICAgIEBwYXJhbSB7P2Jvb2xlYW59IHBhcmFtcy5hZGRlZERhdGFDb3VudCAtIGFkZGVkIGRhdGEgY291bnRcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgbGFiZWxzOiBBcnJheS48c3RyaW5nPixcbiAgICAgKiAgICAgIHRpY2tDb3VudDogbnVtYmVyLFxuICAgICAqICAgICAgdmFsaWRUaWNrQ291bnQ6IG51bWJlcixcbiAgICAgKiAgICAgIGlzTGFiZWxBeGlzOiBib29sZWFuLFxuICAgICAqICAgICAgaXNWZXJ0aWNhbDogYm9vbGVhblxuICAgICAqIH19IGF4aXMgZGF0YVxuICAgICAqL1xuICAgIG1ha2VMYWJlbEF4aXNEYXRhOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHRpY2tDb3VudCA9IHBhcmFtcy5sYWJlbHMubGVuZ3RoO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgbGFiZWxzID0gcGFyYW1zLmxhYmVscztcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzVmFsaWRMYWJlbEludGVydmFsKG9wdGlvbnMubGFiZWxJbnRlcnZhbCwgb3B0aW9ucy50aWNrSW50ZXJ2YWwpXG4gICAgICAgICAgICAgICAgJiYgcGFyYW1zLmxhYmVscy5sZW5ndGggPiBvcHRpb25zLmxhYmVsSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGxhYmVscyA9IHRoaXMuX21ha2VMYWJlbHNCeUludGVydmFsT3B0aW9uKHBhcmFtcy5sYWJlbHMsIG9wdGlvbnMubGFiZWxJbnRlcnZhbCwgcGFyYW1zLmFkZGVkRGF0YUNvdW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyYW1zLmFsaWduZWQpIHtcbiAgICAgICAgICAgIHRpY2tDb3VudCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgICAgICAgdGlja0NvdW50OiB0aWNrQ291bnQsXG4gICAgICAgICAgICB2YWxpZFRpY2tDb3VudDogMCxcbiAgICAgICAgICAgIGlzTGFiZWxBeGlzOiB0cnVlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGlzVmVydGljYWw6ICEhcGFyYW1zLmlzVmVydGljYWwsXG4gICAgICAgICAgICBpc1Bvc2l0aW9uUmlnaHQ6ICEhcGFyYW1zLmlzUG9zaXRpb25SaWdodCxcbiAgICAgICAgICAgIGFsaWduZWQ6ICEhcGFyYW1zLmFsaWduZWRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBkYXRhIGFib3V0IHZhbHVlIGF4aXMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0F4aXNTY2FsZU1ha2VyfSBwYXJhbXMuYXhpc1NjYWxlTWFrZXIgY2hhcnQgdmFsdWVzXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGxhYmVsczogQXJyYXkuPHN0cmluZz4sXG4gICAgICogICAgICB0aWNrQ291bnQ6IG51bWJlcixcbiAgICAgKiAgICAgIHZhbGlkVGlja0NvdW50OiBudW1iZXIsXG4gICAgICogICAgICBpc0xhYmVsQXhpczogYm9vbGVhbixcbiAgICAgKiAgICAgIGxpbWl0OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGlzVmVydGljYWw6IGJvb2xlYW5cbiAgICAgKiB9fSBheGlzIGRhdGFcbiAgICAgKi9cbiAgICBtYWtlVmFsdWVBeGlzRGF0YTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBheGlzU2NhbGVNYWtlciA9IHBhcmFtcy5heGlzU2NhbGVNYWtlcixcbiAgICAgICAgICAgIHJhbmdlVmFsdWVzID0gYXhpc1NjYWxlTWFrZXIuZ2V0Rm9ybWF0dGVkU2NhbGVWYWx1ZXMoKSxcbiAgICAgICAgICAgIHRpY2tDb3VudCA9IHJhbmdlVmFsdWVzLmxlbmd0aDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWxzOiByYW5nZVZhbHVlcyxcbiAgICAgICAgICAgIHRpY2tDb3VudDogdGlja0NvdW50LFxuICAgICAgICAgICAgdmFsaWRUaWNrQ291bnQ6IHRpY2tDb3VudCxcbiAgICAgICAgICAgIGxpbWl0OiBheGlzU2NhbGVNYWtlci5nZXRMaW1pdCgpLFxuICAgICAgICAgICAgc3RlcDogYXhpc1NjYWxlTWFrZXIuZ2V0U3RlcCgpLFxuICAgICAgICAgICAgb3B0aW9uczogcGFyYW1zLm9wdGlvbnMsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiAhIXBhcmFtcy5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgaXNQb3NpdGlvblJpZ2h0OiAhIXBhcmFtcy5pc1Bvc2l0aW9uUmlnaHQsXG4gICAgICAgICAgICBhbGlnbmVkOiAhIXBhcmFtcy5hbGlnbmVkXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYWRqdXN0aW5nIHRpY2sgaW50ZXJ2YWwgaW5mb3JtYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlZm9yZUJsb2NrQ291bnQgLSBiZWZvcmUgYmxvY2sgY291bnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VyaWVzV2lkdGggLSB3aWR0aCBvZiBzZXJpZXMgYXJlYVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja1NpemUgLSBibG9jayBzaXplXG4gICAgICogQHJldHVybnMge251bGwgfCB7YmxvY2tDb3VudDogbnVtYmVyLCBiZWZvcmVSZW1haW5CbG9ja0NvdW50OiBudW1iZXIsIGludGVydmFsOiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBZGp1c3RpbmdJbnRlcnZhbEluZm86IGZ1bmN0aW9uKGJlZm9yZUJsb2NrQ291bnQsIHNlcmllc1dpZHRoLCBibG9ja1NpemUpIHtcbiAgICAgICAgdmFyIG5ld0Jsb2NrQ291bnQgPSBwYXJzZUludChzZXJpZXNXaWR0aCAvIGJsb2NrU2l6ZSwgMTApO1xuICAgICAgICAvLyBpbnRlcnZhbCA6IO2VmOuCmOydmCDsg4jroZzsmrQgYmxvY2sodGlja+qzvCB0aWNrIOyCrOydtOydmCDqs7XqsIQpIOyYgeyXreyXkCDtj6ztlajrkJjripQg7J207KCEIGJsb2NrIOyImFxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBwYXJzZUludChiZWZvcmVCbG9ja0NvdW50IC8gbmV3QmxvY2tDb3VudCwgMTApO1xuICAgICAgICB2YXIgaW50ZXJ2YWxJbmZvID0gbnVsbDtcbiAgICAgICAgdmFyIHJlbWFpbkNvdW50O1xuXG4gICAgICAgIGlmIChpbnRlcnZhbCA+IDEpIHtcbiAgICAgICAgICAgIC8vIHJlbWFpbkNvdW50IDog7J207KCEIGJsb2Nr65OkIOykkSDsg4jroZzsmrQgYmxvY2vsnLzroZwg7LGE7Jqw6rOgIOuCqOydgCDsnbTsoIQgYmxvY2sg7IiYXG4gICAgICAgICAgICAvLyB8IHwgfCB8IHwgfCB8IHwgfCB8IHwgfCAgLSDsnbTsoIQgYmxvY2tcbiAgICAgICAgICAgIC8vIHwgICAgIHwgICAgIHwgICAgIHwgICAgICAtIOyDiOuhnCDqs4TsgrDrkJwgYmxvY2tcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgIHwqfCp8ICAtIOuCqOydgCDsnbTsoIQgYmxvY2sg7IiYXG4gICAgICAgICAgICByZW1haW5Db3VudCA9IGJlZm9yZUJsb2NrQ291bnQgLSAoaW50ZXJ2YWwgKiBuZXdCbG9ja0NvdW50KTtcblxuICAgICAgICAgICAgaWYgKHJlbWFpbkNvdW50ID49IGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgbmV3QmxvY2tDb3VudCArPSBwYXJzZUludChyZW1haW5Db3VudCAvIGludGVydmFsLCAwKTtcbiAgICAgICAgICAgICAgICByZW1haW5Db3VudCA9IHJlbWFpbkNvdW50ICUgaW50ZXJ2YWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGludGVydmFsSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBibG9ja0NvdW50OiBuZXdCbG9ja0NvdW50LFxuICAgICAgICAgICAgICAgIGJlZm9yZVJlbWFpbkJsb2NrQ291bnQ6IHJlbWFpbkNvdW50LFxuICAgICAgICAgICAgICAgIGludGVydmFsOiBpbnRlcnZhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcnZhbEluZm87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY2FuZGlkYXRlIGZvciBhZGp1c3RpbmcgdGljayBpbnRlcnZhbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmVmb3JlQmxvY2tDb3VudCAtIGJlZm9yZSBibG9jayBjb3VudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNXaWR0aCAtIHdpZHRoIG9mIHNlcmllcyBhcmVhXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7bmV3QmxvY2tDb3VudDogbnVtYmVyLCByZW1haW5CbG9ja0NvdW50OiBudW1iZXIsIGludGVydmFsOiBudW1iZXJ9Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ2FuZGlkYXRlc0ZvckFkanVzdGluZ0ludGVydmFsOiBmdW5jdGlvbihiZWZvcmVCbG9ja0NvdW50LCBzZXJpZXNXaWR0aCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBibG9ja1NpemVSYW5nZSA9IHR1aS51dGlsLnJhbmdlKDkwLCAxMjEsIDUpOyAvLyBbOTAsIDk1LCAxMDAsIDEwNSwgMTEwLCAxMTUsIDEyMF1cbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSB0dWkudXRpbC5tYXAoYmxvY2tTaXplUmFuZ2UsIGZ1bmN0aW9uKGJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX21ha2VBZGp1c3RpbmdJbnRlcnZhbEluZm8oYmVmb3JlQmxvY2tDb3VudCwgc2VyaWVzV2lkdGgsIGJsb2NrU2l6ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5maWx0ZXIoY2FuZGlkYXRlcywgZnVuY3Rpb24oaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuICEhaW5mbztcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhZGp1c3RpbmcgaW50ZXJ2YWwgaW5mb3JtYXRpb24gZm9yIGF1dG8gdGljayBpbnRlcnZhbCBvcHRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN1ckJsb2NrQ291bnQgLSBjdXJyZW50IGJsb2NrIGNvdW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlcmllc1dpZHRoIC0gc2VyaWVzIHdpZHRoXG4gICAgICogQHJldHVybnMge3tuZXdCbG9ja0NvdW50OiBudW1iZXIsIHJlbWFpbkJsb2NrQ291bnQ6IG51bWJlciwgaW50ZXJ2YWw6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQWRqdXN0aW5nSW50ZXJ2YWxJbmZvOiBmdW5jdGlvbihjdXJCbG9ja0NvdW50LCBzZXJpZXNXaWR0aCkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IHRoaXMuX21ha2VDYW5kaWRhdGVzRm9yQWRqdXN0aW5nSW50ZXJ2YWwoY3VyQmxvY2tDb3VudCwgc2VyaWVzV2lkdGgpO1xuICAgICAgICB2YXIgaW50ZXJ2YWxJbmZvID0gbnVsbDtcblxuICAgICAgICBpZiAoY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGludGVydmFsSW5mbyA9IHR1aS51dGlsLm1pbihjYW5kaWRhdGVzLCBmdW5jdGlvbihjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlLmJsb2NrQ291bnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcnZhbEluZm87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZmlsdGVyZWQgbGFiZWxzIGJ5IGludGVydmFsLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVscyAtIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IC0gc3RhcnQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJyZXJ9IGludGVydmFsIC0gaW50ZXJ2YWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUZpbHRlcmVkTGFiZWxzQnlJbnRlcnZhbDogZnVuY3Rpb24obGFiZWxzLCBzdGFydEluZGV4LCBpbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwuZmlsdGVyKGxhYmVscy5zbGljZShzdGFydEluZGV4KSwgZnVuY3Rpb24obGFiZWwsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggJSBpbnRlcnZhbCA9PT0gMDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBsYWJlbCB0eXBlIGF4aXNEYXRhIGZvciBhdXRvIHRpY2sgaW50ZXJ2YWwgb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBheGlzRGF0YSAtIGF4aXNEYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlcmllc1dpZHRoIC0gc2VyaWVzIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthZGRlZERhdGFDb3VudF0gLSBhZGRlZCBkYXRhIGNvdW50XG4gICAgICovXG4gICAgdXBkYXRlTGFiZWxBeGlzRGF0YUZvckF1dG9UaWNrSW50ZXJ2YWw6IGZ1bmN0aW9uKGF4aXNEYXRhLCBzZXJpZXNXaWR0aCwgYWRkZWREYXRhQ291bnQpIHtcbiAgICAgICAgdmFyIGJlZm9yZUJsb2NrQ291bnQgPSBheGlzRGF0YS50aWNrQ291bnQgLSAxO1xuICAgICAgICB2YXIgaW50ZXJ2YWxJbmZvID0gdGhpcy5fY2FsY3VsYXRlQWRqdXN0aW5nSW50ZXJ2YWxJbmZvKGJlZm9yZUJsb2NrQ291bnQsIHNlcmllc1dpZHRoKTtcbiAgICAgICAgdmFyIGFkanVzdGluZ0Jsb2NrQ291bnQsIGludGVydmFsLCBiZWZvcmVSZW1haW5CbG9ja0NvdW50LCBzdGFydEluZGV4O1xuXG4gICAgICAgIGlmICghaW50ZXJ2YWxJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RpbmdCbG9ja0NvdW50ID0gaW50ZXJ2YWxJbmZvLmJsb2NrQ291bnQ7XG4gICAgICAgIGludGVydmFsID0gaW50ZXJ2YWxJbmZvLmludGVydmFsO1xuICAgICAgICBiZWZvcmVSZW1haW5CbG9ja0NvdW50ID0gaW50ZXJ2YWxJbmZvLmJlZm9yZVJlbWFpbkJsb2NrQ291bnQ7XG4gICAgICAgIGF4aXNEYXRhLmV2ZW50VGlja0NvdW50ID0gYXhpc0RhdGEudGlja0NvdW50O1xuXG4gICAgICAgIC8vIHN0YXJ0SW5kZXjripQg64Ko7J2AIGJsb2Nr7IiY7J2YIOuwmCDrp4ztgbzsl5DshJwg7ZiE7J6sIOydtOuPmeuQnCB0aWNrIOyImOulvCDruoAg66eM7YG87Jy866GcIOyEpOygle2VqFxuICAgICAgICAvLyB8ICAgICB8ICAgICB8ICAgICB8KnwqfCp8ICAgIC0gKiDsmIHsl63snbQg64Ko7J2AIOydtOyghCBibG9jayDsiJhcbiAgICAgICAgLy8gfCp8KnxPICAgIHwgICAgIHwgICAgIHwqfCAgICAtIO2YhOyerCDsnbTrj5nrkJwgdGlja+ydtCDsl4bsnYQg6rK97JqwIChPIOyngOygkOydtCBzdGFydEluZGV4ID0gMilcbiAgICAgICAgLy8gfCp8TyAgICB8ICAgICB8ICAgICB8KnwqfCAgICAtIHRpY2vsnbQg7ZWY64KYIOydtOuPmSDrkJDsnYQg6rK97JqwIDogTyDsp4DsoJDsnbQgc3RhcnRJbmRleCA9IDEpXG4gICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLnJvdW5kKGJlZm9yZVJlbWFpbkJsb2NrQ291bnQgLyAyKSAtIChhZGRlZERhdGFDb3VudCAlIGludGVydmFsKTtcblxuICAgICAgICAvLyBzdGFydEluZGV46rCAIDDrs7Tri6Qg7J6R7J2EIOqyveyasCBpbnRlcnZhbOunjO2BvCDspp3qsIDsi5ztgrRcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCAwKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ICs9IGludGVydmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc0RhdGEubGFiZWxzID0gdGhpcy5fbWFrZUZpbHRlcmVkTGFiZWxzQnlJbnRlcnZhbChheGlzRGF0YS5sYWJlbHMsIHN0YXJ0SW5kZXgsIGludGVydmFsKTtcblxuICAgICAgICB0dWkudXRpbC5leHRlbmQoYXhpc0RhdGEsIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICB0aWNrQ291bnQ6IGFkanVzdGluZ0Jsb2NrQ291bnQgKyAxLFxuICAgICAgICAgICAgcG9zaXRpb25SYXRpbzogKHN0YXJ0SW5kZXggLyBiZWZvcmVCbG9ja0NvdW50KSxcbiAgICAgICAgICAgIHNpemVSYXRpbzogMSAtIChiZWZvcmVSZW1haW5CbG9ja0NvdW50IC8gYmVmb3JlQmxvY2tDb3VudCksXG4gICAgICAgICAgICBsaW5lV2lkdGg6IHNlcmllc1dpZHRoICsgY2hhcnRDb25zdC5PVkVSTEFQUElOR19XSURUSCxcbiAgICAgICAgICAgIGludGVydmFsOiBpbnRlcnZhbFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGxhYmVsIHR5cGUgYXhpc0RhdGEgZm9yIHN0YWNraW5nIGR5bmFtaWMgZGF0YS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXhpc0RhdGEgLSBheGlzIGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlVwZGF0ZWREYXRhIC0gcHJldmlvdXMgdXBkYXRlZCBheGlzRGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaXJzdFRpY2tDb3VudCAtIGNhbGN1bGF0ZWQgZmlyc3QgdGljayBjb3VudFxuICAgICAqL1xuICAgIHVwZGF0ZUxhYmVsQXhpc0RhdGFGb3JTdGFja2luZ0R5bmFtaWNEYXRhOiBmdW5jdGlvbihheGlzRGF0YSwgcHJldlVwZGF0ZWREYXRhLCBmaXJzdFRpY2tDb3VudCkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBwcmV2VXBkYXRlZERhdGEuaW50ZXJ2YWw7XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gcHJldlVwZGF0ZWREYXRhLnN0YXJ0SW5kZXg7XG4gICAgICAgIHZhciBiZWZvcmVCbG9ja0NvdW50ID0gYXhpc0RhdGEudGlja0NvdW50IC0gMTtcbiAgICAgICAgdmFyIG5ld0Jsb2NrQ291bnQgPSBiZWZvcmVCbG9ja0NvdW50IC8gaW50ZXJ2YWw7XG4gICAgICAgIHZhciBmaXJzdEJsb2NrQ291bnQgPSBmaXJzdFRpY2tDb3VudCA/IGZpcnN0VGlja0NvdW50IC0gMSA6IDA7XG4gICAgICAgIHZhciBiZWZvcmVSZW1haW5CbG9ja0NvdW50O1xuXG4gICAgICAgIC8vIOyDiOuhnCDqs4TsgrDrkJwgYmxvY2vsnZgg7IiY6rCAIOy1nOy0iOuhnCDqs4TsgrDrkJwgYmxvY2sg7IiY7J2YIOuRkOuwsOyImCDrs7Tri6Qg66eO7JWE7KeA66m0IGludGVydmFsIOyIq+yekOulvCDrkZDrsLDroZwg64qY66a8XG4gICAgICAgIGlmIChmaXJzdEJsb2NrQ291bnQgJiYgKChmaXJzdEJsb2NrQ291bnQgKiAyKSA8PSBuZXdCbG9ja0NvdW50KSkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNEYXRhLmxhYmVscyA9IHRoaXMuX21ha2VGaWx0ZXJlZExhYmVsc0J5SW50ZXJ2YWwoYXhpc0RhdGEubGFiZWxzLCBzdGFydEluZGV4LCBpbnRlcnZhbCk7XG4gICAgICAgIG5ld0Jsb2NrQ291bnQgPSBheGlzRGF0YS5sYWJlbHMubGVuZ3RoIC0gMTtcbiAgICAgICAgYmVmb3JlUmVtYWluQmxvY2tDb3VudCA9IGJlZm9yZUJsb2NrQ291bnQgLSAoaW50ZXJ2YWwgKiBuZXdCbG9ja0NvdW50KTtcblxuICAgICAgICB0dWkudXRpbC5leHRlbmQoYXhpc0RhdGEsIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICBldmVudFRpY2tDb3VudDogYXhpc0RhdGEudGlja0NvdW50LFxuICAgICAgICAgICAgdGlja0NvdW50OiBheGlzRGF0YS5sYWJlbHMubGVuZ3RoLFxuICAgICAgICAgICAgcG9zaXRpb25SYXRpbzogc3RhcnRJbmRleCAvIGJlZm9yZUJsb2NrQ291bnQsXG4gICAgICAgICAgICBzaXplUmF0aW86IDEgLSAoYmVmb3JlUmVtYWluQmxvY2tDb3VudCAvIGJlZm9yZUJsb2NrQ291bnQpLFxuICAgICAgICAgICAgbGluZVdpZHRoOiBwcmV2VXBkYXRlZERhdGEubGluZVdpZHRoLFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGludGVydmFsXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpc0RhdGFNYWtlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBBeGlzU2NhbGVNYWtlciBjYWxjdWxhdGVzIHRoZSBsaW1pdCBhbmQgc3RlcCBpbnRvIHZhbHVlcyBvZiBwcm9jZXNzZWQgZGF0YSBhbmQgcmV0dXJucyBpdC5cbiAqIEBhdXRoIE5ITiBFbnQuXG4gKiAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBwcmVkaWNhdGUgPSByZXF1aXJlKCcuL3ByZWRpY2F0ZScpO1xudmFyIGNhbGN1bGF0b3IgPSByZXF1aXJlKCcuL2NhbGN1bGF0b3InKTtcbnZhciByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi9yZW5kZXJVdGlsJyk7XG5cbnZhciBhYnMgPSBNYXRoLmFicztcblxudmFyIEF4aXNTY2FsZU1ha2VyID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBBeGlzU2NhbGVNYWtlci5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogQXhpc1NjYWxlTWFrZXIgY2FsY3VsYXRlcyB0aGUgbGltaXQgYW5kIHN0ZXAgaW50byB2YWx1ZXMgb2YgcHJvY2Vzc2VkIGRhdGEgYW5kIHJldHVybnMgaXQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogQGNvbnN0cnVjdHMgQXhpc1NjYWxlTWFrZXJcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgcHJvY2Vzc29yXG4gICAgICAgICAqIEB0eXBlIHtEYXRhUHJvY2Vzc29yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gcGFyYW1zLmRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhcnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0eXBlIG9mIHZhbHVlIGxpa2UgdmFsdWUsIHgsIHksIHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVUeXBlID0gcGFyYW1zLnZhbHVlVHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdHlwZSBvZiBhcmVhIGxpa2UgeUF4aXMsIHhBeGlzXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFyZWFUeXBlID0gcGFyYW1zLmFyZWFUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHZlcnRpY2FsIHR5cGUgb3Igbm90LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNWZXJ0aWNhbCA9ICEhcGFyYW1zLmlzVmVydGljYWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgc2luZ2xlIHlBeGlzIG9yIG5vdC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzU2luZ2xlWUF4aXMgPSAhIXBhcmFtcy5pc1NpbmdsZVlBeGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ291bnQgb2Ygc2NhbGUgdmFsdWVzLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNvdW50cyA9IHBhcmFtcy52YWx1ZUNvdW50ID8gW3BhcmFtcy52YWx1ZUNvdW50XSA6IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgc2NhbGVcbiAgICAgICAgICogQHR5cGUge3tsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHN0ZXA6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjYWxlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybWF0dGVkIHNjYWxlIHZhbHVlcy5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmcgfCBudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXR0ZWRWYWx1ZXMgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2NhbGUuXG4gICAgICogQHJldHVybnMge3tsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHN0ZXA6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSB0aGlzLl9tYWtlU2NhbGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGltaXQuXG4gICAgICogQHJldHVybnMge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fVxuICAgICAqL1xuICAgIGdldExpbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNjYWxlKCkubGltaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzdGVwLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0U3RlcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTY2FsZSgpLnN0ZXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcGVyY2VudCBzdGFjayBjaGFydCBvciBub3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNQZXJjZW50U3RhY2tDaGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpc0FsbG93ZWRTdGFja09wdGlvbiA9IHByZWRpY2F0ZS5pc0FsbG93ZWRTdGFja09wdGlvbih0aGlzLmNoYXJ0VHlwZSksXG4gICAgICAgICAgICBpc1BlcmNlbnRTdGFjayA9IHByZWRpY2F0ZS5pc1BlcmNlbnRTdGFjayh0aGlzLm9wdGlvbnMuc3RhY2tUeXBlKTtcblxuICAgICAgICByZXR1cm4gaXNBbGxvd2VkU3RhY2tPcHRpb24gJiYgaXNQZXJjZW50U3RhY2s7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgbm9ybWFsIHN0YWNrIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc05vcm1hbFN0YWNrQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXNBbGxvd2VkU3RhY2tPcHRpb24gPSBwcmVkaWNhdGUuaXNBbGxvd2VkU3RhY2tPcHRpb24odGhpcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgaXNOb3JtYWxTdGFjayA9IHByZWRpY2F0ZS5pc05vcm1hbFN0YWNrKHRoaXMub3B0aW9ucy5zdGFja1R5cGUpO1xuXG4gICAgICAgIHJldHVybiBpc0FsbG93ZWRTdGFja09wdGlvbiAmJiBpc05vcm1hbFN0YWNrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGRpdmVyZ2luZyBjaGFydCBvciBub3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0RpdmVyZ2luZ0NoYXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kaXZlcmdpbmcgJiYgcHJlZGljYXRlLmlzQmFyVHlwZUNoYXJ0KHRoaXMuY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGZ1bmN0aW9ucyBmb3IgZm9ybWF0dGluZyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPGZ1bmN0aW9uPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRGb3JtYXRGdW5jdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZm9ybWF0RnVuY3Rpb25zO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1BlcmNlbnRTdGFja0NoYXJ0KCkpIHtcbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9ucyA9IFtmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSArICclJztcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNjYWxlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U2NhbGVWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLl9nZXRTY2FsZSgpLFxuICAgICAgICAgICAgdmFsdWVzID0gY2FsY3VsYXRvci5tYWtlTGFiZWxzRnJvbUxpbWl0KHNjYWxlLmxpbWl0LCBzY2FsZS5zdGVwKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXZlcmdpbmdDaGFydCgpID8gdHVpLnV0aWwubWFwKHZhbHVlcywgYWJzKSA6IHZhbHVlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGZvcm1hdHRlZCBzY2FsZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmd8bnVtYmVyPnwqfVxuICAgICAqL1xuICAgIGdldEZvcm1hdHRlZFNjYWxlVmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYXJ0VHlwZSA9IHRoaXMuY2hhcnRUeXBlO1xuICAgICAgICB2YXIgYXJlYVR5cGUgPSB0aGlzLmFyZWFUeXBlO1xuICAgICAgICB2YXIgdmFsdWVUeXBlID0gdGhpcy52YWx1ZVR5cGU7XG4gICAgICAgIHZhciB2YWx1ZXMsIGZvcm1hdEZ1bmN0aW9ucztcblxuICAgICAgICBpZiAoIXRoaXMuZm9ybWF0dGVkVmFsdWVzKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB0aGlzLl9nZXRTY2FsZVZhbHVlcygpO1xuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5fZ2V0Rm9ybWF0RnVuY3Rpb25zKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZFZhbHVlcyA9IHJlbmRlclV0aWwuZm9ybWF0VmFsdWVzKHZhbHVlcywgZm9ybWF0RnVuY3Rpb25zLCBjaGFydFR5cGUsIGFyZWFUeXBlLCB2YWx1ZVR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkVmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJhc2UgdmFsdWVzIG9mIG5vcm1hbCBzdGFja1R5cGUgY2hhcnQuXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXNlVmFsdWVzRm9yTm9ybWFsU3RhY2tlZENoYXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc0RhdGFNb2RlbCA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRTZXJpZXNEYXRhTW9kZWwodGhpcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgYmFzZVZhbHVlcyA9IFtdO1xuXG4gICAgICAgIHNlcmllc0RhdGFNb2RlbC5lYWNoKGZ1bmN0aW9uKHNlcmllc0dyb3VwKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzTWFwID0gc2VyaWVzR3JvdXAuX21ha2VWYWx1ZXNNYXBQZXJTdGFjaygpO1xuXG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHZhbHVlc01hcCwgZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsdXNTdW0gPSBjYWxjdWxhdG9yLnN1bVBsdXNWYWx1ZXModmFsdWVzKSxcbiAgICAgICAgICAgICAgICAgICAgbWludXNTdW0gPSBjYWxjdWxhdG9yLnN1bU1pbnVzVmFsdWVzKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgYmFzZVZhbHVlcyA9IGJhc2VWYWx1ZXMuY29uY2F0KFtwbHVzU3VtLCBtaW51c1N1bV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBiYXNlVmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJhc2UgdmFsdWVzIGZvciBtYWtpbmcgYXhpcyBzY2FsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IGJhc2UgdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhc2VWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmFzZVZhbHVlcztcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzVHJlZW1hcENoYXJ0KHRoaXMuY2hhcnRUeXBlKSkge1xuICAgICAgICAgICAgYmFzZVZhbHVlcyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZXModGhpcy5jaGFydFR5cGUsICdjb2xvclZhbHVlJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJlZGljYXRlLmlzTWFwQ2hhcnQodGhpcy5jaGFydFR5cGUpIHx8IHRoaXMuaXNTaW5nbGVZQXhpcykge1xuICAgICAgICAgICAgYmFzZVZhbHVlcyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZXMoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc05vcm1hbFN0YWNrQ2hhcnQoKSkge1xuICAgICAgICAgICAgYmFzZVZhbHVlcyA9IHRoaXMuX21ha2VCYXNlVmFsdWVzRm9yTm9ybWFsU3RhY2tlZENoYXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVmFsdWVzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFZhbHVlcyh0aGlzLmNoYXJ0VHlwZSwgdGhpcy52YWx1ZVR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2VWYWx1ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBiYXNlIHNpemUgZm9yIGNhbGN1bGF0aW9uIGNhbmRpZGF0ZSB2YWx1ZSBjb3VudHMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gYmFzZSBzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QmFzZVNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmFzZVNpemU7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgYmFzZVNpemUgPSB0aGlzLmJvdW5kc01ha2VyLm1ha2VTZXJpZXNIZWlnaHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VTaXplID0gdGhpcy5ib3VuZHNNYWtlci5tYWtlU2VyaWVzV2lkdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlU2l6ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNhbmRpZGF0ZSBjb3VudHMgb2YgdmFsdWUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSB2YWx1ZSBjb3VudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDYW5kaWRhdGVDb3VudHNPZlZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1pblN0YXJ0ID0gMyxcbiAgICAgICAgICAgIHZhbHVlQ291bnRzLCBiYXNlU2l6ZSwgc3RhcnQsIGVuZDtcblxuICAgICAgICBiYXNlU2l6ZSA9IHRoaXMuX2dldEJhc2VTaXplKCk7XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgobWluU3RhcnQsIHBhcnNlSW50KGJhc2VTaXplIC8gY2hhcnRDb25zdC5NQVhfUElYRUxfVFlQRV9TVEVQX1NJWkUsIDEwKSk7XG4gICAgICAgIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBwYXJzZUludChiYXNlU2l6ZSAvIGNoYXJ0Q29uc3QuTUlOX1BJWEVMX1RZUEVfU1RFUF9TSVpFLCAxMCkpICsgMTtcbiAgICAgICAgdmFsdWVDb3VudHMgPSB0dWkudXRpbC5yYW5nZShzdGFydCwgZW5kKTtcblxuICAgICAgICByZXR1cm4gdmFsdWVDb3VudHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGltaXQgZm9yIGRpdmVyZ2luZyBvcHRpb24uXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgbGltaXRcbiAgICAgKiBAcmV0dXJucyB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGNoYW5nZWQgbGltaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGltaXRGb3JEaXZlcmdpbmdPcHRpb246IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHZhciBuZXdNYXggPSBNYXRoLm1heChhYnMobGltaXQubWluKSwgYWJzKGxpbWl0Lm1heCkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IC1uZXdNYXgsXG4gICAgICAgICAgICBtYXg6IG5ld01heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGludGVnZXIgdHlwZSBzY2FsZS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBsaW1pdFxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sXG4gICAgICogICAgICBvcHRpb25zOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGRpdmlkZU51bTogbnVtYmVyXG4gICAgICogfX0gaW50ZWdlciB0eXBlIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSW50ZWdlclR5cGVTY2FsZTogZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMubGltaXQgfHwge30sXG4gICAgICAgICAgICBtaW4gPSBsaW1pdC5taW4sXG4gICAgICAgICAgICBtYXggPSBsaW1pdC5tYXgsXG4gICAgICAgICAgICBtdWx0aXBsZU51bSwgY2hhbmdlZE9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGFicyhtaW4pID49IDEgfHwgYWJzKG1heCkgPj0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBkaXZpZGVOdW06IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBtdWx0aXBsZU51bSA9IHR1aS51dGlsLmZpbmRNdWx0aXBsZU51bShtaW4sIG1heCk7XG4gICAgICAgIGNoYW5nZWRPcHRpb25zID0ge307XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc1VuZGVmaW5lZChvcHRpb25zLm1pbikpIHtcbiAgICAgICAgICAgIGNoYW5nZWRPcHRpb25zLm1pbiA9IG9wdGlvbnMubWluICogbXVsdGlwbGVOdW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubWF4KSkge1xuICAgICAgICAgICAgY2hhbmdlZE9wdGlvbnMubWF4ID0gb3B0aW9ucy5tYXggKiBtdWx0aXBsZU51bTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW1pdDoge1xuICAgICAgICAgICAgICAgIG1pbjogbWluICogbXVsdGlwbGVOdW0sXG4gICAgICAgICAgICAgICAgbWF4OiBtYXggKiBtdWx0aXBsZU51bVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGNoYW5nZWRPcHRpb25zLFxuICAgICAgICAgICAgZGl2aWRlTnVtOiBtdWx0aXBsZU51bVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxpbWl0IGlmIGVxdWFsIG1pbiBhbmQgbWF4LlxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGxpbWl0IGxpbWl0XG4gICAgICogQHJldHVybnMge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBjaGFuZ2VkIGxpbWl0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxpbWl0SWZFcXVhbE1pbk1heDogZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgdmFyIG1pbiA9IGxpbWl0Lm1pbixcbiAgICAgICAgICAgIG1heCA9IGxpbWl0Lm1heDtcblxuICAgICAgICBpZiAobWluID4gMCkge1xuICAgICAgICAgICAgbWluID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChtaW4gPCAwKSB7XG4gICAgICAgICAgICBtYXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogbWluLFxuICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBiYXNlIGxpbWl0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gZGF0YUxpbWl0IHVzZXIgbGltaXRcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBvcHRpb25zIGF4aXMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gYmFzZSBsaW1pdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXNlTGltaXQ6IGZ1bmN0aW9uKGRhdGFMaW1pdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaXNNaW51c0xpbWl0ID0gcHJlZGljYXRlLmlzTWludXNMaW1pdChkYXRhTGltaXQpLFxuICAgICAgICAgICAgbWluID0gZGF0YUxpbWl0Lm1pbixcbiAgICAgICAgICAgIG1heCA9IGRhdGFMaW1pdC5tYXgsXG4gICAgICAgICAgICBiYXNlTGltaXQsIHRtcE1pbjtcblxuICAgICAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgICAgICAgIGJhc2VMaW1pdCA9IHRoaXMuX21ha2VMaW1pdElmRXF1YWxNaW5NYXgoZGF0YUxpbWl0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc01pbnVzTGltaXQpIHtcbiAgICAgICAgICAgICAgICB0bXBNaW4gPSBtaW47XG4gICAgICAgICAgICAgICAgbWluID0gLW1heDtcbiAgICAgICAgICAgICAgICBtYXggPSAtdG1wTWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXNlTGltaXQgPSBjYWxjdWxhdG9yLmNhbGN1bGF0ZUxpbWl0KG1pbiwgbWF4KTtcblxuICAgICAgICAgICAgaWYgKGlzTWludXNMaW1pdCkge1xuICAgICAgICAgICAgICAgIHRtcE1pbiA9IGJhc2VMaW1pdC5taW47XG4gICAgICAgICAgICAgICAgYmFzZUxpbWl0Lm1pbiA9IC1iYXNlTGltaXQubWF4O1xuICAgICAgICAgICAgICAgIGJhc2VMaW1pdC5tYXggPSAtdG1wTWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXNlTGltaXQubWluID0gdHVpLnV0aWwuaXNVbmRlZmluZWQob3B0aW9ucy5taW4pID8gYmFzZUxpbWl0Lm1pbiA6IG9wdGlvbnMubWluO1xuICAgICAgICAgICAgYmFzZUxpbWl0Lm1heCA9IHR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubWF4KSA/IGJhc2VMaW1pdC5tYXggOiBvcHRpb25zLm1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlTGltaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBtaW4uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBvcmlnaW5hbCBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBzY2FsZSBzdGVwXG4gICAgICogQHJldHVybnMge251bWJlcn0gbm9ybWFsaXplZCBtaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVNaW46IGZ1bmN0aW9uKG1pbiwgc3RlcCkge1xuICAgICAgICB2YXIgbW9kID0gdHVpLnV0aWwubW9kKG1pbiwgc3RlcCksXG4gICAgICAgICAgICBub3JtYWxpemVkO1xuXG4gICAgICAgIGlmIChtb2QgPT09IDApIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBtaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdHVpLnV0aWwuc3VidHJhY3Rpb24obWluLCAobWluID49IDAgPyBtb2QgOiBzdGVwICsgbW9kKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBub3JtYWxpemVkIG1heC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBsaW1pdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIHNjYWxlIHN0ZXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVDb3VudCB2YWx1ZSBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG5vcm1hbGl6ZWQgbWF4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU5vcm1hbGl6ZWRNYXg6IGZ1bmN0aW9uKGxpbWl0LCBzdGVwLCB2YWx1ZUNvdW50KSB7XG4gICAgICAgIHZhciBtaW5NYXhEaWZmID0gdHVpLnV0aWwubXVsdGlwbGljYXRpb24oc3RlcCwgdmFsdWVDb3VudCAtIDEpLFxuICAgICAgICAgICAgbm9ybWFsaXplZE1heCA9IHR1aS51dGlsLmFkZGl0aW9uKGxpbWl0Lm1pbiwgbWluTWF4RGlmZiksXG4gICAgICAgICAgICBtYXhEaWZmID0gbGltaXQubWF4IC0gbm9ybWFsaXplZE1heCxcbiAgICAgICAgICAgIG1vZERpZmYsIGRpdmlkZURpZmY7XG4gICAgICAgIC8vIG5vcm1hbGl6ZeuQnCBtYXjqsJLsnbQg7JuQ656Y7J2YIG1heOqwkiDrs7Tri6Qg7J6R7J2EIOqyveyasCBzdGVw7J2EIOymneqwgOyLnOy8nCDtgbAg6rCS7Jy866GcIOunjOuTpOq4sFxuICAgICAgICBpZiAobWF4RGlmZiA+IDApIHtcbiAgICAgICAgICAgIG1vZERpZmYgPSBtYXhEaWZmICUgc3RlcDtcbiAgICAgICAgICAgIGRpdmlkZURpZmYgPSBNYXRoLmZsb29yKG1heERpZmYgLyBzdGVwKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXggKz0gc3RlcCAqIChtb2REaWZmID4gMCA/IGRpdmlkZURpZmYgKyAxIDogZGl2aWRlRGlmZik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZE1heDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGxpbWl0LlxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGxpbWl0IGJhc2UgbGltaXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBzY2FsZSBzdGVwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlQ291bnQgdmFsdWUgY291bnRcbiAgICAgKiBAcmV0dXJucyB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IG5vcm1hbGl6ZWQgbGltaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVMaW1pdDogZnVuY3Rpb24obGltaXQsIHN0ZXAsIHZhbHVlQ291bnQpIHtcbiAgICAgICAgbGltaXQubWluID0gdGhpcy5fbm9ybWFsaXplTWluKGxpbWl0Lm1pbiwgc3RlcCk7XG4gICAgICAgIGxpbWl0Lm1heCA9IHRoaXMuX21ha2VOb3JtYWxpemVkTWF4KGxpbWl0LCBzdGVwLCB2YWx1ZUNvdW50KTtcblxuICAgICAgICByZXR1cm4gbGltaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY3JlYXNlIG1pbmltdW0gdmFsdWUgYnkgc3RlcCB2YWx1ZSxcbiAgICAgKiAgd2hlbiBjaGFydCB0eXBlIGlzIGxpbmUgb3IgZGF0YU1pbiBpcyBtaW51cywgb3B0aW9ucyBpcyB1bmRlZmluZWQsIG1pbmltdW0gdmFsdWVzKG1pbiwgZGF0YU1pbikgYXJlIHNhbWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBiYXNlIG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhTWluIG1pbmltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgc2NhbGUgc3RlcFxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gb3B0aW9uTWluIG1pbiBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBjaGFuZ2VkIG1pblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlY3JlYXNlTWluQnlTdGVwOiBmdW5jdGlvbihtaW4sIGRhdGFNaW4sIHN0ZXAsIG9wdGlvbk1pbikge1xuICAgICAgICB2YXIgaXNMaW5lQ2hhcnQgPSBwcmVkaWNhdGUuaXNMaW5lQ2hhcnQodGhpcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgaXNNaW51c0RhdGFNaW4gPSBkYXRhTWluIDwgMCxcbiAgICAgICAgICAgIGlzVW5kZWZpbmVkTWluT3B0aW9uID0gdHVpLnV0aWwuaXNVbmRlZmluZWQob3B0aW9uTWluKSxcbiAgICAgICAgICAgIGlzU2FtZSA9IChtaW4gPT09IGRhdGFNaW4pO1xuXG4gICAgICAgIGlmICgoaXNMaW5lQ2hhcnQgfHwgaXNNaW51c0RhdGFNaW4pICYmIGlzVW5kZWZpbmVkTWluT3B0aW9uICYmIGlzU2FtZSkge1xuICAgICAgICAgICAgbWluIC09IHN0ZXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmNyZWFzZSBtYXhpbXVtIHZhbHVlIGJ5IHN0ZXAgdmFsdWUsXG4gICAgICogIHdoZW4gY2hhcnQgdHlwZSBpcyBsaW5lIG9yIGRhdGFNaW4gaXMgcGx1cywgb3B0aW9ucyBpcyB1bmRlZmluZWQsIG1heGltdW0gdmFsdWVzKG1heCwgZGF0YU1heCkgYXJlIHNhbWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBiYXNlIG1heFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhTWF4IG1heGltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgc2NhbGUgc3RlcFxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gb3B0aW9uTWF4IG1heCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBjaGFuZ2VkIG1heFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luY3JlYXNlTWF4QnlTdGVwOiBmdW5jdGlvbihtYXgsIGRhdGFNYXgsIHN0ZXAsIG9wdGlvbk1heCkge1xuICAgICAgICB2YXIgaXNMaW5lQ2hhcnQgPSBwcmVkaWNhdGUuaXNMaW5lQ2hhcnQodGhpcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgaXNQbHVzRGF0YU1heCA9IGRhdGFNYXggPiAwLFxuICAgICAgICAgICAgaXNVbmRlZmluZWRNYXhPcHRpb24gPSB0dWkudXRpbC5pc1VuZGVmaW5lZChvcHRpb25NYXgpLFxuICAgICAgICAgICAgaXNTYW1lID0gKG1heCA9PT0gZGF0YU1heCk7XG5cbiAgICAgICAgaWYgKChpc0xpbmVDaGFydCB8fCBpc1BsdXNEYXRhTWF4KSAmJiBpc1VuZGVmaW5lZE1heE9wdGlvbiAmJiBpc1NhbWUpIHtcbiAgICAgICAgICAgIG1heCArPSBzdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlIHNjYWxlIHN0ZXAuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgbGltaXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBzdGVwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNhbmRpZGF0ZVZhbHVlQ291bnQgY2FuZGlkYXRlIHZhbHVlQ291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzY2FsZSBzdGVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGl2aWRlU2NhbGVTdGVwOiBmdW5jdGlvbihsaW1pdCwgc3RlcCwgY2FuZGlkYXRlVmFsdWVDb3VudCkge1xuICAgICAgICB2YXIgaXNFdmVuU3RlcCA9ICgoc3RlcCAlIDIpID09PSAwKSxcbiAgICAgICAgICAgIHZhbHVlQ291bnQgPSBjYWxjdWxhdG9yLm1ha2VMYWJlbHNGcm9tTGltaXQobGltaXQsIHN0ZXApLmxlbmd0aCxcbiAgICAgICAgICAgIHR3aWNlVmFsdWVDb3VudCA9ICh2YWx1ZUNvdW50ICogMikgLSAxLFxuICAgICAgICAgICAgZGlmZk9yZyA9IGFicyhjYW5kaWRhdGVWYWx1ZUNvdW50IC0gdmFsdWVDb3VudCksXG4gICAgICAgICAgICBkaWZmVHdpY2UgPSBhYnMoY2FuZGlkYXRlVmFsdWVDb3VudCAtIHR3aWNlVmFsdWVDb3VudCk7XG5cbiAgICAgICAgLy8gc3RlcOydhCDrsJjsnLzroZwg64KY64iE7JeI7J2EIOuVjOydmCB2YWx1ZUNvdW506rCAIO2bhOuztOuhnCDqs4TsgrDrkJwgY2FuZGlkYXRlVmFsdWVDb3VudOyZgCDsnbjsoJHtlZjrqbQgc3RlcOydhCDrsJjsnLzroZwg64KY64iE7Ja0IOuwmO2ZmO2VqeuLiOuLpC5cbiAgICAgICAgaWYgKGlzRXZlblN0ZXAgJiYgZGlmZlR3aWNlIDw9IGRpZmZPcmcpIHtcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbWl6ZSBzY2FsZSBsaW1pdC5cbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBiYXNlIGxpbWl0XG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gZGF0YUxpbWl0IGxpbWl0IG9mIHVzZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIHNjYWxlIHN0ZXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVDb3VudCB2YWx1ZSBjb3VudFxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6bnVtYmVyfX0gb3B0aW9ucyBsaW1pdCBvcHRpb25zIG9mIGF4aXNcbiAgICAgKiBAcmV0dXJucyB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IG1pbmltaXplZCBsaW1pdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21pbmltaXplU2NhbGVMaW1pdDogZnVuY3Rpb24obGltaXQsIGRhdGFMaW1pdCwgc3RlcCwgdmFsdWVDb3VudCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWluID0gbGltaXQubWF4LFxuICAgICAgICAgICAgbWF4ID0gbGltaXQubWluLFxuICAgICAgICAgICAgY29tcGFyaXNvbk1pbiA9IHR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubWluKSA/IGRhdGFMaW1pdC5taW4gLSAxIDogb3B0aW9ucy5taW4sXG4gICAgICAgICAgICBjb21wYXJpc29uTWF4ID0gdHVpLnV0aWwuaXNVbmRlZmluZWQob3B0aW9ucy5tYXgpID8gZGF0YUxpbWl0Lm1heCArIDEgOiBvcHRpb25zLm1heDtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodHVpLnV0aWwucmFuZ2UoMSwgdmFsdWVDb3VudCksIGZ1bmN0aW9uKHZhbHVlSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2luZ1N0ZXAgPSAoc3RlcCAqIHZhbHVlSW5kZXgpLFxuICAgICAgICAgICAgICAgIGNoYW5nZWRNaW4gPSBtYXggKyBjaGFuZ2luZ1N0ZXAsXG4gICAgICAgICAgICAgICAgY2hhbmdlZE1heCA9IG1pbiAtIGNoYW5naW5nU3RlcDtcblxuICAgICAgICAgICAgLy8gbGltaXTsnbQgZGF0YUxpbWl0IOuylOychOulvCDrhJjslrTqsIgg6rKD7Jy866GcIOyYiOyDgeuQmOuKlCDqsr3smrDsl5Ag67OA6rK97J2EIOykkeuLqO2VqFxuICAgICAgICAgICAgaWYgKGRhdGFMaW1pdC5taW4gPD0gY2hhbmdlZE1pbiAmJiBkYXRhTGltaXQubWF4ID49IGNoYW5nZWRNYXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21wYXJpc29uTWluID49IGNoYW5nZWRNaW4pIHtcbiAgICAgICAgICAgICAgICBsaW1pdC5taW4gPSBjaGFuZ2VkTWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcGFyaXNvbk1heCA8PSBjaGFuZ2VkTWF4KSB7XG4gICAgICAgICAgICAgICAgbGltaXQubWF4ID0gY2hhbmdlZE1heDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBsaW1pdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IGxpbWl0IGZvciBidWJibGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgLSBsaW1pdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIC0gc3RlcDtcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGp1c3RMaW1pdEZvckJ1YmJsZUNoYXJ0OiBmdW5jdGlvbihsaW1pdCwgc3RlcCkge1xuICAgICAgICB2YXIgdmFsdWVUeXBlID0gdGhpcy52YWx1ZVR5cGU7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0U2VyaWVzRGF0YU1vZGVsKHRoaXMuY2hhcnRUeXBlKTtcbiAgICAgICAgdmFyIG1heFJhZGl1c1ZhbHVlID0gc2VyaWVzRGF0YU1vZGVsLmdldE1heFZhbHVlKCdyJyk7XG4gICAgICAgIHZhciBpc0JpZ2dlclJhdGlvVGhhbkhhbGZSYXRpbyA9IGZ1bmN0aW9uKHNlcmllc0l0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiAoc2VyaWVzSXRlbS5yIC8gbWF4UmFkaXVzVmFsdWUpID4gY2hhcnRDb25zdC5IQUxGX1JBVElPO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZm91bmRNaW5JdGVtID0gc2VyaWVzRGF0YU1vZGVsLmZpbmRNaW5TZXJpZXNJdGVtKHZhbHVlVHlwZSwgaXNCaWdnZXJSYXRpb1RoYW5IYWxmUmF0aW8pO1xuICAgICAgICB2YXIgZm91bmRNYXhJdGVtID0gc2VyaWVzRGF0YU1vZGVsLmZpbmRNYXhTZXJpZXNJdGVtKHZhbHVlVHlwZSwgaXNCaWdnZXJSYXRpb1RoYW5IYWxmUmF0aW8pO1xuXG4gICAgICAgIGlmIChmb3VuZE1pbkl0ZW0pIHtcbiAgICAgICAgICAgIGxpbWl0Lm1pbiAtPSBzdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvdW5kTWF4SXRlbSkge1xuICAgICAgICAgICAgbGltaXQubWF4ICs9IHN0ZXA7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjYW5kaWRhdGUgYXhpcyBzY2FsZS5cbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBiYXNlTGltaXQgYmFzZSBsaW1pdFxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGRhdGFMaW1pdCBsaW1pdCBvZiB1c2VyIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVDb3VudCB2YWx1ZSBjb3VudFxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6bnVtYmVyfX0gb3B0aW9ucyBsaW1pdCBvcHRpb25zIG9mIGF4aXNcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgbGltaXQ6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9LFxuICAgICAqICAgICAgc3RlcDogbnVtYmVyXG4gICAgICogfX0gc2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ2FuZGlkYXRlU2NhbGU6IGZ1bmN0aW9uKGJhc2VMaW1pdCwgZGF0YUxpbWl0LCB2YWx1ZUNvdW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsaW1pdCA9IHR1aS51dGlsLmV4dGVuZCh7fSwgYmFzZUxpbWl0KSxcbiAgICAgICAgICAgIHN0ZXA7XG5cbiAgICAgICAgLy8gMDEuIOq4sOuzuCBsaW1pdCDsoJXrs7TroZwgc3RlcCDslrvquLBcbiAgICAgICAgc3RlcCA9IGNhbGN1bGF0b3IuY2FsY3VsYXRlU3RlcEZyb21MaW1pdChsaW1pdCwgdmFsdWVDb3VudCk7XG5cbiAgICAgICAgLy8gMDIuIHN0ZXAg7KCV6rec7ZmUIOyLnO2CpOq4sCAoZXg6IDAuMyAtLT4gMC41LCA3IC0tPiAxMClcbiAgICAgICAgc3RlcCA9IGNhbGN1bGF0b3Iubm9ybWFsaXplQXhpc051bWJlcihzdGVwKTtcblxuICAgICAgICAvLyAwMy4gbGltaXQg7KCV6rec7ZmUIOyLnO2CpOq4sFxuICAgICAgICBsaW1pdCA9IHRoaXMuX25vcm1hbGl6ZUxpbWl0KGxpbWl0LCBzdGVwLCB2YWx1ZUNvdW50KTtcblxuICAgICAgICAvLyAwNC4gbGluZeywqO2KuOydmCDqsr3smrAg7IKs7Jqp7J6Q7J2YIG1pbuqwkuydtCBsaW1pdOydmCBtaW7qsJLqs7wg6rCZ7J2EIOqyveyasCwgbWlu6rCS7J2EIDEgc3RlcCDqsJDshowg7Iuc7YK0XG4gICAgICAgIGxpbWl0Lm1pbiA9IHRoaXMuX2RlY3JlYXNlTWluQnlTdGVwKGxpbWl0Lm1pbiwgZGF0YUxpbWl0Lm1pbiwgc3RlcCwgb3B0aW9ucy5taW4pO1xuXG4gICAgICAgIC8vIDA0LiDsgqzsmqnsnpDsnZggbWF46rCS7J20IHNjYWxlIG1heOyZgCDqsJnsnYQg6rK97JqwLCBtYXjqsJLsnYQgMSBzdGVwIOymneqwgCDsi5ztgrRcbiAgICAgICAgbGltaXQubWF4ID0gdGhpcy5faW5jcmVhc2VNYXhCeVN0ZXAobGltaXQubWF4LCBkYXRhTGltaXQubWF4LCBzdGVwLCBvcHRpb25zLm1heCk7XG5cbiAgICAgICAgLy8gMDUuIGF4aXMgbGltaXTsnbQg7IKs7Jqp7J6QIG1pbiwgbWF47JmAIOqxsOumrOqwgCDrqYAg6rK97JqwIOyhsOygiFxuICAgICAgICBsaW1pdCA9IHRoaXMuX21pbmltaXplU2NhbGVMaW1pdChsaW1pdCwgZGF0YUxpbWl0LCBzdGVwLCB2YWx1ZUNvdW50LCBvcHRpb25zKTtcblxuICAgICAgICAvLyAwNi4g7KGw6rG07JeQIOuUsOudvCBzdGVw6rCS7J2EIOuwmOycvOuhnCDrgpjriJRcbiAgICAgICAgc3RlcCA9IHRoaXMuX2RpdmlkZVNjYWxlU3RlcChsaW1pdCwgc3RlcCwgdmFsdWVDb3VudCk7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0J1YmJsZUNoYXJ0KHRoaXMuY2hhcnRUeXBlKSkge1xuICAgICAgICAgICAgdGhpcy5fYWRqdXN0TGltaXRGb3JCdWJibGVDaGFydChsaW1pdCwgc3RlcCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICAgIHZhbHVlQ291bnQ6IGFicyhsaW1pdC5tYXggLSBsaW1pdC5taW4pIC8gc3RlcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNhbmRpZGF0ZXMgYWJvdXQgYXhpcyBzY2FsZS5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGxpbWl0OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSxcbiAgICAgKiAgICAgIG9wdGlvbnM6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9LFxuICAgICAqICAgICAgZGl2aWRlTnVtOiBudW1iZXJcbiAgICAgKiB9fSBpbnRlZ2VyVHlwZVNjYWxlIC0gaW50ZWdlciB0eXBlIGF4aXMgc2NhbGVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZUNvdW50cyAtIGNhbmRpZGF0ZSBjb3VudHMgb2YgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHtsaW1pdDp7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgc3RwZTogbnVtYmVyfT59IC0gY2FuZGlkYXRlcyBzY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDYW5kaWRhdGVTY2FsZXM6IGZ1bmN0aW9uKGludGVnZXJUeXBlU2NhbGUsIHZhbHVlQ291bnRzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGFMaW1pdCA9IGludGVnZXJUeXBlU2NhbGUubGltaXQsXG4gICAgICAgICAgICBvcHRpb25zID0gaW50ZWdlclR5cGVTY2FsZS5vcHRpb25zLFxuICAgICAgICAgICAgYmFzZUxpbWl0ID0gdGhpcy5fbWFrZUJhc2VMaW1pdChkYXRhTGltaXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVDb3VudHMsIGZ1bmN0aW9uKHZhbHVlQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9tYWtlQ2FuZGlkYXRlU2NhbGUoYmFzZUxpbWl0LCBkYXRhTGltaXQsIHZhbHVlQ291bnQsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbXBhcmluZyB2YWx1ZSBmb3Igc2VsZWN0aW5nIGF4aXMgc2NhbGUuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gYmFzZUxpbWl0IC0gbGltaXRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZUNvdW50cyAtIGNhbmRpZGF0ZSBjb3VudHMgb2YgdmFsdWVcbiAgICAgKiBAcGFyYW0ge3tsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHN0ZXA6IG51bWJlcn19IGNhbmRpZGF0ZVNjYWxlIC0gc2NhbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGNvbXBhcmluZyB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENvbXBhcmluZ1ZhbHVlOiBmdW5jdGlvbihiYXNlTGltaXQsIHZhbHVlQ291bnRzLCBjYW5kaWRhdGVTY2FsZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGRpZmZNYXggPSBhYnMoY2FuZGlkYXRlU2NhbGUubGltaXQubWF4IC0gYmFzZUxpbWl0Lm1heCk7XG4gICAgICAgIHZhciBkaWZmTWluID0gYWJzKGJhc2VMaW1pdC5taW4gLSBjYW5kaWRhdGVTY2FsZS5saW1pdC5taW4pO1xuICAgICAgICAvLyDsmIjsg4EgbGFiZWwgY291bnTsmYAg7LCo7J206rCAIOunjuydhCDsiJjroZ0g7ZuE67O0IOygnOyZuCDqsIDriqXshLHsnbQg64aS7J2MXG4gICAgICAgIHZhciBkaWZmQ291bnQgPSBNYXRoLm1heChhYnModmFsdWVDb3VudHNbaW5kZXhdIC0gY2FuZGlkYXRlU2NhbGUudmFsdWVDb3VudCksIDEpO1xuICAgICAgICAvLyDshozsiJjsoJAg7J207ZWYIOq4uOydtOqwgCDquLgg7IiY66GdIO2bhOuztOyXkOyEnCDsoJzsmbjrkKAg6rCA64ql7ISx7J20IOuGkuydjFxuICAgICAgICB2YXIgd2VpZ2h0ID0gTWF0aC5wb3coMTAsIHR1aS51dGlsLmdldERlY2ltYWxMZW5ndGgoY2FuZGlkYXRlU2NhbGUuc3RlcCkpO1xuXG4gICAgICAgIHJldHVybiAoZGlmZk1heCArIGRpZmZNaW4pICogZGlmZkNvdW50ICogd2VpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYXhpcyBzY2FsZS5cbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBiYXNlTGltaXQgbGltaXRcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bGltaXQ6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9LCBzdGVwOiBudW1iZXJ9Pn0gY2FuZGlkYXRlcyBzY2FsZSBjYW5kaWRhdGVzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVDb3VudHMgLSBsYWJlbCBjb3VudHNcbiAgICAgKiBAcmV0dXJucyB7e2xpbWl0OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgc3RlcDogbnVtYmVyfX0gc2VsZWN0ZWQgc2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZWxlY3RBeGlzU2NhbGU6IGZ1bmN0aW9uKGJhc2VMaW1pdCwgY2FuZGlkYXRlcywgdmFsdWVDb3VudHMpIHtcbiAgICAgICAgdmFyIGdldENvbXBhcmluZ1ZhbHVlID0gdHVpLnV0aWwuYmluZCh0aGlzLl9nZXRDb21wYXJpbmdWYWx1ZSwgdGhpcywgYmFzZUxpbWl0LCB2YWx1ZUNvdW50cyk7XG4gICAgICAgIHZhciBheGlzU2NhbGUgPSB0dWkudXRpbC5taW4oY2FuZGlkYXRlcywgZ2V0Q29tcGFyaW5nVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBheGlzU2NhbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgbnVtYmVyIHN0YXRlIG9mIHNjYWxlLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7e2xpbWl0OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgc3RlcDogbnVtYmVyfX0gc2NhbGUgc2NhbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aWRlTnVtIGRpdmlkZSBudW1cbiAgICAgKiBAcmV0dXJucyB7e2xpbWl0OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgc3RlcDogbnVtYmVyfX0gcmVzdG9yZWQgc2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXN0b3JlTnVtYmVyU3RhdGU6IGZ1bmN0aW9uKHNjYWxlLCBkaXZpZGVOdW0pIHtcbiAgICAgICAgaWYgKGRpdmlkZU51bSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NhbGUuc3RlcCA9IHR1aS51dGlsLmRpdmlzaW9uKHNjYWxlLnN0ZXAsIGRpdmlkZU51bSk7XG4gICAgICAgIHNjYWxlLmxpbWl0Lm1pbiA9IHR1aS51dGlsLmRpdmlzaW9uKHNjYWxlLmxpbWl0Lm1pbiwgZGl2aWRlTnVtKTtcbiAgICAgICAgc2NhbGUubGltaXQubWF4ID0gdHVpLnV0aWwuZGl2aXNpb24oc2NhbGUubGltaXQubWF4LCBkaXZpZGVOdW0pO1xuXG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHNjYWxlLlxuICAgICAqIEByZXR1cm5zIHt7bGltaXQ6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9LCBzdGVwOiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJhc2VWYWx1ZXMgPSB0aGlzLl9tYWtlQmFzZVZhbHVlcygpO1xuICAgICAgICB2YXIgZGF0YUxpbWl0ID0ge1xuICAgICAgICAgICAgbWluOiB0dWkudXRpbC5taW4oYmFzZVZhbHVlcyksXG4gICAgICAgICAgICBtYXg6IHR1aS51dGlsLm1heChiYXNlVmFsdWVzKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaW50ZWdlclR5cGVTY2FsZSwgdmFsdWVDb3VudHMsIGNhbmRpZGF0ZXMsIHNjYWxlO1xuXG4gICAgICAgIGlmIChkYXRhTGltaXQubWluID09PSAwICYmIGRhdGFMaW1pdC5tYXggPT09IDApIHtcbiAgICAgICAgICAgIGRhdGFMaW1pdC5tYXggPSA1O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzRGl2ZXJnaW5nQ2hhcnQoKSkge1xuICAgICAgICAgICAgZGF0YUxpbWl0ID0gdGhpcy5fbWFrZUxpbWl0Rm9yRGl2ZXJnaW5nT3B0aW9uKGRhdGFMaW1pdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAwMS4gbGltaXQsIG9wdGlvbnMg7KCV67O066W8IOygleyImO2YleycvOuhnCDrs4Dqsr1cbiAgICAgICAgaW50ZWdlclR5cGVTY2FsZSA9IHRoaXMuX21ha2VJbnRlZ2VyVHlwZVNjYWxlKGRhdGFMaW1pdCk7XG5cbiAgICAgICAgLy8gMDIuIHZhbHVlIGNvdW50IO2bhOuztOq1sCDslrvquLBcbiAgICAgICAgdmFsdWVDb3VudHMgPSB0aGlzLnZhbHVlQ291bnRzIHx8IHRoaXMuX2dldENhbmRpZGF0ZUNvdW50c09mVmFsdWUoKTtcblxuICAgICAgICAvLyAwMy4gYXhpcyBzY2FsZSDtm4Trs7TqtbAg7Ja76riwXG4gICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLl9tYWtlQ2FuZGlkYXRlU2NhbGVzKGludGVnZXJUeXBlU2NhbGUsIHZhbHVlQ291bnRzKTtcblxuICAgICAgICAvLyAwNC4gYXhpcyBzY2FsZSDtm4Trs7TqtbAg7KSRIO2VmOuCmCDshKDtg51cbiAgICAgICAgc2NhbGUgPSB0aGlzLl9zZWxlY3RBeGlzU2NhbGUoaW50ZWdlclR5cGVTY2FsZS5saW1pdCwgY2FuZGlkYXRlcywgdmFsdWVDb3VudHMpO1xuXG4gICAgICAgIC8vIDA1LiDsoJXsiJjtmJXsnLzroZwg67OA6rK97ZaI642YIHNjYWxl66W8IOybkOuemCDtmJXtg5zroZwg67OA6rK9XG4gICAgICAgIHNjYWxlID0gdGhpcy5fcmVzdG9yZU51bWJlclN0YXRlKHNjYWxlLCBpbnRlZ2VyVHlwZVNjYWxlLmRpdmlkZU51bSk7XG5cbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWVzIGZvciBzdW0uXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFZhbHVlc0ZvclN1bTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXM7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTaW5nbGVZQXhpcykge1xuICAgICAgICAgICAgdmFsdWVzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFZhbHVlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFZhbHVlcyh0aGlzLmNoYXJ0VHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbWludXMgc3VtIGFib3V0IGdyb3VwIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZU1pbnVzU3VtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuX2dldFZhbHVlc0ZvclN1bSgpO1xuXG4gICAgICAgIHJldHVybiBjYWxjdWxhdG9yLnN1bU1pbnVzVmFsdWVzKHZhbHVlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBwbHVzIHN1bSBhYm91dCBncm91cCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVQbHVzU3VtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuX2dldFZhbHVlc0ZvclN1bSgpO1xuXG4gICAgICAgIHJldHVybiBjYWxjdWxhdG9yLnN1bVBsdXNWYWx1ZXModmFsdWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHBlcmNlbnQgc3RhY2tUeXBlIHNjYWxlLlxuICAgICAqIEByZXR1cm5zIHt7bGltaXQ6IHttaW46bnVtYmVyLCBtYXg6bnVtYmVyfSwgc3RlcDogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRQZXJjZW50U3RhY2tlZFNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNjYWxlO1xuXG4gICAgICAgIGlmICh0aGlzLl9jYWxjdWxhdGVNaW51c1N1bSgpID09PSAwKSB7XG4gICAgICAgICAgICBzY2FsZSA9IGNoYXJ0Q29uc3QuUEVSQ0VOVF9TVEFDS0VEX0FYSVNfU0NBTEU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY2FsY3VsYXRlUGx1c1N1bSgpID09PSAwKSB7XG4gICAgICAgICAgICBzY2FsZSA9IGNoYXJ0Q29uc3QuTUlOVVNfUEVSQ0VOVF9TVEFDS0VEX0FYSVNfU0NBTEU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNEaXZlcmdpbmdDaGFydCgpKSB7XG4gICAgICAgICAgICBzY2FsZSA9IGNoYXJ0Q29uc3QuRElWRVJHSU5HX1BFUkNFTlRfU1RBQ0tFRF9BWElTX1NDQUxFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NhbGUgPSBjaGFydENvbnN0LkRVQUxfUEVSQ0VOVF9TVEFDS0VEX0FYSVNfU0NBTEU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2NhbGUuXG4gICAgICogQHJldHVybnMge3tsaW1pdDoge21pbjpudW1iZXIsIG1heDpudW1iZXJ9LCBzdGVwOiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzY2FsZTtcblxuICAgICAgICBpZiAodGhpcy5faXNQZXJjZW50U3RhY2tDaGFydCgpKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHRoaXMuX2dldFBlcmNlbnRTdGFja2VkU2NhbGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjYWxlID0gdGhpcy5fY2FsY3VsYXRlU2NhbGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlzU2NhbGVNYWtlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBCb3VuZHMgbWFrZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIGNhbGN1bGF0b3IgPSByZXF1aXJlKCcuL2NhbGN1bGF0b3InKTtcbnZhciBwcmVkaWNhdGUgPSByZXF1aXJlKCcuL3ByZWRpY2F0ZScpO1xudmFyIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuL3JlbmRlclV0aWwnKTtcblxuLyoqXG4gKiBEaW1lbnNpb24uXG4gKiBAdHlwZWRlZiB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDpudW1iZXJ9fSBkaW1lbnNpb25cbiAqL1xuXG4vKipcbiAqIFBvc2l0aW9uLlxuICogQHR5cGVkZWYge3tsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXJ9fSBwb3NpdGlvblxuICovXG5cbi8qKlxuICogQm91bmQuXG4gKiBAdHlwZWRlZiB7e2RpbWVuc2lvbjogZGltZW5zaW9uLCBwb3NpdGlvbjpwb3NpdGlvbn19IGJvdW5kXG4gKi9cblxudmFyIEJvdW5kc01ha2VyID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBCb3VuZHNNYWtlci5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogQm91bmRzIG1ha2VyLlxuICAgICAqIEBjb25zdHJ1Y3RzIEJvdW5kc01ha2VyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlZ2VuZCA9IHRoaXMub3B0aW9ucy5sZWdlbmQgfHwge307XG4gICAgICAgIHRoaXMub3B0aW9ucy55QXhpcyA9IHRoaXMub3B0aW9ucy55QXhpcyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdGhlbWVcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGhlbWUgPSBwYXJhbXMudGhlbWUgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgY2hhcnQgaGFzIGF4ZXMgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNBeGVzID0gcGFyYW1zLmhhc0F4ZXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gcGFyYW1zLmNoYXJ0VHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhcnQgdHlwZXMgZm9yIGNvbWJvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGVzID0gcGFyYW1zLmNoYXJ0VHlwZXMgfHwgW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcHJvY2Vzc29yXG4gICAgICAgICAqIEB0eXBlIHtEYXRhUHJvY2Vzc29yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gcGFyYW1zLmRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgdGhpcy5pbml0Qm91bmRzRGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGJvdW5kcyBkYXRhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGFydE9wdGlvbiBjaGFydCBvcHRpb25cbiAgICAgKi9cbiAgICBpbml0Qm91bmRzRGF0YTogZnVuY3Rpb24oY2hhcnRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5QXhpczoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmlnaHRZQXhpczoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeEF4aXM6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaXJjbGVMZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGN1bGF0aW9uTGVnZW5kOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHt9O1xuXG4gICAgICAgIHRoaXMuYXhlc0RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLnhBeGlzRGVncmVlID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhcnQgbGVmdCBwYWRkaW5nXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0TGVmdFBhZGRpbmcgPSBjaGFydENvbnN0LkNIQVJUX1BBRERJTkc7XG5cbiAgICAgICAgaWYgKGNoYXJ0T3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2hhcnQgPSBjaGFydE9wdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQ2hhcnREaW1lbnNpb24oKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJUaXRsZURpbWVuc2lvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY29tcG9uZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge2RpbWVuc2lvbn0gZGltZW5zaW9uIGNvbXBvbmVudCBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlckRpbWVuc2lvbjogZnVuY3Rpb24obmFtZSwgZGltZW5zaW9uKSB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uc1tuYW1lXSA9IHR1aS51dGlsLmV4dGVuZCh0aGlzLmRpbWVuc2lvbnNbbmFtZV0gfHwge30sIGRpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGJhc2UgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtkaW1lbnNpb259IGRpbWVuc2lvbiBjb21wb25lbnQgZGltZW5zaW9uXG4gICAgICovXG4gICAgcmVnaXN0ZXJCYXNlRGltZW5zaW9uOiBmdW5jdGlvbihuYW1lLCBkaW1lbnNpb24pIHtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEaW1lbnNpb24obmFtZSwgZGltZW5zaW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYXhlcyBkYXRhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBheGVzRGF0YSBheGVzIGRhdGFcbiAgICAgKi9cbiAgICByZWdpc3RlckF4ZXNEYXRhOiBmdW5jdGlvbihheGVzRGF0YSkge1xuICAgICAgICB0aGlzLmF4ZXNEYXRhID0gYXhlc0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF4ZXMgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7e3hBeGlzOiBvYmplY3QsIHlBeGlzOiBvYmplY3QsIHJpZ2h0WUF4aXM6IG9iamVjdH19XG4gICAgICovXG4gICAgZ2V0QXhlc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5heGVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHN0ZXAgb2YgcGl4ZWwgdW5pdC5cbiAgICAgKiBAcGFyYW0ge3t0aWNrQ291bnQ6IG51bWJlciwgaXNMYWJlbDogYm9vbGVhbn19IGF4aXNEYXRhIC0gZGF0YSBmb3IgcmVuZGVyaW5nIGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIHdpZHRoIG9yIGhlaWdodCBvZiBzZXJpc2UgYXJlYVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlUGl4ZWxTdGVwOiBmdW5jdGlvbihheGlzRGF0YSwgc2l6ZSkge1xuICAgICAgICB2YXIgdGlja0NvdW50ID0gYXhpc0RhdGEudGlja0NvdW50O1xuICAgICAgICB2YXIgcGl4ZWxTdGVwO1xuXG4gICAgICAgIGlmIChheGlzRGF0YS5pc0xhYmVsKSB7XG4gICAgICAgICAgICBwaXhlbFN0ZXAgPSBzaXplIC8gdGlja0NvdW50IC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpeGVsU3RlcCA9IHNpemUgLyAodGlja0NvdW50IC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VJbnQocGl4ZWxTdGVwLCAxMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBtaW5pbXVtIHN0ZXAgb2YgcGl4ZWwgdW5pdCBmb3IgYXhpcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldE1pbmltdW1QaXhlbFN0ZXBGb3JBeGlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKTtcbiAgICAgICAgdmFyIHlQaXhlbFN0ZXAgPSB0aGlzLl9jYWxjdWxhdGVQaXhlbFN0ZXAodGhpcy5heGVzRGF0YS55QXhpcywgZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIHZhciB4UGl4ZWxTdGVwID0gdGhpcy5fY2FsY3VsYXRlUGl4ZWxTdGVwKHRoaXMuYXhlc0RhdGEueEF4aXMsIGRpbWVuc2lvbi53aWR0aCk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHlQaXhlbFN0ZXAsIHhQaXhlbFN0ZXApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWF4IHJhZGl1cyBmb3IgYnViYmxlIGNoYXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0TWF4UmFkaXVzRm9yQnViYmxlQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWF4UmFkaXVzID0gdGhpcy5nZXRNaW5pbXVtUGl4ZWxTdGVwRm9yQXhpcygpO1xuICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSB0aGlzLmdldERpbWVuc2lvbignY2FsY3VsYXRpb25MZWdlbmQnKS53aWR0aCB8fCBjaGFydENvbnN0Lk1JTl9MRUdFTkRfV0lEVEg7XG4gICAgICAgIHZhciBjaXJjbGVMZWdlbmRXaWR0aCA9IHRoaXMuZ2V0RGltZW5zaW9uKCdjaXJjbGVMZWdlbmQnKS53aWR0aCB8fCBsZWdlbmRXaWR0aDtcblxuICAgICAgICByZXR1cm4gTWF0aC5taW4oKGNpcmNsZUxlZ2VuZFdpZHRoIC0gY2hhcnRDb25zdC5DSVJDTEVfTEVHRU5EX1BBRERJTkcpIC8gMiwgbWF4UmFkaXVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvdW5kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHJldHVybnMge2JvdW5kfSBjb21wb25lbnQgYm91bmRcbiAgICAgKi9cbiAgICBnZXRCb3VuZDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGltZW5zaW9uOiB0aGlzLmRpbWVuc2lvbnNbbmFtZV0gfHwge30sXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbnNbbmFtZV0gfHwge31cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGJvdW5kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtib3VuZH0gYm91bmQgY29tcG9uZW50IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0Qm91bmQ6IGZ1bmN0aW9uKG5hbWUsIGJvdW5kKSB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uc1tuYW1lXSA9IGJvdW5kLmRpbWVuc2lvbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnNbbmFtZV0gPSBib3VuZC5wb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb21wb25lbnQgbmFtZVxuICAgICAqIEByZXR1cm5zIHtkaW1lbnNpb259IGNvbXBvbmVudCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBnZXREaW1lbnNpb246IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uc1tuYW1lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHJldHVybnMge3Bvc2l0aW9ufSBjb21wb25lbnQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnNbbmFtZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ2lzdGVyQ2hhcnREaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhcnRPcHRpb25zID0gdGhpcy5vcHRpb25zLmNoYXJ0IHx8IHt9LFxuICAgICAgICAgICAgZGltZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBjaGFydE9wdGlvbnMud2lkdGggfHwgY2hhcnRDb25zdC5DSEFSVF9ERUZBVUxUX1dJRFRILFxuICAgICAgICAgICAgICAgIGhlaWdodDogY2hhcnRPcHRpb25zLmhlaWdodCB8fCBjaGFydENvbnN0LkNIQVJUX0RFRkFVTFRfSEVJR0hUXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKCdjaGFydCcsIGRpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHRpdGxlIGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ2lzdGVyVGl0bGVEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhcnRPcHRpb25zID0gdGhpcy5vcHRpb25zLmNoYXJ0IHx8IHt9LFxuICAgICAgICAgICAgdGl0bGVIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQoY2hhcnRPcHRpb25zLnRpdGxlLCB0aGlzLnRoZW1lLnRpdGxlKSxcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRpdGxlSGVpZ2h0ICsgY2hhcnRDb25zdC5USVRMRV9QQURESU5HXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKCd0aXRsZScsIGRpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBsaW1pdCB3aWR0aCBvZiB4IGF4aXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsQ291bnQgLSBsYWJlbCBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGxpbWl0IHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlWEF4aXNMYWJlbExpbWl0V2lkdGg6IGZ1bmN0aW9uKGxhYmVsQ291bnQpIHtcbiAgICAgICAgdmFyIHNlcmllc1dpZHRoID0gdGhpcy5nZXREaW1lbnNpb24oJ3NlcmllcycpLndpZHRoO1xuICAgICAgICB2YXIgaXNBbGlnbiA9IHByZWRpY2F0ZS5pc0xpbmVUeXBlQ2hhcnQodGhpcy5jaGFydFR5cGUpO1xuICAgICAgICB2YXIgeEF4aXNPcHRpb25zID0gdGhpcy5vcHRpb25zLnhBeGlzIHx8IHt9O1xuXG4gICAgICAgIGxhYmVsQ291bnQgPSBsYWJlbENvdW50IHx8IHRoaXMuYXhlc0RhdGEueEF4aXMubGFiZWxzLmxlbmd0aDtcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzVmFsaWRMYWJlbEludGVydmFsKHhBeGlzT3B0aW9ucy5sYWJlbEludGVydmFsLCB4QXhpc09wdGlvbnMudGlja0ludGVydmFsKSkge1xuICAgICAgICAgICAgc2VyaWVzV2lkdGggKj0geEF4aXNPcHRpb25zLmxhYmVsSW50ZXJ2YWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzV2lkdGggLyAoaXNBbGlnbiA/IGxhYmVsQ291bnQgLSAxIDogbGFiZWxDb3VudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgcm90YXRpb24gZGVncmVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFdpZHRoIGxpbWl0IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsV2lkdGggbGFiZWwgd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogQHJldHVybnMge251bWJlcn0gcm90YXRpb24gZGVncmVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZFJvdGF0aW9uRGVncmVlOiBmdW5jdGlvbihsaW1pdFdpZHRoLCBsYWJlbFdpZHRoLCBsYWJlbEhlaWdodCkge1xuICAgICAgICB2YXIgZm91bmREZWdyZWUsXG4gICAgICAgICAgICBoYWxmV2lkdGggPSBsYWJlbFdpZHRoIC8gMixcbiAgICAgICAgICAgIGhhbGZIZWlnaHQgPSBsYWJlbEhlaWdodCAvIDI7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0Q29uc3QuREVHUkVFX0NBTkRJREFURVMsIGZ1bmN0aW9uKGRlZ3JlZSkge1xuICAgICAgICAgICAgdmFyIGNvbXBhcmVXaWR0aCA9IChjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KGRlZ3JlZSwgaGFsZldpZHRoKSArXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudChjaGFydENvbnN0LkFOR0xFXzkwIC0gZGVncmVlLCBoYWxmSGVpZ2h0KSkgKiAyO1xuXG4gICAgICAgICAgICBmb3VuZERlZ3JlZSA9IGRlZ3JlZTtcbiAgICAgICAgICAgIGlmIChjb21wYXJlV2lkdGggPD0gbGltaXRXaWR0aCArIGNoYXJ0Q29uc3QuWEFYSVNfTEFCRUxfQ09NUEFSRV9NQVJHSU4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm91bmREZWdyZWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugcm90YXRpb24gaW5mbyBhYm91dCBob3Jpem9udGFsIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFdpZHRoIGxpbWl0IHdpZHRoXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGFiZWxzIGF4aXMgbGFiZWxzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGF4aXMgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7P29iamVjdH0gcm90YXRpb24gaW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VIb3Jpem9udGFsTGFiZWxSb3RhdGlvbkluZm86IGZ1bmN0aW9uKGxpbWl0V2lkdGgpIHtcbiAgICAgICAgdmFyIGxhYmVscyA9IHRoaXMuYXhlc0RhdGEueEF4aXMubGFiZWxzLFxuICAgICAgICAgICAgdGhlbWUgPSB0aGlzLnRoZW1lLnhBeGlzLmxhYmVsLFxuICAgICAgICAgICAgbWF4TGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhXaWR0aChsYWJlbHMsIHRoZW1lKSxcbiAgICAgICAgICAgIGRlZ3JlZSwgbGFiZWxIZWlnaHQ7XG5cbiAgICAgICAgaWYgKG1heExhYmVsV2lkdGggPD0gbGltaXRXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhIZWlnaHQobGFiZWxzLCB0aGVtZSk7XG4gICAgICAgIGRlZ3JlZSA9IHRoaXMuX2ZpbmRSb3RhdGlvbkRlZ3JlZShsaW1pdFdpZHRoLCBtYXhMYWJlbFdpZHRoLCBsYWJlbEhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1heExhYmVsV2lkdGg6IG1heExhYmVsV2lkdGgsXG4gICAgICAgICAgICBsYWJlbEhlaWdodDogbGFiZWxIZWlnaHQsXG4gICAgICAgICAgICBkZWdyZWU6IGRlZ3JlZVxuICAgICAgICB9O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBvdmVyZmxvdyBwb3NpdGlvbiBsZWZ0LlxuICAgICAqIEBwYXJhbSB7e2RlZ3JlZTogbnVtYmVyLCBsYWJlbEhlaWdodDogbnVtYmVyfX0gcm90YXRpb25JbmZvIHJvdGF0aW9uIGluZm9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlyc3RMYWJlbCBmaXJzdExhYmVsXG4gICAgICogQHJldHVybnMge251bWJlcn0gb3ZlcmZsb3cgcG9zaXRpb24gbGVmdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZU92ZXJmbG93TGVmdDogZnVuY3Rpb24ocm90YXRpb25JbmZvLCBmaXJzdExhYmVsKSB7XG4gICAgICAgIHZhciBkZWdyZWUgPSByb3RhdGlvbkluZm8uZGVncmVlO1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSByb3RhdGlvbkluZm8ubGFiZWxIZWlnaHQ7XG4gICAgICAgIHZhciBmaXJzdExhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChmaXJzdExhYmVsLCB0aGlzLnRoZW1lLnhBeGlzLmxhYmVsKTtcbiAgICAgICAgdmFyIG5ld0xhYmVsV2lkdGggPSAoY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudChkZWdyZWUsIGZpcnN0TGFiZWxXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgKyBjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KGNoYXJ0Q29uc3QuQU5HTEVfOTAgLSBkZWdyZWUsIGxhYmVsSGVpZ2h0IC8gMikpICogMjtcbiAgICAgICAgdmFyIHlBeGlzV2lkdGggPSB0aGlzLm9wdGlvbnMueUF4aXMuaXNDZW50ZXIgPyAwIDogdGhpcy5nZXREaW1lbnNpb24oJ3lBeGlzJykud2lkdGg7XG4gICAgICAgIHZhciBkaWZmTGVmdCA9IG5ld0xhYmVsV2lkdGggLSB5QXhpc1dpZHRoO1xuXG4gICAgICAgIHJldHVybiBkaWZmTGVmdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHdpZHRoIG9mIGRpbWVuc2lvbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG92ZXJmbG93TGVmdCBvdmVyZmxvdyBsZWZ0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlRGltZW5zaW9uc1dpZHRoOiBmdW5jdGlvbihvdmVyZmxvd0xlZnQpIHtcbiAgICAgICAgaWYgKG92ZXJmbG93TGVmdCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnRMZWZ0UGFkZGluZyArPSBvdmVyZmxvd0xlZnQ7XG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnMucGxvdC53aWR0aCAtPSBvdmVyZmxvd0xlZnQ7XG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnMuc2VyaWVzLndpZHRoIC09IG92ZXJmbG93TGVmdDtcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucy5jdXN0b21FdmVudC53aWR0aCAtPSBvdmVyZmxvd0xlZnQ7XG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnMueEF4aXMud2lkdGggLT0gb3ZlcmZsb3dMZWZ0O1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnMuc2VyaWVzLmxlZnQgKz0gb3ZlcmZsb3dMZWZ0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBkZWdyZWUgb2Ygcm90YXRpb25JbmZvLlxuICAgICAqIEBwYXJhbSB7e2RlZ3JlZTogbnVtYmVyLCBtYXhMYWJlbFdpZHRoOiBudW1iZXIsIGxhYmVsSGVpZ2h0OiBudW1iZXJ9fSByb3RhdGlvbkluZm8gLSByb3RhdGlvbiBpbmZvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsQ291bnQgLSBsYWJlbCBjb3VudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvdmVyZmxvd0xlZnQgLSBvdmVyZmxvdyBsZWZ0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlRGVncmVlOiBmdW5jdGlvbihyb3RhdGlvbkluZm8sIGxhYmVsQ291bnQsIG92ZXJmbG93TGVmdCkge1xuICAgICAgICB2YXIgbGltaXRXaWR0aCwgbmV3RGVncmVlO1xuICAgICAgICBpZiAob3ZlcmZsb3dMZWZ0ID4gMCkge1xuICAgICAgICAgICAgbGltaXRXaWR0aCA9IHRoaXMuX2NhbGN1bGF0ZVhBeGlzTGFiZWxMaW1pdFdpZHRoKGxhYmVsQ291bnQpICsgY2hhcnRDb25zdC5YQVhJU19MQUJFTF9HVVRURVI7XG4gICAgICAgICAgICBuZXdEZWdyZWUgPSB0aGlzLl9maW5kUm90YXRpb25EZWdyZWUobGltaXRXaWR0aCwgcm90YXRpb25JbmZvLm1heExhYmVsV2lkdGgsIHJvdGF0aW9uSW5mby5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgICByb3RhdGlvbkluZm8uZGVncmVlID0gbmV3RGVncmVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSByb3RhdGVkIGhlaWdodCBvZiB4QXhpcy5cbiAgICAgKiBAcGFyYW0ge3tkZWdyZWU6IG51bWJlciwgbWF4TGFiZWxXaWR0aDogbnVtYmVyLCBsYWJlbEhlaWdodDogbnVtYmVyfX0gcm90YXRpb25JbmZvIHJvdGF0aW9uIGluZm9cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB4QXhpcyBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVYQXhpc1JvdGF0ZWRIZWlnaHQ6IGZ1bmN0aW9uKHJvdGF0aW9uSW5mbykge1xuICAgICAgICB2YXIgZGVncmVlID0gcm90YXRpb25JbmZvLmRlZ3JlZTtcbiAgICAgICAgdmFyIG1heExhYmVsV2lkdGggPSByb3RhdGlvbkluZm8ubWF4TGFiZWxXaWR0aDtcbiAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gcm90YXRpb25JbmZvLmxhYmVsSGVpZ2h0O1xuICAgICAgICB2YXIgYXhpc0hlaWdodCA9IChjYWxjdWxhdG9yLmNhbGN1bGF0ZU9wcG9zaXRlKGRlZ3JlZSwgbWF4TGFiZWxXaWR0aCAvIDIpICtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdG9yLmNhbGN1bGF0ZU9wcG9zaXRlKGNoYXJ0Q29uc3QuQU5HTEVfOTAgLSBkZWdyZWUsIGxhYmVsSGVpZ2h0IC8gMikpICogMjtcblxuICAgICAgICByZXR1cm4gYXhpc0hlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGhlaWdodCBkaWZmZXJlbmNlIGJldHdlZW4gb3JpZ2luIGNhdGVnb3J5IGFuZCByb3RhdGlvbiBjYXRlZ29yeS5cbiAgICAgKiBAcGFyYW0ge3tkZWdyZWU6IG51bWJlciwgbWF4TGFiZWxXaWR0aDogbnVtYmVyLCBsYWJlbEhlaWdodDogbnVtYmVyfX0gcm90YXRpb25JbmZvIHJvdGF0aW9uIGluZm9cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHQgZGlmZmVyZW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZURpZmZXaXRoUm90YXRlZEhlaWdodDogZnVuY3Rpb24ocm90YXRpb25JbmZvKSB7XG4gICAgICAgIHZhciByb3RhdGVkSGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlWEF4aXNSb3RhdGVkSGVpZ2h0KHJvdGF0aW9uSW5mbyk7XG5cbiAgICAgICAgcmV0dXJuIHJvdGF0ZWRIZWlnaHQgLSByb3RhdGlvbkluZm8ubGFiZWxIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBoZWlnaHQgZGlmZmVyZW5jZSBiZXR3ZWVuIG9yaWdpbiBjYXRlZ29yeSBhbmQgbXVsdGlsaW5lIGNhdGVnb3J5LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVscyBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXRXaWR0aCBsaW1pdCB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGNhbGN1bGF0ZWQgaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlRGlmZldpdGhNdWx0aWxpbmVIZWlnaHQ6IGZ1bmN0aW9uKGxhYmVscywgbGltaXRXaWR0aCkge1xuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnRoZW1lLnhBeGlzLmxhYmVsLFxuICAgICAgICAgICAgbXVsdGlsaW5lTGFiZWxzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldE11bHRpbGluZUNhdGVnb3JpZXMobGltaXRXaWR0aCwgdGhlbWUsIHRoaXMuYXhlc0RhdGEueEF4aXMubGFiZWxzKSxcbiAgICAgICAgICAgIG5vcm1hbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhIZWlnaHQobGFiZWxzLCB0aGVtZSksXG4gICAgICAgICAgICBtdWx0aWxpbmVIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxzTWF4SGVpZ2h0KG11bHRpbGluZUxhYmVscywgdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBjc3NUZXh0OiAnbGluZS1oZWlnaHQ6MS4yO3dpZHRoOicgKyBsaW1pdFdpZHRoICsgJ3B4J1xuICAgICAgICAgICAgfSwgdGhlbWUpKTtcblxuICAgICAgICByZXR1cm4gbXVsdGlsaW5lSGVpZ2h0IC0gbm9ybWFsSGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgaGVpZ2h0IG9mIGRpbWVuc2lvbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpZmZIZWlnaHQgZGlmZiBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVEaW1lbnNpb25zSGVpZ2h0OiBmdW5jdGlvbihkaWZmSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5wbG90LmhlaWdodCAtPSBkaWZmSGVpZ2h0O1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMuc2VyaWVzLmhlaWdodCAtPSBkaWZmSGVpZ2h0O1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMuY3VzdG9tRXZlbnQuaGVpZ2h0IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy50b29sdGlwLmhlaWdodCAtPSBkaWZmSGVpZ2h0O1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMueUF4aXMuaGVpZ2h0IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5yaWdodFlBeGlzLmhlaWdodCAtPSBkaWZmSGVpZ2h0O1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMueEF4aXMuaGVpZ2h0ICs9IGRpZmZIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBkaW1lbnNpb25zIGFuZCBkZWdyZWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlRGltZW5zaW9uc0FuZERlZ3JlZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4QXhpc09wdGlvbnMgPSB0aGlzLm9wdGlvbnMueEF4aXMgfHwge307XG4gICAgICAgIHZhciBsaW1pdFdpZHRoID0gdGhpcy5fY2FsY3VsYXRlWEF4aXNMYWJlbExpbWl0V2lkdGgoKTtcbiAgICAgICAgdmFyIGxhYmVscyA9IHR1aS51dGlsLmZpbHRlcih0aGlzLmF4ZXNEYXRhLnhBeGlzLmxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWxhYmVsO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJvdGF0aW9uSW5mbywgb3ZlcmZsb3dMZWZ0LCBkaWZmSGVpZ2h0O1xuXG4gICAgICAgIGlmICh4QXhpc09wdGlvbnMucm90YXRlTGFiZWwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByb3RhdGlvbkluZm8gPSB0aGlzLl9tYWtlSG9yaXpvbnRhbExhYmVsUm90YXRpb25JbmZvKGxpbWl0V2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdGF0aW9uSW5mbykge1xuICAgICAgICAgICAgb3ZlcmZsb3dMZWZ0ID0gdGhpcy5fY2FsY3VsYXRlT3ZlcmZsb3dMZWZ0KHJvdGF0aW9uSW5mbywgbGFiZWxzWzBdKTtcbiAgICAgICAgICAgIHRoaXMueEF4aXNEZWdyZWUgPSByb3RhdGlvbkluZm8uZGVncmVlO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uc1dpZHRoKG92ZXJmbG93TGVmdCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEZWdyZWUocm90YXRpb25JbmZvLCBsYWJlbHMubGVuZ3RoLCBvdmVyZmxvd0xlZnQpO1xuICAgICAgICAgICAgZGlmZkhlaWdodCA9IHRoaXMuX2NhbGN1bGF0ZURpZmZXaXRoUm90YXRlZEhlaWdodChyb3RhdGlvbkluZm8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlmZkhlaWdodCA9IHRoaXMuX2NhbGN1bGF0ZURpZmZXaXRoTXVsdGlsaW5lSGVpZ2h0KGxhYmVscywgbGltaXRXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zSGVpZ2h0KGRpZmZIZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBsb3QgZGltZW50aW9uXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBsb3QgZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBsb3REaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzRGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogc2VyaWVzRGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBzZXJpZXNEaW1lbnNpb24uaGVpZ2h0ICsgY2hhcnRDb25zdC5PVkVSTEFQUElOR19XSURUSFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBheGlzIGNvbXBvbmVudHMgZGltZW5zaW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ2lzdGVyQXhpc0NvbXBvbmVudHNEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGxvdERpbWVuc2lvbiA9IHRoaXMuX21ha2VQbG90RGltZW5zaW9uKCk7XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEaW1lbnNpb24oJ3Bsb3QnLCBwbG90RGltZW5zaW9uKTtcblxuICAgICAgICB0aGlzLl9yZWdpc3RlckRpbWVuc2lvbigneEF4aXMnLCB7XG4gICAgICAgICAgICB3aWR0aDogcGxvdERpbWVuc2lvbi53aWR0aFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9yZWdpc3RlckRpbWVuc2lvbigneUF4aXMnLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IHBsb3REaW1lbnNpb24uaGVpZ2h0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKCdyaWdodFlBeGlzJywge1xuICAgICAgICAgICAgaGVpZ2h0OiBwbG90RGltZW5zaW9uLmhlaWdodFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgd2lkdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gc2VyaWVzIHdpZHRoXG4gICAgICovXG4gICAgbWFrZVNlcmllc1dpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYXJ0V2lkdGggPSB0aGlzLmdldERpbWVuc2lvbignY2hhcnQnKS53aWR0aDtcbiAgICAgICAgdmFyIHlBeGlzV2lkdGggPSB0aGlzLmdldERpbWVuc2lvbigneUF4aXMnKS53aWR0aDtcbiAgICAgICAgdmFyIGxlZ2VuZERpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uKCdjYWxjdWxhdGlvbkxlZ2VuZCcpO1xuICAgICAgICB2YXIgbGVnZW5kV2lkdGgsIHJpZ2h0QXJlYVdpZHRoO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaGFzVmVydGljYWxMZWdlbmRXaWR0aCh0aGlzLm9wdGlvbnMubGVnZW5kKSkge1xuICAgICAgICAgICAgbGVnZW5kV2lkdGggPSBsZWdlbmREaW1lbnNpb24gPyBsZWdlbmREaW1lbnNpb24ud2lkdGggOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVnZW5kV2lkdGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmlnaHRBcmVhV2lkdGggPSBsZWdlbmRXaWR0aCArIHRoaXMuZ2V0RGltZW5zaW9uKCdyaWdodFlBeGlzJykud2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0V2lkdGggLSAoY2hhcnRDb25zdC5DSEFSVF9QQURESU5HICogMikgLSB5QXhpc1dpZHRoIC0gcmlnaHRBcmVhV2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VyaWVzIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHNlcmllcyBoZWlnaHRcbiAgICAgKi9cbiAgICBtYWtlU2VyaWVzSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYXJ0SGVpZ2h0ID0gdGhpcy5nZXREaW1lbnNpb24oJ2NoYXJ0JykuaGVpZ2h0O1xuICAgICAgICB2YXIgdGl0bGVIZWlnaHQgPSB0aGlzLmdldERpbWVuc2lvbigndGl0bGUnKS5oZWlnaHQ7XG4gICAgICAgIHZhciBsZWdlbmRPcHRpb24gPSB0aGlzLm9wdGlvbnMubGVnZW5kO1xuICAgICAgICB2YXIgbGVnZW5kSGVpZ2h0LCBib3R0b21BcmVhV2lkdGg7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0hvcml6b250YWxMZWdlbmQobGVnZW5kT3B0aW9uLmFsaWduKSAmJiBsZWdlbmRPcHRpb24udmlzaWJsZSkge1xuICAgICAgICAgICAgbGVnZW5kSGVpZ2h0ID0gdGhpcy5nZXREaW1lbnNpb24oJ2xlZ2VuZCcpLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZ2VuZEhlaWdodCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBib3R0b21BcmVhV2lkdGggPSBsZWdlbmRIZWlnaHQgKyB0aGlzLmRpbWVuc2lvbnMueEF4aXMuaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiBjaGFydEhlaWdodCAtIChjaGFydENvbnN0LkNIQVJUX1BBRERJTkcgKiAyKSAtIHRpdGxlSGVpZ2h0IC0gYm90dG9tQXJlYVdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllcyBkaW1lbnNpb24uXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHNlcmllcyBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLm1ha2VTZXJpZXNXaWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLm1ha2VTZXJpZXNIZWlnaHQoKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBjZW50ZXIgY29tcG9uZXRzIGRpbWVuc2lvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlckNlbnRlckNvbXBvbmVudHNEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzRGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKCd0b29sdGlwJywgc2VyaWVzRGltZW5zaW9uKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEaW1lbnNpb24oJ2N1c3RvbUV2ZW50Jywgc2VyaWVzRGltZW5zaW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYXhlcyB0eXBlIGNvbXBvbmVudCBwb3NpdGlvbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnRMZWdlbmRXaWR0aCBsZWdlbmQgd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlckF4aXNDb21wb25lbnRzUG9zaXRpb246IGZ1bmN0aW9uKGxlZnRMZWdlbmRXaWR0aCkge1xuICAgICAgICB2YXIgc2VyaWVzUG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uKCdzZXJpZXMnKSxcbiAgICAgICAgICAgIHNlcmllc0RpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKSxcbiAgICAgICAgICAgIHlBeGlzV2lkdGggPSB0aGlzLmdldERpbWVuc2lvbigneUF4aXMnKS53aWR0aCxcbiAgICAgICAgICAgIGxlZnRBcmVhV2lkdGggPSB5QXhpc1dpZHRoICsgc2VyaWVzRGltZW5zaW9uLndpZHRoICsgbGVmdExlZ2VuZFdpZHRoO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25zLnBsb3QgPSB7XG4gICAgICAgICAgICB0b3A6IHNlcmllc1Bvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHNlcmllc1Bvc2l0aW9uLmxlZnRcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9ucy55QXhpcyA9IHtcbiAgICAgICAgICAgIHRvcDogc2VyaWVzUG9zaXRpb24udG9wLFxuICAgICAgICAgICAgbGVmdDogdGhpcy5jaGFydExlZnRQYWRkaW5nICsgbGVmdExlZ2VuZFdpZHRoXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMueEF4aXMgPSB7XG4gICAgICAgICAgICB0b3A6IHNlcmllc1Bvc2l0aW9uLnRvcCArIHNlcmllc0RpbWVuc2lvbi5oZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiBzZXJpZXNQb3NpdGlvbi5sZWZ0XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMucmlnaHRZQXhpcyA9IHtcbiAgICAgICAgICAgIHRvcDogc2VyaWVzUG9zaXRpb24udG9wLFxuICAgICAgICAgICAgbGVmdDogdGhpcy5jaGFydExlZnRQYWRkaW5nICsgbGVmdEFyZWFXaWR0aCAtIGNoYXJ0Q29uc3QuT1ZFUkxBUFBJTkdfV0lEVEhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsZWdlbmQgYm91bmQuXG4gICAgICogQHJldHVybnMge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIHBvc2l0aW9uOiB7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19fSBsZWdlbmQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGVnZW5kUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucyxcbiAgICAgICAgICAgIHNlcmllc0RpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKSxcbiAgICAgICAgICAgIGxlZ2VuZE9wdGlvbiA9IHRoaXMub3B0aW9ucy5sZWdlbmQsXG4gICAgICAgICAgICB0b3AgPSBkaW1lbnNpb25zLnRpdGxlLmhlaWdodCxcbiAgICAgICAgICAgIHlBeGlzQXJlYVdpZHRoLCBsZWZ0O1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNMZWdlbmRBbGlnbkJvdHRvbShsZWdlbmRPcHRpb24uYWxpZ24pKSB7XG4gICAgICAgICAgICB0b3AgKz0gc2VyaWVzRGltZW5zaW9uLmhlaWdodCArIHRoaXMuZ2V0RGltZW5zaW9uKCd4QXhpcycpLmhlaWdodCArIGNoYXJ0Q29uc3QuTEVHRU5EX0FSRUFfUEFERElORztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNIb3Jpem9udGFsTGVnZW5kKGxlZ2VuZE9wdGlvbi5hbGlnbikpIHtcbiAgICAgICAgICAgIGxlZnQgPSAoKHRoaXMuZ2V0RGltZW5zaW9uKCdjaGFydCcpLndpZHRoIC0gdGhpcy5nZXREaW1lbnNpb24oJ2xlZ2VuZCcpLndpZHRoKSAvIDIpXG4gICAgICAgICAgICAgICAgLSBjaGFydENvbnN0LkxFR0VORF9BUkVBX1BBRERJTkc7XG4gICAgICAgIH0gZWxzZSBpZiAocHJlZGljYXRlLmlzTGVnZW5kQWxpZ25MZWZ0KGxlZ2VuZE9wdGlvbi5hbGlnbikpIHtcbiAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeUF4aXNBcmVhV2lkdGggPSB0aGlzLmdldERpbWVuc2lvbigneUF4aXMnKS53aWR0aCArIHRoaXMuZ2V0RGltZW5zaW9uKCdyaWdodFlBeGlzJykud2lkdGg7XG4gICAgICAgICAgICBsZWZ0ID0gc2VyaWVzRGltZW5zaW9uLndpZHRoICsgeUF4aXNBcmVhV2lkdGggKyB0aGlzLmNoYXJ0TGVmdFBhZGRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgQ2lyY2xlTGVnZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNpcmNsZUxlZ2VuZFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc1Bvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbignc2VyaWVzJyk7XG4gICAgICAgIHZhciBzZXJpZXNEaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbignc2VyaWVzJyk7XG4gICAgICAgIHZhciBjaXJjbGVEaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbignY2lyY2xlTGVnZW5kJyk7XG4gICAgICAgIHZhciBsZWdlbmRPcHRpb24gPSB0aGlzLm9wdGlvbnMubGVnZW5kO1xuICAgICAgICB2YXIgbGVmdCwgbGVnZW5kV2lkdGg7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0xlZ2VuZEFsaWduTGVmdChsZWdlbmRPcHRpb24uYWxpZ24pKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBzZXJpZXNQb3NpdGlvbi5sZWZ0ICsgc2VyaWVzRGltZW5zaW9uLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5oYXNWZXJ0aWNhbExlZ2VuZFdpZHRoKHRoaXMub3B0aW9ucy5sZWdlbmQpKSB7XG4gICAgICAgICAgICBsZWdlbmRXaWR0aCA9IHRoaXMuZ2V0RGltZW5zaW9uKCdsZWdlbmQnKS53aWR0aCArIGNoYXJ0Q29uc3QuQ0hBUlRfUEFERElORztcbiAgICAgICAgICAgIGxlZnQgKz0gKGxlZ2VuZFdpZHRoIC0gY2lyY2xlRGltZW5zaW9uLndpZHRoKSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBzZXJpZXNQb3NpdGlvbi50b3AgKyBzZXJpZXNEaW1lbnNpb24uaGVpZ2h0IC0gY2lyY2xlRGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBuZWVkIGV4cGFuc2lvbiBzZXJpZXMgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzTmVlZEV4cGFuc2lvblNlcmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFydFR5cGUgPSB0aGlzLmNoYXJ0VHlwZTtcblxuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5pc01vdXNlUG9zaXRpb25DaGFydChjaGFydFR5cGUpICYmICFwcmVkaWNhdGUuaXNUcmVlbWFwQ2hhcnQoY2hhcnRUeXBlKVxuICAgICAgICAgICAgJiYgIXByZWRpY2F0ZS5pc1BpZURvbnV0Q29tYm9DaGFydChjaGFydFR5cGUsIHRoaXMuY2hhcnRUeXBlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGVzc2VudGlhbCBjb21wb25lbnRzIHBvc2l0aW9ucy5cbiAgICAgKiBFc3NlbnRpYWwgY29tcG9uZW50cyBpcyBhbGwgY29tcG9uZW50cyBleGNlcHQgY29tcG9uZW50cyBmb3IgYXhpcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlckVzc2VudGlhbENvbXBvbmVudHNQb3NpdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzUG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uKCdzZXJpZXMnKTtcbiAgICAgICAgdmFyIHRvb2x0aXBQb3NpdGlvbjtcblxuICAgICAgICB0aGlzLnBvc2l0aW9ucy5jdXN0b21FdmVudCA9IHR1aS51dGlsLmV4dGVuZCh7fSwgc2VyaWVzUG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucy5sZWdlbmQgPSB0aGlzLl9tYWtlTGVnZW5kUG9zaXRpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5nZXREaW1lbnNpb24oJ2NpcmNsZUxlZ2VuZCcpLndpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5jaXJjbGVMZWdlbmQgPSB0aGlzLl9tYWtlQ2lyY2xlTGVnZW5kUG9zaXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pc05lZWRFeHBhbnNpb25TZXJpZXMoKSkge1xuICAgICAgICAgICAgdG9vbHRpcFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHRvcDogc2VyaWVzUG9zaXRpb24udG9wIC0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICAgICAgbGVmdDogc2VyaWVzUG9zaXRpb24ubGVmdCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9vbHRpcFBvc2l0aW9uID0gc2VyaWVzUG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvc2l0aW9ucy50b29sdGlwID0gdG9vbHRpcFBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBwb3NpdGlvbnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJQb3NpdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWxpZ25PcHRpb24gPSB0aGlzLm9wdGlvbnMubGVnZW5kLmFsaWduO1xuICAgICAgICB2YXIgaXNWaXNpYmxlTGVnZW5kID0gdGhpcy5vcHRpb25zLmxlZ2VuZC52aXNpYmxlO1xuICAgICAgICB2YXIgbGVnZW5kRGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb24oJ2xlZ2VuZCcpO1xuICAgICAgICB2YXIgdG9wTGVnZW5kSGVpZ2h0ID0gKHByZWRpY2F0ZS5pc0xlZ2VuZEFsaWduVG9wKGFsaWduT3B0aW9uKSAmJiBpc1Zpc2libGVMZWdlbmQpID8gbGVnZW5kRGltZW5zaW9uLmhlaWdodCA6IDA7XG4gICAgICAgIHZhciBsZWZ0TGVnZW5kV2lkdGggPSAocHJlZGljYXRlLmlzTGVnZW5kQWxpZ25MZWZ0KGFsaWduT3B0aW9uKSAmJiBpc1Zpc2libGVMZWdlbmQpID8gbGVnZW5kRGltZW5zaW9uLndpZHRoIDogMDtcbiAgICAgICAgdmFyIHNlcmllc1Bvc2l0aW9uID0ge1xuICAgICAgICAgICAgdG9wOiB0aGlzLmdldERpbWVuc2lvbigndGl0bGUnKS5oZWlnaHQgKyBjaGFydENvbnN0LkNIQVJUX1BBRERJTkcgKyB0b3BMZWdlbmRIZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmNoYXJ0TGVmdFBhZGRpbmcgKyBsZWZ0TGVnZW5kV2lkdGggKyB0aGlzLmdldERpbWVuc2lvbigneUF4aXMnKS53aWR0aFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25zLnNlcmllcyA9IHNlcmllc1Bvc2l0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0F4ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnNBbmREZWdyZWUoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQXhpc0NvbXBvbmVudHNQb3NpdGlvbihsZWZ0TGVnZW5kV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJFc3NlbnRpYWxDb21wb25lbnRzUG9zaXRpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGJvdW5kIG9mIGV4dGVuZGVkIHNlcmllcyBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ2lzdGVyRXh0ZW5kZWRTZXJpZXNCb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IHRoaXMuZ2V0Qm91bmQoJ3NlcmllcycpO1xuICAgICAgICBpZiAodGhpcy5faXNOZWVkRXhwYW5zaW9uU2VyaWVzKCkpIHtcbiAgICAgICAgICAgIHNlcmllc0JvdW5kID0gcmVuZGVyVXRpbC5leHBhbmRCb3VuZChzZXJpZXNCb3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRCb3VuZCgnZXh0ZW5kZWRTZXJpZXMnLCBzZXJpZXNCb3VuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBib3VuZHMocG9zaXRpb25zLCBkaW1lbnNpb25zKSBvZiBjb21wb25lbnRzIGZvciBjZW50ZXIgb3B0aW9uIG9mIHlBeGlzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUJvdW5kc0ZvcllBeGlzQ2VudGVyT3B0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHlBeGlzV2lkdGggPSB0aGlzLmdldERpbWVuc2lvbigneUF4aXMnKS53aWR0aCxcbiAgICAgICAgICAgIHlBeGlzRXh0ZW5zaWJsZUxlZnQgPSBNYXRoLmZsb29yKCh0aGlzLmdldERpbWVuc2lvbignc2VyaWVzJykud2lkdGggLyAyKSkgKyBjaGFydENvbnN0Lk9WRVJMQVBQSU5HX1dJRFRILFxuICAgICAgICAgICAgeEF4aXNEZWNyZWFzaW5nTGVmdCA9IHlBeGlzV2lkdGggLSBjaGFydENvbnN0Lk9WRVJMQVBQSU5HX1dJRFRILFxuICAgICAgICAgICAgYWRkaXRpb25hbExlZnQgPSByZW5kZXJVdGlsLmlzT2xkQnJvd3NlcigpID8gMSA6IDA7XG5cbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLmV4dGVuZGVkU2VyaWVzLndpZHRoICs9IHlBeGlzV2lkdGg7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy54QXhpcy53aWR0aCArPSBjaGFydENvbnN0Lk9WRVJMQVBQSU5HX1dJRFRIO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMucGxvdC53aWR0aCArPSB5QXhpc1dpZHRoICsgY2hhcnRDb25zdC5PVkVSTEFQUElOR19XSURUSDtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLmN1c3RvbUV2ZW50LndpZHRoICs9IHlBeGlzV2lkdGg7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy50b29sdGlwLndpZHRoICs9IHlBeGlzV2lkdGg7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMuc2VyaWVzLmxlZnQgLT0gKHlBeGlzV2lkdGggLSBhZGRpdGlvbmFsTGVmdCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25zLmV4dGVuZGVkU2VyaWVzLmxlZnQgLT0gKHhBeGlzRGVjcmVhc2luZ0xlZnQgLSBhZGRpdGlvbmFsTGVmdCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25zLnBsb3QubGVmdCAtPSB4QXhpc0RlY3JlYXNpbmdMZWZ0O1xuICAgICAgICB0aGlzLnBvc2l0aW9ucy55QXhpcy5sZWZ0ICs9IHlBeGlzRXh0ZW5zaWJsZUxlZnQ7XG4gICAgICAgIHRoaXMucG9zaXRpb25zLnhBeGlzLmxlZnQgLT0geEF4aXNEZWNyZWFzaW5nTGVmdDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMuY3VzdG9tRXZlbnQubGVmdCAtPSB4QXhpc0RlY3JlYXNpbmdMZWZ0O1xuICAgICAgICB0aGlzLnBvc2l0aW9ucy50b29sdGlwLmxlZnQgLT0geEF4aXNEZWNyZWFzaW5nTGVmdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgc2VyaWVzIGRpbWVuc2lvbi5cbiAgICAgKi9cbiAgICByZWdpc3RlclNlcmllc0RpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXJpZXNEaW1lbnNpb24gPSB0aGlzLl9tYWtlU2VyaWVzRGltZW5zaW9uKCk7XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEaW1lbnNpb24oJ3NlcmllcycsIHNlcmllc0RpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGJvdW5kcyBkYXRhLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyQm91bmRzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQ2VudGVyQ29tcG9uZW50c0RpbWVuc2lvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0F4ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQXhpc0NvbXBvbmVudHNEaW1lbnNpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyUG9zaXRpb25zKCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRXh0ZW5kZWRTZXJpZXNCb3VuZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMueUF4aXMuaXNDZW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kc0ZvcllBeGlzQ2VudGVyT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZHNNYWtlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBjYWxjdWxhdG9yLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50IG5vLW1hZ2ljLW51bWJlcnM6IFsxLCB7aWdub3JlOiBbLTEsIDAsIDEsIDIsIDEwLCAyMCwgNiwgMC4xXX1dKi9cblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG4vKipcbiAqIENhbGN1bGF0b3IuXG4gKiBAbW9kdWxlIGNhbGN1bGF0b3JcbiAqL1xudmFyIGNhbGN1bGF0b3IgPSB7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGxpbWl0IGZyb20gY2hhcnQgbWluLCBtYXggZGF0YS5cbiAgICAgKiAgLSBodHRwOi8vcGVsdGllcnRlY2guY29tL2hvdy1leGNlbC1jYWxjdWxhdGVzLWF1dG9tYXRpYy1jaGFydC1heGlzLWxpbWl0cy9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmNhbGN1bGF0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIG1pbiBtaW5pbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggbWF4IG1heGltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCB0aWNrIGNvdW50XG4gICAgICogQHJldHVybnMge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBheGlzIGxpbWl0XG4gICAgICovXG4gICAgY2FsY3VsYXRlTGltaXQ6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciBzYXZlTWluID0gMCxcbiAgICAgICAgICAgIGxpbWl0ID0ge30sXG4gICAgICAgICAgICBpb2RWYWx1ZTsgLy8gaW5jcmVhc2Ugb3IgZGVjcmVhc2UgdmFsdWU7XG5cbiAgICAgICAgaWYgKG1pbiA8IDApIHtcbiAgICAgICAgICAgIHNhdmVNaW4gPSBtaW47XG4gICAgICAgICAgICBtYXggLT0gbWluO1xuICAgICAgICAgICAgbWluID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlvZFZhbHVlID0gKG1heCAtIG1pbikgLyAyMDtcbiAgICAgICAgbGltaXQubWF4ID0gbWF4ICsgaW9kVmFsdWUgKyBzYXZlTWluO1xuXG4gICAgICAgIGlmIChtYXggLyA2ID4gbWluKSB7XG4gICAgICAgICAgICBsaW1pdC5taW4gPSAwICsgc2F2ZU1pbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbWl0Lm1pbiA9IG1pbiAtIGlvZFZhbHVlICsgc2F2ZU1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW1pdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIG51bWJlci5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmNhbGN1bGF0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdGFyZ2V0IHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn0gbm9ybWFsaXplZCBudW1iZXJcbiAgICAgKi9cbiAgICBub3JtYWxpemVBeGlzTnVtYmVyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc3RhbmRhcmQgPSAwLFxuICAgICAgICAgICAgZmxhZyA9IDEsXG4gICAgICAgICAgICBub3JtYWxpemVkLCBtb2Q7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBmbGFnID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAqPSBmbGFnO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjaGFydENvbnN0LkFYSVNfU1RBTkRBUkRfTVVMVElQTEVfTlVNUywgZnVuY3Rpb24obnVtKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCBudW0pIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZCA9IG51bTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gY2hhcnRDb25zdC5BWElTX0xBU1RfU1RBTkRBUkRfTVVMVElQTEVfTlVNKSB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmQgPSBudW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3RhbmRhcmQgPCAxKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemVBeGlzTnVtYmVyKHZhbHVlICogMTApICogMC4xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kID0gdHVpLnV0aWwubW9kKHZhbHVlLCBzdGFuZGFyZCk7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdHVpLnV0aWwuYWRkaXRpb24odmFsdWUsIChtb2QgPiAwID8gc3RhbmRhcmQgLSBtb2QgOiAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkICo9IGZsYWc7XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdGljayBwb3NpdGlvbnMgb2YgcGl4ZWwgdHlwZS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmNhbGN1bGF0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBhcmVhIHdpZHRoIG9yIGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBhZGRpdGlvbmFsUG9zaXRpb24gYWRkaXRpb25hbCBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gcG9zaXRpb25zXG4gICAgICovXG4gICAgbWFrZVRpY2tQaXhlbFBvc2l0aW9uczogZnVuY3Rpb24oc2l6ZSwgY291bnQsIGFkZGl0aW9uYWxQb3NpdGlvbikge1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gW10sXG4gICAgICAgICAgICBweExpbWl0LCBweFN0ZXA7XG5cbiAgICAgICAgYWRkaXRpb25hbFBvc2l0aW9uID0gYWRkaXRpb25hbFBvc2l0aW9uIHx8IDA7XG5cbiAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgcHhMaW1pdCA9IHttaW46IDAsIG1heDogc2l6ZSAtIDF9O1xuICAgICAgICAgICAgcHhTdGVwID0gdGhpcy5jYWxjdWxhdGVTdGVwRnJvbUxpbWl0KHB4TGltaXQsIGNvdW50KTtcbiAgICAgICAgICAgIHBvc2l0aW9ucyA9IHR1aS51dGlsLm1hcCh0dWkudXRpbC5yYW5nZSgwLCBzaXplLCBweFN0ZXApLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBvc2l0aW9uICsgYWRkaXRpb25hbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSA9IE1hdGgucm91bmQoc2l6ZSAtIDEgKyBhZGRpdGlvbmFsUG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsYWJlbHMgZnJvbSBsaW1pdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmNhbGN1bGF0b3JcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBheGlzIGxpbWl0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgc3RlcCBiZXR3ZWVuIG1heCBhbmQgbWluXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBsYWJlbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1ha2VMYWJlbHNGcm9tTGltaXQ6IGZ1bmN0aW9uKGxpbWl0LCBzdGVwKSB7XG4gICAgICAgIHZhciBtdWx0aXBsZU51bSA9IHR1aS51dGlsLmZpbmRNdWx0aXBsZU51bShzdGVwKTtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgucm91bmQobGltaXQubWluICogbXVsdGlwbGVOdW0pO1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5yb3VuZChsaW1pdC5tYXggKiBtdWx0aXBsZU51bSk7XG4gICAgICAgIHZhciBsYWJlbHMgPSB0dWkudXRpbC5yYW5nZShtaW4sIG1heCArIDEsIHN0ZXAgKiBtdWx0aXBsZU51bSk7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChsYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWwgLyBtdWx0aXBsZU51bTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBzdGVwIGZyb20gbGltaXQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpjYWxjdWxhdG9yXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgYXhpcyBsaW1pdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCB2YWx1ZSBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHN0ZXBcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVTdGVwRnJvbUxpbWl0OiBmdW5jdGlvbihsaW1pdCwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIChsaW1pdC5tYXggLSBsaW1pdC5taW4pIC8gKGNvdW50IC0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhZGphY2VudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlIGRlZ3JlZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoeXBvdGVudXNlIGh5cG90ZW51c2VcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBhZGphY2VudFxuICAgICAqXG4gICAgICogICBIIDogSHlwb3RlbnVzZVxuICAgICAqICAgQSA6IEFkamFjZW50XG4gICAgICogICBPIDogT3Bwb3NpdGVcbiAgICAgKiAgIEQgOiBEZWdyZWVcbiAgICAgKlxuICAgICAqICAgICAgICAvfFxuICAgICAqICAgICAgIC8gfFxuICAgICAqICAgIEggLyAgfCBPXG4gICAgICogICAgIC8gICB8XG4gICAgICogICAgL1xcIEQgfFxuICAgICAqICAgIC0tLS0tXG4gICAgICogICAgICAgQVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUFkamFjZW50OiBmdW5jdGlvbihkZWdyZWUsIGh5cG90ZW51c2UpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY29zKGRlZ3JlZSAqIGNoYXJ0Q29uc3QuUkFEKSAqIGh5cG90ZW51c2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBvcHBvc2l0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlIGRlZ3JlZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoeXBvdGVudXNlIGh5cG90ZW51c2VcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBvcHBvc2l0ZVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZU9wcG9zaXRlOiBmdW5jdGlvbihkZWdyZWUsIGh5cG90ZW51c2UpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKGRlZ3JlZSAqIGNoYXJ0Q29uc3QuUkFEKSAqIGh5cG90ZW51c2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1bSBwbHVzIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgdmFsdWVzXG4gICAgICogQHJldHVybnMge251bWJlcn0gc3VtXG4gICAgICovXG4gICAgc3VtUGx1c1ZhbHVlczogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIHZhciBwbHVzVmFsdWVzID0gdHVpLnV0aWwuZmlsdGVyKHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5zdW0ocGx1c1ZhbHVlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1bSBtaW51cyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVzIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHN1bVxuICAgICAqL1xuICAgIHN1bU1pbnVzVmFsdWVzOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgdmFyIG1pbnVzVmFsdWVzID0gdHVpLnV0aWwuZmlsdGVyKHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5zdW0obWludXNWYWx1ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBlcmNlbnRhZ2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWxWYWx1ZSAtIHRvdGFsIHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBtYWtlUGVyY2VudGFnZVZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgdG90YWxWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgLyB0b3RhbFZhbHVlICogMTAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgcmF0aW8gZm9yIG1ha2luZyBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZOdW1iZXIgLSBudW1iZXIgZm9yIGRpdmlzaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1Yk51bWJlciAtIG51bWJlciBmb3Igc3VidHJhY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZVJhdGlvIC0gYmFzZSByYXRpb1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY2FsY3VsYXRlUmF0aW86IGZ1bmN0aW9uKHZhbHVlLCBkaXZOdW1iZXIsIHN1Yk51bWJlciwgYmFzZVJhdGlvKSB7XG4gICAgICAgIHJldHVybiAoKHZhbHVlIC0gc3ViTnVtYmVyKSAvIGRpdk51bWJlcikgKiBiYXNlUmF0aW87XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjYWxjdWxhdG9yO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxpdHkgbWV0aG9kcyB0byBtYW5pcHVsYXRlIGNvbG9yc1xuICogQGF1dGhvciBOSE4gRW50LiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBuby1tYWdpYy1udW1iZXJzOiBbMSwge2lnbm9yZTogWy0xLCAwLCAxLCAyLCA0LCAxNl19XSovXG5cbnZhciBoZXhSWCA9IC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaTtcblxuLyoqXG4gKiBDb2xvciBtYXAuXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1NzMwNTMvamF2YXNjcmlwdC1mdW5jdGlvbi10by1jb252ZXJ0LWNvbG9yLW5hbWVzLXRvLWhleC1jb2Rlc1xuICogaHR0cDovL3d3dy53M3NjaG9vbHMuY29tL0hUTUwvaHRtbF9jb2xvcm5hbWVzLmFzcFxuICogQHR5cGUge29iamVjdH1cbiAqL1xudmFyIGNvbG9yTWFwID0ge1xuICAgICdhbGljZWJsdWUnOiAnI2YwZjhmZicsXG4gICAgJ2FudGlxdWV3aGl0ZSc6ICcjZmFlYmQ3JyxcbiAgICAnYXF1YSc6ICcjMDBmZmZmJyxcbiAgICAnYXF1YW1hcmluZSc6ICcjN2ZmZmQ0JyxcbiAgICAnYXp1cmUnOiAnI2YwZmZmZicsXG4gICAgJ2JlaWdlJzogJyNmNWY1ZGMnLFxuICAgICdiaXNxdWUnOiAnI2ZmZTRjNCcsXG4gICAgJ2JsYWNrJzogJyMwMDAwMDAnLFxuICAgICdibGFuY2hlZGFsbW9uZCc6ICcjZmZlYmNkJyxcbiAgICAnYmx1ZSc6ICcjMDAwMGZmJyxcbiAgICAnYmx1ZXZpb2xldCc6ICcjOGEyYmUyJyxcbiAgICAnYnJvd24nOiAnI2E1MmEyYScsXG4gICAgJ2J1cmx5d29vZCc6ICcjZGViODg3JyxcbiAgICAnY2FkZXRibHVlJzogJyM1ZjllYTAnLFxuICAgICdjaGFydHJldXNlJzogJyM3ZmZmMDAnLFxuICAgICdjaG9jb2xhdGUnOiAnI2QyNjkxZScsXG4gICAgJ2NvcmFsJzogJyNmZjdmNTAnLFxuICAgICdjb3JuZmxvd2VyYmx1ZSc6ICcjNjQ5NWVkJyxcbiAgICAnY29ybnNpbGsnOiAnI2ZmZjhkYycsXG4gICAgJ2NyaW1zb24nOiAnI2RjMTQzYycsXG4gICAgJ2N5YW4nOiAnIzAwZmZmZicsXG4gICAgJ2RhcmtibHVlJzogJyMwMDAwOGInLFxuICAgICdkYXJrY3lhbic6ICcjMDA4YjhiJyxcbiAgICAnZGFya2dvbGRlbnJvZCc6ICcjYjg4NjBiJyxcbiAgICAnZGFya2dyYXknOiAnI2E5YTlhOScsXG4gICAgJ2RhcmtncmVlbic6ICcjMDA2NDAwJyxcbiAgICAnZGFya2toYWtpJzogJyNiZGI3NmInLFxuICAgICdkYXJrbWFnZW50YSc6ICcjOGIwMDhiJyxcbiAgICAnZGFya29saXZlZ3JlZW4nOiAnIzU1NmIyZicsXG4gICAgJ2RhcmtvcmFuZ2UnOiAnI2ZmOGMwMCcsXG4gICAgJ2RhcmtvcmNoaWQnOiAnIzk5MzJjYycsXG4gICAgJ2RhcmtyZWQnOiAnIzhiMDAwMCcsXG4gICAgJ2RhcmtzYWxtb24nOiAnI2U5OTY3YScsXG4gICAgJ2RhcmtzZWFncmVlbic6ICcjOGZiYzhmJyxcbiAgICAnZGFya3NsYXRlYmx1ZSc6ICcjNDgzZDhiJyxcbiAgICAnZGFya3NsYXRlZ3JheSc6ICcjMmY0ZjRmJyxcbiAgICAnZGFya3R1cnF1b2lzZSc6ICcjMDBjZWQxJyxcbiAgICAnZGFya3Zpb2xldCc6ICcjOTQwMGQzJyxcbiAgICAnZGVlcHBpbmsnOiAnI2ZmMTQ5MycsXG4gICAgJ2RlZXBza3libHVlJzogJyMwMGJmZmYnLFxuICAgICdkaW1ncmF5JzogJyM2OTY5NjknLFxuICAgICdkb2RnZXJibHVlJzogJyMxZTkwZmYnLFxuICAgICdmaXJlYnJpY2snOiAnI2IyMjIyMicsXG4gICAgJ2Zsb3JhbHdoaXRlJzogJyNmZmZhZjAnLFxuICAgICdmb3Jlc3RncmVlbic6ICcjMjI4YjIyJyxcbiAgICAnZnVjaHNpYSc6ICcjZmYwMGZmJyxcbiAgICAnZ2FpbnNib3JvJzogJyNkY2RjZGMnLFxuICAgICdnaG9zdHdoaXRlJzogJyNmOGY4ZmYnLFxuICAgICdnb2xkJzogJyNmZmQ3MDAnLFxuICAgICdnb2xkZW5yb2QnOiAnI2RhYTUyMCcsXG4gICAgJ2dyYXknOiAnIzgwODA4MCcsXG4gICAgJ2dyZWVuJzogJyMwMDgwMDAnLFxuICAgICdncmVlbnllbGxvdyc6ICcjYWRmZjJmJyxcbiAgICAnaG9uZXlkZXcnOiAnI2YwZmZmMCcsXG4gICAgJ2hvdHBpbmsnOiAnI2ZmNjliNCcsXG4gICAgJ2luZGlhbnJlZCAnOiAnI2NkNWM1YycsXG4gICAgJ2luZGlnbyc6ICcjNGIwMDgyJyxcbiAgICAnaXZvcnknOiAnI2ZmZmZmMCcsXG4gICAgJ2toYWtpJzogJyNmMGU2OGMnLFxuICAgICdsYXZlbmRlcic6ICcjZTZlNmZhJyxcbiAgICAnbGF2ZW5kZXJibHVzaCc6ICcjZmZmMGY1JyxcbiAgICAnbGF3bmdyZWVuJzogJyM3Y2ZjMDAnLFxuICAgICdsZW1vbmNoaWZmb24nOiAnI2ZmZmFjZCcsXG4gICAgJ2xpZ2h0Ymx1ZSc6ICcjYWRkOGU2JyxcbiAgICAnbGlnaHRjb3JhbCc6ICcjZjA4MDgwJyxcbiAgICAnbGlnaHRjeWFuJzogJyNlMGZmZmYnLFxuICAgICdsaWdodGdvbGRlbnJvZHllbGxvdyc6ICcjZmFmYWQyJyxcbiAgICAnbGlnaHRncmV5JzogJyNkM2QzZDMnLFxuICAgICdsaWdodGdyZWVuJzogJyM5MGVlOTAnLFxuICAgICdsaWdodHBpbmsnOiAnI2ZmYjZjMScsXG4gICAgJ2xpZ2h0c2FsbW9uJzogJyNmZmEwN2EnLFxuICAgICdsaWdodHNlYWdyZWVuJzogJyMyMGIyYWEnLFxuICAgICdsaWdodHNreWJsdWUnOiAnIzg3Y2VmYScsXG4gICAgJ2xpZ2h0c2xhdGVncmF5JzogJyM3Nzg4OTknLFxuICAgICdsaWdodHN0ZWVsYmx1ZSc6ICcjYjBjNGRlJyxcbiAgICAnbGlnaHR5ZWxsb3cnOiAnI2ZmZmZlMCcsXG4gICAgJ2xpbWUnOiAnIzAwZmYwMCcsXG4gICAgJ2xpbWVncmVlbic6ICcjMzJjZDMyJyxcbiAgICAnbGluZW4nOiAnI2ZhZjBlNicsXG4gICAgJ21hZ2VudGEnOiAnI2ZmMDBmZicsXG4gICAgJ21hcm9vbic6ICcjODAwMDAwJyxcbiAgICAnbWVkaXVtYXF1YW1hcmluZSc6ICcjNjZjZGFhJyxcbiAgICAnbWVkaXVtYmx1ZSc6ICcjMDAwMGNkJyxcbiAgICAnbWVkaXVtb3JjaGlkJzogJyNiYTU1ZDMnLFxuICAgICdtZWRpdW1wdXJwbGUnOiAnIzkzNzBkOCcsXG4gICAgJ21lZGl1bXNlYWdyZWVuJzogJyMzY2IzNzEnLFxuICAgICdtZWRpdW1zbGF0ZWJsdWUnOiAnIzdiNjhlZScsXG4gICAgJ21lZGl1bXNwcmluZ2dyZWVuJzogJyMwMGZhOWEnLFxuICAgICdtZWRpdW10dXJxdW9pc2UnOiAnIzQ4ZDFjYycsXG4gICAgJ21lZGl1bXZpb2xldHJlZCc6ICcjYzcxNTg1JyxcbiAgICAnbWlkbmlnaHRibHVlJzogJyMxOTE5NzAnLFxuICAgICdtaW50Y3JlYW0nOiAnI2Y1ZmZmYScsXG4gICAgJ21pc3R5cm9zZSc6ICcjZmZlNGUxJyxcbiAgICAnbW9jY2FzaW4nOiAnI2ZmZTRiNScsXG4gICAgJ25hdmFqb3doaXRlJzogJyNmZmRlYWQnLFxuICAgICduYXZ5JzogJyMwMDAwODAnLFxuICAgICdvbGRsYWNlJzogJyNmZGY1ZTYnLFxuICAgICdvbGl2ZSc6ICcjODA4MDAwJyxcbiAgICAnb2xpdmVkcmFiJzogJyM2YjhlMjMnLFxuICAgICdvcmFuZ2UnOiAnI2ZmYTUwMCcsXG4gICAgJ29yYW5nZXJlZCc6ICcjZmY0NTAwJyxcbiAgICAnb3JjaGlkJzogJyNkYTcwZDYnLFxuICAgICdwYWxlZ29sZGVucm9kJzogJyNlZWU4YWEnLFxuICAgICdwYWxlZ3JlZW4nOiAnIzk4ZmI5OCcsXG4gICAgJ3BhbGV0dXJxdW9pc2UnOiAnI2FmZWVlZScsXG4gICAgJ3BhbGV2aW9sZXRyZWQnOiAnI2Q4NzA5MycsXG4gICAgJ3BhcGF5YXdoaXAnOiAnI2ZmZWZkNScsXG4gICAgJ3BlYWNocHVmZic6ICcjZmZkYWI5JyxcbiAgICAncGVydSc6ICcjY2Q4NTNmJyxcbiAgICAncGluayc6ICcjZmZjMGNiJyxcbiAgICAncGx1bSc6ICcjZGRhMGRkJyxcbiAgICAncG93ZGVyYmx1ZSc6ICcjYjBlMGU2JyxcbiAgICAncHVycGxlJzogJyM4MDAwODAnLFxuICAgICdyZWQnOiAnI2ZmMDAwMCcsXG4gICAgJ3Jvc3licm93bic6ICcjYmM4ZjhmJyxcbiAgICAncm95YWxibHVlJzogJyM0MTY5ZTEnLFxuICAgICdzYWRkbGVicm93bic6ICcjOGI0NTEzJyxcbiAgICAnc2FsbW9uJzogJyNmYTgwNzInLFxuICAgICdzYW5keWJyb3duJzogJyNmNGE0NjAnLFxuICAgICdzZWFncmVlbic6ICcjMmU4YjU3JyxcbiAgICAnc2Vhc2hlbGwnOiAnI2ZmZjVlZScsXG4gICAgJ3NpZW5uYSc6ICcjYTA1MjJkJyxcbiAgICAnc2lsdmVyJzogJyNjMGMwYzAnLFxuICAgICdza3libHVlJzogJyM4N2NlZWInLFxuICAgICdzbGF0ZWJsdWUnOiAnIzZhNWFjZCcsXG4gICAgJ3NsYXRlZ3JheSc6ICcjNzA4MDkwJyxcbiAgICAnc25vdyc6ICcjZmZmYWZhJyxcbiAgICAnc3ByaW5nZ3JlZW4nOiAnIzAwZmY3ZicsXG4gICAgJ3N0ZWVsYmx1ZSc6ICcjNDY4MmI0JyxcbiAgICAndGFuJzogJyNkMmI0OGMnLFxuICAgICd0ZWFsJzogJyMwMDgwODAnLFxuICAgICd0aGlzdGxlJzogJyNkOGJmZDgnLFxuICAgICd0b21hdG8nOiAnI2ZmNjM0NycsXG4gICAgJ3R1cnF1b2lzZSc6ICcjNDBlMGQwJyxcbiAgICAndmlvbGV0JzogJyNlZTgyZWUnLFxuICAgICd3aGVhdCc6ICcjZjVkZWIzJyxcbiAgICAnd2hpdGUnOiAnI2ZmZmZmZicsXG4gICAgJ3doaXRlc21va2UnOiAnI2Y1ZjVmNScsXG4gICAgJ3llbGxvdyc6ICcjZmZmZjAwJyxcbiAgICAneWVsbG93Z3JlZW4nOiAnIzlhY2QzMidcbn07XG5cbnZhciBjb2xvcnV0aWwgPSB7XG4gICAgLyoqXG4gICAgICogcGFkIGxlZnQgemVybyBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgbnVtYmVyIHZhbHVlIHRvIHBhZCB6ZXJvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggcGFkIGxlbmd0aCB0byB3YW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBhZGRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgbGVhZGluZ1plcm86IGZ1bmN0aW9uKG51bWJlciwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB6ZXJvID0gJycsXG4gICAgICAgICAgICBpID0gMDtcblxuICAgICAgICBpZiAoU3RyaW5nKG51bWJlcikubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKG51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IChsZW5ndGggLSAxKTsgaSArPSAxKSB7XG4gICAgICAgICAgICB6ZXJvICs9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoemVybyArIG51bWJlcikuc2xpY2UobGVuZ3RoICogLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB2YWxpZGF0ZSBvZiBoZXggc3RyaW5nIHZhbHVlIGlzIFJHQlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSByZ2IgaGV4IHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm4gdHJ1ZSB3aGVuIHN1cHBsaWVkIHN0ciBpcyB2YWxpZCBSR0IgaGV4IHN0cmluZ1xuICAgICAqL1xuICAgIGlzVmFsaWRSR0I6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICByZXR1cm4gaGV4UlgudGVzdChzdHIpO1xuICAgIH0sXG5cbiAgICAvLyBAbGljZW5zZSBSR0IgPC0+IEhTViBjb252ZXJzaW9uIHV0aWxpdGllcyBiYXNlZCBvZmYgb2YgaHR0cDovL3d3dy5jcy5yaXQuZWR1L35uY3MvY29sb3IvdF9jb252ZXJ0Lmh0bWxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgY29sb3IgaGV4IHN0cmluZyB0byByZ2IgbnVtYmVyIGFycmF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciAtIGhleCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IHJnYiBudW1iZXJzXG4gICAgICovXG4gICAgaGV4VG9SR0I6IGZ1bmN0aW9uKGhleFN0cikge1xuICAgICAgICB2YXIgciwgZywgYjtcblxuICAgICAgICBpZiAoIWNvbG9ydXRpbC5pc1ZhbGlkUkdCKGhleFN0cikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhleFN0ciA9IGhleFN0ci5zdWJzdHJpbmcoMSk7XG5cbiAgICAgICAgciA9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoMCwgMiksIDE2KTtcbiAgICAgICAgZyA9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoMiwgMiksIDE2KTtcbiAgICAgICAgYiA9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoNCwgMiksIDE2KTtcblxuICAgICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHJnYiBudW1iZXIgdG8gaGV4IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIC0gcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGcgLSBncmVlblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gYmx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8Ym9vbGVhbn0gcmV0dXJuIGZhbHNlIHdoZW4gc3VwcGxpZWQgcmdiIG51bWJlciBpcyBub3QgdmFsaWQuIG90aGVyd2lzZSwgY29udmVydGVkIGhleCBzdHJpbmdcbiAgICAgKi9cbiAgICByZ2JUb0hFWDogZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgICB2YXIgaGV4U3RyID0gJyMnICtcbiAgICAgICAgICAgIGNvbG9ydXRpbC5sZWFkaW5nWmVybyhyLnRvU3RyaW5nKDE2KSwgMikgK1xuICAgICAgICAgICAgY29sb3J1dGlsLmxlYWRpbmdaZXJvKGcudG9TdHJpbmcoMTYpLCAyKSArXG4gICAgICAgICAgICBjb2xvcnV0aWwubGVhZGluZ1plcm8oYi50b1N0cmluZygxNiksIDIpO1xuXG4gICAgICAgIGlmIChjb2xvcnV0aWwuaXNWYWxpZFJHQihoZXhTdHIpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4U3RyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBuYW1lIHRvIGhleC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JOYW1lIGNvbG9yIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBoZXhcbiAgICAgKi9cbiAgICBjb2xvck5hbWVUb0hleDogZnVuY3Rpb24oY29sb3JOYW1lKSB7XG4gICAgICAgIHJldHVybiBjb2xvck1hcFtjb2xvck5hbWUudG9Mb3dlckNhc2UoKV0gfHwgY29sb3JOYW1lO1xuICAgIH1cbn07XG5cbnR1aS51dGlsLmRlZmluZU5hbWVzcGFjZSgndHVpLmNoYXJ0Jyk7XG50dWkuY2hhcnQuY29sb3J1dGlsID0gY29sb3J1dGlsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbG9ydXRpbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBET00gSGFuZGxlci5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIERPTSBIYW5kbGVyLlxuICogQG1vZHVsZSBkb21IYW5kbGVyXG4gKi9cbnZhciBkb21IYW5kbGVyID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBlbGVtZW50LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgaHRtbCB0YWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q2xhc3MgY2xhc3MgbmFtZVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gY3JlYXRlZCBlbGVtZW50XG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbih0YWcsIG5ld0NsYXNzKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcblxuICAgICAgICBpZiAobmV3Q2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoZWwsIG5ld0NsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNsYXNzIG5hbWVzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHJldHVybnMge0FycmF5fSBuYW1lc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENsYXNzTmFtZXM6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUsIGNsYXNzTmFtZXM7XG5cbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcyA9IGFwcy5jYWxsKGVsLmNsYXNzTGlzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBlbC5jbGFzc05hbWUgfHwgJyc7XG4gICAgICAgICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lICYmIHR1aS51dGlsLmlzU3RyaW5nKGNsYXNzTmFtZSkgPyBjbGFzc05hbWUuc3BsaXQoJyAnKSA6IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjc3MgY2xhc3MgdG8gdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkb21IYW5kbGVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q2xhc3MgYWRkIGNsYXNzIG5hbWVcbiAgICAgKi9cbiAgICBhZGRDbGFzczogZnVuY3Rpb24oZWwsIG5ld0NsYXNzKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWVzLCBpbmRleDtcblxuICAgICAgICBpZiAoIWVsIHx8ICFuZXdDbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xhc3NOYW1lcyA9IHRoaXMuX2dldENsYXNzTmFtZXMoZWwpO1xuICAgICAgICBpbmRleCA9IHR1aS51dGlsLmluQXJyYXkobmV3Q2xhc3MsIGNsYXNzTmFtZXMpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzLnB1c2gobmV3Q2xhc3MpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNzcyBjbGFzcyBmcm9tIHRhcmdldCBlbGVtZW50LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJtQ2xhc3MgcmVtb3ZlIGNsYXNzIG5hbWVcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWwsIHJtQ2xhc3MpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSB0aGlzLl9nZXRDbGFzc05hbWVzKGVsKSxcbiAgICAgICAgICAgIGluZGV4ID0gdHVpLnV0aWwuaW5BcnJheShybUNsYXNzLCBjbGFzc05hbWVzKTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNsYXNzIGV4aXN0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRvbUhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaW5kQ2xhc3MgdGFyZ2V0IGNzcyBjbGFzc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBoYXMgY2xhc3NcbiAgICAgKi9cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oZWwsIGZpbmRDbGFzcykge1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IHRoaXMuX2dldENsYXNzTmFtZXMoZWwpO1xuICAgICAgICB2YXIgaW5kZXggPSB0dWkudXRpbC5pbkFycmF5KGZpbmRDbGFzcywgY2xhc3NOYW1lcyk7XG5cbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgcGFyZW50IGJ5IGNsYXNzIG5hbWUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkb21IYW5kbGVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRhcmdldCBjc3MgY2xhc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFzdENsYXNzIGxhc3QgY3NzIGNsYXNzXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSByZXN1bHQgZWxlbWVudFxuICAgICAqL1xuICAgIGZpbmRQYXJlbnRCeUNsYXNzOiBmdW5jdGlvbihlbCwgY2xhc3NOYW1lLCBsYXN0Q2xhc3MpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGUsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNDbGFzcyhwYXJlbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudDtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJyB8fCB0aGlzLmhhc0NsYXNzKHBhcmVudCwgbGFzdENsYXNzKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmluZFBhcmVudEJ5Q2xhc3MocGFyZW50LCBjbGFzc05hbWUsIGxhc3RDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgY2hpbGQgZWxlbWVudC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRvbUhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjaGlsZHJlbiBjaGlsZCBlbGVtZW50XG4gICAgICovXG4gICAgYXBwZW5kOiBmdW5jdGlvbihjb250YWluZXIsIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyIHx8ICFjaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuID0gdHVpLnV0aWwuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbiA6IFtjaGlsZHJlbl07XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tSGFuZGxlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBFdmVudCBsaXN0ZW5lci5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZEhhbmRsZXJNYXAgPSB7fTtcblxuLyoqXG4gKiBFdmVudCBsaXN0ZW5lci5cbiAqIEBtb2R1bGUgZXZlbnRMaXN0ZW5lclxuICovXG52YXIgZXZlbnRMaXN0ZW5lciA9IHtcbiAgICAvKipcbiAgICAgKiBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIElFLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IGNvbnRleHQgZm9yIGNhbGxiYWNrXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICB2YXIgYmluZEhhbmRsZXI7XG5cbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGJpbmRIYW5kbGVyID0gdHVpLnV0aWwuYmluZChoYW5kbGVyLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJpbmRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmRIYW5kbGVyTWFwW3R5cGUgKyBoYW5kbGVyXSA9IGJpbmRIYW5kbGVyO1xuICAgICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGJpbmRIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGV2ZW50IGxpc3RlbmVyIGZvciBvdGhlciBicm93c2Vycy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIGNvbnRleHQgZm9yIGhhbmRsZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGJpbmRIYW5kbGVyO1xuXG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICBiaW5kSGFuZGxlciA9IHR1aS51dGlsLmJpbmQoaGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaW5kSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIH1cblxuICAgICAgICBiaW5kSGFuZGxlck1hcFt0eXBlICsgaGFuZGxlcl0gPSBiaW5kSGFuZGxlcjtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgYmluZEhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kIERPTSBldmVudC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmV2ZW50TGlzdGVuZXJcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIGNvbnRleHQgZm9yIGhhbmRsZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9iaW5kRXZlbnQ6IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICB2YXIgYmluZEV2ZW50O1xuXG4gICAgICAgIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICBiaW5kRXZlbnQgPSB0aGlzLl9hZGRFdmVudExpc3RlbmVyO1xuICAgICAgICB9IGVsc2UgaWYgKCdhdHRhY2hFdmVudCcgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICBiaW5kRXZlbnQgPSB0aGlzLl9hdHRhY2hFdmVudDtcbiAgICAgICAgfVxuICAgICAgICBldmVudExpc3RlbmVyLl9iaW5kRXZlbnQgPSBiaW5kRXZlbnQ7XG5cbiAgICAgICAgYmluZEV2ZW50KHRhcmdldCwgdHlwZSwgaGFuZGxlciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJpbmQgRE9NIGV2ZW50cy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgb2JqZWN0fSB0eXBlcyAtIHR5cGUgb3IgbWFwIG9mIHR5cGUgYW5kIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uIHwgb2JqZWN0fSBbaGFuZGxlcl0gLSBoYW5kbGVyIG9yIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gY29udGV4dFxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbih0YXJnZXQsIHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBoYW5kbGVyTWFwID0ge307XG4gICAgICAgIGlmICh0dWkudXRpbC5pc1N0cmluZyh0eXBlcykpIHtcbiAgICAgICAgICAgIGhhbmRsZXJNYXBbdHlwZXNdID0gaGFuZGxlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZXJNYXAgPSB0eXBlcztcbiAgICAgICAgICAgIGNvbnRleHQgPSBoYW5kbGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChoYW5kbGVyTWFwLCBmdW5jdGlvbihfaGFuZGxlciwgdHlwZSkge1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lci5fYmluZEV2ZW50KHRhcmdldCwgdHlwZSwgX2hhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZvciBJRS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBoYW5kbGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoYmluZEhhbmRsZXJNYXBbdHlwZSArIGhhbmRsZXJdKSB7XG4gICAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGJpbmRIYW5kbGVyTWFwW3R5cGUgKyBoYW5kbGVyXSk7XG4gICAgICAgICAgICBkZWxldGUgYmluZEhhbmRsZXJNYXBbdHlwZSArIGhhbmRsZXJdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBldmVudCBsaXN0ZW5lciBmb3Igb3RoZXIgYnJvd3NlcnMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpldmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gaGFuZGxlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgaGFuZGxlcikge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBiaW5kSGFuZGxlck1hcFt0eXBlICsgaGFuZGxlcl0pO1xuICAgICAgICBkZWxldGUgYmluZEhhbmRsZXJNYXBbdHlwZSArIGhhbmRsZXJdO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFVuYmluZCBET00gZXZlbnQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpldmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gaGFuZGxlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VuYmluZEV2ZW50OiBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHVuYmluZEV2ZW50O1xuICAgICAgICBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIHRhcmdldCkge1xuICAgICAgICAgICAgdW5iaW5kRXZlbnQgPSBldmVudExpc3RlbmVyLl9yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgICAgICB9IGVsc2UgaWYgKCdkZXRhY2hFdmVudCcgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICB1bmJpbmRFdmVudCA9IGV2ZW50TGlzdGVuZXIuX2RldGFjaEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuX3VuYmluZEV2ZW50ID0gdW5iaW5kRXZlbnQ7XG5cbiAgICAgICAgdW5iaW5kRXZlbnQodGFyZ2V0LCB0eXBlLCBoYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kIERPTSBldmVudHMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpldmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG9iamVjdH0gdHlwZXMgLSB0eXBlIG9yIG1hcCBvZiB0eXBlIGFuZCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXJdIC0gaGFuZGxlclxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24odGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlck1hcCA9IHt9O1xuICAgICAgICBpZiAodHVpLnV0aWwuaXNTdHJpbmcodHlwZXMpKSB7XG4gICAgICAgICAgICBoYW5kbGVyTWFwW3R5cGVzXSA9IGhhbmRsZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVyTWFwID0gdHlwZXM7XG4gICAgICAgIH1cblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGhhbmRsZXJNYXAsIGZ1bmN0aW9uKF9oYW5kbGVyLCB0eXBlKSB7XG4gICAgICAgICAgICBldmVudExpc3RlbmVyLl91bmJpbmRFdmVudCh0YXJnZXQsIHR5cGUsIF9oYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBldmVudExpc3RlbmVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFByZWRpY2F0ZS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogcHJlZGljYXRlLlxuICogQG1vZHVsZSBwcmVkaWNhdGVcbiAqL1xudmFyIHByZWRpY2F0ZSA9IHtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGJhciBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQmFyQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gY2hhcnRUeXBlID09PSBjaGFydENvbnN0LkNIQVJUX1RZUEVfQkFSO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNvbHVtbiBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ29sdW1uQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gY2hhcnRUeXBlID09PSBjaGFydENvbnN0LkNIQVJUX1RZUEVfQ09MVU1OO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGJhciB0eXBlIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSB0eXBlIG9mIGNoYXJ0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNCYXJUeXBlQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlLmlzQmFyQ2hhcnQoY2hhcnRUeXBlKSB8fCBwcmVkaWNhdGUuaXNDb2x1bW5DaGFydChjaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNvbWJvIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSB0eXBlIG9mIGNoYXJ0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDb21ib0NoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJ0VHlwZSA9PT0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0NPTUJPO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHBpZSBhbmQgZG9udXQgY29tYm8gY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIHR5cGUgb2YgY2hhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzdWJDaGFydFR5cGVzIC0gdHlwZXMgb2YgY2hhcnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1BpZURvbnV0Q29tYm9DaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlLCBzdWJDaGFydFR5cGVzKSB7XG4gICAgICAgIHZhciBpc0FsbFBpZVR5cGUgPSB0dWkudXRpbC5hbGwoc3ViQ2hhcnRUeXBlcywgZnVuY3Rpb24oc3ViQ2hhcnRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmlzUGllVHlwZUNoYXJ0KHN1YkNoYXJ0VHlwZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUuaXNDb21ib0NoYXJ0KGNoYXJ0VHlwZSkgJiYgaXNBbGxQaWVUeXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGxpbmUgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIHR5cGUgb2YgY2hhcnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0xpbmVDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9MSU5FO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFyZWEgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIHR5cGUgb2YgY2hhcnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FyZWFDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9BUkVBO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGxpbmUgYW5kIGFyZWEgY29tYm8gY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIHR5cGUgb2YgY2hhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzdWJDaGFydFR5cGVzIC0gdHlwZXMgb2YgY2hhcnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0xpbmVBcmVhQ29tYm9DaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlLCBzdWJDaGFydFR5cGVzKSB7XG4gICAgICAgIHZhciBpc0FsbExpbmVUeXBlID0gdHVpLnV0aWwuYWxsKHN1YkNoYXJ0VHlwZXMgfHwgW10sIGZ1bmN0aW9uKHN1YkNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5pc0xpbmVDaGFydChzdWJDaGFydFR5cGUpIHx8IHByZWRpY2F0ZS5pc0FyZWFDaGFydChzdWJDaGFydFR5cGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJlZGljYXRlLmlzQ29tYm9DaGFydChjaGFydFR5cGUpICYmIGlzQWxsTGluZVR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgbGluZSB0eXBlIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSB0eXBlIG9mIGNoYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW3N1YkNoYXJ0VHlwZXNdIC0gdHlwZXMgb2YgY2hhcnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0xpbmVUeXBlQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgc3ViQ2hhcnRUeXBlcykge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlLmlzTGluZUNoYXJ0KGNoYXJ0VHlwZSkgfHwgcHJlZGljYXRlLmlzQXJlYUNoYXJ0KGNoYXJ0VHlwZSlcbiAgICAgICAgICAgIHx8IHByZWRpY2F0ZS5pc0xpbmVBcmVhQ29tYm9DaGFydChjaGFydFR5cGUsIHN1YkNoYXJ0VHlwZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGJ1YmJsZSBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQnViYmxlQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gY2hhcnRUeXBlID09PSBjaGFydENvbnN0LkNIQVJUX1RZUEVfQlVCQkxFO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHNjYXR0ZXIgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1NjYXR0ZXJDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9TQ0FUVEVSO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGhlYXRtYXAgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0hlYXRtYXBDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9IRUFUTUFQO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRyZWVtYXAgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RyZWVtYXBDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9UUkVFTUFQO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGJveCB0eXBlIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNCb3hUeXBlQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlLmlzSGVhdG1hcENoYXJ0KGNoYXJ0VHlwZSkgfHwgcHJlZGljYXRlLmlzVHJlZW1hcENoYXJ0KGNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcGllIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQaWVDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9QSUU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZG9udXQgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRG9udXRDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9ET05VVDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBwaWUgdHlwZSBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUGllVHlwZUNoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5pc1BpZUNoYXJ0KGNoYXJ0VHlwZSkgfHwgcHJlZGljYXRlLmlzRG9udXRDaGFydChjaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG1hcCBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTWFwQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gY2hhcnRUeXBlID09PSBjaGFydENvbnN0LkNIQVJUX1RZUEVfTUFQO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNvb3JkaW5hdGUgdHlwZSBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ29vcmRpbmF0ZVR5cGVDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUuaXNCdWJibGVDaGFydChjaGFydFR5cGUpIHx8IHByZWRpY2F0ZS5pc1NjYXR0ZXJDaGFydChjaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFsbG93IHJlbmRlcmluZyBmb3IgbWludXMgcG9pbnQgaW4gYXJlYSBvZiBzZXJpZXMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGFsbG93TWludXNQb2ludFJlbmRlcjogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUuaXNMaW5lVHlwZUNoYXJ0KGNoYXJ0VHlwZSkgfHwgcHJlZGljYXRlLmlzQ29vcmRpbmF0ZVR5cGVDaGFydChjaGFydFR5cGUpIHx8XG4gICAgICAgICAgICBwcmVkaWNhdGUuaXNCb3hUeXBlQ2hhcnQoY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBtb3VzZSBwb3NpdGlvbiBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTW91c2VQb3NpdGlvbkNoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5pc1BpZVR5cGVDaGFydChjaGFydFR5cGUpIHx8IHByZWRpY2F0ZS5pc01hcENoYXJ0KGNoYXJ0VHlwZSlcbiAgICAgICAgICAgIHx8IHByZWRpY2F0ZS5pc0Nvb3JkaW5hdGVUeXBlQ2hhcnQoY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhbGlnbiBvZiBsYWJlbCBpcyBvdXRlciBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gLSBhbGlnbiBvZiBsZWdlbmRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0xhYmVsQWxpZ25PdXRlcjogZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgICAgcmV0dXJuIGFsaWduID09PSBjaGFydENvbnN0LkxBQkVMX0FMSUdOX09VVEVSO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHNob3cgbGFiZWwgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7e3Nob3dMYWJlbDogP2Jvb2xlYW4sIHNob3dMZWdlbmQ6ID9ib29sZWFufX0gb3B0aW9ucyAtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1Nob3dMYWJlbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5zaG93TGFiZWwgfHwgb3B0aW9ucy5zaG93TGVnZW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHNob3cgb3V0ZXIgbGFiZWwgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7e3Nob3dMYWJlbDogP2Jvb2xlYW4sIHNob3dMZWdlbmQ6ID9ib29sZWFuLCBsYWJlbEFsaWduOiBzdHJpbmd9fSBvcHRpb25zIC0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW59XG4gICAgICovXG4gICAgaXNTaG93T3V0ZXJMYWJlbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlLmlzU2hvd0xhYmVsKG9wdGlvbnMpICYmIHByZWRpY2F0ZS5pc0xhYmVsQWxpZ25PdXRlcihvcHRpb25zLmxhYmVsQWxpZ24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFsaWduIG9mIGxlZ2VuZCBpcyBsZWZ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbiAtIGFsaWduIG9mIGxlZ2VuZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTGVnZW5kQWxpZ25MZWZ0OiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICByZXR1cm4gYWxpZ24gPT09IGNoYXJ0Q29uc3QuTEVHRU5EX0FMSUdOX0xFRlQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYWxpZ24gb2YgbGVnZW5kIGlzIHRvcCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gLSBhbGlnbiBvZiBsZWdlbmRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0xlZ2VuZEFsaWduVG9wOiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICByZXR1cm4gYWxpZ24gPT09IGNoYXJ0Q29uc3QuTEVHRU5EX0FMSUdOX1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhbGlnbiBvZiBsZWdlbmQgaXMgYm90dG9tIG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbiAtIGFsaWduIG9mIGxlZ2VuZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTGVnZW5kQWxpZ25Cb3R0b206IGZ1bmN0aW9uKGFsaWduKSB7XG4gICAgICAgIHJldHVybiBhbGlnbiA9PT0gY2hhcnRDb25zdC5MRUdFTkRfQUxJR05fQk9UVE9NO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGhvcml6b250YWwgbGVnZW5kIGFsaWduIG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbiAtIGFsaWduIG9mIGxlZ2VuZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzSG9yaXpvbnRhbExlZ2VuZDogZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5pc0xlZ2VuZEFsaWduVG9wKGFsaWduKSB8fCBwcmVkaWNhdGUuaXNMZWdlbmRBbGlnbkJvdHRvbShhbGlnbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaGFzIHdpZHRoIGZvciB2ZXJ0aWNhbCB0eXBlIGxlZ2VuZCBvciBub3QuXG4gICAgICogQHBhcmFtIHt7YWxpZ246IHN0cmluZywgdmlzaWJsZTogYm9vbGVhbn19IGxlZ2VuZE9wdGlvbiAtIG9wdGlvbiBmb3IgbGVnZW5kIGNvbXBvbmVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1ZlcnRpY2FsTGVnZW5kV2lkdGg6IGZ1bmN0aW9uKGxlZ2VuZE9wdGlvbikge1xuICAgICAgICBsZWdlbmRPcHRpb24gPSBsZWdlbmRPcHRpb24gfHwge307XG5cbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuaXNIb3Jpem9udGFsTGVnZW5kKGxlZ2VuZE9wdGlvbi5hbGlnbikgJiYgbGVnZW5kT3B0aW9uLnZpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYWxsb3dlZCBzdGFja1R5cGUgb3B0aW9uIG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSB0eXBlIG9mIGNoYXJ0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNBbGxvd2VkU3RhY2tPcHRpb246IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlLmlzQmFyQ2hhcnQoY2hhcnRUeXBlKSB8fCBwcmVkaWNhdGUuaXNDb2x1bW5DaGFydChjaGFydFR5cGUpXG4gICAgICAgICAgICB8fCBwcmVkaWNhdGUuaXNBcmVhQ2hhcnQoY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBub3JtYWwgc3RhY2sgdHlwZSBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrVHlwZSAtIHN0YWNrVHlwZSBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc05vcm1hbFN0YWNrOiBmdW5jdGlvbihzdGFja1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrVHlwZSA9PT0gY2hhcnRDb25zdC5OT1JNQUxfU1RBQ0tfVFlQRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBwZXJjZW50IHN0YWNrIHR5cGUgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja1R5cGUgLSBzdGFja1R5cGUgb3B0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQZXJjZW50U3RhY2s6IGZ1bmN0aW9uKHN0YWNrVHlwZSkge1xuICAgICAgICByZXR1cm4gc3RhY2tUeXBlID09PSBjaGFydENvbnN0LlBFUkNFTlRfU1RBQ0tfVFlQRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB2YWxpZCBzdGFja1R5cGUgb3B0aW9uIG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2tUeXBlIC0gc3RhY2tUeXBlIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVmFsaWRTdGFja09wdGlvbjogZnVuY3Rpb24oc3RhY2tUeXBlKSB7XG4gICAgICAgIHJldHVybiBzdGFja1R5cGUgJiYgKHByZWRpY2F0ZS5pc05vcm1hbFN0YWNrKHN0YWNrVHlwZSkgfHwgcHJlZGljYXRlLmlzUGVyY2VudFN0YWNrKHN0YWNrVHlwZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFsbG93IHJhbmdlIGRhdGEgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSAtIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FsbG93UmFuZ2VEYXRhOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5pc0JhclR5cGVDaGFydChjaGFydFR5cGUpIHx8IHByZWRpY2F0ZS5pc0FyZWFDaGFydChjaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFsaWduIG9mIHlBeGlzIGlzIGNlbnRlciBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1JpZ2h0WUF4aXMgLSB3aGV0aGVyIGhhcyByaWdodCB5QXhpcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ25PcHRpb24gLSBhbGlnbiBvcHRpb24gb2YgeUF4aXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgLSBhbGlnbiBjZW50ZXIgb3Igbm90LlxuICAgICAqL1xuICAgIGlzWUF4aXNBbGlnbkNlbnRlcjogZnVuY3Rpb24oaGFzUmlnaHRZQXhpcywgYWxpZ25PcHRpb24pIHtcbiAgICAgICAgcmV0dXJuICFoYXNSaWdodFlBeGlzICYmIChhbGlnbk9wdGlvbiA9PT0gY2hhcnRDb25zdC5ZQVhJU19BTElHTl9DRU5URVIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG1pbnVzIGxpbWl0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGxpbWl0IC0gbGltaXRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc01pbnVzTGltaXQ6IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHJldHVybiBsaW1pdC5taW4gPD0gMCAmJiBsaW1pdC5tYXggPD0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhdXRvIHRpY2sgaW50ZXJ2YWwgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGlja0ludGVydmFsXSAtIHRpY2sgaW50ZXJ2YWwgb3B0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNBdXRvVGlja0ludGVydmFsOiBmdW5jdGlvbih0aWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRpY2tJbnRlcnZhbCA9PT0gY2hhcnRDb25zdC5USUNLX0lOVEVSVkFMX0FVVE87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdmFsaWQgbGFiZWwgaW50ZXJ2YWwgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGFiZWxJbnRlcnZhbF0gLSBsYWJlbCBpbnRlcnZhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RpY2tJbnRlcnZhbF0gLSB0aWNrIGludGVydmFsIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW59XG4gICAgICovXG4gICAgaXNWYWxpZExhYmVsSW50ZXJ2YWw6IGZ1bmN0aW9uKGxhYmVsSW50ZXJ2YWwsIHRpY2tJbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gbGFiZWxJbnRlcnZhbCAmJiBsYWJlbEludGVydmFsID4gMSAmJiAhdGlja0ludGVydmFsO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlZGljYXRlO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhdyBkYXRhIGhhbmRsZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG4vKipcbiAqIFJhdyBkYXRhIEhhbmRsZXIuXG4gKiBAbW9kdWxlIHJhd0RhdGFIYW5kbGVyXG4gKi9cbnZhciByYXdEYXRhSGFuZGxlciA9IHtcbiAgICAvKipcbiAgICAgKiBQaWNrIHN0YWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7c3RhY2s6IHN0cmluZ30+fSBzZXJpZXNEYXRhIC0gcmF3IHNlcmllcyBkYXRhXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGl2ZXJnaW5nT3B0aW9uXSAtIGRpdmVyZ2luZyBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IHN0YWNrc1xuICAgICAqL1xuICAgIHBpY2tTdGFja3M6IGZ1bmN0aW9uKHNlcmllc0RhdGEsIGRpdmVyZ2luZ09wdGlvbikge1xuICAgICAgICB2YXIgc3RhY2tzLCB1bmlxU3RhY2tzLCBmaWx0ZXJlZFN0YWNrO1xuXG4gICAgICAgIHN0YWNrcyA9IHR1aS51dGlsLm1hcChzZXJpZXNEYXRhLCBmdW5jdGlvbihzZXJpZXNEYXR1bSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmllc0RhdHVtLnN0YWNrO1xuICAgICAgICB9KTtcblxuICAgICAgICB1bmlxU3RhY2tzID0gdHVpLnV0aWwudW5pcXVlKHN0YWNrcyk7XG5cbiAgICAgICAgaWYgKGRpdmVyZ2luZ09wdGlvbikge1xuICAgICAgICAgICAgdW5pcVN0YWNrcyA9IHVuaXFTdGFja3Muc2xpY2UoMCwgMik7XG4gICAgICAgIH1cblxuICAgICAgICBmaWx0ZXJlZFN0YWNrID0gdHVpLnV0aWwuZmlsdGVyKHVuaXFTdGFja3MsIGZ1bmN0aW9uKHN0YWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gISFzdGFjaztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGZpbHRlcmVkU3RhY2subGVuZ3RoIDwgdW5pcVN0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkU3RhY2sucHVzaChjaGFydENvbnN0LkRFRkFVTFRfU1RBQ0spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkU3RhY2s7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNvcnQgc2VyaWVzIGRhdGEgZnJvbSBzdGFja3MuXG4gICAgICogQHBhcmFtIHtBcnJheS48e3N0YWNrOiA/c3RyaW5nfT59IHNlcmllc0RhdGEgc2VyaWVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzdGFja3Mgc3RhY2tzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHNvcnRTZXJpZXNEYXRhOiBmdW5jdGlvbihzZXJpZXNEYXRhLCBzdGFja3MpIHtcbiAgICAgICAgdmFyIG5ld1Nlcmllc0RhdGEgPSBbXTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoc3RhY2tzLCBmdW5jdGlvbihzdGFjaykge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gdHVpLnV0aWwuZmlsdGVyKHNlcmllc0RhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkYXR1bS5zdGFjayB8fCBjaGFydENvbnN0LkRFRkFVTFRfU1RBQ0spID09PSBzdGFjaztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3U2VyaWVzRGF0YSA9IG5ld1Nlcmllc0RhdGEuY29uY2F0KGZpbHRlcmVkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1Nlcmllc0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBzdGFjayBvZiBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7c3RhY2s6ID9zdHJpbmd9Pn0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqL1xuICAgIHJlbW92ZVNlcmllc1N0YWNrOiBmdW5jdGlvbihzZXJpZXNEYXRhKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZXJpZXNEYXRhLCBmdW5jdGlvbihkYXR1bSkge1xuICAgICAgICAgICAgZGVsZXRlIGRhdHVtLnN0YWNrO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBjaGFyIHR5cGUgZnJvbSBjaGFydCBuYW1lLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IHNlcmllc0FsaWFzIC0gYWxpYXMgbWFwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmllc05hbWUgLSBzZXJpZXMgbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZpbmRDaGFydFR5cGU6IGZ1bmN0aW9uKHNlcmllc0FsaWFzLCBzZXJpZXNOYW1lKSB7XG4gICAgICAgIHZhciBjaGFydFR5cGU7XG5cbiAgICAgICAgaWYgKHNlcmllc0FsaWFzKSB7XG4gICAgICAgICAgICBjaGFydFR5cGUgPSBzZXJpZXNBbGlhc1tzZXJpZXNOYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgfHwgc2VyaWVzTmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNoYXJ0IHR5cGUgbWFwLlxuICAgICAqIEBwYXJhbSB7e3NlcmllczogKEFycmF5IHwgb2JqZWN0KX19IHJhd0RhdGEgLSByYXcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtvYmplY3QuPHN0cmluZywgc3RyaW5nPn1cbiAgICAgKi9cbiAgICBnZXRDaGFydFR5cGVNYXA6IGZ1bmN0aW9uKHJhd0RhdGEpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY2hhcnRUeXBlTWFwID0ge307XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzT2JqZWN0KHJhd0RhdGEuc2VyaWVzKSkge1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChyYXdEYXRhLnNlcmllcywgZnVuY3Rpb24oZGF0YSwgc2VyaWVzTmFtZSkge1xuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZU1hcFtzZWxmLmZpbmRDaGFydFR5cGUocmF3RGF0YS5zZXJpZXNBbGlhcywgc2VyaWVzTmFtZSldID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0VHlwZU1hcDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhd0RhdGFIYW5kbGVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWwgZm9yIHJlbmRlcmluZy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBuby1tYWdpYy1udW1iZXJzOiBbMSwge2lnbm9yZTogWy0xLCAwLCAxLCAyLCA3LCA4XX1dKi9cblxudmFyIGRvbSA9IHJlcXVpcmUoJy4vZG9tSGFuZGxlcicpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLy4uL2NvbnN0Jyk7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG52YXIgYnJvd3NlciA9IHR1aS51dGlsLmJyb3dzZXIsXG4gICAgaXNJRTcgPSBicm93c2VyLm1zaWUgJiYgYnJvd3Nlci52ZXJzaW9uID09PSA3LFxuICAgIGlzT2xkQnJvd3NlciA9IGJyb3dzZXIubXNpZSAmJiBicm93c2VyLnZlcnNpb24gPD0gODtcblxuLyoqXG4gKiBVdGlsIGZvciByZW5kZXJpbmcuXG4gKiBAbW9kdWxlIHJlbmRlclV0aWxcbiAqL1xudmFyIHJlbmRlclV0aWwgPSB7XG4gICAgLyoqXG4gICAgICogQ29uY2F0IHN0cmluZy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW1zIHsuLi5zdHJpbmd9IHRhcmdldCBzdHJpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY29uY2F0IHN0cmluZ1xuICAgICAqL1xuICAgIGNvbmNhdFN0cjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmNvbmNhdC5hcHBseSgnJywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjc3NUZXh0IGZvciBmb250LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGZvbnQgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjc3NUZXh0XG4gICAgICovXG4gICAgbWFrZUZvbnRDc3NUZXh0OiBmdW5jdGlvbih0aGVtZSkge1xuICAgICAgICB2YXIgY3NzVGV4dHMgPSBbXTtcblxuICAgICAgICBpZiAoIXRoZW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhlbWUuZm9udFNpemUpIHtcbiAgICAgICAgICAgIGNzc1RleHRzLnB1c2godGhpcy5jb25jYXRTdHIoJ2ZvbnQtc2l6ZTonLCB0aGVtZS5mb250U2l6ZSwgJ3B4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoZW1lLmZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgIGNzc1RleHRzLnB1c2godGhpcy5jb25jYXRTdHIoJ2ZvbnQtZmFtaWx5OicsIHRoZW1lLmZvbnRGYW1pbHkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGVtZS5jb2xvcikge1xuICAgICAgICAgICAgY3NzVGV4dHMucHVzaCh0aGlzLmNvbmNhdFN0cignY29sb3I6JywgdGhlbWUuY29sb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjc3NUZXh0cy5qb2luKCc7Jyk7XG4gICAgfSxcblxuICAgIGNoZWNrRWw6IG51bGwsXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVsZW1lbnQgZm9yIHNpemUgY2hlY2suXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlU2l6ZUNoZWNrRWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGl2LCBzcGFuO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tFbCkge1xuICAgICAgICAgICAgZGl2ID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1zaXplLWNoZWNrLWVsZW1lbnQnKTtcbiAgICAgICAgICAgIHNwYW4gPSBkb20uY3JlYXRlKCdTUEFOJyk7XG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRWwgPSBkaXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRWwuc3R5bGUuY3NzVGV4dCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjYWNoaW5nIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgbGFiZWtcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmd9fSB0aGVtZSB0aGVtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvZmZzZXRUeXBlIG9mZnNldCB0eXBlIChvZmZzZXRXaWR0aCBvciBvZmZzZXRIZWlnaHQpXG4gICAgICogQHJldHVybnMge3N0cmluZ30ga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNhY2hpbmdLZXk6IGZ1bmN0aW9uKGxhYmVsLCB0aGVtZSwgb2Zmc2V0VHlwZSkge1xuICAgICAgICB2YXIga2V5cyA9IFtsYWJlbCwgb2Zmc2V0VHlwZV07XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh0aGVtZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSArIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGtleXMuam9pbignLScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaXplIGNhY2hlLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgc2l6ZUNhY2hlOiB7fSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjc3Mgc3R5bGUuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGl2IGRpdiBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogc3RyaW5nLCBjc3NUZXh0OiBzdHJpbmd9fSB0aGVtZSB0aGVtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENzc1N0eWxlOiBmdW5jdGlvbihkaXYsIHRoZW1lKSB7XG4gICAgICAgIGRpdi5zdHlsZS5mb250U2l6ZSA9ICh0aGVtZS5mb250U2l6ZSB8fCBjaGFydENvbnN0LkRFRkFVTFRfTEFCRUxfRk9OVF9TSVpFKSArICdweCc7XG5cbiAgICAgICAgaWYgKHRoZW1lLmZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5mb250RmFtaWx5ID0gdGhlbWUuZm9udEZhbWlseTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGVtZS5jc3NUZXh0KSB7XG4gICAgICAgICAgICBkaXYuc3R5bGUuY3NzVGV4dCArPSB0aGVtZS5jc3NUZXh0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZW5kZXJlZCBsYWJlbCBzaXplICh3aWR0aCBvciBoZWlnaHQpLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBsYWJlbCBsYWJlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvZmZzZXRUeXBlIG9mZnNldCB0eXBlIChvZmZzZXRXaWR0aCBvciBvZmZzZXRIZWlnaHQpXG4gICAgICogQHJldHVybnMge251bWJlcn0gc2l6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFJlbmRlcmVkTGFiZWxTaXplOiBmdW5jdGlvbihsYWJlbCwgdGhlbWUsIG9mZnNldFR5cGUpIHtcbiAgICAgICAgdmFyIGtleSwgZGl2LCBzcGFuLCBsYWJlbFNpemU7XG5cbiAgICAgICAgdGhlbWUgPSB0aGVtZSB8fCB7fTtcblxuICAgICAgICBsYWJlbCA9IHR1aS51dGlsLmlzRXhpc3R5KGxhYmVsKSA/IFN0cmluZyhsYWJlbCkgOiAnJztcblxuICAgICAgICBpZiAoIWxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IHRoaXMuX21ha2VDYWNoaW5nS2V5KGxhYmVsLCB0aGVtZSwgb2Zmc2V0VHlwZSk7XG4gICAgICAgIGxhYmVsU2l6ZSA9IHRoaXMuc2l6ZUNhY2hlW2tleV07XG5cbiAgICAgICAgaWYgKCFsYWJlbFNpemUpIHtcbiAgICAgICAgICAgIGRpdiA9IHRoaXMuX2NyZWF0ZVNpemVDaGVja0VsKCk7XG4gICAgICAgICAgICBzcGFuID0gZGl2LmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gbGFiZWw7XG5cbiAgICAgICAgICAgIHRoaXMuX2FkZENzc1N0eWxlKGRpdiwgdGhlbWUpO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICBsYWJlbFNpemUgPSBzcGFuW29mZnNldFR5cGVdO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuXG4gICAgICAgICAgICB0aGlzLnNpemVDYWNoZVtrZXldID0gbGFiZWxTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsU2l6ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlbmRlcmVkIGxhYmVsIHdpZHRoLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBsYWJlbFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gd2lkdGhcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZExhYmVsV2lkdGg6IGZ1bmN0aW9uKGxhYmVsLCB0aGVtZSkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHRoaXMuX2dldFJlbmRlcmVkTGFiZWxTaXplKGxhYmVsLCB0aGVtZSwgJ29mZnNldFdpZHRoJyk7XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsV2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZW5kZXJlZCBsYWJlbCBoZWlnaHQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIGxhYmVsXG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogc3RyaW5nLCBjb2xvcjogc3RyaW5nfX0gdGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZExhYmVsSGVpZ2h0OiBmdW5jdGlvbihsYWJlbCwgdGhlbWUpIHtcbiAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gdGhpcy5fZ2V0UmVuZGVyZWRMYWJlbFNpemUobGFiZWwsIHRoZW1lLCAnb2Zmc2V0SGVpZ2h0Jyk7XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsSGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgUmVuZGVyZWQgTGFiZWxzIE1heCBTaXplKHdpZHRoIG9yIGhlaWdodCkuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpib3VuZHNNYWtlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGxhYmVscyBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmcsIGNvbG9yOiBzdHJpbmd9fSB0aGVtZSBsYWJlbCB0aGVtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIGl0ZXJhdGVlXG4gICAgICogQHJldHVybnMge251bWJlcn0gbWF4IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRSZW5kZXJlZExhYmVsc01heFNpemU6IGZ1bmN0aW9uKGxhYmVscywgdGhlbWUsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBtYXhTaXplID0gMCxcbiAgICAgICAgICAgIHNpemVzO1xuXG4gICAgICAgIGlmIChsYWJlbHMgJiYgbGFiZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2l6ZXMgPSB0dWkudXRpbC5tYXAobGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRlZShsYWJlbCwgdGhlbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtYXhTaXplID0gdHVpLnV0aWwubWF4KHNpemVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXhTaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVuZGVyZWQgbGFiZWxzIG1heCB3aWR0aC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmJvdW5kc01ha2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gbWF4IHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZExhYmVsc01heFdpZHRoOiBmdW5jdGlvbihsYWJlbHMsIHRoZW1lKSB7XG4gICAgICAgIHZhciBpdGVyYXRlZSA9IHR1aS51dGlsLmJpbmQodGhpcy5nZXRSZW5kZXJlZExhYmVsV2lkdGgsIHRoaXMpO1xuICAgICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLl9nZXRSZW5kZXJlZExhYmVsc01heFNpemUobGFiZWxzLCB0aGVtZSwgaXRlcmF0ZWUpO1xuXG4gICAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlbmRlcmVkIGxhYmVscyBtYXggaGVpZ2h0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Ym91bmRzTWFrZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBsYWJlbHMgbGFiZWxzXG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogc3RyaW5nLCBjb2xvcjogc3RyaW5nfX0gdGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBtYXggaGVpZ2h0XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRMYWJlbHNNYXhIZWlnaHQ6IGZ1bmN0aW9uKGxhYmVscywgdGhlbWUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdGVlID0gdHVpLnV0aWwuYmluZCh0aGlzLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQsIHRoaXMpO1xuICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy5fZ2V0UmVuZGVyZWRMYWJlbHNNYXhTaXplKGxhYmVscywgdGhlbWUsIGl0ZXJhdGVlKTtcblxuICAgICAgICByZXR1cm4gbWF4SGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZGltZW5zaW9uLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICovXG4gICAgcmVuZGVyRGltZW5zaW9uOiBmdW5jdGlvbihlbCwgZGltZW5zaW9uKSB7XG4gICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBbXG4gICAgICAgICAgICB0aGlzLmNvbmNhdFN0cignd2lkdGg6JywgZGltZW5zaW9uLndpZHRoLCAncHgnKSxcbiAgICAgICAgICAgIHRoaXMuY29uY2F0U3RyKCdoZWlnaHQ6JywgZGltZW5zaW9uLmhlaWdodCwgJ3B4JylcbiAgICAgICAgXS5qb2luKCc7Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBwb3NpdGlvbih0b3AsIHJpZ2h0KS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqL1xuICAgIHJlbmRlclBvc2l0aW9uOiBmdW5jdGlvbihlbCwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHR1aS51dGlsLmlzVW5kZWZpbmVkKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc1VuZGVmaW5lZChwb3NpdGlvbi50b3ApKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS50b3AgPSBwb3NpdGlvbi50b3AgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc1VuZGVmaW5lZChwb3NpdGlvbi5sZWZ0KSkge1xuICAgICAgICAgICAgZWwuc3R5bGUubGVmdCA9IHBvc2l0aW9uLmxlZnQgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc1VuZGVmaW5lZChwb3NpdGlvbi5yaWdodCkpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLnJpZ2h0ID0gcG9zaXRpb24ucmlnaHQgKyAncHgnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBiYWNrZ3JvdW5kLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmQgYmFja2dyb3VuZCBvcHRpb25cbiAgICAgKi9cbiAgICByZW5kZXJCYWNrZ3JvdW5kOiBmdW5jdGlvbihlbCwgYmFja2dyb3VuZCkge1xuICAgICAgICBpZiAoIWJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZm9udCBmYW1pbHkuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udEZhbWlseSBmb250IGZhbWlseSBvcHRpb25cbiAgICAgKi9cbiAgICByZW5kZXJGb250RmFtaWx5OiBmdW5jdGlvbihlbCwgZm9udEZhbWlseSkge1xuICAgICAgICBpZiAoIWZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGl0bGUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlIHRpdGxlXG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgY29sb3I6IHN0cmluZywgYmFja2dyb3VuZDogc3RyaW5nfX0gdGhlbWUgdGl0bGUgdGhlbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIGNzcyBjbGFzcyBuYW1lXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB0aXRsZSBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyVGl0bGU6IGZ1bmN0aW9uKHRpdGxlLCB0aGVtZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBlbFRpdGxlLCBjc3NUZXh0O1xuXG4gICAgICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxUaXRsZSA9IGRvbS5jcmVhdGUoJ0RJVicsIGNsYXNzTmFtZSk7XG4gICAgICAgIGVsVGl0bGUuaW5uZXJIVE1MID0gdGl0bGU7XG5cbiAgICAgICAgY3NzVGV4dCA9IHJlbmRlclV0aWwubWFrZUZvbnRDc3NUZXh0KHRoZW1lKTtcblxuICAgICAgICBpZiAodGhlbWUuYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgY3NzVGV4dCArPSAnOycgKyB0aGlzLmNvbmNhdFN0cignYmFja2dyb3VuZDonLCB0aGVtZS5iYWNrZ3JvdW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsVGl0bGUuc3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7XG5cbiAgICAgICAgcmV0dXJuIGVsVGl0bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZCBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYm91bmQgc2VyaWVzIGJvdW5kXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBleHBlbmRlZCBib3VuZFxuICAgICAqL1xuICAgIGV4cGFuZEJvdW5kOiBmdW5jdGlvbihib3VuZCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gYm91bmQuZGltZW5zaW9uO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBib3VuZC5wb3NpdGlvbjtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGltZW5zaW9uOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGRpbWVuc2lvbi53aWR0aCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFICogMixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGRpbWVuc2lvbi5oZWlnaHQgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSAqIDJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgLSBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSxcbiAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY3VzdG9tIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBwcmVmaXhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3VmZml4IHN1ZmZpeFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGN1c3RvbSBldmVudCBuYW1lXG4gICAgICovXG4gICAgbWFrZUN1c3RvbUV2ZW50TmFtZTogZnVuY3Rpb24ocHJlZml4LCB2YWx1ZSwgc3VmZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyB0dWkudXRpbC5wcm9wZXJDYXNlKHZhbHVlKSArIHR1aS51dGlsLnByb3BlckNhc2Uoc3VmZml4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGZ1bmN0aW9uPn0gZm9ybWF0RnVuY3Rpb25zIC0gZnVuY3Rpb25zIGZvciBmb3JtYXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmVhVHlwZSAtIHR5cGUgb2YgYXJlYSBsaWtlIHlBeGlzLCB4QXhpcywgc2VyaWVzLCBjaXJjbGVMZWdlbmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlVHlwZV0gLSB0eXBlIG9mIHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHZhbHVlXG4gICAgICovXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXRGdW5jdGlvbnMsIGNoYXJ0VHlwZSwgYXJlYVR5cGUsIHZhbHVlVHlwZSkge1xuICAgICAgICB2YXIgZm5zID0gW1N0cmluZyh2YWx1ZSldLmNvbmNhdChmb3JtYXRGdW5jdGlvbnMgfHwgW10pO1xuXG4gICAgICAgIHZhbHVlVHlwZSA9IHZhbHVlVHlwZSB8fCAndmFsdWUnO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5yZWR1Y2UoZm5zLCBmdW5jdGlvbihzdG9yZWQsIGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oc3RvcmVkLCBjaGFydFR5cGUsIGFyZWFUeXBlLCB2YWx1ZVR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgdmFsdWVzXG4gICAgICogQHBhcmFtIHtBcnJheS48ZnVuY3Rpb24+fSBmb3JtYXRGdW5jdGlvbnMgZnVuY3Rpb25zIGZvciBmb3JtYXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmVhVHlwZSAtIHR5cGUgb2YgYXJlYSBsaWtlIHlBeGlzLCB4QXhpcywgc2VyaWVzLCBjaXJjbGVMZWdlbmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVUeXBlIC0gdHlwZSBvZiB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBmb3JtYXRWYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlcywgZm9ybWF0RnVuY3Rpb25zLCBjaGFydFR5cGUsIGFyZWFUeXBlLCB2YWx1ZVR5cGUpIHtcbiAgICAgICAgdmFyIGZvcm1hdGVkVmFsdWVzO1xuXG4gICAgICAgIGlmICghZm9ybWF0RnVuY3Rpb25zIHx8ICFmb3JtYXRGdW5jdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdGVkVmFsdWVzID0gdHVpLnV0aWwubWFwKHZhbHVlcywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKGxhYmVsLCBmb3JtYXRGdW5jdGlvbnMsIGNoYXJ0VHlwZSwgYXJlYVR5cGUsIHZhbHVlVHlwZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRlZFZhbHVlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7e2lkOiBudW1iZXJ9fSBhbmltYXRpb24gYW5pbWFpb24gb2JqZWN0XG4gICAgICovXG4gICAgY2FuY2VsQW5pbWF0aW9uOiBmdW5jdGlvbihhbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24uaWQpIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbi5pZCk7XG4gICAgICAgICAgICBkZWxldGUgYW5pbWF0aW9uLmlkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5pbWF0aW9uVGltZSAtIGFuaW1hdGlvbiB0aW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25BbmltYXRpb24gLSBhbmltYXRpb24gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkNvbXBsZXRlZCAtIGNvbXBsZXRlZCBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHt7aWQ6IG51bWJlcn19IHJlcXVlc3RBbmltYXRpb25GcmFtZSBpZFxuICAgICAqL1xuICAgIHN0YXJ0QW5pbWF0aW9uOiBmdW5jdGlvbihhbmltYXRpb25UaW1lLCBvbkFuaW1hdGlvbiwgb25Db21wbGV0ZWQpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHt9LFxuICAgICAgICAgICAgc3RhcnRUaW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbmltYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBkaWZmVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgcmF0aW8gPSBNYXRoLm1pbigoZGlmZlRpbWUgLyBhbmltYXRpb25UaW1lKSwgMSk7XG5cbiAgICAgICAgICAgIG9uQW5pbWF0aW9uKHJhdGlvKTtcblxuICAgICAgICAgICAgaWYgKHJhdGlvID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFuaW1hdGlvbi5pZDtcbiAgICAgICAgICAgICAgICBpZiAob25Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgIGFuaW1hdGlvbi5pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcblxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIElFNyBvciBub3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNJRTc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNJRTc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb2xkQnJvd3NlciBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNPbGRCcm93c2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzT2xkQnJvd3NlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRvIHplcm8gZmlsbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdGFyZ2V0IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbiBsZW5ndGggb2YgcmVzdWx0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmb3JtYXRUb1plcm9GaWxsOiBmdW5jdGlvbih2YWx1ZSwgbGVuKSB7XG4gICAgICAgIHZhciB6ZXJvID0gJzAnO1xuXG4gICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IGxlbikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgICAgdmFsdWUgPSB6ZXJvICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB0byBEZWNpbWFsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuIGxlbmd0aCBvZiB1bmRlciBkZWNpbWFsIHBvaW50XG4gICAgICogQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHZhbHVlXG4gICAgICovXG4gICAgZm9ybWF0VG9EZWNpbWFsOiBmdW5jdGlvbih2YWx1ZSwgbGVuKSB7XG4gICAgICAgIHZhciBwb3c7XG5cbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG93ID0gTWF0aC5wb3coMTAsIGxlbik7XG4gICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIHBvdykgLyBwb3c7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkudG9GaXhlZChsZW4pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRvIENvbW1hLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZvcm1hdFRvQ29tbWE6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBjb21tYSA9ICcsJyxcbiAgICAgICAgICAgIHVuZGVyUG9pbnRWYWx1ZSA9ICcnLFxuICAgICAgICAgICAgYmV0d2VlbkxlbiA9IDMsXG4gICAgICAgICAgICBvcmdWYWx1ZSA9IHZhbHVlLFxuICAgICAgICAgICAgc2lnbiwgdmFsdWVzLCBsYXN0SW5kZXgsIGZvcm1hdHRlZFZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgc2lnbiA9IHZhbHVlLmluZGV4T2YoJy0nKSA+IC0xID8gJy0nIDogJyc7XG5cbiAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcoTWF0aC5hYnModmFsdWVzWzBdKSk7XG4gICAgICAgICAgICB1bmRlclBvaW50VmFsdWUgPSAnLicgKyB2YWx1ZXNbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyhNYXRoLmFicyh2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBiZXR3ZWVuTGVuKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IG9yZ1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzID0gKHZhbHVlKS5zcGxpdCgnJykucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YWx1ZXMgPSB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbihjaGFyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbY2hhcl07XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbGFzdEluZGV4ICYmIChpbmRleCArIDEpICUgYmV0d2VlbkxlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb21tYSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSBzaWduICsgY29uY2F0LmFwcGx5KFtdLCB2YWx1ZXMpLnJldmVyc2UoKS5qb2luKCcnKSArIHVuZGVyUG9pbnRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjc3NUZXh0IGZyb20gbWFwLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjc3NNYXAgLSBjc3MgbWFwXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBtYWtlQ3NzVGV4dEZyb21NYXA6IGZ1bmN0aW9uKGNzc01hcCkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGNzc01hcCwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJVdGlsLmNvbmNhdFN0cihuYW1lLCAnOicsIHZhbHVlKTtcbiAgICAgICAgfSkuam9pbignOycpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IGNzcyBvcGFjaXR5LlxuICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IEFycmF5LjxIVE1MRWxlbWVudD59IGVsZW1lbnRzIC0gZWxlbWVudHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gaXRlcmF0ZWVcbiAqL1xuZnVuY3Rpb24gc2V0T3BhY2l0eShlbGVtZW50cywgaXRlcmF0ZWUpIHtcbiAgICBlbGVtZW50cyA9IHR1aS51dGlsLmlzQXJyYXkoZWxlbWVudHMpID8gZWxlbWVudHMgOiBbZWxlbWVudHNdO1xuICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShlbGVtZW50cywgaXRlcmF0ZWUpO1xufVxuXG4vKipcbiAqIE1ha2UgZmlsdGVyIG9wYWNpdHkgY3NzIHN0cmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IC0gb3BhY2l0eVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbWFrZUNzc0ZpbHRlck9wYWNpdHlTdHJpbmcob3BhY2l0eSkge1xuICAgIHJldHVybiAnYWxwaGEob3BhY2l0eT0nICsgKG9wYWNpdHkgKiBjaGFydENvbnN0Lk9MRF9CUk9XU0VSX09QQUNJVFlfMTAwKSArICcpJztcbn1cblxuaWYgKGlzT2xkQnJvd3Nlcikge1xuICAgIC8qKlxuICAgICAqIE1ha2Ugb3BhY2l0eSBjc3MgdGV4dCBmb3Igb2xkIGJyb3dzZXIoSUU3LCBJRTgpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IC0gb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgcmVuZGVyVXRpbC5tYWtlT3BhY2l0eUNzc1RleHQgPSBmdW5jdGlvbihvcGFjaXR5KSB7XG4gICAgICAgIHJldHVybiAnO2ZpbHRlcjonICsgbWFrZUNzc0ZpbHRlck9wYWNpdHlTdHJpbmcob3BhY2l0eSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBjc3Mgb3BhY2l0eSBmb3Igb2xkIGJyb3dzZXIoSUU3LCBJRTgpLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBBcnJheS48SFRNTEVsZW1lbnQ+fSBlbGVtZW50cyAtIGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgLSBvcGFjaXR5XG4gICAgICovXG4gICAgcmVuZGVyVXRpbC5zZXRPcGFjaXR5ID0gZnVuY3Rpb24oZWxlbWVudHMsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIGZpbHRlciA9IG1ha2VDc3NGaWx0ZXJPcGFjaXR5U3RyaW5nKG9wYWNpdHkpO1xuICAgICAgICBzZXRPcGFjaXR5KGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgLyoqXG4gICAgICogTWFrZSBvcGFjaXR5IGNzcyB0ZXh0IGZvciBicm93c2VyIHN1cHBvcnRpbmcgb3BhY2l0eSBwcm9wZXJ0eSBvZiBDU1MzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IC0gb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgcmVuZGVyVXRpbC5tYWtlT3BhY2l0eUNzc1RleHQgPSBmdW5jdGlvbihvcGFjaXR5KSB7XG4gICAgICAgIHJldHVybiAnO29wYWNpdHk6JyArIG9wYWNpdHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBjc3Mgb3BhY2l0eSBmb3IgYnJvd3NlciBzdXBwb3J0aW5nIG9wYWNpdHkgcHJvcGVydHkgb2YgQ1NTMy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgQXJyYXkuPEhUTUxFbGVtZW50Pn0gZWxlbWVudHMgLSBlbGVtZW50c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IC0gb3BhY2l0eVxuICAgICAqL1xuICAgIHJlbmRlclV0aWwuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBvcGFjaXR5KSB7XG4gICAgICAgIHNldE9wYWNpdHkoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbnR1aS51dGlsLmRlZmluZU5hbWVzcGFjZSgndHVpLmNoYXJ0Jyk7XG50dWkuY2hhcnQucmVuZGVyVXRpbCA9IHJlbmRlclV0aWw7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyVXRpbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIHRlbXBsYXRlIG1ha2VyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGVtcGxhdGUgbWFrZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgaHRtbFxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gdGVtcGxhdGUgZnVuY3Rpb25cbiAgICAgKiBAZWF4bXBsZVxuICAgICAqXG4gICAgICogICB2YXIgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKCc8c3Bhbj57eyBuYW1lIH19PC9zcGFuPicpLFxuICAgICAqICAgICAgIHJlc3VsdCA9IHRlbXBsYXRlKHtuYW1lOiAnSm9obicpO1xuICAgICAqICAgY29uc29sZS5sb2cocmVzdWx0KTsgLy8gPHNwYW4+Sm9objwvc3Bhbj5cbiAgICAgKlxuICAgICAqL1xuICAgIHRlbXBsYXRlOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaHRtbDtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goZGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKCd7e1xcXFxzKicgKyBrZXkgKyAnXFxcXHMqfX0nLCAnZycpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKHJlZ0V4cCwgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKCckMCcsICc8c3Bhbj4kPC9zcGFuPjAnKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFVzZXJFdmVudExpc3RlbmVyIGlzIGxpc3RlbmVyIG9mIHVzZXIgZXZlbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVzZXJFdmVudExpc3RlbmVyID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBVc2VyRXZlbnRMaXN0ZW5lci5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHVzZXIgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBldmVudCBjYWxsYmFja1xuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihldmVudE5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5vbihldmVudE5hbWUsIGZ1bmMpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oVXNlckV2ZW50TGlzdGVuZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXJFdmVudExpc3RlbmVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBDaXJjbGUgbGVnZW5kIGNvbXBvbmVudCByZW5kZXIgYSBsZWdlbmQgaW4gdGhlIGZvcm0gb2Ygb3ZlcmxhcHBpbmcgY2lyY2xlc1xuICogICAgICAgICAgICAgICAgICBieSByZXByZXNlbnRhdGl2ZSByYWRpdXMgdmFsdWVzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKTtcbnZhciByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG52YXIgcGx1Z2luRmFjdG9yeSA9IHJlcXVpcmUoJy4uL2ZhY3Rvcmllcy9wbHVnaW5GYWN0b3J5Jyk7XG52YXIgbGVnZW5kVGVtcGxhdGUgPSByZXF1aXJlKCcuLy4uL2xlZ2VuZHMvbGVnZW5kVGVtcGxhdGUnKTtcblxudmFyIENpcmNsZUxlZ2VuZCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgQ2lyY2xlTGVnZW5kLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogY3NzIGNsYXNzTmFtZSBvZiBjaXJjbGUgbGVnZW5kXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBjbGFzc05hbWU6ICd0dWktY2hhcnQtY2lyY2xlLWxlZ2VuZC1hcmVhJyxcbiAgICAvKipcbiAgICAgKiByYXRpb3MgZm9yIHJlbmRlcmluZyBjaXJjbGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgY2lyY2xlUmF0aW9zOiBbMSwgMC41LCAwLjI1XSxcbiAgICAvKipcbiAgICAgKiBDaXJjbGUgbGVnZW5kIGNvbXBvbmVudCByZW5kZXIgYSBsZWdlbmQgaW4gdGhlIGZvcm0gb2Ygb3ZlcmxhcHBpbmcgY2lyY2xlcyBieSByZXByZXNlbnRhdGl2ZSByYWRpdXMgdmFsdWVzLlxuICAgICAqIEBjb25zdHJ1Y3RzIENpcmNsZUxlZ2VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHs/c3RyaW5nfSBwYXJhbXMubGliVHlwZSAtIGxpYnJhcnkgdHlwZSBmb3IgZ3JhcGggcmVuZGVyaW5nXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSAtIGNoYXJ0IHR5cGVcbiAgICAgKiAgICAgIEBwYXJhbSB7RGF0YVByb2Nlc3Nvcn0gcGFyYW1zLmRhdGFQcm9jZXNzb3IgLSBEYXRhUHJvY2Vzc29yXG4gICAgICogICAgICBAcGFyYW0ge0JvdW5kc01ha2VyfSBwYXJhbXMuYm91bmRzTWFrZXIgLSBCb3VuZHNNYWtlclxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5iYXNlRm9udEZhbWlseSAtIGJhc2UgZm9udEZhbWlseSBvZiBjaGFydFxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbGliVHlwZSA9IHBhcmFtcy5saWJUeXBlIHx8IGNoYXJ0Q29uc3QuREVGQVVMVF9QTFVHSU47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gcGFyYW1zLmNoYXJ0VHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZGF0YSBwcm9jZXNzb3JcbiAgICAgICAgICogQHR5cGUge0RhdGFQcm9jZXNzb3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IgPSBwYXJhbXMuZGF0YVByb2Nlc3NvcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYm91bmRzIG1ha2VyXG4gICAgICAgICAqIEB0eXBlIHtCb3VuZHNNYWtlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBwYXJhbXMuYm91bmRzTWFrZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZW1lIGZvciBsYWJlbCBvZiBjaXJjbGUgbGVnZW5kIGFyZWFcbiAgICAgICAgICogQHR5cGUge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiAqfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFiZWxUaGVtZSA9IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiBjaGFydENvbnN0LkNJUkNMRV9MRUdFTkRfTEFCRUxfRk9OVF9TSVpFLFxuICAgICAgICAgICAgZm9udEZhbWlseTogcGFyYW1zLmJhc2VGb250RmFtaWx5XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoIHJlbmRlcmVyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIgPSBwbHVnaW5GYWN0b3J5LmdldChsaWJUeXBlLCAnY2lyY2xlTGVnZW5kJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBsYWJlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbCAtIGxhYmVsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxMZW5ndGggLSBkZWNpbWFsIGxlbmd0aFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZm9ybWF0TGFiZWw6IGZ1bmN0aW9uKGxhYmVsLCBkZWNpbWFsTGVuZ3RoKSB7XG4gICAgICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0RnVuY3Rpb25zKCk7XG5cbiAgICAgICAgaWYgKGRlY2ltYWxMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxhYmVsID0gU3RyaW5nKHBhcnNlSW50KGxhYmVsLCAxMCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFiZWwgPSBTdHJpbmcobGFiZWwpO1xuICAgICAgICAgICAgbGFiZWwgPSByZW5kZXJVdGlsLmZvcm1hdFRvRGVjaW1hbChsYWJlbCwgZGVjaW1hbExlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZShsYWJlbCwgZm9ybWF0RnVuY3Rpb25zLCB0aGlzLmNoYXJ0VHlwZSwgJ2NpcmNsZUxlZ2VuZCcsICdyJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGFiZWwgaHRtbC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMYWJlbEh0bWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBib3VuZHNNYWtlciA9IHRoaXMuYm91bmRzTWFrZXI7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2NpcmNsZUxlZ2VuZCcpO1xuICAgICAgICB2YXIgaGFsZldpZHRoID0gZGltZW5zaW9uLndpZHRoIC8gMjtcbiAgICAgICAgdmFyIG1heFJhZGl1cyA9IGJvdW5kc01ha2VyLmdldE1heFJhZGl1c0ZvckJ1YmJsZUNoYXJ0KCk7XG4gICAgICAgIHZhciBtYXhWYWx1ZVJhZGl1cyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRNYXhWYWx1ZSh0aGlzLmNoYXJ0VHlwZSwgJ3InKTtcbiAgICAgICAgdmFyIGRlY2ltYWxMZW5ndGggPSB0dWkudXRpbC5nZXREZWNpbWFsTGVuZ3RoKG1heFZhbHVlUmFkaXVzKTtcbiAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KG1heFZhbHVlUmFkaXVzLCB0aGlzLmxhYmVsVGhlbWUpO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodGhpcy5jaXJjbGVSYXRpb3MsIGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICAgICAgICB2YXIgZGlhbWV0ZXIgPSBtYXhSYWRpdXMgKiByYXRpbyAqIDI7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBzZWxmLl9mb3JtYXRMYWJlbChtYXhWYWx1ZVJhZGl1cyAqIHJhdGlvLCBkZWNpbWFsTGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBsYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGFiZWwsIHNlbGYubGFiZWxUaGVtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsZWdlbmRUZW1wbGF0ZS50cGxDaXJjbGVMZWdlbmRMYWJlbCh7XG4gICAgICAgICAgICAgICAgbGVmdDogaGFsZldpZHRoIC0gKGxhYmVsV2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICB0b3A6IGRpbWVuc2lvbi5oZWlnaHQgLSBkaWFtZXRlciAtIGxhYmVsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbGFiZWwgYXJlYS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJMYWJlbEFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGFiZWxDb250YWluZXIgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LWNpcmNsZS1sZWdlbmQtbGFiZWwtYXJlYScpO1xuXG4gICAgICAgIGxhYmVsQ29udGFpbmVyLmlubmVySFRNTCA9IHRoaXMuX21ha2VMYWJlbEh0bWwoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWxDb250YWluZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZm9yIGNpcmNsZSBsZWdlbmQgYXJlYS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2lyY2xlQ29udGFpbmVyID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1jaXJjbGUtYXJlYScpO1xuICAgICAgICB2YXIgYm91bmRzTWFrZXIgPSB0aGlzLmJvdW5kc01ha2VyO1xuICAgICAgICB2YXIgYm91bmQgPSBib3VuZHNNYWtlci5nZXRCb3VuZCgnY2lyY2xlTGVnZW5kJyk7XG4gICAgICAgIHZhciBtYXhSYWRpdXMgPSBib3VuZHNNYWtlci5nZXRNYXhSYWRpdXNGb3JCdWJibGVDaGFydCgpO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNpcmNsZUNvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlbmRlcihjaXJjbGVDb250YWluZXIsIGJvdW5kLmRpbWVuc2lvbiwgbWF4UmFkaXVzLCB0aGlzLmNpcmNsZVJhdGlvcyk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyTGFiZWxBcmVhKCk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24odGhpcy5jb250YWluZXIsIGJvdW5kLnBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyLlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXJlbmRlci5cbiAgICAgKi9cbiAgICByZXJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplLlxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVyZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IG1heCB3aWR0aCBvZiBsYWJlbCBmb3IgQ2lyY2xlTGVnZW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q2lyY2xlTGVnZW5kTGFiZWxNYXhXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYXhMYWJlbCA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGb3JtYXR0ZWRNYXhWYWx1ZSh0aGlzLmNoYXJ0VHlwZSwgJ2NpcmNsZUxlZ2VuZCcsICdyJyk7XG4gICAgICAgIHZhciBtYXhMYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobWF4TGFiZWwsIHtcbiAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmxhYmVsVGhlbWUuZm9udFNpemUsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB0aGlzLmxhYmVsVGhlbWUuZm9udEZhbWlseVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWF4TGFiZWxXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNpcmNsZSBsZWdlbmQgd2lkdGguXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDaXJjbGVMZWdlbmRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYXhSYWRpdXMgPSB0aGlzLmJvdW5kc01ha2VyLmdldE1pbmltdW1QaXhlbFN0ZXBGb3JBeGlzKCk7XG4gICAgICAgIHZhciBtYXhMYWJlbFdpZHRoID0gdGhpcy5fZ2V0Q2lyY2xlTGVnZW5kTGFiZWxNYXhXaWR0aCgpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCgobWF4UmFkaXVzICogMiksIG1heExhYmVsV2lkdGgpICsgY2hhcnRDb25zdC5DSVJDTEVfTEVHRU5EX1BBRERJTkc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGRpbWVuc2lvbiBvZiBjaXJjbGUgbGVnZW5kLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVnaXN0ZXJDaXJjbGVMZWdlbmREaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2lyY2xlTGVnZW5kV2lkdGggPSB0aGlzLl9nZXRDaXJjbGVMZWdlbmRXaWR0aCgpO1xuICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignY2FsY3VsYXRpb25MZWdlbmQnKS53aWR0aCB8fCBjaGFydENvbnN0Lk1JTl9MRUdFTkRfV0lEVEg7XG5cbiAgICAgICAgY2lyY2xlTGVnZW5kV2lkdGggPSBNYXRoLm1pbihjaXJjbGVMZWdlbmRXaWR0aCwgbGVnZW5kV2lkdGgpO1xuXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCYXNlRGltZW5zaW9uKCdjaXJjbGVMZWdlbmQnLCB7XG4gICAgICAgICAgICB3aWR0aDogY2lyY2xlTGVnZW5kV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNpcmNsZUxlZ2VuZFdpZHRoXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZUxlZ2VuZDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgTGVnZW5kIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGVnZW5kTW9kZWwgPSByZXF1aXJlKCcuL2xlZ2VuZE1vZGVsJyksXG4gICAgTGVnZW5kRGltZW5zaW9uTW9kZWwgPSByZXF1aXJlKCcuL2xlZ2VuZERpbWVuc2lvbk1vZGVsJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICBldmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi4vaGVscGVycy9ldmVudExpc3RlbmVyJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIGxlZ2VuZFRlbXBsYXRlID0gcmVxdWlyZSgnLi8uLi9sZWdlbmRzL2xlZ2VuZFRlbXBsYXRlJyk7XG5cbnZhciBMZWdlbmQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIExlZ2VuZC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIExlZ2VuZCBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgTGVnZW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIGF4aXMgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7P0FycmF5LjxzdHJpbmc+fSBwYXJhbXMuY2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFydCB0eXBlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsZWdlbmREYXRhO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsZWdlbmQgdGhlbWVcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGhlbWUgPSBwYXJhbXMudGhlbWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IHBhcmFtcy5jaGFydFR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlcmllcyBuYW1lc1xuICAgICAgICAgKiBAdHlwZSB7P0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJpZXNOYW1lcyA9IHBhcmFtcy5zZXJpZXNOYW1lcyB8fCBbdGhpcy5jaGFydFR5cGVdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1c2VyIGV2ZW50IG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VyRXZlbnQgPSBwYXJhbXMudXNlckV2ZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZWdlbmQgdmlldyBjbGFzc05hbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jaGFydC1sZWdlbmQtYXJlYSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrZWQgaW5kZXhlc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrZWRJbmRleGVzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IHBhcmFtcy5kYXRhUHJvY2Vzc29yO1xuXG4gICAgICAgIGxlZ2VuZERhdGEgPSBwYXJhbXMuZGF0YVByb2Nlc3Nvci5nZXRMZWdlbmREYXRhKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsZWdlbmQgbW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVnZW5kTW9kZWwgPSBuZXcgTGVnZW5kTW9kZWwoe1xuICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXG4gICAgICAgICAgICBsYWJlbHM6IHBhcmFtcy5kYXRhUHJvY2Vzc29yLmdldExlZ2VuZExhYmVscygpLFxuICAgICAgICAgICAgbGVnZW5kRGF0YTogbGVnZW5kRGF0YSxcbiAgICAgICAgICAgIHNlcmllc05hbWVzOiB0aGlzLnNlcmllc05hbWVzLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmRpbWVuc2lvbk1vZGVsID0gbmV3IExlZ2VuZERpbWVuc2lvbk1vZGVsKHtcbiAgICAgICAgICAgIGxlZ2VuZExhYmVsczogdHVpLnV0aWwucGx1Y2sobGVnZW5kRGF0YSwgJ2xhYmVsJyksXG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGxlZ2VuZCBkaW1lbnNpb24uXG4gICAgICovXG4gICAgcmVnaXN0ZXJEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhcnRXaWR0aCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdjaGFydCcpLndpZHRoO1xuICAgICAgICB2YXIgbGVnZW5kRGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb25Nb2RlbC5tYWtlRGltZW5zaW9uKGNoYXJ0V2lkdGgpO1xuXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCYXNlRGltZW5zaW9uKCdsZWdlbmQnLCBsZWdlbmREaW1lbnNpb24pO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaGFzVmVydGljYWxMZWdlbmRXaWR0aCh0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kc01ha2VyLnJlZ2lzdGVyQmFzZURpbWVuc2lvbignY2FsY3VsYXRpb25MZWdlbmQnLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGxlZ2VuZERpbWVuc2lvbi53aWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxlZ2VuZCBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxlZ2VuZENvbnRhaW5lciBsZWdlbmQgY29udGFpbmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTGVnZW5kQXJlYTogZnVuY3Rpb24obGVnZW5kQ29udGFpbmVyKSB7XG4gICAgICAgIGxlZ2VuZENvbnRhaW5lci5pbm5lckhUTUwgPSB0aGlzLl9tYWtlTGVnZW5kSHRtbCh0aGlzLmxlZ2VuZE1vZGVsLmdldERhdGEoKSk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24obGVnZW5kQ29udGFpbmVyLCB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKCdsZWdlbmQnKSk7XG4gICAgICAgIGxlZ2VuZENvbnRhaW5lci5zdHlsZS5jc3NUZXh0ICs9ICc7JyArIHJlbmRlclV0aWwubWFrZUZvbnRDc3NUZXh0KHRoaXMudGhlbWUubGFiZWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbGVnZW5kIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGxlZ2VuZCBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKTtcblxuICAgICAgICB0aGlzLmxlZ2VuZENvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzSG9yaXpvbnRhbExlZ2VuZCh0aGlzLm9wdGlvbnMuYWxpZ24pKSB7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3MoY29udGFpbmVyLCAnaG9yaXpvbnRhbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kQXJlYShjb250YWluZXIpO1xuICAgICAgICB0aGlzLl9hdHRhY2hFdmVudChjb250YWluZXIpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcmVuZGVyLlxuICAgICAqL1xuICAgIHJlcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kQXJlYSh0aGlzLmxlZ2VuZENvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBsZWdlbmQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVyZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjc3NUZXh0IG9mIGxlZ2VuZCByZWN0LlxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgY2hhcnRUeXBlOiBzdHJpbmcsXG4gICAgICogICAgICB0aGVtZToge2NvbG9yOiBzdHJpbmcsIGJvcmRlckNvbG9yOiA/c3RyaW5nLCBzaW5nbGVDb2xvcjogP3N0cmluZ31cbiAgICAgKiB9fSBsZWdlbmREYXR1bSBsZWdlbmQgZGF0dW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZU1hcmdpblRvcCBiYXNlIG1hcmdpbi10b3BcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjc3NUZXh0IG9mIGxlZ2VuZCByZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxlZ2VuZFJlY3RDc3NUZXh0OiBmdW5jdGlvbihsZWdlbmREYXR1bSwgYmFzZU1hcmdpblRvcCkge1xuICAgICAgICB2YXIgdGhlbWUgPSBsZWdlbmREYXR1bS50aGVtZSxcbiAgICAgICAgICAgIGJvcmRlckNzc1RleHQgPSB0aGVtZS5ib3JkZXJDb2xvciA/IHJlbmRlclV0aWwuY29uY2F0U3RyKCc7Ym9yZGVyOjFweCBzb2xpZCAnLCB0aGVtZS5ib3JkZXJDb2xvcikgOiAnJyxcbiAgICAgICAgICAgIHJlY3RNYXJnaW4sIG1hcmdpblRvcDtcbiAgICAgICAgaWYgKGxlZ2VuZERhdHVtLmNoYXJ0VHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICBtYXJnaW5Ub3AgPSBiYXNlTWFyZ2luVG9wICsgY2hhcnRDb25zdC5MSU5FX01BUkdJTl9UT1A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJnaW5Ub3AgPSBiYXNlTWFyZ2luVG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdE1hcmdpbiA9IHJlbmRlclV0aWwuY29uY2F0U3RyKCc7bWFyZ2luLXRvcDonLCBtYXJnaW5Ub3AsICdweCcpO1xuXG4gICAgICAgIHJldHVybiByZW5kZXJVdGlsLmNvbmNhdFN0cignYmFja2dyb3VuZC1jb2xvcjonLCB0aGVtZS5zaW5nbGVDb2xvciB8fCB0aGVtZS5jb2xvciwgYm9yZGVyQ3NzVGV4dCwgcmVjdE1hcmdpbik7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsYWJlbHMgd2lkdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48e2NoYXJ0VHlwZTogP3N0cmluZywgbGFiZWw6IHN0cmluZ30+fSBsZWdlbmREYXRhIGxlZ2VuZCBkYXRhXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSBsYWJlbHMgd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxzV2lkdGg6IGZ1bmN0aW9uKGxlZ2VuZERhdGEpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAobGVnZW5kRGF0YSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChpdGVtLmxhYmVsLCBzZWxmLnRoZW1lLmxhYmVsKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsV2lkdGggKyBjaGFydENvbnN0LkxFR0VORF9BUkVBX1BBRERJTkc7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxlZ2VuZCBodG1sLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHtjaGFydFR5cGU6ID9zdHJpbmcsIGxhYmVsOiBzdHJpbmd9Pn0gbGVnZW5kRGF0YSBsZWdlbmQgZGF0YVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGxlZ2VuZCBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxlZ2VuZEh0bWw6IGZ1bmN0aW9uKGxlZ2VuZERhdGEpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBsZWdlbmRUZW1wbGF0ZS50cGxMZWdlbmQ7XG4gICAgICAgIHZhciBjaGVja0JveFRlbXBsYXRlID0gbGVnZW5kVGVtcGxhdGUudHBsQ2hlY2tib3g7XG4gICAgICAgIHZhciBsYWJlbHNXaWR0aCA9IHRoaXMuX21ha2VMYWJlbHNXaWR0aChsZWdlbmREYXRhKTtcbiAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGxlZ2VuZERhdGFbMF0ubGFiZWwsIGxlZ2VuZERhdGFbMF0udGhlbWUpO1xuICAgICAgICB2YXIgaXNIb3Jpem9udGFsTGVnZW5kID0gcHJlZGljYXRlLmlzSG9yaXpvbnRhbExlZ2VuZCh0aGlzLm9wdGlvbnMuYWxpZ24pO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gbGFiZWxIZWlnaHQgKyAoY2hhcnRDb25zdC5MQUJFTF9QQURESU5HX1RPUCAqIDIpO1xuICAgICAgICB2YXIgYmFzZU1hcmdpblRvcCA9IHBhcnNlSW50KChoZWlnaHQgLSBjaGFydENvbnN0LkxFR0VORF9SRUNUX1dJRFRIKSAvIDIsIDEwKSAtIDE7XG4gICAgICAgIHZhciBodG1sID0gdHVpLnV0aWwubWFwKGxlZ2VuZERhdGEsIGZ1bmN0aW9uKGxlZ2VuZERhdHVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHJlY3RDc3NUZXh0ID0gc2VsZi5fbWFrZUxlZ2VuZFJlY3RDc3NUZXh0KGxlZ2VuZERhdHVtLCBiYXNlTWFyZ2luVG9wKTtcbiAgICAgICAgICAgIHZhciBjaGVja2JveCA9IHNlbGYub3B0aW9ucy5zaG93Q2hlY2tib3ggPT09IGZhbHNlID8gJycgOiBjaGVja0JveFRlbXBsYXRlKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogc2VsZi5sZWdlbmRNb2RlbC5pc0NoZWNrZWRJbmRleChpbmRleCkgPyAnIGNoZWNrZWQnIDogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgcmVjdENzc1RleHQ6IHJlY3RDc3NUZXh0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxhYmVsSGVpZ2h0OiBsYWJlbEhlaWdodCxcbiAgICAgICAgICAgICAgICB1bnNlbGVjdGVkOiBzZWxmLmxlZ2VuZE1vZGVsLmlzVW5zZWxlY3RlZEluZGV4KGluZGV4KSA/ICcgdW5zZWxlY3RlZCcgOiAnJyxcbiAgICAgICAgICAgICAgICBsYWJlbFdpZHRoOiBpc0hvcml6b250YWxMZWdlbmQgPyAnO3dpZHRoOicgKyBsYWJlbHNXaWR0aFtpbmRleF0gKyAncHgnIDogJycsXG4gICAgICAgICAgICAgICAgaWNvblR5cGU6IGxlZ2VuZERhdHVtLmNoYXJ0VHlwZSB8fCAncmVjdCcsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxlZ2VuZERhdHVtLmxhYmVsLFxuICAgICAgICAgICAgICAgIGNoZWNrYm94OiBjaGVja2JveCxcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZShkYXRhKTtcbiAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbGVnZW5kIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUYXJnZXQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGxlZ2VuZCBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZExlZ2VuZExhYmVsRWxlbWVudDogZnVuY3Rpb24oZWxUYXJnZXQpIHtcbiAgICAgICAgdmFyIGxlZ2VuZENvbnRhaW5lcjtcblxuICAgICAgICBpZiAoZG9tLmhhc0NsYXNzKGVsVGFyZ2V0LCBjaGFydENvbnN0LkNMQVNTX05BTUVfTEVHRU5EX0xBQkVMKSkge1xuICAgICAgICAgICAgbGVnZW5kQ29udGFpbmVyID0gZWxUYXJnZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWdlbmRDb250YWluZXIgPSBkb20uZmluZFBhcmVudEJ5Q2xhc3MoZWxUYXJnZXQsIGNoYXJ0Q29uc3QuQ0xBU1NfTkFNRV9MRUdFTkRfTEFCRUwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlZ2VuZENvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZSBsZWdlbmQgY2hlY2tib3ggZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUxlZ2VuZENoZWNrYm94RXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZUNoZWNrZWRMZWdlbmRzJywgdGhpcy5sZWdlbmRNb2RlbC5nZXRDaGVja2VkSW5kZXhlcygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZSBsZWdlbmQgZXZlbnQuXG4gICAgICogQHBhcmFtIHt7Y2hhcnRUeXBlOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ9fSBkYXRhIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlTGVnZW5kU2VsZWN0aW9uRXZlbnQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VyaWVzTmFtZXMgPSB0aGlzLnNlcmllc05hbWVzO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxlZ2VuZE1vZGVsLmdldFNlbGVjdGVkSW5kZXgoKTtcbiAgICAgICAgdmFyIGxlZ2VuZEluZGV4ID0gIXR1aS51dGlsLmlzTnVsbChpbmRleCkgPyBkYXRhLnNlcmllc0luZGV4IDogaW5kZXg7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHNlcmllc05hbWVzLCBmdW5jdGlvbihzZXJpZXNOYW1lKSB7XG4gICAgICAgICAgICB2YXIgY2hhcnRUeXBlID0gc2VsZi5kYXRhUHJvY2Vzc29yLmZpbmRDaGFydFR5cGUoc2VyaWVzTmFtZSk7XG4gICAgICAgICAgICBzZWxmLmZpcmUocmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzZWxlY3QnLCBjaGFydFR5cGUsICdsZWdlbmQnKSwgZGF0YS5jaGFydFR5cGUsIGxlZ2VuZEluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmUgdXNlciBldmVudC5cbiAgICAgKiBAcGFyYW0ge3tsYWJlbDogc3RyaW5nLCBjaGFydFR5cGU6IHN0cmluZywgaW5kZXg6IG51bWJlcn19IGRhdGEgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVVc2VyRXZlbnQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnc2VsZWN0TGVnZW5kJywge1xuICAgICAgICAgICAgbGVnZW5kOiBkYXRhLmxhYmVsLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBkYXRhLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIGluZGV4OiBkYXRhLmluZGV4XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbGVjdExlZ2VuZDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmxlZ2VuZE1vZGVsLmdldERhdHVtKGluZGV4KTtcblxuICAgICAgICB0aGlzLmxlZ2VuZE1vZGVsLnRvZ2dsZVNlbGVjdGVkSW5kZXgoaW5kZXgpO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNOdWxsKHRoaXMubGVnZW5kTW9kZWwuZ2V0U2VsZWN0ZWRJbmRleCgpKSAmJiAhdGhpcy5sZWdlbmRNb2RlbC5pc0NoZWNrZWRTZWxlY3RlZEluZGV4KCkpIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kTW9kZWwuY2hlY2tTZWxlY3RlZEluZGV4KCk7XG4gICAgICAgICAgICB0aGlzLl9maXJlTGVnZW5kQ2hlY2tib3hFdmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kQXJlYSh0aGlzLmxlZ2VuZENvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5fZmlyZUxlZ2VuZFNlbGVjdGlvbkV2ZW50KGRhdGEpO1xuICAgICAgICB0aGlzLl9maXJlVXNlckV2ZW50KGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2hlY2tlZCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY2hlY2tlZCBpbmRleGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q2hlY2tlZEluZGV4ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hlY2tlZEluZGV4ZXMgPSBbXTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5sZWdlbmRDb250YWluZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JyksIGZ1bmN0aW9uKGNoZWNrYm94LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoZWNrZWRJbmRleGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBsZWdlbmQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tMZWdlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hlY2tlZEluZGV4ZXMgPSB0aGlzLl9nZXRDaGVja2VkSW5kZXhlcygpO1xuICAgICAgICB2YXIgY2hlY2tlZENvdW50ID0gY2hlY2tlZEluZGV4ZXMubGVuZ3RoO1xuICAgICAgICB2YXIgaXNQaWVUeXBlQ2hhcnRzID0gdHVpLnV0aWwuYWxsKHRoaXMuc2VyaWVzTmFtZXMsIHByZWRpY2F0ZS5pc1BpZVR5cGVDaGFydCk7XG4gICAgICAgIHZhciBkYXRhO1xuXG4gICAgICAgIGlmICgoaXNQaWVUeXBlQ2hhcnRzICYmIGNoZWNrZWRDb3VudCA9PT0gMSkgfHwgY2hlY2tlZENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJMZWdlbmRBcmVhKHRoaXMubGVnZW5kQ29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kTW9kZWwudXBkYXRlQ2hlY2tlZERhdGEoY2hlY2tlZEluZGV4ZXMpO1xuXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5sZWdlbmRNb2RlbC5nZXRTZWxlY3RlZERhdHVtKCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5sZWdlbmRNb2RlbC5pc0NoZWNrZWRTZWxlY3RlZEluZGV4KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlZ2VuZE1vZGVsLnVwZGF0ZVNlbGVjdGVkSW5kZXgobnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckxlZ2VuZEFyZWEodGhpcy5sZWdlbmRDb250YWluZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9maXJlTGVnZW5kQ2hlY2tib3hFdmVudCgpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVMZWdlbmRTZWxlY3Rpb25FdmVudChkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGljayBldmVudCBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGVsVGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxuICAgICAgICAgICAgbGVnZW5kQ29udGFpbmVyLCBpbmRleDtcblxuICAgICAgICBpZiAoZG9tLmhhc0NsYXNzKGVsVGFyZ2V0LCBjaGFydENvbnN0LkNMQVNTX05BTUVfTEVHRU5EX0NIRUNLQk9YKSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tMZWdlbmQoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVnZW5kQ29udGFpbmVyID0gdGhpcy5fZmluZExlZ2VuZExhYmVsRWxlbWVudChlbFRhcmdldCk7XG5cbiAgICAgICAgaWYgKCFsZWdlbmRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gcGFyc2VJbnQobGVnZW5kQ29udGFpbmVyLmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpLCAxMCk7XG4gICAgICAgIHRoaXMuX3NlbGVjdExlZ2VuZChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBicm93c2VyIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F0dGFjaEV2ZW50OiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lci5vbih0YXJnZXQsICdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oTGVnZW5kKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZWdlbmQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTGVnZW5kRGltZW5zaW9uTW9kZWwgaXMgbW9kZWwgZm9yIGNhbGN1bGF0aW5nIGRpbWVuc2lvbiBvZiBsZWdlbmQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgTGVnZW5kRGltZW5zaW9uTW9kZWwgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIExlZ2VuZERpbWVuc2lvbk1vZGVsLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTGVnZW5kRGltZW5zaW9uTW9kZWwgaXMgbW9kZWwgZm9yIGNhbGN1bGF0aW5nIGRpbWVuc2lvbiBvZiBsZWdlbmQuXG4gICAgICogQGNvbnN0cnVjdHMgTGVnZW5kRGltZW5zaW9uTW9kZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhcnRUeXBlIC0gdHlwZSBvZiBjaGFydFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIC0gbGVnZW5kIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgLSBsZWdlbmQgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7QXJyYXkuPHN0cmluZyB8IG51bWJlcj59IHBhcmFtcy5sZWdlbmRMYWJlbHMgLSBsZWdlbmQgbGFiZWxzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gcGFyYW1zLmNoYXJ0VHlwZTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcblxuICAgICAgICB0aGlzLnRoZW1lID0gcGFyYW1zLnRoZW1lO1xuXG4gICAgICAgIHRoaXMubGVnZW5kTGFiZWxzID0gcGFyYW1zLmxlZ2VuZExhYmVscztcblxuICAgICAgICB0aGlzLmxlZ2VuZENoZWNrYm94V2lkdGggPSB0aGlzLm9wdGlvbnMuc2hvd0NoZWNrYm94ID09PSBmYWxzZSA/IDAgOiBjaGFydENvbnN0LkxFR0VORF9DSEVDS0JPWF9XSURUSDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsZWdlbmQgd2lkdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsV2lkdGggbGFiZWwgd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMZWdlbmRXaWR0aDogZnVuY3Rpb24obGFiZWxXaWR0aCkge1xuICAgICAgICByZXR1cm4gbGFiZWxXaWR0aCArIHRoaXMubGVnZW5kQ2hlY2tib3hXaWR0aCArIGNoYXJ0Q29uc3QuTEVHRU5EX1JFQ1RfV0lEVEggK1xuICAgICAgICAgICAgY2hhcnRDb25zdC5MRUdFTkRfTEFCRUxfTEVGVF9QQURESU5HICsgY2hhcnRDb25zdC5MRUdFTkRfQVJFQV9QQURESU5HO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgc3VtIG9mIGxlZ2VuZHMgd2lkdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGFiZWxzIGxlZ2VuZCBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBudW1iZXJ9fSBsYWJlbFRoZW1lIGxlZ2VuZCBsYWJlbCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlTGVnZW5kc1dpZHRoU3VtOiBmdW5jdGlvbihsYWJlbHMsIGxhYmVsVGhlbWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5zdW0odHVpLnV0aWwubWFwKGxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9tYWtlTGVnZW5kV2lkdGgocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGFiZWwsIGxhYmVsVGhlbWUpKTtcbiAgICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgbGVnZW5kIGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBsYWJlbHMgbGVnZW5kIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBkaXZpc2lvbiBjb3VudFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPHN0cmluZz4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RpdmlkZUxlZ2VuZExhYmVsczogZnVuY3Rpb24obGFiZWxzLCBjb3VudCkge1xuICAgICAgICB2YXIgbGltaXRDb3VudCA9IE1hdGgucm91bmQobGFiZWxzLmxlbmd0aCAvIGNvdW50KSxcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgIHRlbXAgPSBbXTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkobGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgaWYgKHRlbXAubGVuZ3RoIDwgbGltaXRDb3VudCkge1xuICAgICAgICAgICAgICAgIHRlbXAucHVzaChsYWJlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgICAgICB0ZW1wID0gW2xhYmVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRlbXAubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGVtcCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IG1heCBsaW5lIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGRpdmlkZWRMYWJlbHMgLSBkaXZpZGVkIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7e2ZvbnRGYW1pbHk6ID9zdHJpbmcsIGZvbnRTaXplOiA/c3RyaW5nfX0gbGFiZWxUaGVtZSAtIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRNYXhMaW5lV2lkdGg6IGZ1bmN0aW9uKGRpdmlkZWRMYWJlbHMsIGxhYmVsVGhlbWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbGluZVdpZHRocyA9IHR1aS51dGlsLm1hcChkaXZpZGVkTGFiZWxzLCBmdW5jdGlvbihfbGFiZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY2FsY3VsYXRlTGVnZW5kc1dpZHRoU3VtKF9sYWJlbHMsIGxhYmVsVGhlbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWF4KGxpbmVXaWR0aHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRpdmlzaW9uIGxhYmVscyBhbmQgbWF4IGxpbmUgd2lkdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGFiZWxzIGxlZ2VuZCBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhcnRXaWR0aCBjaGFydCB3aWR0aFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IG51bWJlcn19IGxhYmVsVGhlbWUgbGVnZW5kIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge3tkaXZpZGVkTGFiZWxzOiBBcnJheS48QXJyYXkuPHN0cmluZz4+LCBtYXhMaW5lV2lkdGg6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZURpdmlkZWRMYWJlbHNBbmRNYXhMaW5lV2lkdGg6IGZ1bmN0aW9uKGxhYmVscywgY2hhcnRXaWR0aCwgbGFiZWxUaGVtZSkge1xuICAgICAgICB2YXIgZGl2aWRlQ291bnQgPSAxLFxuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gMCxcbiAgICAgICAgICAgIHByZXZNYXhXaWR0aCA9IDAsXG4gICAgICAgICAgICBkaXZpZGVkTGFiZWxzLCBwcmV2TGFiZWxzO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRpdmlkZWRMYWJlbHMgPSB0aGlzLl9kaXZpZGVMZWdlbmRMYWJlbHMobGFiZWxzLCBkaXZpZGVDb3VudCk7XG4gICAgICAgICAgICBtYXhMaW5lV2lkdGggPSB0aGlzLl9nZXRNYXhMaW5lV2lkdGgoZGl2aWRlZExhYmVscywgbGFiZWxUaGVtZSk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2TWF4V2lkdGggPT09IG1heExpbmVXaWR0aCkge1xuICAgICAgICAgICAgICAgIGRpdmlkZWRMYWJlbHMgPSBwcmV2TGFiZWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2TWF4V2lkdGggPSBtYXhMaW5lV2lkdGg7XG4gICAgICAgICAgICBwcmV2TGFiZWxzID0gZGl2aWRlZExhYmVscztcbiAgICAgICAgICAgIGRpdmlkZUNvdW50ICs9IDE7XG4gICAgICAgIH0gd2hpbGUgKG1heExpbmVXaWR0aCA+PSBjaGFydFdpZHRoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGl2aWRlZExhYmVsczogZGl2aWRlZExhYmVscyxcbiAgICAgICAgICAgIG1heExpbmVXaWR0aDogbWF4TGluZVdpZHRoXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBoZWlnaHQgb2YgaG9yaXpvbnRhbCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHN0cmluZz4+fSBkaXZpZGVkTGFiZWxzIGRpdmlkZWQgbGFiZWxzXG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogbnVtYmVyfX0gbGFiZWxUaGVtZSBsZWdlbmQgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZUhvcml6b250YWxMZWdlbmRIZWlnaHQ6IGZ1bmN0aW9uKGRpdmlkZWRMYWJlbHMsIGxhYmVsVGhlbWUpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLnN1bSh0dWkudXRpbC5tYXAoZGl2aWRlZExhYmVscywgZnVuY3Rpb24obGFiZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsc01heEhlaWdodChsYWJlbHMsIGxhYmVsVGhlbWUpO1xuICAgICAgICB9KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZGltZW5zaW9uIG9mIGhvcml6b250YWwgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFydFdpZHRoIGNoYXJ0IHdpZHRoXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IChudW1iZXIpfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbERpbWVuc2lvbjogZnVuY3Rpb24oY2hhcnRXaWR0aCkge1xuICAgICAgICB2YXIgbGFiZWxUaGVtZSA9IHRoaXMudGhlbWUubGFiZWwsXG4gICAgICAgICAgICBsYWJlbHNBbmRNYXhXaWR0aCA9IHRoaXMuX21ha2VEaXZpZGVkTGFiZWxzQW5kTWF4TGluZVdpZHRoKHRoaXMubGVnZW5kTGFiZWxzLCBjaGFydFdpZHRoLCBsYWJlbFRoZW1lKSxcbiAgICAgICAgICAgIGhvcml6b250YWxMZWdlbmRIZWlnaHQgPSB0aGlzLl9jYWxjdWxhdGVIb3Jpem9udGFsTGVnZW5kSGVpZ2h0KGxhYmVsc0FuZE1heFdpZHRoLmRpdmlkZWRMYWJlbHMsIGxhYmVsVGhlbWUpLFxuICAgICAgICAgICAgbGVnZW5kSGVpZ2h0ID0gaG9yaXpvbnRhbExlZ2VuZEhlaWdodCArIChjaGFydENvbnN0LkxFR0VORF9BUkVBX1BBRERJTkcgKiAyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KGxhYmVsc0FuZE1heFdpZHRoLm1heExpbmVXaWR0aCwgY2hhcnRDb25zdC5NSU5fTEVHRU5EX1dJRFRIKSxcbiAgICAgICAgICAgIGhlaWdodDogbGVnZW5kSGVpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZGltZW5zaW9uIG9mIHZlcnRpY2FsIGxlZ2VuZC5cbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiAobnVtYmVyKX19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1heExhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxzTWF4V2lkdGgodGhpcy5sZWdlbmRMYWJlbHMsIHRoaXMudGhlbWUubGFiZWwpO1xuICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSB0aGlzLl9tYWtlTGVnZW5kV2lkdGgobWF4TGFiZWxXaWR0aCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBsZWdlbmRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxlZ2VuZCBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYXJ0V2lkdGggY2hhcnQgd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX1cbiAgICAgKi9cbiAgICBtYWtlRGltZW5zaW9uOiBmdW5jdGlvbihjaGFydFdpZHRoKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB7fTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy52aXNpYmxlKSB7XG4gICAgICAgICAgICBkaW1lbnNpb24ud2lkdGggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWRpY2F0ZS5pc0hvcml6b250YWxMZWdlbmQodGhpcy5vcHRpb25zLmFsaWduKSkge1xuICAgICAgICAgICAgZGltZW5zaW9uID0gdGhpcy5fbWFrZUhvcml6b250YWxEaW1lbnNpb24oY2hhcnRXaWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSB0aGlzLl9tYWtlVmVydGljYWxEaW1lbnNpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaW1lbnNpb247XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGVnZW5kRGltZW5zaW9uTW9kZWw7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTGVnZW5kTW9kZWwgaXMgbGVnZW5kIG1vZGVsLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0VGhlbWUgPSByZXF1aXJlKCcuLi90aGVtZXMvZGVmYXVsdFRoZW1lJyk7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG52YXIgTGVnZW5kTW9kZWwgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIExlZ2VuZE1vZGVsLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTGVnZW5kTW9kZWwgaXMgbGVnZW5kIG1vZGVsLlxuICAgICAqIEBjb25zdHJ1Y3RzIExlZ2VuZE1vZGVsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxhYmVscyBsZWdlbmQgbGFiZWxzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmJvdW5kIGF4aXMgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogbGVnZW5kIHRoZW1lXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRoZW1lID0gcGFyYW1zLnRoZW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsZWdlbmQgbGFiZWxzXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPiB8IHtjb2x1bW46ID9BcnJheS48c3RyaW5nPiwgbGluZTogP0FycmF5LjxzdHJpbmc+fX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFiZWxzID0gcGFyYW1zLmxhYmVscztcblxuICAgICAgICAvKipcbiAgICAgICAgICogbGFiZWwgaW5mb3NcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljx7Y2hhcnRUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ9Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVnZW5kRGF0YSA9IHBhcmFtcy5sZWdlbmREYXRhO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCB0eXBlc1xuICAgICAgICAgKiBAdHlwZSB7P0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJpZXNOYW1lcyA9IHBhcmFtcy5zZXJpZXNOYW1lcyB8fCBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhcnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZWdlbmQgZGF0YVxuICAgICAgICAgKiBAdHlwZSB7P0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0ZWQgbGVnZW5kIGluZGV4LlxuICAgICAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlbmRpbmcgZGF0YSB0byBzZXJpZXNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tlZEluZGV4ZXNNYXAgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hlY2tlZCBpbmRleGVzXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tlZFdob2xlSW5kZXhlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2luaXRDaGVja2VkSW5kZXhlcygpO1xuICAgICAgICB0aGlzLl9zZXREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgY2hlY2tlZCBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRDaGVja2VkSW5kZXhlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGVja2VkV2hvbGVJbmRleGVzID0gW107XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmxlZ2VuZERhdGEsIGZ1bmN0aW9uKGxlZ2VuZERhdHVtLCBpbmRleCkge1xuICAgICAgICAgICAgY2hlY2tlZFdob2xlSW5kZXhlc1tpbmRleF0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGVja2VkV2hvbGVJbmRleGVzID0gY2hlY2tlZFdob2xlSW5kZXhlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsYWJlbCBpbmZvIHRoYXQgYXBwbGllZCB0aGVtZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBsZWdlbmREYXRhIGxlZ2VuZCBkYXRhXG4gICAgICogQHBhcmFtIHt7Y29sb3JzOiBBcnJheS48bnVtYmVyPiwgc2luZ2xlQ29sb3I6ID9zdHJpbmcsIGJvcmRlcmNvbG9yOiA/c3RyaW5nfX0gdGhlbWUgbGVnZW5kIHRoZW1lXG4gICAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IGNoZWNrZWRJbmRleGVzIGNoZWNrZWQgaW5kZXhlc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gbGFiZWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxhYmVsSW5mb0FwcGxpZWRUaGVtZTogZnVuY3Rpb24obGVnZW5kRGF0YSwgdGhlbWUsIGNoZWNrZWRJbmRleGVzKSB7XG4gICAgICAgIHZhciBzZXJpZXNJbmRleCA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChsZWdlbmREYXRhLCBmdW5jdGlvbihkYXR1bSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtVGhlbWUgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHRoZW1lLmNvbG9yc1tpbmRleF1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aGVtZS5zaW5nbGVDb2xvcnMgJiYgdGhlbWUuc2luZ2xlQ29sb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGl0ZW1UaGVtZS5zaW5nbGVDb2xvciA9IHRoZW1lLnNpbmdsZUNvbG9yc1tpbmRleF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGVtZS5ib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgIGl0ZW1UaGVtZS5ib3JkZXJDb2xvciA9IHRoZW1lLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXR1bS50aGVtZSA9IGl0ZW1UaGVtZTtcbiAgICAgICAgICAgIGRhdHVtLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICAgIGlmICghY2hlY2tlZEluZGV4ZXMgfHwgIXR1aS51dGlsLmlzVW5kZWZpbmVkKGNoZWNrZWRJbmRleGVzW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBkYXR1bS5zZXJpZXNJbmRleCA9IHNlcmllc0luZGV4O1xuICAgICAgICAgICAgICAgIHNlcmllc0luZGV4ICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdHVtLnNlcmllc0luZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXR1bTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBsZWdlbmQgZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbGVnZW5kRGF0YSA9IHRoaXMubGVnZW5kRGF0YTtcbiAgICAgICAgdmFyIGRhdGEsIGRlZmF1bHRMZWdlbmRUaGVtZSwgc3RhcnRJbmRleCwgc3RhcnRUaGVtZUluZGV4O1xuXG4gICAgICAgIGlmICghdGhpcy5zZXJpZXNOYW1lcyB8fCB0aGlzLnNlcmllc05hbWVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9tYWtlTGFiZWxJbmZvQXBwbGllZFRoZW1lKGxlZ2VuZERhdGEsIHRoaXMudGhlbWUsIHRoaXMuY2hlY2tlZEluZGV4ZXNNYXBbdGhpcy5jaGFydFR5cGVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAgICAgc3RhcnRUaGVtZUluZGV4ID0gMDtcbiAgICAgICAgICAgIGRlZmF1bHRMZWdlbmRUaGVtZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcnM6IGRlZmF1bHRUaGVtZS5zZXJpZXMuY29sb3JzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YSA9IGNvbmNhdC5hcHBseShbXSwgdHVpLnV0aWwubWFwKHRoaXMuc2VyaWVzTmFtZXMsIGZ1bmN0aW9uKHNlcmllc05hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhcnRUaGVtZSA9IHNlbGYudGhlbWVbc2VyaWVzTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsTGVuID0gc2VsZi5sYWJlbHNbc2VyaWVzTmFtZV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyBsYWJlbExlbjtcbiAgICAgICAgICAgICAgICB2YXIgc2xpY2VkTGVnZW5kRGF0YSwgY2hlY2tlZEluZGV4ZXMsIHRoZW1lRW5kSW5kZXgsIGRhdHVtO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjaGFydFRoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZW1lRW5kSW5kZXggPSBzdGFydFRoZW1lSW5kZXggKyBsYWJlbExlbjtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRUaGVtZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGVmYXVsdExlZ2VuZFRoZW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0VGhlbWUuY29sb3JzID0gY2hhcnRUaGVtZS5jb2xvcnMuc2xpY2Uoc3RhcnRUaGVtZUluZGV4LCB0aGVtZUVuZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaGVtZUluZGV4ID0gdGhlbWVFbmRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzbGljZWRMZWdlbmREYXRhID0gbGVnZW5kRGF0YS5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgICAgICAgICAgY2hlY2tlZEluZGV4ZXMgPSBzZWxmLmNoZWNrZWRJbmRleGVzTWFwW3Nlcmllc05hbWVdO1xuICAgICAgICAgICAgICAgIGRhdHVtID0gc2VsZi5fbWFrZUxhYmVsSW5mb0FwcGxpZWRUaGVtZShzbGljZWRMZWdlbmREYXRhLCBjaGFydFRoZW1lLCBjaGVja2VkSW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IGVuZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdHVtO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxlZ2VuZCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e2NoYXJ0VHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nLCB0aGVtZTogb2JqZWN0fT59IGxlZ2VuZCBkYXRhXG4gICAgICovXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBsZWdlbmQgZGF0dW0gYnkgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGxlZ2VuZCBpbmRleFxuICAgICAqIEByZXR1cm5zIHt7Y2hhcnRUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcsIHRoZW1lOiBvYmplY3R9fSBsZWdlbmQgZGF0dW1cbiAgICAgKi9cbiAgICBnZXREYXR1bTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzZWxlY3RlZCBkYXR1bS5cbiAgICAgKiBAcmV0dXJucyB7e2NoYXJ0VHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nLCB0aGVtZTogT2JqZWN0fX0gbGVnZW5kIGRhdHVtXG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWREYXR1bTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdHVtKHRoaXMuc2VsZWN0ZWRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzZWxlY3RlZCBpbmRleC5cbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlU2VsZWN0ZWRJbmRleDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBzZWxlY3RlZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggbGVnZW5kIGluZGV4XG4gICAgICovXG4gICAgdG9nZ2xlU2VsZWN0ZWRJbmRleDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZEluZGV4KHNlbGVjdGVkSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VsZWN0ZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gc2VsZWN0ZWQgaW5kZXhcbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZEluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRJbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB1bnNlbGVjdGVkIGluZGV4IG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggbGVnZW5kIGluZGV4XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBpc1Vuc2VsZWN0ZWRJbmRleDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICF0dWkudXRpbC5pc051bGwodGhpcy5zZWxlY3RlZEluZGV4KSAmJiAodGhpcy5zZWxlY3RlZEluZGV4ICE9PSBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hlY2tlZCBzZWxlY3RlZCBpbmRleCBvciBub3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgY2hlY2tlZFxuICAgICAqL1xuICAgIGlzQ2hlY2tlZFNlbGVjdGVkSW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NoZWNrZWRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hlY2tlZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggbGVnZW5kIGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2hlY2tlZEluZGV4OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB0aGlzLmNoZWNrZWRXaG9sZUluZGV4ZXNbaW5kZXhdID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjaGVja2VkIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBjaGVja2VkXG4gICAgICovXG4gICAgaXNDaGVja2VkSW5kZXg6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuY2hlY2tlZFdob2xlSW5kZXhlc1tpbmRleF07XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQWRkIHNlbmRpbmcgZGF0dW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGxlZ2VuZCBpbmRleFxuICAgICAqL1xuICAgIF9hZGRTZW5kaW5nRGF0dW06IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBsZWdlbmREYXR1bSA9IHRoaXMuZ2V0RGF0dW0oaW5kZXgpO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tlZEluZGV4ZXNNYXBbbGVnZW5kRGF0dW0uY2hhcnRUeXBlXSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja2VkSW5kZXhlc01hcFtsZWdlbmREYXR1bS5jaGFydFR5cGVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja2VkSW5kZXhlc01hcFtsZWdlbmREYXR1bS5jaGFydFR5cGVdW2xlZ2VuZERhdHVtLmluZGV4XSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHNlbGVjdGVkIGluZGV4O1xuICAgICAqL1xuICAgIGNoZWNrU2VsZWN0ZWRJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoZWNrZWRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpO1xuICAgICAgICB0aGlzLl9hZGRTZW5kaW5nRGF0dW0odGhpcy5zZWxlY3RlZEluZGV4KTtcbiAgICAgICAgdGhpcy5fc2V0RGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2hlY2tlZCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHt7Y29sdW1uOiA/QXJyYXkuPGJvb2xlYW4+LCBsaW5lOiA/QXJyYXkuPGJvb2xlYW4+fSB8IEFycmF5Ljxib29sZWFuPn0gc2VuZGluZyBkYXRhXG4gICAgICovXG4gICAgZ2V0Q2hlY2tlZEluZGV4ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja2VkSW5kZXhlc01hcFt0aGlzLmNoYXJ0VHlwZV0gfHwgdGhpcy5jaGVja2VkSW5kZXhlc01hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgY2hlY2tlZCBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0Q2hlY2tlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoZWNrZWRXaG9sZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGVja2VkSW5kZXhlc01hcCA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hlY2tlZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGluZGV4ZXMgaW5keGVzXG4gICAgICovXG4gICAgdXBkYXRlQ2hlY2tlZERhdGE6IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3Jlc2V0Q2hlY2tlZERhdGEoKTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICBzZWxmLl91cGRhdGVDaGVja2VkSW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgc2VsZi5fYWRkU2VuZGluZ0RhdHVtKGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NldERhdGEoKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZWdlbmRNb2RlbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIHRlbXBsYXRlcyBvZiBsZWdlbmQgdmlldy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVtcGxhdGVNYWtlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdGVtcGxhdGVNYWtlcicpO1xuXG52YXIgaHRtbHMgPSB7XG4gICAgSFRNTF9DSEVDS0JPWDogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbGVnZW5kLWNoZWNrYm94LWFyZWFcIj48aW5wdXQgY2xhc3M9XCJ0dWktY2hhcnQtbGVnZW5kLWNoZWNrYm94XCInICtcbiAgICAgICAgJyB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cInt7IGluZGV4IH19XCJ7eyBjaGVja2VkIH19IC8+PC9kaXY+JyxcbiAgICBIVE1MX0xFR0VORDogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbGVnZW5ke3sgdW5zZWxlY3RlZCB9fVwiIHN0eWxlPVwiaGVpZ2h0Ont7IGhlaWdodCB9fXB4XCI+JyArXG4gICAgICAgICd7eyBjaGVja2JveCB9fTxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbGVnZW5kLXJlY3Qge3sgaWNvblR5cGUgfX1cIiBzdHlsZT1cInt7IHJlY3RDc3NUZXh0IH19XCI+PC9kaXY+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LWxlZ2VuZC1sYWJlbFwiIHN0eWxlPVwiaGVpZ2h0Ont7IGxhYmVsSGVpZ2h0IH19cHh7eyBsYWJlbFdpZHRoIH19XCInICtcbiAgICAgICAgICAgICcgZGF0YS1pbmRleD1cInt7IGluZGV4IH19XCI+e3sgbGFiZWwgfX08L2Rpdj48L2Rpdj4nLFxuICAgIEhUTUxfVElDSzogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbWFwLWxlZ2VuZC10aWNrXCIgc3R5bGU9XCJ7eyBwb3NpdGlvbiB9fVwiPjwvZGl2PicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1tYXAtbGVnZW5kLXRpY2stbGFiZWxcIiBzdHlsZT1cInt7IGxhYmVsUG9zaXRpb24gfX1cIj57eyBsYWJlbCB9fTwvZGl2PicsXG4gICAgSFRNTF9DSVJDTEVfTEVHRU5EX0xBQkVMOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1jaXJjbGUtbGVnZW5kLWxhYmVsXCInICtcbiAgICAgICAgICAgICcgc3R5bGU9XCJsZWZ0OiB7eyBsZWZ0IH19cHg7dG9wOiB7eyB0b3AgfX1weFwiPnt7IGxhYmVsIH19PC9kaXY+J1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdHBsQ2hlY2tib3g6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9DSEVDS0JPWCksXG4gICAgdHBsTGVnZW5kOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfTEVHRU5EKSxcbiAgICB0cGxUaWNrOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfVElDSyksXG4gICAgdHBsQ2lyY2xlTGVnZW5kTGFiZWw6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9DSVJDTEVfTEVHRU5EX0xBQkVMKVxufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgU3BlY3RydW0gTGVnZW5kIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcbnZhciBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKTtcbnZhciByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG52YXIgcGx1Z2luRmFjdG9yeSA9IHJlcXVpcmUoJy4uL2ZhY3Rvcmllcy9wbHVnaW5GYWN0b3J5Jyk7XG52YXIgbGVnZW5kVGVtcGxhdGUgPSByZXF1aXJlKCcuLy4uL2xlZ2VuZHMvbGVnZW5kVGVtcGxhdGUnKTtcblxudmFyIFNwZWN0cnVtTGVnZW5kID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBTcGVjdHJ1bUxlZ2VuZC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFNwZWN0cnVtIExlZ2VuZCBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgU3BlY3RydW1MZWdlbmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqICAgICAgQHBhcmFtIHs/QXJyYXkuPHN0cmluZz59IHBhcmFtcy5vcHRpb25zIGxlZ2VuZCBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge01hcENoYXJ0RGF0YVByb2Nlc3Nvcn0gcGFyYW1zLmRhdGFQcm9jZXNzb3IgZGF0YSBwcm9jZXNzb3JcbiAgICAgKiAgICAgIEBwYXJhbSB7Qm91bmRzTWFrZXJ9IHBhcmFtcy5ib3VuZHNNYWtlciBib3VuZHMgbWFrZXJcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxpYlR5cGUgPSBwYXJhbXMubGliVHlwZSB8fCBjaGFydENvbnN0LkRFRkFVTFRfUExVR0lOO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbGFzcyBuYW1lLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWNoYXJ0LWxlZ2VuZC1hcmVhJztcblxuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IHBhcmFtcy5jaGFydFR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxlZ2VuZCB0aGVtZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IHBhcmFtcy50aGVtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogb3B0aW9uc1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gcGFyYW1zLm9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcHJvY2Vzc29yXG4gICAgICAgICAqIEB0eXBlIHtEYXRhUHJvY2Vzc29yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gcGFyYW1zLmRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaCByZW5kZXJlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyID0gcGx1Z2luRmFjdG9yeS5nZXQobGliVHlwZSwgJ21hcExlZ2VuZCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIGhvcml6b250YWwgbGVnZW5kIG9yIG5vdC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzSG9yaXpvbnRhbCA9IHByZWRpY2F0ZS5pc0hvcml6b250YWxMZWdlbmQodGhpcy5vcHRpb25zLmFsaWduKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB2ZXJ0aWNhbCBsZWdlbmQgZGltZW5zaW9uLlxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmVydGljYWxEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWF4VmFsdWUgPSB0dWkudXRpbC5tYXgodGhpcy5kYXRhUHJvY2Vzc29yLmdldFZhbHVlcygpKTtcbiAgICAgICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGb3JtYXRGdW5jdGlvbnMoKTtcbiAgICAgICAgdmFyIHZhbHVlU3RyID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZShtYXhWYWx1ZSwgZm9ybWF0RnVuY3Rpb25zLCB0aGlzLmNoYXJ0VHlwZSwgJ2xlZ2VuZCcpO1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKHZhbHVlU3RyLCB0aGlzLnRoZW1lLmxhYmVsKTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBjaGFydENvbnN0LkxFR0VORF9BUkVBX1BBRERJTkcgKyBjaGFydENvbnN0Lk1BUF9MRUdFTkRfTEFCRUxfUEFERElORztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IGNoYXJ0Q29uc3QuTUFQX0xFR0VORF9HUkFQSF9TSVpFICsgbGFiZWxXaWR0aCArIHBhZGRpbmcsXG4gICAgICAgICAgICBoZWlnaHQ6IGNoYXJ0Q29uc3QuTUFQX0xFR0VORF9TSVpFXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaG9yaXpvbnRhbCBsZWdlbmQgZGltZW5zaW9uXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VIb3Jpem9udGFsRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gdHVpLnV0aWwubWF4KHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZXMoKSksXG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChtYXhWYWx1ZSwgdGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBwYWRkaW5nID0gY2hhcnRDb25zdC5MRUdFTkRfQVJFQV9QQURESU5HICsgY2hhcnRDb25zdC5NQVBfTEVHRU5EX0xBQkVMX1BBRERJTkc7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBjaGFydENvbnN0Lk1BUF9MRUdFTkRfU0laRSxcbiAgICAgICAgICAgIGhlaWdodDogY2hhcnRDb25zdC5NQVBfTEVHRU5EX0dSQVBIX1NJWkUgKyBsYWJlbEhlaWdodCArIHBhZGRpbmdcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgZGltZW5zaW9uLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbjtcblxuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHRoaXMuX21ha2VIb3Jpem9udGFsRGltZW5zaW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSB0aGlzLl9tYWtlVmVydGljYWxEaW1lbnNpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCYXNlRGltZW5zaW9uKCdsZWdlbmQnLCBkaW1lbnNpb24pO1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyLnJlZ2lzdGVyQmFzZURpbWVuc2lvbignY2FsY3VsYXRpb25MZWdlbmQnLCBkaW1lbnNpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJhc2UgZGF0YSB0byBtYWtlIHRpY2sgaHRtbC5cbiAgICAgKiBAcmV0dXJucyB7e3N0YXJ0UG9zaXRpb25WYWx1ZTogbnVtYmVyLCBzdGVwOiBudW1iZXIsIHBvc2l0aW9uVHlwZTogc3RyaW5nLCBsYWJlbFNpemU6ID9udW1iZXJ9fSBiYXNlIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQmFzZURhdGFUb01ha2VUaWNrSHRtbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignbGVnZW5kJyksXG4gICAgICAgICAgICBzdGVwQ291bnQgPSB0aGlzLmF4ZXNEYXRhLnRpY2tDb3VudCAtIDEsXG4gICAgICAgICAgICBiYXNlRGF0YSA9IHt9LFxuICAgICAgICAgICAgZmlyc3RMYWJlbDtcblxuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIGJhc2VEYXRhLnN0YXJ0UG9zaXRpb25WYWx1ZSA9IDU7XG4gICAgICAgICAgICBiYXNlRGF0YS5zdGVwID0gZGltZW5zaW9uLndpZHRoIC8gc3RlcENvdW50O1xuICAgICAgICAgICAgYmFzZURhdGEucG9zaXRpb25UeXBlID0gJ2xlZnQ6JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VEYXRhLnN0YXJ0UG9zaXRpb25WYWx1ZSA9IDA7XG4gICAgICAgICAgICBiYXNlRGF0YS5zdGVwID0gZGltZW5zaW9uLmhlaWdodCAvIHN0ZXBDb3VudDtcbiAgICAgICAgICAgIGJhc2VEYXRhLnBvc2l0aW9uVHlwZSA9ICd0b3A6JztcbiAgICAgICAgICAgIGZpcnN0TGFiZWwgPSB0aGlzLmF4ZXNEYXRhLmxhYmVsc1swXTtcbiAgICAgICAgICAgIGJhc2VEYXRhLmxhYmVsU2l6ZSA9IHBhcnNlSW50KHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChmaXJzdExhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSAvIDIsIDEwKSAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmFzZURhdGE7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNYWtlIHRpY2sgaHRtbC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aWNrIGh0bWwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRpY2tIdG1sOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgYmFzZURhdGEgPSB0aGlzLl9tYWtlQmFzZURhdGFUb01ha2VUaWNrSHRtbCgpLFxuICAgICAgICAgICAgcG9zaXRpb25WYWx1ZSA9IGJhc2VEYXRhLnN0YXJ0UG9zaXRpb25WYWx1ZSxcbiAgICAgICAgICAgIGh0bWxzO1xuXG4gICAgICAgIGh0bWxzID0gdHVpLnV0aWwubWFwKHRoaXMuYXhlc0RhdGEubGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsU2l6ZSwgaHRtbDtcblxuICAgICAgICAgICAgaWYgKHNlbGYuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxTaXplID0gcGFyc2VJbnQocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGFiZWwsIHNlbGYudGhlbWUubGFiZWwpIC8gMiwgMTApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYWJlbFNpemUgPSBiYXNlRGF0YS5sYWJlbFNpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh0bWwgPSBsZWdlbmRUZW1wbGF0ZS50cGxUaWNrKHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogYmFzZURhdGEucG9zaXRpb25UeXBlICsgcG9zaXRpb25WYWx1ZSArICdweCcsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogYmFzZURhdGEucG9zaXRpb25UeXBlICsgKHBvc2l0aW9uVmFsdWUgLSBsYWJlbFNpemUpICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwb3NpdGlvblZhbHVlICs9IGJhc2VEYXRhLnN0ZXA7XG5cbiAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaHRtbHMuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aWNrIGFyZWEuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB0aWNrIGNvdW50YWluZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJUaWNrQXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aWNrQ29udGFpbmVyID0gZG9tLmNyZWF0ZSgnZGl2JywgJ3R1aS1jaGFydC1sZWdlbmQtdGljay1hcmVhJyk7XG5cbiAgICAgICAgdGlja0NvbnRhaW5lci5pbm5lckhUTUwgPSB0aGlzLl9tYWtlVGlja0h0bWwoKTtcblxuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyh0aWNrQ29udGFpbmVyLCAnaG9yaXpvbnRhbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRpY2tDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZ3JhcGggZGltZW5zaW9uIG9mIHZlcnRpY2FsIGxlZ2VuZFxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmVydGljYWxHcmFwaERpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogY2hhcnRDb25zdC5NQVBfTEVHRU5EX0dSQVBIX1NJWkUsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdsZWdlbmQnKS5oZWlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBncmFwaCBkaW1lbnNpb24gb2YgaG9yaXpvbnRhbCBsZWdlbmRcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUhvcml6b250YWxHcmFwaERpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2xlZ2VuZCcpLndpZHRoICsgMTAsXG4gICAgICAgICAgICBoZWlnaHQ6IGNoYXJ0Q29uc3QuTUFQX0xFR0VORF9HUkFQSF9TSVpFXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBncmFwaC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJHcmFwaDogZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb247XG5cbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSB0aGlzLl9tYWtlSG9yaXpvbnRhbEdyYXBoRGltZW5zaW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSB0aGlzLl9tYWtlVmVydGljYWxHcmFwaERpbWVuc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlbmRlcihjb250YWluZXIsIGRpbWVuc2lvbiwgdGhpcy5jb2xvclNwZWN0cnVtLCB0aGlzLmlzSG9yaXpvbnRhbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBsZWdlbmQgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgbGVnZW5kIGNvbnRhaW5lclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckxlZ2VuZEFyZWE6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgdGlja0NvbnRhaW5lcjtcblxuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24oY29udGFpbmVyLCB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKCdsZWdlbmQnKSk7XG4gICAgICAgIHRoaXMuX3JlbmRlckdyYXBoKGNvbnRhaW5lcik7XG4gICAgICAgIHRpY2tDb250YWluZXIgPSB0aGlzLl9yZW5kZXJUaWNrQXJlYSgpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGlja0NvbnRhaW5lcik7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ICs9ICc7JyArIHJlbmRlclV0aWwubWFrZUZvbnRDc3NUZXh0KHRoaXMudGhlbWUubGFiZWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbGVnZW5kIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3tjb2xvclNwZWN0cnVtOiBDb2xvclNwZWN0cnVtLCBheGVzRGF0YTogb2JqZWN0fX0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gbGVnZW5kIGVsZW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKTtcblxuICAgICAgICB0aGlzLmxlZ2VuZENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb2xvclNwZWN0cnVtID0gZGF0YS5jb2xvclNwZWN0cnVtO1xuICAgICAgICB0aGlzLmF4ZXNEYXRhID0gZGF0YS5heGVzRGF0YTtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kQXJlYShjb250YWluZXIpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBsZWdlbmQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckxlZ2VuZEFyZWEodGhpcy5sZWdlbmRDb250YWluZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBzaG93IHdlZGdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyByYXRpb1xuICAgICAqL1xuICAgIG9uU2hvd1dlZGdlOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd1dlZGdlKGNoYXJ0Q29uc3QuTUFQX0xFR0VORF9TSVpFICogcmF0aW8pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBoaWRlIHdlZGdlLlxuICAgICAqL1xuICAgIG9uSGlkZVdlZGdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLmhpZGVXZWRnZSgpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oU3BlY3RydW1MZWdlbmQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwZWN0cnVtTGVnZW5kO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFBsb3QgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxjdWxhdG9yJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIHBsb3RUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vcGxvdFRlbXBsYXRlJyk7XG5cbnZhciBQbG90ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBQbG90LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUGxvdCBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgUGxvdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52VGlja0NvdW50IHZlcnRpY2FsIHRpY2sgY291bnRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuaFRpY2tDb3VudCBob3Jpem9udGFsIHRpY2sgY291bnRcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUGxvdCB2aWV3IGNsYXNzTmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWNoYXJ0LXBsb3QtYXJlYSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNob3dMaW5lID0gdHVpLnV0aWwuaXNVbmRlZmluZWQodGhpcy5vcHRpb25zLnNob3dMaW5lKSA/IHRydWUgOiB0aGlzLm9wdGlvbnMuc2hvd0xpbmU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZW1lXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRoZW1lID0gcGFyYW1zLnRoZW1lIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbG90IGRhdGEuXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHBsb3QgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwbG90Q29udGFpbmVyIHBsb3QgYXJlYSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJQbG90QXJlYTogZnVuY3Rpb24ocGxvdENvbnRhaW5lciwgZGF0YSkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3Bsb3QnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckRpbWVuc2lvbihwbG90Q29udGFpbmVyLCBkaW1lbnNpb24pO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKHBsb3RDb250YWluZXIsIHRoaXMuYm91bmRzTWFrZXIuZ2V0UG9zaXRpb24oJ3Bsb3QnKSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTGluZXMocGxvdENvbnRhaW5lciwgZGltZW5zaW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgcGxvdCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHBsb3QgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgICB0aGlzLl9yZW5kZXJQbG90QXJlYShjb250YWluZXIsIGRhdGEpO1xuICAgICAgICB0aGlzLnBsb3RDb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVyZW5kZXIuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgcmVuZGVyaW5nXG4gICAgICovXG4gICAgcmVyZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5wbG90Q29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLl9yZW5kZXJQbG90QXJlYSh0aGlzLnBsb3RDb250YWluZXIsIGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgcGxvdCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXJlbmRlcihkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHBsb3QgbGluZXMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIHBsb3QgYXJlYSBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJMaW5lczogZnVuY3Rpb24oZWwsIGRpbWVuc2lvbikge1xuICAgICAgICB2YXIgaFBvc2l0aW9ucyA9IHRoaXMuX21ha2VIb3Jpem9udGFsUGl4ZWxQb3NpdGlvbnMoZGltZW5zaW9uLndpZHRoKSxcbiAgICAgICAgICAgIHZQb3NpdGlvbnMgPSB0aGlzLl9tYWtlVmVydGljYWxQaXhlbFBvc2l0aW9ucyhkaW1lbnNpb24uaGVpZ2h0KSxcbiAgICAgICAgICAgIHRoZW1lID0gdGhpcy50aGVtZSxcbiAgICAgICAgICAgIGxpbmVIdG1sID0gJyc7XG5cbiAgICAgICAgbGluZUh0bWwgKz0gdGhpcy5fbWFrZUxpbmVIdG1sKHtcbiAgICAgICAgICAgIHBvc2l0aW9uczogaFBvc2l0aW9ucyxcbiAgICAgICAgICAgIHNpemU6IGRpbWVuc2lvbi5oZWlnaHQsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd2ZXJ0aWNhbCcsXG4gICAgICAgICAgICBwb3NpdGlvblR5cGU6ICdsZWZ0JyxcbiAgICAgICAgICAgIHNpemVUeXBlOiAnaGVpZ2h0JyxcbiAgICAgICAgICAgIGxpbmVDb2xvcjogdGhlbWUubGluZUNvbG9yXG4gICAgICAgIH0pO1xuICAgICAgICBsaW5lSHRtbCArPSB0aGlzLl9tYWtlTGluZUh0bWwoe1xuICAgICAgICAgICAgcG9zaXRpb25zOiB2UG9zaXRpb25zLFxuICAgICAgICAgICAgc2l6ZTogZGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICBwb3NpdGlvblR5cGU6ICdib3R0b20nLFxuICAgICAgICAgICAgc2l6ZVR5cGU6ICd3aWR0aCcsXG4gICAgICAgICAgICBsaW5lQ29sb3I6IHRoZW1lLmxpbmVDb2xvclxuICAgICAgICB9KTtcblxuICAgICAgICBlbC5pbm5lckhUTUwgPSBsaW5lSHRtbDtcblxuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckJhY2tncm91bmQoZWwsIHRoZW1lLmJhY2tncm91bmQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGh0bWwgb2YgcGxvdCBsaW5lLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gcGFyYW1zLnBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc2l6ZSB3aWR0aCBvciBoZWlnaHRcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2xhc3NOYW1lIGxpbmUgY2xhc3NOYW1lXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBvc2l0aW9uVHlwZSBwb3NpdGlvbiB0eXBlIChsZWZ0IG9yIGJvdHRvbSlcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2l6ZVR5cGUgc2l6ZSB0eXBlIChzaXplIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubGluZUNvbG9yIGxpbmUgY29sb3JcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxpbmVIdG1sOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gcGxvdFRlbXBsYXRlLnRwbFBsb3RMaW5lO1xuICAgICAgICB2YXIgbGluZUh0bWwgPSB0dWkudXRpbC5tYXAocGFyYW1zLnBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBjc3NUZXh0cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVXRpbC5jb25jYXRTdHIocGFyYW1zLnBvc2l0aW9uVHlwZSwgJzonLCBwb3NpdGlvbiwgJ3B4JyksXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclV0aWwuY29uY2F0U3RyKHBhcmFtcy5zaXplVHlwZSwgJzonLCBwYXJhbXMuc2l6ZSwgJ3B4JylcbiAgICAgICAgICAgICAgICBdLCBkYXRhO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmxpbmVDb2xvcikge1xuICAgICAgICAgICAgICAgIGNzc1RleHRzLnB1c2gocmVuZGVyVXRpbC5jb25jYXRTdHIoJ2JhY2tncm91bmQtY29sb3I6JywgcGFyYW1zLmxpbmVDb2xvcikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhID0ge2NsYXNzTmFtZTogcGFyYW1zLmNsYXNzTmFtZSwgY3NzVGV4dDogY3NzVGV4dHMuam9pbignOycpfTtcblxuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKGRhdGEpO1xuICAgICAgICB9KS5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gbGluZUh0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcGl4ZWwgdmFsdWUgb2YgdmVydGljYWwgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBwbG90IGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsUGl4ZWxQb3NpdGlvbnM6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gY2FsY3VsYXRvci5tYWtlVGlja1BpeGVsUG9zaXRpb25zKGhlaWdodCwgdGhpcy5kYXRhLnZUaWNrQ291bnQpO1xuXG4gICAgICAgIHBvc2l0aW9ucy5zaGlmdCgpO1xuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZGl2aWRlZCBwb3NpdGlvbnMgb2YgcGxvdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggcGxvdCB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlRGl2aWRlZFBsb3RQb3NpdGlvbnM6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgIHZhciB0aWNrQ291bnQgPSBwYXJzZUludCh0aGlzLmRhdGEuaFRpY2tDb3VudCAvIDIsIDEwKSArIDEsXG4gICAgICAgICAgICB5QXhpc1dpZHRoID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3lBeGlzJykud2lkdGgsXG4gICAgICAgICAgICBsZWZ0V2lkdGgsIHJpZ2h0V2lkdGgsIGxlZnRQb3NpdGlvbnMsIHJpZ2h0UG9zaXRpb25zO1xuXG4gICAgICAgIHdpZHRoIC09IHlBeGlzV2lkdGg7XG4gICAgICAgIGxlZnRXaWR0aCA9IE1hdGgucm91bmQoKHdpZHRoKSAvIDIpO1xuICAgICAgICByaWdodFdpZHRoID0gd2lkdGggLSBsZWZ0V2lkdGg7XG5cbiAgICAgICAgbGVmdFBvc2l0aW9ucyA9IGNhbGN1bGF0b3IubWFrZVRpY2tQaXhlbFBvc2l0aW9ucyhsZWZ0V2lkdGgsIHRpY2tDb3VudCk7XG4gICAgICAgIHJpZ2h0UG9zaXRpb25zID0gY2FsY3VsYXRvci5tYWtlVGlja1BpeGVsUG9zaXRpb25zKHJpZ2h0V2lkdGgsIHRpY2tDb3VudCwgbGVmdFdpZHRoICsgeUF4aXNXaWR0aCk7XG5cbiAgICAgICAgbGVmdFBvc2l0aW9ucy5wb3AoKTtcbiAgICAgICAgcmlnaHRQb3NpdGlvbnMuc2hpZnQoKTtcblxuICAgICAgICByZXR1cm4gbGVmdFBvc2l0aW9ucy5jb25jYXQocmlnaHRQb3NpdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBpeGVsIHZhbHVlIG9mIGhvcml6b250YWwgcG9zaXRpb25zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBwbG90IHdpZHRoXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbFBpeGVsUG9zaXRpb25zOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICB2YXIgcG9zaXRpb25zO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGl2aWRlZCkge1xuICAgICAgICAgICAgcG9zaXRpb25zID0gdGhpcy5fbWFrZURpdmlkZWRQbG90UG9zaXRpb25zKHdpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9ucyA9IGNhbGN1bGF0b3IubWFrZVRpY2tQaXhlbFBvc2l0aW9ucyh3aWR0aCwgdGhpcy5kYXRhLmhUaWNrQ291bnQpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsb3Q7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBpcyB0ZW1wbGF0ZXMgb2YgcGxvdCB2aWV3IC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVtcGxhdGVNYWtlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdGVtcGxhdGVNYWtlcicpO1xuXG52YXIgdGFncyA9IHtcbiAgICBIVE1MX1BMT1RfTElORTogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtcGxvdC1saW5lIHt7IGNsYXNzTmFtZSB9fVwiIHN0eWxlPVwie3sgY3NzVGV4dCB9fVwiPjwvZGl2Pidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRwbFBsb3RMaW5lOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKHRhZ3MuSFRNTF9QTE9UX0xJTkUpXG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWwgcmVuZGVyIHBsdWdpbi5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFyQ2hhcnQgPSByZXF1aXJlKCcuL3JhcGhhZWxCYXJDaGFydCcpO1xudmFyIExpbmVDaGFydCA9IHJlcXVpcmUoJy4vcmFwaGFlbExpbmVDaGFydCcpO1xudmFyIEFyZWFDaGFydCA9IHJlcXVpcmUoJy4vcmFwaGFlbEFyZWFDaGFydCcpO1xudmFyIFBpZUNoYXJ0ID0gcmVxdWlyZSgnLi9yYXBoYWVsUGllQ2hhcnQnKTtcbnZhciBDb29yZGluYXRlVHlwZUNoYXJ0ID0gcmVxdWlyZSgnLi9yYXBoYWVsQ29vcmRpbmF0ZVR5cGVDaGFydCcpO1xudmFyIEJveFR5cGVDaGFydCA9IHJlcXVpcmUoJy4vcmFwaGFlbEJveFR5cGVDaGFydCcpO1xudmFyIE1hcENoYXJ0ID0gcmVxdWlyZSgnLi9yYXBoYWVsTWFwQ2hhcnQnKTtcbnZhciBNYXBMZWdlbmQgPSByZXF1aXJlKCcuL3JhcGhhZWxNYXBMZWdlbmQnKTtcbnZhciBDaXJjbGVMZWdlbmQgPSByZXF1aXJlKCcuL3JhcGhhZWxDaXJjbGVMZWdlbmQnKTtcblxudmFyIHBsdWdpbk5hbWUgPSAncmFwaGFlbCc7XG52YXIgcGx1Z2luUmFwaGFlbCA9IHtcbiAgICBiYXI6IEJhckNoYXJ0LFxuICAgIGNvbHVtbjogQmFyQ2hhcnQsXG4gICAgbGluZTogTGluZUNoYXJ0LFxuICAgIGFyZWE6IEFyZWFDaGFydCxcbiAgICBwaWU6IFBpZUNoYXJ0LFxuICAgIGJ1YmJsZTogQ29vcmRpbmF0ZVR5cGVDaGFydCxcbiAgICBzY2F0dGVyOiBDb29yZGluYXRlVHlwZUNoYXJ0LFxuICAgIGhlYXRtYXA6IEJveFR5cGVDaGFydCxcbiAgICB0cmVlbWFwOiBCb3hUeXBlQ2hhcnQsXG4gICAgbWFwOiBNYXBDaGFydCxcbiAgICBtYXBMZWdlbmQ6IE1hcExlZ2VuZCxcbiAgICBjaXJjbGVMZWdlbmQ6IENpcmNsZUxlZ2VuZFxufTtcblxudHVpLmNoYXJ0LnJlZ2lzdGVyUGx1Z2luKHBsdWdpbk5hbWUsIHBsdWdpblJhcGhhZWwpO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWwgYXJlYSBjaGFydCByZW5kZXJlci5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmFwaGFlbExpbmVCYXNlID0gcmVxdWlyZSgnLi9yYXBoYWVsTGluZVR5cGVCYXNlJyk7XG52YXIgcmFwaGFlbFJlbmRlclV0aWwgPSByZXF1aXJlKCcuL3JhcGhhZWxSZW5kZXJVdGlsJyk7XG5cbnZhciBFTVBIQVNJU19PUEFDSVRZID0gMTtcbnZhciBERV9FTVBIQVNJU19PUEFDSVRZID0gMC4zO1xudmFyIExFRlRfQkFSX1dJRFRIID0gMTA7XG5cbnZhciByYXBoYWVsID0gd2luZG93LlJhcGhhZWw7XG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxudmFyIFJhcGhhZWxBcmVhQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhSYXBoYWVsTGluZUJhc2UsIC8qKiBAbGVuZHMgUmFwaGFlbEFyZWFDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJhcGhhZWxBcmVhQ2hhcnQgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIGFyZWEgY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgUmFwaGFlbEFyZWFDaGFydFxuICAgICAqIEBleHRlbmRzIFJhcGhhZWxMaW5lVHlwZUJhc2VcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlbGVjdGVkIGxlZ2VuZCBpbmRleFxuICAgICAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHR5cGUgb2YgY2hhcnRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gJ2FyZWEnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZnVuY3Rpb24gb2YgYXJlYSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyXG4gICAgICogQHBhcmFtIHt7Z3JvdXBQb3NpdGlvbnM6IEFycmF5LjxBcnJheT4sIGRpbWVuc2lvbjogb2JqZWN0LCB0aGVtZTogb2JqZWN0LCBvcHRpb25zOiBvYmplY3R9fSBkYXRhIHJlbmRlciBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIC0gcmFwaGFlbCBwYXBlclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIHBhcGVyKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBkYXRhLmRpbWVuc2lvbjtcbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb25zID0gZGF0YS5ncm91cFBvc2l0aW9ucztcbiAgICAgICAgdmFyIHRoZW1lID0gZGF0YS50aGVtZTtcbiAgICAgICAgdmFyIGNvbG9ycyA9IHRoZW1lLmNvbG9ycztcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBkYXRhLm9wdGlvbnMuc2hvd0RvdCA/IDEgOiAwO1xuICAgICAgICB2YXIgYm9yZGVyU3R5bGUgPSB0aGlzLm1ha2VCb3JkZXJTdHlsZSh0aGVtZS5ib3JkZXJDb2xvciwgb3BhY2l0eSk7XG4gICAgICAgIHZhciBvdXREb3RTdHlsZSA9IHRoaXMubWFrZU91dERvdFN0eWxlKG9wYWNpdHksIGJvcmRlclN0eWxlKTtcblxuICAgICAgICBwYXBlciA9IHBhcGVyIHx8IHJhcGhhZWwoY29udGFpbmVyLCAxLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXI7XG4gICAgICAgIHRoaXMuaXNTcGxpbmUgPSBkYXRhLm9wdGlvbnMuc3BsaW5lO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbiA9IGRpbWVuc2lvbjtcbiAgICAgICAgdGhpcy56ZXJvVG9wID0gZGF0YS56ZXJvVG9wO1xuICAgICAgICB0aGlzLmhhc1JhbmdlRGF0YSA9IGRhdGEuaGFzUmFuZ2VEYXRhO1xuXG4gICAgICAgIHRoaXMuZ3JvdXBQYXRocyA9IHRoaXMuX2dldEFyZWFDaGFydFBhdGgoZ3JvdXBQb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLmdyb3VwQXJlYXMgPSB0aGlzLl9yZW5kZXJBcmVhcyhwYXBlciwgdGhpcy5ncm91cFBhdGhzLCBjb2xvcnMpO1xuICAgICAgICB0aGlzLmxlZnRCYXIgPSB0aGlzLl9yZW5kZXJMZWZ0QmFyKGRpbWVuc2lvbi5oZWlnaHQsIGRhdGEuY2hhcnRCYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy50b29sdGlwTGluZSA9IHRoaXMuX3JlbmRlclRvb2x0aXBMaW5lKHBhcGVyLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5ncm91cERvdHMgPSB0aGlzLl9yZW5kZXJEb3RzKHBhcGVyLCBncm91cFBvc2l0aW9ucywgY29sb3JzLCBvcGFjaXR5KTtcblxuICAgICAgICBpZiAoZGF0YS5vcHRpb25zLmFsbG93U2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkRvdCA9IHRoaXMuX21ha2VTZWxlY3Rpb25Eb3QocGFwZXIpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Db2xvciA9IHRoZW1lLnNlbGVjdGlvbkNvbG9yO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNSYW5nZURhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0RG90ID0gdGhpcy5fbWFrZVNlbGVjdGlvbkRvdChwYXBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm91dERvdFN0eWxlID0gb3V0RG90U3R5bGU7XG4gICAgICAgIHRoaXMuZ3JvdXBQb3NpdGlvbnMgPSBncm91cFBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5kb3RPcGFjaXR5ID0gb3BhY2l0eTtcblxuICAgICAgICB0aGlzLnBpdm90R3JvdXBEb3RzID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gcGFwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBwYXRoIGZvciBhcmVhIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn0+Pn0gZ3JvdXBQb3NpdGlvbnMgLSBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXNFeHRyYVBhdGhdIC0gd2hldGhlciBoYXMgZXh0cmEgcGF0aCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRBcmVhQ2hhcnRQYXRoOiBmdW5jdGlvbihncm91cFBvc2l0aW9ucywgaGFzRXh0cmFQYXRoKSB7XG4gICAgICAgIHZhciBwYXRoO1xuXG4gICAgICAgIGlmICh0aGlzLmlzU3BsaW5lKSB7XG4gICAgICAgICAgICBwYXRoID0gdGhpcy5fbWFrZVNwbGluZUFyZWFDaGFydFBhdGgoZ3JvdXBQb3NpdGlvbnMsIGhhc0V4dHJhUGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gdGhpcy5fbWFrZUFyZWFDaGFydFBhdGgoZ3JvdXBQb3NpdGlvbnMsIGhhc0V4dHJhUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGFyZWEgZ3JhcGhzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciBwYXBlclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IGdyb3VwUGF0aHMgZ3JvdXAgcGF0aHNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgY29sb3JzXG4gICAgICogQHJldHVybnMge0FycmF5fSByYXBoYWVsIG9iamVjdHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJBcmVhczogZnVuY3Rpb24ocGFwZXIsIGdyb3VwUGF0aHMsIGNvbG9ycykge1xuICAgICAgICB2YXIgZ3JvdXBBcmVhcztcblxuICAgICAgICBjb2xvcnMgPSBjb2xvcnMuc2xpY2UoMCwgZ3JvdXBQYXRocy5sZW5ndGgpO1xuICAgICAgICBjb2xvcnMucmV2ZXJzZSgpO1xuICAgICAgICBncm91cFBhdGhzLnJldmVyc2UoKTtcblxuICAgICAgICBncm91cEFyZWFzID0gdHVpLnV0aWwubWFwKGdyb3VwUGF0aHMsIGZ1bmN0aW9uKHBhdGgsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBhcmVhQ29sb3IgPSBjb2xvcnNbZ3JvdXBJbmRleF0gfHwgJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICBsaW5lQ29sb3IgPSBhcmVhQ29sb3IsXG4gICAgICAgICAgICAgICAgcG9seWdvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZWE6IHJhcGhhZWxSZW5kZXJVdGlsLnJlbmRlckFyZWEocGFwZXIsIHBhdGguYXJlYS5qb2luKCcgJyksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGFyZWFDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogYXJlYUNvbG9yXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJMaW5lKHBhcGVyLCBwYXRoLmxpbmUuam9pbignICcpLCBsaW5lQ29sb3IsIDEpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHBhdGguc3RhcnRMaW5lKSB7XG4gICAgICAgICAgICAgICAgcG9seWdvbnMuc3RhcnRMaW5lID0gcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyTGluZShwYXBlciwgcGF0aC5zdGFydExpbmUuam9pbignICcpLCBsaW5lQ29sb3IsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbnM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBncm91cEFyZWFzLnJldmVyc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBoZWlnaHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCB0b3BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRUb3Agc3RhcnQgdG9wXG4gICAgICogQHJldHVybnMge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUhlaWdodDogZnVuY3Rpb24odG9wLCBzdGFydFRvcCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModG9wIC0gc3RhcnRUb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGFyZWFzIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHN0YXJ0VG9wOiBudW1iZXJ9Pn0gcG9zaXRpb25zIHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hhc0V4dHJhUGF0aF0gLSB3aGV0aGVyIGhhcyBleHRyYSBwYXRoIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nIHwgbnVtYmVyPn0gcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBcmVhc1BhdGg6IGZ1bmN0aW9uKHBvc2l0aW9ucywgaGFzRXh0cmFQYXRoKSB7XG4gICAgICAgIHZhciBsZW4gPSBwb3NpdGlvbnMubGVuZ3RoICogMjtcbiAgICAgICAgdmFyIHBhdGggPSBbXTtcbiAgICAgICAgdmFyIHRhcmdldEluZGV4O1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgcGF0aFtpbmRleF0gPSBbJ0wnLCBwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3BdO1xuICAgICAgICAgICAgcGF0aFtsZW4gLSBpbmRleCAtIDFdID0gWydMJywgcG9zaXRpb24ubGVmdCwgcG9zaXRpb24uc3RhcnRUb3BdO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzRXh0cmFQYXRoICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSBwb3NpdGlvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHBhdGguc3BsaWNlKHRhcmdldEluZGV4ICsgMSwgMCwgcGF0aFt0YXJnZXRJbmRleF0sIHBhdGhbdGFyZ2V0SW5kZXggKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoID0gY29uY2F0LmFwcGx5KFtdLCBwYXRoKTtcbiAgICAgICAgcGF0aFswXSA9ICdNJztcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwYXRoIGZvciBhcmVhIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn0+Pn0gZ3JvdXBQb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGFzRXh0cmFQYXRoXSAtIHdoZXRoZXIgaGFzIGV4dHJhIHBhdGggb3Igbm90XG4gICAgICogQHJldHVybnMge0FycmF5Ljx7YXJlYTogQXJyYXkuPHN0cmluZyB8IG51bWJlcj4sIGxpbmU6IEFycmF5LjxzdHJpbmcgfCBudW1iZXI+fT59IHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXJlYUNoYXJ0UGF0aDogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMsIGhhc0V4dHJhUGF0aCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcGF0aHM7XG5cbiAgICAgICAgICAgIHBhdGhzID0ge1xuICAgICAgICAgICAgICAgIGFyZWE6IHNlbGYuX21ha2VBcmVhc1BhdGgocG9zaXRpb25zLCBoYXNFeHRyYVBhdGgpLFxuICAgICAgICAgICAgICAgIGxpbmU6IHNlbGYuX21ha2VMaW5lc1BhdGgocG9zaXRpb25zKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuaGFzUmFuZ2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgcGF0aHMuc3RhcnRMaW5lID0gc2VsZi5fbWFrZUxpbmVzUGF0aChwb3NpdGlvbnMsICdzdGFydFRvcCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGF0aHM7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNwbGluZSBhcmVhIGJvdHRvbSBwYXRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfT59IHBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZyB8IG51bWJlcj59IHNwbGluZSBhcmVhIHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3BsaW5lQXJlYUJvdHRvbVBhdGg6IGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gWydMJywgcG9zaXRpb24ubGVmdCwgc2VsZi56ZXJvVG9wXTtcbiAgICAgICAgfSkucmV2ZXJzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNwbGluZSBwYXRoIGZvciBhcmVhIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn0+Pn0gZ3JvdXBQb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGFzRXh0cmFQYXRoXSAtIHdoZXRoZXIgaGFzIGV4dHJhIHBhdGggb3Igbm90XG4gICAgICogQHJldHVybnMge0FycmF5Ljx7YXJlYTogQXJyYXkuPHN0cmluZyB8IG51bWJlcj4sIGxpbmU6IEFycmF5LjxzdHJpbmcgfCBudW1iZXI+fT59IHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3BsaW5lQXJlYUNoYXJ0UGF0aDogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMsIGhhc0V4dHJhUGF0aCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgbGluZXNQYXRoID0gc2VsZi5fbWFrZVNwbGluZUxpbmVzUGF0aChwb3NpdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGFyZWFQYXRoID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsaW5lc1BhdGgpKTtcbiAgICAgICAgICAgIHZhciBhcmVhc0JvdHRvbVBhdGggPSBzZWxmLl9tYWtlU3BsaW5lQXJlYUJvdHRvbVBhdGgocG9zaXRpb25zKTtcbiAgICAgICAgICAgIHZhciBsYXN0UG9zaXRpb247XG5cbiAgICAgICAgICAgIGlmIChoYXNFeHRyYVBhdGggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbGFzdFBvc2l0aW9uID0gcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBhcmVhUGF0aC5wdXNoKFsnTCcsIGxhc3RQb3NpdGlvbi5sZWZ0LCBsYXN0UG9zaXRpb24udG9wXSk7XG4gICAgICAgICAgICAgICAgYXJlYXNCb3R0b21QYXRoLnVuc2hpZnQoWydMJywgbGFzdFBvc2l0aW9uLmxlZnQsIHNlbGYuemVyb1RvcF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFyZWE6IGFyZWFQYXRoLmNvbmNhdChhcmVhc0JvdHRvbVBhdGgpLFxuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVzUGF0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBncmFwaCBvZiBhcmVhIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheS48e2xlZnQ6bnVtYmVyLCB0b3A6bnVtYmVyfT4+fSBwYXJhbXMuZ3JvdXBQb3NpdGlvbnMgZ3JvdXAgcG9zaXRpb25zXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgZGltZW5zaW9uID0gcGFyYW1zLmRpbWVuc2lvbixcbiAgICAgICAgICAgIGdyb3VwUG9zaXRpb25zID0gcGFyYW1zLmdyb3VwUG9zaXRpb25zO1xuXG4gICAgICAgIHRoaXMuemVyb1RvcCA9IHBhcmFtcy56ZXJvVG9wO1xuICAgICAgICB0aGlzLmdyb3VwUG9zaXRpb25zID0gZ3JvdXBQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBQYXRocyA9IHRoaXMuX2dldEFyZWFDaGFydFBhdGgoZ3JvdXBQb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLnBhcGVyLnNldFNpemUoZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgdGhpcy50b29sdGlwTGluZS5hdHRyKHt0b3A6IGRpbWVuc2lvbi5oZWlnaHR9KTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5ncm91cFBhdGhzLCBmdW5jdGlvbihwYXRoLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYXJlYSA9IHNlbGYuZ3JvdXBBcmVhc1tncm91cEluZGV4XTtcbiAgICAgICAgICAgIGFyZWEuYXJlYS5hdHRyKHtwYXRoOiBwYXRoLmFyZWEuam9pbignICcpfSk7XG4gICAgICAgICAgICBhcmVhLmxpbmUuYXR0cih7cGF0aDogcGF0aC5saW5lLmpvaW4oJyAnKX0pO1xuXG4gICAgICAgICAgICBpZiAoYXJlYS5zdGFydExpbmUpIHtcbiAgICAgICAgICAgICAgICBhcmVhLnN0YXJ0TGluZS5hdHRyKHtwYXRoOiBwYXRoLnN0YXJ0TGluZS5qb2luKCcgJyl9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHNlbGYuZ3JvdXBEb3RzW2dyb3VwSW5kZXhdLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdyb3VwUG9zaXRpb25zW2dyb3VwSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3NpdG9uO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fbW92ZURvdChpdGVtLmVuZERvdC5kb3QsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGFydERvdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBvc2l0b24gPSB0dWkudXRpbC5leHRlbmQoe30sIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3NpdG9uLnRvcCA9IHN0YXJ0UG9zaXRvbi5zdGFydFRvcDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbW92ZURvdChpdGVtLnN0YXJ0RG90LmRvdCwgc3RhcnRQb3NpdG9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBsZWdlbmRJbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKi9cbiAgICBzZWxlY3RMZWdlbmQ6IGZ1bmN0aW9uKGxlZ2VuZEluZGV4KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIG5vbmVTZWxlY3RlZCA9IHR1aS51dGlsLmlzTnVsbChsZWdlbmRJbmRleCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4ID0gbGVnZW5kSW5kZXg7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuZ3JvdXBBcmVhcywgZnVuY3Rpb24oYXJlYSwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSAobm9uZVNlbGVjdGVkIHx8IGxlZ2VuZEluZGV4ID09PSBncm91cEluZGV4KSA/IEVNUEhBU0lTX09QQUNJVFkgOiBERV9FTVBIQVNJU19PUEFDSVRZO1xuXG4gICAgICAgICAgICBhcmVhLmFyZWEuYXR0cih7J2ZpbGwtb3BhY2l0eSc6IG9wYWNpdHl9KTtcbiAgICAgICAgICAgIGFyZWEubGluZS5hdHRyKHsnc3Ryb2tlLW9wYWNpdHknOiBvcGFjaXR5fSk7XG5cbiAgICAgICAgICAgIGlmIChhcmVhLnN0YXJ0TGluZSkge1xuICAgICAgICAgICAgICAgIGFyZWEuc3RhcnRMaW5lLmF0dHIoeydzdHJva2Utb3BhY2l0eSc6IG9wYWNpdHl9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHNlbGYuZ3JvdXBEb3RzW2dyb3VwSW5kZXhdLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZG90T3BhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmVuZERvdC5kb3QuYXR0cih7J2ZpbGwtb3BhY2l0eSc6IG9wYWNpdHl9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3RhcnREb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc3RhcnREb3QuZG90LmF0dHIoeydmaWxsLW9wYWNpdHknOiBvcGFjaXR5fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgZm9yIGFkZGluZyBkYXRhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBmb3IgZ3JhcGggcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tTaXplIC0gdGljayBzaXplXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBncm91cFBvc2l0aW9ucyAtIGdyb3VwIHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NoaWZ0aW5nT3B0aW9uXSAtIHNoaWZ0aW5nIG9wdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6ZXJvVG9wIC0gcG9zaXRpb24gdG9wIHZhbHVlIGZvciB6ZXJvIHBvaW50XG4gICAgICovXG4gICAgYW5pbWF0ZUZvckFkZGluZ0RhdGE6IGZ1bmN0aW9uKGRhdGEsIHRpY2tTaXplLCBncm91cFBvc2l0aW9ucywgc2hpZnRpbmdPcHRpb24sIHplcm9Ub3ApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYWRkaXRpb25hbEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGdyb3VwUGF0aHM7XG5cbiAgICAgICAgaWYgKCFncm91cFBvc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuemVyb1RvcCA9IHplcm9Ub3A7XG5cbiAgICAgICAgZ3JvdXBQYXRocyA9IHRoaXMuX2dldEFyZWFDaGFydFBhdGgoZ3JvdXBQb3NpdGlvbnMsIGZhbHNlKTtcblxuICAgICAgICBpZiAoc2hpZnRpbmdPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGVmdEJhci5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGlja1NpemUgKyBMRUZUX0JBUl9XSURUSFxuICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxJbmRleCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5ncm91cEFyZWFzLCBmdW5jdGlvbihhcmVhLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZG90cyA9IHNlbGYuZ3JvdXBEb3RzW2dyb3VwSW5kZXhdO1xuICAgICAgICAgICAgdmFyIGdyb3VwUG9zaXRpb24gPSBncm91cFBvc2l0aW9uc1tncm91cEluZGV4XTtcbiAgICAgICAgICAgIHZhciBwYXRoTWFwID0gZ3JvdXBQYXRoc1tncm91cEluZGV4XTtcblxuICAgICAgICAgICAgaWYgKHNoaWZ0aW5nT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlRmlyc3REb3QoZG90cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShkb3RzLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdyb3VwUG9zaXRpb25baW5kZXggKyBhZGRpdGlvbmFsSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fYW5pbWF0ZUJ5UG9zaXRpb24oaXRlbS5lbmREb3QuZG90LCBwb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGFydERvdCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9hbmltYXRlQnlQb3NpdGlvbihpdGVtLnN0YXJ0RG90LmRvdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24uc3RhcnRUb3BcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlbGYuX2FuaW1hdGVCeVBhdGgoYXJlYS5hcmVhLCBwYXRoTWFwLmFyZWEpO1xuICAgICAgICAgICAgc2VsZi5fYW5pbWF0ZUJ5UGF0aChhcmVhLmxpbmUsIHBhdGhNYXAubGluZSk7XG5cbiAgICAgICAgICAgIGlmIChhcmVhLnN0YXJ0TGluZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2FuaW1hdGVCeVBhdGgoYXJlYS5zdGFydExpbmUsIHBhdGhNYXAuc3RhcnRMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbEFyZWFDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSYXBoYWVsIGJhciBjaGFydCByZW5kZXJlci5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xudmFyIHJhcGhhZWxSZW5kZXJVdGlsID0gcmVxdWlyZSgnLi9yYXBoYWVsUmVuZGVyVXRpbCcpO1xuXG52YXIgcmFwaGFlbCA9IHdpbmRvdy5SYXBoYWVsO1xuXG52YXIgQU5JTUFUSU9OX0RVUkFUSU9OID0gNzAwO1xudmFyIEVNUEhBU0lTX09QQUNJVFkgPSAxO1xudmFyIERFX0VNUEhBU0lTX09QQUNJVFkgPSAwLjM7XG52YXIgREVGQVVMVF9MVU1JTkFOQyA9IDAuMjtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFJhcGhhZWxCYXJDaGFydCBpcyBncmFwaCByZW5kZXJlciBmb3IgYmFyLCBjb2x1bW4gY2hhcnQuXG4gKiBAY2xhc3MgUmFwaGFlbEJhckNoYXJ0XG4gKi9cbnZhciBSYXBoYWVsQmFyQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFJhcGhhZWxCYXJDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBmdW5jdGlvbiBvZiBiYXIgY2hhcnRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3tzaXplOiBvYmplY3QsIG1vZGVsOiBvYmplY3QsIG9wdGlvbnM6IG9iamVjdCwgdG9vbHRpcFBvc2l0aW9uOiBzdHJpbmd9fSBkYXRhIGNoYXJ0IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGdyb3VwQm91bmRzID0gZGF0YS5ncm91cEJvdW5kcyxcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uLFxuICAgICAgICAgICAgcGFwZXI7XG5cbiAgICAgICAgaWYgKCFncm91cEJvdW5kcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXIgPSByYXBoYWVsKGNvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLnRoZW1lID0gZGF0YS50aGVtZTtcbiAgICAgICAgdGhpcy5zZXJpZXNEYXRhTW9kZWwgPSBkYXRhLnNlcmllc0RhdGFNb2RlbDtcbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBkYXRhLmNoYXJ0VHlwZTtcblxuICAgICAgICB0aGlzLmdyb3VwQmFycyA9IHRoaXMuX3JlbmRlckJhcnMoZ3JvdXBCb3VuZHMpO1xuICAgICAgICB0aGlzLmdyb3VwQm9yZGVycyA9IHRoaXMuX3JlbmRlckJhckJvcmRlcnMoZ3JvdXBCb3VuZHMpO1xuXG4gICAgICAgIHRoaXMub3ZlcmxheSA9IHRoaXMuX3JlbmRlck92ZXJsYXkoKTtcbiAgICAgICAgdGhpcy50aGVtZSA9IGRhdGEudGhlbWU7XG4gICAgICAgIHRoaXMuZ3JvdXBCb3VuZHMgPSBncm91cEJvdW5kcztcblxuICAgICAgICByZXR1cm4gcGFwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBvdmVybGF5LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyT3ZlcmxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckJhcihib3VuZCwgJyNmZmYnLCBhdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHJlY3RcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIHNlcmllcyBjb2xvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbYXR0cmlidXRlc10gLSBhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybnMge29iamVjdH0gYmFyIHJlY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJCYXI6IGZ1bmN0aW9uKGJvdW5kLCBjb2xvciwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgcmVjdDtcblxuICAgICAgICBpZiAoYm91bmQud2lkdGggPCAwIHx8IGJvdW5kLmhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdCA9IHJhcGhhZWxSZW5kZXJVdGlsLnJlbmRlclJlY3QodGhpcy5wYXBlciwgYm91bmQsIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnXG4gICAgICAgIH0sIGF0dHJpYnV0ZXMpKTtcblxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGJhcnMuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfT4+fSBncm91cEJvdW5kcyBib3VuZHNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gYmFyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckJhcnM6IGZ1bmN0aW9uKGdyb3VwQm91bmRzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNpbmdsZUNvbG9ycyA9IFtdLFxuICAgICAgICAgICAgY29sb3JzID0gdGhpcy50aGVtZS5jb2xvcnMsXG4gICAgICAgICAgICBncm91cEJhcnM7XG5cbiAgICAgICAgaWYgKChncm91cEJvdW5kc1swXS5sZW5ndGggPT09IDEpICYmIHRoaXMudGhlbWUuc2luZ2xlQ29sb3JzKSB7XG4gICAgICAgICAgICBzaW5nbGVDb2xvcnMgPSB0aGlzLnRoZW1lLnNpbmdsZUNvbG9ycztcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwQmFycyA9IHR1aS51dGlsLm1hcChncm91cEJvdW5kcywgZnVuY3Rpb24oYm91bmRzLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2luZ2xlQ29sb3IgPSBzaW5nbGVDb2xvcnNbZ3JvdXBJbmRleF07XG5cbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoYm91bmRzLCBmdW5jdGlvbihib3VuZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IsIHJlY3QsIGl0ZW07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0gPSBzZWxmLnNlcmllc0RhdGFNb2RlbC5nZXRTZXJpZXNJdGVtKGdyb3VwSW5kZXgsIGluZGV4KTtcblxuICAgICAgICAgICAgICAgIGNvbG9yID0gc2luZ2xlQ29sb3IgfHwgY29sb3JzW2luZGV4XTtcbiAgICAgICAgICAgICAgICByZWN0ID0gc2VsZi5fcmVuZGVyQmFyKGJvdW5kLnN0YXJ0LCBjb2xvcik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiBib3VuZC5lbmQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNSYW5nZTogaXRlbS5pc1JhbmdlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZ3JvdXBCYXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJlY3QgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCByZWN0IGJvdW5kXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGxlZnRUb3A6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHJpZ2h0VG9wOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn0sXG4gICAgICogICAgICByaWdodEJvdHRvbToge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9LFxuICAgICAqICAgICAgbGVmdEJvdHRvbToge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gcmVjdCBwb2ludHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUmVjdFBvaW50czogZnVuY3Rpb24oYm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnRUb3A6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBNYXRoLmNlaWwoYm91bmQubGVmdCksXG4gICAgICAgICAgICAgICAgdG9wOiBNYXRoLmNlaWwoYm91bmQudG9wKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJpZ2h0VG9wOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogTWF0aC5jZWlsKGJvdW5kLmxlZnQgKyBib3VuZC53aWR0aCksXG4gICAgICAgICAgICAgICAgdG9wOiBNYXRoLmNlaWwoYm91bmQudG9wKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJpZ2h0Qm90dG9tOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogTWF0aC5jZWlsKGJvdW5kLmxlZnQgKyBib3VuZC53aWR0aCksXG4gICAgICAgICAgICAgICAgdG9wOiBNYXRoLmNlaWwoYm91bmQudG9wICsgYm91bmQuaGVpZ2h0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlZnRCb3R0b206IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBNYXRoLmNlaWwoYm91bmQubGVmdCksXG4gICAgICAgICAgICAgICAgdG9wOiBNYXRoLmNlaWwoYm91bmQudG9wICsgYm91bmQuaGVpZ2h0KVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvcCBsaW5lIHBhdGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBvaW50cyBwb2ludHNcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb2ludHMubGVmdFRvcCBsZWZ0IHRvcFxuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvaW50cy5yaWdodFRvcCByaWdodCB0b3BcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvcCBsaW5lIHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9wTGluZVBhdGg6IGZ1bmN0aW9uKHBvaW50cywgY2hhcnRUeXBlLCBpdGVtKSB7XG4gICAgICAgIHZhciBsaW5lUGF0aCA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZW0udmFsdWUsXG4gICAgICAgICAgICBjbG9uZUxlZnRUb3A7XG5cbiAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gJ2JhcicgfHwgdmFsdWUgPj0gMCB8fCBpdGVtLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIGNsb25lTGVmdFRvcCA9IHR1aS51dGlsLmV4dGVuZCh7fSwgcG9pbnRzLmxlZnRUb3ApO1xuICAgICAgICAgICAgY2xvbmVMZWZ0VG9wLmxlZnQgLT0gY2hhcnRUeXBlID09PSAnY29sdW1uJyB8fCB2YWx1ZSA8IDAgPyAxIDogMDtcbiAgICAgICAgICAgIGxpbmVQYXRoID0gcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKGNsb25lTGVmdFRvcCwgcG9pbnRzLnJpZ2h0VG9wKS5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZVBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcmlnaHQgbGluZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludHMgcG9pbnRzXG4gICAgICogICAgICBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9pbnRzLnJpZ2h0VG9wIHJpZ2h0IHRvcFxuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvaW50cy5yaWdodEJvdHRvbSByaWdodCBib3R0b21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvcCBsaW5lIHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUmlnaHRMaW5lUGF0aDogZnVuY3Rpb24ocG9pbnRzLCBjaGFydFR5cGUsIGl0ZW0pIHtcbiAgICAgICAgdmFyIGxpbmVQYXRoID0gbnVsbDtcblxuICAgICAgICBpZiAoY2hhcnRUeXBlID09PSAnY29sdW1uJyB8fCBpdGVtLnZhbHVlID49IDAgfHwgaXRlbS5pc1JhbmdlKSB7XG4gICAgICAgICAgICBsaW5lUGF0aCA9IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VMaW5lUGF0aChwb2ludHMucmlnaHRUb3AsIHBvaW50cy5yaWdodEJvdHRvbSkuam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbmVQYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdHRvbSBsaW5lIHBhdGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBvaW50cyBwb2ludHNcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb2ludHMubGVmQm90dG9tIGxlZnQgYm90dG9tXG4gICAgICogICAgICBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9pbnRzLnJpZ2h0Qm90dG9tIHJpZ2h0IGJvdHRvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7SXRlbX0gaXRlbSBpdGVtXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdG9wIGxpbmUgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCb3R0b21MaW5lUGF0aDogZnVuY3Rpb24ocG9pbnRzLCBjaGFydFR5cGUsIGl0ZW0pIHtcbiAgICAgICAgdmFyIGxpbmVQYXRoID0gbnVsbDtcblxuICAgICAgICBpZiAoY2hhcnRUeXBlID09PSAnYmFyJyB8fCBpdGVtLnZhbHVlIDwgMCB8fCBpdGVtLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIGxpbmVQYXRoID0gcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHBvaW50cy5sZWZ0Qm90dG9tLCBwb2ludHMucmlnaHRCb3R0b20pLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5lUGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsZWZ0IGxpbmUgcGF0aC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcG9pbnRzIHBvaW50c1xuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvaW50cy5sZWZUb3AgbGVmdCB0b3BcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb2ludHMubGVmdEJvdHRvbSBsZWZ0IGJvdHRvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7SXRlbX0gaXRlbSBpdGVtXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdG9wIGxpbmUgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMZWZ0TGluZVBhdGg6IGZ1bmN0aW9uKHBvaW50cywgY2hhcnRUeXBlLCBpdGVtKSB7XG4gICAgICAgIHZhciBsaW5lUGF0aCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gJ2NvbHVtbicgfHwgaXRlbS52YWx1ZSA8IDAgfHwgaXRlbS5pc1JhbmdlKSB7XG4gICAgICAgICAgICBsaW5lUGF0aCA9IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VMaW5lUGF0aChwb2ludHMubGVmdFRvcCwgcG9pbnRzLmxlZnRCb3R0b20pLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5lUGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3JkZXIgbGluZXMgcGF0aHMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIHJlY3QgYm91bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gaXRlbVxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBzdHJpbmcsIHJpZ2h0OiBzdHJpbmcsIGJvdHRvbTogc3RyaW5nLCBsZWZ0OiBzdHJpbmd9fSBwYXRoc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCb3JkZXJMaW5lc1BhdGhzOiBmdW5jdGlvbihib3VuZCwgY2hhcnRUeXBlLCBpdGVtKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9tYWtlUmVjdFBvaW50cyhib3VuZCksXG4gICAgICAgICAgICBwYXRocyA9IHtcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuX21ha2VUb3BMaW5lUGF0aChwb2ludHMsIGNoYXJ0VHlwZSwgaXRlbSksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMuX21ha2VSaWdodExpbmVQYXRoKHBvaW50cywgY2hhcnRUeXBlLCBpdGVtKSxcbiAgICAgICAgICAgICAgICBib3R0b206IHRoaXMuX21ha2VCb3R0b21MaW5lUGF0aChwb2ludHMsIGNoYXJ0VHlwZSwgaXRlbSksXG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5fbWFrZUxlZnRMaW5lUGF0aChwb2ludHMsIGNoYXJ0VHlwZSwgaXRlbSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmZpbHRlcihwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYm9yZGVyIGxpbmVzO1xuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCBiYXIgYm91bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYm9yZGVyQ29sb3IgYm9yZGVyIGNvbG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtJdGVtfSBpdGVtIGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckJvcmRlckxpbmVzOiBmdW5jdGlvbihib3VuZCwgYm9yZGVyQ29sb3IsIGNoYXJ0VHlwZSwgaXRlbSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBib3JkZXJMaW5lUGF0aHMgPSB0aGlzLl9tYWtlQm9yZGVyTGluZXNQYXRocyhib3VuZCwgY2hhcnRUeXBlLCBpdGVtKSxcbiAgICAgICAgICAgIGxpbmVzID0ge307XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChib3JkZXJMaW5lUGF0aHMsIGZ1bmN0aW9uKHBhdGgsIG5hbWUpIHtcbiAgICAgICAgICAgIGxpbmVzW25hbWVdID0gcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyTGluZShzZWxmLnBhcGVyLCBwYXRoLCBib3JkZXJDb2xvciwgMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGJhciBib3JkZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0+Pn0gZ3JvdXBCb3VuZHMgYm91bmRzXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGJvcmRlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJCYXJCb3JkZXJzOiBmdW5jdGlvbihncm91cEJvdW5kcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IHRoaXMudGhlbWUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBncm91cEJvcmRlcnM7XG5cbiAgICAgICAgaWYgKCFib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cEJvcmRlcnMgPSB0dWkudXRpbC5tYXAoZ3JvdXBCb3VuZHMsIGZ1bmN0aW9uKGJvdW5kcywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChib3VuZHMsIGZ1bmN0aW9uKGJvdW5kLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNJdGVtO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXJpZXNJdGVtID0gc2VsZi5zZXJpZXNEYXRhTW9kZWwuZ2V0U2VyaWVzSXRlbShncm91cEluZGV4LCBpbmRleCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcmVuZGVyQm9yZGVyTGluZXMoYm91bmQuc3RhcnQsIGJvcmRlckNvbG9yLCBzZWxmLmNoYXJ0VHlwZSwgc2VyaWVzSXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwQm9yZGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZSByZWN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZWN0IHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIHJlY3QgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hbmltYXRlUmVjdDogZnVuY3Rpb24ocmVjdCwgYm91bmQpIHtcbiAgICAgICAgcmVjdC5hbmltYXRlKHtcbiAgICAgICAgICAgIHg6IGJvdW5kLmxlZnQsXG4gICAgICAgICAgICB5OiBib3VuZC50b3AsXG4gICAgICAgICAgICB3aWR0aDogYm91bmQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kLmhlaWdodFxuICAgICAgICB9LCBBTklNQVRJT05fRFVSQVRJT04pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGJvcmRlcnMuXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gbGluZXMgcmFwaGFlbCBvYmplY3RzXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIHJlY3QgYm91bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gaXRlbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGVCb3JkZXJzOiBmdW5jdGlvbihsaW5lcywgYm91bmQsIGNoYXJ0VHlwZSwgaXRlbSkge1xuICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLl9tYWtlQm9yZGVyTGluZXNQYXRocyhib3VuZCwgY2hhcnRUeXBlLCBpdGVtKTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGxpbmVzLCBmdW5jdGlvbihsaW5lLCBuYW1lKSB7XG4gICAgICAgICAgICBsaW5lLmFuaW1hdGUoe3BhdGg6IHBhdGhzW25hbWVdfSwgQU5JTUFUSU9OX0RVUkFUSU9OKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25GaW5pc2ggZmluaXNoIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24ob25GaW5pc2gpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgZ3JvdXBCb3JkZXJzID0gdGhpcy5ncm91cEJvcmRlcnMgfHwgW107XG5cbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jYWxsYmFja1RpbWVvdXQpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tUaW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJhcGhhZWxSZW5kZXJVdGlsLmZvckVhY2gyZEFycmF5KHRoaXMuZ3JvdXBCYXJzLCBmdW5jdGlvbihiYXIsIGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBncm91cEJvcmRlcnNbZ3JvdXBJbmRleF0gJiYgZ3JvdXBCb3JkZXJzW2dyb3VwSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghYmFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5fYW5pbWF0ZVJlY3QoYmFyLnJlY3QsIGJhci5ib3VuZCk7XG4gICAgICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9hbmltYXRlQm9yZGVycyhsaW5lcywgYmFyLmJvdW5kLCBzZWxmLmNoYXJ0VHlwZSwgYmFyLml0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvbkZpbmlzaCgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmNhbGxiYWNrVGltZW91dDtcbiAgICAgICAgICAgIH0sIEFOSU1BVElPTl9EVVJBVElPTik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDpudW1iZXJ9fSBkYXRhIHNob3cgaW5mb1xuICAgICAqL1xuICAgIHNob3dBbmltYXRpb246IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGJhciA9IHRoaXMuZ3JvdXBCYXJzW2RhdGEuZ3JvdXBJbmRleF1bZGF0YS5pbmRleF0sXG4gICAgICAgICAgICBib3VuZCA9IGJhci5ib3VuZDtcbiAgICAgICAgdGhpcy5vdmVybGF5LmF0dHIoe1xuICAgICAgICAgICAgd2lkdGg6IGJvdW5kLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZC5oZWlnaHQsXG4gICAgICAgICAgICB4OiBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgeTogYm91bmQudG9wLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAuM1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBhbmltYXRpb24uXG4gICAgICovXG4gICAgaGlkZUFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheS5hdHRyKHtcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHJlY3QgYm91bmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVjdCByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVSZWN0Qm91bmQ6IGZ1bmN0aW9uKHJlY3QsIGJvdW5kKSB7XG4gICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgICB4OiBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgeTogYm91bmQudG9wLFxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZC5oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBncmFwaCBvZiBiYXIgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDpudW1iZXJ9fSBwYXJhbXMuZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXkuPHtcbiAgICAgKiAgICAgICAgICAgICAgICAgIGxlZnQ6bnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlclxuICAgICAqICAgICAgICAgICAgICB9Pj59IHBhcmFtcy5ncm91cEJvdW5kcyBncm91cCBib3VuZHNcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBncm91cEJvcmRlcnMgPSB0aGlzLmdyb3VwQm9yZGVycyB8fCBbXSxcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHBhcmFtcy5kaW1lbnNpb24sXG4gICAgICAgICAgICBncm91cEJvdW5kcyA9IHBhcmFtcy5ncm91cEJvdW5kcztcblxuICAgICAgICB0aGlzLmdyb3VwQm91bmRzID0gZ3JvdXBCb3VuZHM7XG4gICAgICAgIHRoaXMucGFwZXIuc2V0U2l6ZShkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuXG4gICAgICAgIHJhcGhhZWxSZW5kZXJVdGlsLmZvckVhY2gyZEFycmF5KHRoaXMuZ3JvdXBCYXJzLCBmdW5jdGlvbihiYXIsIGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbGluZXMsIGJvdW5kO1xuXG4gICAgICAgICAgICBpZiAoIWJhcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZXMgPSBncm91cEJvcmRlcnNbZ3JvdXBJbmRleF0gJiYgZ3JvdXBCb3JkZXJzW2dyb3VwSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICAgIGJvdW5kID0gZ3JvdXBCb3VuZHNbZ3JvdXBJbmRleF1baW5kZXhdLmVuZDtcbiAgICAgICAgICAgIGJhci5ib3VuZCA9IGJvdW5kO1xuICAgICAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwudXBkYXRlUmVjdEJvdW5kKGJhci5yZWN0LCBib3VuZCk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUJvcmRlcnNQYXRoKGxpbmVzLCBib3VuZCwgc2VsZi5jaGFydFR5cGUsIGJhci5pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBib3JkZXJzIGNvbG9yLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IGxpbmVzIHJhcGhhZWwgb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Ym9yZGVyQ29sb3J9IGJvcmRlckNvbG9yIGJvcmRlciBjb2xvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NoYW5nZUJvcmRlcnNDb2xvcjogZnVuY3Rpb24obGluZXMsIGJvcmRlckNvbG9yKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2gobGluZXMsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIGxpbmUuYXR0cih7c3Ryb2tlOiBib3JkZXJDb2xvcn0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGJhciBjb2xvci5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gYm9yZGVyQ29sb3Igc3Ryb2tlIGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hhbmdlQmFyQ29sb3I6IGZ1bmN0aW9uKGluZGV4ZXMsIGNvbG9yLCBib3JkZXJDb2xvcikge1xuICAgICAgICB2YXIgYmFyID0gdGhpcy5ncm91cEJhcnNbaW5kZXhlcy5ncm91cEluZGV4XVtpbmRleGVzLmluZGV4XSxcbiAgICAgICAgICAgIGxpbmVzO1xuXG4gICAgICAgIGJhci5yZWN0LmF0dHIoe1xuICAgICAgICAgICAgZmlsbDogY29sb3JcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICBsaW5lcyA9IHRoaXMuZ3JvdXBCb3JkZXJzW2luZGV4ZXMuZ3JvdXBJbmRleF1baW5kZXhlcy5pbmRleF07XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VCb3JkZXJzQ29sb3IobGluZXMsIGJvcmRlckNvbG9yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Qgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqL1xuICAgIHNlbGVjdFNlcmllczogZnVuY3Rpb24oaW5kZXhlcykge1xuICAgICAgICB2YXIgYmFyID0gdGhpcy5ncm91cEJhcnNbaW5kZXhlcy5ncm91cEluZGV4XVtpbmRleGVzLmluZGV4XSxcbiAgICAgICAgICAgIG9iakNvbG9yID0gcmFwaGFlbC5jb2xvcihiYXIuY29sb3IpLFxuICAgICAgICAgICAgc2VsZWN0aW9uQ29sb3JUaGVtZSA9IHRoaXMudGhlbWUuc2VsZWN0aW9uQ29sb3IsXG4gICAgICAgICAgICBjb2xvciA9IHNlbGVjdGlvbkNvbG9yVGhlbWUgfHwgcmFwaGFlbFJlbmRlclV0aWwubWFrZUNoYW5nZWRMdW1pbmFuY2VDb2xvcihvYmpDb2xvci5oZXgsIERFRkFVTFRfTFVNSU5BTkMpLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSB0aGlzLnRoZW1lLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgb2JqQm9yZGVyQ29sb3I7XG5cbiAgICAgICAgaWYgKGJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICBvYmpCb3JkZXJDb2xvciA9IHJhcGhhZWwuY29sb3IoYm9yZGVyQ29sb3IpO1xuICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSByYXBoYWVsUmVuZGVyVXRpbC5tYWtlQ2hhbmdlZEx1bWluYW5jZUNvbG9yKG9iakJvcmRlckNvbG9yLmhleCwgREVGQVVMVF9MVU1JTkFOQyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jaGFuZ2VCYXJDb2xvcihpbmRleGVzLCBjb2xvciwgYm9yZGVyQ29sb3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbnNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgdW5zZWxlY3RTZXJpZXM6IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgdmFyIGJhciA9IHRoaXMuZ3JvdXBCYXJzW2luZGV4ZXMuZ3JvdXBJbmRleF1baW5kZXhlcy5pbmRleF0sXG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IHRoaXMudGhlbWUuYm9yZGVyQ29sb3I7XG4gICAgICAgIHRoaXMuX2NoYW5nZUJhckNvbG9yKGluZGV4ZXMsIGJhci5jb2xvciwgYm9yZGVyQ29sb3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gbGVnZW5kSW5kZXggbGVnZW5kIGluZGV4XG4gICAgICovXG4gICAgc2VsZWN0TGVnZW5kOiBmdW5jdGlvbihsZWdlbmRJbmRleCkge1xuICAgICAgICB2YXIgZ3JvdXBCb3JkZXJzID0gdGhpcy5ncm91cEJvcmRlcnMgfHwgW10sXG4gICAgICAgICAgICBub25lU2VsZWN0ZWQgPSB0dWkudXRpbC5pc051bGwobGVnZW5kSW5kZXgpO1xuXG4gICAgICAgIHJhcGhhZWxSZW5kZXJVdGlsLmZvckVhY2gyZEFycmF5KHRoaXMuZ3JvdXBCYXJzLCBmdW5jdGlvbihiYXIsIGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbGluZXMsIG9wYWNpdHk7XG5cbiAgICAgICAgICAgIGlmICghYmFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lcyA9IGdyb3VwQm9yZGVyc1tncm91cEluZGV4XSAmJiBncm91cEJvcmRlcnNbZ3JvdXBJbmRleF1baW5kZXhdO1xuICAgICAgICAgICAgb3BhY2l0eSA9IChub25lU2VsZWN0ZWQgfHwgbGVnZW5kSW5kZXggPT09IGluZGV4KSA/IEVNUEhBU0lTX09QQUNJVFkgOiBERV9FTVBIQVNJU19PUEFDSVRZO1xuXG4gICAgICAgICAgICBiYXIucmVjdC5hdHRyKHsnZmlsbC1vcGFjaXR5Jzogb3BhY2l0eX0pO1xuICAgICAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChsaW5lcywgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lLmF0dHIoeydzdHJva2Utb3BhY2l0eSc6IG9wYWNpdHl9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbEJhckNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWxCb3hUeXBlQ2hhcnQgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIGJveCB0eXBlIGNoYXJ0KGhlYXRtYXAgY2hhcnQsIHRyZWVtYXAgY2hhcnQpLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG52YXIgcmFwaGFlbFJlbmRlclV0aWwgPSByZXF1aXJlKCcuL3JhcGhhZWxSZW5kZXJVdGlsJyk7XG5cbnZhciByYXBoYWVsID0gd2luZG93LlJhcGhhZWw7XG5cbnZhciBBTklNQVRJT05fRFVSQVRJT04gPSAxMDA7XG52YXIgTUlOX0JPUkRFUl9XSURUSCA9IDE7XG52YXIgTUFYX0JPUkRFUl9XSURUSCA9IDM7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBSYXBoYWVsQm94VHlwZUNoYXJ0IGlzIGdyYXBoIHJlbmRlcmVyIGZvciBib3ggdHlwZSBjaGFydChoZWF0bWFwIGNoYXJ0LCB0cmVlbWFwIGNoYXJ0KS5cbiAqIEBjbGFzcyBSYXBoYWVsQmFyQ2hhcnRcbiAqL1xudmFyIFJhcGhhZWxCb3hUeXBlQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFJhcGhhZWxCb3hUeXBlQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZnVuY3Rpb24gb2YgYmFyIGNoYXJ0XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBjb2xvclNwZWN0cnVtOiBvYmplY3QsXG4gICAgICogICAgICBzZXJpZXNEYXRhTW9kZWw6IFNlcmllc0RhdGFNb2RlbCxcbiAgICAgKiAgICAgIGdyb3VwQm91bmRzOiAoQXJyYXkuPEFycmF5LjxvYmplY3Q+PnxvYmplY3QuPHN0cmluZywgb2JqZWN0PiksXG4gICAgICogICAgICB0aGVtZTogb2JqZWN0XG4gICAgICogfX0gc2VyaWVzRGF0YSAtIGRhdGEgZm9yIGdyYXBoIHJlbmRlcmluZ1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIHNlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHNlcmllc0RhdGEuZGltZW5zaW9uO1xuXG4gICAgICAgIHRoaXMucGFwZXIgPSByYXBoYWVsKGNvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZW1lXG4gICAgICAgICAqIEB0eXBlIHsqfHt9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IHNlcmllc0RhdGEudGhlbWUgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbG9yIHNwZWN0cnVtXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbG9yU3BlY3RydW0gPSBzZXJpZXNEYXRhLmNvbG9yU3BlY3RydW07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0QmFja2dyb3VuZCA9IHNlcmllc0RhdGEuY2hhcnRCYWNrZ3JvdW5kO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB6b29tYWJsZSBvcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuem9vbWFibGUgPSBzZXJpZXNEYXRhLnpvb21hYmxlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBib3JkZXIgY29sb3IgZm9yIHJlbmRlcmluZyBib3hcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSB0aGlzLnRoZW1lLmJvcmRlckNvbG9yIHx8ICdub25lJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogZ3JvdXAgYm91bmRzXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fG9iamVjdC48c3RyaW5nLCBvYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cEJvdW5kcyA9IHNlcmllc0RhdGEuZ3JvdXBCb3VuZHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJvdW5kIG1hcFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0LjxzdHJpbmcsIHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZE1hcCA9IHNlcmllc0RhdGEuYm91bmRNYXA7XG5cbiAgICAgICAgdGhpcy5fYmluZEdldEJvdW5kRnVuY3Rpb24oKTtcbiAgICAgICAgdGhpcy5fYmluZEdldENvbG9yRnVuY3Rpb24oKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYm94ZXMgc2V0XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPHtyZWN0OiBPYmplY3QsIGNvbG9yOiBzdHJpbmd9Pj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJveGVzU2V0ID0gdGhpcy5fcmVuZGVyQm94ZXMoc2VyaWVzRGF0YS5zZXJpZXNEYXRhTW9kZWwsIHNlcmllc0RhdGEuc3RhcnREZXB0aCwgISFzZXJpZXNEYXRhLmlzUGl2b3QpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kIF9nZXRCb3VuZCBwcml2YXRlIGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JpbmRHZXRCb3VuZEZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYm91bmRNYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2dldEJvdW5kID0gdGhpcy5fZ2V0Qm91bmRGcm9tQm91bmRNYXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRCb3VuZCA9IHRoaXMuX2dldEJvdW5kRnJvbUdyb3VwQm91bmRzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJpbmQgX2JpbmRHZXRDb2xvckZ1bmN0aW9uIHByaXZhdGUgZnVuY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYmluZEdldENvbG9yRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jb2xvclNwZWN0cnVtKSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRDb2xvciA9IHRoaXMuX2dldENvbG9yRnJvbVNwZWN0cnVtO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuem9vbWFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldENvbG9yID0gdGhpcy5fZ2V0Q29sb3JGcm9tQ29sb3JzV2hlblpvb21hYmxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2V0Q29sb3IgPSB0aGlzLl9nZXRDb2xvckZyb21Db2xvcnM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvdW5kIGZyb20gZ3JvdXBCb3VuZHMgYnkgaW5kZXhlcyhncm91cEluZGV4LCBpbmRleCkgb2Ygc2VyaWVzSXRlbS5cbiAgICAgKiBAcGFyYW0ge1Nlcmllc0l0ZW19IHNlcmllc0l0ZW0gLSBzZXJpZXNJdGVtXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgbGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Qm91bmRGcm9tR3JvdXBCb3VuZHM6IGZ1bmN0aW9uKHNlcmllc0l0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBCb3VuZHNbc2VyaWVzSXRlbS5ncm91cEluZGV4XVtzZXJpZXNJdGVtLmluZGV4XS5lbmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBib3VuZCBmcm9tIGJvdW5kTWFwIGJ5IGlkIG9mIHNlcmllc0l0ZW0uXG4gICAgICogQHBhcmFtIHtTZXJpZXNJdGVtfSBzZXJpZXNJdGVtIC0gc2VyaWVzSXRlbVxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGxlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEJvdW5kRnJvbUJvdW5kTWFwOiBmdW5jdGlvbihzZXJpZXNJdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kTWFwW3Nlcmllc0l0ZW0uaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29sb3IgZnJvbSBjb2xvclNwZWN0cnVtIGJ5IHJhdGlvIG9mIHNlcmllc0l0ZW0uXG4gICAgICogQHBhcmFtIHtTZXJpZXNJdGVtfSBzZXJpZXNJdGVtIC0gc2VyaWVzSXRlbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q29sb3JGcm9tU3BlY3RydW06IGZ1bmN0aW9uKHNlcmllc0l0ZW0pIHtcbiAgICAgICAgdmFyIGNvbG9yO1xuXG4gICAgICAgIGlmICghc2VyaWVzSXRlbS5oYXNDaGlsZCkge1xuICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNvbG9yU3BlY3RydW0uZ2V0Q29sb3Ioc2VyaWVzSXRlbS5yYXRpbykgfHwgdGhpcy5jaGFydEJhY2tncm91bmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xvciA9ICdub25lJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbG9yIGZyb20gY29sb3JzIHRoZW1lIGJ5IGdyb3VwIHByb3BlcnR5IG9mIHNlcmllc0l0ZW0uXG4gICAgICogQHBhcmFtIHtTZXJpZXNJdGVtfSBzZXJpZXNJdGVtIC0gc2VyaWVzSXRlbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q29sb3JGcm9tQ29sb3JzOiBmdW5jdGlvbihzZXJpZXNJdGVtKSB7XG4gICAgICAgIHJldHVybiBzZXJpZXNJdGVtLmhhc0NoaWxkID8gJ25vbmUnIDogdGhpcy50aGVtZS5jb2xvcnNbc2VyaWVzSXRlbS5ncm91cF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb2xvciBmcm9tIGNvbG9ycyB0aGVtZSwgd2hlbiB6b29tYWJsZSBvcHRpb24uXG4gICAgICogQHBhcmFtIHtTZXJpZXNJdGVtfSBzZXJpZXNJdGVtIC0gc2VyaWVzSXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydERlcHRoIC0gc3RhcnQgZGVwdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENvbG9yRnJvbUNvbG9yc1doZW5ab29tYWJsZTogZnVuY3Rpb24oc2VyaWVzSXRlbSwgc3RhcnREZXB0aCkge1xuICAgICAgICByZXR1cm4gKHNlcmllc0l0ZW0uZGVwdGggPT09IHN0YXJ0RGVwdGgpID8gdGhpcy50aGVtZS5jb2xvcnNbc2VyaWVzSXRlbS5ncm91cF0gOiAnbm9uZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciByZWN0LlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYm91bmQgLSBib3VuZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cm9rZVdpZHRoIC0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJSZWN0OiBmdW5jdGlvbihib3VuZCwgY29sb3IsIHN0cm9rZVdpZHRoKSB7XG4gICAgICAgIHJldHVybiByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJSZWN0KHRoaXMucGFwZXIsIGJvdW5kLCB7XG4gICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgIHN0cm9rZTogdGhpcy5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBzdHJva2VXaWR0aFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGJveGVzLlxuICAgICAqIEBwYXJhbSB7U2VyaWVzRGF0YU1vZGVsfSBzZXJpZXNEYXRhTW9kZWwgLSBzZXJpZXNEYXRhTW9kZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnREZXB0aCAtIHN0YXJ0IGRlcHRoXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1Bpdm90IC0gd2hldGhlciBwaXZvdCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5Ljx7cmVjdDogb2JqZWN0LCBjb2xvcjogc3RyaW5nfT4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckJveGVzOiBmdW5jdGlvbihzZXJpZXNEYXRhTW9kZWwsIHN0YXJ0RGVwdGgsIGlzUGl2b3QpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcmVjdFRvQmFjaztcblxuICAgICAgICBpZiAodGhpcy5jb2xvclNwZWN0cnVtIHx8ICF0aGlzLnpvb21hYmxlKSB7XG4gICAgICAgICAgICByZWN0VG9CYWNrID0gZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICAgICAgICAgIHJlY3QudG9CYWNrKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjdFRvQmFjayA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzRGF0YU1vZGVsLm1hcChmdW5jdGlvbihzZXJpZXNHcm91cCwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLm1hcChmdW5jdGlvbihzZXJpZXNJdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzdHJva2VXaWR0aCA9IE1JTl9CT1JERVJfV0lEVEg7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kLCBjb2xvcjtcblxuICAgICAgICAgICAgICAgIGlmICh0dWkudXRpbC5pc0V4aXN0eShzZXJpZXNJdGVtLmRlcHRoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aCA9IE1hdGgubWF4KE1JTl9CT1JERVJfV0lEVEgsIE1BWF9CT1JERVJfV0lEVEggLSAoc2VyaWVzSXRlbS5kZXB0aCAtIHN0YXJ0RGVwdGgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXJpZXNJdGVtLmdyb3VwSW5kZXggPSBncm91cEluZGV4O1xuICAgICAgICAgICAgICAgIHNlcmllc0l0ZW0uaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBib3VuZCA9IHNlbGYuX2dldEJvdW5kKHNlcmllc0l0ZW0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gc2VsZi5fZ2V0Q29sb3Ioc2VyaWVzSXRlbSwgc3RhcnREZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Q6IHNlbGYuX3JlbmRlclJlY3QoYm91bmQsIGNvbG9yLCBzdHJva2VXaWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJdGVtOiBzZXJpZXNJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlY3RUb0JhY2socmVzdWx0LnJlY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaXNQaXZvdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgY2hhbmdpbmcgY29sb3Igb2YgYm94LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZWN0IC0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbG9yXSAtIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wYWNpdHldIC0gZmlsbCBvcGFjaXR5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYW5pbWF0ZUNoYW5naW5nQ29sb3I6IGZ1bmN0aW9uKHJlY3QsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IHR1aS51dGlsLmlzRXhpc3R5KG9wYWNpdHkpID8gb3BhY2l0eSA6IDFcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuZmlsbCA9IGNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdC5hbmltYXRlKHByb3BlcnRpZXMsIEFOSU1BVElPTl9EVVJBVElPTik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6bnVtYmVyfX0gaW5kZXhlcyAtIGluZGV4IGluZm9cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VTcGVjdHJ1bV0gLSB3aGV0aGVyIHVzZSBzcGVjdHJ1bSBsZWdlbmQgb3Igbm90XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcGFjaXR5XSAtIGZpbGwgb3BhY2l0eVxuICAgICAqL1xuICAgIHNob3dBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4ZXMsIHVzZVNwZWN0cnVtLCBvcGFjaXR5KSB7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLmJveGVzU2V0W2luZGV4ZXMuZ3JvdXBJbmRleF1baW5kZXhlcy5pbmRleF07XG4gICAgICAgIHZhciBjb2xvcjtcblxuICAgICAgICBpZiAoIWJveCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXNlU3BlY3RydW0gPSB0dWkudXRpbC5pc1VuZGVmaW5lZCh1c2VTcGVjdHJ1bSkgPyB0cnVlIDogdXNlU3BlY3RydW07XG4gICAgICAgIGNvbG9yID0gdXNlU3BlY3RydW0gPyB0aGlzLnRoZW1lLm92ZXJDb2xvciA6IGJveC5jb2xvcjtcblxuICAgICAgICBpZiAoYm94LnNlcmllc0l0ZW0uaGFzQ2hpbGQpIHtcbiAgICAgICAgICAgIGlmICh1c2VTcGVjdHJ1bSkge1xuICAgICAgICAgICAgICAgIGJveC5yZWN0LmF0dHIoeydmaWxsLW9wYWNpdHknOiAwfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3gucmVjdC50b0Zyb250KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hbmltYXRlQ2hhbmdpbmdDb2xvcihib3gucmVjdCwgY29sb3IsIG9wYWNpdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4Om51bWJlcn19IGluZGV4ZXMgLSBpbmRleCBpbmZvXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXNlQ29sb3JWYWx1ZV0gLSB3aGV0aGVyIHVzZSBjb2xvclZhbHVlIG9yIG5vdFxuICAgICAqL1xuICAgIGhpZGVBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4ZXMsIHVzZUNvbG9yVmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbG9yU3BlY3RydW0gPSB0aGlzLmNvbG9yU3BlY3RydW07XG4gICAgICAgIHZhciBib3ggPSB0aGlzLmJveGVzU2V0W2luZGV4ZXMuZ3JvdXBJbmRleF1baW5kZXhlcy5pbmRleF07XG4gICAgICAgIHZhciBvcGFjaXR5ID0gMTtcbiAgICAgICAgdmFyIGNvbG9yO1xuXG4gICAgICAgIGlmICghYm94KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm94LnNlcmllc0l0ZW0uaGFzQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbG9yID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh1c2VDb2xvclZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xvciA9IGJveC5jb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FuaW1hdGVDaGFuZ2luZ0NvbG9yKGJveC5yZWN0LCBjb2xvciwgb3BhY2l0eSk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghY29sb3JTcGVjdHJ1bSAmJiBib3guc2VyaWVzSXRlbS5oYXNDaGlsZCkge1xuICAgICAgICAgICAgICAgIGJveC5yZWN0LnRvQmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBBTklNQVRJT05fRFVSQVRJT04pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBncm91cEJvdW5kczogKEFycmF5LjxBcnJheS48b2JqZWN0Pj58b2JqZWN0LjxzdHJpbmcsIG9iamVjdD4pXG4gICAgICogfX0gc2VyaWVzRGF0YSAtIGRhdGEgZm9yIGdyYXBoIHJlbmRlcmluZ1xuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oc2VyaWVzRGF0YSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBzZXJpZXNEYXRhLmRpbWVuc2lvbjtcblxuICAgICAgICB0aGlzLmJvdW5kTWFwID0gc2VyaWVzRGF0YS5ib3VuZE1hcDtcbiAgICAgICAgdGhpcy5ncm91cEJvdW5kcyA9IHNlcmllc0RhdGEuZ3JvdXBCb3VuZHM7XG4gICAgICAgIHRoaXMucGFwZXIuc2V0U2l6ZShkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuXG4gICAgICAgIHJhcGhhZWxSZW5kZXJVdGlsLmZvckVhY2gyZEFycmF5KHRoaXMuYm94ZXNTZXQsIGZ1bmN0aW9uKGJveCwgZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBib3VuZDtcblxuICAgICAgICAgICAgaWYgKCFib3gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvdW5kID0gc2VsZi5fZ2V0Qm91bmQoYm94LnNlcmllc0l0ZW0sIGdyb3VwSW5kZXgsIGluZGV4KTtcblxuICAgICAgICAgICAgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwudXBkYXRlUmVjdEJvdW5kKGJveC5yZWN0LCBib3VuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhcGhhZWxCb3hUeXBlQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmFwaGFlbENpcmNsZUxlZ2VuZCBpcyBncmFwaCByZW5kZXJlciBmb3IgY2lyY2xlTGVnZW5kLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIHJhcGhhZWwgPSB3aW5kb3cuUmFwaGFlbDtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFJhcGhhZWxDaXJjbGVMZWdlbmQgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIGNpcmNsZUxlZ2VuZC5cbiAqIEBjbGFzcyBSYXBoYWVsQ2lyY2xlTGVnZW5kXG4gKi9cbnZhciBSYXBoYWVsQ2lyY2xlTGVnZW5kID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBSYXBoYWVsQ2lyY2xlTGVnZW5kLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGZ1bmN0aW9uIG9mIG1hcCBjaGFydCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIC0gZGltZW5zaW9uIG9mIGNpcmNsZSBsZWdlbmQgYXJlYVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSYWRpdXMgLSBwaXhlbCB0eXBlIG1heGltdW0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmFkaXVzUmF0aW9zIC0gcmFkaXVzIHJhdGlvc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGltZW5zaW9uLCBtYXhSYWRpdXMsIHJhZGl1c1JhdGlvcykge1xuICAgICAgICB2YXIgcGFwZXIgPSByYXBoYWVsKGNvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXI7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyQ2lyY2xlcyhkaW1lbnNpb24sIG1heFJhZGl1cywgcmFkaXVzUmF0aW9zKTtcblxuICAgICAgICByZXR1cm4gcGFwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjaXJjbGVzLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIC0gZGltZW5zaW9uIG9mIGNpcmNsZSBsZWdlbmQgYXJlYVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSYWRpdXMgLSBwaXhlbCB0eXBlIG1heGltdW0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmFkaXVzUmF0aW9zIC0gcmFkaXVzIHJhdGlvc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckNpcmNsZXM6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgbWF4UmFkaXVzLCByYWRpdXNSYXRpb3MpIHtcbiAgICAgICAgdmFyIHBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgdmFyIGxlZnQgPSBkaW1lbnNpb24ud2lkdGggLyAyO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShyYWRpdXNSYXRpb3MsIGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gbWF4UmFkaXVzICogcmF0aW87XG4gICAgICAgICAgICB2YXIgdG9wID0gKGRpbWVuc2lvbi5oZWlnaHQgLSByYWRpdXMpIC0gMTtcblxuICAgICAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyQ2lyY2xlKHBhcGVyLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICAgICAgfSwgcmFkaXVzLCB7XG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzg4OCcsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXBoYWVsQ2lyY2xlTGVnZW5kO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWwgYnViYmxlIGNoYXJ0IHJlbmRlcmVyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG52YXIgcmFwaGFlbFJlbmRlclV0aWwgPSByZXF1aXJlKCcuL3JhcGhhZWxSZW5kZXJVdGlsJyk7XG5cbnZhciByYXBoYWVsID0gd2luZG93LlJhcGhhZWw7XG5cbnZhciBBTklNQVRJT05fRFVSQVRJT04gPSA3MDA7XG52YXIgQ0lSQ0xFX09QQUNJVFkgPSAwLjU7XG52YXIgU1RST0tFX09QQUNJVFkgPSAwLjM7XG52YXIgRU1QSEFTSVNfT1BBQ0lUWSA9IDAuNTtcbnZhciBERV9FTVBIQVNJU19PUEFDSVRZID0gMC4zO1xudmFyIERFRkFVTFRfTFVNSU5BTkMgPSAwLjI7XG52YXIgT1ZFUkxBWV9CT1JERVJfV0lEVEggPSAyO1xuXG4vKipcbiAqIGJvdW5kIGZvciBjaXJjbGVcbiAqIEB0eXBlZGVmIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmFkaXVzOiBudW1iZXJ9fSBib3VuZFxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZm9yIHJlbmRlcmVkIGNpcmNsZVxuICogQHR5cGVkZWYge3tjaXJjbGU6IG9iamVjdCwgY29sb3I6IHN0cmluZywgYm91bmQ6IGJvdW5kfX0gY2lyY2xlSW5mb1xuICovXG5cbi8qKlxuICogQGNsYXNzZGVzYyBSYXBoYWVsQnViYmxlQ2hhcnQgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIGJ1YmJsZSBjaGFydC5cbiAqIEBjbGFzcyBSYXBoYWVsQnViYmxlQ2hhcnRcbiAqL1xudmFyIFJhcGhhZWxCdWJibGVDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgUmFwaGFlbEJ1YmJsZUNoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGZ1bmN0aW9uIG9mIGJ1YmJsZSBjaGFydFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBzZXJpZXNEYXRhTW9kZWw6IFNlcmllc0RhdGFNb2RlbCxcbiAgICAgKiAgICAgIGdyb3VwQm91bmRzOiBBcnJheS48QXJyYXkuPGJvdW5kPj4sXG4gICAgICogICAgICB0aGVtZTogb2JqZWN0XG4gICAgICogfX0gZGF0YSAtIGRhdGEgZm9yIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7e3Nob3dUb29sdGlwOiBmdW5jdGlvbiwgaGlkZVRvb2x0aXA6IGZ1bmN0aW9ufX0gY2FsbGJhY2tzIC0gY2FsbGJhY2tzIGZvciB0b2dnbGUgb2YgdG9vbHRpcC5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhLCBjYWxsYmFja3MpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uLFxuICAgICAgICAgICAgcGFwZXI7XG5cbiAgICAgICAgdGhpcy5wYXBlciA9IHBhcGVyID0gcmFwaGFlbChjb250YWluZXIsIGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGVtZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IGRhdGEudGhlbWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlcmllc0RhdGFNb2RlbFxuICAgICAgICAgKiBAdHlwZSB7U2VyaWVzRGF0YU1vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJpZXNEYXRhTW9kZWwgPSBkYXRhLnNlcmllc0RhdGFNb2RlbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZ3JvdXAgYm91bmRzXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPGJvdW5kPj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwQm91bmRzID0gZGF0YS5ncm91cEJvdW5kcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2FsbGJhY2tzIGZvciB0b2dnbGUgb2YgdG9vbHRpcC5cbiAgICAgICAgICogQHR5cGUge3tzaG93VG9vbHRpcDogRnVuY3Rpb24sIGhpZGVUb29sdGlwOiBGdW5jdGlvbn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogb3ZlcmxheSBpcyBjaXJjbGUgb2JqZWN0IG9mIHJhcGhhZWwsIHRoYXQgdXNpbmcgZm9yIG1vdXNlb3Zlci5cbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3ZlcmxheSA9IHRoaXMuX3JlbmRlck92ZXJsYXkoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdHdvLWRpbWVuc2lvbmFsIGFycmF5IGJ5IGNpcmNsZUluZm9cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxBcnJheS48Y2lyY2xlSW5mbz4+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cENpcmNsZUluZm9zID0gdGhpcy5fcmVuZGVyQ2lyY2xlcygpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmV2aW91cyBzZWxlY3RlZCBjaXJjbGVcbiAgICAgICAgICogQHR5cGUgez9vYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZDaXJjbGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmV2aW91cyBvdmVyIGNpcmNsZVxuICAgICAgICAgKiBAdHlwZSB7P29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldk92ZXJDaXJjbGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbmltYXRpb24gdGltZW91dCBpZFxuICAgICAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uVGltZW91dElkID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gcGFwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBvdmVybGF5LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyT3ZlcmxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHtcbiAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgIHN0cm9rZTogJyNmZmYnLFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogU1RST0tFX09QQUNJVFksXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMlxuICAgICAgICB9O1xuICAgICAgICB2YXIgY2lyY2xlID0gcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyQ2lyY2xlKHRoaXMucGFwZXIsIHBvc2l0aW9uLCAwLCBhdHRyaWJ1dGUpO1xuXG4gICAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjaXJjbGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPGNpcmNsZUluZm8+Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJDaXJjbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sb3JzID0gdGhpcy50aGVtZS5jb2xvcnM7XG4gICAgICAgIHZhciBzaW5nbGVDb2xvcnMgPSBbXTtcblxuICAgICAgICBpZiAoKHRoaXMuZ3JvdXBCb3VuZHNbMF0ubGVuZ3RoID09PSAxKSAmJiB0aGlzLnRoZW1lLnNpbmdsZUNvbG9ycykge1xuICAgICAgICAgICAgc2luZ2xlQ29sb3JzID0gdGhpcy50aGVtZS5zaW5nbGVDb2xvcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHRoaXMuZ3JvdXBCb3VuZHMsIGZ1bmN0aW9uKGJvdW5kcywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIHNpbmdsZUNvbG9yID0gc2luZ2xlQ29sb3JzW2dyb3VwSW5kZXhdO1xuXG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGJvdW5kcywgZnVuY3Rpb24oYm91bmQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNpcmNsZUluZm8gPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciwgY2lyY2xlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gc2luZ2xlQ29sb3IgfHwgY29sb3JzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlID0gcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyQ2lyY2xlKHNlbGYucGFwZXIsIGJvdW5kLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBjaXJjbGUuZGF0YSgnZ3JvdXBJbmRleCcsIGdyb3VwSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjaXJjbGUuZGF0YSgnaW5kZXgnLCBpbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZTogY2lyY2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQ6IGJvdW5kXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNpcmNsZUluZm87XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgY2lyY2xlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNpcmNsZSAtIHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIHJhZGl1cyBvZiBjaXJjbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hbmltYXRlQ2lyY2xlOiBmdW5jdGlvbihjaXJjbGUsIHJhZGl1cykge1xuICAgICAgICBjaXJjbGUuYW5pbWF0ZSh7XG4gICAgICAgICAgICByOiByYWRpdXMsXG4gICAgICAgICAgICBvcGFjaXR5OiBDSVJDTEVfT1BBQ0lUWVxuICAgICAgICB9LCBBTklNQVRJT05fRFVSQVRJT04pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uRmluaXNoIC0gZmluaXNoIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24ob25GaW5pc2gpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvblRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbWF0aW9uVGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJhcGhhZWxSZW5kZXJVdGlsLmZvckVhY2gyZEFycmF5KHRoaXMuZ3JvdXBDaXJjbGVJbmZvcywgZnVuY3Rpb24oY2lyY2xlSW5mbykge1xuICAgICAgICAgICAgaWYgKCFjaXJjbGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5fYW5pbWF0ZUNpcmNsZShjaXJjbGVJbmZvLmNpcmNsZSwgY2lyY2xlSW5mby5ib3VuZC5yYWRpdXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvbkZpbmlzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgIH0sIEFOSU1BVElPTl9EVVJBVElPTik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNpcmNsZSBib3VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaXJjbGUgLSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBib3VuZCAtIGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uKGNpcmNsZSwgYm91bmQpIHtcbiAgICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICAgICAgY3g6IGJvdW5kLmxlZnQsXG4gICAgICAgICAgICBjeTogYm91bmQudG9wLFxuICAgICAgICAgICAgcjogYm91bmQucmFkaXVzXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgZ3JhcGggb2YgYnViYmxlIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gcGFyYW1zLmRpbWVuc2lvbiAtIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXkuPGJvdW5kPj59IHBhcmFtcy5ncm91cEJvdW5kcyAtIGdyb3VwIGJvdW5kc1xuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHBhcmFtcy5kaW1lbnNpb247XG4gICAgICAgIHZhciBncm91cEJvdW5kcyA9IHBhcmFtcy5ncm91cEJvdW5kcztcblxuICAgICAgICB0aGlzLmdyb3VwQm91bmRzID0gZ3JvdXBCb3VuZHM7XG4gICAgICAgIHRoaXMucGFwZXIuc2V0U2l6ZShkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuXG4gICAgICAgIHJhcGhhZWxSZW5kZXJVdGlsLmZvckVhY2gyZEFycmF5KHRoaXMuZ3JvdXBDaXJjbGVJbmZvcywgZnVuY3Rpb24oY2lyY2xlSW5mbywgZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBib3VuZCA9IGdyb3VwQm91bmRzW2dyb3VwSW5kZXhdW2luZGV4XTtcblxuICAgICAgICAgICAgY2lyY2xlSW5mby5ib3VuZCA9IGJvdW5kO1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlUG9zaXRpb24oY2lyY2xlSW5mby5jaXJjbGUsIGJvdW5kKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsaWNrIHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKi9cbiAgICBjbGlja1NlcmllczogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGNpcmNsZSA9IHRoaXMucGFwZXIuZ2V0RWxlbWVudEJ5UG9pbnQocG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wKTtcbiAgICAgICAgdmFyIHByZXZDaXJjbGUgPSB0aGlzLnByZXZDaXJjbGU7XG5cbiAgICAgICAgaWYgKGNpcmNsZSAmJiBwcmV2Q2lyY2xlKSB7XG4gICAgICAgICAgICB0aGlzLl91bnNlbGVjdFNlcmllcyhwcmV2Q2lyY2xlLmRhdGEoJ2dyb3VwSW5kZXgnKSwgcHJldkNpcmNsZS5kYXRhKCdpbmRleCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2Q2lyY2xlID09PSBjaXJjbGUpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkNpcmNsZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoY2lyY2xlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RTZXJpZXMoY2lyY2xlLmRhdGEoJ2dyb3VwSW5kZXgnKSwgY2lyY2xlLmRhdGEoJ2luZGV4JykpO1xuICAgICAgICAgICAgdGhpcy5wcmV2Q2lyY2xlID0gY2lyY2xlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzZXJpZXMgY29udGFpbmVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENvbnRhaW5lckJvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lckJvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kID0gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJCb3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjaGFuZ2VkIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcHJldlBvc2l0aW9uIC0gcHJldmlvdXMgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gLSBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2hhbmdlZFBvc2l0aW9uOiBmdW5jdGlvbihwcmV2UG9zaXRpb24sIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiAhcHJldlBvc2l0aW9uIHx8IHByZXZQb3NpdGlvbi5sZWZ0ICE9PSBwb3NpdGlvbi5sZWZ0IHx8IHByZXZQb3NpdGlvbi50b3AgIT09IHBvc2l0aW9uLnRvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBvdmVybGF5IHdoZW4gbW91c2Ugb3ZlciBhIGNpcmNsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJbmRleCAtIGluZGV4IG9mIGNpcmNsZXMgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBjaXJjbGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd092ZXJsYXk6IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgIHZhciBjaXJjbGVJbmZvID0gdGhpcy5ncm91cENpcmNsZUluZm9zW2dyb3VwSW5kZXhdW2luZGV4XTtcbiAgICAgICAgdmFyIGJvdW5kID0gY2lyY2xlSW5mby5ib3VuZDtcblxuICAgICAgICB0aGlzLm92ZXJsYXkuYXR0cih7XG4gICAgICAgICAgICBjeDogYm91bmQubGVmdCxcbiAgICAgICAgICAgIGN5OiBib3VuZC50b3AsXG4gICAgICAgICAgICByOiBib3VuZC5yYWRpdXMgKyBPVkVSTEFZX0JPUkRFUl9XSURUSCxcbiAgICAgICAgICAgIHN0cm9rZTogY2lyY2xlSW5mby5jb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgb3ZlcmxheS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlT3ZlcmxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheS5hdHRyKHtcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBjaXJjbGUuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIC0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7P29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kQ2lyY2xlOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgY2lyY2xlcyA9IFtdO1xuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICB2YXIgZm91bmRDaXJjbGUsIGNpcmNsZTtcblxuICAgICAgICB3aGlsZSAodHVpLnV0aWwuaXNVbmRlZmluZWQoZm91bmRDaXJjbGUpKSB7XG4gICAgICAgICAgICBjaXJjbGUgPSBwYXBlci5nZXRFbGVtZW50QnlQb2ludChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApO1xuXG4gICAgICAgICAgICBpZiAoY2lyY2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNpcmNsZS5hdHRycy5vcGFjaXR5ID4gREVfRU1QSEFTSVNfT1BBQ0lUWSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENpcmNsZSA9IGNpcmNsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaXJjbGVzLnB1c2goY2lyY2xlKTtcbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kQ2lyY2xlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm91bmRDaXJjbGUpIHtcbiAgICAgICAgICAgIGZvdW5kQ2lyY2xlID0gY2lyY2xlc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjaXJjbGVzLCBmdW5jdGlvbihfY2lyY2xlKSB7XG4gICAgICAgICAgICBfY2lyY2xlLnNob3coKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kQ2lyY2xlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIG1vdXNlIG9uIHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gLSBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIG1vdmVNb3VzZU9uU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgY2lyY2xlID0gdGhpcy5fZmluZENpcmNsZShwb3NpdGlvbik7XG4gICAgICAgIHZhciBjb250YWluZXJCb3VuZCwgaXNDaGFuZ2VkLCBncm91cEluZGV4LCBpbmRleCwgYXJncztcblxuICAgICAgICBpZiAoY2lyY2xlICYmIHR1aS51dGlsLmlzRXhpc3R5KGNpcmNsZS5kYXRhKCdncm91cEluZGV4JykpKSB7XG4gICAgICAgICAgICBjb250YWluZXJCb3VuZCA9IHRoaXMuX2dldENvbnRhaW5lckJvdW5kKCk7XG4gICAgICAgICAgICBpc0NoYW5nZWQgPSAodGhpcy5wcmV2T3ZlckNpcmNsZSAhPT0gY2lyY2xlKTtcbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSBjaXJjbGUuZGF0YSgnZ3JvdXBJbmRleCcpO1xuICAgICAgICAgICAgaW5kZXggPSBjaXJjbGUuZGF0YSgnaW5kZXgnKTtcbiAgICAgICAgICAgIGFyZ3MgPSBbe30sIGdyb3VwSW5kZXgsIGluZGV4LCB7XG4gICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGNvbnRhaW5lckJvdW5kLmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgLSBjb250YWluZXJCb3VuZC50b3BcbiAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd092ZXJsYXkoZ3JvdXBJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNDaGFuZ2VkUG9zaXRpb24odGhpcy5wcmV2UG9zaXRpb24sIHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNob3dUb29sdGlwLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldk92ZXJDaXJjbGUgPSBjaXJjbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2T3ZlckNpcmNsZSkge1xuICAgICAgICAgICAgdGhpcy5faGlkZU92ZXJsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICB0aGlzLnByZXZPdmVyQ2lyY2xlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Qgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IC0gaW5kZXggb2YgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleFxuICAgICAqL1xuICAgIF9zZWxlY3RTZXJpZXM6IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgIHZhciBjaXJjbGVJbmZvID0gdGhpcy5ncm91cENpcmNsZUluZm9zW2dyb3VwSW5kZXhdW2luZGV4XTtcbiAgICAgICAgdmFyIG9iakNvbG9yID0gcmFwaGFlbC5jb2xvcihjaXJjbGVJbmZvLmNvbG9yKTtcbiAgICAgICAgdmFyIHRoZW1lQ29sb3IgPSB0aGlzLnRoZW1lLnNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB2YXIgY29sb3IgPSB0aGVtZUNvbG9yIHx8IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VDaGFuZ2VkTHVtaW5hbmNlQ29sb3Iob2JqQ29sb3IuaGV4LCBERUZBVUxUX0xVTUlOQU5DKTtcblxuICAgICAgICBjaXJjbGVJbmZvLmNpcmNsZS5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IGNvbG9yXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbnNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggLSBpbmRleCBvZiBncm91cFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4XG4gICAgICovXG4gICAgX3Vuc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihncm91cEluZGV4LCBpbmRleCkge1xuICAgICAgICB2YXIgY2lyY2xlSW5mbyA9IHRoaXMuZ3JvdXBDaXJjbGVJbmZvc1tncm91cEluZGV4XVtpbmRleF07XG5cbiAgICAgICAgY2lyY2xlSW5mby5jaXJjbGUuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBjaXJjbGVJbmZvLmNvbG9yXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gbGVnZW5kSW5kZXggLSBpbmRleCBvZiBsZWdlbmRcbiAgICAgKi9cbiAgICBzZWxlY3RMZWdlbmQ6IGZ1bmN0aW9uKGxlZ2VuZEluZGV4KSB7XG4gICAgICAgIHZhciBub25lU2VsZWN0ZWQgPSB0dWkudXRpbC5pc051bGwobGVnZW5kSW5kZXgpO1xuXG4gICAgICAgIHJhcGhhZWxSZW5kZXJVdGlsLmZvckVhY2gyZEFycmF5KHRoaXMuZ3JvdXBDaXJjbGVJbmZvcywgZnVuY3Rpb24oY2lyY2xlSW5mbywgZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5O1xuXG4gICAgICAgICAgICBpZiAoIWNpcmNsZUluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wYWNpdHkgPSAobm9uZVNlbGVjdGVkIHx8IGxlZ2VuZEluZGV4ID09PSBpbmRleCkgPyBFTVBIQVNJU19PUEFDSVRZIDogREVfRU1QSEFTSVNfT1BBQ0lUWTtcblxuICAgICAgICAgICAgY2lyY2xlSW5mby5jaXJjbGUuYXR0cih7b3BhY2l0eTogb3BhY2l0eX0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXBoYWVsQnViYmxlQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmFwaGFlbCBsaW5lIGNoYXJ0IHJlbmRlcmVyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSYXBoYWVsTGluZUJhc2UgPSByZXF1aXJlKCcuL3JhcGhhZWxMaW5lVHlwZUJhc2UnKSxcbiAgICByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIEVNUEhBU0lTX09QQUNJVFkgPSAxO1xudmFyIERFX0VNUEhBU0lTX09QQUNJVFkgPSAwLjM7XG52YXIgTEVGVF9CQVJfV0lEVEggPSAxMDtcblxudmFyIHJhcGhhZWwgPSB3aW5kb3cuUmFwaGFlbDtcblxudmFyIFJhcGhhZWxMaW5lQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhSYXBoYWVsTGluZUJhc2UsIC8qKiBAbGVuZHMgUmFwaGFlbExpbmVDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJhcGhhZWxMaW5lQ2hhcnRzIGlzIGdyYXBoIHJlbmRlcmVyIGZvciBsaW5lIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIFJhcGhhZWxMaW5lQ2hhcnRcbiAgICAgKiBAZXh0ZW5kcyBSYXBoYWVsTGluZVR5cGVCYXNlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZWxlY3RlZCBsZWdlbmQgaW5kZXhcbiAgICAgICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0eXBlIG9mIGNoYXJ0XG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9ICdsaW5lJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGZ1bmN0aW9uIG9mIGxpbmUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7e2dyb3VwUG9zaXRpb25zOiBBcnJheS48QXJyYXk+LCBkaW1lbnNpb246IG9iamVjdCwgdGhlbWU6IG9iamVjdCwgb3B0aW9uczogb2JqZWN0fX0gZGF0YSByZW5kZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcGFwZXJdIC0gcmFwaGFlbCBwYXBlclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSwgcGFwZXIpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uO1xuICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvbnMgPSBkYXRhLmdyb3VwUG9zaXRpb25zO1xuICAgICAgICB2YXIgdGhlbWUgPSBkYXRhLnRoZW1lO1xuICAgICAgICB2YXIgY29sb3JzID0gdGhlbWUuY29sb3JzO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IGRhdGEub3B0aW9ucy5zaG93RG90ID8gMSA6IDA7XG4gICAgICAgIHZhciBpc1NwbGluZSA9IGRhdGEub3B0aW9ucy5zcGxpbmU7XG4gICAgICAgIHZhciBncm91cFBhdGhzID0gaXNTcGxpbmUgPyB0aGlzLl9nZXRTcGxpbmVMaW5lc1BhdGgoZ3JvdXBQb3NpdGlvbnMpIDogdGhpcy5fZ2V0TGluZXNQYXRoKGdyb3VwUG9zaXRpb25zKTtcbiAgICAgICAgdmFyIGJvcmRlclN0eWxlID0gdGhpcy5tYWtlQm9yZGVyU3R5bGUodGhlbWUuYm9yZGVyQ29sb3IsIG9wYWNpdHkpO1xuICAgICAgICB2YXIgb3V0RG90U3R5bGUgPSB0aGlzLm1ha2VPdXREb3RTdHlsZShvcGFjaXR5LCBib3JkZXJTdHlsZSk7XG5cbiAgICAgICAgcGFwZXIgPSBwYXBlciB8fCByYXBoYWVsKGNvbnRhaW5lciwgMSwgZGltZW5zaW9uLmhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5wYXBlciA9IHBhcGVyO1xuICAgICAgICB0aGlzLmlzU3BsaW5lID0gaXNTcGxpbmU7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uO1xuXG4gICAgICAgIHRoaXMuZ3JvdXBMaW5lcyA9IHRoaXMuX3JlbmRlckxpbmVzKHBhcGVyLCBncm91cFBhdGhzLCBjb2xvcnMpO1xuICAgICAgICB0aGlzLmxlZnRCYXIgPSB0aGlzLl9yZW5kZXJMZWZ0QmFyKGRpbWVuc2lvbi5oZWlnaHQsIGRhdGEuY2hhcnRCYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy50b29sdGlwTGluZSA9IHRoaXMuX3JlbmRlclRvb2x0aXBMaW5lKHBhcGVyLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5ncm91cERvdHMgPSB0aGlzLl9yZW5kZXJEb3RzKHBhcGVyLCBncm91cFBvc2l0aW9ucywgY29sb3JzLCBvcGFjaXR5KTtcblxuICAgICAgICBpZiAoZGF0YS5vcHRpb25zLmFsbG93U2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkRvdCA9IHRoaXMuX21ha2VTZWxlY3Rpb25Eb3QocGFwZXIpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Db2xvciA9IHRoZW1lLnNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xvcnMgPSBjb2xvcnM7XG4gICAgICAgIHRoaXMuYm9yZGVyU3R5bGUgPSBib3JkZXJTdHlsZTtcbiAgICAgICAgdGhpcy5vdXREb3RTdHlsZSA9IG91dERvdFN0eWxlO1xuICAgICAgICB0aGlzLmdyb3VwUG9zaXRpb25zID0gZ3JvdXBQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBQYXRocyA9IGdyb3VwUGF0aHM7XG4gICAgICAgIHRoaXMuZG90T3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBpdm90R3JvdXBEb3RzO1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxpbmVzIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfT4+fSBncm91cFBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxzdHJpbmc+Pn0gcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVzUGF0aDogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoZ3JvdXBQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX21ha2VMaW5lc1BhdGgocG9zaXRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzcGxpbmUgbGluZXMgcGF0aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHN0YXJ0VG9wOiBudW1iZXJ9Pj59IGdyb3VwUG9zaXRpb25zIHBvc2l0aW9uc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFNwbGluZUxpbmVzUGF0aDogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFBvc2l0aW9ucywgdGhpcy5fbWFrZVNwbGluZUxpbmVzUGF0aCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxzdHJpbmc+Pn0gZ3JvdXBQYXRocyBwYXRoc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGNvbG9ycyBsaW5lIGNvbG9yc1xuICAgICAqIEBwYXJhbSB7P251bWJlcn0gc3Ryb2tlV2lkdGggc3Ryb2tlIHdpZHRoXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGxpbmVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTGluZXM6IGZ1bmN0aW9uKHBhcGVyLCBncm91cFBhdGhzLCBjb2xvcnMsIHN0cm9rZVdpZHRoKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoZ3JvdXBQYXRocywgZnVuY3Rpb24ocGF0aCwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JzW2dyb3VwSW5kZXhdIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICByZXR1cm4gcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyTGluZShwYXBlciwgcGF0aC5qb2luKCcgJyksIGNvbG9yLCBzdHJva2VXaWR0aCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgZ3JhcGggb2YgbGluZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDpudW1iZXJ9fSBwYXJhbXMuZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0Om51bWJlciwgdG9wOm51bWJlcn0+Pn0gcGFyYW1zLmdyb3VwUG9zaXRpb25zIGdyb3VwIHBvc2l0aW9uc1xuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHBhcmFtcy5kaW1lbnNpb24sXG4gICAgICAgICAgICBncm91cFBvc2l0aW9ucyA9IHBhcmFtcy5ncm91cFBvc2l0aW9ucztcblxuICAgICAgICB0aGlzLmdyb3VwUG9zaXRpb25zID0gZ3JvdXBQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBQYXRocyA9IHRoaXMuaXNTcGxpbmUgPyB0aGlzLl9nZXRTcGxpbmVMaW5lc1BhdGgoZ3JvdXBQb3NpdGlvbnMpIDogdGhpcy5fZ2V0TGluZXNQYXRoKGdyb3VwUG9zaXRpb25zKTtcbiAgICAgICAgdGhpcy5wYXBlci5zZXRTaXplKGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIHRoaXMudG9vbHRpcExpbmUuYXR0cih7dG9wOiBkaW1lbnNpb24uaGVpZ2h0fSk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuZ3JvdXBQYXRocywgZnVuY3Rpb24ocGF0aCwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgc2VsZi5ncm91cExpbmVzW2dyb3VwSW5kZXhdLmF0dHIoe3BhdGg6IHBhdGguam9pbignICcpfSk7XG5cbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZWxmLmdyb3VwRG90c1tncm91cEluZGV4XSwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9tb3ZlRG90KGl0ZW0uZW5kRG90LmRvdCwgZ3JvdXBQb3NpdGlvbnNbZ3JvdXBJbmRleF1baW5kZXhdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGxlZ2VuZEluZGV4IGxlZ2VuZCBpbmRleFxuICAgICAqL1xuICAgIHNlbGVjdExlZ2VuZDogZnVuY3Rpb24obGVnZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgbm9uZVNlbGVjdGVkID0gdHVpLnV0aWwuaXNOdWxsKGxlZ2VuZEluZGV4KTtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXggPSBsZWdlbmRJbmRleDtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5ncm91cExpbmVzLCBmdW5jdGlvbihsaW5lLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IChub25lU2VsZWN0ZWQgfHwgbGVnZW5kSW5kZXggPT09IGdyb3VwSW5kZXgpID8gRU1QSEFTSVNfT1BBQ0lUWSA6IERFX0VNUEhBU0lTX09QQUNJVFk7XG5cbiAgICAgICAgICAgIGxpbmUuYXR0cih7J3N0cm9rZS1vcGFjaXR5Jzogb3BhY2l0eX0pO1xuXG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoc2VsZi5ncm91cERvdHNbZ3JvdXBJbmRleF0sIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZG90T3BhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmVuZERvdC5kb3QuYXR0cih7J2ZpbGwtb3BhY2l0eSc6IG9wYWNpdHl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgZm9yIGFkZGluZyBkYXRhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBmb3IgZ3JhcGggcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tTaXplIC0gdGljayBzaXplXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBncm91cFBvc2l0aW9ucyAtIGdyb3VwIHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NoaWZ0aW5nT3B0aW9uXSAtIHNoaWZ0aW5nIG9wdGlvblxuICAgICAqL1xuICAgIGFuaW1hdGVGb3JBZGRpbmdEYXRhOiBmdW5jdGlvbihkYXRhLCB0aWNrU2l6ZSwgZ3JvdXBQb3NpdGlvbnMsIHNoaWZ0aW5nT3B0aW9uKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGlzU3BsaW5lID0gZGF0YS5vcHRpb25zLnNwbGluZTtcbiAgICAgICAgdmFyIGdyb3VwUGF0aHMgPSBpc1NwbGluZSA/IHRoaXMuX2dldFNwbGluZUxpbmVzUGF0aChncm91cFBvc2l0aW9ucykgOiB0aGlzLl9nZXRMaW5lc1BhdGgoZ3JvdXBQb3NpdGlvbnMpO1xuICAgICAgICB2YXIgYWRkaXRpb25hbEluZGV4ID0gMDtcblxuICAgICAgICBpZiAoIWdyb3VwUG9zaXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoaWZ0aW5nT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRCYXIuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRpY2tTaXplICsgTEVGVF9CQVJfV0lEVEhcbiAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSW5kZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuZ3JvdXBMaW5lcywgZnVuY3Rpb24obGluZSwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIGRvdHMgPSBzZWxmLmdyb3VwRG90c1tncm91cEluZGV4XTtcbiAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uID0gZ3JvdXBQb3NpdGlvbnNbZ3JvdXBJbmRleF07XG5cbiAgICAgICAgICAgIGlmIChzaGlmdGluZ09wdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGYuX3JlbW92ZUZpcnN0RG90KGRvdHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoZG90cywgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBncm91cFBvc2l0aW9uW2luZGV4ICsgYWRkaXRpb25hbEluZGV4XTtcbiAgICAgICAgICAgICAgICBzZWxmLl9hbmltYXRlQnlQb3NpdGlvbihpdGVtLmVuZERvdC5kb3QsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZWxmLl9hbmltYXRlQnlQYXRoKGxpbmUsIGdyb3VwUGF0aHNbZ3JvdXBJbmRleF0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXBoYWVsTGluZUNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWxMaW5lVHlwZUJhc2UgaXMgYmFzZSBjbGFzcyBmb3IgbGluZSB0eXBlIHJlbmRlcmVyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIEFOSU1BVElPTl9EVVJBVElPTiA9IDcwMDtcbnZhciBERUZBVUxUX0RPVF9SQURJVVMgPSAzO1xudmFyIEhPVkVSX0RPVF9SQURJVVMgPSA0O1xudmFyIFNFTEVDVElPTl9ET1RfUkFESVVTID0gNztcbnZhciBERV9FTVBIQVNJU19PUEFDSVRZID0gMC4zO1xudmFyIE1PVklOR19BTklNQVRJT05fRFVSQVRJT04gPSAzMDA7XG52YXIgTEVGVF9CQVJfV0lEVEggPSAxMDtcblxudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBSYXBoYWVsTGluZVR5cGVCYXNlIGlzIGJhc2UgZm9yIGxpbmUgdHlwZSByZW5kZXJlci5cbiAqIEBjbGFzcyBSYXBoYWVsTGluZVR5cGVCYXNlXG4gKi9cbnZhciBSYXBoYWVsTGluZVR5cGVCYXNlID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBSYXBoYWVsTGluZVR5cGVCYXNlLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxlZnQgYmFyIGZvciBoaWRpbmcgb3ZlcmZsb3cgZ3JhcGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIGFyZWEgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0QmFja2dyb3VuZCAtIGJhY2tncm91bmQgc3R5bGUgb2YgY2hhcnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgX3JlbmRlckxlZnRCYXI6IGZ1bmN0aW9uKGhlaWdodCwgY2hhcnRCYWNrZ3JvdW5kKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICB3aWR0aDogTEVGVF9CQVJfV0lEVEgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJSZWN0KHRoaXMucGFwZXIsIGJvdW5kLCB7XG4gICAgICAgICAgICBmaWxsOiBjaGFydEJhY2tncm91bmQsXG4gICAgICAgICAgICBzdHJva2U6ICdub25lJ1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsaW5lcyBwYXRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfT59IHBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHBvc1RvcFR5cGUgcG9zaXRpb24gdG9wIHR5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZyB8IG51bWJlcj59IHBhdGhzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxpbmVzUGF0aDogZnVuY3Rpb24ocG9zaXRpb25zLCBwb3NUb3BUeXBlKSB7XG4gICAgICAgIHZhciBwYXRoO1xuXG4gICAgICAgIHBvc1RvcFR5cGUgPSBwb3NUb3BUeXBlIHx8ICd0b3AnO1xuICAgICAgICBwYXRoID0gdHVpLnV0aWwubWFwKHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBbJ0wnLCBwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbltwb3NUb3BUeXBlXV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBhdGggPSBjb25jYXQuYXBwbHkoW10sIHBhdGgpO1xuICAgICAgICBwYXRoWzBdID0gJ00nO1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW5jaG9yLiAoaHR0cDovL3JhcGhhZWxqcy5jb20vYW5hbHl0aWNzLmpzKVxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBmcm9tUG9zIGZyb20gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IG5leHRQb3MgbmV4dCBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHt7eDE6IG51bWJlciwgeTE6IG51bWJlciwgeDI6IG51bWJlciwgeTI6IG51bWJlcn19IGFuY2hvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEFuY2hvcjogZnVuY3Rpb24oZnJvbVBvcywgcG9zLCBuZXh0UG9zKSB7XG4gICAgICAgIHZhciBsMSA9IChwb3MubGVmdCAtIGZyb21Qb3MubGVmdCkgLyAyLFxuICAgICAgICAgICAgbDIgPSAobmV4dFBvcy5sZWZ0IC0gcG9zLmxlZnQpIC8gMixcbiAgICAgICAgICAgIGEgPSBNYXRoLmF0YW4oKHBvcy5sZWZ0IC0gZnJvbVBvcy5sZWZ0KSAvIE1hdGguYWJzKHBvcy50b3AgLSBmcm9tUG9zLnRvcCkpLFxuICAgICAgICAgICAgYiA9IE1hdGguYXRhbigobmV4dFBvcy5sZWZ0IC0gcG9zLmxlZnQpIC8gTWF0aC5hYnMocG9zLnRvcCAtIG5leHRQb3MudG9wKSksXG4gICAgICAgICAgICBhbHBoYSwgZHgxLCBkeTEsIGR4MiwgZHkyO1xuXG4gICAgICAgIGEgPSBmcm9tUG9zLnRvcCA8IHBvcy50b3AgPyBNYXRoLlBJIC0gYSA6IGE7XG4gICAgICAgIGIgPSBuZXh0UG9zLnRvcCA8IHBvcy50b3AgPyBNYXRoLlBJIC0gYiA6IGI7XG4gICAgICAgIGFscGhhID0gTWF0aC5QSSAvIDIgLSAoKGEgKyBiKSAlIChNYXRoLlBJICogMikpIC8gMjtcbiAgICAgICAgZHgxID0gbDEgKiBNYXRoLnNpbihhbHBoYSArIGEpO1xuICAgICAgICBkeTEgPSBsMSAqIE1hdGguY29zKGFscGhhICsgYSk7XG4gICAgICAgIGR4MiA9IGwyICogTWF0aC5zaW4oYWxwaGEgKyBiKTtcbiAgICAgICAgZHkyID0gbDIgKiBNYXRoLmNvcyhhbHBoYSArIGIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MTogcG9zLmxlZnQgLSBkeDEsXG4gICAgICAgICAgICB5MTogcG9zLnRvcCArIGR5MSxcbiAgICAgICAgICAgIHgyOiBwb3MubGVmdCArIGR4MixcbiAgICAgICAgICAgIHkyOiBwb3MudG9wICsgZHkyXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3BsaW5lIGxpbmVzIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHN0YXJ0VG9wOiBudW1iZXJ9Pn0gcG9zaXRpb25zIHBvc2l0aW9uc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nIHwgbnVtYmVyPn0gcGF0aHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3BsaW5lTGluZXNQYXRoOiBmdW5jdGlvbihwb3NpdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZmlyc3RQb3MgPSBwb3NpdGlvbnNbMF07XG4gICAgICAgIHZhciBwb3NpdGlvbnNMZW4gPSBwb3NpdGlvbnMubGVuZ3RoO1xuICAgICAgICB2YXIgZnJvbVBvcyA9IGZpcnN0UG9zO1xuICAgICAgICB2YXIgbGFzdFBvcyA9IHBvc2l0aW9uc1twb3NpdGlvbnNMZW4gLSAxXTtcbiAgICAgICAgdmFyIG1pZGRsZVBvc2l0aW9ucyA9IHBvc2l0aW9ucy5zbGljZSgxKS5zbGljZSgwLCBwb3NpdGlvbnNMZW4gLSAyKTtcbiAgICAgICAgdmFyIHBhdGggPSB0dWkudXRpbC5tYXAobWlkZGxlUG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UG9zID0gcG9zaXRpb25zW2luZGV4ICsgMl07XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gc2VsZi5fZ2V0QW5jaG9yKGZyb21Qb3MsIHBvc2l0aW9uLCBuZXh0UG9zKTtcblxuICAgICAgICAgICAgZnJvbVBvcyA9IHBvc2l0aW9uO1xuXG4gICAgICAgICAgICByZXR1cm4gW2FuY2hvci54MSwgYW5jaG9yLnkxLCBwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3AsIGFuY2hvci54MiwgYW5jaG9yLnkyXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGF0aC5wdXNoKFtsYXN0UG9zLmxlZnQsIGxhc3RQb3MudG9wLCBsYXN0UG9zLmxlZnQsIGxhc3RQb3MudG9wXSk7XG4gICAgICAgIHBhdGgudW5zaGlmdChbJ00nLCBmaXJzdFBvcy5sZWZ0LCBmaXJzdFBvcy50b3AsICdDJywgZmlyc3RQb3MubGVmdCwgZmlyc3RQb3MudG9wXSk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0b29sdGlwIGxpbmUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyVG9vbHRpcExpbmU6IGZ1bmN0aW9uKHBhcGVyLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGxpbmVQYXRoID0gcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHtcbiAgICAgICAgICAgIGxlZnQ6IDEwLFxuICAgICAgICAgICAgdG9wOiBoZWlnaHRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGVmdDogMTAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJhcGhhZWxSZW5kZXJVdGlsLnJlbmRlckxpbmUocGFwZXIsIGxpbmVQYXRoLCAndHJhbnNwYXJlbnQnLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3JkZXIgc3R5bGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJvcmRlckNvbG9yIGJvcmRlciBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7e3N0cm9rZTogc3RyaW5nLCBzdHJva2Utd2lkdGg6IG51bWJlciwgc3RyaWtlLW9wYWNpdHk6IG51bWJlcn19IGJvcmRlciBzdHlsZVxuICAgICAqL1xuICAgIG1ha2VCb3JkZXJTdHlsZTogZnVuY3Rpb24oYm9yZGVyQ29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIGJvcmRlclN0eWxlO1xuXG4gICAgICAgIGlmIChib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgYm9yZGVyU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiBvcGFjaXR5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvcmRlclN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRvdCBzdHlsZSBmb3IgbW91c2VvdXQgZXZlbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgb3BhY2l0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBib3JkZXJTdHlsZSBib3JkZXIgc3R5bGVcbiAgICAgKiBAcmV0dXJucyB7e2ZpbGwtb3BhY2l0eTogbnVtYmVyLCBzdHJva2Utb3BhY2l0eTogbnVtYmVyLCByOiBudW1iZXJ9fSBzdHlsZVxuICAgICAqL1xuICAgIG1ha2VPdXREb3RTdHlsZTogZnVuY3Rpb24ob3BhY2l0eSwgYm9yZGVyU3R5bGUpIHtcbiAgICAgICAgdmFyIG91dERvdFN0eWxlID0ge1xuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IG9wYWNpdHksXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwLFxuICAgICAgICAgICAgcjogREVGQVVMVF9ET1RfUkFESVVTXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGJvcmRlclN0eWxlKSB7XG4gICAgICAgICAgICB0dWkudXRpbC5leHRlbmQob3V0RG90U3R5bGUsIGJvcmRlclN0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXREb3RTdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGRvdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBhZXJcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gZG90IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIGRvdCBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByYXBoYWVsIGRvdFxuICAgICAqL1xuICAgIHJlbmRlckRvdDogZnVuY3Rpb24ocGFwZXIsIHBvc2l0aW9uLCBjb2xvciwgb3BhY2l0eSkge1xuICAgICAgICB2YXIgZG90ID0gcGFwZXIuY2lyY2xlKHBvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnRvcCwgREVGQVVMVF9ET1RfUkFESVVTKSxcbiAgICAgICAgICAgIGRvdFN0eWxlID0ge1xuICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBvcGFjaXR5LFxuICAgICAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZG90LmF0dHIoZG90U3R5bGUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb3Q6IGRvdCxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGRvdHMgdG8gZnJvbnQuXG4gICAgICogQHBhcmFtIHtBcnJheS48e3N0YXJ0RG90OiB7ZG90OiBvYmplY3R9LCBlbmREb3Q6IHtkb3Q6IG9iamVjdH19Pn0gZG90cyAtIGRvdHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3ZlRG90c1RvRnJvbnQ6IGZ1bmN0aW9uKGRvdHMpIHtcbiAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwuZm9yRWFjaDJkQXJyYXkoZG90cywgZnVuY3Rpb24oZG90SW5mbykge1xuICAgICAgICAgICAgZG90SW5mby5lbmREb3QuZG90LnRvRnJvbnQoKTtcbiAgICAgICAgICAgIGlmIChkb3RJbmZvLnN0YXJ0RG90KSB7XG4gICAgICAgICAgICAgICAgZG90SW5mby5zdGFydERvdC5kb3QudG9Gcm9udCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGRvdHMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGdyb3VwUG9zaXRpb25zIHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGNvbG9ycyBjb2xvcnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBvcGFjaXR5XG4gICAgICogQHJldHVybnMge0FycmF5LjxvYmplY3Q+fSBkb3RzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyRG90czogZnVuY3Rpb24ocGFwZXIsIGdyb3VwUG9zaXRpb25zLCBjb2xvcnMsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZG90cztcblxuICAgICAgICAvLyDquLDsobTsl5Ag7LqQ7Iux65CcIGRvdOydhCDri6Trpbgg64+E7ZiV7JeQIOydmO2VtCDqsIDroKTsp4Dsp4Ag7JWK6rKMIO2VmOq4sCDsnITtlbQg7KCc7J28IOyVnuycvOuhnCDsnbTrj5nsi5ztgrRcbiAgICAgICAgaWYgKHBhcGVyLmRvdHMpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdmVEb3RzVG9Gcm9udChwYXBlci5kb3RzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvdHMgPSB0dWkudXRpbC5tYXAoZ3JvdXBQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9ucywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JzW2dyb3VwSW5kZXhdO1xuXG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZG90TWFwID0ge1xuICAgICAgICAgICAgICAgICAgICBlbmREb3Q6IHNlbGYucmVuZGVyRG90KHBhcGVyLCBwb3NpdGlvbiwgY29sb3IsIG9wYWNpdHkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc1JhbmdlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gdHVpLnV0aWwuZXh0ZW5kKHt9LCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24udG9wID0gc3RhcnRQb3NpdGlvbi5zdGFydFRvcDtcbiAgICAgICAgICAgICAgICAgICAgZG90TWFwLnN0YXJ0RG90ID0gc2VsZi5yZW5kZXJEb3QocGFwZXIsIHN0YXJ0UG9zaXRpb24sIGNvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZG90TWFwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcGFwZXIuZG90cykge1xuICAgICAgICAgICAgcGFwZXIuZG90cyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g64uk66W4IOq3uOuemO2UhCDroIzrjZTrp4Eg7IucIOyVnuycvOuhnCDsnbTrj5nsi5ztgqTquLAg7JyE7ZW0IHBhcGVy7JeQIOy6kOyLse2VqFxuICAgICAgICBwYXBlci5kb3RzID0gcGFwZXIuZG90cy5jb25jYXQoZG90cyk7XG5cbiAgICAgICAgcmV0dXJuIGRvdHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjZW50ZXIgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gZnJvbVBvcyBmcm9tIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHRvUG9zIHRvIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDZW50ZXI6IGZ1bmN0aW9uKGZyb21Qb3MsIHRvUG9zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAoZnJvbVBvcy5sZWZ0ICsgdG9Qb3MubGVmdCkgLyAyLFxuICAgICAgICAgICAgdG9wOiAoZnJvbVBvcy50b3AgKyB0b1Bvcy50b3ApIC8gMlxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGRvdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZG90IHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd0RvdDogZnVuY3Rpb24oZG90KSB7XG4gICAgICAgIGRvdC5hdHRyKHtcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAxLFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMC4zLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgICAgICAgICByOiBIT1ZFUl9ET1RfUkFESVVTXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbGluZSBzdHJva2Ugd2lkdGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGxpbmUgcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3Ryb2tlV2lkdGggc3Ryb2tlIHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlTGluZVN0cm9rZVdpZHRoOiBmdW5jdGlvbihsaW5lLCBzdHJva2VXaWR0aCkge1xuICAgICAgICBsaW5lLmF0dHIoe1xuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4Om51bWJlcn19IGRhdGEgc2hvdyBpbmZvXG4gICAgICovXG4gICAgc2hvd0FuaW1hdGlvbjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgaW5kZXggPSBkYXRhLmdyb3VwSW5kZXg7IC8vIExpbmUgY2hhcnQgaGFzIHBpdm90IHZhbHVlcy5cbiAgICAgICAgdmFyIGdyb3VwSW5kZXggPSBkYXRhLmluZGV4O1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ3JvdXBMaW5lcyA/IHRoaXMuZ3JvdXBMaW5lc1tncm91cEluZGV4XSA6IHRoaXMuZ3JvdXBBcmVhc1tncm91cEluZGV4XTtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdyb3VwRG90c1tncm91cEluZGV4XVtpbmRleF07XG4gICAgICAgIHZhciBzdHJva2VXaWR0aCwgc3RhcnRMaW5lO1xuXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2hhcnRUeXBlID09PSAnYXJlYScpIHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gMjtcbiAgICAgICAgICAgIHN0YXJ0TGluZSA9IGxpbmUuc3RhcnRMaW5lO1xuICAgICAgICAgICAgbGluZSA9IGxpbmUubGluZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gMztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxpbmVTdHJva2VXaWR0aChsaW5lLCBzdHJva2VXaWR0aCk7XG5cbiAgICAgICAgaWYgKHN0YXJ0TGluZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGluZVN0cm9rZVdpZHRoKHN0YXJ0TGluZSwgc3Ryb2tlV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2hvd0RvdChpdGVtLmVuZERvdC5kb3QpO1xuXG4gICAgICAgIGlmIChpdGVtLnN0YXJ0RG90KSB7XG4gICAgICAgICAgICB0aGlzLl9zaG93RG90KGl0ZW0uc3RhcnREb3QuZG90KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGl2b3QgZ3JvdXAgZG90cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5Pn0gZG90c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFBpdm90R3JvdXBEb3RzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBpdm90R3JvdXBEb3RzKSB7XG4gICAgICAgICAgICB0aGlzLnBpdm90R3JvdXBEb3RzID0gdHVpLnV0aWwucGl2b3QodGhpcy5ncm91cERvdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGl2b3RHcm91cERvdHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgZ3JvdXAgZG90cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93R3JvdXBEb3RzOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBncm91cERvdHMgPSB0aGlzLl9nZXRQaXZvdEdyb3VwRG90cygpO1xuXG4gICAgICAgIGlmICghZ3JvdXBEb3RzW2luZGV4XSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGdyb3VwRG90c1tpbmRleF0sIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHNlbGYuX3Nob3dEb3QoaXRlbS5lbmREb3QuZG90KTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0uc3RhcnREb3QpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9zaG93RG90KGl0ZW0uc3RhcnREb3QuZG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgbGluZSBmb3IgZ3JvdXAgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBib3VuZCBib3VuZFxuICAgICAqL1xuICAgIHNob3dHcm91cFRvb2x0aXBMaW5lOiBmdW5jdGlvbihib3VuZCkge1xuICAgICAgICB2YXIgbGluZVBhdGggPSByYXBoYWVsUmVuZGVyVXRpbC5tYWtlTGluZVBhdGgoe1xuICAgICAgICAgICAgbGVmdDogYm91bmQucG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIHRvcDogYm91bmQucG9zaXRpb24udG9wICsgYm91bmQuZGltZW5zaW9uLmhlaWdodFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsZWZ0OiBib3VuZC5wb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBib3VuZC5wb3NpdGlvbi50b3BcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50b29sdGlwTGluZS5hdHRyKHtcbiAgICAgICAgICAgIHBhdGg6IGxpbmVQYXRoLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzk5OScsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAxXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGdyb3VwIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBzaG93R3JvdXBBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3Nob3dHcm91cERvdHMoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGRvdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZG90IHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBvcGFjaXR5IG9wYWNpdHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlRG90OiBmdW5jdGlvbihkb3QsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIG91dERvdFN0eWxlID0gdGhpcy5vdXREb3RTdHlsZTtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKG9wYWNpdHkpKSB7XG4gICAgICAgICAgICBvdXREb3RTdHlsZSA9IHR1aS51dGlsLmV4dGVuZCh7fSwgdGhpcy5vdXREb3RTdHlsZSwge1xuICAgICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBvcGFjaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvdC5hdHRyKG91dERvdFN0eWxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDpudW1iZXJ9fSBkYXRhIGhpZGUgaW5mb1xuICAgICAqL1xuICAgIGhpZGVBbmltYXRpb246IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZGF0YS5ncm91cEluZGV4OyAvLyBMaW5lIGNoYXJ0IGhhcyBwaXZvdCB2YWx1ZXMuXG4gICAgICAgIHZhciBncm91cEluZGV4ID0gZGF0YS5pbmRleDtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSB0aGlzLmRvdE9wYWNpdHk7XG4gICAgICAgIHZhciBncm91cERvdCA9IHRoaXMuZ3JvdXBEb3RzW2dyb3VwSW5kZXhdO1xuICAgICAgICB2YXIgbGluZSwgaXRlbSwgc3Ryb2tlV2lkdGgsIHN0YXJ0TGluZTtcblxuICAgICAgICBpZiAoIWdyb3VwRG90IHx8ICFncm91cERvdFtpbmRleF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSB0aGlzLmdyb3VwTGluZXMgPyB0aGlzLmdyb3VwTGluZXNbZ3JvdXBJbmRleF0gOiB0aGlzLmdyb3VwQXJlYXNbZ3JvdXBJbmRleF07XG4gICAgICAgIGl0ZW0gPSBncm91cERvdFtpbmRleF07XG5cbiAgICAgICAgaWYgKHRoaXMuY2hhcnRUeXBlID09PSAnYXJlYScpIHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gMTtcbiAgICAgICAgICAgIHN0YXJ0TGluZSA9IGxpbmUuc3RhcnRMaW5lO1xuICAgICAgICAgICAgbGluZSA9IGxpbmUubGluZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcGFjaXR5ICYmICF0dWkudXRpbC5pc051bGwodGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4KSAmJiB0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXggIT09IGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIG9wYWNpdHkgPSBERV9FTVBIQVNJU19PUEFDSVRZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxpbmVTdHJva2VXaWR0aChsaW5lLCBzdHJva2VXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMaW5lU3Ryb2tlV2lkdGgoc3RhcnRMaW5lLCBzdHJva2VXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5faGlkZURvdChpdGVtLmVuZERvdC5kb3QsIG9wYWNpdHkpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5zdGFydERvdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVEb3QoaXRlbS5zdGFydERvdC5kb3QsIG9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgZ3JvdXAgZG90cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlR3JvdXBEb3RzOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBncm91cERvdHMgPSB0aGlzLl9nZXRQaXZvdEdyb3VwRG90cygpO1xuICAgICAgICB2YXIgaGFzU2VsZWN0ZWRJbmRleCA9ICF0dWkudXRpbC5pc051bGwodGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4KTtcbiAgICAgICAgdmFyIGJhc2VPcGFjaXR5ID0gdGhpcy5kb3RPcGFjaXR5O1xuXG4gICAgICAgIGlmICghZ3JvdXBEb3RzW2luZGV4XSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGdyb3VwRG90c1tpbmRleF0sIGZ1bmN0aW9uKGl0ZW0sIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gYmFzZU9wYWNpdHk7XG5cbiAgICAgICAgICAgIGlmIChvcGFjaXR5ICYmIGhhc1NlbGVjdGVkSW5kZXggJiYgc2VsZi5zZWxlY3RlZExlZ2VuZEluZGV4ICE9PSBncm91cEluZGV4KSB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eSA9IERFX0VNUEhBU0lTX09QQUNJVFk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuX2hpZGVEb3QoaXRlbS5lbmREb3QuZG90LCBvcGFjaXR5KTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0uc3RhcnREb3QpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9oaWRlRG90KGl0ZW0uc3RhcnREb3QuZG90LCBvcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgbGluZSBmb3IgZ3JvdXAgdG9vbHRpcC5cbiAgICAgKi9cbiAgICBoaWRlR3JvdXBUb29sdGlwTGluZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcExpbmUuYXR0cih7XG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGdyb3VwIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBoaWRlR3JvdXBBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2hpZGVHcm91cERvdHMoaW5kZXgpO1xuICAgIH0sXG5cbiAgICBfbW92ZURvdDogZnVuY3Rpb24oZG90LCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgZG90QXR0cnMgPSB7XG4gICAgICAgICAgICBjeDogcG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIGN5OiBwb3NpdGlvbi50b3BcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5kb3RPcGFjaXR5KSB7XG4gICAgICAgICAgICBkb3RBdHRycyA9IHR1aS51dGlsLmV4dGVuZCh7J2ZpbGwtb3BhY2l0eSc6IHRoaXMuZG90T3BhY2l0eX0sIGRvdEF0dHJzLCB0aGlzLmJvcmRlclN0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvdC5hdHRyKGRvdEF0dHJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBncmFwaCBmb3Igem9vbS5cbiAgICAgKi9cbiAgICBzaG93R3JhcGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBhcGVyLnNldFNpemUodGhpcy5kaW1lbnNpb24ud2lkdGgsIHRoaXMuZGltZW5zaW9uLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25GaW5pc2ggY2FsbGJhY2tcbiAgICAgKi9cbiAgICBhbmltYXRlOiBmdW5jdGlvbihvbkZpbmlzaCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZXJpZXNXaWR0aCA9IHRoaXMuZGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgc2VyaWVzSGVpZ2h0ID0gdGhpcy5kaW1lbnNpb24uaGVpZ2h0O1xuXG4gICAgICAgIHR1aS5jaGFydC5yZW5kZXJVdGlsLmNhbmNlbEFuaW1hdGlvbih0aGlzLmFuaW1hdGlvbik7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSB0dWkuY2hhcnQucmVuZGVyVXRpbC5zdGFydEFuaW1hdGlvbihBTklNQVRJT05fRFVSQVRJT04sIGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBNYXRoLm1pbihzZXJpZXNXaWR0aCAqIHJhdGlvLCBzZXJpZXNXaWR0aCk7XG5cbiAgICAgICAgICAgIHNlbGYucGFwZXIuc2V0U2l6ZSh3aWR0aCwgc2VyaWVzSGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYgKHJhdGlvID09PSAxKSB7XG4gICAgICAgICAgICAgICAgb25GaW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VsZWN0aW9uIGRvdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHNlbGVjdGlvbiBkb3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VsZWN0aW9uRG90OiBmdW5jdGlvbihwYXBlcikge1xuICAgICAgICB2YXIgc2VsZWN0aW9uRG90ID0gcGFwZXIuY2lyY2xlKDAsIDAsIFNFTEVDVElPTl9ET1RfUkFESVVTKTtcblxuICAgICAgICBzZWxlY3Rpb25Eb3QuYXR0cih7XG4gICAgICAgICAgICAnZmlsbCc6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAwLFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMCxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25Eb3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5ncm91cERvdHNbaW5kZXhlcy5pbmRleF1baW5kZXhlcy5ncm91cEluZGV4XSxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5ncm91cFBvc2l0aW9uc1tpbmRleGVzLmluZGV4XVtpbmRleGVzLmdyb3VwSW5kZXhdO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Eb3QuYXR0cih7XG4gICAgICAgICAgICBjeDogcG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIGN5OiBwb3NpdGlvbi50b3AsXG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMC41LFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMSxcbiAgICAgICAgICAgIHN0cm9rZTogdGhpcy5zZWxlY3Rpb25Db2xvciB8fCBpdGVtLmRvdC5jb2xvclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydERvdCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydERvdC5hdHRyKHtcbiAgICAgICAgICAgICAgICBjeDogcG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgICAgICBjeTogcG9zaXRpb24uc3RhcnRUb3AsXG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAuNSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAxLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5zZWxlY3Rpb25Db2xvciB8fCBpdGVtLnN0YXJ0RG90LmNvbG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbnNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgdW5zZWxlY3RTZXJpZXM6IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdyb3VwRG90c1tpbmRleGVzLmluZGV4XVtpbmRleGVzLmdyb3VwSW5kZXhdO1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Eb3QuYXR0cih7XG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydERvdCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydERvdC5hdHRyKHtcbiAgICAgICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMCxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgd2lkdGggb3IgaGVpZ2h0IG9mIHBhcGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIGhlaWdodFxuICAgICAqL1xuICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCB0aGlzLmRpbWVuc2lvbi53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMuZGltZW5zaW9uLmhlaWdodDtcbiAgICAgICAgdGhpcy5wYXBlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGJ5IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByYXBoYWVsT2JqIC0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gLSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGVCeVBvc2l0aW9uOiBmdW5jdGlvbihyYXBoYWVsT2JqLCBwb3NpdGlvbikge1xuICAgICAgICByYXBoYWVsT2JqLmFuaW1hdGUoe1xuICAgICAgICAgICAgY3g6IHBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICBjeTogcG9zaXRpb24udG9wXG4gICAgICAgIH0sIE1PVklOR19BTklNQVRJT05fRFVSQVRJT04pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGJ5IHBhdGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJhcGhhZWxPYmogLSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZyB8IG51bWJlcj59IHBhdGhzIC0gcGF0aHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hbmltYXRlQnlQYXRoOiBmdW5jdGlvbihyYXBoYWVsT2JqLCBwYXRocykge1xuICAgICAgICByYXBoYWVsT2JqLmFuaW1hdGUoe1xuICAgICAgICAgICAgcGF0aDogcGF0aHMuam9pbignICcpXG4gICAgICAgIH0sIE1PVklOR19BTklNQVRJT05fRFVSQVRJT04pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZmlyc3QgZG90LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IGRvdHMgLSBkb3RzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRmlyc3REb3Q6IGZ1bmN0aW9uKGRvdHMpIHtcbiAgICAgICAgdmFyIGZpcnN0RG90ID0gZG90cy5zaGlmdCgpO1xuXG4gICAgICAgIGZpcnN0RG90LmVuZERvdC5kb3QucmVtb3ZlKCk7XG5cbiAgICAgICAgaWYgKGZpcnN0RG90LnN0YXJ0RG90KSB7XG4gICAgICAgICAgICBmaXJzdERvdC5zdGFydERvdC5kb3QucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgcGFwZXIuXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5wYXBlci5kb3RzO1xuICAgICAgICB0aGlzLnBhcGVyLmNsZWFyKCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbExpbmVUeXBlQmFzZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSYXBoYWVsUGllQ2hhcnRzIGlzIGdyYXBoIHJlbmRlcmVyIGZvciBtYXAgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJhcGhhZWxSZW5kZXJVdGlsID0gcmVxdWlyZSgnLi9yYXBoYWVsUmVuZGVyVXRpbCcpO1xuXG52YXIgcmFwaGFlbCA9IHdpbmRvdy5SYXBoYWVsO1xuXG52YXIgU1RST0tFX0NPTE9SID0gJ2dyYXknO1xudmFyIEFOSU1BVElPTl9EVVJBVElPTiA9IDEwMDtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFJhcGhhZWxNYXBDaGFydHMgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIG1hcCBjaGFydC5cbiAqIEBjbGFzcyBSYXBoYWVsTWFwQ2hhcnRcbiAqL1xudmFyIFJhcGhhZWxNYXBDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgUmFwaGFlbE1hcENoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGZ1bmN0aW9uIG9mIG1hcCBjaGFydC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkYXRhLmRpbWVuc2lvbiBzZXJpZXMgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5Ljx7Y29kZTogc3RyaW5nLCBwYXRoOiBzdHJpbmd9Pn0gZGF0YS5tYXAgbWFwRGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtDb2xvclNwZWN0cnVtfSBkYXRhLmNvbG9yU3BlY3RydW0gY29sb3IgbW9kZWxcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uLFxuICAgICAgICAgICAgbWFwRGltZW5zaW9uID0gZGF0YS5tYXBNb2RlbC5nZXRNYXBEaW1lbnNpb24oKSxcbiAgICAgICAgICAgIHBhcGVyO1xuXG4gICAgICAgIHRoaXMucGFwZXIgPSBwYXBlciA9IHJhcGhhZWwoY29udGFpbmVyLCBkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICB0aGlzLnNlY3RvcnMgPSB0aGlzLl9yZW5kZXJNYXAoZGF0YSk7XG4gICAgICAgIHRoaXMub3ZlckNvbG9yID0gZGF0YS50aGVtZS5vdmVyQ29sb3I7XG5cbiAgICAgICAgcGFwZXIuc2V0Vmlld0JveCgwLCAwLCBtYXBEaW1lbnNpb24ud2lkdGgsIG1hcERpbWVuc2lvbi5oZWlnaHQsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gcGFwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBtYXAgZ3JhcGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkYXRhLmRpbWVuc2lvbiBzZXJpZXMgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5Ljx7Y29kZTogc3RyaW5nLCBwYXRoOiBzdHJpbmd9Pn0gZGF0YS5tYXAgbWFwRGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtDb2xvclNwZWN0cnVtfSBkYXRhLmNvbG9yU3BlY3RydW0gY29sb3IgbW9kZWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHtzZWN0b3I6IG9iamVjdCwgY29sb3I6IHN0cmluZywgZGF0YTogb2JqZWN0fT59IHJlbmRlcmVkIG1hcCBpbmZvcm1hdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlck1hcDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyLFxuICAgICAgICAgICAgY29sb3JTcGVjdHJ1bSA9IGRhdGEuY29sb3JTcGVjdHJ1bTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGRhdGEubWFwTW9kZWwuZ2V0TWFwRGF0YSgpLCBmdW5jdGlvbihkYXR1bSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IGRhdHVtLnJhdGlvIHx8IDAsXG4gICAgICAgICAgICAgICAgY29sb3IgPSBjb2xvclNwZWN0cnVtLmdldENvbG9yKHJhdGlvKSxcbiAgICAgICAgICAgICAgICBzZWN0b3IgPSByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJBcmVhKHBhcGVyLCBkYXR1bS5wYXRoLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFNUUk9LRV9DT0xPUixcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZWN0b3IuZGF0YSgnaW5kZXgnLCBpbmRleCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VjdG9yOiBzZWN0b3IsXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIHJhdGlvOiBkYXR1bS5yYXRpb1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgc2VjdG9yIGluZGV4LlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHs/bnVtYmVyfSBmb3VuZCBpbmRleFxuICAgICAqL1xuICAgIGZpbmRTZWN0b3JJbmRleDogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHNlY3RvciA9IHRoaXMucGFwZXIuZ2V0RWxlbWVudEJ5UG9pbnQocG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wKSxcbiAgICAgICAgICAgIGZvdW5kSW5kZXggPSBzZWN0b3IgJiYgc2VjdG9yLmRhdGEoJ2luZGV4JyksXG4gICAgICAgICAgICBkYXRhID0gIXR1aS51dGlsLmlzVW5kZWZpbmVkKGZvdW5kSW5kZXgpICYmIHRoaXMuc2VjdG9yc1tmb3VuZEluZGV4XTtcblxuICAgICAgICByZXR1cm4gZGF0YSAmJiAhdHVpLnV0aWwuaXNVbmRlZmluZWQoZGF0YS5yYXRpbykgPyBmb3VuZEluZGV4IDogbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGNvbG9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqL1xuICAgIGNoYW5nZUNvbG9yOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5zZWN0b3JzW2luZGV4XTtcblxuICAgICAgICBzZWN0b3Iuc2VjdG9yLmFuaW1hdGUoe1xuICAgICAgICAgICAgZmlsbDogdGhpcy5vdmVyQ29sb3JcbiAgICAgICAgfSwgQU5JTUFUSU9OX0RVUkFUSU9OKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZSBjb2xvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICByZXN0b3JlQ29sb3I6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBzZWN0b3IgPSB0aGlzLnNlY3RvcnNbaW5kZXhdO1xuXG4gICAgICAgIHNlY3Rvci5zZWN0b3IuYW5pbWF0ZSh7XG4gICAgICAgICAgICBmaWxsOiBzZWN0b3IuY29sb3JcbiAgICAgICAgfSwgQU5JTUFUSU9OX0RVUkFUSU9OKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHNpemVcbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBzZXRTaXplOiBmdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgICAgICAgdGhpcy5wYXBlci5zZXRTaXplKGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbE1hcENoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWxNYXBMZWdlbmQgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIG1hcCBjaGFydCBsZWdlbmQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogMCovXG5cbnZhciByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIHJhcGhhZWwgPSB3aW5kb3cuUmFwaGFlbDtcblxudmFyIFBBRERJTkcgPSAxMDtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFJhcGhhZWxNYXBMZWdlbmQgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIG1hcCBjaGFydCBsZWdlbmQuXG4gKiBAY2xhc3MgUmFwaGFlbE1hcExlZ2VuZFxuICovXG52YXIgUmFwaGFlbE1hcExlZ2VuZCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgUmFwaGFlbE1hcExlZ2VuZC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBmdW5jdGlvbiBvZiBtYXAgY2hhcnQgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBsZWdlbmQgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtDb2xvclNwZWN0cnVtfSBjb2xvclNwZWN0cnVtIG1hcCBjaGFydCBjb2xvciBtb2RlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIb3Jpem9udGFsIHdoZXRoZXIgaG9yaXpvbnRhbCBsZWdlbmQgb3Igbm90XG4gICAgICogQHJldHVybnMge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY29udGFpbmVyLCBkaW1lbnNpb24sIGNvbG9yU3BlY3RydW0sIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgcGFwZXIgPSByYXBoYWVsKGNvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJHcmFkaWVudEJhcihwYXBlciwgZGltZW5zaW9uLCBjb2xvclNwZWN0cnVtLCBpc0hvcml6b250YWwpO1xuICAgICAgICB0aGlzLndlZGdlID0gdGhpcy5fcmVuZGVyV2VkZ2UocGFwZXIpO1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGdyYWRpZW50IGJhci5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBsZWdlbmQgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtDb2xvclNwZWN0cnVtfSBjb2xvclNwZWN0cnVtIG1hcCBjaGFydCBjb2xvciBtb2RlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIb3Jpem9udGFsIHdoZXRoZXIgaG9yaXpvbnRhbCBsZWdlbmQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyR3JhZGllbnRCYXI6IGZ1bmN0aW9uKHBhcGVyLCBkaW1lbnNpb24sIGNvbG9yU3BlY3RydW0sIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgcmVjdEhlaWdodCA9IGRpbWVuc2lvbi5oZWlnaHQ7XG4gICAgICAgIHZhciBsZWZ0ID0gMDtcbiAgICAgICAgdmFyIGRlZ3JlZSwgYm91bmQ7XG5cbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmVjdEhlaWdodCAtPSBQQURESU5HO1xuICAgICAgICAgICAgbGVmdCA9IFBBRERJTkcgLyAyO1xuICAgICAgICAgICAgZGVncmVlID0gMzYwO1xuICAgICAgICAgICAgdGhpcy5fbWFrZVdlZGdoUGF0aCA9IHRoaXMuX21ha2VIb3Jpem9udGFsV2VkZ2VQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVncmVlID0gMjcwO1xuICAgICAgICAgICAgdGhpcy5fbWFrZVdlZGdoUGF0aCA9IHRoaXMuX21ha2VWZXJ0aWNhbFdlZGdlUGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvdW5kID0ge1xuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIHdpZHRoOiBkaW1lbnNpb24ud2lkdGggLSBQQURESU5HLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0SGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyUmVjdChwYXBlciwgYm91bmQsIHtcbiAgICAgICAgICAgIGZpbGw6IGRlZ3JlZSArICctJyArIGNvbG9yU3BlY3RydW0uc3RhcnQgKyAnLScgKyBjb2xvclNwZWN0cnVtLmVuZCxcbiAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgd2VkZ2UuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJXZWRnZTogZnVuY3Rpb24ocGFwZXIpIHtcbiAgICAgICAgdmFyIHdlZGdlID0gcGFwZXIucGF0aCh0aGlzLnZlcnRpY2FsQmFzZVBhdGgpLmF0dHIoe1xuICAgICAgICAgICAgJ2ZpbGwnOiAnZ3JheScsXG4gICAgICAgICAgICBzdHJva2U6ICdub25lJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHdlZGdlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBiYXNlIHBhdGhcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdmVydGljYWxCYXNlUGF0aDogWydNJywgMTYsIDYsICdMJywgMjQsIDMsICdMJywgMjQsIDldLFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB2ZXJ0aWNhbCB3ZWRnZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgdG9wXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsV2VkZ2VQYXRoOiBmdW5jdGlvbih0b3ApIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnZlcnRpY2FsQmFzZVBhdGg7XG5cbiAgICAgICAgcGF0aFsyXSA9IHRvcDtcbiAgICAgICAgcGF0aFs1XSA9IHRvcCAtIDM7XG4gICAgICAgIHBhdGhbOF0gPSB0b3AgKyAzO1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIGJhc2UgcGF0aFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBob3Jpem9udGFsQmFzZVBhdGg6IFsnTScsIDUsIDE2LCAnTCcsIDgsIDI0LCAnTCcsIDIsIDI0XSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaG9yaXpvbnRhbCB3ZWRnZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGxlZnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbFdlZGdlUGF0aDogZnVuY3Rpb24obGVmdCkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuaG9yaXpvbnRhbEJhc2VQYXRoO1xuXG4gICAgICAgIGxlZnQgKz0gUEFERElORyAvIDI7XG5cbiAgICAgICAgcGF0aFsxXSA9IGxlZnQ7XG4gICAgICAgIHBhdGhbNF0gPSBsZWZ0ICsgMztcbiAgICAgICAgcGF0aFs3XSA9IGxlZnQgLSAzO1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHdlZGdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblZhbHVlIHRvcFxuICAgICAqL1xuICAgIHNob3dXZWRnZTogZnVuY3Rpb24ocG9zaXRpb25WYWx1ZSkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuX21ha2VXZWRnaFBhdGgocG9zaXRpb25WYWx1ZSk7XG5cbiAgICAgICAgdGhpcy53ZWRnZS5hdHRyKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHdlZGdlXG4gICAgICovXG4gICAgaGlkZVdlZGdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy53ZWRnZS5hdHRyKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbE1hcExlZ2VuZDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSYXBoYWVsUGllQ2hhcnRzIGlzIGdyYXBoIHJlbmRlcmVyIGZvciBwaWUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJhcGhhZWxSZW5kZXJVdGlsID0gcmVxdWlyZSgnLi9yYXBoYWVsUmVuZGVyVXRpbCcpO1xuXG52YXIgcmFwaGFlbCA9IHdpbmRvdy5SYXBoYWVsO1xuXG52YXIgREVHUkVFXzE4MCA9IDE4MDtcbnZhciBERUdSRUVfMzYwID0gMzYwO1xudmFyIE1JTl9ERUdSRUUgPSAwLjAxO1xudmFyIFJBRCA9IE1hdGguUEkgLyBERUdSRUVfMTgwO1xudmFyIExPQURJTkdfQU5JTUFUSU9OX0RVUkFUSU9OID0gNzAwO1xudmFyIEVNUEhBU0lTX09QQUNJVFkgPSAxO1xudmFyIERFX0VNUEhBU0lTX09QQUNJVFkgPSAwLjM7XG52YXIgREVGQVVMVF9MVU1JTkFOQyA9IDAuMjtcbnZhciBPVkVSTEFZX0lEID0gJ292ZXJsYXknO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgUmFwaGFlbFBpZUNoYXJ0cyBpcyBncmFwaCByZW5kZXJlciBmb3IgcGllIGNoYXJ0LlxuICogQGNsYXNzIFJhcGhhZWxQaWVDaGFydFxuICovXG52YXIgUmFwaGFlbFBpZUNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBSYXBoYWVsUGllQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZnVuY3Rpb24gb2YgcGllIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIHNlY3RvckRhdGE6IEFycmF5LjxvYmplY3Q+LFxuICAgICAqICAgICAgY2lyY2xlQm91bmQ6IHtjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByOiBudW1iZXJ9LFxuICAgICAqICAgICAgZGltZW5zaW9uOiBvYmplY3QsIHRoZW1lOiBvYmplY3QsIG9wdGlvbnM6IG9iamVjdFxuICAgICAqIH19IGRhdGEgcmVuZGVyIGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2tzIGNhbGxiYWNrc1xuICAgICAqICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLnNob3dUb29sdGlwIHNob3cgdG9vbHRpcCBmdW5jdGlvblxuICAgICAqICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLmhpZGVUb29sdGlwIGhpZGUgdG9vbHRpcCBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSwgY2FsbGJhY2tzKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBkYXRhLmRpbWVuc2lvbjtcbiAgICAgICAgdmFyIHBhcGVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByYXBoYWVsIG9iamVjdFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGRhdGEucGFwZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGFwZXIgPSBwYXBlciA9IGRhdGEucGFwZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXIgPSByYXBoYWVsKGNvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXJpZXMgY29udGFpbmVyXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByYXRpbyBmb3IgaG9sZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob2xlUmF0aW8gPSBkYXRhLm9wdGlvbnMucmFkaXVzUmFuZ2VbMF07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJhc2UgYmFja2dyb3VuZFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydEJhY2tncm91bmQgPSBkYXRhLmNoYXJ0QmFja2dyb3VuZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdHlwZSBvZiBjaGFydFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBkYXRhLmNoYXJ0VHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZnVuY3Rpb25zIGZvciB0b29sdGlwIGNvbnRyb2xcbiAgICAgICAgICogQHR5cGUge3tzaG93VG9vbHRpcDogRnVuY3Rpb24sIGhpZGVUb29sdGlwOiBGdW5jdGlvbn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogY29sb3IgZm9yIHNlbGVjdGlvblxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Db2xvciA9IGRhdGEudGhlbWUuc2VsZWN0aW9uQ29sb3I7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJvdW5kIGZvciBjaXJjbGVcbiAgICAgICAgICogQHR5cGUge3tjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByOiBudW1iZXJ9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaXJjbGVCb3VuZCA9IGRhdGEuY2lyY2xlQm91bmQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlY3RvciBhdHRyJ3MgbmFtZSBmb3IgZHJhdyBncmFwaFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWN0b3JOYW1lID0gJ3NlY3Rvcl8nICsgdGhpcy5jaGFydFR5cGU7XG5cbiAgICAgICAgdGhpcy5fc2V0U2VjdG9yQXR0cigpO1xuXG4gICAgICAgIHRoaXMuc2VjdG9ySW5mb3MgPSB0aGlzLl9yZW5kZXJQaWUoZGF0YS5zZWN0b3JEYXRhLCBkYXRhLnRoZW1lLmNvbG9ycyk7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IHRoaXMuX3JlbmRlck92ZXJsYXkoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYm91bmQgb2YgY29udGFpbmVyXG4gICAgICAgICAqIEB0eXBlIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2VsZWN0ZWQgcHJldmlvdXMgc2VjdG9yXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZTZWxlY3RlZFNlY3RvciA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZXZpb3VzIG1vdXNlIHBvc2l0aW9uXG4gICAgICAgICAqIEB0eXBlIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZQb3NpdGlvbiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZXZpb3VzIGhvdmVyIHNlY3RvclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2SG92ZXJTZWN0b3IgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgcGFwZXIuXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxlZ2VuZExpbmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXBlci5jbGVhcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlY3RvciBwYXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjeCBjZW50ZXIgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjeSBjZW50ZXIgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlIHN0YXJ0IGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlIGVuZCBhbmdlbFxuICAgICAqIEByZXR1cm5zIHt7cGF0aDogQXJyYXl9fSBzZWN0b3IgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZWN0b3JQYXRoOiBmdW5jdGlvbihjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gICAgICAgIHZhciBzdGFydFJhZGlhbiA9IHN0YXJ0QW5nbGUgKiBSQUQ7XG4gICAgICAgIHZhciBlbmRSYWRpYW4gPSBlbmRBbmdsZSAqIFJBRDtcbiAgICAgICAgdmFyIHgxID0gY3ggKyByICogTWF0aC5zaW4oc3RhcnRSYWRpYW4pOyAvLyDsm5Ag7Zi47J2YIOyLnOyekSB4IOyijO2RnFxuICAgICAgICB2YXIgeTEgPSBjeSAtIHIgKiBNYXRoLmNvcyhzdGFydFJhZGlhbik7IC8vIOybkCDtmLjsnZgg7Iuc7J6RIHkg7KKM7ZGcXG4gICAgICAgIHZhciB4MiA9IGN4ICsgciAqIE1hdGguc2luKGVuZFJhZGlhbik7IC8vIOybkCDtmLjsnZgg7KKF66OMIHgg7KKM7ZGcXG4gICAgICAgIHZhciB5MiA9IGN5IC0gciAqIE1hdGguY29zKGVuZFJhZGlhbik7IC8vIOybkCDtmLjsnZgg7KKF66OMIHkg7KKM7ZGcXG4gICAgICAgIHZhciBsYXJnZUFyY0ZsYWcgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPiBERUdSRUVfMTgwID8gMSA6IDA7XG4gICAgICAgIHZhciBwYXRoID0gWydNJywgY3gsIGN5LFxuICAgICAgICAgICAgJ0wnLCB4MSwgeTEsXG4gICAgICAgICAgICAnQScsIHIsIHIsIDAsIGxhcmdlQXJjRmxhZywgMSwgeDIsIHkyLFxuICAgICAgICAgICAgJ1onXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gcGF0aOyXkCDrjIDtlZwg7J6Q7IS47ZWcIOyEpOuqheydgCDslYTrnpgg66eB7YGs66W8IOywuOqzoFxuICAgICAgICAvLyBodHRwOi8vd3d3Lnczc2Nob29scy5jb20vc3ZnL3N2Z19wYXRoLmFzcFxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2RcbiAgICAgICAgcmV0dXJuIHtwYXRoOiBwYXRofTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZWN0b3IgcGF0aCBmb3IgZG9udXQgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN4IC0gY2VudGVyIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3kgLSBjZW50ZXIgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIC0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGUgLSBzdGFydCBhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZSAtIGVuZCBhbmdlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaG9sZVJhZGl1c10gLSBob2xlIHJhZGl1c1xuICAgICAqIEByZXR1cm5zIHt7cGF0aDogQXJyYXl9fSBzZWN0b3IgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VEb251dFNlY3RvclBhdGg6IGZ1bmN0aW9uKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGhvbGVSYWRpdXMpIHtcbiAgICAgICAgLyplc2xpbnQgbWF4LXBhcmFtczogWzIsIDZdKi9cbiAgICAgICAgdmFyIHN0YXJ0UmFkaWFuID0gc3RhcnRBbmdsZSAqIFJBRDtcbiAgICAgICAgdmFyIGVuZFJhZGlhbiA9IGVuZEFuZ2xlICogUkFEO1xuICAgICAgICB2YXIgcjIgPSBob2xlUmFkaXVzIHx8IChyICogdGhpcy5ob2xlUmF0aW8pOyAvLyDqtazrqY0g67CY7KeA66aEXG4gICAgICAgIHZhciB4MSA9IGN4ICsgciAqIE1hdGguc2luKHN0YXJ0UmFkaWFuKTtcbiAgICAgICAgdmFyIHkxID0gY3kgLSByICogTWF0aC5jb3Moc3RhcnRSYWRpYW4pO1xuICAgICAgICB2YXIgeDIgPSBjeCArIHIyICogTWF0aC5zaW4oc3RhcnRSYWRpYW4pO1xuICAgICAgICB2YXIgeTIgPSBjeSAtIHIyICogTWF0aC5jb3Moc3RhcnRSYWRpYW4pO1xuICAgICAgICB2YXIgeDMgPSBjeCArIHIgKiBNYXRoLnNpbihlbmRSYWRpYW4pO1xuICAgICAgICB2YXIgeTMgPSBjeSAtIHIgKiBNYXRoLmNvcyhlbmRSYWRpYW4pO1xuICAgICAgICB2YXIgeDQgPSBjeCArIHIyICogTWF0aC5zaW4oZW5kUmFkaWFuKTtcbiAgICAgICAgdmFyIHk0ID0gY3kgLSByMiAqIE1hdGguY29zKGVuZFJhZGlhbik7XG4gICAgICAgIHZhciBsYXJnZUFyY0ZsYWcgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPiBERUdSRUVfMTgwID8gMSA6IDA7XG4gICAgICAgIHZhciBwYXRoID0gW1xuICAgICAgICAgICAgJ00nLCB4MSwgeTEsXG4gICAgICAgICAgICAnQScsIHIsIHIsIDAsIGxhcmdlQXJjRmxhZywgMSwgeDMsIHkzLFxuICAgICAgICAgICAgJ0wnLCB4NCwgeTQsXG4gICAgICAgICAgICAnQScsIHIyLCByMiwgMCwgbGFyZ2VBcmNGbGFnLCAwLCB4MiwgeTIsXG4gICAgICAgICAgICAnWidcbiAgICAgICAgXTtcblxuICAgICAgICByZXR1cm4ge3BhdGg6IHBhdGh9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgc2VjdG9yIGF0dHJpYnV0ZSBmb3IgcmFwaGFlbCBwYXBlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTZWN0b3JBdHRyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1ha2VTZWN0b3JQYXRoO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNbdGhpcy5zZWN0b3JOYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaG9sZVJhdGlvKSB7XG4gICAgICAgICAgICBtYWtlU2VjdG9yUGF0aCA9IHRoaXMuX21ha2VEb251dFNlY3RvclBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYWtlU2VjdG9yUGF0aCA9IHRoaXMuX21ha2VTZWN0b3JQYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXBlci5jdXN0b21BdHRyaWJ1dGVzW3RoaXMuc2VjdG9yTmFtZV0gPSB0dWkudXRpbC5iaW5kKG1ha2VTZWN0b3JQYXRoLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG92ZXJsYXkuXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJPdmVybGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHBhcGVyOiB0aGlzLnBhcGVyLFxuICAgICAgICAgICAgY2lyY2xlQm91bmQ6IHtcbiAgICAgICAgICAgICAgICBjeDogMCxcbiAgICAgICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgICAgICByOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW5nbGVzOiB7XG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogMCxcbiAgICAgICAgICAgICAgICBlbmRBbmdsZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmNoYXJ0QmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaW5uZXIgPSB0aGlzLl9yZW5kZXJTZWN0b3IocGFyYW1zKTtcblxuICAgICAgICBpbm5lci5kYXRhKCdpZCcsIE9WRVJMQVlfSUQpO1xuICAgICAgICBpbm5lci5kYXRhKCdjaGFydFR5cGUnLCB0aGlzLmNoYXJ0VHlwZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlubmVyOiBpbm5lcixcbiAgICAgICAgICAgIG91dGVyOiB0aGlzLl9yZW5kZXJTZWN0b3IocGFyYW1zKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VjdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKiAgICAgIEBwYXJhbSB7e2N4OiBudW1iZXIsIGN5OiBudW1iZXIsIHI6bnVtYmVyfX0gcGFyYW1zLmNpcmNsZUJvdW5kIGNpcmNsZSBib3VuZHNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnRBbmdsZSBzdGFydCBhbmdsZVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmRBbmdsZSBlbmQgYW5nbGVcbiAgICAgKiAgICAgIEBwYXJhbSB7e2ZpbGw6IHN0cmluZywgc3Ryb2tlOiBzdHJpbmcsIHN0cmlrZS13aWR0aDogc3RyaW5nfX0gcGFyYW1zLmF0dHJzIGF0dHJzXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZWN0b3I6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgY2lyY2xlQm91bmQgPSBwYXJhbXMuY2lyY2xlQm91bmQ7XG4gICAgICAgIHZhciBhbmdsZXMgPSBwYXJhbXMuYW5nbGVzO1xuICAgICAgICB2YXIgYXR0cnMgPSBwYXJhbXMuYXR0cnM7XG5cbiAgICAgICAgYXR0cnNbdGhpcy5zZWN0b3JOYW1lXSA9IFtjaXJjbGVCb3VuZC5jeCwgY2lyY2xlQm91bmQuY3ksIGNpcmNsZUJvdW5kLnIsIGFuZ2xlcy5zdGFydEFuZ2xlLCBhbmdsZXMuZW5kQW5nbGVdO1xuXG4gICAgICAgIHJldHVybiBwYXJhbXMucGFwZXIucGF0aCgpLmF0dHIoYXR0cnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgcGllIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHNlY3RvckRhdGEgLSBzZWN0b3JEYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIC0gc2VjdG9yIGNvbG9yc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJQaWU6IGZ1bmN0aW9uKHNlY3RvckRhdGEsIGNvbG9ycykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjaXJjbGVCb3VuZCA9IHRoaXMuY2lyY2xlQm91bmQ7XG4gICAgICAgIHZhciBjaGFydEJhY2tncm91bmQgPSB0aGlzLmNoYXJ0QmFja2dyb3VuZDtcbiAgICAgICAgdmFyIHNlY3RvckluZm9zID0gW107XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHNlY3RvckRhdGEsIGZ1bmN0aW9uKHNlY3RvckRhdHVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gc2VjdG9yRGF0dW0ucmF0aW87XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvcnNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIHNlY3RvciA9IHNlbGYuX3JlbmRlclNlY3Rvcih7XG4gICAgICAgICAgICAgICAgcGFwZXI6IHNlbGYucGFwZXIsXG4gICAgICAgICAgICAgICAgY2lyY2xlQm91bmQ6IGNpcmNsZUJvdW5kLFxuICAgICAgICAgICAgICAgIGFuZ2xlczogc2VjdG9yRGF0dW0uYW5nbGVzLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IGNoYXJ0QmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBjaGFydEJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0b3IuZGF0YSgnaW5kZXgnLCBpbmRleCk7XG4gICAgICAgICAgICBzZWN0b3IuZGF0YSgnY2hhcnRUeXBlJywgc2VsZi5jaGFydFR5cGUpO1xuXG4gICAgICAgICAgICBzZWN0b3JJbmZvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWN0b3I6IHNlY3RvcixcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgYW5nbGVzOiBzZWN0b3JEYXR1bS5hbmdsZXMuZW5kLFxuICAgICAgICAgICAgICAgIHJhdGlvOiByYXRpb1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWN0b3JJbmZvcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxlZ2VuZCBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBvdXRlclBvc2l0aW9ucyBvdXRlciBwb3NpdGlvblxuICAgICAqL1xuICAgIHJlbmRlckxlZ2VuZExpbmVzOiBmdW5jdGlvbihvdXRlclBvc2l0aW9ucykge1xuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyLFxuICAgICAgICAgICAgcGF0aHM7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxlZ2VuZExpbmVzKSB7XG4gICAgICAgICAgICBwYXRocyA9IHRoaXMuX21ha2VMaW5lUGF0aHMob3V0ZXJQb3NpdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5sZWdlbmRMaW5lcyA9IHR1aS51dGlsLm1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJMaW5lKHBhcGVyLCBwYXRoLCAndHJhbnNwYXJlbnQnLCAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGluZSBwYXRocy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBvdXRlclBvc2l0aW9ucyBvdXRlciBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGxpbmUgcGF0aHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxpbmVQYXRoczogZnVuY3Rpb24ob3V0ZXJQb3NpdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gdHVpLnV0aWwubWFwKG91dGVyUG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHBvc2l0aW9ucy5zdGFydCwgcG9zaXRpb25zLm1pZGRsZSksXG4gICAgICAgICAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHBvc2l0aW9ucy5taWRkbGUsIHBvc2l0aW9ucy5lbmQpLFxuICAgICAgICAgICAgICAgICdaJ1xuICAgICAgICAgICAgXS5qb2luKCcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IG92ZXJsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93T3ZlcmxheTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIG92ZXJsYXkgPSB0aGlzLm92ZXJsYXk7XG4gICAgICAgIHZhciBzZWN0b3JJbmZvID0gdGhpcy5zZWN0b3JJbmZvc1tpbmRleF07XG4gICAgICAgIHZhciBzYSA9IHNlY3RvckluZm8uYW5nbGVzLnN0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBlYSA9IHNlY3RvckluZm8uYW5nbGVzLmVuZEFuZ2xlO1xuICAgICAgICB2YXIgY2IgPSB0aGlzLmNpcmNsZUJvdW5kO1xuICAgICAgICB2YXIgaW5uZXJBdHRycztcblxuICAgICAgICBpbm5lckF0dHJzID0ge1xuICAgICAgICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4zXG4gICAgICAgIH07XG4gICAgICAgIGlubmVyQXR0cnNbdGhpcy5zZWN0b3JOYW1lXSA9IFtjYi5jeCwgY2IuY3ksIGNiLnIsIHNhLCBlYSwgY2IuciAqIHRoaXMuaG9sZVJhdGlvXTtcbiAgICAgICAgb3ZlcmxheS5pbm5lci5hdHRyKGlubmVyQXR0cnMpO1xuICAgICAgICBvdmVybGF5LmlubmVyLmRhdGEoJ2luZGV4JywgaW5kZXgpO1xuICAgICAgICBvdmVybGF5Lm91dGVyLmF0dHIoe1xuICAgICAgICAgICAgcGF0aDogdGhpcy5fbWFrZURvbnV0U2VjdG9yUGF0aChjYi5jeCwgY2IuY3ksIGNiLnIgKyAxMCwgc2EsIGVhLCBjYi5yKS5wYXRoLFxuICAgICAgICAgICAgZmlsbDogc2VjdG9ySW5mby5jb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuM1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBvdmVybGF5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hpZGVPdmVybGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG92ZXJsYXkgPSB0aGlzLm92ZXJsYXk7XG4gICAgICAgIHZhciBhdHRycyA9IHtcbiAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBvdmVybGF5LmlubmVyLmF0dHIoYXR0cnMpO1xuICAgICAgICBvdmVybGF5Lm91dGVyLmF0dHIoYXR0cnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrXG4gICAgICovXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRlbGF5VGltZSA9IDA7XG4gICAgICAgIHZhciBzZWN0b3JOYW1lID0gdGhpcy5zZWN0b3JOYW1lO1xuICAgICAgICB2YXIgY2lyY2xlQm91bmQgPSB0aGlzLmNpcmNsZUJvdW5kO1xuICAgICAgICB2YXIgc2VjdG9yQXJncyA9IFtjaXJjbGVCb3VuZC5jeCwgY2lyY2xlQm91bmQuY3ksIGNpcmNsZUJvdW5kLnJdO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLnNlY3RvckluZm9zLCBmdW5jdGlvbihzZWN0b3JJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYW5nbGVzID0gc2VjdG9ySW5mby5hbmdsZXM7XG4gICAgICAgICAgICB2YXIgYXR0ck1hcCA9IHtcbiAgICAgICAgICAgICAgICBmaWxsOiBzZWN0b3JJbmZvLmNvbG9yXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvblRpbWUgPSBMT0FESU5HX0FOSU1BVElPTl9EVVJBVElPTiAqIHNlY3RvckluZm8ucmF0aW87XG4gICAgICAgICAgICB2YXIgYW5pbTtcblxuICAgICAgICAgICAgaWYgKChhbmdsZXMuc3RhcnRBbmdsZSA9PT0gMCkgJiYgKGFuZ2xlcy5lbmRBbmdsZSA9PT0gREVHUkVFXzM2MCkpIHtcbiAgICAgICAgICAgICAgICBhbmdsZXMuZW5kQW5nbGUgPSBERUdSRUVfMzYwIC0gTUlOX0RFR1JFRTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXR0ck1hcFtzZWN0b3JOYW1lXSA9IHNlY3RvckFyZ3MuY29uY2F0KFthbmdsZXMuc3RhcnRBbmdsZSwgYW5nbGVzLmVuZEFuZ2xlXSk7XG4gICAgICAgICAgICBhbmltID0gcmFwaGFlbC5hbmltYXRpb24oYXR0ck1hcCwgYW5pbWF0aW9uVGltZSk7XG4gICAgICAgICAgICBzZWN0b3JJbmZvLnNlY3Rvci5hbmltYXRlKGFuaW0uZGVsYXkoZGVsYXlUaW1lKSk7XG4gICAgICAgICAgICBkZWxheVRpbWUgKz0gYW5pbWF0aW9uVGltZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheVRpbWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgbGVnZW5kIGxpbmVzLlxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gbGVnZW5kSW5kZXggbGVnZW5kIGluZGV4XG4gICAgICovXG4gICAgYW5pbWF0ZUxlZ2VuZExpbmVzOiBmdW5jdGlvbihsZWdlbmRJbmRleCkge1xuICAgICAgICB2YXIgaXNOdWxsO1xuXG4gICAgICAgIGlmICghdGhpcy5sZWdlbmRMaW5lcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNOdWxsID0gdHVpLnV0aWwuaXNOdWxsKGxlZ2VuZEluZGV4KTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5sZWdlbmRMaW5lcywgZnVuY3Rpb24obGluZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gKGlzTnVsbCB8fCBsZWdlbmRJbmRleCA9PT0gaW5kZXgpID8gRU1QSEFTSVNfT1BBQ0lUWSA6IERFX0VNUEhBU0lTX09QQUNJVFk7XG5cbiAgICAgICAgICAgIGxpbmUuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgJ3N0cm9rZSc6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5Jzogb3BhY2l0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgZ3JhcGggb2YgcGllIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge3tjeDpudW1iZXIsIGN5Om51bWJlciwgcjogbnVtYmVyfX0gcGFyYW1zLmNpcmNsZUJvdW5kIGNpcmNsZSBib3VuZFxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBwYXJhbXMuZGltZW5zaW9uO1xuICAgICAgICB2YXIgY2lyY2xlQm91bmQgPSBwYXJhbXMuY2lyY2xlQm91bmQ7XG4gICAgICAgIHZhciBzZWN0b3JOYW1lID0gdGhpcy5zZWN0b3JOYW1lO1xuXG4gICAgICAgIHRoaXMuY2lyY2xlQm91bmQgPSBjaXJjbGVCb3VuZDtcbiAgICAgICAgdGhpcy5wYXBlci5zZXRTaXplKGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmQgPSBudWxsO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLnNlY3RvckluZm9zLCBmdW5jdGlvbihzZWN0b3JJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYW5nbGVzID0gc2VjdG9ySW5mby5hbmdsZXM7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgICAgIGF0dHJzW3NlY3Rvck5hbWVdID0gW2NpcmNsZUJvdW5kLmN4LCBjaXJjbGVCb3VuZC5jeSwgY2lyY2xlQm91bmQuciwgYW5nbGVzLnN0YXJ0QW5nbGUsIGFuZ2xlcy5lbmRBbmdsZV07XG4gICAgICAgICAgICBzZWN0b3JJbmZvLnNlY3Rvci5hdHRyKGF0dHJzKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmUgbGVnZW5kIGxpbmVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IG91dGVyUG9zaXRpb25zIG91dGVyIHBvc2l0aW9uc1xuICAgICAqL1xuICAgIG1vdmVMZWdlbmRMaW5lczogZnVuY3Rpb24ob3V0ZXJQb3NpdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhdGhzO1xuXG4gICAgICAgIGlmICghdGhpcy5sZWdlbmRMaW5lcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aHMgPSB0aGlzLl9tYWtlTGluZVBhdGhzKG91dGVyUG9zaXRpb25zKTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMubGVnZW5kTGluZXMsIGZ1bmN0aW9uKGxpbmUsIGluZGV4KSB7XG4gICAgICAgICAgICBsaW5lLmF0dHIoe3BhdGg6IHBhdGhzW2luZGV4XX0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdmFsaWQgc2VjdG9yIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VjdG9yIC0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1ZhbGlkU2VjdG9yOiBmdW5jdGlvbihzZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHNlY3RvciAmJiBzZWN0b3IuZGF0YSgnY2hhcnRUeXBlJykgPT09IHRoaXMuY2hhcnRUeXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGRldGVjdGVkIGxhYmVsIGVsZW1lbnQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiAtIG1vdXNlIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNEZXRlY3RlZExhYmVsOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgbGFiZWxFbGVtZW50ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5pc1N0cmluZyhsYWJlbEVsZW1lbnQuY2xhc3NOYW1lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xpY2sgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIGNsaWNrU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5wYXBlci5nZXRFbGVtZW50QnlQb2ludChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApO1xuICAgICAgICB2YXIgcHJldlNlY3RvciA9IHRoaXMucHJldlNlbGVjdGVkU2VjdG9yO1xuICAgICAgICB2YXIgc2VjdG9ySW5kZXg7XG5cbiAgICAgICAgaWYgKChzZWN0b3IgfHwgdGhpcy5faXNEZXRlY3RlZExhYmVsKHBvc2l0aW9uKSkgJiYgdGhpcy5wcmV2U2VsZWN0ZWRTZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc2VsZWN0U2VyaWVzKHRoaXMucHJldlNlbGVjdGVkU2VjdG9yLmRhdGEoJ2luZGV4JykpO1xuICAgICAgICAgICAgdGhpcy5wcmV2U2VsZWN0ZWRTZWN0b3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkU2VjdG9yKHNlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlY3RvckluZGV4ID0gc2VjdG9yLmRhdGEoJ2luZGV4Jyk7XG4gICAgICAgIHNlY3RvciA9IHRoaXMuc2VjdG9ySW5mb3Nbc2VjdG9ySW5kZXhdLnNlY3RvcjtcblxuICAgICAgICBpZiAoc2VjdG9yICE9PSBwcmV2U2VjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RTZXJpZXMoc2VjdG9ySW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5wcmV2U2VsZWN0ZWRTZWN0b3IgPSBzZWN0b3I7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VyaWVzIGNvbnRhaW5lciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBjb250YWluZXIgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDb250YWluZXJCb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXJCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJCb3VuZCA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyQm91bmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBvciBub3QuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHByZXZQb3NpdGlvbiBwcmV2aW91cyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2hhbmdlZFBvc2l0aW9uOiBmdW5jdGlvbihwcmV2UG9zaXRpb24sIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiAhcHJldlBvc2l0aW9uIHx8IHByZXZQb3NpdGlvbi5sZWZ0ICE9PSBwb3NpdGlvbi5sZWZ0IHx8IHByZXZQb3NpdGlvbi50b3AgIT09IHBvc2l0aW9uLnRvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZWN0b3IgLSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiAtIG1vdXNlIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKHNlY3RvciwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lckJvdW5kID0gdGhpcy5fZ2V0Q29udGFpbmVyQm91bmQoKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbe30sIDAsIHNlY3Rvci5kYXRhKCdpbmRleCcpLCB7XG4gICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0IC0gY29udGFpbmVyQm91bmQubGVmdCxcbiAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wIC0gY29udGFpbmVyQm91bmQudG9wXG4gICAgICAgIH1dO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5zaG93VG9vbHRpcC5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSBtb3VzZSBvbiBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICovXG4gICAgbW92ZU1vdXNlT25TZXJpZXM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBzZWN0b3IgPSB0aGlzLnBhcGVyLmdldEVsZW1lbnRCeVBvaW50KHBvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnRvcCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTZWN0b3Ioc2VjdG9yKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldkhvdmVyU2VjdG9yICE9PSBzZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG93T3ZlcmxheShzZWN0b3IuZGF0YSgnaW5kZXgnKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2SG92ZXJTZWN0b3IgPSBzZWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NoYW5nZWRQb3NpdGlvbih0aGlzLnByZXZQb3NpdGlvbiwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXAoc2VjdG9yLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2SG92ZXJTZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgdGhpcy5wcmV2SG92ZXJTZWN0b3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmV2UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZWxlY3RTZXJpZXM6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBzZWN0b3JJbmZvID0gdGhpcy5zZWN0b3JJbmZvc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpDb2xvciwgY29sb3I7XG5cbiAgICAgICAgaWYgKCFzZWN0b3JJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvYmpDb2xvciA9IHJhcGhhZWwuY29sb3Ioc2VjdG9ySW5mby5jb2xvcik7XG4gICAgICAgIGNvbG9yID0gdGhpcy5zZWxlY3Rpb25Db2xvciB8fCByYXBoYWVsUmVuZGVyVXRpbC5tYWtlQ2hhbmdlZEx1bWluYW5jZUNvbG9yKG9iakNvbG9yLmhleCwgREVGQVVMVF9MVU1JTkFOQyk7XG5cbiAgICAgICAgc2VjdG9ySW5mby5zZWN0b3IuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBjb2xvclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5lbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5zZWxlY3RTZXJpZXM6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBzZWN0b3JJbmZvID0gdGhpcy5zZWN0b3JJbmZvc1tpbmRleF07XG5cbiAgICAgICAgaWYgKCFzZWN0b3JJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZWN0b3JJbmZvLnNlY3Rvci5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IHNlY3RvckluZm8uY29sb3JcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBsZWdlbmRJbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKi9cbiAgICBzZWxlY3RMZWdlbmQ6IGZ1bmN0aW9uKGxlZ2VuZEluZGV4KSB7XG4gICAgICAgIHZhciBpc051bGwgPSB0dWkudXRpbC5pc051bGwobGVnZW5kSW5kZXgpO1xuICAgICAgICB2YXIgbGVnZW5kTGluZXMgPSB0aGlzLmxlZ2VuZExpbmVzO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLnNlY3RvckluZm9zLCBmdW5jdGlvbihzZWN0b3JJbmZvLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSAoaXNOdWxsIHx8IGxlZ2VuZEluZGV4ID09PSBpbmRleCkgPyBFTVBIQVNJU19PUEFDSVRZIDogREVfRU1QSEFTSVNfT1BBQ0lUWTtcblxuICAgICAgICAgICAgc2VjdG9ySW5mby5zZWN0b3IuYXR0cih7XG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IG9wYWNpdHlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobGVnZW5kTGluZXMpIHtcbiAgICAgICAgICAgICAgICBsZWdlbmRMaW5lc1tpbmRleF0uYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IG9wYWNpdHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbFBpZUNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWwgZm9yIHJhcGhhZWwgcmVuZGVyaW5nLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXRpbCBmb3IgcmFwaGFlbCByZW5kZXJpbmcuXG4gKiBAbW9kdWxlIHJhcGhhZWxSZW5kZXJVdGlsXG4gKi9cbnZhciByYXBoYWVsUmVuZGVyVXRpbCA9IHtcbiAgICAvKipcbiAgICAgKiBNYWtlIGxpbmUgcGF0aC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJhcGhhZWxSZW5kZXJVdGlsXG4gICAgICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IGZyb21Qb3MgZnJvbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSB0b1BvcyB0byBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBhdGhcbiAgICAgKi9cbiAgICBtYWtlTGluZVBhdGg6IGZ1bmN0aW9uKGZyb21Qb3MsIHRvUG9zLCB3aWR0aCkge1xuICAgICAgICB2YXIgZnJvbVBvaW50ID0gW2Zyb21Qb3MubGVmdCwgZnJvbVBvcy50b3BdLFxuICAgICAgICAgICAgdG9Qb2ludCA9IFt0b1Bvcy5sZWZ0LCB0b1Bvcy50b3BdO1xuXG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgMTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoZnJvbVBvaW50LCBmdW5jdGlvbihmcm9tLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvUG9pbnRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgZnJvbVBvaW50W2luZGV4XSA9IHRvUG9pbnRbaW5kZXhdID0gTWF0aC5yb3VuZChmcm9tKSAtICh3aWR0aCAlIDIgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFsnTSddLmNvbmNhdChmcm9tUG9pbnQpLmNvbmNhdCgnTCcpLmNvbmNhdCh0b1BvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxpbmUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyYXBoYWVsUmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggbGluZSBwYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIGxpbmUgY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3Ryb2tlV2lkdGggc3Ryb2tlIHdpZHRoXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBsaW5lXG4gICAgICovXG4gICAgcmVuZGVyTGluZTogZnVuY3Rpb24ocGFwZXIsIHBhdGgsIGNvbG9yLCBzdHJva2VXaWR0aCkge1xuICAgICAgICB2YXIgbGluZSA9IHBhcGVyLnBhdGgoW3BhdGhdKSxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoIHx8IDJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICBzdHJva2VTdHlsZS5zdHJva2UgPSAnI2ZmZic7XG4gICAgICAgICAgICBzdHJva2VTdHlsZVsnc3Ryb2tlLW9wYWNpdHknXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGluZS5hdHRyKHN0cm9rZVN0eWxlKTtcblxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGFyZWEgZ3JhcGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZpbGxTdHlsZSBmaWxsIHN0eWxlXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gZmlsbFN0eWxlLmZpbGwgZmlsbCBjb2xvclxuICAgICAqICAgICAgQHBhcmFtIHs/bnVtYmVyfSBmaWxsU3R5bGUub3BhY2l0eSBmaWxsIG9wYWNpdHlcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBmaWxsU3R5bGUuc3Ryb2tlIHN0cm9rZSBjb2xvclxuICAgICAqICAgICAgQHBhcmFtIHs/bnVtYmVyfSBmaWxsU3R5bGUuc3Ryb2tlLW9wYWNpdHkgc3Ryb2tlIG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59IHJhcGhhZWwgb2JqZWN0XG4gICAgICovXG4gICAgcmVuZGVyQXJlYTogZnVuY3Rpb24ocGFwZXIsIHBhdGgsIGZpbGxTdHlsZSkge1xuICAgICAgICB2YXIgYXJlYSA9IHBhcGVyLnBhdGgocGF0aCk7XG5cbiAgICAgICAgZmlsbFN0eWxlID0gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDBcbiAgICAgICAgfSwgZmlsbFN0eWxlKTtcbiAgICAgICAgYXJlYS5hdHRyKGZpbGxTdHlsZSk7XG5cbiAgICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjaXJjbGUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIC0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gLSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlcyAtIGF0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVuZGVyQ2lyY2xlOiBmdW5jdGlvbihwYXBlciwgcG9zaXRpb24sIHJhZGl1cywgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgY2lyY2xlID0gcGFwZXIuY2lyY2xlKHBvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnRvcCwgcmFkaXVzKTtcblxuICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgY2lyY2xlLmF0dHIoYXR0cmlidXRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgcmVjdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgLSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodCwgbnVtYmVyfX0gYm91bmQgLSBib3VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHJlbmRlclJlY3Q6IGZ1bmN0aW9uKHBhcGVyLCBib3VuZCwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgcmVjdCA9IHBhcGVyLnJlY3QoYm91bmQubGVmdCwgYm91bmQudG9wLCBib3VuZC53aWR0aCwgYm91bmQuaGVpZ2h0KTtcblxuICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgcmVjdC5hdHRyKGF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSByZWN0IGJvdW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlY3QgcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICovXG4gICAgdXBkYXRlUmVjdEJvdW5kOiBmdW5jdGlvbihyZWN0LCBib3VuZCkge1xuICAgICAgICByZWN0LmF0dHIoe1xuICAgICAgICAgICAgeDogYm91bmQubGVmdCxcbiAgICAgICAgICAgIHk6IGJvdW5kLnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYm91bmQuaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgaXRlbXMgb2YgbGluZSB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gZ3JvdXBJdGVtcyBncm91cCBpdGVtc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNSZW5kZXJJdGVtIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZm9yRWFjaDJkQXJyYXk6IGZ1bmN0aW9uKGdyb3VwSXRlbXMsIGZ1bmNSZW5kZXJJdGVtKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShncm91cEl0ZW1zLCBmdW5jdGlvbihpdGVtcywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGl0ZW1zLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGZ1bmNSZW5kZXJJdGVtKGl0ZW0sIGdyb3VwSW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjaGFuZ2VkIGx1bWluYW5jZSBjb2xvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4IGhheCBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsdW0gbHVtaW5hbmNlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY2hhbmdlZCBjb2xvclxuICAgICAqL1xuICAgIG1ha2VDaGFuZ2VkTHVtaW5hbmNlQ29sb3I6IGZ1bmN0aW9uKGhleCwgbHVtKSB7XG4gICAgICAgIC8qZXNsaW50IG5vLW1hZ2ljLW51bWJlcnM6IDAqL1xuICAgICAgICB2YXIgY2hhbmdlZEhleDtcblxuICAgICAgICBoZXggPSBoZXgucmVwbGFjZSgnIycsICcnKTtcbiAgICAgICAgbHVtID0gbHVtIHx8IDA7XG5cbiAgICAgICAgY2hhbmdlZEhleCA9IHR1aS51dGlsLm1hcCh0dWkudXRpbC5yYW5nZSgzKSwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBoZCA9IHBhcnNlSW50KGhleC5zdWJzdHIoaW5kZXggKiAyLCAyKSwgMTYpO1xuICAgICAgICAgICAgdmFyIG5ld0hkID0gaGQgKyAoaGQgKiBsdW0pO1xuXG4gICAgICAgICAgICBuZXdIZCA9IE1hdGgucm91bmQoTWF0aC5taW4oTWF0aC5tYXgoMCwgbmV3SGQpLCAyNTUpKS50b1N0cmluZygxNik7XG5cbiAgICAgICAgICAgIHJldHVybiB0dWkuY2hhcnQucmVuZGVyVXRpbC5mb3JtYXRUb1plcm9GaWxsKG5ld0hkLCAyKTtcbiAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuICcjJyArIGNoYW5nZWRIZXg7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSByYXBoYWVsUmVuZGVyVXRpbDtcbiIsIi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT05cbi8vIEFueSBjb3B5cmlnaHQgaXMgZGVkaWNhdGVkIHRvIHRoZSBQdWJsaWMgRG9tYWluLiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9wdWJsaWNkb21haW4vemVyby8xLjAvXG5pZiAoIXdpbmRvdy5KU09OKSB7XG4gICAgd2luZG93LkpTT04gPSB7XG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihzSlNPTikgeyByZXR1cm4gZXZhbCgnKCcgKyBzSlNPTiArICcpJyk7IH0sXG4gICAgICAgIHN0cmluZ2lmeTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYSkgPT09ICdbb2JqZWN0IEFycmF5XSc7IH07XG4gICAgICAgICAgICB2YXIgZXNjTWFwID0geydcIic6ICdcXFxcXCInLCAnXFxcXCc6ICdcXFxcXFxcXCcsICdcXGInOiAnXFxcXGInLCAnXFxmJzogJ1xcXFxmJywgJ1xcbic6ICdcXFxcbicsICdcXHInOiAnXFxcXHInLCAnXFx0JzogJ1xcXFx0J307XG4gICAgICAgICAgICB2YXIgZXNjRnVuYyA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBlc2NNYXBbbV0gfHwgJ1xcXFx1JyArIChtLmNoYXJDb2RlQXQoMCkgKyAweDEwMDAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpOyB9O1xuICAgICAgICAgICAgdmFyIGVzY1JFID0gL1tcXFxcXCJcXHUwMDAwLVxcdTAwMUZcXHUyMDI4XFx1MjAyOV0vZztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6ICdudWxsJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh2YWx1ZS50b0pTT04oKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSAnWyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSAoaSA/ICcsICcgOiAnJykgKyBzdHJpbmdpZnkodmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcyArICddJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKHN0cmluZ2lmeShrKSArICc6ICcgKyBzdHJpbmdpZnkodmFsdWVba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAneycgKyB0bXAuam9pbignLCAnKSArICd9JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1wiJyArIHZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZShlc2NSRSwgZXNjRnVuYykgKyAnXCInO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKVxuICAgIH07XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGVcbi8vIEFueSBjb3B5cmlnaHQgaXMgZGVkaWNhdGVkIHRvIHRoZSBQdWJsaWMgRG9tYWluLiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9wdWJsaWNkb21haW4vemVyby8xLjAvXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5jcmVhdGUgPSAoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBUZW1wID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnRpZXNPYmplY3QpIHtcbiAgICAgICAgICAgIGlmKHByb3RvdHlwZSAhPT0gT2JqZWN0KHByb3RvdHlwZSkgJiYgcHJvdG90eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCwgb3IgbnVsbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVGVtcC5wcm90b3R5cGUgPSBwcm90b3R5cGUgfHwge307XG4gICAgICAgICAgICBpZiAocHJvcGVydGllc09iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGVtcC5wcm90b3R5cGUsIHByb3BlcnRpZXNPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBUZW1wKCk7XG4gICAgICAgICAgICBUZW1wLnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgICAgICAvLyB0byBpbWl0YXRlIHRoZSBjYXNlIG9mIE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgICAgIGlmKHByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5fX3Byb3RvX18gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xufVxuXG4vLyBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuLy8gaHR0cDovL215Lm9wZXJhLmNvbS9lbW9sbGVyL2Jsb2cvMjAxMS8xMi8yMC9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWVyLWFuaW1hdGluZ1xuLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJ5IEVyaWsgTcO2bGxlci4gZml4ZXMgZnJvbSBQYXVsIElyaXNoIGFuZCBUaW5vIFppamRlbFxuLy8gTUlUIGxpY2Vuc2VcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgIHZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddXG4gICAgICAgICAgICB8fCB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICB9XG5cbiAgICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgICAgICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRpbWVUb0NhbGwpO1xuICAgICAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICB9O1xuICAgIH1cbn0oKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi9jb25zdCcpO1xudmFyIGNoYXJ0RmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yaWVzL2NoYXJ0RmFjdG9yeScpO1xudmFyIEJhckNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvYmFyQ2hhcnQnKTtcbnZhciBDb2x1bW5DaGFydCA9IHJlcXVpcmUoJy4vY2hhcnRzL2NvbHVtbkNoYXJ0Jyk7XG52YXIgTGluZUNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvbGluZUNoYXJ0Jyk7XG52YXIgQXJlYUNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvYXJlYUNoYXJ0Jyk7XG52YXIgQ29sdW1uTGluZUNvbWJvQ2hhcnQgPSByZXF1aXJlKCcuL2NoYXJ0cy9jb2x1bW5MaW5lQ29tYm9DaGFydCcpO1xudmFyIExpbmVBcmVhQ29tYm9DaGFydCA9IHJlcXVpcmUoJy4vY2hhcnRzL2xpbmVBcmVhQ29tYm9DaGFydCcpO1xudmFyIFBpZURvbnV0Q29tYm9DaGFydCA9IHJlcXVpcmUoJy4vY2hhcnRzL3BpZURvbnV0Q29tYm9DaGFydCcpO1xudmFyIFBpZUNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvcGllQ2hhcnQnKTtcbnZhciBCdWJibGVDaGFydCA9IHJlcXVpcmUoJy4vY2hhcnRzL2J1YmJsZUNoYXJ0Jyk7XG52YXIgU2NhdHRlckNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvc2NhdHRlckNoYXJ0Jyk7XG52YXIgSGVhdG1hcENoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvaGVhdG1hcENoYXJ0Jyk7XG52YXIgVHJlZW1hcENoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvdHJlZW1hcENoYXJ0Jyk7XG52YXIgTWFwQ2hhcnQgPSByZXF1aXJlKCcuL2NoYXJ0cy9tYXBDaGFydCcpO1xuXG5jaGFydEZhY3RvcnkucmVnaXN0ZXIoY2hhcnRDb25zdC5DSEFSVF9UWVBFX0JBUiwgQmFyQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9DT0xVTU4sIENvbHVtbkNoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfTElORSwgTGluZUNoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfQVJFQSwgQXJlYUNoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfQ09MVU1OX0xJTkVfQ09NQk8sIENvbHVtbkxpbmVDb21ib0NoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfTElORV9BUkVBX0NPTUJPLCBMaW5lQXJlYUNvbWJvQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9QSUVfRE9OVVRfQ09NQk8sIFBpZURvbnV0Q29tYm9DaGFydCk7XG5jaGFydEZhY3RvcnkucmVnaXN0ZXIoY2hhcnRDb25zdC5DSEFSVF9UWVBFX1BJRSwgUGllQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9CVUJCTEUsIEJ1YmJsZUNoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfU0NBVFRFUiwgU2NhdHRlckNoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfSEVBVE1BUCwgSGVhdG1hcENoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfVFJFRU1BUCwgVHJlZW1hcENoYXJ0KTtcbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfTUFQLCBNYXBDaGFydCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi9jb25zdCcpLFxuICAgIHRoZW1lRmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yaWVzL3RoZW1lRmFjdG9yeScpLFxuICAgIGRlZmF1bHRUaGVtZSA9IHJlcXVpcmUoJy4vdGhlbWVzL2RlZmF1bHRUaGVtZScpO1xuXG50aGVtZUZhY3RvcnkucmVnaXN0ZXIoY2hhcnRDb25zdC5ERUZBVUxUX1RIRU1FX05BTUUsIGRlZmF1bHRUaGVtZSk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQXJlYSBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuL3NlcmllcycpO1xudmFyIExpbmVUeXBlU2VyaWVzQmFzZSA9IHJlcXVpcmUoJy4vbGluZVR5cGVTZXJpZXNCYXNlJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcblxudmFyIEFyZWFDaGFydFNlcmllcyA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFNlcmllcywgLyoqIEBsZW5kcyBBcmVhQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBBcmVhIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgQXJlYUNoYXJ0U2VyaWVzXG4gICAgICogQGV4dGVuZHMgU2VyaWVzXG4gICAgICogQG1peGVzIExpbmVUeXBlU2VyaWVzQmFzZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBTZXJpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogb2JqZWN0IGZvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICogQHR5cGUge251bGwgfCB7aWQ6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdmluZ0FuaW1hdGlvbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcG9zaXRpb24gdG9wIG9mIHplcm8gcG9pbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gcG9zaXRpb24gdG9wXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBvc2l0aW9uVG9wT2ZaZXJvUG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuICAgICAgICB2YXIgbGltaXQgPSB0aGlzLmJvdW5kc01ha2VyLmdldEF4ZXNEYXRhKCkueUF4aXMubGltaXQ7XG4gICAgICAgIHZhciB0b3AgPSB0aGlzLl9nZXRMaW1pdERpc3RhbmNlRnJvbVplcm9Qb2ludChkaW1lbnNpb24uaGVpZ2h0LCBsaW1pdCkudG9NYXg7XG5cbiAgICAgICAgaWYgKGxpbWl0Lm1pbiA+PSAwICYmICF0b3ApIHtcbiAgICAgICAgICAgIHRvcCA9IGRpbWVuc2lvbi5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9wICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3RhY2tUeXBlIHBvc2l0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9Pj59IGdyb3VwUG9zaXRpb25zIGdyb3VwIHBvc2l0aW9uc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfT4+fSBzdGFja1R5cGUgcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVN0YWNrZWRQb3NpdGlvbnM6IGZ1bmN0aW9uKGdyb3VwUG9zaXRpb25zKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJykuaGVpZ2h0ICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICBmaXJzdFN0YXJ0VG9wID0gdGhpcy5fbWFrZVBvc2l0aW9uVG9wT2ZaZXJvUG9pbnQoKSxcbiAgICAgICAgICAgIHByZXZQb3NpdGlvblRvcHMgPSBbXTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGdyb3VwUG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAocG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlRvcCA9IHByZXZQb3NpdGlvblRvcHNbaW5kZXhdIHx8IGZpcnN0U3RhcnRUb3A7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRIZWlnaHQgPSBoZWlnaHQgLSBwb3NpdGlvbi50b3A7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IHByZXZUb3AgLSBzdGFja2VkSGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc3RhcnRUb3AgPSBwcmV2VG9wO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnRvcCA9IHRvcDtcblxuICAgICAgICAgICAgICAgIHByZXZQb3NpdGlvblRvcHNbaW5kZXhdID0gdG9wO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBvc2l0aW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VyaWVzV2lkdGggLSB3aWR0aCBvZiBzZXJpZXMgYXJlYVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfT4+fSBzdGFja1R5cGUgcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBvc2l0aW9uczogZnVuY3Rpb24oc2VyaWVzV2lkdGgpIHtcbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb25zID0gdGhpcy5fbWFrZUJhc2ljUG9zaXRpb25zKHNlcmllc1dpZHRoKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzVmFsaWRTdGFja09wdGlvbih0aGlzLm9wdGlvbnMuc3RhY2tUeXBlKSkge1xuICAgICAgICAgICAgZ3JvdXBQb3NpdGlvbnMgPSB0aGlzLl9tYWtlU3RhY2tlZFBvc2l0aW9ucyhncm91cFBvc2l0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXBQb3NpdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VyaWVzIGRhdGEuXG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJyksXG4gICAgICAgICAgICB6ZXJvVG9wID0gdGhpcy5fZ2V0TGltaXREaXN0YW5jZUZyb21aZXJvUG9pbnQoZGltZW5zaW9uLmhlaWdodCwgdGhpcy5kYXRhLmxpbWl0KS50b01heDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhcnRCYWNrZ3JvdW5kOiB0aGlzLmNoYXJ0QmFja2dyb3VuZCxcbiAgICAgICAgICAgIGdyb3VwUG9zaXRpb25zOiB0aGlzLl9tYWtlUG9zaXRpb25zKCksXG4gICAgICAgICAgICBoYXNSYW5nZURhdGE6IHRoaXMuX2dldFNlcmllc0RhdGFNb2RlbCgpLmhhc1JhbmdlRGF0YSgpLFxuICAgICAgICAgICAgemVyb1RvcDogemVyb1RvcCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcmVuZGVyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBmb3IgcmVyZW5kZXJpbmdcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZXJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgcGFwZXI7XG5cbiAgICAgICAgdGhpcy5fY2FuY2VsTW92aW5nQW5pbWF0aW9uKCk7XG5cbiAgICAgICAgcGFwZXIgPSBTZXJpZXMucHJvdG90eXBlLnJlcmVuZGVyLmNhbGwodGhpcywgZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcGVyO1xuICAgIH1cbn0pO1xuXG5MaW5lVHlwZVNlcmllc0Jhc2UubWl4aW4oQXJlYUNoYXJ0U2VyaWVzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcmVhQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmFyIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyk7XG52YXIgQmFyVHlwZVNlcmllc0Jhc2UgPSByZXF1aXJlKCcuL2JhclR5cGVTZXJpZXNCYXNlJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcbnZhciByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG52YXIgY2FsY3VsYXRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2FsY3VsYXRvcicpO1xuXG52YXIgQmFyQ2hhcnRTZXJpZXMgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhTZXJpZXMsIC8qKiBAbGVuZHMgQmFyQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBCYXIgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBCYXJDaGFydFNlcmllc1xuICAgICAqIEBleHRlbmRzIFNlcmllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5tb2RlbCBzZXJpZXMgbW9kZWxcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBzZXJpZXMgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBzZXJpZXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgU2VyaWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYm91bmQgb2YgYmFyIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCB0b3AgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRMZWZ0IHN0YXJ0IGxlZnQgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kTGVmdCBlbmQgbGVmdCBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBzdGFydDoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGVuZDoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfVxuICAgICAqIH19IGNvbHVtbiBjaGFydCBib3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCb3VuZDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgdG9wLCBzdGFydExlZnQsIGVuZExlZnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogc3RhcnRMZWZ0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogZW5kTGVmdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGFkZGl0aW9uYWwgbGVmdCBmb3IgZGl2aWRlZCBvcHRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVBZGRpdGlvbmFsTGVmdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxMZWZ0ID0gMDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpdmlkZWQgJiYgdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsTGVmdCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCd5QXhpcycpLndpZHRoICsgY2hhcnRDb25zdC5PVkVSTEFQUElOR19XSURUSDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhZGRpdGlvbmFsTGVmdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBiYXIgY2hhcnQgYm91bmQuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBiYXNlU2l6ZTogbnVtYmVyLFxuICAgICAqICAgICAgYmFzZVBvc2l0aW9uOiBudW1iZXIsXG4gICAgICogICAgICBzdGVwOiBudW1iZXIsXG4gICAgICogICAgICBhZGRpdGlvbmFsUG9zaXRpb246ID9udW1iZXIsXG4gICAgICogICAgICBiYXJTaXplOiBudW1iZXJcbiAgICAgKiB9fSBiYXNlRGF0YSBiYXNlIGRhdGEgZm9yIG1ha2luZyBib3VuZFxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgYmFzZVRvcDogbnVtYmVyLFxuICAgICAqICAgICAgdG9wOiBudW1iZXIsXG4gICAgICogICAgICBwbHVzTGVmdDogbnVtYmVyLFxuICAgICAqICAgICAgbWludXNMZWZ0OiBudW1iZXIsXG4gICAgICogICAgICBwcmV2U3RhY2s6ID9zdHJpbmdcbiAgICAgKiB9fSBpdGVyYXRpb25EYXRhIGl0ZXJhdGlvbiBkYXRhXG4gICAgICogQHBhcmFtIHs/Ym9vbGVhbn0gaXNTdGFja1R5cGUgd2hldGhlciBzdGFja1R5cGUgb3B0aW9uIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge1Nlcmllc0l0ZW19IHNlcmllc0l0ZW0gc2VyaWVzIGl0ZW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgc3RhcnQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBlbmQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn1cbiAgICAgKiB9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXJDaGFydEJvdW5kOiBmdW5jdGlvbihiYXNlRGF0YSwgaXRlcmF0aW9uRGF0YSwgaXNTdGFja1R5cGUsIHNlcmllc0l0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciBiYXJXaWR0aCA9IGJhc2VEYXRhLmJhc2VCYXJTaXplICogc2VyaWVzSXRlbS5yYXRpb0Rpc3RhbmNlLFxuICAgICAgICAgICAgYWRkaXRpb25hbExlZnQgPSB0aGlzLl9jYWxjdWxhdGVBZGRpdGlvbmFsTGVmdChzZXJpZXNJdGVtLnZhbHVlKSxcbiAgICAgICAgICAgIGJhclN0YXJ0TGVmdCA9IGJhc2VEYXRhLmJhc2VCYXJTaXplICogc2VyaWVzSXRlbS5zdGFydFJhdGlvLFxuICAgICAgICAgICAgc3RhcnRMZWZ0ID0gYmFzZURhdGEuYmFzZVBvc2l0aW9uICsgYmFyU3RhcnRMZWZ0ICsgYWRkaXRpb25hbExlZnQgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSxcbiAgICAgICAgICAgIGNoYW5nZWRTdGFjayA9IChzZXJpZXNJdGVtLnN0YWNrICE9PSBpdGVyYXRpb25EYXRhLnByZXZTdGFjayksXG4gICAgICAgICAgICBzdGVwQ291bnQsIGVuZExlZnQsIGJvdW5kO1xuXG4gICAgICAgIGlmICghaXNTdGFja1R5cGUgfHwgKCF0aGlzLm9wdGlvbnMuZGl2ZXJnaW5nICYmIGNoYW5nZWRTdGFjaykpIHtcbiAgICAgICAgICAgIHN0ZXBDb3VudCA9IGlzU3RhY2tUeXBlID8gdGhpcy5kYXRhUHJvY2Vzc29yLmZpbmRTdGFja0luZGV4KHNlcmllc0l0ZW0uc3RhY2spIDogaW5kZXg7XG4gICAgICAgICAgICBpdGVyYXRpb25EYXRhLnRvcCA9IChiYXNlRGF0YS5zdGVwICogc3RlcENvdW50KSArIGl0ZXJhdGlvbkRhdGEuYmFzZVRvcCArIGJhc2VEYXRhLmFkZGl0aW9uYWxQb3NpdGlvbjtcbiAgICAgICAgICAgIGl0ZXJhdGlvbkRhdGEucGx1c0xlZnQgPSAwO1xuICAgICAgICAgICAgaXRlcmF0aW9uRGF0YS5taW51c0xlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcmllc0l0ZW0udmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgZW5kTGVmdCA9IHN0YXJ0TGVmdCArIGl0ZXJhdGlvbkRhdGEucGx1c0xlZnQ7XG4gICAgICAgICAgICBpdGVyYXRpb25EYXRhLnBsdXNMZWZ0ICs9IGJhcldpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0aW9uRGF0YS5taW51c0xlZnQgLT0gYmFyV2lkdGg7XG4gICAgICAgICAgICBlbmRMZWZ0ID0gc3RhcnRMZWZ0ICsgaXRlcmF0aW9uRGF0YS5taW51c0xlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRpb25EYXRhLnByZXZTdGFjayA9IHNlcmllc0l0ZW0uc3RhY2s7XG5cbiAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlQm91bmQoYmFyV2lkdGgsIGJhc2VEYXRhLmJhclNpemUsIGl0ZXJhdGlvbkRhdGEudG9wLCBzdGFydExlZnQsIGVuZExlZnQpO1xuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZHMgb2YgYmFyIGNoYXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBib3VuZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5fZ2V0U2VyaWVzRGF0YU1vZGVsKCksXG4gICAgICAgICAgICBpc1N0YWNrZWQgPSBwcmVkaWNhdGUuaXNWYWxpZFN0YWNrT3B0aW9uKHRoaXMub3B0aW9ucy5zdGFja1R5cGUpLFxuICAgICAgICAgICAgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpLFxuICAgICAgICAgICAgYmFzZURhdGEgPSB0aGlzLl9tYWtlQmFzZURhdGFGb3JNYWtpbmdCb3VuZChkaW1lbnNpb24uaGVpZ2h0LCBkaW1lbnNpb24ud2lkdGgpO1xuXG4gICAgICAgIHJldHVybiBzZXJpZXNEYXRhTW9kZWwubWFwKGZ1bmN0aW9uKHNlcmllc0dyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYmFzZVRvcCA9IChncm91cEluZGV4ICogYmFzZURhdGEuZ3JvdXBTaXplKSArIGJhc2VEYXRhLmZpcnN0QWRkaXRpb25hbFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgICAgIGl0ZXJhdGlvbkRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VUb3A6IGJhc2VUb3AsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogYmFzZVRvcCxcbiAgICAgICAgICAgICAgICAgICAgcGx1c0xlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIG1pbnVzTGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlN0YWNrOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpdGVyYXRlZSA9IHR1aS51dGlsLmJpbmQoc2VsZi5fbWFrZUJhckNoYXJ0Qm91bmQsIHNlbGYsIGJhc2VEYXRhLCBpdGVyYXRpb25EYXRhLCBpc1N0YWNrZWQpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAubWFwKGl0ZXJhdGVlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0b3AgcG9zaXRpb24gb2Ygc3VtIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBib3VuZCBib3VuZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0b3AgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVUb3BQb3NpdGlvbk9mU3VtTGFiZWw6IGZ1bmN0aW9uKGJvdW5kLCBsYWJlbEhlaWdodCkge1xuICAgICAgICByZXR1cm4gYm91bmQudG9wICsgKChib3VuZC5oZWlnaHQgLSBsYWJlbEhlaWdodCArIGNoYXJ0Q29uc3QuVEVYVF9QQURESU5HKSAvIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGh0bWwgb2YgcGx1cyBzdW0gbGFiZWwuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVzIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBib3VuZCBib3VuZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwbHVzIHN1bSBsYWJlbCBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBsdXNTdW1MYWJlbEh0bWw6IGZ1bmN0aW9uKHZhbHVlcywgYm91bmQsIGxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIHZhciBodG1sID0gJyc7XG4gICAgICAgIHZhciBzdW0sIGZvcm1hdEZ1bmN0aW9ucywgZm9ybWF0dGVkU3VtO1xuXG4gICAgICAgIGlmIChib3VuZCkge1xuICAgICAgICAgICAgc3VtID0gY2FsY3VsYXRvci5zdW1QbHVzVmFsdWVzKHZhbHVlcyk7XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0RnVuY3Rpb25zKCk7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdW0gPSByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKHN1bSwgZm9ybWF0RnVuY3Rpb25zLCB0aGlzLmNoYXJ0VHlwZSwgJ3NlcmllcycpO1xuICAgICAgICAgICAgaHRtbCA9IHRoaXMuX21ha2VTZXJpZXNMYWJlbEh0bWwoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IGJvdW5kLmxlZnQgKyBib3VuZC53aWR0aCArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkcsXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLl9jYWxjdWxhdGVUb3BQb3NpdGlvbk9mU3VtTGFiZWwoYm91bmQsIGxhYmVsSGVpZ2h0KVxuICAgICAgICAgICAgfSwgZm9ybWF0dGVkU3VtLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBtaW51cyBzdW0gbGFiZWwgaHRtbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgdmFsdWVzXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBsdXMgbWludXMgbGFiZWwgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VNaW51c1N1bUxhYmVsSHRtbDogZnVuY3Rpb24odmFsdWVzLCBib3VuZCwgbGFiZWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcbiAgICAgICAgdmFyIHN1bSwgZm9ybWF0RnVuY3Rpb25zLCBmb3JtYXR0ZWRTdW0sIGxhYmVsV2lkdGg7XG5cbiAgICAgICAgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgICBzdW0gPSBjYWxjdWxhdG9yLnN1bU1pbnVzVmFsdWVzKHZhbHVlcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gTWF0aC5hYnMoc3VtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpO1xuICAgICAgICAgICAgZm9ybWF0dGVkU3VtID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZShzdW0sIGZvcm1hdEZ1bmN0aW9ucywgdGhpcy5jaGFydFR5cGUsICdzZXJpZXMnKTtcbiAgICAgICAgICAgIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChmb3JtYXR0ZWRTdW0sIHRoaXMudGhlbWUubGFiZWwpO1xuICAgICAgICAgICAgaHRtbCA9IHRoaXMuX21ha2VTZXJpZXNMYWJlbEh0bWwoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IGJvdW5kLmxlZnQgLSBsYWJlbFdpZHRoIC0gY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORyxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuX2NhbGN1bGF0ZVRvcFBvc2l0aW9uT2ZTdW1MYWJlbChib3VuZCwgbGFiZWxIZWlnaHQpXG4gICAgICAgICAgICB9LCBmb3JtYXR0ZWRTdW0sIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbn0pO1xuXG5CYXJUeXBlU2VyaWVzQmFzZS5taXhpbihCYXJDaGFydFNlcmllcyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFyQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmFyVHlwZVNlcmllc0Jhc2UgaXMgYmFzZSBjbGFzcyBmb3IgYmFyIHR5cGUgc2VyaWVzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBsYWJlbEhlbHBlciA9IHJlcXVpcmUoJy4vcmVuZGVyaW5nTGFiZWxIZWxwZXInKTtcbnZhciBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpO1xudmFyIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcblxudmFyIEJhclR5cGVTZXJpZXNCYXNlID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBCYXJUeXBlU2VyaWVzQmFzZS5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VyaWVzIGRhdGEuXG4gICAgICogQHJldHVybnMge29iamVjdH0gYWRkIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBCb3VuZHMgPSB0aGlzLl9tYWtlQm91bmRzKHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwQm91bmRzOiB0aGlzLmdyb3VwQm91bmRzLFxuICAgICAgICAgICAgc2VyaWVzRGF0YU1vZGVsOiB0aGlzLl9nZXRTZXJpZXNEYXRhTW9kZWwoKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJhciBndXR0ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwU2l6ZSBiYXIgZ3JvdXAgc2l6ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgZ3JvdXAgaXRlbSBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGJhciBndXR0ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQmFyR3V0dGVyOiBmdW5jdGlvbihncm91cFNpemUsIGl0ZW1Db3VudCkge1xuICAgICAgICB2YXIgYmFzZVNpemUgPSBncm91cFNpemUgLyAoaXRlbUNvdW50ICsgMSkgLyAyO1xuICAgICAgICB2YXIgc3RhbmRhcmRTaXplID0gNjtcbiAgICAgICAgdmFyIGd1dHRlcjtcblxuICAgICAgICBpZiAoYmFzZVNpemUgPD0gMikge1xuICAgICAgICAgICAgZ3V0dGVyID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlU2l6ZSA8PSBzdGFuZGFyZFNpemUpIHtcbiAgICAgICAgICAgIGd1dHRlciA9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBndXR0ZXIgPSA0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGd1dHRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBiYXIgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBTaXplIGJhciBncm91cCBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhckd1dHRlciBiYXIgcGFkZGluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgZ3JvdXAgaXRlbSBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGJhciBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhclNpemU6IGZ1bmN0aW9uKGdyb3VwU2l6ZSwgYmFyR3V0dGVyLCBpdGVtQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIChncm91cFNpemUgLSAoYmFyR3V0dGVyICogKGl0ZW1Db3VudCAtIDEpKSkgLyAoaXRlbUNvdW50ICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugb3B0aW9uIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhclNpemUgYmFyIHNpemVcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IG9wdGlvbkJhcldpZHRoIGJhcldpZHRoIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG9wdGlvbiBzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU9wdGlvblNpemU6IGZ1bmN0aW9uKGJhclNpemUsIG9wdGlvbkJhcldpZHRoKSB7XG4gICAgICAgIHZhciBvcHRpb25zU2l6ZSA9IDA7XG5cbiAgICAgICAgaWYgKG9wdGlvbkJhcldpZHRoKSB7XG4gICAgICAgICAgICBvcHRpb25zU2l6ZSA9IE1hdGgubWluKGJhclNpemUsIG9wdGlvbkJhcldpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zU2l6ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBvcHRpb25TaXplIGFuZCBiYXJTaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXJTaXplIGJhciBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvblNpemUgb3B0aW9uIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaXRlbUNvdW50IGl0ZW0gY291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBhZGRpdGlvbiBwYWRkaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQWRkaXRpb25hbFBvc2l0aW9uOiBmdW5jdGlvbihiYXJTaXplLCBvcHRpb25TaXplLCBpdGVtQ291bnQpIHtcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxQb3NpdGlvbiA9IDA7XG5cbiAgICAgICAgaWYgKG9wdGlvblNpemUgJiYgb3B0aW9uU2l6ZSA8IGJhclNpemUpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQb3NpdGlvbiA9IChiYXJTaXplIC8gMikgKyAoKGJhclNpemUgLSBvcHRpb25TaXplKSAqIGl0ZW1Db3VudCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWxQb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBiYXNlIGRhdGEgZm9yIG1ha2luZyBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZUdyb3VwU2l6ZSBiYXNlIGdyb3VwIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZUJhclNpemUgYmFzZSBiYXIgc2l6ZVxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBiYXNlQmFyU2l6ZTogbnVtYmVyLFxuICAgICAqICAgICAgZ3JvdXBTaXplOiBudW1iZXIsXG4gICAgICogICAgICBiYXJTaXplOiBudW1iZXIsXG4gICAgICogICAgICBzdGVwOiBudW1iZXIsXG4gICAgICogICAgICBmaXJzdEFkZGl0aW9uYWxQb3NpdGlvbjogbnVtYmVyLFxuICAgICAqICAgICAgYWRkaXRpb25hbFBvc2l0aW9uOiBudW1iZXIsXG4gICAgICogICAgICBiYXNlUG9zaXRpb246IG51bWJlclxuICAgICAqIH19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhc2VEYXRhRm9yTWFraW5nQm91bmQ6IGZ1bmN0aW9uKGJhc2VHcm91cFNpemUsIGJhc2VCYXJTaXplKSB7XG4gICAgICAgIHZhciBpc1N0YWNrVHlwZSA9IHByZWRpY2F0ZS5pc1ZhbGlkU3RhY2tPcHRpb24odGhpcy5vcHRpb25zLnN0YWNrVHlwZSk7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLl9nZXRTZXJpZXNEYXRhTW9kZWwoKTtcbiAgICAgICAgdmFyIGdyb3VwU2l6ZSA9IGJhc2VHcm91cFNpemUgLyBzZXJpZXNEYXRhTW9kZWwuZ2V0R3JvdXBDb3VudCgpO1xuICAgICAgICB2YXIgZmlyc3RBZGRpdGlvbmFsUG9zaXRpb24gPSAwO1xuICAgICAgICB2YXIgaXRlbUNvdW50LCBiYXJHdXR0ZXIsIGJhclNpemUsIG9wdGlvblNpemUsIGFkZGl0aW9uYWxQb3NpdGlvbiwgYmFzZVBvc2l0aW9uO1xuXG4gICAgICAgIGlmICghaXNTdGFja1R5cGUpIHtcbiAgICAgICAgICAgIGl0ZW1Db3VudCA9IHNlcmllc0RhdGFNb2RlbC5nZXRGaXJzdFNlcmllc0dyb3VwKCkuZ2V0U2VyaWVzSXRlbUNvdW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtQ291bnQgPSB0aGlzLm9wdGlvbnMuZGl2ZXJnaW5nID8gMSA6IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRTdGFja0NvdW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBiYXJHdXR0ZXIgPSB0aGlzLl9tYWtlQmFyR3V0dGVyKGdyb3VwU2l6ZSwgaXRlbUNvdW50KTtcbiAgICAgICAgYmFyU2l6ZSA9IHRoaXMuX21ha2VCYXJTaXplKGdyb3VwU2l6ZSwgYmFyR3V0dGVyLCBpdGVtQ291bnQpO1xuICAgICAgICBvcHRpb25TaXplID0gdGhpcy5fbWFrZU9wdGlvblNpemUoYmFyU2l6ZSwgdGhpcy5vcHRpb25zLmJhcldpZHRoKTtcbiAgICAgICAgYWRkaXRpb25hbFBvc2l0aW9uID0gdGhpcy5fY2FsY3VsYXRlQWRkaXRpb25hbFBvc2l0aW9uKGJhclNpemUsIG9wdGlvblNpemUsIGl0ZW1Db3VudCk7XG4gICAgICAgIGJhclNpemUgPSBvcHRpb25TaXplIHx8IGJhclNpemU7XG4gICAgICAgIGJhc2VQb3NpdGlvbiA9IHRoaXMuX2dldExpbWl0RGlzdGFuY2VGcm9tWmVyb1BvaW50KGJhc2VCYXJTaXplLCB0aGlzLmRhdGEubGltaXQpLnRvTWluO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNDb2x1bW5DaGFydCh0aGlzLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIGJhc2VQb3NpdGlvbiA9IGJhc2VCYXJTaXplIC0gYmFzZVBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYmFyV2lkdGggfHwgYmFyU2l6ZSA8IHRoaXMub3B0aW9ucy5iYXJXaWR0aCkge1xuICAgICAgICAgICAgZmlyc3RBZGRpdGlvbmFsUG9zaXRpb24gPSAoYmFyU2l6ZSAvIDIpICsgYWRkaXRpb25hbFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhc2VCYXJTaXplOiBiYXNlQmFyU2l6ZSxcbiAgICAgICAgICAgIGdyb3VwU2l6ZTogZ3JvdXBTaXplLFxuICAgICAgICAgICAgYmFyU2l6ZTogYmFyU2l6ZSxcbiAgICAgICAgICAgIHN0ZXA6IGJhckd1dHRlciArIGJhclNpemUsXG4gICAgICAgICAgICBmaXJzdEFkZGl0aW9uYWxQb3NpdGlvbjogZmlyc3RBZGRpdGlvbmFsUG9zaXRpb24sXG4gICAgICAgICAgICBhZGRpdGlvbmFsUG9zaXRpb246IGFkZGl0aW9uYWxQb3NpdGlvbixcbiAgICAgICAgICAgIGJhc2VQb3NpdGlvbjogYmFzZVBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBub3JtYWwgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxhYmVsQ29udGFpbmVyIHNlcmllcyBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJOb3JtYWxTZXJpZXNMYWJlbDogZnVuY3Rpb24obGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgdmFyIHNkbSA9IHRoaXMuX2dldFNlcmllc0RhdGFNb2RlbCgpO1xuICAgICAgICB2YXIgYm91bmRzU2V0ID0gdGhpcy5zZXJpZXNEYXRhLmdyb3VwQm91bmRzO1xuICAgICAgICB2YXIgbGFiZWxUaGVtZSA9IHRoaXMudGhlbWUubGFiZWw7XG4gICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gdGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4O1xuICAgICAgICB2YXIgcG9zaXRpb25zU2V0LCBodG1sO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNCYXJDaGFydCh0aGlzLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uc1NldCA9IGxhYmVsSGVscGVyLmJvdW5kc1RvTGFiZWxQb3NpdGlvbnNGb3JCYXJDaGFydChzZG0sIGJvdW5kc1NldCwgbGFiZWxUaGVtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbnNTZXQgPSBsYWJlbEhlbHBlci5ib3VuZHNUb0xhYmVsUG9zaXRpb25zRm9yQ29sdW1uQ2hhcnQoc2RtLCBib3VuZHNTZXQsIGxhYmVsVGhlbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaHRtbCA9IGxhYmVsSGVscGVyLm1ha2VMYWJlbHNIdG1sRm9yQm91bmRUeXBlKHNkbSwgcG9zaXRpb25zU2V0LCBsYWJlbFRoZW1lLCBzZWxlY3RlZEluZGV4KTtcblxuICAgICAgICBsYWJlbENvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1bSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVzIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHN1bSByZXN1bHQuXG4gICAgICovXG4gICAgX21ha2VTdW1WYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICB2YXIgc3VtID0gdHVpLnV0aWwuc3VtKHZhbHVlcyk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlclV0aWwuZm9ybWF0VmFsdWUoc3VtLCB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0RnVuY3Rpb25zKCksIHRoaXMuY2hhcnRUeXBlLCAnc2VpcmVzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3RhY2tUeXBlIGxhYmVsIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYm91bmQgZWxlbWVudCBib3VuZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBsYWJlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTdGFja2VkTGFiZWxQb3NpdGlvbjogZnVuY3Rpb24oYm91bmQsIGxhYmVsLCBsYWJlbEhlaWdodCkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSxcbiAgICAgICAgICAgIGxlZnQgPSBib3VuZC5sZWZ0ICsgKChib3VuZC53aWR0aCAtIGxhYmVsV2lkdGggKyBjaGFydENvbnN0LlRFWFRfUEFERElORykgLyAyKSxcbiAgICAgICAgICAgIHRvcCA9IGJvdW5kLnRvcCArICgoYm91bmQuaGVpZ2h0IC0gbGFiZWxIZWlnaHQgKyBjaGFydENvbnN0LlRFWFRfUEFERElORykgLyAyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3RhY2tUeXBlIGxhYmVscyBodG1sLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5ncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBwYXJhbXMuYm91bmRzIGJvdW5kcyxcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gbGFiZWxzIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3RhY2tlZExhYmVsc0h0bWw6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZXJpZXNHcm91cCA9IHBhcmFtcy5zZXJpZXNHcm91cCxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcGFyYW1zLmxhYmVsSGVpZ2h0LFxuICAgICAgICAgICAgaHRtbHMsIHBsdXNCb3VuZCwgbWludXNCb3VuZCwgdmFsdWVzO1xuXG4gICAgICAgIGh0bWxzID0gc2VyaWVzR3JvdXAubWFwKGZ1bmN0aW9uKHNlcmllc0l0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYm91bmQgPSBwYXJhbXMuYm91bmRzW2luZGV4XSxcbiAgICAgICAgICAgICAgICBsYWJlbEh0bWwgPSAnJyxcbiAgICAgICAgICAgICAgICBib3VuZEVuZCwgcG9zaXRpb247XG5cbiAgICAgICAgICAgIGlmIChib3VuZCAmJiBzZXJpZXNJdGVtKSB7XG4gICAgICAgICAgICAgICAgYm91bmRFbmQgPSBib3VuZC5lbmQ7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBzZWxmLl9tYWtlU3RhY2tlZExhYmVsUG9zaXRpb24oYm91bmRFbmQsIHNlcmllc0l0ZW0ubGFiZWwsIHBhcmFtcy5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgbGFiZWxIdG1sID0gc2VsZi5fbWFrZVNlcmllc0xhYmVsSHRtbChwb3NpdGlvbiwgc2VyaWVzSXRlbS5sYWJlbCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VyaWVzSXRlbS52YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBwbHVzQm91bmQgPSBib3VuZEVuZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VyaWVzSXRlbS52YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICBtaW51c0JvdW5kID0gYm91bmRFbmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsYWJlbEh0bWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhY2tUeXBlID09PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgdmFsdWVzID0gc2VyaWVzR3JvdXAucGx1Y2soJ3ZhbHVlJyk7XG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMuX21ha2VQbHVzU3VtTGFiZWxIdG1sKHZhbHVlcywgcGx1c0JvdW5kLCBsYWJlbEhlaWdodCkpO1xuICAgICAgICAgICAgaHRtbHMucHVzaCh0aGlzLl9tYWtlTWludXNTdW1MYWJlbEh0bWwodmFsdWVzLCBtaW51c0JvdW5kLCBsYWJlbEhlaWdodCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc3RhY2tUeXBlIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFNlcmllc0xhYmVsQXJlYSBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU3RhY2tlZFNlcmllc0xhYmVsOiBmdW5jdGlvbihlbFNlcmllc0xhYmVsQXJlYSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBncm91cEJvdW5kcyA9IHRoaXMuc2VyaWVzRGF0YS5ncm91cEJvdW5kcztcbiAgICAgICAgdmFyIHNlcmllc0RhdGFNb2RlbCA9IHRoaXMuX2dldFNlcmllc0RhdGFNb2RlbCgpO1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQoY2hhcnRDb25zdC5NQVhfSEVJR0hUX1dPUkxELCB0aGlzLnRoZW1lLmxhYmVsKTtcbiAgICAgICAgdmFyIGh0bWwgPSBzZXJpZXNEYXRhTW9kZWwubWFwKGZ1bmN0aW9uKHNlcmllc0dyb3VwLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsc0h0bWwgPSBzZWxmLl9tYWtlU3RhY2tlZExhYmVsc0h0bWwoe1xuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIHNlcmllc0dyb3VwOiBzZXJpZXNHcm91cCxcbiAgICAgICAgICAgICAgICBib3VuZHM6IGdyb3VwQm91bmRzW2luZGV4XSxcbiAgICAgICAgICAgICAgICBsYWJlbEhlaWdodDogbGFiZWxIZWlnaHRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzSHRtbDtcbiAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgZWxTZXJpZXNMYWJlbEFyZWEuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFNlcmllc0xhYmVsQXJlYSBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU2VyaWVzTGFiZWw6IGZ1bmN0aW9uKGVsU2VyaWVzTGFiZWxBcmVhKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhY2tUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGFja2VkU2VyaWVzTGFiZWwoZWxTZXJpZXNMYWJlbEFyZWEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTm9ybWFsU2VyaWVzTGFiZWwoZWxTZXJpZXNMYWJlbEFyZWEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkJhclR5cGVTZXJpZXNCYXNlLm1peGluID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHR1aS51dGlsLmV4dGVuZChmdW5jLnByb3RvdHlwZSwgQmFyVHlwZVNlcmllc0Jhc2UucHJvdG90eXBlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFyVHlwZVNlcmllc0Jhc2U7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQnViYmxlIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyk7XG52YXIgQ29vcmRpbmF0ZVR5cGVTZXJpZXNCYXNlID0gcmVxdWlyZSgnLi9jb29yZGluYXRlVHlwZVNlcmllc0Jhc2UnKTtcblxudmFyIEJ1YmJsZUNoYXJ0U2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoU2VyaWVzLCAvKiogQGxlbmRzIEJ1YmJsZUNoYXJ0U2VyaWVzLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQnViYmxlIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgQnViYmxlQ2hhcnRTZXJpZXNcbiAgICAgKiBAZXh0ZW5kcyBTZXJpZXNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgU2VyaWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBzdGVwIHZhbHVlIGZvciBsYWJlbCBheGlzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlU3RlcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGVwID0gMDtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiwgc2VyaWVzRGF0YU1vZGVsLCBzaXplLCBsZW47XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YVByb2Nlc3Nvci5oYXNDYXRlZ29yaWVzKGZhbHNlKSkge1xuICAgICAgICAgICAgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuICAgICAgICAgICAgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5fZ2V0U2VyaWVzRGF0YU1vZGVsKCk7XG4gICAgICAgICAgICBsZW4gPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Q2F0ZWdvcnlDb3VudChmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXNEYXRhTW9kZWwuaXNYQ291bnRHcmVhdGVyVGhhbllDb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGRpbWVuc2lvbi5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpemUgPSBkaW1lbnNpb24ud2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0ZXAgPSBzaXplIC8gbGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYm91bmQgZm9yIGJ1YmJsZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlciwgcjogbnVtYmVyfX0gcmF0aW9NYXAgLSByYXRpbyBtYXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25CeVN0ZXAgLSBwb3NpdGlvbiB2YWx1ZSBieSBzdGVwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFJhZGl1cyAtIG1heCByYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHJhZGl1czogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQm91bmQ6IGZ1bmN0aW9uKHJhdGlvTWFwLCBwb3NpdGlvbkJ5U3RlcCwgbWF4UmFkaXVzKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJyk7XG4gICAgICAgIHZhciBsZWZ0ID0gdHVpLnV0aWwuaXNFeGlzdHkocmF0aW9NYXAueCkgPyAocmF0aW9NYXAueCAqIGRpbWVuc2lvbi53aWR0aCkgOiBwb3NpdGlvbkJ5U3RlcDtcbiAgICAgICAgdmFyIHRvcCA9IHR1aS51dGlsLmlzRXhpc3R5KHJhdGlvTWFwLnkpID8gKHJhdGlvTWFwLnkgKiBkaW1lbnNpb24uaGVpZ2h0KSA6IHBvc2l0aW9uQnlTdGVwO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgdG9wOiBkaW1lbnNpb24uaGVpZ2h0IC0gdG9wLFxuICAgICAgICAgICAgcmFkaXVzOiBNYXRoLm1heChtYXhSYWRpdXMgKiByYXRpb01hcC5yLCAyKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kcyBmb3IgYnViYmxlIGNoYXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByYWRpdXM6IG51bWJlcn0+Pn0gcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlcmllc0RhdGFNb2RlbCA9IHRoaXMuX2dldFNlcmllc0RhdGFNb2RlbCgpO1xuICAgICAgICB2YXIgbWF4UmFkaXVzID0gdGhpcy5ib3VuZHNNYWtlci5nZXRNYXhSYWRpdXNGb3JCdWJibGVDaGFydCgpO1xuICAgICAgICB2YXIgc3RlcCA9IHRoaXMuX2NhbGN1bGF0ZVN0ZXAoKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gc3RlcCA/IHN0ZXAgLyAyIDogMDtcblxuICAgICAgICByZXR1cm4gc2VyaWVzRGF0YU1vZGVsLm1hcChmdW5jdGlvbihzZXJpZXNHcm91cCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkJ5U3RlcCA9IHN0YXJ0ICsgKHN0ZXAgKiBpbmRleCk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNHcm91cC5tYXAoZnVuY3Rpb24oc2VyaWVzSXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNSYXRpb25NYXAgPSAoc2VyaWVzSXRlbSAmJiBzZXJpZXNJdGVtLnJhdGlvTWFwKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNSYXRpb25NYXAgPyBzZWxmLl9tYWtlQm91bmQoc2VyaWVzSXRlbS5yYXRpb01hcCwgcG9zaXRpb25CeVN0ZXAsIG1heFJhZGl1cykgOiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5Db29yZGluYXRlVHlwZVNlcmllc0Jhc2UubWl4aW4oQnViYmxlQ2hhcnRTZXJpZXMpO1xudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKEJ1YmJsZUNoYXJ0U2VyaWVzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWJibGVDaGFydFNlcmllcztcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb2x1bW4gY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2VyaWVzID0gcmVxdWlyZSgnLi9zZXJpZXMnKTtcbnZhciBCYXJUeXBlU2VyaWVzQmFzZSA9IHJlcXVpcmUoJy4vYmFyVHlwZVNlcmllc0Jhc2UnKTtcbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpO1xudmFyIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcbnZhciBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxjdWxhdG9yJyk7XG5cbnZhciBDb2x1bW5DaGFydFNlcmllcyA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFNlcmllcywgLyoqIEBsZW5kcyBDb2x1bW5DaGFydFNlcmllcy5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIENvbHVtbiBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIENvbHVtbkNoYXJ0U2VyaWVzXG4gICAgICogQGV4dGVuZHMgU2VyaWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm1vZGVsIHNlcmllcyBtb2RlbFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIHNlcmllcyBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBTZXJpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZCBvZiBjb2x1bW4gY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCB0b3AgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRUb3Agc3RhcnQgdG9wIHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFRvcCBlbmQgdG9wIHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIHN0YXJ0OiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgZW5kOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9XG4gICAgICogfX0gY29sdW1uIGNoYXJ0IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJvdW5kOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBsZWZ0LCBzdGFydFRvcCwgZW5kVG9wKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIHRvcDogc3RhcnRUb3AsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgdG9wOiBlbmRUb3AsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjb2x1bW4gY2hhcnQgYm91bmQuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBiYXNlU2l6ZTogbnVtYmVyLFxuICAgICAqICAgICAgYmFzZVBvc2l0aW9uOiBudW1iZXIsXG4gICAgICogICAgICBzdGVwOiBudW1iZXIsXG4gICAgICogICAgICBhZGRpdGlvbmFsUG9zaXRpb246ID9udW1iZXIsXG4gICAgICogICAgICBiYXJTaXplOiBudW1iZXJcbiAgICAgKiB9fSBiYXNlRGF0YSBiYXNlIGRhdGEgZm9yIG1ha2luZyBib3VuZFxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgYmFzZUxlZnQ6IG51bWJlcixcbiAgICAgKiAgICAgIGxlZnQ6IG51bWJlcixcbiAgICAgKiAgICAgIHBsdXNUb3A6IG51bWJlcixcbiAgICAgKiAgICAgIG1pbnVzVG9wOiBudW1iZXIsXG4gICAgICogICAgICBwcmV2U3RhY2s6ID9zdHJpbmdcbiAgICAgKiB9fSBpdGVyYXRpb25EYXRhIGl0ZXJhdGlvbiBkYXRhXG4gICAgICogQHBhcmFtIHs/Ym9vbGVhbn0gaXNTdGFja1R5cGUgd2hldGhlciBzdGFja1R5cGUgb3B0aW9uIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge1Nlcmllc0l0ZW19IHNlcmllc0l0ZW0gc2VyaWVzIGl0ZW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgc3RhcnQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBlbmQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn1cbiAgICAgKiB9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDb2x1bW5DaGFydEJvdW5kOiBmdW5jdGlvbihiYXNlRGF0YSwgaXRlcmF0aW9uRGF0YSwgaXNTdGFja1R5cGUsIHNlcmllc0l0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciBiYXJIZWlnaHQgPSBNYXRoLmFicyhiYXNlRGF0YS5iYXNlQmFyU2l6ZSAqIHNlcmllc0l0ZW0ucmF0aW9EaXN0YW5jZSksXG4gICAgICAgICAgICBiYXJTdGFydFRvcCA9IGJhc2VEYXRhLmJhc2VCYXJTaXplICogc2VyaWVzSXRlbS5zdGFydFJhdGlvLFxuICAgICAgICAgICAgc3RhcnRUb3AgPSBiYXNlRGF0YS5iYXNlUG9zaXRpb24gLSBiYXJTdGFydFRvcCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgY2hhbmdlZFN0YWNrID0gKHNlcmllc0l0ZW0uc3RhY2sgIT09IGl0ZXJhdGlvbkRhdGEucHJldlN0YWNrKSxcbiAgICAgICAgICAgIHN0ZXBDb3VudCwgZW5kVG9wLCBib3VuZDtcblxuICAgICAgICBpZiAoIWlzU3RhY2tUeXBlIHx8ICghdGhpcy5vcHRpb25zLmRpdmVyZ2luZyAmJiBjaGFuZ2VkU3RhY2spKSB7XG4gICAgICAgICAgICBzdGVwQ291bnQgPSBpc1N0YWNrVHlwZSA/IHRoaXMuZGF0YVByb2Nlc3Nvci5maW5kU3RhY2tJbmRleChzZXJpZXNJdGVtLnN0YWNrKSA6IGluZGV4O1xuICAgICAgICAgICAgaXRlcmF0aW9uRGF0YS5sZWZ0ID0gKGJhc2VEYXRhLnN0ZXAgKiBzdGVwQ291bnQpICsgaXRlcmF0aW9uRGF0YS5iYXNlTGVmdCArIGJhc2VEYXRhLmFkZGl0aW9uYWxQb3NpdGlvbjtcbiAgICAgICAgICAgIGl0ZXJhdGlvbkRhdGEucGx1c1RvcCA9IDA7XG4gICAgICAgICAgICBpdGVyYXRpb25EYXRhLm1pbnVzVG9wID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXJpZXNJdGVtLnZhbHVlID49IDApIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbkRhdGEucGx1c1RvcCAtPSBiYXJIZWlnaHQ7XG4gICAgICAgICAgICBlbmRUb3AgPSBzdGFydFRvcCArIGl0ZXJhdGlvbkRhdGEucGx1c1RvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZFRvcCA9IHN0YXJ0VG9wICsgaXRlcmF0aW9uRGF0YS5taW51c1RvcDtcbiAgICAgICAgICAgIGl0ZXJhdGlvbkRhdGEubWludXNUb3AgKz0gYmFySGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlcmF0aW9uRGF0YS5wcmV2U3RhY2sgPSBzZXJpZXNJdGVtLnN0YWNrO1xuICAgICAgICBib3VuZCA9IHRoaXMuX21ha2VCb3VuZChiYXNlRGF0YS5iYXJTaXplLCBiYXJIZWlnaHQsIGl0ZXJhdGlvbkRhdGEubGVmdCwgc3RhcnRUb3AsIGVuZFRvcCk7XG5cbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kcyBvZiBjb2x1bW4gY2hhcnQuXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLl9nZXRTZXJpZXNEYXRhTW9kZWwoKTtcbiAgICAgICAgdmFyIGlzU3RhY2tUeXBlID0gcHJlZGljYXRlLmlzVmFsaWRTdGFja09wdGlvbih0aGlzLm9wdGlvbnMuc3RhY2tUeXBlKTtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKTtcbiAgICAgICAgdmFyIGJhc2VEYXRhID0gdGhpcy5fbWFrZUJhc2VEYXRhRm9yTWFraW5nQm91bmQoZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzRGF0YU1vZGVsLm1hcChmdW5jdGlvbihzZXJpZXNHcm91cCwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIGJhc2VMZWZ0ID0gKGdyb3VwSW5kZXggKiBiYXNlRGF0YS5ncm91cFNpemUpICsgYmFzZURhdGEuZmlyc3RBZGRpdGlvbmFsUG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICAgICAgaXRlcmF0aW9uRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZUxlZnQ6IGJhc2VMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBiYXNlTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgcGx1c1RvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgbWludXNUb3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIHByZXZTdGFjazogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXRlcmF0ZWUgPSB0dWkudXRpbC5iaW5kKHNlbGYuX21ha2VDb2x1bW5DaGFydEJvdW5kLCBzZWxmLCBiYXNlRGF0YSwgaXRlcmF0aW9uRGF0YSwgaXNTdGFja1R5cGUpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAubWFwKGl0ZXJhdGVlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBsZWZ0IHBvc2l0aW9uIG9mIHN1bSBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYm91bmQgYm91bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkU3VtIGZvcm1hdHRlZCBzdW0uXG4gICAgICogQHJldHVybnMge251bWJlcn0gbGVmdCBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZUxlZnRQb3NpdGlvbk9mU3VtTGFiZWw6IGZ1bmN0aW9uKGJvdW5kLCBmb3JtYXR0ZWRTdW0pIHtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChmb3JtYXR0ZWRTdW0sIHRoaXMudGhlbWUubGFiZWwpO1xuXG4gICAgICAgIHJldHVybiBib3VuZC5sZWZ0ICsgKChib3VuZC53aWR0aCAtIGxhYmVsV2lkdGggKyBjaGFydENvbnN0LlRFWFRfUEFERElORykgLyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwbHVzIHN1bSBsYWJlbCBodG1sLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlcyB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYm91bmQgYm91bmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGx1cyBzdW0gbGFiZWwgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQbHVzU3VtTGFiZWxIdG1sOiBmdW5jdGlvbih2YWx1ZXMsIGJvdW5kLCBsYWJlbEhlaWdodCkge1xuICAgICAgICB2YXIgaHRtbCA9ICcnO1xuICAgICAgICB2YXIgc3VtLCBmb3JtYXRGdW5jdGlvbnMsIGZvcm1hdHRlZFN1bTtcblxuICAgICAgICBpZiAoYm91bmQpIHtcbiAgICAgICAgICAgIHN1bSA9IGNhbGN1bGF0b3Iuc3VtUGx1c1ZhbHVlcyh2YWx1ZXMpO1xuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpO1xuICAgICAgICAgICAgZm9ybWF0dGVkU3VtID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZShzdW0sIGZvcm1hdEZ1bmN0aW9ucywgdGhpcy5jaGFydFR5cGUsICdzZXJpZXMnKTtcbiAgICAgICAgICAgIGh0bWwgPSB0aGlzLl9tYWtlU2VyaWVzTGFiZWxIdG1sKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLl9jYWxjdWxhdGVMZWZ0UG9zaXRpb25PZlN1bUxhYmVsKGJvdW5kLCBmb3JtYXR0ZWRTdW0pLFxuICAgICAgICAgICAgICAgIHRvcDogYm91bmQudG9wIC0gbGFiZWxIZWlnaHQgLSBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HXG4gICAgICAgICAgICB9LCBmb3JtYXR0ZWRTdW0sIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG1pbnVzIHN1bSBsYWJlbCBodG1sLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlcyB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYm91bmQgYm91bmRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwbHVzIG1pbnVzIGxhYmVsIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTWludXNTdW1MYWJlbEh0bWw6IGZ1bmN0aW9uKHZhbHVlcywgYm91bmQpIHtcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcbiAgICAgICAgdmFyIHN1bSwgZm9ybWF0RnVuY3Rpb25zLCBmb3JtYXR0ZWRTdW07XG5cbiAgICAgICAgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgICBzdW0gPSBjYWxjdWxhdG9yLnN1bU1pbnVzVmFsdWVzKHZhbHVlcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gTWF0aC5hYnMoc3VtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpO1xuICAgICAgICAgICAgZm9ybWF0dGVkU3VtID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZShzdW0sIGZvcm1hdEZ1bmN0aW9ucywgdGhpcy5jaGFydFR5cGUsICdzZXJpZXMnKTtcbiAgICAgICAgICAgIGh0bWwgPSB0aGlzLl9tYWtlU2VyaWVzTGFiZWxIdG1sKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLl9jYWxjdWxhdGVMZWZ0UG9zaXRpb25PZlN1bUxhYmVsKGJvdW5kLCBmb3JtYXR0ZWRTdW0pLFxuICAgICAgICAgICAgICAgIHRvcDogYm91bmQudG9wICsgYm91bmQuaGVpZ2h0ICsgY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElOR1xuICAgICAgICAgICAgfSwgZm9ybWF0dGVkU3VtLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG59KTtcblxuQmFyVHlwZVNlcmllc0Jhc2UubWl4aW4oQ29sdW1uQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbkNoYXJ0U2VyaWVzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvb3JkaW5hdGVUeXBlU2VyaWVzQmFzZSBpcyBiYXNlIGNsYXNzIGZvciBjb29yZGluYXRlIHR5cGUgc2VyaWVzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcblxudmFyIENvb3JkaW5hdGVUeXBlU2VyaWVzQmFzZSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgQ29vcmRpbmF0ZVR5cGVTZXJpZXNCYXNlLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgZ3JvdXBCb3VuZHM6IEFycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHJhZGl1czogbnVtYmVyfT4+LFxuICAgICAqICAgICAgc2VyaWVzRGF0YU1vZGVsOiBTZXJpZXNEYXRhTW9kZWxcbiAgICAgKiB9fSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX21ha2VCb3VuZHMoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JvdXBCb3VuZHM6IGJvdW5kcyxcbiAgICAgICAgICAgIHNlcmllc0RhdGFNb2RlbDogdGhpcy5fZ2V0U2VyaWVzRGF0YU1vZGVsKClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2hvd1Rvb2x0aXAgaXMgbW91c2VvdmVyIGV2ZW50IGNhbGxiYWNrIG9uIHNlcmllcyBncmFwaC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmFsbG93TmVnYXRpdmVUb29sdGlwIHdoZXRoZXIgYWxsb3cgbmVnYXRpdmUgdG9vbHRpcCBvciBub3RcbiAgICAgKiBAcGFyYW0ge3t0b3A6bnVtYmVyLCBsZWZ0OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgZ3JhcGggYm91bmQgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJbmRleCBncm91cCBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBtb3VzZVBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKHBhcmFtcywgYm91bmQsIGdyb3VwSW5kZXgsIGluZGV4LCBtb3VzZVBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd1Rvb2x0aXAnLCB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2VQb3NpdGlvbjogbW91c2VQb3NpdGlvblxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGlkZVRvb2x0aXAgaXMgbW91c2VvdXQgZXZlbnQgY2FsbGJhY2sgb24gc2VyaWVzIGdyYXBoLlxuICAgICAqL1xuICAgIGhpZGVUb29sdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgcmFwaGFlbCBncmFwaC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3JlbmRlckdyYXBoOiBmdW5jdGlvbihkaW1lbnNpb24sIHNlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIHNob3dUb29sdGlwID0gdHVpLnV0aWwuYmluZCh0aGlzLnNob3dUb29sdGlwLCB0aGlzLCB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgc2hvd1Rvb2x0aXA6IHNob3dUb29sdGlwLFxuICAgICAgICAgICAgaGlkZVRvb2x0aXA6IHR1aS51dGlsLmJpbmQodGhpcy5oaWRlVG9vbHRpcCwgdGhpcylcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuX21ha2VQYXJhbXNGb3JHcmFwaFJlbmRlcmluZyhkaW1lbnNpb24sIHNlcmllc0RhdGEpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5yZW5kZXIodGhpcy5zZXJpZXNDb250YWluZXIsIHBhcmFtcywgY2FsbGJhY2tzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBodG1sIGZvciBsYWJlbCBvZiBzZXJpZXMgYXJlYS5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYmFzZVBvc2l0aW9uIC0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgLSBsYWJlbCBvZiBTZXJpZXNJdGVtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNMYWJlbHNIdG1sOiBmdW5jdGlvbihiYXNlUG9zaXRpb24sIGxhYmVsLCBpbmRleCkge1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQobGFiZWwsIHRoaXMudGhlbWUubGFiZWwpO1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGVmdDogYmFzZVBvc2l0aW9uLmxlZnQgLSAobGFiZWxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgdG9wOiBiYXNlUG9zaXRpb24udG9wIC0gKGxhYmVsSGVpZ2h0IC8gMilcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFrZVNlcmllc0xhYmVsSHRtbChwb3NpdGlvbiwgbGFiZWwsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBsYWJlbENvbnRhaW5lciAtIGNvbnRhaW5lciBmb3IgbGFiZWwgYXJlYVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0xhYmVsOiBmdW5jdGlvbihsYWJlbENvbnRhaW5lcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLl9nZXRTZXJpZXNEYXRhTW9kZWwoKTtcbiAgICAgICAgdmFyIGh0bWwgPSBzZXJpZXNEYXRhTW9kZWwubWFwKGZ1bmN0aW9uKHNlcmllc0dyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAubWFwKGZ1bmN0aW9uKHNlcmllc0l0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kID0gc2VsZi5zZXJpZXNEYXRhLmdyb3VwQm91bmRzW2dyb3VwSW5kZXhdW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpZXNJdGVtID8gc2VsZi5fbWFrZVNlcmllc0xhYmVsc0h0bWwoYm91bmQsIHNlcmllc0l0ZW0ubGFiZWwsIGluZGV4KSA6ICcnO1xuICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuXG4gICAgICAgIGxhYmVsQ29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGNsaWNrIHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKi9cbiAgICBvbkNsaWNrU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93U2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9leGVjdXRlR3JhcGhSZW5kZXJlcihwb3NpdGlvbiwgJ2NsaWNrU2VyaWVzJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW92ZSBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICovXG4gICAgb25Nb3ZlU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9leGVjdXRlR3JhcGhSZW5kZXJlcihwb3NpdGlvbiwgJ21vdmVNb3VzZU9uU2VyaWVzJyk7XG4gICAgfVxufSk7XG5cbkNvb3JkaW5hdGVUeXBlU2VyaWVzQmFzZS5taXhpbiA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB0dWkudXRpbC5leHRlbmQoZnVuYy5wcm90b3R5cGUsIENvb3JkaW5hdGVUeXBlU2VyaWVzQmFzZS5wcm90b3R5cGUpO1xufTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKENvb3JkaW5hdGVUeXBlU2VyaWVzQmFzZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29vcmRpbmF0ZVR5cGVTZXJpZXNCYXNlO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlcmllcyBjb21wb25lbnQgZm9yIHJlbmRlcmluZyBncmFwaCBvZiBoZWF0bWFwIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuL3NlcmllcycpO1xudmFyIGxhYmVsSGVscGVyID0gcmVxdWlyZSgnLi9yZW5kZXJpbmdMYWJlbEhlbHBlcicpO1xudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgSGVhdG1hcENoYXJ0U2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoU2VyaWVzLCAvKiogQGxlbmRzIEhlYXRtYXBDaGFydFNlcmllcy5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFNlcmllcyBjb21wb25lbnQgZm9yIHJlbmRlcmluZyBncmFwaCBvZiBoZWF0bWFwIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIEhlYXRtYXBDaGFydFNlcmllc1xuICAgICAqIEBleHRlbmRzIFNlcmllc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBTZXJpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgZ3JvdXBCb3VuZHM6IEFycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHJhZGl1czogbnVtYmVyfT4+LFxuICAgICAqICAgICAgc2VyaWVzRGF0YU1vZGVsOiBTZXJpZXNEYXRhTW9kZWxcbiAgICAgKiB9fSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJvdW5kc1NldCA9IHRoaXMuX21ha2VCb3VuZHMoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sb3JTcGVjdHJ1bTogdGhpcy5kYXRhLmNvbG9yU3BlY3RydW0sXG4gICAgICAgICAgICBncm91cEJvdW5kczogYm91bmRzU2V0LFxuICAgICAgICAgICAgc2VyaWVzRGF0YU1vZGVsOiB0aGlzLl9nZXRTZXJpZXNEYXRhTW9kZWwoKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kIGZvciBncmFwaCByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrV2lkdGggLSBibG9jayB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja0hlaWdodCAtIGJsb2NrIGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geCBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0geSBpbmRleFxuICAgICAqIEByZXR1cm5zIHt7ZW5kOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQm91bmQ6IGZ1bmN0aW9uKGJsb2NrV2lkdGgsIGJsb2NrSGVpZ2h0LCB4LCB5KSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJykuaGVpZ2h0O1xuICAgICAgICB2YXIgbGVmdCA9IChibG9ja1dpZHRoICogeCkgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRTtcbiAgICAgICAgdmFyIHRvcCA9IGhlaWdodCAtIChibG9ja0hlaWdodCAqICh5ICsgMSkpICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkU7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGJsb2NrV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBibG9ja0hlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kcyBmb3IgZ3JhcGggcmVuZGVyaW5nLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByYWRpdXM6IG51bWJlcn0+Pn0gcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlcmllc0RhdGFNb2RlbCA9IHRoaXMuX2dldFNlcmllc0RhdGFNb2RlbCgpO1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuICAgICAgICB2YXIgYmxvY2tXaWR0aCA9IGRpbWVuc2lvbi53aWR0aCAvIHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRDYXRlZ29yeUNvdW50KGZhbHNlKTtcbiAgICAgICAgdmFyIGJsb2NrSGVpZ2h0ID0gZGltZW5zaW9uLmhlaWdodCAvIHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRDYXRlZ29yeUNvdW50KHRydWUpO1xuXG4gICAgICAgIHJldHVybiBzZXJpZXNEYXRhTW9kZWwubWFwKGZ1bmN0aW9uKHNlcmllc0dyb3VwLCB4KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAubWFwKGZ1bmN0aW9uKHNlcmllc0l0ZW0sIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbWFrZUJvdW5kKGJsb2NrV2lkdGgsIGJsb2NrSGVpZ2h0LCB4LCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gc2hvdyB0b29sdGlwIGZvciBjYWxsaW5nIHNob3dXZWRnZS5cbiAgICAgKiBAcGFyYW0ge3tpbmRleGVzOiB7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX19IHBhcmFtcyAtIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBvblNob3dUb29sdGlwOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNlcmllc0RhdGFNb2RlbCA9IHRoaXMuX2dldFNlcmllc0RhdGFNb2RlbCgpO1xuICAgICAgICB2YXIgaW5kZXhlcyA9IHBhcmFtcy5pbmRleGVzO1xuICAgICAgICB2YXIgcmF0aW8gPSBzZXJpZXNEYXRhTW9kZWwuZ2V0U2VyaWVzSXRlbShpbmRleGVzLmdyb3VwSW5kZXgsIGluZGV4ZXMuaW5kZXgpLnJhdGlvO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd1dlZGdlJywgcmF0aW8pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxhYmVsQ29udGFpbmVyIC0gc2VyaWVzIGxhYmVsIGNvbnRhaW5lclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0xhYmVsOiBmdW5jdGlvbihsYWJlbENvbnRhaW5lcikge1xuICAgICAgICB2YXIgc2RtID0gdGhpcy5fZ2V0U2VyaWVzRGF0YU1vZGVsKCk7XG4gICAgICAgIHZhciBib3VuZHNTZXQgPSB0aGlzLnNlcmllc0RhdGEuZ3JvdXBCb3VuZHM7XG4gICAgICAgIHZhciBsYWJlbFRoZW1lID0gdGhpcy50aGVtZS5sYWJlbDtcbiAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSB0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXg7XG4gICAgICAgIHZhciBwb3NpdGlvbnNTZXQgPSBsYWJlbEhlbHBlci5ib3VuZHNUb0xhYmVsUG9zaXRpb25zKHNkbSwgYm91bmRzU2V0LCBsYWJlbFRoZW1lKTtcbiAgICAgICAgdmFyIGh0bWwgPSBsYWJlbEhlbHBlci5tYWtlTGFiZWxzSHRtbEZvckJvdW5kVHlwZShzZG0sIHBvc2l0aW9uc1NldCwgbGFiZWxUaGVtZSwgc2VsZWN0ZWRJbmRleCk7XG5cbiAgICAgICAgbGFiZWxDb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBleHBvcnRhdGlvbiBkYXRhIGZvciBzZXJpZXMgdHlwZSB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc0RhdGEgLSBzZXJpZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VFeHBvcnRhdGlvblNlcmllc0RhdGE6IGZ1bmN0aW9uKHNlcmllc0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHNlcmllc0RhdGEuaW5kZXhlcy5ncm91cEluZGV4LFxuICAgICAgICAgICAgeTogc2VyaWVzRGF0YS5pbmRleGVzLmluZGV4XG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihIZWF0bWFwQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYXRtYXBDaGFydFNlcmllcztcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBMaW5lIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyksXG4gICAgTGluZVR5cGVTZXJpZXNCYXNlID0gcmVxdWlyZSgnLi9saW5lVHlwZVNlcmllc0Jhc2UnKTtcblxudmFyIExpbmVDaGFydFNlcmllcyA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFNlcmllcywgLyoqIEBsZW5kcyBMaW5lQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBMaW5lIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgTGluZUNoYXJ0U2VyaWVzXG4gICAgICogQGV4dGVuZHMgU2VyaWVzXG4gICAgICogQG1peGVzIExpbmVUeXBlU2VyaWVzQmFzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5tb2RlbCBzZXJpZXMgbW9kZWxcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBzZXJpZXMgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBzZXJpZXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgU2VyaWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9iamVjdCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwge2lkOiBudW1iZXJ9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3ZpbmdBbmltYXRpb24gPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBvc2l0aW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Nlcmllc1dpZHRoXSAtIHNlcmllcyB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfT4+fSBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUG9zaXRpb25zOiBmdW5jdGlvbihzZXJpZXNXaWR0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFrZUJhc2ljUG9zaXRpb25zKHNlcmllc1dpZHRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYXJ0QmFja2dyb3VuZDogdGhpcy5jaGFydEJhY2tncm91bmQsXG4gICAgICAgICAgICBncm91cFBvc2l0aW9uczogdGhpcy5fbWFrZVBvc2l0aW9ucygpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcmVuZGVyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBmb3IgcmVyZW5kZXJpbmdcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZXJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgcGFwZXI7XG5cbiAgICAgICAgdGhpcy5fY2FuY2VsTW92aW5nQW5pbWF0aW9uKCk7XG5cbiAgICAgICAgcGFwZXIgPSBTZXJpZXMucHJvdG90eXBlLnJlcmVuZGVyLmNhbGwodGhpcywgZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcGVyO1xuICAgIH1cbn0pO1xuXG5MaW5lVHlwZVNlcmllc0Jhc2UubWl4aW4oTGluZUNoYXJ0U2VyaWVzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTGluZVR5cGVTZXJpZXNCYXNlIGlzIGJhc2UgY2xhc3MgZm9yIGxpbmUgdHlwZSBzZXJpZXMuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNlcmllc1RlbXBsYXRlID0gcmVxdWlyZSgnLi9zZXJpZXNUZW1wbGF0ZScpO1xudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIExpbmVUeXBlU2VyaWVzQmFzZSBpcyBiYXNlIGNsYXNzIGZvciBsaW5lIHR5cGUgc2VyaWVzLlxuICogQGNsYXNzIExpbmVUeXBlU2VyaWVzQmFzZVxuICogQG1peGluXG4gKi9cbnZhciBMaW5lVHlwZVNlcmllc0Jhc2UgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIExpbmVUeXBlU2VyaWVzQmFzZS5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIE1ha2UgYmFzaWMgcG9zaXRpb25zIGZvciByZW5kZXJpbmcgbGluZSBncmFwaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Nlcmllc1dpZHRoXSAtIHdpZHRoIG9mIHNlcmllcyBhcmVhXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhc2ljUG9zaXRpb25zOiBmdW5jdGlvbihzZXJpZXNXaWR0aCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpLFxuICAgICAgICAgICAgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5fZ2V0U2VyaWVzRGF0YU1vZGVsKCksXG4gICAgICAgICAgICB3aWR0aCA9IHNlcmllc1dpZHRoIHx8IGRpbWVuc2lvbi53aWR0aCB8fCAwLFxuICAgICAgICAgICAgaGVpZ2h0ID0gZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGxlbiA9IHNlcmllc0RhdGFNb2RlbC5nZXRHcm91cENvdW50KCksXG4gICAgICAgICAgICBzdGFydCA9IGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgc3RlcDtcblxuICAgICAgICBpZiAodGhpcy5kYXRhLmFsaWduZWQpIHtcbiAgICAgICAgICAgIHN0ZXAgPSB3aWR0aCAvIChsZW4gLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ZXAgPSB3aWR0aCAvIGxlbjtcbiAgICAgICAgICAgIHN0YXJ0ICs9IChzdGVwIC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzRGF0YU1vZGVsLm1hcChmdW5jdGlvbihzZXJpZXNHcm91cCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLm1hcChmdW5jdGlvbihzZXJpZXNJdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc3RhcnQgKyAoc3RlcCAqIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBoZWlnaHQgLSAoc2VyaWVzSXRlbS5yYXRpbyAqIGhlaWdodCkgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAodHVpLnV0aWwuaXNFeGlzdHkoc2VyaWVzSXRlbS5zdGFydFJhdGlvKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5zdGFydFRvcCA9IGhlaWdodCAtIChzZXJpZXNJdGVtLnN0YXJ0UmF0aW8gKiBoZWlnaHQpICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbGFiZWwgcG9zaXRpb24gdG9wLlxuICAgICAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfX0gYmFzZVBvc2l0aW9uIC0gYmFzZSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlIG9mIHNlcmllc0l0ZW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxIZWlnaHQgLSBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RhcnQgLSB3aGV0aGVyIHN0YXJ0IHZhbHVlIG9mIHNlcmllc0l0ZW0gb3Igbm90XG4gICAgICogQHJldHVybnMge251bWJlcn0gcG9zaXRpb24gdG9wXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlTGFiZWxQb3NpdGlvblRvcDogZnVuY3Rpb24oYmFzZVBvc2l0aW9uLCB2YWx1ZSwgbGFiZWxIZWlnaHQsIGlzU3RhcnQpIHtcbiAgICAgICAgdmFyIGJhc2VUb3AgPSBiYXNlUG9zaXRpb24udG9wLFxuICAgICAgICAgICAgdG9wO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNWYWxpZFN0YWNrT3B0aW9uKHRoaXMub3B0aW9ucy5zdGFja1R5cGUpKSB7XG4gICAgICAgICAgICB0b3AgPSAoYmFzZVBvc2l0aW9uLnN0YXJ0VG9wICsgYmFzZVRvcCAtIGxhYmVsSGVpZ2h0KSAvIDIgKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKCh2YWx1ZSA+PSAwICYmICFpc1N0YXJ0KSB8fCAodmFsdWUgPCAwICYmIGlzU3RhcnQpKSB7XG4gICAgICAgICAgICB0b3AgPSBiYXNlVG9wIC0gbGFiZWxIZWlnaHQgLSBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wID0gYmFzZVRvcCArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxhYmVsIHBvc2l0aW9uIGZvciByZW5kZXJpbmcgbGFiZWwgb2Ygc2VyaWVzIGFyZWEuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6ID9udW1iZXJ9fSBiYXNlUG9zaXRpb24gLSBiYXNlIHBvc2l0aW9uIGZvciBjYWxjdWxhdGluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEhlaWdodCAtIGxhYmVsIGhlaWdodFxuICAgICAqIEBwYXJhbSB7KHN0cmluZyB8IG51bWJlcil9IGxhYmVsIC0gbGFiZWwgb2Ygc2VyaWVzSXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlIG9mIHNlcmllc0l0ZW1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RhcnQgLSB3aGV0aGVyIHN0YXJ0IGxhYmVsIHBvc2l0aW9uIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxhYmVsUG9zaXRpb246IGZ1bmN0aW9uKGJhc2VQb3NpdGlvbiwgbGFiZWxIZWlnaHQsIGxhYmVsLCB2YWx1ZSwgaXNTdGFydCkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKTtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdleHRlbmRlZFNlcmllcycpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAoYmFzZVBvc2l0aW9uLmxlZnQgLSAobGFiZWxXaWR0aCAvIDIpKSAvIGRpbWVuc2lvbi53aWR0aCAqIDEwMCxcbiAgICAgICAgICAgIHRvcDogdGhpcy5fY2FsY3VsYXRlTGFiZWxQb3NpdGlvblRvcChiYXNlUG9zaXRpb24sIHZhbHVlLCBsYWJlbEhlaWdodCwgaXNTdGFydCkgLyBkaW1lbnNpb24uaGVpZ2h0ICogMTAwXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaHRtbCBmb3Igc2VyaWVzIGxhYmVsIGZvciBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggLSBpbmRleCBvZiBzZXJpZXNEYXRhTW9kZWwuZ3JvdXBzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygc2VyaWVzR3JvdXAuaXRlbXNcbiAgICAgKiBAcGFyYW0ge1Nlcmllc0l0ZW19IHNlcmllc0l0ZW0gLSBzZXJpZXMgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEhlaWdodCAtIGxhYmVsIGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdGFydCAtIHdoZXRoZXIgc3RhcnQgbGFiZWwgcG9zaXRpb24gb3Igbm90XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzTGFiZWxIdG1sRm9yTGluZVR5cGU6IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGluZGV4LCBzZXJpZXNJdGVtLCBsYWJlbEhlaWdodCwgaXNTdGFydCkge1xuICAgICAgICB2YXIgYmFzZVBvc2l0aW9uID0gdHVpLnV0aWwuZXh0ZW5kKHt9LCB0aGlzLnNlcmllc0RhdGEuZ3JvdXBQb3NpdGlvbnNbZ3JvdXBJbmRleF1baW5kZXhdKSxcbiAgICAgICAgICAgIGxhYmVsLCBwb3NpdGlvbjtcblxuICAgICAgICBpZiAoaXNTdGFydCkge1xuICAgICAgICAgICAgbGFiZWwgPSBzZXJpZXNJdGVtLnN0YXJ0TGFiZWw7XG4gICAgICAgICAgICBiYXNlUG9zaXRpb24udG9wID0gYmFzZVBvc2l0aW9uLnN0YXJ0VG9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFiZWwgPSBzZXJpZXNJdGVtLmVuZExhYmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9tYWtlTGFiZWxQb3NpdGlvbihiYXNlUG9zaXRpb24sIGxhYmVsSGVpZ2h0LCBsYWJlbCwgc2VyaWVzSXRlbS52YWx1ZSwgaXNTdGFydCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21ha2VTZXJpZXNMYWJlbEh0bWwocG9zaXRpb24sIGxhYmVsLCBncm91cEluZGV4LCBzZXJpZXNUZW1wbGF0ZS50cGxDc3NUZXh0Rm9yTGluZVR5cGUsIGlzU3RhcnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsU2VyaWVzTGFiZWxBcmVhIHNlcmllcyBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZXJpZXNMYWJlbDogZnVuY3Rpb24oZWxTZXJpZXNMYWJlbEFyZWEpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5fZ2V0U2VyaWVzRGF0YU1vZGVsKCksXG4gICAgICAgICAgICBmaXJzdExhYmVsID0gc2VyaWVzRGF0YU1vZGVsLmdldEZpcnN0SXRlbUxhYmVsKCksXG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChmaXJzdExhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSxcbiAgICAgICAgICAgIGh0bWxzO1xuXG4gICAgICAgIGh0bWxzID0gc2VyaWVzRGF0YU1vZGVsLm1hcChmdW5jdGlvbihzZXJpZXNHcm91cCwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLm1hcChmdW5jdGlvbihzZXJpZXNJdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbEh0bWwgPSBzZWxmLl9tYWtlU2VyaWVzTGFiZWxIdG1sRm9yTGluZVR5cGUoZ3JvdXBJbmRleCwgaW5kZXgsIHNlcmllc0l0ZW0sIGxhYmVsSGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNJdGVtLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxIdG1sICs9IHNlbGYuX21ha2VTZXJpZXNMYWJlbEh0bWxGb3JMaW5lVHlwZShncm91cEluZGV4LCBpbmRleCwgc2VyaWVzSXRlbSwgbGFiZWxIZWlnaHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbEh0bWw7XG4gICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgZWxTZXJpZXNMYWJlbEFyZWEuaW5uZXJIVE1MID0gaHRtbHMuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBvciBub3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggZ3JvdXAgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBjaGFuZ2VkIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2hhbmdlZDogZnVuY3Rpb24oZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHByZXZJbmRleGVzID0gdGhpcy5wcmV2SW5kZXhlcztcblxuICAgICAgICB0aGlzLnByZXZJbmRleGVzID0ge1xuICAgICAgICAgICAgZ3JvdXBJbmRleDogZ3JvdXBJbmRleCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAhcHJldkluZGV4ZXMgfHwgKHByZXZJbmRleGVzLmdyb3VwSW5kZXggIT09IGdyb3VwSW5kZXgpIHx8IChwcmV2SW5kZXhlcy5pbmRleCAhPT0gaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIHNob3dHcm91cFRvb2x0aXBMaW5lIGZ1bmN0aW9uIG9mIGdyYXBoUmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYm91bmQgYm91bmRcbiAgICAgKi9cbiAgICBvblNob3dHcm91cFRvb2x0aXBMaW5lOiBmdW5jdGlvbihib3VuZCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGhSZW5kZXJlci5zaG93R3JvdXBUb29sdGlwTGluZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zaG93R3JvdXBUb29sdGlwTGluZShib3VuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgaGlkZUdyb3VwVG9vbHRpcExpbmUgZnVuY3Rpb24gb2YgZ3JhcGhSZW5kZXJlci5cbiAgICAgKi9cbiAgICBvbkhpZGVHcm91cFRvb2x0aXBMaW5lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoUmVuZGVyZXIuaGlkZUdyb3VwVG9vbHRpcExpbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuaGlkZUdyb3VwVG9vbHRpcExpbmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSBieSBtb3VzZSBkcmFnLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YVxuICAgICAqIEByZXR1cm5zIHt7Y29udGFpbmVyOiBIVE1MRWxlbWVudCwgcGFwZXI6IG9iamVjdH19XG4gICAgICovXG4gICAgem9vbTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgcGFwZXI7XG5cbiAgICAgICAgdGhpcy5fY2FuY2VsTW92aW5nQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuX2NsZWFyQ29udGFpbmVyKGRhdGEucGFwZXIpO1xuICAgICAgICBwYXBlciA9IHRoaXMuX3JlbmRlclNlcmllc0FyZWEodGhpcy5zZXJpZXNDb250YWluZXIsIGRhdGEsIHR1aS51dGlsLmJpbmQodGhpcy5fcmVuZGVyR3JhcGgsIHRoaXMpKTtcbiAgICAgICAgdGhpcy5fc2hvd0dyYXBoV2l0aG91dEFuaW1hdGlvbigpO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNOdWxsKHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zZWxlY3RMZWdlbmQodGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250YWluZXI6IHRoaXMuc2VyaWVzQ29udGFpbmVyLFxuICAgICAgICAgICAgcGFwZXI6IHBhcGVyXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBsaW1pdChtaW4sIG1heCkgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2hhbmdlZExpbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJlZm9yZUxpbWl0ID0gdGhpcy5kYXRhLmxpbWl0O1xuICAgICAgICB2YXIgYWZ0ZXJMaW1pdCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0QXhlc0RhdGEoKS55QXhpcy5saW1pdDtcblxuICAgICAgICByZXR1cm4gYmVmb3JlTGltaXQubWluICE9PSBhZnRlckxpbWl0Lm1pbiB8fCBiZWZvcmVMaW1pdC5tYXggIT09IGFmdGVyTGltaXQubWF4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGZvciBtb3Rpb24gb2Ygc2VyaWVzIGFyZWEuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNoYW5nZWRMaW1pdCA9IHRoaXMuX2lzQ2hhbmdlZExpbWl0KCk7XG5cbiAgICAgICAgdGhpcy5tb3ZpbmdBbmltYXRpb24gPSByZW5kZXJVdGlsLnN0YXJ0QW5pbWF0aW9uKDMwMCwgZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkTGltaXQgJiYgc2VsZi5zZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VyaWVzTGFiZWxDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhyYXRpbyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5tb3ZpbmdBbmltYXRpb24gPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGljayBmaXJzdCBsYWJlbCBlbGVtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEhUTUxFbGVtZW50Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9waWNrRmlyc3RMYWJlbEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW1Db3VudCA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRDYXRlZ29yeUNvdW50KCkgLSAxO1xuICAgICAgICB2YXIgc2VyaWVzTGFiZWxDb250YWluZXIgPSB0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyO1xuICAgICAgICB2YXIgbGFiZWxFbGVtZW50cyA9IHNlcmllc0xhYmVsQ29udGFpbmVyLmNoaWxkTm9kZXM7XG4gICAgICAgIHZhciBmaWx0ZXJlZEVsZW1lbnRzID0gW107XG4gICAgICAgIHZhciBmaXJzdExhYmVsRWxlbWVudHM7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGxhYmVsRWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmFuZ2UnKSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZpbHRlcmVkRWxlbWVudHMgPSB0dWkudXRpbC5maWx0ZXIoZmlsdGVyZWRFbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAoKHBhcnNlSW50KGluZGV4LCAxMCkgKyAxKSAlIGl0ZW1Db3VudCkgPT09IDE7XG4gICAgICAgIH0pO1xuICAgICAgICBmaXJzdExhYmVsRWxlbWVudHMgPSB0dWkudXRpbC5tYXAoZmlsdGVyZWRFbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG5leHRFbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IFtlbGVtZW50XTtcblxuICAgICAgICAgICAgaWYgKG5leHRFbGVtZW50ICYmIG5leHRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1yYW5nZScpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChuZXh0RWxlbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgZmlyc3RMYWJlbEVsZW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBmaXJzdCBsYWJlbHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlkZUZpcnN0TGFiZWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc0xhYmVsQ29udGFpbmVyID0gdGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lcjtcbiAgICAgICAgdmFyIGZpcnNMYWJlbEVsZW1lbnRzO1xuXG4gICAgICAgIGlmICghc2VyaWVzTGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpcnNMYWJlbEVsZW1lbnRzID0gdGhpcy5fcGlja0ZpcnN0TGFiZWxFbGVtZW50cygpO1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoZmlyc0xhYmVsRWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNlcmllc0xhYmVsQ29udGFpbmVyLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZSBmb3IgbW92aW5nIG9mIGdyYXBoIGNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWwgLSBpbnRlcnZhbCBmb3IgbW92aW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYW5pbWF0ZUZvck1vdmluZzogZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIGdyYXBoUmVuZGVyZXIgPSB0aGlzLmdyYXBoUmVuZGVyZXI7XG4gICAgICAgIHZhciBjaGlsZHJlbkZvck1vdmluZyA9IHRoaXMuc2VyaWVzQ29udGFpbmVyLmNoaWxkTm9kZXM7XG4gICAgICAgIHZhciBhcmVhV2lkdGggPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignZXh0ZW5kZWRTZXJpZXMnKS53aWR0aDtcbiAgICAgICAgdmFyIGJlZm9yZUxlZnQgPSAwO1xuXG4gICAgICAgIHRoaXMuX2hpZGVGaXJzdExhYmVscygpO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbkZvck1vdmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJlZm9yZUxlZnQgPSBwYXJzZUludChjaGlsZHJlbkZvck1vdmluZ1swXS5zdHlsZS5sZWZ0LCAxMCkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FuaW1hdGUoZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gaW50ZXJ2YWwgKiByYXRpbztcblxuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoaWxkcmVuRm9yTW92aW5nLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnN0eWxlLmxlZnQgPSAoYmVmb3JlTGVmdCAtIGxlZnQpICsgJ3B4JztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBncmFwaFJlbmRlcmVyLnNldFNpemUoYXJlYVdpZHRoICsgbGVmdCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGZvciByZXNpemluZyBvZiBsYWJlbCBjb250YWluZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsIC0gaW50ZXJ2YWwgZm9yIHN0YWNraW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYW5pbWF0ZUZvclJlc2l6aW5nOiBmdW5jdGlvbihpbnRlcnZhbCkge1xuICAgICAgICB2YXIgc2VyaWVzTGFiZWxDb250YWluZXIgPSB0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyO1xuICAgICAgICB2YXIgYXJlYVdpZHRoO1xuXG4gICAgICAgIGlmICghc2VyaWVzTGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZWFXaWR0aCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdleHRlbmRlZFNlcmllcycpLndpZHRoO1xuXG4gICAgICAgIHRoaXMuX2FuaW1hdGUoZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gaW50ZXJ2YWwgKiByYXRpbztcblxuICAgICAgICAgICAgc2VyaWVzTGFiZWxDb250YWluZXIuc3R5bGUud2lkdGggPSAoYXJlYVdpZHRoIC0gbGVmdCkgKyAncHgnO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b3Agb2YgemVybyBwb2ludCBmb3IgYWRkaW5nIGRhdGEuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9tYWtlWmVyb1RvcEZvckFkZGluZ0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzSGVpZ2h0ID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpLmhlaWdodDtcbiAgICAgICAgdmFyIGxpbWl0ID0gdGhpcy5ib3VuZHNNYWtlci5nZXRBeGVzRGF0YSgpLnlBeGlzLmxpbWl0O1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRMaW1pdERpc3RhbmNlRnJvbVplcm9Qb2ludChzZXJpZXNIZWlnaHQsIGxpbWl0KS50b01heCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGZvciBhZGRpbmcgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3t0aWNrU2l6ZTogbnVtYmVyfX0gcGFyYW1zIC0gcGFyYW1ldGVycyBmb3IgYWRkaW5nIGRhdGEuXG4gICAgICovXG4gICAgYW5pbWF0ZUZvckFkZGluZ0RhdGE6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgc2VyaWVzRGF0YSA9IHRoaXMuX21ha2VTZXJpZXNEYXRhKCk7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignZXh0ZW5kZWRTZXJpZXMnKTtcbiAgICAgICAgdmFyIHNlcmllc1dpZHRoID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpLndpZHRoO1xuICAgICAgICB2YXIgcGFyYW1zRm9yUmVuZGVyaW5nID0gdGhpcy5fbWFrZVBhcmFtc0ZvckdyYXBoUmVuZGVyaW5nKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSk7XG4gICAgICAgIHZhciB0aWNrU2l6ZSA9IHBhcmFtcy50aWNrU2l6ZTtcbiAgICAgICAgdmFyIHNoaWZ0aW5nT3B0aW9uID0gdGhpcy5vcHRpb25zLnNoaWZ0aW5nO1xuICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvbnMsIHplcm9Ub3A7XG5cbiAgICAgICAgaWYgKHNoaWZ0aW5nT3B0aW9uKSB7XG4gICAgICAgICAgICBzZXJpZXNXaWR0aCArPSB0aWNrU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwUG9zaXRpb25zID0gdGhpcy5fbWFrZVBvc2l0aW9ucyhzZXJpZXNXaWR0aCk7XG4gICAgICAgIHplcm9Ub3AgPSB0aGlzLl9tYWtlWmVyb1RvcEZvckFkZGluZ0RhdGEoKTtcblxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuYW5pbWF0ZUZvckFkZGluZ0RhdGEocGFyYW1zRm9yUmVuZGVyaW5nLCB0aWNrU2l6ZSwgZ3JvdXBQb3NpdGlvbnMsIHNoaWZ0aW5nT3B0aW9uLCB6ZXJvVG9wKTtcblxuICAgICAgICBpZiAoc2hpZnRpbmdPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVGb3JNb3ZpbmcodGlja1NpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUZvclJlc2l6aW5nKHRpY2tTaXplKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgbW92aW5nIGFuaW1hdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYW5jZWxNb3ZpbmdBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5tb3ZpbmdBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubW92aW5nQW5pbWF0aW9uLmlkKTtcbiAgICAgICAgICAgIHRoaXMubW92aW5nQW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5MaW5lVHlwZVNlcmllc0Jhc2UubWl4aW4gPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdHVpLnV0aWwuZXh0ZW5kKGZ1bmMucHJvdG90eXBlLCBMaW5lVHlwZVNlcmllc0Jhc2UucHJvdG90eXBlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZVR5cGVTZXJpZXNCYXNlO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hcCBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuL3NlcmllcycpO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpO1xudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgTWFwQ2hhcnRTZXJpZXMgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhTZXJpZXMsIC8qKiBAbGVuZHMgTWFwQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBNYXAgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBNYXBDaGFydFNlcmllc1xuICAgICAqIEBleHRlbmRzIFNlcmllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIHNlcmllcyBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqICAgICAgQHBhcmFtIHtNYXBDaGFydERhdGFQcm9jZXNzb3J9IHBhcmFtcy5kYXRhUHJvY2Vzc29yIGRhdGEgcHJvY2Vzc29yIGZvciBtYXAgY2hhcnRcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhc2UgcG9zaXRpb24uXG4gICAgICAgICAqIEB0eXBlIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhc2VQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogWm9vbSBtYWduaWZpY2F0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy56b29tTWFnbiA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCByYXRpby5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFwUmF0aW8gPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaCBkaW1lbnNpb24uXG4gICAgICAgICAqIEB0eXBlIHt7fX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JhcGhEaW1lbnNpb24gPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGltaXQgcG9zaXRpb24uXG4gICAgICAgICAqIEB0eXBlIHt7fX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGltaXRQb3NpdGlvbiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgbW9kZWwuXG4gICAgICAgICAqIEB0eXBlIHtNYXBDaGFydE1hcE1vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBNb2RlbCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZXZpb3VzIG1vdXNlIHBvc2l0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7P3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldlBvc2l0aW9uID0gbnVsbDtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmV2aW91cyBtb3ZlZCBpbmRleC5cbiAgICAgICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZNb3ZlZEluZGV4ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBkcmFnIG9yIG5vdC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzRHJhZyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydCBwb3NpdGlvbi5cbiAgICAgICAgICogQHR5cGUgez97bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBudWxsO1xuXG4gICAgICAgIFNlcmllcy5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBtYXAgcmF0aW8uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TWFwUmF0aW86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzRGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpLFxuICAgICAgICAgICAgbWFwRGltZW5zaW9uID0gdGhpcy5tYXBNb2RlbC5nZXRNYXBEaW1lbnNpb24oKSxcbiAgICAgICAgICAgIHdpZHRoUmF0aW8gPSBzZXJpZXNEaW1lbnNpb24ud2lkdGggLyBtYXBEaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRSYXRpbyA9IHNlcmllc0RpbWVuc2lvbi5oZWlnaHQgLyBtYXBEaW1lbnNpb24uaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMubWFwUmF0aW8gPSBNYXRoLm1pbih3aWR0aFJhdGlvLCBoZWlnaHRSYXRpbyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBncmFwaCBkaW1lbnNpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0R3JhcGhEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzRGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhEaW1lbnNpb24gPSB7XG4gICAgICAgICAgICB3aWR0aDogc2VyaWVzRGltZW5zaW9uLndpZHRoICogdGhpcy56b29tTWFnbixcbiAgICAgICAgICAgIGhlaWdodDogc2VyaWVzRGltZW5zaW9uLmhlaWdodCAqIHRoaXMuem9vbU1hZ25cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBzZXJpZXMgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgY29udGFpbmVyO1xuXG4gICAgICAgIHRoaXMubWFwTW9kZWwgPSBkYXRhLm1hcE1vZGVsO1xuICAgICAgICB0aGlzLl9zZXRNYXBSYXRpbygpO1xuXG4gICAgICAgIGNvbnRhaW5lciA9IFNlcmllcy5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGxpbWl0IHBvc2l0aW9uIHRvIG1vdmUgbWFwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExpbWl0UG9zaXRpb25Ub01vdmVNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzRGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpLFxuICAgICAgICAgICAgZ3JhcGhEaW1lbnNpb24gPSB0aGlzLmdyYXBoRGltZW5zaW9uO1xuXG4gICAgICAgIHRoaXMubGltaXRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHNlcmllc0RpbWVuc2lvbi53aWR0aCAtIGdyYXBoRGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgdG9wOiBzZXJpZXNEaW1lbnNpb24uaGVpZ2h0IC0gZ3JhcGhEaW1lbnNpb24uaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciByYXBoYWVsIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3JlbmRlckdyYXBoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoQ29udGFpbmVyID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1zZXJpZXMtZ3JhcGgtYXJlYScpO1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ncmFwaENvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRHcmFwaERpbWVuc2lvbigpO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckRpbWVuc2lvbih0aGlzLmdyYXBoQ29udGFpbmVyLCB0aGlzLmdyYXBoRGltZW5zaW9uKTtcblxuICAgICAgICB0aGlzLl9zZXRMaW1pdFBvc2l0aW9uVG9Nb3ZlTWFwKCk7XG5cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlbmRlcih0aGlzLmdyYXBoQ29udGFpbmVyLCB7XG4gICAgICAgICAgICBjb2xvclNwZWN0cnVtOiB0aGlzLmRhdGEuY29sb3JTcGVjdHJ1bSxcbiAgICAgICAgICAgIG1hcE1vZGVsOiB0aGlzLm1hcE1vZGVsLFxuICAgICAgICAgICAgZGltZW5zaW9uOiB0aGlzLmdyYXBoRGltZW5zaW9uLFxuICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2VyaWVzTGFiZWxDb250YWluZXIgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0xhYmVsOiBmdW5jdGlvbihzZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBodG1scyA9IHR1aS51dGlsLm1hcCh0aGlzLm1hcE1vZGVsLmdldExhYmVsRGF0YSh0aGlzLnpvb21NYWduICogdGhpcy5tYXBSYXRpbyksIGZ1bmN0aW9uKGRhdHVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGRhdHVtLm5hbWUgfHwgZGF0dW0uY29kZSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGRhdHVtLmxhYmVsUG9zaXRpb24ubGVmdCAtIChyZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChsYWJlbCwgc2VsZi50aGVtZS5sYWJlbCkgLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gZGF0dW0ubGFiZWxQb3NpdGlvbi50b3AgLSAocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGxhYmVsLCBzZWxmLnRoZW1lLmxhYmVsKSAvIDIpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX21ha2VTZXJpZXNMYWJlbEh0bWwoe1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICAgICAgICAgIH0sIGRhdHVtLm5hbWUsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBzZXJpZXNMYWJlbENvbnRhaW5lci5pbm5lckhUTUwgPSBodG1scy5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNlcmllcyBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNlcmllc0NvbnRhaW5lciBzZXJpZXMgYXJlYSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1JlbmRlckdyYXBoIGZ1bmN0aW9uIGZvciBncmFwaCByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZXJpZXNBcmVhOiBmdW5jdGlvbihzZXJpZXNDb250YWluZXIsIGRhdGEsIGZ1bmNSZW5kZXJHcmFwaCkge1xuICAgICAgICBTZXJpZXMucHJvdG90eXBlLl9yZW5kZXJTZXJpZXNBcmVhLmNhbGwodGhpcywgc2VyaWVzQ29udGFpbmVyLCBkYXRhLCBmdW5jUmVuZGVyR3JhcGgpO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNTaG93TGFiZWwodGhpcy5vcHRpb25zKSAmJiAhdGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5ncmFwaENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgbWFwIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSB0YXJnZXRQb3NpdGlvbiB0YXJnZXQgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBhZGp1c3RlZCBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkanVzdE1hcFBvc2l0aW9uOiBmdW5jdGlvbih0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0UG9zaXRpb24ubGVmdCwgMCksIHRoaXMubGltaXRQb3NpdGlvbi5sZWZ0KSxcbiAgICAgICAgICAgIHRvcDogTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0UG9zaXRpb24udG9wLCAwKSwgdGhpcy5saW1pdFBvc2l0aW9uLnRvcClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGJhc2UgcG9zaXRpb24gZm9yIHpvb20uXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwcmV2RGltZW5zaW9uIHByZXZpb3VzIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2TGltaXRQb3NpdGlvbiBwcmV2aW91cyBsaW1pdCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFuZ2VkUmF0aW8gY2hhbmdlZCByYXRpb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUJhc2VQb3NpdGlvbkZvclpvb206IGZ1bmN0aW9uKHByZXZEaW1lbnNpb24sIHByZXZMaW1pdFBvc2l0aW9uLCBjaGFuZ2VkUmF0aW8pIHtcbiAgICAgICAgdmFyIHByZXZCYXNlUG9zaXRpb24gPSB0aGlzLmJhc2VQb3NpdGlvbixcbiAgICAgICAgICAgIHByZXZMZWZ0ID0gcHJldkJhc2VQb3NpdGlvbi5sZWZ0IC0gKHByZXZMaW1pdFBvc2l0aW9uLmxlZnQgLyAyKSxcbiAgICAgICAgICAgIHByZXZUb3AgPSBwcmV2QmFzZVBvc2l0aW9uLnRvcCAtIChwcmV2TGltaXRQb3NpdGlvbi50b3AgLyAyKSxcbiAgICAgICAgICAgIG5ld0Jhc2VQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAocHJldkxlZnQgKiBjaGFuZ2VkUmF0aW8pICsgKHRoaXMubGltaXRQb3NpdGlvbi5sZWZ0IC8gMiksXG4gICAgICAgICAgICAgICAgdG9wOiAocHJldlRvcCAqIGNoYW5nZWRSYXRpbykgKyAodGhpcy5saW1pdFBvc2l0aW9uLnRvcCAvIDIpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYmFzZVBvc2l0aW9uID0gdGhpcy5fYWRqdXN0TWFwUG9zaXRpb24obmV3QmFzZVBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbmdlZFJhdGlvIGNoYW5nZWQgcmF0aW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF96b29tOiBmdW5jdGlvbihjaGFuZ2VkUmF0aW8pIHtcbiAgICAgICAgdmFyIHByZXZEaW1lbnNpb24gPSB0aGlzLmdyYXBoRGltZW5zaW9uLFxuICAgICAgICAgICAgcHJldkxpbWl0UG9zaXRpb24gPSB0aGlzLmxpbWl0UG9zaXRpb247XG5cbiAgICAgICAgdGhpcy5fc2V0R3JhcGhEaW1lbnNpb24oKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24odGhpcy5ncmFwaENvbnRhaW5lciwgdGhpcy5ncmFwaERpbWVuc2lvbik7XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zZXRTaXplKHRoaXMuZ3JhcGhEaW1lbnNpb24pO1xuXG4gICAgICAgIHRoaXMuX3NldExpbWl0UG9zaXRpb25Ub01vdmVNYXAoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmFzZVBvc2l0aW9uRm9yWm9vbShwcmV2RGltZW5zaW9uLCBwcmV2TGltaXRQb3NpdGlvbiwgY2hhbmdlZFJhdGlvKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbih0aGlzLmdyYXBoQ29udGFpbmVyLCB0aGlzLmJhc2VQb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0xhYmVsKHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwb3NpdGlvbnMgdG8gcmVzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmV2TWFwUmF0aW8gcHJldmlvdXMgcmF0aW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVQb3NpdGlvbnNUb1Jlc2l6ZTogZnVuY3Rpb24ocHJldk1hcFJhdGlvKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkUmF0aW8gPSB0aGlzLm1hcFJhdGlvIC8gcHJldk1hcFJhdGlvO1xuXG4gICAgICAgIHRoaXMuYmFzZVBvc2l0aW9uLmxlZnQgKj0gY2hhbmdlZFJhdGlvO1xuICAgICAgICB0aGlzLmJhc2VQb3NpdGlvbi50b3AgKj0gY2hhbmdlZFJhdGlvO1xuXG4gICAgICAgIHRoaXMubGltaXRQb3NpdGlvbi5sZWZ0ICo9IGNoYW5nZWRSYXRpbztcbiAgICAgICAgdGhpcy5saW1pdFBvc2l0aW9uLnRvcCAqPSBjaGFuZ2VkUmF0aW87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBncmFwaC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNpemVHcmFwaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcmV2UmF0aW8gPSB0aGlzLm1hcFJhdGlvO1xuXG4gICAgICAgIHRoaXMuX3NldE1hcFJhdGlvKCk7XG5cbiAgICAgICAgdGhpcy5fc2V0R3JhcGhEaW1lbnNpb24oKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24odGhpcy5ncmFwaENvbnRhaW5lciwgdGhpcy5ncmFwaERpbWVuc2lvbik7XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zZXRTaXplKHRoaXMuZ3JhcGhEaW1lbnNpb24pO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uc0ZvclJlc2l6aW5nKHByZXZSYXRpbyk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24odGhpcy5ncmFwaENvbnRhaW5lciwgdGhpcy5iYXNlUG9zaXRpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJTZXJpZXNMYWJlbCh0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGljayBzZXJpZXMuXG4gICAgICovXG4gICAgb25DbGlja1NlcmllczogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBvciBub3QuXG4gICAgICogQHBhcmFtIHs/e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2UG9zaXRpb24gcHJldmlvdXMgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0NoYW5nZWRQb3NpdGlvbjogZnVuY3Rpb24ocHJldlBvc2l0aW9uLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gIXByZXZQb3NpdGlvbiB8fCBwcmV2UG9zaXRpb24ubGVmdCAhPT0gcG9zaXRpb24ubGVmdCB8fCBwcmV2UG9zaXRpb24udG9wICE9PSBwb3NpdGlvbi50b3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgd2VkZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IG1hcCBkYXRhIGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd1dlZGdlOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgZGF0dW0gPSB0aGlzLm1hcE1vZGVsLmdldERhdHVtKGluZGV4KTtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKGRhdHVtLnJhdGlvKSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdzaG93V2VkZ2UnLCBkYXR1bS5yYXRpbyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IG1hcCBkYXRhIGluZGV4XG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IG1vdXNlUG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93VG9vbHRpcDogZnVuY3Rpb24oaW5kZXgsIG1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5maXJlKCdzaG93VG9vbHRpcCcsIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICAgICAgICBpbmRleGVzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2VQb3NpdGlvbjogbW91c2VQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlcmllcyBjb250YWluZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gY29udGFpbmVyIGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q29udGFpbmVyQm91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyQm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyQm91bmQgPSB0aGlzLnNlcmllc0NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckJvdW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3ZlIHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKi9cbiAgICBvbk1vdmVTZXJpZXM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBmb3VuZEluZGV4ID0gdGhpcy5fZXhlY3V0ZUdyYXBoUmVuZGVyZXIocG9zaXRpb24sICdmaW5kU2VjdG9ySW5kZXgnKSxcbiAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNOdWxsKGZvdW5kSW5kZXgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2TW92ZWRJbmRleCAhPT0gZm91bmRJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghdHVpLnV0aWwuaXNOdWxsKHRoaXMucHJldk1vdmVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5yZXN0b3JlQ29sb3IodGhpcy5wcmV2TW92ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVdlZGdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVRvb2x0aXAnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuY2hhbmdlQ29sb3IoZm91bmRJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NoYW5nZWRQb3NpdGlvbih0aGlzLnByZXZQb3NpdGlvbiwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyQm91bmQgPSB0aGlzLl9nZXRDb250YWluZXJCb3VuZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dUb29sdGlwKGZvdW5kSW5kZXgsIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGNvbnRhaW5lckJvdW5kLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wIC0gY29udGFpbmVyQm91bmQudG9wXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2TW92ZWRJbmRleCA9IGZvdW5kSW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3Nob3dXZWRnZShmb3VuZEluZGV4KTtcbiAgICAgICAgfSBlbHNlIGlmICghdHVpLnV0aWwuaXNOdWxsKHRoaXMucHJldk1vdmVkSW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIucmVzdG9yZUNvbG9yKHRoaXMucHJldk1vdmVkSW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlV2VkZ2UnKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVRvb2x0aXAnKTtcbiAgICAgICAgICAgIHRoaXMucHJldk1vdmVkSW5kZXggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGRyYWcgc3RhcnQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqL1xuICAgIG9uRHJhZ1N0YXJ0U2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3BcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gc3RhcnRQb3NpdGlvbiBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBlbmRQb3NpdGlvbiBlbmQgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3ZlUG9zaXRpb246IGZ1bmN0aW9uKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBtb3ZlbWVudFBvc2l0aW9uID0gdGhpcy5fYWRqdXN0TWFwUG9zaXRpb24oe1xuICAgICAgICAgICAgbGVmdDogdGhpcy5iYXNlUG9zaXRpb24ubGVmdCArIChlbmRQb3NpdGlvbi5sZWZ0IC0gc3RhcnRQb3NpdGlvbi5sZWZ0KSxcbiAgICAgICAgICAgIHRvcDogdGhpcy5iYXNlUG9zaXRpb24udG9wICsgKGVuZFBvc2l0aW9uLnRvcCAtIHN0YXJ0UG9zaXRpb24udG9wKVxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKHRoaXMuZ3JhcGhDb250YWluZXIsIG1vdmVtZW50UG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuYmFzZVBvc2l0aW9uID0gbW92ZW1lbnRQb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gZHJhZyBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICovXG4gICAgb25EcmFnU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9tb3ZlUG9zaXRpb24odGhpcy5zdGFydFBvc2l0aW9uLCBwb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gcG9zaXRpb247XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZykge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGRyYWcgZW5kIHNlcmllcy5cbiAgICAgKi9cbiAgICBvbkRyYWdFbmRTZXJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlzRHJhZyA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHBvc2l0aW9uIGZvciB6b29tLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFuZ2VkUmF0aW8gY2hhbmdlZCByYXRpb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdmVQb3NpdGlvbkZvclpvb206IGZ1bmN0aW9uKHBvc2l0aW9uLCBjaGFuZ2VkUmF0aW8pIHtcbiAgICAgICAgdmFyIHNlcmllc0RpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKSxcbiAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kID0gdGhpcy5fZ2V0Q29udGFpbmVyQm91bmQoKSxcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogKHNlcmllc0RpbWVuc2lvbi53aWR0aCAvIDIpICsgY29udGFpbmVyQm91bmQubGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IChzZXJpZXNEaW1lbnNpb24uaGVpZ2h0IC8gMikgKyBjb250YWluZXJCb3VuZC50b3BcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3ZlbWVudFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgLSBzdGFydFBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgLSBzdGFydFBvc2l0aW9uLnRvcFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZFBvc2l0aW9uO1xuXG4gICAgICAgIGNoYW5nZWRSYXRpbyA9IGNoYW5nZWRSYXRpbyA+IDEgPyAtKGNoYW5nZWRSYXRpbyAvIDIpIDogY2hhbmdlZFJhdGlvO1xuXG4gICAgICAgIGVuZFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGVmdDogc3RhcnRQb3NpdGlvbi5sZWZ0ICsgKG1vdmVtZW50UG9zaXRpb24ubGVmdCAqIGNoYW5nZWRSYXRpbyksXG4gICAgICAgICAgICB0b3A6IHN0YXJ0UG9zaXRpb24udG9wICsgKG1vdmVtZW50UG9zaXRpb24udG9wICogY2hhbmdlZFJhdGlvKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX21vdmVQb3NpdGlvbihzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIHpvb20uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld01hZ24gbmV3IHpvb20gbWFnbmlmaWNhdGlvblxuICAgICAqIEBwYXJhbSB7P3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKi9cbiAgICBvblpvb206IGZ1bmN0aW9uKG5ld01hZ24sIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkUmF0aW8gPSBuZXdNYWduIC8gdGhpcy56b29tTWFnbjtcblxuICAgICAgICB0aGlzLnpvb21NYWduID0gbmV3TWFnbjtcblxuICAgICAgICB0aGlzLl96b29tKGNoYW5nZWRSYXRpbyk7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlUG9zaXRpb25Gb3Jab29tKHBvc2l0aW9uLCBjaGFuZ2VkUmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnem9vbScsIG5ld01hZ24pO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oTWFwQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENoYXJ0U2VyaWVzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFBpZSBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuL3NlcmllcycpO1xudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgUGllQ2hhcnRTZXJpZXMgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhTZXJpZXMsIC8qKiBAbGVuZHMgUGllQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBMaW5lIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgUGllQ2hhcnRTZXJpZXNcbiAgICAgKiBAZXh0ZW5kcyBTZXJpZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubW9kZWwgc2VyaWVzIG1vZGVsXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgc2VyaWVzIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgc2VyaWVzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIFNlcmllcy5jYWxsKHRoaXMsIHBhcmFtcyk7XG5cbiAgICAgICAgdGhpcy5pc0NvbWJvID0gISFwYXJhbXMuaXNDb21ibztcblxuICAgICAgICB0aGlzLmlzU2hvd091dGVyTGFiZWwgPSAhIXBhcmFtcy5pc1Nob3dPdXRlckxhYmVsIHx8IHByZWRpY2F0ZS5pc1Nob3dPdXRlckxhYmVsKHRoaXMub3B0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJhbmdlIGZvciBxdWFkcmFudC5cbiAgICAgICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnF1YWRyYW50UmFuZ2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NldERlZmF1bHRPcHRpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdmFsaWQgYW5nbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIC0gYW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdEFuZ2xlIC0gZGVmYXVsdCBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZhbGlkQW5nbGU6IGZ1bmN0aW9uKGFuZ2xlLCBkZWZhdWx0QW5nbGUpIHtcbiAgICAgICAgaWYgKHR1aS51dGlsLmlzVW5kZWZpbmVkKGFuZ2xlKSkge1xuICAgICAgICAgICAgYW5nbGUgPSBkZWZhdWx0QW5nbGU7XG4gICAgICAgIH0gZWxzZSBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICBhbmdsZSA9IGNoYXJ0Q29uc3QuQU5HTEVfMzYwIC0gKE1hdGguYWJzKGFuZ2xlKSAlIGNoYXJ0Q29uc3QuQU5HTEVfMzYwKTtcbiAgICAgICAgfSBlbHNlIGlmIChhbmdsZSA+IDApIHtcbiAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUgJSBjaGFydENvbnN0LkFOR0xFXzM2MDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbmdsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHJhZGl1cyByYW5nZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByYWRpdXNSYW5nZSAtIHJhZGl1cyByYW5nZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90cmFuc2Zvcm1SYWRpdXNSYW5nZTogZnVuY3Rpb24ocmFkaXVzUmFuZ2UpIHtcbiAgICAgICAgcmFkaXVzUmFuZ2UgPSByYWRpdXNSYW5nZSB8fCBbJzAlJywgJzEwMCUnXTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHJhZGl1c1JhbmdlLCBmdW5jdGlvbihwZXJjZW50KSB7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBwYXJzZUludChwZXJjZW50LCAxMCkgKiAwLjAxO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocmF0aW8sIDEpLCAwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmllcyBvZiBwaWUgdHlwZSBjaGFydC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXREZWZhdWx0T3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIG9wdGlvbnMuc3RhcnRBbmdsZSA9IHRoaXMuX21ha2VWYWxpZEFuZ2xlKG9wdGlvbnMuc3RhcnRBbmdsZSwgMCk7XG4gICAgICAgIG9wdGlvbnMuZW5kQW5nbGUgPSB0aGlzLl9tYWtlVmFsaWRBbmdsZShvcHRpb25zLmVuZEFuZ2xlLCBvcHRpb25zLnN0YXJ0QW5nbGUpO1xuICAgICAgICBvcHRpb25zLnJhZGl1c1JhbmdlID0gdGhpcy5fdHJhbnNmb3JtUmFkaXVzUmFuZ2Uob3B0aW9ucy5yYWRpdXNSYW5nZSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmFkaXVzUmFuZ2UubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJhZGl1c1JhbmdlLnVuc2hpZnQoMCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGFuZ2xlIGZvciByZW5kZXJpbmcuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVBbmdsZUZvclJlbmRlcmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBlbmRBbmdsZSA9IHRoaXMub3B0aW9ucy5lbmRBbmdsZTtcbiAgICAgICAgdmFyIHJlbmRlcmluZ0FuZ2xlO1xuXG4gICAgICAgIGlmIChzdGFydEFuZ2xlIDwgZW5kQW5nbGUpIHtcbiAgICAgICAgICAgIHJlbmRlcmluZ0FuZ2xlID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgcmVuZGVyaW5nQW5nbGUgPSBjaGFydENvbnN0LkFOR0xFXzM2MCAtIChzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyaW5nQW5nbGUgPSBjaGFydENvbnN0LkFOR0xFXzM2MDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJpbmdBbmdsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZWN0b3JzIGluZm9ybWF0aW9uLlxuICAgICAqIEBwYXJhbSB7e2N4OiBudW1iZXIsIGN5OiBudW1iZXIsIHI6IG51bWJlcn19IGNpcmNsZUJvdW5kIGNpcmNsZSBib3VuZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gc2VjdG9ycyBpbmZvcm1hdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZWN0b3JEYXRhOiBmdW5jdGlvbihjaXJjbGVCb3VuZCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZXJpZXNHcm91cCA9IHRoaXMuX2dldFNlcmllc0RhdGFNb2RlbCgpLmdldEZpcnN0U2VyaWVzR3JvdXAoKTtcbiAgICAgICAgdmFyIGN4ID0gY2lyY2xlQm91bmQuY3g7XG4gICAgICAgIHZhciBjeSA9IGNpcmNsZUJvdW5kLmN5O1xuICAgICAgICB2YXIgciA9IGNpcmNsZUJvdW5kLnI7XG4gICAgICAgIHZhciBhbmdsZSA9IHRoaXMub3B0aW9ucy5zdGFydEFuZ2xlO1xuICAgICAgICB2YXIgYW5nbGVGb3JSZW5kZXJpbmcgPSB0aGlzLl9jYWxjdWxhdGVBbmdsZUZvclJlbmRlcmluZygpO1xuICAgICAgICB2YXIgZGVsdGEgPSAxMDtcbiAgICAgICAgdmFyIGhvbGVSYXRpbyA9IHRoaXMub3B0aW9ucy5yYWRpdXNSYW5nZVswXTtcbiAgICAgICAgdmFyIGNlbnRlclIgPSByICogMC41O1xuICAgICAgICB2YXIgcGF0aHM7XG5cbiAgICAgICAgaWYgKGhvbGVSYXRpbykge1xuICAgICAgICAgICAgY2VudGVyUiArPSBjZW50ZXJSICogaG9sZVJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aHMgPSBzZXJpZXNHcm91cC5tYXAoZnVuY3Rpb24oc2VyaWVzSXRlbSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRBbmdsZSA9IGFuZ2xlRm9yUmVuZGVyaW5nICogc2VyaWVzSXRlbS5yYXRpbztcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGFuZ2xlICsgY3VycmVudEFuZ2xlO1xuICAgICAgICAgICAgdmFyIHBvcHVwQW5nbGUgPSBhbmdsZSArIChjdXJyZW50QW5nbGUgLyAyKTtcbiAgICAgICAgICAgIHZhciBhbmdsZXMgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogYW5nbGUsXG4gICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBhbmdsZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IGFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBwb3B1cEFuZ2xlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJhdGlvOiBzZXJpZXNJdGVtLnJhdGlvLFxuICAgICAgICAgICAgICAgIGFuZ2xlczogYW5nbGVzLFxuICAgICAgICAgICAgICAgIGNlbnRlclBvc2l0aW9uOiBzZWxmLl9nZXRBcmNQb3NpdGlvbih0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICByOiBjZW50ZXJSXG4gICAgICAgICAgICAgICAgfSwgcG9zaXRpb25EYXRhKSksXG4gICAgICAgICAgICAgICAgb3V0ZXJQb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VsZi5fZ2V0QXJjUG9zaXRpb24odHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6IHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcG9zaXRpb25EYXRhKSksXG4gICAgICAgICAgICAgICAgICAgIG1pZGRsZTogc2VsZi5fZ2V0QXJjUG9zaXRpb24odHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6IHIgKyBkZWx0YVxuICAgICAgICAgICAgICAgICAgICB9LCBwb3NpdGlvbkRhdGEpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwYXRocztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgY2hhcnRCYWNrZ3JvdW5kOiBzdHJpbmcsXG4gICAgICogICAgICBjaXJjbGVCb3VuZDogKHtjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByOiBudW1iZXJ9KSxcbiAgICAgKiAgICAgIHNlY3RvckRhdGE6IEFycmF5LjxvYmplY3Q+XG4gICAgICogfX0gYWRkIGRhdGEgZm9yIGdyYXBoIHJlbmRlcmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNpcmNsZUJvdW5kID0gdGhpcy5fbWFrZUNpcmNsZUJvdW5kKCksXG4gICAgICAgICAgICBzZWN0b3JEYXRhID0gdGhpcy5fbWFrZVNlY3RvckRhdGEoY2lyY2xlQm91bmQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFydEJhY2tncm91bmQ6IHRoaXMuY2hhcnRCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgY2lyY2xlQm91bmQ6IGNpcmNsZUJvdW5kLFxuICAgICAgICAgICAgc2VjdG9yRGF0YTogc2VjdG9yRGF0YVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcXVhZHJhbnQgZnJvbSBhbmdsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBhbmdsZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbmQgd2hldGhlciBlbmQgcXVhZHJhbnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFF1YWRyYW50RnJvbUFuZ2xlOiBmdW5jdGlvbihhbmdsZSwgaXNFbmQpIHtcbiAgICAgICAgdmFyIHF1YWRyYW50ID0gcGFyc2VJbnQoYW5nbGUgLyBjaGFydENvbnN0LkFOR0xFXzkwLCAxMCkgKyAxO1xuXG4gICAgICAgIGlmIChpc0VuZCAmJiAoYW5nbGUgJSBjaGFydENvbnN0LkFOR0xFXzkwID09PSAwKSkge1xuICAgICAgICAgICAgcXVhZHJhbnQgKz0gKHF1YWRyYW50ID09PSAxKSA/IDMgOiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxdWFkcmFudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJhbmdlIGZvciBxdWFkcmFudC5cbiAgICAgKiBAcmV0dXJucyB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRSYW5nZUZvclF1YWRyYW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnF1YWRyYW50UmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucXVhZHJhbnRSYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5fZ2V0UXVhZHJhbnRGcm9tQW5nbGUodGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUpLFxuICAgICAgICAgICAgICAgIGVuZDogdGhpcy5fZ2V0UXVhZHJhbnRGcm9tQW5nbGUodGhpcy5vcHRpb25zLmVuZEFuZ2xlLCB0cnVlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRyYW50UmFuZ2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaW4gcmFuZ2UgZm9yIHF1YWRyYW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IHF1YWRyYW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIGVuZCBxdWFkcmFudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzSW5RdWFkcmFudFJhbmdlOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBxdWFkcmFudFJhbmdlID0gdGhpcy5fZ2V0UmFuZ2VGb3JRdWFkcmFudCgpO1xuXG4gICAgICAgIHJldHVybiBxdWFkcmFudFJhbmdlLnN0YXJ0ID09PSBzdGFydCAmJiBxdWFkcmFudFJhbmdlLmVuZCA9PT0gZW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYmFzZSBzaXplLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQmFzZVNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuICAgICAgICB2YXIgd2lkdGggPSBkaW1lbnNpb24ud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBkaW1lbnNpb24uaGVpZ2h0O1xuICAgICAgICB2YXIgcXVhZHJhbnRSYW5nZTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNDb21ibykge1xuICAgICAgICAgICAgcXVhZHJhbnRSYW5nZSA9IHRoaXMuX2dldFJhbmdlRm9yUXVhZHJhbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luUXVhZHJhbnRSYW5nZSgyLCAzKSB8fCB0aGlzLl9pc0luUXVhZHJhbnRSYW5nZSg0LCAxKSkge1xuICAgICAgICAgICAgICAgIGhlaWdodCAqPSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0luUXVhZHJhbnRSYW5nZSgxLCAyKSB8fCB0aGlzLl9pc0luUXVhZHJhbnRSYW5nZSgzLCA0KSkge1xuICAgICAgICAgICAgICAgIHdpZHRoICo9IDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHF1YWRyYW50UmFuZ2Uuc3RhcnQgPT09IHF1YWRyYW50UmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggKj0gMjtcbiAgICAgICAgICAgICAgICBoZWlnaHQgKj0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHJhZGl1cy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVJhZGl1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByYWRpdXNSYXRpbyA9IHRoaXMuaXNTaG93T3V0ZXJMYWJlbCA/IGNoYXJ0Q29uc3QuUElFX0dSQVBIX1NNQUxMX1JBVElPIDogY2hhcnRDb25zdC5QSUVfR1JBUEhfREVGQVVMVF9SQVRJTztcbiAgICAgICAgdmFyIGJhc2VTaXplID0gdGhpcy5fY2FsY3VsYXRlQmFzZVNpemUoKTtcblxuICAgICAgICByZXR1cm4gYmFzZVNpemUgKiByYWRpdXNSYXRpbyAqIHRoaXMub3B0aW9ucy5yYWRpdXNSYW5nZVsxXSAvIDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBjZW50ZXIgeCwgeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gcmFkaXVzXG4gICAgICogQHJldHVybnMge3tjeDogbnVtYmVyLCBjeTogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVDZW50ZXJYWTogZnVuY3Rpb24ocmFkaXVzKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJyk7XG4gICAgICAgIHZhciBoYWxmUmFkaXVzID0gcmFkaXVzIC8gMjtcbiAgICAgICAgdmFyIGN4ID0gZGltZW5zaW9uLndpZHRoIC8gMjtcbiAgICAgICAgdmFyIGN5ID0gZGltZW5zaW9uLmhlaWdodCAvIDI7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tYm8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luUXVhZHJhbnRSYW5nZSgxLCAxKSkge1xuICAgICAgICAgICAgICAgIGN4IC09IGhhbGZSYWRpdXM7XG4gICAgICAgICAgICAgICAgY3kgKz0gaGFsZlJhZGl1cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNJblF1YWRyYW50UmFuZ2UoMSwgMikpIHtcbiAgICAgICAgICAgICAgICBjeCAtPSBoYWxmUmFkaXVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0luUXVhZHJhbnRSYW5nZSgyLCAyKSkge1xuICAgICAgICAgICAgICAgIGN4IC09IGhhbGZSYWRpdXM7XG4gICAgICAgICAgICAgICAgY3kgLT0gaGFsZlJhZGl1cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNJblF1YWRyYW50UmFuZ2UoMiwgMykpIHtcbiAgICAgICAgICAgICAgICBjeSAtPSBoYWxmUmFkaXVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0luUXVhZHJhbnRSYW5nZSgzLCAzKSkge1xuICAgICAgICAgICAgICAgIGN4ICs9IGhhbGZSYWRpdXM7XG4gICAgICAgICAgICAgICAgY3kgLT0gaGFsZlJhZGl1cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNJblF1YWRyYW50UmFuZ2UoMywgNCkpIHtcbiAgICAgICAgICAgICAgICBjeCArPSBoYWxmUmFkaXVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0luUXVhZHJhbnRSYW5nZSg0LCAxKSkge1xuICAgICAgICAgICAgICAgIGN5ICs9IGhhbGZSYWRpdXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzSW5RdWFkcmFudFJhbmdlKDQsIDQpKSB7XG4gICAgICAgICAgICAgICAgY3ggKz0gaGFsZlJhZGl1cztcbiAgICAgICAgICAgICAgICBjeSArPSBoYWxmUmFkaXVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgIGN5OiBjeVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNpcmNsZSBib3VuZFxuICAgICAqIEByZXR1cm5zIHt7Y3g6IG51bWJlciwgY3k6IG51bWJlciwgcjogbnVtYmVyfX0gY2lyY2xlIGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDaXJjbGVCb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLl9jYWxjdWxhdGVSYWRpdXMoKTtcbiAgICAgICAgdmFyIGNlbnRlclhZID0gdGhpcy5fY2FsY3VsYXRlQ2VudGVyWFkocmFkaXVzKTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIHI6IHJhZGl1c1xuICAgICAgICB9LCBjZW50ZXJYWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhcmMgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmN4IGNlbnRlciB4XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmN5IGNlbnRlciB5XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnIgcmFkaXVzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmFuZ2xlIGFuZ2xlKGRlZ3JlZSlcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBhcmMgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRBcmNQb3NpdGlvbjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBwYXJhbXMuY3ggKyAocGFyYW1zLnIgKiBNYXRoLnNpbihwYXJhbXMuYW5nbGUgKiBjaGFydENvbnN0LlJBRCkpLFxuICAgICAgICAgICAgdG9wOiBwYXJhbXMuY3kgLSAocGFyYW1zLnIgKiBNYXRoLmNvcyhwYXJhbXMuYW5nbGUgKiBjaGFydENvbnN0LlJBRCkpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciByYXBoYWVsIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfcmVuZGVyR3JhcGg6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSwgcGFwZXIpIHtcbiAgICAgICAgdmFyIHNob3dUb290bHRpcCA9IHR1aS51dGlsLmJpbmQodGhpcy5zaG93VG9vbHRpcCwgdGhpcywge1xuICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZVRvb2x0aXA6ICEhdGhpcy5hbGxvd05lZ2F0aXZlVG9vbHRpcCxcbiAgICAgICAgICAgIHNlcmllc05hbWU6IHRoaXMuc2VyaWVzTmFtZSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBzaG93VG9vbHRpcDogc2hvd1Rvb3RsdGlwLFxuICAgICAgICAgICAgaGlkZVRvb2x0aXA6IHR1aS51dGlsLmJpbmQodGhpcy5oaWRlVG9vbHRpcCwgdGhpcylcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuX21ha2VQYXJhbXNGb3JHcmFwaFJlbmRlcmluZyhkaW1lbnNpb24sIHNlcmllc0RhdGEpO1xuXG4gICAgICAgIHBhcmFtcy5wYXBlciA9IHBhcGVyO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdyYXBoUmVuZGVyZXIucmVuZGVyKHRoaXMuc2VyaWVzQ29udGFpbmVyLCBwYXJhbXMsIGNhbGxiYWNrcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZS5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBTZXJpZXMucHJvdG90eXBlLnJlc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9tb3ZlTGVnZW5kTGluZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2hvd1Rvb2x0aXAgaXMgbW91c2VvdmVyIGV2ZW50IGNhbGxiYWNrIG9uIHNlcmllcyBncmFwaC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmFsbG93TmVnYXRpdmVUb29sdGlwIHdoZXRoZXIgYWxsb3cgbmVnYXRpdmUgdG9vbHRpcCBvciBub3RcbiAgICAgKiBAcGFyYW0ge3t0b3A6bnVtYmVyLCBsZWZ0OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgZ3JhcGggYm91bmQgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJbmRleCBncm91cCBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBtb3VzZVBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKHBhcmFtcywgYm91bmQsIGdyb3VwSW5kZXgsIGluZGV4LCBtb3VzZVBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd1Rvb2x0aXAnLCB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2VQb3NpdGlvbjogbW91c2VQb3NpdGlvblxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGlkZVRvb2x0aXAgaXMgbW91c2VvdXQgZXZlbnQgY2FsbGJhY2sgb24gc2VyaWVzIGdyYXBoLlxuICAgICAqL1xuICAgIGhpZGVUb29sdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllcyBkYXRhIGJ5IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e2luZGV4ZXM6IHtpbmRleDogbnVtYmVyLCBncm91cEluZGV4OiBudW1iZXJ9fX0gc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YUJ5U2VsZWN0aW9uOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiBpbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5sZWdlbmQgbGVnZW5kXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmxhYmVsIGxhYmVsXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNlcGFyYXRvciBzZXBhcmF0b3JcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzZXJpZXMgbGFiZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTZXJpZXNMYWJlbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBzZXJpZXNMYWJlbCA9ICcnO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgc2VyaWVzTGFiZWwgPSAnPHNwYW4gY2xhc3M9XCJ0dWktY2hhcnQtc2VyaWVzLWxlZ2VuZFwiPicgKyBwYXJhbXMubGVnZW5kICsgJzwvc3Bhbj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TGFiZWwpIHtcbiAgICAgICAgICAgIHNlcmllc0xhYmVsICs9IChzZXJpZXNMYWJlbCA/IHBhcmFtcy5zZXBhcmF0b3IgOiAnJykgKyBwYXJhbXMubGFiZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzTGFiZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjZW50ZXIgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gcGFyYW1zLnBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2VwYXJhdG9yIHNlcGFyYXRvclxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHBhcmFtcy5mdW5jTW92ZVRvUG9zaXRpb24gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzZXJpZXNMYWJlbENvbnRhaW5lciBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTGVnZW5kTGFiZWw6IGZ1bmN0aW9uKHBhcmFtcywgc2VyaWVzTGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZGF0YVByb2Nlc3NvciA9IHRoaXMuZGF0YVByb2Nlc3NvcjtcbiAgICAgICAgdmFyIHNlcmllc0RhdGFNb2RlbCA9IHRoaXMuX2dldFNlcmllc0RhdGFNb2RlbCgpO1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gcGFyYW1zLnBvc2l0aW9ucztcbiAgICAgICAgdmFyIGh0bWxzID0gdHVpLnV0aWwubWFwKGRhdGFQcm9jZXNzb3IuZ2V0TGVnZW5kTGFiZWxzKHRoaXMuc2VyaWVzTmFtZSksIGZ1bmN0aW9uKGxlZ2VuZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gJycsXG4gICAgICAgICAgICAgICAgbGFiZWwsIHBvc2l0aW9uO1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb25zW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gc2VsZi5fZ2V0U2VyaWVzTGFiZWwoe1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHNlcmllc0RhdGFNb2RlbC5nZXRTZXJpZXNJdGVtKDAsIGluZGV4KS5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yOiBwYXJhbXMuc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwYXJhbXMuZnVuY01vdmVUb1Bvc2l0aW9uKHBvc2l0aW9uc1tpbmRleF0sIGxhYmVsKTtcbiAgICAgICAgICAgICAgICBodG1sID0gc2VsZi5fbWFrZVNlcmllc0xhYmVsSHRtbChwb3NpdGlvbiwgbGFiZWwsIGluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlcmllc0xhYmVsQ29udGFpbmVyLmlubmVySFRNTCA9IGh0bWxzLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIGNlbnRlciBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgbGFiZWxcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBjZW50ZXIgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3ZlVG9DZW50ZXJQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24sIGxhYmVsKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcG9zaXRpb24ubGVmdCAtIChyZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChsYWJlbCwgdGhpcy50aGVtZS5sYWJlbCkgLyAyKSxcbiAgICAgICAgICAgIHRvcCA9IHBvc2l0aW9uLnRvcCAtIChyZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQobGFiZWwsIHRoaXMudGhlbWUubGFiZWwpIC8gMik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIHBvaXN0aW9ucyBmcm9tIHNlY3RvciBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvblR5cGUgcG9zaXRpb24gdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGlja1Bvc2l0aW9uc0Zyb21TZWN0b3JEYXRhOiBmdW5jdGlvbihwb3NpdGlvblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0aGlzLnNlcmllc0RhdGEuc2VjdG9yRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXR1bS5yYXRpbyA/IGRhdHVtW3Bvc2l0aW9uVHlwZV0gOiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGNlbnRlciBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2VyaWVzTGFiZWxDb250YWluZXIgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckNlbnRlckxlZ2VuZDogZnVuY3Rpb24oc2VyaWVzTGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kTGFiZWwoe1xuICAgICAgICAgICAgcG9zaXRpb25zOiB0aGlzLl9waWNrUG9zaXRpb25zRnJvbVNlY3RvckRhdGEoJ2NlbnRlclBvc2l0aW9uJyksXG4gICAgICAgICAgICBmdW5jTW92ZVRvUG9zaXRpb246IHR1aS51dGlsLmJpbmQodGhpcy5fbW92ZVRvQ2VudGVyUG9zaXRpb24sIHRoaXMpLFxuICAgICAgICAgICAgc2VwYXJhdG9yOiAnPGJyPidcbiAgICAgICAgfSwgc2VyaWVzTGFiZWxDb250YWluZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZW5kIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXJMZWZ0IGNlbnRlciBsZWZ0XG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gcG9zaXRpb25zIHBvc2l0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEVuZFBvc2l0aW9uOiBmdW5jdGlvbihjZW50ZXJMZWZ0LCBwb3NpdGlvbnMpIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBlbmQ7XG5cbiAgICAgICAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVuZCA9IHR1aS51dGlsLmV4dGVuZCh7fSwgcG9zaXRpb24ubWlkZGxlKTtcbiAgICAgICAgICAgIGlmIChlbmQubGVmdCA8IGNlbnRlckxlZnQpIHtcbiAgICAgICAgICAgICAgICBlbmQubGVmdCAtPSBjaGFydENvbnN0LlNFUklFU19PVVRFUl9MQUJFTF9QQURESU5HO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQubGVmdCArPSBjaGFydENvbnN0LlNFUklFU19PVVRFUl9MQUJFTF9QQURESU5HO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zaXRpb24uZW5kID0gZW5kO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0byBvdXRlciBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VudGVyTGVmdCBjZW50ZXIgbGVmdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBsYWJlbFxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IG91dGVyIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW92ZVRvT3V0ZXJQb3NpdGlvbjogZnVuY3Rpb24oY2VudGVyTGVmdCwgcG9zaXRpb24sIGxhYmVsKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbkVuZCA9IHBvc2l0aW9uLmVuZCxcbiAgICAgICAgICAgIGxlZnQgPSBwb3NpdGlvbkVuZC5sZWZ0LFxuICAgICAgICAgICAgdG9wID0gcG9zaXRpb25FbmQudG9wIC0gKHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChsYWJlbCwgdGhpcy50aGVtZS5sYWJlbCkgLyAyKTtcblxuICAgICAgICBpZiAobGVmdCA8IGNlbnRlckxlZnQpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGFiZWwsIHRoaXMudGhlbWUubGFiZWwpICsgY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgKz0gY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgdG9wOiB0b3BcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG91dGVyIGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzZXJpZXNMYWJlbENvbnRhaW5lciBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyT3V0ZXJMZWdlbmQ6IGZ1bmN0aW9uKHNlcmllc0xhYmVsQ29udGFpbmVyKSB7XG4gICAgICAgIHZhciBjZW50ZXJMZWZ0ID0gdGhpcy5nZXRTZXJpZXNEYXRhKCkuY2lyY2xlQm91bmQuY3g7XG4gICAgICAgIHZhciBvdXRlclBvc2l0aW9ucyA9IHRoaXMuX3BpY2tQb3NpdGlvbnNGcm9tU2VjdG9yRGF0YSgnb3V0ZXJQb3NpdGlvbicpO1xuICAgICAgICB2YXIgZmlsdGVyZWRQb3NpdGlvbnMgPSB0dWkudXRpbC5maWx0ZXIob3V0ZXJQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZEVuZFBvc2l0aW9uKGNlbnRlckxlZnQsIGZpbHRlcmVkUG9zaXRpb25zKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kTGFiZWwoe1xuICAgICAgICAgICAgcG9zaXRpb25zOiBvdXRlclBvc2l0aW9ucyxcbiAgICAgICAgICAgIGZ1bmNNb3ZlVG9Qb3NpdGlvbjogdHVpLnV0aWwuYmluZCh0aGlzLl9tb3ZlVG9PdXRlclBvc2l0aW9uLCB0aGlzLCBjZW50ZXJMZWZ0KSxcbiAgICAgICAgICAgIHNlcGFyYXRvcjogJzombmJzcDsnXG4gICAgICAgIH0sIHNlcmllc0xhYmVsQ29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIucmVuZGVyTGVnZW5kTGluZXMoZmlsdGVyZWRQb3NpdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNlcmllc0xhYmVsQ29udGFpbmVyIHNlcmllcyBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZXJpZXNMYWJlbDogZnVuY3Rpb24oc2VyaWVzTGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0xhYmVsQWxpZ25PdXRlcih0aGlzLm9wdGlvbnMubGFiZWxBbGlnbikpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlck91dGVyTGVnZW5kKHNlcmllc0xhYmVsQ29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNlbnRlckxlZ2VuZChzZXJpZXNMYWJlbENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZSBzZXJpZXMgbGFiZWwgYXJlYS5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBhbmltYXRlU2VyaWVzTGFiZWxBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLmFuaW1hdGVMZWdlbmRMaW5lcyh0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXgpO1xuICAgICAgICBTZXJpZXMucHJvdG90eXBlLmFuaW1hdGVTZXJpZXNMYWJlbEFyZWEuY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSBsZWdlbmQgbGluZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbW92ZUxlZ2VuZExpbmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNlbnRlckxlZnQgPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignY2hhcnQnKS53aWR0aCAvIDIsXG4gICAgICAgICAgICBvdXRlclBvc2l0aW9ucyA9IHRoaXMuX3BpY2tQb3NpdGlvbnNGcm9tU2VjdG9yRGF0YSgnb3V0ZXJQb3NpdGlvbicpLFxuICAgICAgICAgICAgZmlsdGVyZWRQb3NpdGlvbnMgPSB0dWkudXRpbC5maWx0ZXIob3V0ZXJQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkRW5kUG9zaXRpb24oY2VudGVyTGVmdCwgZmlsdGVyZWRQb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIubW92ZUxlZ2VuZExpbmVzKGZpbHRlcmVkUG9zaXRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2sgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIG9uQ2xpY2tTZXJpZXM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dTZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVHcmFwaFJlbmRlcmVyKHBvc2l0aW9uLCAnY2xpY2tTZXJpZXMnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3ZlIHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKi9cbiAgICBvbk1vdmVTZXJpZXM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuX2V4ZWN1dGVHcmFwaFJlbmRlcmVyKHBvc2l0aW9uLCAnbW92ZU1vdXNlT25TZXJpZXMnKTtcbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFBpZUNoYXJ0U2VyaWVzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaWVDaGFydFNlcmllcztcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgcmVuZGVyaW5nTGFiZWxIZWxwZXIgaXMgaGVscGVyIGZvciByZW5kZXJpbmcgb2Ygc2VyaWVzIGxhYmVsLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG52YXIgc2VyaWVzVGVtcGxhdGUgPSByZXF1aXJlKCcuL3Nlcmllc1RlbXBsYXRlJyk7XG5cbi8qKlxuICogcmVuZGVyaW5nTGFiZWxIZWxwZXIgaXMgaGVscGVyIGZvciByZW5kZXJpbmcgb2Ygc2VyaWVzIGxhYmVsLlxuICovXG52YXIgcmVuZGVyaW5nTGFiZWxIZWxwZXIgPSB7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGxlZnQgcG9zaXRpb24gZm9yIGNlbnRlciBhbGlnbiBvZiBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6bnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIC0gYm91bmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxXaWR0aCAtIGxhYmVsIHdpZHRoXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVMZWZ0UG9zaXRpb25Gb3JDZW50ZXJBbGlnbjogZnVuY3Rpb24oYm91bmQsIGxhYmVsV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kLmxlZnQgKyAoKGJvdW5kLndpZHRoIC0gbGFiZWxXaWR0aCkgLyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRvcCBwb3NpdGlvbiBmb3IgbWlkZGxlIGFsaWduIG9mIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDpudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgLSBib3VuZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEhlaWdodCAtIGxhYmVsIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlVG9wUG9zaXRpb25Gb3JNaWRkbGVBbGlnbjogZnVuY3Rpb24oYm91bmQsIGxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBib3VuZC50b3AgKyAoKGJvdW5kLmhlaWdodCAtIGxhYmVsSGVpZ2h0ICsgY2hhcnRDb25zdC5URVhUX1BBRERJTkcpIC8gMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcG9zaXRpb24gZm9yIHR5cGUgb2YgYm91bmQgZm9yIHJlbmRlcmluZyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDpudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgLSBib3VuZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEhlaWdodCAtIGxhYmVsIGhlaWdodFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCAtIGxhYmVsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIC0gdGhlbWUgZm9yIHNlcmllcyBsYWJlbFxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBvc2l0aW9uRm9yQm91bmRUeXBlOiBmdW5jdGlvbihib3VuZCwgbGFiZWxIZWlnaHQsIGxhYmVsLCB0aGVtZSkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGVtZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMuX2NhbGN1bGF0ZUxlZnRQb3NpdGlvbkZvckNlbnRlckFsaWduKGJvdW5kLCBsYWJlbFdpZHRoKSxcbiAgICAgICAgICAgIHRvcDogdGhpcy5fY2FsY3VsYXRlVG9wUG9zaXRpb25Gb3JNaWRkbGVBbGlnbihib3VuZCwgbGFiZWxIZWlnaHQpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcG9zaXRpb24gbWFwIGZvciByZW5kZXJpbmcgbGFiZWwuXG4gICAgICogQHBhcmFtIHtTZXJpZXNJdGVtfSBzZXJpZXNJdGVtIC0gc2VyaWVzIGl0ZW1cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIC0gYm91bmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxIZWlnaHQgLSBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgLSB0aGVtZSBmb3Igc2VyaWVzIGxhYmVsXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWFrZVBvc2l0aW9uIC0gZnVuY3Rpb24gZm9yIG1ha2luZyBwb3NpdGlvbiBvZiBsYWJlbFxuICAgICAqIEByZXR1cm5zIHt7ZW5kOiAqfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUG9zaXRpb25NYXA6IGZ1bmN0aW9uKHNlcmllc0l0ZW0sIGJvdW5kLCBsYWJlbEhlaWdodCwgdGhlbWUsIG1ha2VQb3NpdGlvbikge1xuICAgICAgICB2YXIgdmFsdWUgPSBzZXJpZXNJdGVtLnZhbHVlO1xuICAgICAgICB2YXIgaXNPcHBvc2l0ZVNpZGUgPSB2YWx1ZSA+PSAwO1xuICAgICAgICB2YXIgcG9zaXRpb25NYXAgPSB7XG4gICAgICAgICAgICBlbmQ6IG1ha2VQb3NpdGlvbihib3VuZCwgbGFiZWxIZWlnaHQsIHNlcmllc0l0ZW0uZW5kTGFiZWwgfHwgc2VyaWVzSXRlbS5sYWJlbCwgdGhlbWUsIGlzT3Bwb3NpdGVTaWRlKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzZXJpZXNJdGVtLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIGlzT3Bwb3NpdGVTaWRlID0gdmFsdWUgPCAwO1xuICAgICAgICAgICAgcG9zaXRpb25NYXAuc3RhcnQgPSBtYWtlUG9zaXRpb24oYm91bmQsIGxhYmVsSGVpZ2h0LCBzZXJpZXNJdGVtLnN0YXJ0TGFiZWwsIHRoZW1lLCBpc09wcG9zaXRlU2lkZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb25NYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJvdW5kcyB0byBsYWJlbCBwb3NpdGlvbnMuXG4gICAgICogQHBhcmFtIHtTZXJpZXNEYXRhTW9kZWx9IHNlcmllc0RhdGFNb2RlbCAtIHNlcmllcyBkYXRhIG1vZGVsXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0+Pn0gYm91bmRzU2V0IC0gYm91bmRzIHNldFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSAtIHRoZW1lIGZvciBzZXJpZXMgbGFiZWxcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbbWFrZVBvc2l0aW9uXSAtIGZ1bmN0aW9uIGZvciBtYWtpbmcgcG9zaXRpb24gb2YgbGFiZWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1Bpdm90XSAtIHdoZXRoZXIgcGl2b3Qgb3Igbm90XG4gICAgICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICAgIGJvdW5kc1RvTGFiZWxQb3NpdGlvbnM6IGZ1bmN0aW9uKHNlcmllc0RhdGFNb2RlbCwgYm91bmRzU2V0LCB0aGVtZSwgbWFrZVBvc2l0aW9uLCBpc1Bpdm90KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGNoYXJ0Q29uc3QuTUFYX0hFSUdIVF9XT1JMRCwgdGhlbWUpO1xuXG4gICAgICAgIG1ha2VQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbiB8fCB0dWkudXRpbC5iaW5kKHRoaXMuX21ha2VQb3NpdGlvbkZvckJvdW5kVHlwZSwgdGhpcyk7XG4gICAgICAgIGlzUGl2b3QgPSAhIWlzUGl2b3Q7XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc0RhdGFNb2RlbC5tYXAoZnVuY3Rpb24oc2VyaWVzR3JvdXAsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBib3VuZHNTZXRbZ3JvdXBJbmRleF07XG5cbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNHcm91cC5tYXAoZnVuY3Rpb24oc2VyaWVzSXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmQgPSBib3VuZHNbaW5kZXhdLmVuZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9tYWtlUG9zaXRpb25NYXAoc2VyaWVzSXRlbSwgYm91bmQsIGxhYmVsSGVpZ2h0LCB0aGVtZSwgbWFrZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBpc1Bpdm90KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsYWJlbCBwb3NpdGlvbiBmb3IgYmFyIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOm51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCAtIGJvdW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IC0gbGFiZWwgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0gbGFiZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgLSB0aGVtZSBmb3Igc2VyaWVzIGxhYmVsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc09wcG9zaXRlU2lkZSAtIHdoZXRoZXIgb3Bvc3NpdGUgc2lkZSBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQb3NpdGlvbkZvckJhckNoYXJ0OiBmdW5jdGlvbihib3VuZCwgbGFiZWxIZWlnaHQsIGxhYmVsLCB0aGVtZSwgaXNPcHBvc2l0ZVNpZGUpIHtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChsYWJlbCwgdGhlbWUpO1xuICAgICAgICB2YXIgbGVmdCA9IGJvdW5kLmxlZnQ7XG5cbiAgICAgICAgaWYgKGlzT3Bwb3NpdGVTaWRlKSB7XG4gICAgICAgICAgICBsZWZ0ICs9IGJvdW5kLndpZHRoICsgY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgLT0gbGFiZWxXaWR0aCArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHRvcDogdGhpcy5fY2FsY3VsYXRlVG9wUG9zaXRpb25Gb3JNaWRkbGVBbGlnbihib3VuZCwgbGFiZWxIZWlnaHQpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJvdW5kcyB0byBsYWJlbCBwb3NpdGlvbnMgZm9yIGJhciBjaGFydC5cbiAgICAgKiBAcGFyYW0ge1Nlcmllc0RhdGFNb2RlbH0gc2VyaWVzRGF0YU1vZGVsIC0gc2VyaWVzIGRhdGEgbW9kZWxcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfT4+fSBib3VuZHNTZXQgLSBib3VuZHMgc2V0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIC0gdGhlbWUgZm9yIHNlcmllcyBsYWJlbFxuICAgICAqIEByZXR1cm5zIHsqfEFycmF5LjxPYmplY3Q+fEFycmF5fVxuICAgICAqL1xuICAgIGJvdW5kc1RvTGFiZWxQb3NpdGlvbnNGb3JCYXJDaGFydDogZnVuY3Rpb24oc2VyaWVzRGF0YU1vZGVsLCBib3VuZHNTZXQsIHRoZW1lKSB7XG4gICAgICAgIHZhciBtYWtlUG9zaXRpb25GdW5jdGlvbiA9IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZVBvc2l0aW9uRm9yQmFyQ2hhcnQsIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kc1RvTGFiZWxQb3NpdGlvbnMoc2VyaWVzRGF0YU1vZGVsLCBib3VuZHNTZXQsIHRoZW1lLCBtYWtlUG9zaXRpb25GdW5jdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGFiZWwgcG9zaXRpb24gZm9yIGNvbHVtbiBjaGFydC5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDpudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgLSBib3VuZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEhlaWdodCAtIGxhYmVsIGhlaWdodFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCAtIGxhYmVsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIC0gdGhlbWUgZm9yIHNlcmllcyBsYWJlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPcHBvc2l0ZVNpZGUgLSB3aGV0aGVyIG9wb3NzaXRlIHNpZGUgb3Igbm90XG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUG9zaXRpb25Gb3JDb2x1bW5DaGFydDogZnVuY3Rpb24oYm91bmQsIGxhYmVsSGVpZ2h0LCBsYWJlbCwgdGhlbWUsIGlzT3Bwb3NpdGVTaWRlKSB7XG4gICAgICAgIHZhciBsYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGFiZWwsIHRoZW1lKTtcbiAgICAgICAgdmFyIHRvcCA9IGJvdW5kLnRvcDtcblxuICAgICAgICBpZiAoaXNPcHBvc2l0ZVNpZGUpIHtcbiAgICAgICAgICAgIHRvcCAtPSBsYWJlbEhlaWdodCArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3AgKz0gYm91bmQuaGVpZ2h0ICsgY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiB0aGlzLl9jYWxjdWxhdGVMZWZ0UG9zaXRpb25Gb3JDZW50ZXJBbGlnbihib3VuZCwgbGFiZWxXaWR0aCksXG4gICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCb3VuZHMgdG8gbGFiZWwgcG9zaXRpb25zIGZvciBjb2x1bW4gY2hhcnQuXG4gICAgICogQHBhcmFtIHtTZXJpZXNEYXRhTW9kZWx9IHNlcmllc0RhdGFNb2RlbCAtIHNlcmllcyBkYXRhIG1vZGVsXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0+Pn0gYm91bmRzU2V0IC0gYm91bmRzIHNldFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSAtIHRoZW1lIGZvciBzZXJpZXMgbGFiZWxcbiAgICAgKiBAcmV0dXJucyB7KnxBcnJheS48T2JqZWN0PnxBcnJheX1cbiAgICAgKi9cbiAgICBib3VuZHNUb0xhYmVsUG9zaXRpb25zRm9yQ29sdW1uQ2hhcnQ6IGZ1bmN0aW9uKHNlcmllc0RhdGFNb2RlbCwgYm91bmRzU2V0LCB0aGVtZSkge1xuICAgICAgICB2YXIgbWFrZVBvc2l0aW9uRnVuY3Rpb24gPSB0dWkudXRpbC5iaW5kKHRoaXMuX21ha2VQb3NpdGlvbkZvckNvbHVtbkNoYXJ0LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHNUb0xhYmVsUG9zaXRpb25zKHNlcmllc0RhdGFNb2RlbCwgYm91bmRzU2V0LCB0aGVtZSwgbWFrZVBvc2l0aW9uRnVuY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNzcyB0ZXh0IGZvciBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIC0gcG9zaXRpb24gZm9yIHJlbmRlcmluZyBsYWJlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSAtIHRoZW1lIGZvciBzZXJpZXMgbGFiZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBsZWdlbmRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlbGVjdGVkSW5kZXggLSBzZWxlY3RlZCBpbmRleCBvZiBsZWdlbmRzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFt0cGxDc3NUZXh0XSAtIGNzc1RleHQgdGVtcGxhdGUgb2JqZWN0XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxhYmVsQ3NzVGV4dDogZnVuY3Rpb24ocG9zaXRpb24sIHRoZW1lLCBpbmRleCwgc2VsZWN0ZWRJbmRleCwgdHBsQ3NzVGV4dCkge1xuICAgICAgICB2YXIgY3NzT2JqID0gdHVpLnV0aWwuZXh0ZW5kKHBvc2l0aW9uLCB0aGVtZSk7XG5cbiAgICAgICAgdHBsQ3NzVGV4dCA9IHRwbENzc1RleHQgfHwgc2VyaWVzVGVtcGxhdGUudHBsQ3NzVGV4dDtcblxuICAgICAgICBpZiAodHVpLnV0aWwuaXNFeGlzdHkoc2VsZWN0ZWRJbmRleCkgJiYgKHNlbGVjdGVkSW5kZXggIT09IGluZGV4KSkge1xuICAgICAgICAgICAgY3NzT2JqLm9wYWNpdHkgPSByZW5kZXJVdGlsLm1ha2VPcGFjaXR5Q3NzVGV4dChjaGFydENvbnN0LlNFUklFU19MQUJFTF9PUEFDSVRZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzc09iai5vcGFjaXR5ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHBsQ3NzVGV4dChjc3NPYmopO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGh0bWwgZm9yIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gLSBwb3NpdGlvbiBmb3IgcmVuZGVyaW5nIGxhYmVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0gbGFiZWwgb2YgU2VyaWVzSXRlbVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSAtIHRoZW1lIGZvciBzZXJpZXMgbGFiZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBsZWdlbmRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlbGVjdGVkSW5kZXggLSBzZWxlY3RlZCBpbmRleCBvZiBsZWdlbmRzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFt0cGxDc3NUZXh0XSAtIGNzc1RleHQgdGVtcGxhdGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdGFydF0gLSB3aGV0aGVyIHN0YXJ0IGxhYmVsIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgbWFrZVNlcmllc0xhYmVsSHRtbDogZnVuY3Rpb24ocG9zaXRpb24sIGxhYmVsLCB0aGVtZSwgaW5kZXgsIHNlbGVjdGVkSW5kZXgsIHRwbENzc1RleHQsIGlzU3RhcnQpIHtcbiAgICAgICAgLyplc2xpbnQgbWF4LXBhcmFtczogWzIsIDddKi9cbiAgICAgICAgdmFyIGNzc1RleHQgPSB0aGlzLl9tYWtlTGFiZWxDc3NUZXh0KHBvc2l0aW9uLCB0aGVtZSwgaW5kZXgsIHNlbGVjdGVkSW5kZXgsIHRwbENzc1RleHQpO1xuICAgICAgICB2YXIgcmFuZ2VMYWJlbEF0dHJpYnV0ZSA9ICcnO1xuXG4gICAgICAgIGlmIChpc1N0YXJ0KSB7XG4gICAgICAgICAgICByYW5nZUxhYmVsQXR0cmlidXRlID0gJyBkYXRhLXJhbmdlPVwidHJ1ZVwiJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXJpZXNUZW1wbGF0ZS50cGxTZXJpZXNMYWJlbCh7XG4gICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICBjc3NUZXh0OiBjc3NUZXh0LFxuICAgICAgICAgICAgcmFuZ2VMYWJlbEF0dHJpYnV0ZTogcmFuZ2VMYWJlbEF0dHJpYnV0ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsYWJlbHMgaHRtbCBmb3IgYm91bmQgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge1Nlcmllc0RhdGFNb2RlbH0gc2VyaWVzRGF0YU1vZGVsIC0gc2VyaWVzIGRhdGEgbW9kZWxcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9Pj59IHBvc2l0aW9uc1NldCAtIHBvc2l0aW9ucyBzZXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgLSB0aGVtZSBmb3Igc2VyaWVzIGxhYmVsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlbGVjdGVkSW5kZXggLSBzZWxlY3RlZCBpbmRleCBvZiBsZWdlbmRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNQaXZvdF0gLSB3aGV0aGVyIHBpdm90IG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIG1ha2VMYWJlbHNIdG1sRm9yQm91bmRUeXBlOiBmdW5jdGlvbihzZXJpZXNEYXRhTW9kZWwsIHBvc2l0aW9uc1NldCwgdGhlbWUsIHNlbGVjdGVkSW5kZXgsIGlzUGl2b3QpIHtcbiAgICAgICAgdmFyIG1ha2VTZXJpZXNMYWJlbEh0bWwgPSB0dWkudXRpbC5iaW5kKHRoaXMubWFrZVNlcmllc0xhYmVsSHRtbCwgdGhpcyk7XG4gICAgICAgIHZhciBsYWJlbHNIdG1sID0gc2VyaWVzRGF0YU1vZGVsLm1hcChmdW5jdGlvbihzZXJpZXNHcm91cCwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLm1hcChmdW5jdGlvbihzZXJpZXNJdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbk1hcCA9IHBvc2l0aW9uc1NldFtncm91cEluZGV4XVtpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBtYWtlU2VyaWVzTGFiZWxIdG1sKHBvc2l0aW9uTWFwLmVuZCwgc2VyaWVzSXRlbS5lbmRMYWJlbCwgdGhlbWUsIGluZGV4LCBzZWxlY3RlZEluZGV4KTtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbk1hcC5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9IG1ha2VTZXJpZXNMYWJlbEh0bWwocG9zaXRpb25NYXAuc3RhcnQsIHNlcmllc0l0ZW0uc3RhcnRMYWJlbCwgdGhlbWUsIGluZGV4LCBzZWxlY3RlZEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICB9LCAhIWlzUGl2b3QpLmpvaW4oJycpO1xuXG4gICAgICAgIHJldHVybiBsYWJlbHNIdG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxhYmVscyBodG1sIGZvciB0cmVlbWFwIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFNlcmllc0l0ZW0+fSBzZXJpZXNJdGVtcyAtIHNlcmllc0l0ZW1zXG4gICAgICogQHBhcmFtIHtvYmplY3QuPHN0cmluZywge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfT59IGJvdW5kTWFwIC0gYm91bmQgbWFwXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIC0gdGhlbWUgZm9yIHNlcmllcyBsYWJlbFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHNob3VsZERpbW1lZCAtIHJldHVybnMgd2hldGhlciBzaG91bGQgZGltbWVkIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgbWFrZUxhYmVsc0h0bWxGb3JUcmVlbWFwOiBmdW5jdGlvbihzZXJpZXNJdGVtcywgYm91bmRNYXAsIHRoZW1lLCBzaG91bGREaW1tZWQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQoY2hhcnRDb25zdC5NQVhfSEVJR0hUX1dPUkxELCB0aGVtZSk7XG4gICAgICAgIHZhciBtYWtlUG9zaXRpb24gPSB0dWkudXRpbC5iaW5kKHRoaXMuX21ha2VQb3NpdGlvbkZvckJvdW5kVHlwZSwgdGhpcyk7XG5cbiAgICAgICAgdmFyIGxhYmVsc0h0bWwgPSB0dWkudXRpbC5tYXAoc2VyaWVzSXRlbXMsIGZ1bmN0aW9uKHNlcmllc0l0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYm91bmQgPSBib3VuZE1hcFtzZXJpZXNJdGVtLmlkXTtcbiAgICAgICAgICAgIHZhciBodG1sID0gJyc7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24sIGNvbXBhcmVJbmRleDtcblxuICAgICAgICAgICAgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBzZWxmLl9tYWtlUG9zaXRpb25NYXAoc2VyaWVzSXRlbSwgYm91bmQsIGxhYmVsSGVpZ2h0LCB0aGVtZSwgbWFrZVBvc2l0aW9uKS5lbmQ7XG4gICAgICAgICAgICAgICAgY29tcGFyZUluZGV4ID0gc2hvdWxkRGltbWVkKHNlcmllc0l0ZW0pID8gLTEgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgaHRtbCA9IHNlbGYubWFrZVNlcmllc0xhYmVsSHRtbChwb3NpdGlvbiwgc2VyaWVzSXRlbS5sYWJlbCwgdGhlbWUsIGluZGV4LCBjb21wYXJlSW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsc0h0bWw7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZW5kZXJpbmdMYWJlbEhlbHBlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBTY2F0dGVyIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyk7XG52YXIgQ29vcmRpbmF0ZVR5cGVTZXJpZXNCYXNlID0gcmVxdWlyZSgnLi9jb29yZGluYXRlVHlwZVNlcmllc0Jhc2UnKTtcbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxudmFyIFNjYXR0ZXJDaGFydFNlcmllcyA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFNlcmllcywgLyoqIEBsZW5kcyBTY2F0dGVyQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBTY2F0dGVyIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgU2NhdHRlckNoYXJ0U2VyaWVzXG4gICAgICogQGV4dGVuZHMgU2VyaWVzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIFNlcmllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kIGZvciBzY2F0dGVyIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyLCByOiBudW1iZXJ9fSByYXRpb01hcCAtIHJhdGlvIG1hcFxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmFpdXM6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJvdW5kOiBmdW5jdGlvbihyYXRpb01hcCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByYXRpb01hcC54ICogZGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgdG9wOiBkaW1lbnNpb24uaGVpZ2h0IC0gKHJhdGlvTWFwLnkgKiBkaW1lbnNpb24uaGVpZ2h0KSxcbiAgICAgICAgICAgIHJhZGl1czogY2hhcnRDb25zdC5TQ0FUVEVSX1JBRElVU1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kcyBmb3Igc2NhdHRlciBjaGFydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmFkaXVzOiBudW1iZXJ9Pj59IHBvc2l0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLl9nZXRTZXJpZXNEYXRhTW9kZWwoKTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzRGF0YU1vZGVsLm1hcChmdW5jdGlvbihzZXJpZXNHcm91cCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLm1hcChmdW5jdGlvbihzZXJpZXNJdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1JhdGlvTWFwID0gKHNlcmllc0l0ZW0gJiYgc2VyaWVzSXRlbS5yYXRpb01hcCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzUmF0aW9NYXAgPyBzZWxmLl9tYWtlQm91bmQoc2VyaWVzSXRlbS5yYXRpb01hcCkgOiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5Db29yZGluYXRlVHlwZVNlcmllc0Jhc2UubWl4aW4oU2NhdHRlckNoYXJ0U2VyaWVzKTtcbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihTY2F0dGVyQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYXR0ZXJDaGFydFNlcmllcztcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBTZXJpZXMgYmFzZSBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxhYmVsSGVscGVyID0gcmVxdWlyZSgnLi9yZW5kZXJpbmdMYWJlbEhlbHBlcicpO1xudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpO1xudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xudmFyIHBsdWdpbkZhY3RvcnkgPSByZXF1aXJlKCcuLi9mYWN0b3JpZXMvcGx1Z2luRmFjdG9yeScpO1xuXG52YXIgU2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBTZXJpZXMgYmFzZSBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgU2VyaWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgc2VyaWVzIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgc2VyaWVzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsaWJUeXBlID0gcGFyYW1zLmxpYlR5cGUgfHwgY2hhcnRDb25zdC5ERUZBVUxUX1BMVUdJTjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhcnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXJpZXMgbmFtZVxuICAgICAgICAgKiBAdHB5ZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJpZXNOYW1lID0gcGFyYW1zLnNlcmllc05hbWUgfHwgcGFyYW1zLmNoYXJ0VHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcG9uZW50VHlwZSA9IHBhcmFtcy5jb21wb25lbnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIHByb2Nlc3NvclxuICAgICAgICAgKiBAdHlwZSB7RGF0YVByb2Nlc3Nvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IHBhcmFtcy5kYXRhUHJvY2Vzc29yO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZHMgbWFrZXJcbiAgICAgICAgICogQHR5cGUge0JvdW5kc01ha2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlciA9IHBhcmFtcy5ib3VuZHNNYWtlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlciBldmVudCBsaXN0ZW5lclxuICAgICAgICAgKiBAdHlwZSB7VXNlckV2ZW50TGlzdGVuZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZXJFdmVudCA9IHBhcmFtcy51c2VyRXZlbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IGJhY2tncm91bmQuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0QmFja2dyb3VuZCA9IHBhcmFtcy5jaGFydEJhY2tncm91bmQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVtZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmdUaGVtZSA9IHRoaXMudGhlbWUgPSBwYXJhbXMudGhlbWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgY2hhcnQgaGFzIGF4ZXMgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNBeGVzID0gISFwYXJhbXMuaGFzQXhlcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGggcmVuZGVyZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlciA9IHBsdWdpbkZhY3RvcnkuZ2V0KGxpYlR5cGUsIHBhcmFtcy5jaGFydFR5cGUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXJpZXMgdmlldyBjbGFzc05hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jaGFydC1zZXJpZXMtYXJlYSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlcmllcyBjb250YWluZXJcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJpZXNDb250YWluZXIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXJpZXMgbGFiZWwgY29udGFpbmVyXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXJpZXMgZGF0YVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcmllc0RhdGEgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0ZWQgbGVnZW5kIGluZGV4XG4gICAgICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZWZmZWN0b3IgZm9yIHNob3cgbGF5ZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFiZWxTaG93RWZmZWN0b3IgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VyaWVzRGF0YU1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtTZXJpZXNEYXRhTW9kZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U2VyaWVzRGF0YU1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRTZXJpZXNEYXRhTW9kZWwodGhpcy5zZXJpZXNOYW1lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzZXJpZXNEYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VyaWVzIGRhdGFcbiAgICAgKi9cbiAgICBnZXRTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9yZW5kZXJTZXJpZXNMYWJlbDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzZXJpZXMgbGFiZWwgYXJlYVxuICAgICAqIEBwYXJhbSB7P0hUTUxFbGVtZW50fSBzZXJpZXNMYWJlbENvbnRhaW5lciBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU2VyaWVzTGFiZWxBcmVhOiBmdW5jdGlvbihzZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICB2YXIgZXh0ZW5kZWREaW1lbnNpb247XG5cbiAgICAgICAgaWYgKCFzZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICAgICAgc2VyaWVzTGFiZWxDb250YWluZXIgPSBkb20uY3JlYXRlKCdkaXYnLCAndHVpLWNoYXJ0LXNlcmllcy1sYWJlbC1hcmVhJyk7XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZS5pc01vdXNlUG9zaXRpb25DaGFydCh0aGlzLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZERpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdleHRlbmRlZFNlcmllcycpO1xuICAgICAgICAgICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKHNlcmllc0xhYmVsQ29udGFpbmVyLCBleHRlbmRlZERpbWVuc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZW5kZXJTZXJpZXNMYWJlbChzZXJpZXNMYWJlbENvbnRhaW5lcik7XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc0xhYmVsQ29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2VyaWVzQ29udGFpbmVyIHNlcmllcyBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jUmVuZGVyR3JhcGggZnVuY3Rpb24gZm9yIGdyYXBoIHJlbmRlcmluZ1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU2VyaWVzQXJlYTogZnVuY3Rpb24oc2VyaWVzQ29udGFpbmVyLCBkYXRhLCBmdW5jUmVuZGVyR3JhcGgpIHtcbiAgICAgICAgdmFyIGV4dGVuZGVkQm91bmQgPSB0aGlzLmJvdW5kc01ha2VyLmdldEJvdW5kKCdleHRlbmRlZFNlcmllcycpO1xuICAgICAgICB2YXIgc2VyaWVzRGF0YSwgc2VyaWVzTGFiZWxDb250YWluZXIsIHBhcGVyO1xuXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgdGhpcy5zZXJpZXNEYXRhID0gc2VyaWVzRGF0YSA9IHRoaXMuX21ha2VTZXJpZXNEYXRhKCk7XG5cbiAgICAgICAgaWYgKCFkYXRhLnBhcGVyKSB7XG4gICAgICAgICAgICByZW5kZXJVdGlsLnJlbmRlckRpbWVuc2lvbihzZXJpZXNDb250YWluZXIsIGV4dGVuZGVkQm91bmQuZGltZW5zaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlclBvc2l0aW9uKHNlcmllc0NvbnRhaW5lciwgZXh0ZW5kZWRCb3VuZC5wb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGZ1bmNSZW5kZXJHcmFwaCkge1xuICAgICAgICAgICAgcGFwZXIgPSBmdW5jUmVuZGVyR3JhcGgoZXh0ZW5kZWRCb3VuZC5kaW1lbnNpb24sIHNlcmllc0RhdGEsIGRhdGEucGFwZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc1Nob3dMYWJlbCh0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICBzZXJpZXNMYWJlbENvbnRhaW5lciA9IHRoaXMuX3JlbmRlclNlcmllc0xhYmVsQXJlYSh0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIgPSBzZXJpZXNMYWJlbENvbnRhaW5lcjtcbiAgICAgICAgICAgIGRvbS5hcHBlbmQoc2VyaWVzQ29udGFpbmVyLCBzZXJpZXNMYWJlbENvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcGFyYW1ldGVycyBmb3IgZ3JhcGggcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gcGFyYW1ldGVycyBmb3IgZ3JhcGggcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBhcmFtc0ZvckdyYXBoUmVuZGVyaW5nOiBmdW5jdGlvbihkaW1lbnNpb24sIHNlcmllc0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBkaW1lbnNpb246IGRpbWVuc2lvbixcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5zZXJpZXNOYW1lLFxuICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnNcbiAgICAgICAgfSwgc2VyaWVzRGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciByYXBoYWVsIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIC0gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc0RhdGEgLSBzZXJpZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcGFwZXJdIC0gcmFwaGFlbCBwYXBlclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyR3JhcGg6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSwgcGFwZXIpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuX21ha2VQYXJhbXNGb3JHcmFwaFJlbmRlcmluZyhkaW1lbnNpb24sIHNlcmllc0RhdGEpO1xuXG4gICAgICAgIHBhcGVyID0gdGhpcy5ncmFwaFJlbmRlcmVyLnJlbmRlcih0aGlzLnNlcmllc0NvbnRhaW5lciwgcGFyYW1zLCBwYXBlcik7XG5cbiAgICAgICAgcmV0dXJuIHBhcGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHNlcmllcyBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb20uY3JlYXRlKCdESVYnLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICAgIHZhciBwYXBlcjtcblxuICAgICAgICB0aGlzLnNlcmllc0NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgcGFwZXIgPSB0aGlzLl9yZW5kZXJTZXJpZXNBcmVhKGNvbnRhaW5lciwgZGF0YSwgdHVpLnV0aWwuYmluZCh0aGlzLl9yZW5kZXJHcmFwaCwgdGhpcykpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgICAgIHBhcGVyOiBwYXBlclxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGxlZ2VuZCB0aGVtZVxuICAgICAqIEBwYXJhbSB7P0FycmF5Ljw/Ym9vbGVhbj59IGNoZWNrZWRMZWdlbmRzIGNoZWNrZWQgbGVnZW5kc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHVwZGF0ZWQgdGhlbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVUaGVtZTogZnVuY3Rpb24odGhlbWUsIGNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgIHZhciBjbG9uZVRoZW1lO1xuXG4gICAgICAgIGlmICghY2hlY2tlZExlZ2VuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhlbWU7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9uZVRoZW1lID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGVtZSkpO1xuICAgICAgICBjbG9uZVRoZW1lLmNvbG9ycyA9IHR1aS51dGlsLmZpbHRlcihjbG9uZVRoZW1lLmNvbG9ycywgZnVuY3Rpb24oY29sb3IsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tlZExlZ2VuZHNbaW5kZXhdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2xvbmVUaGVtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgY29udGFpbmVyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciAtIHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xlYXJDb250YWluZXI6IGZ1bmN0aW9uKHBhcGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmdyYXBoUmVuZGVyZXIuY2xlYXIgJiYgIXBhcGVyKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VyaWVzQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXJpZXNEYXRhID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcmVuZGVyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGEgZm9yIHJlbmRlcmluZ1xuICAgICAqIEByZXR1cm5zIHt7Y29udGFpbmVyOiBIVE1MRWxlbWVudCwgcGFwZXI6IG9iamVjdH19XG4gICAgICovXG4gICAgcmVyZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHBhcGVyO1xuXG4gICAgICAgIHRoaXMuX2NsZWFyQ29udGFpbmVyKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRHcm91cENvdW50KHRoaXMuc2VyaWVzTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZSA9IHRoaXMuX3VwZGF0ZVRoZW1lKHRoaXMub3JnVGhlbWUsIGRhdGEuY2hlY2tlZExlZ2VuZHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXBlciA9IHRoaXMuX3JlbmRlclNlcmllc0FyZWEodGhpcy5zZXJpZXNDb250YWluZXIsIGRhdGEsIHR1aS51dGlsLmJpbmQodGhpcy5fcmVuZGVyR3JhcGgsIHRoaXMpKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWxTaG93RWZmZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMubGFiZWxTaG93RWZmZWN0b3IudGltZXJJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlQ29tcG9uZW50KHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG93R3JhcGhXaXRob3V0QW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdHVpLnV0aWwuaXNOdWxsKHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2VsZWN0TGVnZW5kKHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLnNlcmllc0NvbnRhaW5lcixcbiAgICAgICAgICAgIHBhcGVyOiBwYXBlclxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHVzZSBsYWJlbCBvciBub3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXNlTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciAmJiAodGhpcy5vcHRpb25zLnNob3dMYWJlbCB8fCB0aGlzLm9wdGlvbnMuc2hvd0xlZ2VuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgc2VyaWVzIGxhYmVsIHdpdGhvdXQgYW5pbWF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3dTZXJpZXNMYWJlbFdpdGhvdXRBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ3Nob3cgb3BhY2l0eScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGdyYXBoIHdpdGhvdXQgYW5pbWF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3dHcmFwaFdpdGhvdXRBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd0dyYXBoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3VzZUxhYmVsKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dTZXJpZXNMYWJlbFdpdGhvdXRBbmltYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgcmFwaGFlbCBncmFwaC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2l6ZUdyYXBoOiBmdW5jdGlvbihkaW1lbnNpb24sIHNlcmllc0RhdGEpIHtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlc2l6ZSh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgZGltZW5zaW9uOiBkaW1lbnNpb25cbiAgICAgICAgfSwgc2VyaWVzRGF0YSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiB9fSBib3VuZCBzZXJpZXMgYm91bmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyU2VyaWVzQXJlYSh0aGlzLnNlcmllc0NvbnRhaW5lciwgZGF0YSwgdHVpLnV0aWwuYmluZCh0aGlzLl9yZXNpemVHcmFwaCwgdGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYm91bmRzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgc2VyaWVzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gcG9zaXRpb24gc2VyaWVzIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyUG9zaXRpb246IGZ1bmN0aW9uKGVsLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgaGlkZGVuV2lkdGggPSByZW5kZXJVdGlsLmlzT2xkQnJvd3NlcigpID8gMSA6IDA7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihlbCwge1xuICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgLSAoaGlkZGVuV2lkdGgpLFxuICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIChoaWRkZW5XaWR0aCAqIDIpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGltaXQgZGlzdGFuY2UgZnJvbSB6ZXJvIHBvaW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIGNoYXJ0IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBsaW1pdFxuICAgICAqIEByZXR1cm5zIHt7dG9NYXg6IG51bWJlciwgdG9NaW46IG51bWJlcn19IHBpeGVsIGRpc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGltaXREaXN0YW5jZUZyb21aZXJvUG9pbnQ6IGZ1bmN0aW9uKHNpemUsIGxpbWl0KSB7XG4gICAgICAgIHZhciBtaW4gPSBsaW1pdC5taW4sXG4gICAgICAgICAgICBtYXggPSBsaW1pdC5tYXgsXG4gICAgICAgICAgICBkaXN0YW5jZSA9IG1heCAtIG1pbixcbiAgICAgICAgICAgIHRvTWF4ID0gMCxcbiAgICAgICAgICAgIHRvTWluID0gMDtcblxuICAgICAgICBpZiAobWluIDw9IDAgJiYgbWF4ID49IDApIHtcbiAgICAgICAgICAgIHRvTWF4ID0gKGRpc3RhbmNlICsgbWluKSAvIGRpc3RhbmNlICogc2l6ZTtcbiAgICAgICAgICAgIHRvTWluID0gKGRpc3RhbmNlIC0gbWF4KSAvIGRpc3RhbmNlICogc2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtaW4gPiAwKSB7XG4gICAgICAgICAgICB0b01heCA9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9NYXg6IHRvTWF4LFxuICAgICAgICAgICAgdG9NaW46IHRvTWluXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbGFiZWwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRhcmdldCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gbGFiZWwgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRMYWJlbEVsZW1lbnQ6IGZ1bmN0aW9uKGVsVGFyZ2V0KSB7XG4gICAgICAgIHZhciBlbExhYmVsID0gbnVsbDtcblxuICAgICAgICBpZiAoZG9tLmhhc0NsYXNzKGVsVGFyZ2V0LCBjaGFydENvbnN0LkNMQVNTX05BTUVfU0VSSUVTX0xBQkVMKSkge1xuICAgICAgICAgICAgZWxMYWJlbCA9IGVsVGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxMYWJlbCA9IGRvbS5maW5kUGFyZW50QnlDbGFzcyhlbFRhcmdldCwgY2hhcnRDb25zdC5DTEFTU19OQU1FX1NFUklFU19MQUJFTCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxMYWJlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBzaG93QW5pbWF0aW9uIGZ1bmN0aW9uIG9mIGdyYXBoUmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gZGF0YSBkYXRhXG4gICAgICovXG4gICAgb25TaG93QW5pbWF0aW9uOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaFJlbmRlcmVyLnNob3dBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd0FuaW1hdGlvbihkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBoaWRlQW5pbWF0aW9uIGZ1bmN0aW9uIG9mIGdyYXBoUmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gZGF0YSBkYXRhXG4gICAgICovXG4gICAgb25IaWRlQW5pbWF0aW9uOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaFJlbmRlcmVyLmhpZGVBbmltYXRpb24gfHwgIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuaGlkZUFuaW1hdGlvbihkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBzaG93R3JvdXBBbmltYXRpb24gZnVuY3Rpb24gb2YgZ3JhcGhSZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBvblNob3dHcm91cEFuaW1hdGlvbjogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd0dyb3VwQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnNob3dHcm91cEFuaW1hdGlvbihpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgaGlkZUdyb3VwQW5pbWF0aW9uIGZ1bmN0aW9uIG9mIGdyYXBoUmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICovXG4gICAgb25IaWRlR3JvdXBBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaFJlbmRlcmVyLmhpZGVHcm91cEFuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5oaWRlR3JvdXBBbmltYXRpb24oaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1JlcmVuZGVyaW5nXSAtIHdoZXRoZXIgcmVyZW5kZXJpbmcgb3Igbm90XG4gICAgICovXG4gICAgYW5pbWF0ZUNvbXBvbmVudDogZnVuY3Rpb24oaXNSZXJlbmRlcmluZykge1xuICAgICAgICBpZiAodGhpcy5ncmFwaFJlbmRlcmVyLmFuaW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5hbmltYXRlKHR1aS51dGlsLmJpbmQodGhpcy5hbmltYXRlU2VyaWVzTGFiZWxBcmVhLCB0aGlzLCBpc1JlcmVuZGVyaW5nKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVTZXJpZXNMYWJlbEFyZWEoaXNSZXJlbmRlcmluZyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBodG1sIGFib3V0IHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gLSBwb3NpdGlvbiBmb3IgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0gbGFiZWwgb2YgU2VyaWVzSXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIGxlZ2VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdHBsQ3NzVGV4dF0gLSBjc3NUZXh0IHRlbXBsYXRlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RhcnRdIC0gd2hldGhlciBzdGFydCBsYWJlbCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNMYWJlbEh0bWw6IGZ1bmN0aW9uKHBvc2l0aW9uLCBsYWJlbCwgaW5kZXgsIHRwbENzc1RleHQsIGlzU3RhcnQpIHtcbiAgICAgICAgdmFyIGxhYmVsVGhlbWUgPSB0aGlzLnRoZW1lLmxhYmVsO1xuICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleDtcblxuICAgICAgICByZXR1cm4gbGFiZWxIZWxwZXIubWFrZVNlcmllc0xhYmVsSHRtbChwb3NpdGlvbiwgbGFiZWwsIGxhYmVsVGhlbWUsIGluZGV4LCBzZWxlY3RlZEluZGV4LCB0cGxDc3NUZXh0LCBpc1N0YXJ0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZSBsb2FkIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzUmVyZW5kZXJpbmddIC0gd2hldGhlciByZXJlbmRlcmluZyBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlTG9hZEV2ZW50OiBmdW5jdGlvbihpc1JlcmVuZGVyaW5nKSB7XG4gICAgICAgIGlmICghaXNSZXJlbmRlcmluZykge1xuICAgICAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnbG9hZCcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgc2VyaWVzIGxhYmVsIGFyZWEuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNSZXJlbmRlcmluZ10gLSB3aGV0aGVyIHJlcmVuZGVyaW5nIG9yIG5vdFxuICAgICAqL1xuICAgIGFuaW1hdGVTZXJpZXNMYWJlbEFyZWE6IGZ1bmN0aW9uKGlzUmVyZW5kZXJpbmcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5fdXNlTGFiZWwoKSkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZUxvYWRFdmVudChpc1JlcmVuZGVyaW5nKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlclV0aWwuaXNJRTcoKSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvd1Nlcmllc0xhYmVsV2l0aG91dEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZUxvYWRFdmVudChpc1JlcmVuZGVyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyLCAnc2hvdycpO1xuICAgICAgICAgICAgdGhpcy5sYWJlbFNob3dFZmZlY3RvciA9IG5ldyB0dWkuY29tcG9uZW50LkVmZmVjdHMuRmFkZSh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMzAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubGFiZWxTaG93RWZmZWN0b3IuYWN0aW9uKHtcbiAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICBlbmQ6IDEsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5sYWJlbFNob3dFZmZlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLmxhYmVsU2hvd0VmZmVjdG9yLnRpbWVySWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGFiZWxTaG93RWZmZWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkb20uYWRkQ2xhc3Moc2VsZi5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ29wYWNpdHknKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZmlyZUxvYWRFdmVudChpc1JlcmVuZGVyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGV4cG9ydGF0aW9uIGRhdGEgZm9yIHNlcmllcyB0eXBlIHVzZXJFdmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHt7Y2hhcnRUeXBlOiBzdHJpbmcsIGxlZ2VuZDogc3RyaW5nLCBsZWdlbmRJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gZXhwb3J0IGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlRXhwb3J0YXRpb25TZXJpZXNEYXRhOiBmdW5jdGlvbihzZXJpZXNEYXRhKSB7XG4gICAgICAgIHZhciBsZWdlbmRJbmRleCA9IHNlcmllc0RhdGEuaW5kZXhlcy5pbmRleDtcbiAgICAgICAgdmFyIGxlZ2VuZERhdGEgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0TGVnZW5kSXRlbShsZWdlbmRJbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogbGVnZW5kRGF0YS5jaGFydFR5cGUsXG4gICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZERhdGEubGFiZWwsXG4gICAgICAgICAgICBsZWdlbmRJbmRleDogbGVnZW5kSW5kZXgsXG4gICAgICAgICAgICBpbmRleDogc2VyaWVzRGF0YS5pbmRleGVzLmdyb3VwSW5kZXhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBncmFwaCByZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY05hbWUgZnVuY3Rpb24gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfSByZXN1bHQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXhlY3V0ZUdyYXBoUmVuZGVyZXI6IGZ1bmN0aW9uKHBvc2l0aW9uLCBmdW5jTmFtZSkge1xuICAgICAgICB2YXIgaXNTaG93TGFiZWwgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICB0aGlzLmZpcmUoJ2hpZGVUb29sdGlwQ29udGFpbmVyJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIgJiYgZG9tLmhhc0NsYXNzKHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIsICdzaG93JykpIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyh0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyLCAnc2hvdycpO1xuICAgICAgICAgICAgaXNTaG93TGFiZWwgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5ncmFwaFJlbmRlcmVyW2Z1bmNOYW1lXShwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGlzU2hvd0xhYmVsKSB7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ3Nob3cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd1Rvb2x0aXBDb250YWluZXInKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIHNlbGVjdFNlcmllcyBjYWxsYmFjayBvZiB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc0RhdGEgc2VyaWVzIGRhdGFcbiAgICAgKi9cbiAgICBvblNlbGVjdFNlcmllczogZnVuY3Rpb24oc2VyaWVzRGF0YSkge1xuICAgICAgICB0aGlzLnVzZXJFdmVudC5maXJlKCdzZWxlY3RTZXJpZXMnLCB0aGlzLl9tYWtlRXhwb3J0YXRpb25TZXJpZXNEYXRhKHNlcmllc0RhdGEpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGxvd1NlbGVjdCAmJiB0aGlzLmdyYXBoUmVuZGVyZXIuc2VsZWN0U2VyaWVzKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2VsZWN0U2VyaWVzKHNlcmllc0RhdGEuaW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCB1bnNlbGVjdFNlcmllcyBjYWxsYmFjayBvZiB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc0RhdGEgc2VyaWVzIGRhdGEuXG4gICAgICovXG4gICAgb25VbnNlbGVjdFNlcmllczogZnVuY3Rpb24oc2VyaWVzRGF0YSkge1xuICAgICAgICB0aGlzLnVzZXJFdmVudC5maXJlKCd1bnNlbGVjdFNlcmllcycsIHRoaXMuX21ha2VFeHBvcnRhdGlvblNlcmllc0RhdGEoc2VyaWVzRGF0YSkpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93U2VsZWN0ICYmIHRoaXMuZ3JhcGhSZW5kZXJlci51bnNlbGVjdFNlcmllcykge1xuICAgICAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnVuc2VsZWN0U2VyaWVzKHNlcmllc0RhdGEuaW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpPbiBzZWxlY3QgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJpZXNOYW1lIC0gc2VyaWVzIG5hbWVcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGxlZ2VuZEluZGV4IC0gbGVnZW5kIGluZGV4XG4gICAgICovXG4gICAgb25TZWxlY3RMZWdlbmQ6IGZ1bmN0aW9uKHNlcmllc05hbWUsIGxlZ2VuZEluZGV4KSB7XG4gICAgICAgIGlmICgodGhpcy5zZXJpZXNOYW1lICE9PSBzZXJpZXNOYW1lKSAmJiAhdHVpLnV0aWwuaXNOdWxsKGxlZ2VuZEluZGV4KSkge1xuICAgICAgICAgICAgbGVnZW5kSW5kZXggPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCA9IGxlZ2VuZEluZGV4O1xuXG4gICAgICAgIGlmICh0aGlzLl9nZXRTZXJpZXNEYXRhTW9kZWwoKS5nZXRHcm91cENvdW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0FyZWEodGhpcy5zZXJpZXNDb250YWluZXIsIHRoaXMuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2VsZWN0TGVnZW5kKGxlZ2VuZEluZGV4KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGxhYmVsLlxuICAgICAqL1xuICAgIHNob3dMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaG93TGFiZWwgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zaG93U2VyaWVzTGFiZWxXaXRob3V0QW5pbWF0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgbGFiZWwuXG4gICAgICovXG4gICAgaGlkZUxhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNob3dMYWJlbCA9IGZhbHNlO1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3ModGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ3Nob3cnKTtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIsICdvcGFjaXR5Jyk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VyaWVzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgaXMgdGVtcGxhdGVzIG9mIHNlcmllcy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVtcGxhdGVNYWtlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdGVtcGxhdGVNYWtlcicpO1xuXG52YXIgaHRtbHMgPSB7XG4gICAgSFRNTF9TRVJJRVNfTEFCRUw6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LXNlcmllcy1sYWJlbFwiIHN0eWxlPVwie3sgY3NzVGV4dCB9fVwie3sgcmFuZ2VMYWJlbEF0dHJpYnV0ZSB9fT4nICtcbiAgICAgICAgJ3t7IGxhYmVsIH19PC9kaXY+JyxcbiAgICBURVhUX0NTU19URVhUOiAnbGVmdDp7eyBsZWZ0IH19cHg7dG9wOnt7IHRvcCB9fXB4O2ZvbnQtZmFtaWx5Ont7IGZvbnRGYW1pbHkgfX07JyArXG4gICAgICAgICdmb250LXNpemU6e3sgZm9udFNpemUgfX1weHt7b3BhY2l0eX19JyxcbiAgICBURVhUX0NTU19URVhUX0ZPUl9MSU5FX1RZUEU6ICdsZWZ0Ont7IGxlZnQgfX0lO3RvcDp7eyB0b3AgfX0lO2ZvbnQtZmFtaWx5Ont7IGZvbnRGYW1pbHkgfX07JyArXG4gICAgJ2ZvbnQtc2l6ZTp7eyBmb250U2l6ZSB9fXB4e3tvcGFjaXR5fX0nLFxuICAgIEhUTUxfWk9PTV9CVVRUT05TOiAnPGEgY2xhc3M9XCJ0dWktY2hhcnQtem9vbS1idG5cIiBocmVmPVwiI1wiIGRhdGEtbWFnbj1cIjJcIj4nICtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaG9yaXpvbnRhbC1saW5lXCI+PC9kaXY+PGRpdiBjbGFzcz1cInZlcnRpY2FsLWxpbmVcIj48L2Rpdj48L2E+JyArXG4gICAgICAgICc8YSBjbGFzcz1cInR1aS1jaGFydC16b29tLWJ0blwiIGhyZWY9XCIjXCIgZGF0YS1tYWduPVwiMC41XCI+PGRpdiBjbGFzcz1cImhvcml6b250YWwtbGluZVwiPjwvZGl2PjwvYT4nLFxuICAgIEhUTUxfU0VSSUVTX0JMT0NLOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1zZXJpZXMtYmxvY2tcIiBzdHlsZT1cInt7IGNzc1RleHQgfX1cIj57eyBsYWJlbCB9fTwvZGl2Pidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRwbFNlcmllc0xhYmVsOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfU0VSSUVTX0xBQkVMKSxcbiAgICB0cGxDc3NUZXh0OiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLlRFWFRfQ1NTX1RFWFQpLFxuICAgIHRwbENzc1RleHRGb3JMaW5lVHlwZTogdGVtcGxhdGVNYWtlci50ZW1wbGF0ZShodG1scy5URVhUX0NTU19URVhUX0ZPUl9MSU5FX1RZUEUpLFxuICAgIFpPT01fQlVUVE9OUzogaHRtbHMuSFRNTF9aT09NX0JVVFRPTlMsXG4gICAgdHBsU2VyaWVzQmxvY2s6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9TRVJJRVNfQkxPQ0spXG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IHNxdWFyaWZpZXIgY3JlYXRlIHNxdWFyaWZpZWQgYm91bmRzIGZvciByZW5kZXJpbmcgZ3JhcGggb2YgdHJlZW1hcCBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3F1YXJpZmllciA9IHtcbiAgICAvKipcbiAgICAgKiBib3VuZCBtYXBcbiAgICAgKiBAdHlwZSB7b2JqZWN0LjxzdHJpbmcsIHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgbGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn0+fVxuICAgICAqL1xuICAgIGJvdW5kTWFwOiB7fSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYmFzZSBib3VuZCBmb3IgY2FsY3VsYXRpbmcgYm91bmRzLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIC0gZGltZW5zaW9uXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgbGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhc2VCb3VuZDogZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMFxuICAgICAgICB9LCBkaW1lbnNpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgc2NhbGUgZm9yIGNhbGN1bGF0aW5nIHdlaWdodC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgLSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB3aWR0aCBvZiBzZXJpZXMgYXJlYVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBoZWlnaHQgb2Ygc2VyaWVzIGFyZWFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVNjYWxlOiBmdW5jdGlvbih2YWx1ZXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuICh3aWR0aCAqIGhlaWdodCkgLyB0dWkudXRpbC5zdW0odmFsdWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBiYXNlIGRhdGEgZm9yIGNyZWF0aW5nIHNxdWFyaWZpZWQgYm91bmRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFNlcmllc0l0ZW0+fSBzZXJpZXNJdGVtcyAtIFNlcmllc0l0ZW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gd2lkdGggb2Ygc2VyaWVzIGFyZWFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gaGVpZ2h0IG9mIHNlcmllcyBhcmVhXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7aXRtZTogU2VyaWVzSXRlbSwgd2VpZ2h0OiBudW1iZXJ9Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQmFzZURhdGE6IGZ1bmN0aW9uKHNlcmllc0l0ZW1zLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuX2NhbGN1bGF0ZVNjYWxlKHR1aS51dGlsLnBsdWNrKHNlcmllc0l0ZW1zLCAndmFsdWUnKSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBkYXRhID0gdHVpLnV0aWwubWFwKHNlcmllc0l0ZW1zLCBmdW5jdGlvbihzZXJpZXNJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBzZXJpZXNJdGVtLmlkLFxuICAgICAgICAgICAgICAgIHdlaWdodDogc2VyaWVzSXRlbS52YWx1ZSAqIHNjYWxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLndlaWdodCAtIGEud2VpZ2h0O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHdvcnN0IGFzcGVjdCByYXRpby5cbiAgICAgKiBSZWZlcnJlZCBmdW5jdGlvbiB3b3JzdCgpIGluIGh0dHBzOi8vd3d3Lndpbi50dWUubmwvfnZhbndpamsvc3RtLnBkZlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdW0gLSBzdW0gZm9yIHdlaWdodHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gbWluaW11bSB3ZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gbWF4aW11bSB3ZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZVNpemUgLSBiYXNlIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3dvcnN0OiBmdW5jdGlvbihzdW0sIG1pbiwgbWF4LCBiYXNlU2l6ZSkge1xuICAgICAgICB2YXIgc3VtU3F1YXJlID0gc3VtICogc3VtO1xuICAgICAgICB2YXIgc2l6ZVNxdWFyZSA9IGJhc2VTaXplICogYmFzZVNpemU7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KChzaXplU3F1YXJlICogbWF4KSAvIHN1bVNxdWFyZSwgc3VtU3F1YXJlIC8gKHNpemVTcXVhcmUgKiBtaW4pKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjaGFuZ2VkIHN0YWNrIGRpcmVjdGlvbiBvciBub3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1bSAtIHN1bSBmb3Igd2VpZ2h0c1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHdlaWdodHMgLSB3ZWlnaHRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VTaXplIC0gYmFzZSBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1dlaWdodCAtIG5ldyB3ZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGFuZ2VkU3RhY2tEaXJlY3Rpb246IGZ1bmN0aW9uKHN1bSwgd2VpZ2h0cywgYmFzZVNpemUsIG5ld1dlaWdodCkge1xuICAgICAgICB2YXIgbWluID0gdHVpLnV0aWwubWluKHdlaWdodHMpO1xuICAgICAgICB2YXIgbWF4ID0gdHVpLnV0aWwubWF4KHdlaWdodHMpO1xuICAgICAgICB2YXIgYmVmb3JlV29yc3QgPSB0aGlzLl93b3JzdChzdW0sIG1pbiwgbWF4LCBiYXNlU2l6ZSk7XG4gICAgICAgIHZhciBuZXdXb3JzdCA9IHRoaXMuX3dvcnN0KHN1bSArIG5ld1dlaWdodCwgTWF0aC5taW4obWluLCBuZXdXZWlnaHQpLCBNYXRoLm1heChtYXgsIG5ld1dlaWdodCksIGJhc2VTaXplKTtcblxuICAgICAgICByZXR1cm4gbmV3V29yc3QgPj0gYmVmb3JlV29yc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdHlwZSBvZiB2ZXJ0aWNhbCBzdGFjayBvciBub3QuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBiYXNlQm91bmQgLSBiYXNlIGJvdW5kXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNWZXJ0aWNhbFN0YWNrOiBmdW5jdGlvbihiYXNlQm91bmQpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VCb3VuZC5oZWlnaHQgPCBiYXNlQm91bmQud2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBiYXNlIHNpemUgZnJvbSBiYXNlQm91bmQuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBiYXNlQm91bmQgLSBiYXNlIGJvdW5kXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZWxlY3RCYXNlU2l6ZTogZnVuY3Rpb24oYmFzZUJvdW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1ZlcnRpY2FsU3RhY2soYmFzZUJvdW5kKSA/IGJhc2VCb3VuZC5oZWlnaHQgOiBiYXNlQm91bmQud2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBmaXhlZCBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlU2l6ZSAtIGJhc2Ugc2l6ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdW0gLSBzdW0gZm9yIHdlaWdodHNcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7d2VpZ2h0OiBudW1iZXJ9Pn0gcm93IC0gcm93XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVGaXhlZFNpemU6IGZ1bmN0aW9uKGJhc2VTaXplLCBzdW0sIHJvdykge1xuICAgICAgICB2YXIgd2VpZ2h0cztcblxuICAgICAgICBpZiAoIXN1bSkge1xuICAgICAgICAgICAgd2VpZ2h0cyA9IHR1aS51dGlsLnBsdWNrKHJvdywgJ3dlaWdodCcpO1xuICAgICAgICAgICAgc3VtID0gdHVpLnV0aWwuc3VtKHdlaWdodHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1bSAvIGJhc2VTaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYm91bmRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFBvc2l0aW9uIC0gc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7d2VpZ2h0OiBudW1iZXJ9Pn0gcm93IC0gcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZpeGVkU2l6ZSAtIGZpeGVkIHNpemVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQm91bmRzOiBmdW5jdGlvbihzdGFydFBvc2l0aW9uLCByb3csIGZpeGVkU2l6ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdHVpLnV0aWwucmVkdWNlKFtzdGFydFBvc2l0aW9uXS5jb25jYXQocm93KSwgZnVuY3Rpb24oc3RvcmVkUG9zaXRpb24sIHJvd0RhdHVtKSB7XG4gICAgICAgICAgICB2YXIgZHluYW1pY1NpemUgPSByb3dEYXR1bS53ZWlnaHQgLyBmaXhlZFNpemU7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKGR5bmFtaWNTaXplLCBzdG9yZWRQb3NpdGlvbiwgcm93RGF0dW0uaWQpO1xuXG4gICAgICAgICAgICByZXR1cm4gc3RvcmVkUG9zaXRpb24gKyBkeW5hbWljU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCAtIGxlZnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wIC0gdG9wIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGlkIC0gaWQgb2Ygc2VyaWVzSXRlbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEJvdW5kOiBmdW5jdGlvbihsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIGlkKSB7XG4gICAgICAgIHRoaXMuYm91bmRNYXBbaWRdID0ge1xuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGJvdW5kcyBmb3IgdHlwZSBvZiB2ZXJ0aWNhbCBzdGFjay5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7d2VpZ2h0OiBudW1iZXJ9Pn0gcm93IC0gcm93XG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBiYXNlQm91bmQgLSBiYXNlIGJvdW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VTaXplIC0gYmFzZSBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1bSAtIHN1bSBmb3Igd2VpZ2h0cyBvZiByb3dcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRCb3VuZHNGb3JWZXJ0aWNhbFN0YWNrOiBmdW5jdGlvbihyb3csIGJhc2VCb3VuZCwgYmFzZVNpemUsIHN1bSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBmaXhlZFdpZHRoID0gdGhpcy5fY2FsY3VsYXRlRml4ZWRTaXplKGJhc2VTaXplLCBzdW0sIHJvdyk7XG5cbiAgICAgICAgdGhpcy5fYWRkQm91bmRzKGJhc2VCb3VuZC50b3AsIHJvdywgZml4ZWRXaWR0aCwgZnVuY3Rpb24oZHluYW1pY0hlaWdodCwgc3RvcmVkVG9wLCBpZCkge1xuICAgICAgICAgICAgc2VsZi5fYWRkQm91bmQoYmFzZUJvdW5kLmxlZnQsIHN0b3JlZFRvcCwgZml4ZWRXaWR0aCwgZHluYW1pY0hlaWdodCwgaWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBiYXNlQm91bmQubGVmdCArPSBmaXhlZFdpZHRoO1xuICAgICAgICBiYXNlQm91bmQud2lkdGggLT0gZml4ZWRXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGJvdW5kcyBmb3IgdHlwZSBvZiBob3Jpem9udGFsIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHt3ZWlnaHQ6IG51bWJlcn0+fSByb3cgLSByb3dcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJhc2VCb3VuZCAtIGJhc2UgYm91bmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZVNpemUgLSBiYXNlIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VtIC0gc3VtIGZvciB3ZWlnaHRzIG9mIHJvd1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEJvdW5kc0Zvckhvcml6b250YWxTdGFjazogZnVuY3Rpb24ocm93LCBiYXNlQm91bmQsIGJhc2VTaXplLCBzdW0pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZml4ZWRIZWlnaHQgPSB0aGlzLl9jYWxjdWxhdGVGaXhlZFNpemUoYmFzZVNpemUsIHN1bSwgcm93KTtcblxuICAgICAgICB0aGlzLl9hZGRCb3VuZHMoYmFzZUJvdW5kLmxlZnQsIHJvdywgZml4ZWRIZWlnaHQsIGZ1bmN0aW9uKGR5bmFtaWNXaWR0aCwgc3RvcmVkTGVmdCwgaWQpIHtcbiAgICAgICAgICAgIHNlbGYuX2FkZEJvdW5kKHN0b3JlZExlZnQsIGJhc2VCb3VuZC50b3AsIGR5bmFtaWNXaWR0aCwgZml4ZWRIZWlnaHQsIGlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYmFzZUJvdW5kLnRvcCArPSBmaXhlZEhlaWdodDtcbiAgICAgICAgYmFzZUJvdW5kLmhlaWdodCAtPSBmaXhlZEhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFkZGluZyBib3VuZHMgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBiYXNlQm91bmQgLSBiYXNlIGJvdW5kXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QWRkaW5nQm91bmRzRnVuY3Rpb246IGZ1bmN0aW9uKGJhc2VCb3VuZCkge1xuICAgICAgICB2YXIgYWRkQm91bmQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWxTdGFjayhiYXNlQm91bmQpKSB7XG4gICAgICAgICAgICBhZGRCb3VuZCA9IHR1aS51dGlsLmJpbmQodGhpcy5fYWRkQm91bmRzRm9yVmVydGljYWxTdGFjaywgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRCb3VuZCA9IHR1aS51dGlsLmJpbmQodGhpcy5fYWRkQm91bmRzRm9ySG9yaXpvbnRhbFN0YWNrLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhZGRCb3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHNxdWFyaWZpZWQgYm91bmQgbWFwIGZvciBncmFwaCByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gLSBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxTZXJpZXNJdGVtPn0gc2VyaWVzSXRlbXMgLSBzZXJpZXNJdGVtc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3QuPHN0cmluZywge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfT59XG4gICAgICovXG4gICAgc3F1YXJpZnk6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgc2VyaWVzSXRlbXMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYmFzZUJvdW5kID0gdGhpcy5fbWFrZUJhc2VCb3VuZChkaW1lbnNpb24pO1xuICAgICAgICB2YXIgYmFzZURhdGEgPSB0aGlzLl9tYWtlQmFzZURhdGEoc2VyaWVzSXRlbXMsIGJhc2VCb3VuZC53aWR0aCwgYmFzZUJvdW5kLmhlaWdodCk7XG4gICAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgICAgdmFyIGJhc2VTaXplLCBhZGRCb3VuZHM7XG5cbiAgICAgICAgdGhpcy5ib3VuZE1hcCA9IHt9O1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShiYXNlRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgIHZhciB3ZWlnaHRzID0gdHVpLnV0aWwucGx1Y2socm93LCAnd2VpZ2h0Jyk7XG4gICAgICAgICAgICB2YXIgc3VtID0gdHVpLnV0aWwuc3VtKHdlaWdodHMpO1xuXG4gICAgICAgICAgICBpZiAocm93Lmxlbmd0aCAmJiBzZWxmLl9jaGFuZ2VkU3RhY2tEaXJlY3Rpb24oc3VtLCB3ZWlnaHRzLCBiYXNlU2l6ZSwgZGF0dW0ud2VpZ2h0KSkge1xuICAgICAgICAgICAgICAgIGFkZEJvdW5kcyhyb3csIGJhc2VCb3VuZCwgYmFzZVNpemUsIHN1bSk7XG4gICAgICAgICAgICAgICAgcm93ID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJhc2VTaXplID0gc2VsZi5fc2VsZWN0QmFzZVNpemUoYmFzZUJvdW5kKTtcbiAgICAgICAgICAgICAgICBhZGRCb3VuZHMgPSBzZWxmLl9nZXRBZGRpbmdCb3VuZHNGdW5jdGlvbihiYXNlQm91bmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByb3cucHVzaChkYXR1bSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZGRCb3VuZHMocm93LCBiYXNlQm91bmQsIGJhc2VTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kTWFwO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3F1YXJpZmllcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBTZXJpZXMgY29tcG9uZW50IGZvciByZW5kZXJpbmcgZ3JhcGggb2YgdHJlZW1hcCBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2VyaWVzID0gcmVxdWlyZSgnLi9zZXJpZXMnKTtcbnZhciBzcXVhcmlmaWVyID0gcmVxdWlyZSgnLi9zcXVhcmlmaWVyJyk7XG52YXIgbGFiZWxIZWxwZXIgPSByZXF1aXJlKCcuL3JlbmRlcmluZ0xhYmVsSGVscGVyJyk7XG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcblxudmFyIFRyZWVtYXBDaGFydFNlcmllcyA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFNlcmllcywgLyoqIEBsZW5kcyBUcmVlbWFwQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBTZXJpZXMgY29tcG9uZW50IGZvciByZW5kZXJpbmcgZ3JhcGggb2YgdHJlZW1hcCBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBUcmVlbWFwQ2hhcnRTZXJpZXNcbiAgICAgKiBAZXh0ZW5kcyBTZXJpZXNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgU2VyaWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdGhpcy50aGVtZS5ib3JkZXJDb2xvciA9IHRoaXMudGhlbWUuYm9yZGVyQ29sb3IgfHwgY2hhcnRDb25zdC5UUkVFTUFQX0RFRkFVTFRfQk9SREVSO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByb290IGlkXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvb3RJZCA9IGNoYXJ0Q29uc3QuVFJFRU1BUF9ST09UX0lEO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdGFydCBkZXB0aCBvZiBzZXJpZXNJdGVtIGZvciByZW5kZXJpbmcgZ3JhcGhcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnREZXB0aCA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlbGVjdGVkIGdyb3VwXG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwgbnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZEdyb3VwID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYm91bmQgbWFwXG4gICAgICAgICAqIEB0eXBlIHtudWxsfG9iamVjdC48c3RyaW5nLCBvYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZE1hcCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5faW5pdE9wdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBvcHRpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRPcHRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnVzZUNvbG9yVmFsdWUgPSAhIXRoaXMub3B0aW9ucy51c2VDb2xvclZhbHVlO1xuXG4gICAgICAgIGlmICh0dWkudXRpbC5pc1VuZGVmaW5lZCh0aGlzLm9wdGlvbnMuem9vbWFibGUpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuem9vbWFibGUgPSAhdGhpcy5vcHRpb25zLnVzZUNvbG9yVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHVpLnV0aWwuaXNVbmRlZmluZWQodGhpcy5vcHRpb25zLnVzZUxlYWZMYWJlbCkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy51c2VMZWFmTGFiZWwgPSAhdGhpcy5vcHRpb25zLnpvb21hYmxlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VyaWVzIGRhdGEuXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGdyb3VwQm91bmRzOiBvYmplY3QuPHN0cmluZywge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfT4sXG4gICAgICogICAgICBzZXJpZXNEYXRhTW9kZWw6IFNlcmllc0RhdGFNb2RlbFxuICAgICAqIH19XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYm91bmRNYXAgPSB0aGlzLl9nZXRCb3VuZE1hcCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib3VuZE1hcDogYm91bmRNYXAsXG4gICAgICAgICAgICBncm91cEJvdW5kczogdGhpcy5fbWFrZUJvdW5kcyhib3VuZE1hcCksXG4gICAgICAgICAgICBzZXJpZXNEYXRhTW9kZWw6IHRoaXMuX2dldFNlcmllc0RhdGFNb2RlbCgpLFxuICAgICAgICAgICAgc3RhcnREZXB0aDogdGhpcy5zdGFydERlcHRoLFxuICAgICAgICAgICAgaXNQaXZvdDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbG9yU3BlY3RydW06IHRoaXMub3B0aW9ucy51c2VDb2xvclZhbHVlID8gdGhpcy5kYXRhLmNvbG9yU3BlY3RydW0gOiBudWxsLFxuICAgICAgICAgICAgY2hhcnRCYWNrZ3JvdW5kOiB0aGlzLmNoYXJ0QmFja2dyb3VuZCxcbiAgICAgICAgICAgIHpvb21hYmxlOiB0aGlzLm9wdGlvbnMuem9vbWFibGVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZCBtYXAgYnkgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBwYXJlbnQgLSBwYXJlbnQgaWRcbiAgICAgKiBAcGFyYW0ge29iamVjdC48c3RyaW5nLCB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9Pn0gYm91bmRNYXAgLSBib3VuZCBtYXBcbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiAtIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIHtvYmplY3QuPHN0cmluZywge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJvdW5kTWFwOiBmdW5jdGlvbihwYXJlbnQsIGJvdW5kTWFwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5fZ2V0U2VyaWVzRGF0YU1vZGVsKCk7XG4gICAgICAgIHZhciBzZXJpZXNJdGVtcztcblxuICAgICAgICBkaW1lbnNpb24gPSBkaW1lbnNpb24gfHwgdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuICAgICAgICBzZXJpZXNJdGVtcyA9IHNlcmllc0RhdGFNb2RlbC5maW5kU2VyaWVzSXRlbXNCeVBhcmVudChwYXJlbnQpO1xuICAgICAgICBib3VuZE1hcCA9IHR1aS51dGlsLmV4dGVuZChib3VuZE1hcCB8fCB7fSwgc3F1YXJpZmllci5zcXVhcmlmeShkaW1lbnNpb24sIHNlcmllc0l0ZW1zKSk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHNlcmllc0l0ZW1zLCBmdW5jdGlvbihzZXJpZXNJdGVtKSB7XG4gICAgICAgICAgICBib3VuZE1hcCA9IHNlbGYuX21ha2VCb3VuZE1hcChzZXJpZXNJdGVtLmlkLCBib3VuZE1hcCwgYm91bmRNYXBbc2VyaWVzSXRlbS5pZF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYm91bmRNYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYm91bmRzIGZvciByZW5kZXJpbmcgZ3JhcGguXG4gICAgICogQHBhcmFtIHtvYmplY3QuPHN0cmluZywge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfT59IGJvdW5kTWFwIC0gYm91bmQgbWFwXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfT4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kTWFwKSB7XG4gICAgICAgIHZhciBzdGFydERlcHRoID0gdGhpcy5zdGFydERlcHRoO1xuICAgICAgICB2YXIgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5fZ2V0U2VyaWVzRGF0YU1vZGVsKCk7XG4gICAgICAgIHZhciBpc1ZhbGlkO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbWFibGUpIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmdW5jdGlvbihzZXJpZXNJdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllc0l0ZW0uZGVwdGggPT09IHN0YXJ0RGVwdGg7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZ1bmN0aW9uKHNlcmllc0l0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXNlcmllc0l0ZW0uaGFzQ2hpbGQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc0RhdGFNb2RlbC5tYXAoZnVuY3Rpb24oc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNHcm91cC5tYXAoZnVuY3Rpb24oc2VyaWVzSXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZCA9IGJvdW5kTWFwW3Nlcmllc0l0ZW0uaWRdO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kICYmIGlzVmFsaWQoc2VyaWVzSXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBib3VuZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBib3VuZCBtYXAgZm9yIHJlbmRlcmluZyBncmFwaC5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0LjxzdHJpbmcsIHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEJvdW5kTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJvdW5kTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kTWFwID0gdGhpcy5fbWFrZUJvdW5kTWFwKHRoaXMucm9vdElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHNob3VsZCBkaW1tZWQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7U2VyaWVzRGF0YU1vZGVsfSBzZXJpZXNEYXRhTW9kZWwgLSBTZXJpZXNEYXRhTW9kZWwgZm9yIHRyZWVtYXBcbiAgICAgKiBAcGFyYW0ge1Nlcmllc0l0ZW19IGhvdmVyU2VyaWVzSXRlbSAtIGhvdmVyIFNlcmllc0l0ZW1cbiAgICAgKiBAcGFyYW0ge1Nlcmllc0l0ZW19IHNlcmllc0l0ZW0gLSB0YXJnZXQgU2VyaWVzSXRlbVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3VsZERpbW1lZDogZnVuY3Rpb24oc2VyaWVzRGF0YU1vZGVsLCBob3ZlclNlcmllc0l0ZW0sIHNlcmllc0l0ZW0pIHtcbiAgICAgICAgdmFyIHNob3VsZFRyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBwYXJlbnQ7XG5cbiAgICAgICAgaWYgKGhvdmVyU2VyaWVzSXRlbSAmJiBzZXJpZXNJdGVtLmlkICE9PSBob3ZlclNlcmllc0l0ZW0uaWQgJiYgc2VyaWVzSXRlbS5ncm91cCA9PT0gaG92ZXJTZXJpZXNJdGVtLmdyb3VwKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBzZXJpZXNEYXRhTW9kZWwuZmluZFBhcmVudEJ5RGVwdGgoc2VyaWVzSXRlbS5pZCwgaG92ZXJTZXJpZXNJdGVtLmRlcHRoICsgMSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCA9PT0gaG92ZXJTZXJpZXNJdGVtLmlkKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkVHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNob3VsZFRyYW5zcGFyZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxhYmVsQ29udGFpbmVyIC0gc2VyaWVzIGxhYmVsIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7U2VyaWVzSXRlbX0gaG92ZXJTZXJpZXNJdGVtIC0gaG92ZXIgU2VyaWVzSXRlbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0xhYmVsOiBmdW5jdGlvbihsYWJlbENvbnRhaW5lciwgaG92ZXJTZXJpZXNJdGVtKSB7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhTW9kZWwgPSB0aGlzLl9nZXRTZXJpZXNEYXRhTW9kZWwoKTtcbiAgICAgICAgdmFyIGJvdW5kTWFwID0gdGhpcy5fZ2V0Qm91bmRNYXAoKTtcbiAgICAgICAgdmFyIHNlcmllc0l0ZW1zLCBzaG91bGREaW1tZWQsIGh0bWw7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VMZWFmTGFiZWwpIHtcbiAgICAgICAgICAgIHNlcmllc0l0ZW1zID0gc2VyaWVzRGF0YU1vZGVsLmZpbmRMZWFmU2VyaWVzSXRlbXModGhpcy5zZWxlY3RlZEdyb3VwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcmllc0l0ZW1zID0gc2VyaWVzRGF0YU1vZGVsLmZpbmRTZXJpZXNJdGVtc0J5RGVwdGgodGhpcy5zdGFydERlcHRoLCB0aGlzLnNlbGVjdGVkR3JvdXApO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hvdWxkRGltbWVkID0gdHVpLnV0aWwuYmluZCh0aGlzLl9zaG91bGREaW1tZWQsIHRoaXMsIHNlcmllc0RhdGFNb2RlbCwgaG92ZXJTZXJpZXNJdGVtKTtcbiAgICAgICAgaHRtbCA9IGxhYmVsSGVscGVyLm1ha2VMYWJlbHNIdG1sRm9yVHJlZW1hcChzZXJpZXNJdGVtcywgYm91bmRNYXAsIHRoaXMudGhlbWUubGFiZWwsIHNob3VsZERpbW1lZCk7XG5cbiAgICAgICAgbGFiZWxDb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYm91bmRNYXAgPSBudWxsO1xuICAgICAgICBTZXJpZXMucHJvdG90eXBlLnJlc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSByb290SWQgLSByb290IGlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0RGVwdGggLSBzdGFydCBkZXB0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cCAtIGdyb3VwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfem9vbTogZnVuY3Rpb24ocm9vdElkLCBzdGFydERlcHRoLCBncm91cCkge1xuICAgICAgICB0aGlzLl9jbGVhckNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLmJvdW5kTWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yb290SWQgPSByb290SWQ7XG4gICAgICAgIHRoaXMuc3RhcnREZXB0aCA9IHN0YXJ0RGVwdGg7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRHcm91cCA9IGdyb3VwO1xuICAgICAgICB0aGlzLl9yZW5kZXJTZXJpZXNBcmVhKHRoaXMuc2VyaWVzQ29udGFpbmVyLCB0aGlzLmRhdGEsIHR1aS51dGlsLmJpbmQodGhpcy5fcmVuZGVyR3JhcGgsIHRoaXMpKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzU2hvd0xhYmVsKHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dTZXJpZXNMYWJlbFdpdGhvdXRBbmltYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tXG4gICAgICogQHBhcmFtIHt7aW5kZXg6IG51bWJlcn19IGRhdGEgLSBkYXRhIGZvciB6b29tXG4gICAgICovXG4gICAgem9vbTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgZGV0ZWN0ZWRJbmRleCA9IGRhdGEuaW5kZXg7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhTW9kZWwsIHNlcmllc0l0ZW07XG5cbiAgICAgICAgaWYgKGRldGVjdGVkSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl96b29tKGNoYXJ0Q29uc3QuVFJFRU1BUF9ST09UX0lELCAxLCBudWxsKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWVzRGF0YU1vZGVsID0gdGhpcy5fZ2V0U2VyaWVzRGF0YU1vZGVsKCk7XG4gICAgICAgIHNlcmllc0l0ZW0gPSBzZXJpZXNEYXRhTW9kZWwuZ2V0U2VyaWVzSXRlbSgwLCBkZXRlY3RlZEluZGV4LCB0cnVlKTtcblxuICAgICAgICBpZiAoIXNlcmllc0l0ZW0gfHwgIXNlcmllc0l0ZW0uaGFzQ2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3pvb20oc2VyaWVzSXRlbS5pZCwgc2VyaWVzSXRlbS5kZXB0aCArIDEsIHNlcmllc0l0ZW0uZ3JvdXApO1xuICAgICAgICB0aGlzLmZpcmUoJ2FmdGVyWm9vbScsIGRldGVjdGVkSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIHNob3dBbmltYXRpb24gZnVuY3Rpb24gb2YgZ3JhcGhSZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIC0gaW5kZXhlc1xuICAgICAqL1xuICAgIG9uU2hvd0FuaW1hdGlvbjogZnVuY3Rpb24oaW5kZXhlcykge1xuICAgICAgICB2YXIgc2VyaWVzSXRlbTtcblxuICAgICAgICBpZiAoIXByZWRpY2F0ZS5pc1Nob3dMYWJlbCh0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpZXNJdGVtID0gdGhpcy5fZ2V0U2VyaWVzRGF0YU1vZGVsKCkuZ2V0U2VyaWVzSXRlbShpbmRleGVzLmdyb3VwSW5kZXgsIGluZGV4ZXMuaW5kZXgsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0xhYmVsKHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIsIHNlcmllc0l0ZW0pO1xuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd0FuaW1hdGlvbihpbmRleGVzLCB0aGlzLm9wdGlvbnMudXNlQ29sb3JWYWx1ZSwgMC42KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBoaWRlQW5pbWF0aW9uIGZ1bmN0aW9uIG9mIGdyYXBoUmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyAtIGluZGV4ZXNcbiAgICAgKi9cbiAgICBvbkhpZGVBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUuaXNTaG93TGFiZWwodGhpcy5vcHRpb25zKSB8fCAhaW5kZXhlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyU2VyaWVzTGFiZWwodGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5oaWRlQW5pbWF0aW9uKGluZGV4ZXMsIHRoaXMub3B0aW9ucy51c2VDb2xvclZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gc2hvdyB0b29sdGlwIGZvciBjYWxsaW5nIHNob3dXZWRnZS5cbiAgICAgKiBAcGFyYW0ge3tpbmRleGVzOiB7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX19IHBhcmFtcyAtIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBvblNob3dUb29sdGlwOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNlcmllc0RhdGFNb2RlbCA9IHRoaXMuX2dldFNlcmllc0RhdGFNb2RlbCgpO1xuICAgICAgICB2YXIgaW5kZXhlcyA9IHBhcmFtcy5pbmRleGVzO1xuICAgICAgICB2YXIgcmF0aW8gPSBzZXJpZXNEYXRhTW9kZWwuZ2V0U2VyaWVzSXRlbShpbmRleGVzLmdyb3VwSW5kZXgsIGluZGV4ZXMuaW5kZXgsIHRydWUpLnJhdGlvO1xuXG4gICAgICAgIGlmIChyYXRpbyA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3Nob3dXZWRnZScsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oVHJlZW1hcENoYXJ0U2VyaWVzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlbWFwQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgWm9vbSBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNlcmllc1RlbXBsYXRlID0gcmVxdWlyZSgnLi9zZXJpZXNUZW1wbGF0ZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBldmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi4vaGVscGVycy9ldmVudExpc3RlbmVyJyk7XG5cbnZhciBab29tID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBab29tLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBab29tIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7Qm91bmRzTWFrZXJ9IHBhcmFtcy5ib3VuZHNNYWtlciBib3VuZHMgbWFrZXJcbiAgICAgKiBAY29uc3RydWN0cyBab29tXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jaGFydC16b29tLWFyZWEnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZHMgbWFrZXJcbiAgICAgICAgICogQHR5cGUge0JvdW5kc01ha2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlciA9IHBhcmFtcy5ib3VuZHNNYWtlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFnbmlmaWNhdGlvbi5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFnbiA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YWNrZWQgd2hlZWxEZWx0YS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhY2tlZFdoZWVsRGVsdGEgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB6b29tIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb20uY3JlYXRlKCdESVYnLCB0aGlzLmNsYXNzTmFtZSk7XG5cbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCArPSBzZXJpZXNUZW1wbGF0ZS5aT09NX0JVVFRPTlM7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24oY29udGFpbmVyLCB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKCdzZXJpZXMnKSk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV2ZW50KGNvbnRhaW5lcik7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBidXR0b24gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgez9IVE1MRWxlbWVudH0gYnV0dG9uIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kQnRuRWxlbWVudDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIHZhciBidG5DbGFzc05hbWUgPSAndHVpLWNoYXJ0LXpvb20tYnRuJyxcbiAgICAgICAgICAgIGJ0bkVsZW1lbnQgPSB0YXJnZXQ7XG5cbiAgICAgICAgaWYgKCFkb20uaGFzQ2xhc3ModGFyZ2V0LCBidG5DbGFzc05hbWUpKSB7XG4gICAgICAgICAgICBidG5FbGVtZW50ID0gZG9tLmZpbmRQYXJlbnRCeUNsYXNzKHRhcmdldCwgYnRuQ2xhc3NOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidG5FbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hZ24gbWFnbmlmaWNhdGlvblxuICAgICAqIEBwYXJhbSB7P3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF96b29tOiBmdW5jdGlvbihtYWduLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgY2hhbmdlZE1hZ24gPSBNYXRoLm1pbihNYXRoLm1heCgxLCB0aGlzLm1hZ24gKiBtYWduKSwgY2hhcnRDb25zdC5NQVhfWk9PTV9NQUdOKTtcblxuICAgICAgICBpZiAoY2hhbmdlZE1hZ24gIT09IHRoaXMubWFnbikge1xuICAgICAgICAgICAgdGhpcy5tYWduID0gY2hhbmdlZE1hZ247XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3pvb20nLCB0aGlzLm1hZ24sIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGljay5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7P2Jvb2xlYW59IHByZXZlbnQgZGVmYXVsdCBmb3IgaWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXG4gICAgICAgICAgICBidG5FbGVtZW50ID0gdGhpcy5fZmluZEJ0bkVsZW1lbnQodGFyZ2V0KSxcbiAgICAgICAgICAgIG1hZ247XG5cbiAgICAgICAgaWYgKGJ0bkVsZW1lbnQpIHtcbiAgICAgICAgICAgIG1hZ24gPSBwYXJzZUZsb2F0KGJ0bkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW1hZ24nKSk7XG4gICAgICAgICAgICB0aGlzLl96b29tKG1hZ24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F0dGFjaEV2ZW50OiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lci5vbih0YXJnZXQsICdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbWFnbmlmaWNhdGlvbiBmcm9tIHdoZWVsRGVsdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdoZWVsRGVsdGEgd2hlZWxEZWx0YVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG1hZ25pZmljYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVNYWduOiBmdW5jdGlvbih3aGVlbERlbHRhKSB7XG4gICAgICAgIHZhciB0aWNrID0gcGFyc2VJbnQod2hlZWxEZWx0YSAvIGNoYXJ0Q29uc3QuV0hFRUxfVElDSywgMTApLFxuICAgICAgICAgICAgbWFnbjtcblxuICAgICAgICBpZiAodGljayA+IDApIHtcbiAgICAgICAgICAgIG1hZ24gPSBNYXRoLnBvdygyLCB0aWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hZ24gPSBNYXRoLnBvdygwLjUsIE1hdGguYWJzKHRpY2spKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYWduO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiB3aGVlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2hlZWxEZWx0YSB3aGVlbERlbHRhXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICovXG4gICAgb25XaGVlbDogZnVuY3Rpb24od2hlZWxEZWx0YSwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIG1hZ247XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHdoZWVsRGVsdGEpIDwgY2hhcnRDb25zdC5XSEVFTF9USUNLKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrZWRXaGVlbERlbHRhICs9IHdoZWVsRGVsdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrZWRXaGVlbERlbHRhID0gd2hlZWxEZWx0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnN0YWNrZWRXaGVlbERlbHRhKSA8IGNoYXJ0Q29uc3QuV0hFRUxfVElDSykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFnbiA9IHRoaXMuX2NhbGN1bGF0ZU1hZ24odGhpcy5zdGFja2VkV2hlZWxEZWx0YSk7XG5cbiAgICAgICAgdGhpcy5fem9vbShtYWduLCBwb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5zdGFja2VkV2hlZWxEZWx0YSA9IHRoaXMuc3RhY2tlZFdoZWVsRGVsdGEgJSBjaGFydENvbnN0LldIRUVMX1RJQ0s7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihab29tKTtcblxubW9kdWxlLmV4cG9ydHMgPSBab29tO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgREVGQVVMVF9DT0xPUiA9ICcjMDAwMDAwJyxcbiAgICBERUZBVUxUX0JBQ0tHUk9VTkQgPSAnI2ZmZmZmZicsXG4gICAgRU1QVFkgPSAnJyxcbiAgICBERUZBVUxUX0FYSVMgPSB7XG4gICAgICAgIHRpY2tDb2xvcjogREVGQVVMVF9DT0xPUixcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IEVNUFRZLFxuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfQ09MT1JcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IEVNUFRZLFxuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfQ09MT1JcbiAgICAgICAgfVxuICAgIH07XG5cbnZhciBkZWZhdWx0VGhlbWUgPSB7XG4gICAgY2hhcnQ6IHtcbiAgICAgICAgYmFja2dyb3VuZDogREVGQVVMVF9CQUNLR1JPVU5ELFxuICAgICAgICBmb250RmFtaWx5OiAnVmVyZGFuYSdcbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICAgIGZvbnRTaXplOiAxOCxcbiAgICAgICAgZm9udEZhbWlseTogRU1QVFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0NPTE9SXG4gICAgfSxcbiAgICB5QXhpczogREVGQVVMVF9BWElTLFxuICAgIHhBeGlzOiBERUZBVUxUX0FYSVMsXG4gICAgcGxvdDoge1xuICAgICAgICBsaW5lQ29sb3I6ICcjZGRkZGRkJyxcbiAgICAgICAgYmFja2dyb3VuZDogJyNmZmZmZmYnXG4gICAgfSxcbiAgICBzZXJpZXM6IHtcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IEVNUFRZLFxuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfQ09MT1JcbiAgICAgICAgfSxcbiAgICAgICAgY29sb3JzOiBbJyNhYzQxNDInLCAnI2QyODQ0NScsICcjZjRiZjc1JywgJyM5MGE5NTknLCAnIzc1YjVhYScsICcjNmE5ZmI1JywgJyNhYTc1OWYnLCAnIzhmNTUzNiddLFxuICAgICAgICBzaW5nbGVDb2xvcnM6IFtdLFxuICAgICAgICBib3JkZXJDb2xvcjogRU1QVFksXG4gICAgICAgIHNlbGVjdGlvbkNvbG9yOiBFTVBUWSxcbiAgICAgICAgc3RhcnRDb2xvcjogJyNGNEY0RjQnLFxuICAgICAgICBlbmRDb2xvcjogJyMzNDUzOTEnLFxuICAgICAgICBvdmVyQ29sb3I6ICcjRjBDOTUyJ1xuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgICAgICBmb250RmFtaWx5OiBFTVBUWSxcbiAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0NPTE9SXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRUaGVtZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBHcm91cCB0b29sdGlwIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9vbHRpcEJhc2UgPSByZXF1aXJlKCcuL3Rvb2x0aXBCYXNlJyksXG4gICAgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCA9IHJlcXVpcmUoJy4vZ3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCcpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBkZWZhdWx0VGhlbWUgPSByZXF1aXJlKCcuLi90aGVtZXMvZGVmYXVsdFRoZW1lJyksXG4gICAgdG9vbHRpcFRlbXBsYXRlID0gcmVxdWlyZSgnLi90b29sdGlwVGVtcGxhdGUnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIEdyb3VwVG9vbHRpcCBjb21wb25lbnQuXG4gKiBAY2xhc3MgR3JvdXBUb29sdGlwXG4gKi9cbnZhciBHcm91cFRvb2x0aXAgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhUb29sdGlwQmFzZSwgLyoqIEBsZW5kcyBHcm91cFRvb2x0aXAucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBHcm91cCB0b29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBHcm91cFRvb2x0aXBcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBudWxsO1xuICAgICAgICBUb29sdGlwQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvb2x0aXAgaHRtbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnkgY2F0ZWdvcnlcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7dmFsdWU6IHN0cmluZywgbGVnZW5kOiBzdHJpbmcsIGNoYXJ0VHlwZTogc3RyaW5nLCBzdWZmaXg6ID9zdHJpbmd9Pn0gaXRlbXMgaXRlbXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvb2x0aXAgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwSHRtbDogZnVuY3Rpb24oY2F0ZWdvcnksIGl0ZW1zKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRvb2x0aXBUZW1wbGF0ZS50cGxHcm91cEl0ZW0sXG4gICAgICAgICAgICBjc3NUZXh0VGVtcGxhdGUgPSB0b29sdGlwVGVtcGxhdGUudHBsR3JvdXBDc3NUZXh0LFxuICAgICAgICAgICAgY29sb3JzID0gdGhpcy5fbWFrZUNvbG9ycyh0aGlzLnRoZW1lKSxcbiAgICAgICAgICAgIGl0ZW1zSHRtbCA9IHR1aS51dGlsLm1hcChpdGVtcywgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUodHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dDogY3NzVGV4dFRlbXBsYXRlKHtjb2xvcjogY29sb3JzW2luZGV4XX0pXG4gICAgICAgICAgICAgICAgfSwgaXRlbSkpO1xuICAgICAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRvb2x0aXBUZW1wbGF0ZS50cGxHcm91cCh7XG4gICAgICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcnksXG4gICAgICAgICAgICBpdGVtczogaXRlbXNIdG1sXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGVmYXVsdCBhbGlnbiBvcHRpb24gb2YgdG9vbHRpcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZXREZWZhdWx0VG9vbHRpcFBvc2l0aW9uT3B0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGlnbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFsaWduID0gY2hhcnRDb25zdC5UT09MVElQX0RFRkFVTFRfR1JPVVBfQUxJR05fT1BUSU9OO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFsaWduID0gY2hhcnRDb25zdC5UT09MVElQX0RFRkFVTFRfR1JPVVBfSE9SSVpPTlRBTF9BTElHTl9PUFRJT047XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRvb2x0aXAgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdG9vbHRpcCBlbGVtZW50XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsID0gVG9vbHRpcEJhc2UucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpLFxuICAgICAgICAgICAgY2hhcnREaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignY2hhcnQnKSxcbiAgICAgICAgICAgIGJvdW5kID0gdGhpcy5ib3VuZHNNYWtlci5nZXRCb3VuZCgndG9vbHRpcCcpO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbCA9IG5ldyBHcm91cFRvb2x0aXBQb3NpdGlvbk1vZGVsKGNoYXJ0RGltZW5zaW9uLCBib3VuZCwgdGhpcy5pc1ZlcnRpY2FsLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVyZW5kZXIuXG4gICAgICogQHBhcmFtIHt7Y2hlY2tlZExlZ2VuZHM6IEFycmF5Ljxib29sZWFuPn19IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZXJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBUb29sdGlwQmFzZS5wcm90b3R5cGUucmVyZW5kZXIuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBudWxsO1xuXG4gICAgICAgIGlmIChkYXRhLmNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgICAgICB0aGlzLnRoZW1lID0gdGhpcy5fdXBkYXRlTGVnZW5kVGhlbWUoZGF0YS5jaGVja2VkTGVnZW5kcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbS5cbiAgICAgKi9cbiAgICB6b29tOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBudWxsO1xuICAgICAgICBUb29sdGlwQmFzZS5wcm90b3R5cGUuem9vbS5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbGVnZW5kIHRoZW1lLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgQXJyYXkuPGJvb2xlYW4+fWNoZWNrZWRMZWdlbmRzIGNoZWNrZWQgbGVnZW5kc1xuICAgICAqIEByZXR1cm5zIHt7Y29sb3JzOiBBcnJheS48c3RyaW5nPn19IGxlZ2VuZCB0aGVtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUxlZ2VuZFRoZW1lOiBmdW5jdGlvbihjaGVja2VkTGVnZW5kcykge1xuICAgICAgICB2YXIgY29sb3JzID0gW107XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRPcmlnaW5hbExlZ2VuZERhdGEoKSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIF9jaGVja2VkTGVnZW5kcyA9IGNoZWNrZWRMZWdlbmRzW2l0ZW0uY2hhcnRUeXBlXSB8fCBjaGVja2VkTGVnZW5kcztcbiAgICAgICAgICAgIGlmIChfY2hlY2tlZExlZ2VuZHNbaXRlbS5pbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChpdGVtLnRoZW1lLmNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbG9yczogY29sb3JzXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gdG9vbHRpcCBkYXRhXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRTZXJpZXNHcm91cHMoKSwgZnVuY3Rpb24oc2VyaWVzR3JvdXAsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBzZWxmLmRhdGFQcm9jZXNzb3IuZ2V0Q2F0ZWdvcnkoaW5kZXgpLFxuICAgICAgICAgICAgICAgIHZhbHVlczogc2VyaWVzR3JvdXAucGx1Y2soJ2xhYmVsJylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNvbG9ycy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgdG9vbHRpcCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gY29sb3JzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNvbG9yczogZnVuY3Rpb24odGhlbWUpIHtcbiAgICAgICAgdmFyIGNvbG9ySW5kZXggPSAwLFxuICAgICAgICAgICAgbGVnZW5kTGFiZWxzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldExlZ2VuZERhdGEoKSxcbiAgICAgICAgICAgIGRlZmF1bHRDb2xvcnMsIGNvbG9ycywgcHJldkNoYXJ0VHlwZTtcblxuICAgICAgICBpZiAodGhlbWUuY29sb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhlbWUuY29sb3JzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdENvbG9ycyA9IGRlZmF1bHRUaGVtZS5zZXJpZXMuY29sb3JzLnNsaWNlKDAsIGxlZ2VuZExhYmVscy5sZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodHVpLnV0aWwucGx1Y2sobGVnZW5kTGFiZWxzLCAnY2hhcnRUeXBlJyksIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIGNvbG9yO1xuXG4gICAgICAgICAgICBpZiAocHJldkNoYXJ0VHlwZSAhPT0gY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzID0gdGhlbWVbY2hhcnRUeXBlXSA/IHRoZW1lW2NoYXJ0VHlwZV0uY29sb3JzIDogZGVmYXVsdENvbG9ycztcbiAgICAgICAgICAgICAgICBjb2xvckluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldkNoYXJ0VHlwZSA9IGNoYXJ0VHlwZTtcbiAgICAgICAgICAgIGNvbG9yID0gY29sb3JzW2NvbG9ySW5kZXhdO1xuICAgICAgICAgICAgY29sb3JJbmRleCArPSAxO1xuXG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJlbmRlcmluZyBkYXRhIGFib3V0IGxlZ2VuZCBpdGVtLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHZhbHVlcyB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHt2YWx1ZTogc3RyaW5nLCBsZWdlbmQ6IHN0cmluZywgY2hhcnRUeXBlOiBzdHJpbmcsIHN1ZmZpeDogP3N0cmluZ30+fSBsZWdlbmQgaXRlbSBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VJdGVtUmVuZGVyaW5nRGF0YTogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhUHJvY2Vzc29yID0gdGhpcy5kYXRhUHJvY2Vzc29yLFxuICAgICAgICAgICAgc3VmZml4ID0gdGhpcy5zdWZmaXg7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGxlZ2VuZExhYmVsID0gZGF0YVByb2Nlc3Nvci5nZXRMZWdlbmRJdGVtKGluZGV4KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgbGVnZW5kOiBsZWdlbmRMYWJlbC5sYWJlbCxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGxlZ2VuZExhYmVsLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IHN1ZmZpeFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJbmRleCBncm91cCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvb2x0aXAgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VHcm91cFRvb2x0aXBIdG1sOiBmdW5jdGlvbihncm91cEluZGV4KSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhW2dyb3VwSW5kZXhdLFxuICAgICAgICAgICAgaXRlbXMgPSB0aGlzLl9tYWtlSXRlbVJlbmRlcmluZ0RhdGEoZGF0YS52YWx1ZXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlRnVuYyhkYXRhLmNhdGVnb3J5LCBpdGVtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0b29sdGlwIHNlY3RvciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gc2VjdG9yIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRUb29sdGlwU2VjdG9yRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncm91cFRvb2x0aXBTZWN0b3I7XG5cbiAgICAgICAgaWYgKCF0aGlzLmdyb3VwVG9vbHRpcFNlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5ncm91cFRvb2x0aXBTZWN0b3IgPSBncm91cFRvb2x0aXBTZWN0b3IgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LWdyb3VwLXRvb2x0aXAtc2VjdG9yJyk7XG4gICAgICAgICAgICBkb20uYXBwZW5kKHRoaXMudG9vbHRpcENvbnRhaW5lciwgZ3JvdXBUb29sdGlwU2VjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwVG9vbHRpcFNlY3RvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZCBhYm91dCB0b29sdGlwIHNlY3RvciBvZiB2ZXJ0aWNhbCB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaGVpZ2h0XG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMaW5lIHdoZXRoZXIgbGluZSBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsVG9vbHRpcFNlY3RvckJvdW5kOiBmdW5jdGlvbihoZWlnaHQsIHJhbmdlLCBpc0xpbmUpIHtcbiAgICAgICAgdmFyIHdpZHRoO1xuXG4gICAgICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgICAgIHdpZHRoID0gMTtcbiAgICAgICAgICAgIGhlaWdodCArPSA2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2lkdGggPSByYW5nZS5lbmQgLSByYW5nZS5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaW1lbnNpb246IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHJhbmdlLnN0YXJ0ICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICAgICAgdG9wOiBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kIGFib3V0IHRvb2x0aXAgc2VjdG9yIG9mIGhvcml6b250YWwgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggd2lkdGhcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcmV0dXJucyB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUhvcml6b250YWxUb29sdGlwU2VjdG9yQm91bmQ6IGZ1bmN0aW9uKHdpZHRoLCByYW5nZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGltZW5zaW9uOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgICAgIHRvcDogcmFuZ2Uuc3RhcnQgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kIGFib3V0IHRvb2x0aXAgc2VjdG9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHdpZHRoIG9yIGhlaWdodFxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDpudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMaW5lIHdoZXRoZXIgbGluZSB0eXBlIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcFNlY3RvckJvdW5kOiBmdW5jdGlvbihzaXplLCByYW5nZSwgaXNWZXJ0aWNhbCwgaXNMaW5lKSB7XG4gICAgICAgIHZhciBib3VuZDtcblxuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlVmVydGljYWxUb29sdGlwU2VjdG9yQm91bmQoc2l6ZSwgcmFuZ2UsIGlzTGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3VuZCA9IHRoaXMuX21ha2VIb3Jpem9udGFsVG9vbHRpcFNlY3RvckJvdW5kKHNpemUsIHJhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwIHNlY3Rvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB3aWR0aCBvciBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01vdmluZ10gd2hldGhlciBtb3Zpbmcgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd1Rvb2x0aXBTZWN0b3I6IGZ1bmN0aW9uKHNpemUsIHJhbmdlLCBpc1ZlcnRpY2FsLCBpbmRleCwgaXNNb3ZpbmcpIHtcbiAgICAgICAgdmFyIGdyb3VwVG9vbHRpcFNlY3RvciA9IHRoaXMuX2dldFRvb2x0aXBTZWN0b3JFbGVtZW50KCksXG4gICAgICAgICAgICBpc0xpbmUgPSAocmFuZ2Uuc3RhcnQgPT09IHJhbmdlLmVuZCksXG4gICAgICAgICAgICBib3VuZCA9IHRoaXMuX21ha2VUb29sdGlwU2VjdG9yQm91bmQoc2l6ZSwgcmFuZ2UsIGlzVmVydGljYWwsIGlzTGluZSk7XG5cbiAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdzaG93R3JvdXBUb29sdGlwTGluZScsIGJvdW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKGdyb3VwVG9vbHRpcFNlY3RvciwgYm91bmQuZGltZW5zaW9uKTtcbiAgICAgICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24oZ3JvdXBUb29sdGlwU2VjdG9yLCBib3VuZC5wb3NpdGlvbik7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3MoZ3JvdXBUb29sdGlwU2VjdG9yLCAnc2hvdycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW92aW5nKSB7XG4gICAgICAgICAgICBpbmRleCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCdzaG93R3JvdXBBbmltYXRpb24nLCBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgdG9vbHRpcCBzZWN0b3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlkZVRvb2x0aXBTZWN0b3I6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBncm91cFRvb2x0aXBTZWN0b3IgPSB0aGlzLl9nZXRUb29sdGlwU2VjdG9yRWxlbWVudCgpO1xuXG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhncm91cFRvb2x0aXBTZWN0b3IsICdzaG93Jyk7XG4gICAgICAgIHRoaXMuZmlyZSgnaGlkZUdyb3VwQW5pbWF0aW9uJywgaW5kZXgpO1xuICAgICAgICB0aGlzLmZpcmUoJ2hpZGVHcm91cFRvb2x0aXBMaW5lJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRvb2x0aXAgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7aW5kZXg6IG51bWJlciwgcmFuZ2U6IHtzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn0sXG4gICAgICogICAgICAgICAgc2l6ZTogbnVtYmVyLCBkaXJlY3Rpb246IHN0cmluZywgaXNWZXJ0aWNhbDogYm9vbGVhblxuICAgICAqICAgICAgICB9fSBwYXJhbXMgY29vcmRpbmF0ZSBldmVudCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHByZXZQb3NpdGlvbiBwcmV2IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKGVsVG9vbHRpcCwgcGFyYW1zLCBwcmV2UG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiwgcG9zaXRpb247XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc051bGwodGhpcy5wcmV2SW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2hpZGVHcm91cEFuaW1hdGlvbicsIHRoaXMucHJldkluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsVG9vbHRpcC5pbm5lckhUTUwgPSB0aGlzLl9tYWtlR3JvdXBUb29sdGlwSHRtbChwYXJhbXMuaW5kZXgpO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVCZWZvcmVTaG93VG9vbHRpcChwYXJhbXMuaW5kZXgsIHBhcmFtcy5yYW5nZSk7XG5cbiAgICAgICAgZG9tLmFkZENsYXNzKGVsVG9vbHRpcCwgJ3Nob3cnKTtcblxuICAgICAgICB0aGlzLl9zaG93VG9vbHRpcFNlY3RvcihwYXJhbXMuc2l6ZSwgcGFyYW1zLnJhbmdlLCBwYXJhbXMuaXNWZXJ0aWNhbCwgcGFyYW1zLmluZGV4LCBwYXJhbXMuaXNNb3ZpbmcpO1xuXG4gICAgICAgIGRpbWVuc2lvbiA9IHRoaXMuZ2V0VG9vbHRpcERpbWVuc2lvbihlbFRvb2x0aXApO1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb25Nb2RlbC5jYWxjdWxhdGVQb3NpdGlvbihkaW1lbnNpb24sIHBhcmFtcy5yYW5nZSk7XG5cbiAgICAgICAgdGhpcy5fbW92ZVRvUG9zaXRpb24oZWxUb29sdGlwLCBwb3NpdGlvbiwgcHJldlBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLl9maXJlQWZ0ZXJTaG93VG9vbHRpcChwYXJhbXMuaW5kZXgsIHBhcmFtcy5yYW5nZSwge1xuICAgICAgICAgICAgZWxlbWVudDogZWxUb29sdGlwLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucHJldkluZGV4ID0gcGFyYW1zLmluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIGJlZm9yZVNob3dUb29sdGlwIGNhbGxiYWNrIG9mIHVzZXJFdmVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUJlZm9yZVNob3dUb29sdGlwOiBmdW5jdGlvbihpbmRleCwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnYmVmb3JlU2hvd1Rvb2x0aXAnLCB7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgYWZ0ZXJTaG93VG9vbHRpcCBjYWxsYmFjayBvZiB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhZGRpdGlvblBhcmFtcyBhZGRpdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUFmdGVyU2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKGluZGV4LCByYW5nZSwgYWRkaXRpb25QYXJhbXMpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnYWZ0ZXJTaG93VG9vbHRpcCcsIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgICAgfSwgYWRkaXRpb25QYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVG9vbHRpcCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlVG9vbHRpcDogZnVuY3Rpb24oZWxUb29sdGlwLCBpbmRleCkge1xuICAgICAgICB0aGlzLnByZXZJbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hpZGVUb29sdGlwU2VjdG9yKGluZGV4KTtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGVsVG9vbHRpcCwgJ3Nob3cnKTtcbiAgICAgICAgZWxUb29sdGlwLnN0eWxlLmNzc1RleHQgPSAnJztcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cFRvb2x0aXA7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCBpcyBwb3NpdGlvbiBtb2RlbCBmb3IgZ3JvdXAgdG9vbHRpcC4uXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEdyb3VwVG9vbHRpcFBvc2l0aW9uTW9kZWwgaXMgcG9zaXRpb24gbW9kZWwgZm9yIGdyb3VwIHRvb2x0aXAuXG4gICAgICogQGNvbnN0cnVjdHMgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbFxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gY2hhcnREaW1lbnNpb24gY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYXJlYUJvdW5kIHRvb2x0aXAgYXJlYSBib3VuZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7e2FsaWduOiA/c3RyaW5nLCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gb3B0aW9ucyB0b29sdGlwIG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihjaGFydERpbWVuc2lvbiwgYXJlYUJvdW5kLCBpc1ZlcnRpY2FsLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCBkaW1lbnNpb25cbiAgICAgICAgICogQHR5cGUge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0RGltZW5zaW9uID0gY2hhcnREaW1lbnNpb247XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvb2x0aXAgYXJlYSBib3VuZFxuICAgICAgICAgKiBAdHlwZSB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFyZWFCb3VuZCA9IGFyZWFCb3VuZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVmVydGljYWwgPSBpc1ZlcnRpY2FsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b29sdGlwIG9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge3thbGlnbjogP3N0cmluZywgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgY2FjaGluZ1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSB7fTtcblxuICAgICAgICB0aGlzLl9zZXREYXRhKGNoYXJ0RGltZW5zaW9uLCBhcmVhQm91bmQsIGlzVmVydGljYWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgaG9yaXpvbnRhbCBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBhbGlnbk9wdGlvbiBhbGlnbiBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRIb3Jpem9udGFsRGlyZWN0aW9uOiBmdW5jdGlvbihhbGlnbk9wdGlvbikge1xuICAgICAgICB2YXIgZGlyZWN0aW9uO1xuXG4gICAgICAgIGFsaWduT3B0aW9uID0gYWxpZ25PcHRpb24gfHwgJyc7XG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdsZWZ0JykgPiAtMSkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9CQUNLV0FSRDtcbiAgICAgICAgfSBlbHNlIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdjZW50ZXInKSA+IC0xKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0NFTlRFUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdmVydGljYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGNoYXJ0RGltZW5zaW9uIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IGFyZWFCb3VuZCB0b29sdGlwIGFyZWEgYm91bmRcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IGFsaWduT3B0aW9uIGFsaWduIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBwb3NpdGlvblR5cGU6IHN0cmluZywgc2l6ZVR5cGU6IHN0cmluZywgZGlyZWN0aW9uOiAoc3RyaW5nKSxcbiAgICAgKiAgICAgIGFyZWFQb3NpdGlvbjogbnVtYmVyLCBhcmVhU2l6ZTogbnVtYmVyLCBjaGFydFNpemU6IG51bWJlcixcbiAgICAgKiAgICAgIGJhc2VQb3NpdGlvbjogKG51bWJlcilcbiAgICAgKiB9fSB2ZXJ0aWNhbCBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsRGF0YTogZnVuY3Rpb24oY2hhcnREaW1lbnNpb24sIGFyZWFCb3VuZCwgYWxpZ25PcHRpb24pIHtcbiAgICAgICAgdmFyIGhEaXJlY3Rpb24gPSB0aGlzLl9nZXRIb3Jpem9udGFsRGlyZWN0aW9uKGFsaWduT3B0aW9uKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb25UeXBlOiAnbGVmdCcsXG4gICAgICAgICAgICBzaXplVHlwZTogJ3dpZHRoJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogaERpcmVjdGlvbixcbiAgICAgICAgICAgIGFyZWFQb3NpdGlvbjogYXJlYUJvdW5kLnBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICBhcmVhU2l6ZTogYXJlYUJvdW5kLmRpbWVuc2lvbi53aWR0aCxcbiAgICAgICAgICAgIGNoYXJ0U2l6ZTogY2hhcnREaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBiYXNlUG9zaXRpb246IGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB2ZXJ0aWNhbCBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBhbGlnbk9wdGlvbiBhbGlnbiBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRWZXJ0aWNhbERpcmVjdGlvbjogZnVuY3Rpb24oYWxpZ25PcHRpb24pIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbjtcblxuICAgICAgICBhbGlnbk9wdGlvbiA9IGFsaWduT3B0aW9uIHx8ICcnO1xuXG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCd0b3AnKSA+IC0xKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJEO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ2JvdHRvbScpID4gLTEpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fQ0VOVEVSO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBob3Jpem9udGFsIGRhdGEuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBjaGFydERpbWVuc2lvbiBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBhcmVhQm91bmQgdG9vbHRpcCBhcmVhIGJvdW5kXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBhbGlnbk9wdGlvbiBhbGlnbiBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgcG9zaXRpb25UeXBlOiBzdHJpbmcsIHNpemVUeXBlOiBzdHJpbmcsIGRpcmVjdGlvbjogKHN0cmluZyksXG4gICAgICogICAgICBhcmVhUG9zaXRpb246IG51bWJlciwgYXJlYVNpemU6IG51bWJlciwgY2hhcnRTaXplOiBudW1iZXIsXG4gICAgICogICAgICBiYXNlUG9zaXRpb246IChudW1iZXIpXG4gICAgICogfX0gaG9yaXpvbnRhbCBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUhvcml6b250YWxEYXRhOiBmdW5jdGlvbihjaGFydERpbWVuc2lvbiwgYXJlYUJvdW5kLCBhbGlnbk9wdGlvbikge1xuICAgICAgICB2YXIgdkRpcmVjdGlvbiA9IHRoaXMuX2dldFZlcnRpY2FsRGlyZWN0aW9uKGFsaWduT3B0aW9uKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb25UeXBlOiAndG9wJyxcbiAgICAgICAgICAgIHNpemVUeXBlOiAnaGVpZ2h0JyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdkRpcmVjdGlvbixcbiAgICAgICAgICAgIGFyZWFQb3NpdGlvbjogYXJlYUJvdW5kLnBvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGFyZWFTaXplOiBhcmVhQm91bmQuZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGNoYXJ0U2l6ZTogY2hhcnREaW1lbnNpb24uaGVpZ2h0LFxuICAgICAgICAgICAgYmFzZVBvc2l0aW9uOiBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGNoYXJ0RGltZW5zaW9uIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IGFyZWFCb3VuZCB0b29sdGlwIGFyZWEgYm91bmRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcGFyYW0ge3thbGlnbjogP3N0cmluZywgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IG9wdGlvbnMgdG9vbHRpcCBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0RGF0YTogZnVuY3Rpb24oY2hhcnREaW1lbnNpb24sIGFyZWFCb3VuZCwgaXNWZXJ0aWNhbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdmVydGljYWxEYXRhID0gdGhpcy5fbWFrZVZlcnRpY2FsRGF0YShjaGFydERpbWVuc2lvbiwgYXJlYUJvdW5kLCBvcHRpb25zLmFsaWduKSxcbiAgICAgICAgICAgIGhvcml6b250YWxEYXRhID0gdGhpcy5fbWFrZUhvcml6b250YWxEYXRhKGNoYXJ0RGltZW5zaW9uLCBhcmVhQm91bmQsIG9wdGlvbnMuYWxpZ24pO1xuXG4gICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLm1haW5EYXRhID0gdmVydGljYWxEYXRhO1xuICAgICAgICAgICAgdGhpcy5zdWJEYXRhID0gaG9yaXpvbnRhbERhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW5EYXRhID0gaG9yaXpvbnRhbERhdGE7XG4gICAgICAgICAgICB0aGlzLnN1YkRhdGEgPSB2ZXJ0aWNhbERhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvc2l0aW9uT3B0aW9uID0gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgfSwgb3B0aW9ucy5wb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIG1haW4gcG9zaXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvb2x0aXBTaXplIHRvb2x0aXAgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gZGF0YS5kaXJlY3Rpb24gZGlyZWN0aW9uXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5iYXNlUG9zaXRpb24gYmFzZVBvc2l0aW9uXG4gICAgICogQHJldHVybnMge251bWJlcn0gcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVNYWluUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odG9vbHRpcFNpemUsIHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIHZhciBpc0xpbmUgPSAocmFuZ2Uuc3RhcnQgPT09IHJhbmdlLmVuZCksXG4gICAgICAgICAgICBsaW5lVHlwZVBhZGRpbmcgPSA5LFxuICAgICAgICAgICAgb3RoZXJUeXBlUGFkZGluZyA9IDUsXG4gICAgICAgICAgICBwYWRkaW5nID0gaXNMaW5lID8gbGluZVR5cGVQYWRkaW5nIDogb3RoZXJUeXBlUGFkZGluZyxcbiAgICAgICAgICAgIHZhbHVlID0gZGF0YS5iYXNlUG9zaXRpb247XG5cbiAgICAgICAgaWYgKGRhdGEuZGlyZWN0aW9uID09PSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0ZPUldBUkQpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHJhbmdlLmVuZCArIHBhZGRpbmc7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5kaXJlY3Rpb24gPT09IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fQkFDS1dBUkQpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHJhbmdlLnN0YXJ0IC0gdG9vbHRpcFNpemUgLSBwYWRkaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgdmFsdWUgKz0gcmFuZ2Uuc3RhcnQgLSB0b29sdGlwU2l6ZSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSArPSByYW5nZS5zdGFydCArICgocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQgLSB0b29sdGlwU2l6ZSkgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHN1YiBwb3NpdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYXJlYVNpemUgdG9vbHRpcCBhcmVhIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLmRpcmVjdGlvbiBkaXJlY3Rpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmJhc2VQb3NpdGlvbiBiYXNlUG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVN1YlBvc2l0aW9uVmFsdWU6IGZ1bmN0aW9uKHRvb2x0aXBTaXplLCBkYXRhKSB7XG4gICAgICAgIHZhciBtaWRkbGUgPSBkYXRhLmFyZWFTaXplIC8gMixcbiAgICAgICAgICAgIHZhbHVlO1xuXG4gICAgICAgIGlmIChkYXRhLmRpcmVjdGlvbiA9PT0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9GT1JXQVJEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1pZGRsZSArIGRhdGEuYmFzZVBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuZGlyZWN0aW9uID09PSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1pZGRsZSAtIHRvb2x0aXBTaXplICsgZGF0YS5iYXNlUG9zaXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1pZGRsZSAtICh0b29sdGlwU2l6ZSAvIDIpICsgZGF0YS5iYXNlUG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcG9zaXRpb24gdmFsdWUgZGlmZi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgcG9zaXRvaW4gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuY2hhcnRTaXplIGNoYXJ0IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFyZWFQb3NpdGlvbiB0b29sdGlwIGFyZWEgcG9zaXRpb24gKGxlZnQgb3IgdG9wKVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGRpZmZcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUG9zaXRpb25WYWx1ZURpZmY6IGZ1bmN0aW9uKHZhbHVlLCB0b29sdGlwU2l6ZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgKyBkYXRhLmFyZWFQb3NpdGlvbiArIHRvb2x0aXBTaXplIC0gZGF0YS5jaGFydFNpemU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBiYWNrd2FyZCBwb3NpdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvb2x0aXBTaXplIHRvb2x0aXAgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmNoYXJ0U2l6ZSBjaGFydCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5hcmVhUG9zaXRpb24gdG9vbHRpcCBhcmVhIHBvc2l0aW9uIChsZWZ0IG9yIHRvcClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmJhc2VQb3NpdGlvbiBiYXNlUG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkanVzdEJhY2t3YXJkUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odmFsdWUsIHJhbmdlLCB0b29sdGlwU2l6ZSwgZGF0YSkge1xuICAgICAgICB2YXIgY2hhbmdlZFZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSA8IC1kYXRhLmFyZWFQb3NpdGlvbikge1xuICAgICAgICAgICAgY2hhbmdlZFZhbHVlID0gdGhpcy5fY2FsY3VsYXRlTWFpblBvc2l0aW9uVmFsdWUodG9vbHRpcFNpemUsIHJhbmdlLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0ZPUldBUkQsXG4gICAgICAgICAgICAgICAgYmFzZVBvc2l0aW9uOiBkYXRhLmJhc2VQb3NpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWFrZVBvc2l0aW9uVmFsdWVEaWZmKGNoYW5nZWRWYWx1ZSwgdG9vbHRpcFNpemUsIGRhdGEpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gLWRhdGEuYXJlYVBvc2l0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYW5nZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IGZvcndhcmQgcG9zaXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b29sdGlwU2l6ZSB0b29sdGlwIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5jaGFydFNpemUgY2hhcnQgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYXJlYVBvc2l0aW9uIHRvb2x0aXAgYXJlYSBwb3NpdGlvbiAobGVmdCBvciB0b3ApXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5iYXNlUG9zaXRpb24gYmFzZVBvc2l0aW9uXG4gICAgICogQHJldHVybnMge251bWJlcn0gcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGp1c3RGb3J3YXJkUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odmFsdWUsIHJhbmdlLCB0b29sdGlwU2l6ZSwgZGF0YSkge1xuICAgICAgICB2YXIgZGlmZiA9IHRoaXMuX21ha2VQb3NpdGlvblZhbHVlRGlmZih2YWx1ZSwgdG9vbHRpcFNpemUsIGRhdGEpLFxuICAgICAgICAgICAgY2hhbmdlZFZhbHVlO1xuXG4gICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgY2hhbmdlZFZhbHVlID0gdGhpcy5fY2FsY3VsYXRlTWFpblBvc2l0aW9uVmFsdWUodG9vbHRpcFNpemUsIHJhbmdlLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJELFxuICAgICAgICAgICAgICAgIGJhc2VQb3NpdGlvbjogZGF0YS5iYXNlUG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRWYWx1ZSA8IC1kYXRhLmFyZWFQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhbHVlIC09IGRpZmY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhbmdlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgbWFpbiBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuY2hhcnRTaXplIGNoYXJ0IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFyZWFQb3NpdGlvbiB0b29sdGlwIGFyZWEgcG9zaXRpb24gKGxlZnQgb3IgdG9wKVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRqdXN0TWFpblBvc2l0aW9uVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCByYW5nZSwgdG9vbHRpcFNpemUsIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuZGlyZWN0aW9uID09PSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkanVzdEJhY2t3YXJkUG9zaXRpb25WYWx1ZSh2YWx1ZSwgcmFuZ2UsIHRvb2x0aXBTaXplLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmRpcmVjdGlvbiA9PT0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9GT1JXQVJEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkanVzdEZvcndhcmRQb3NpdGlvblZhbHVlKHZhbHVlLCByYW5nZSwgdG9vbHRpcFNpemUsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heCh2YWx1ZSwgLWRhdGEuYXJlYVBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5taW4odmFsdWUsIGRhdGEuY2hhcnRTaXplIC0gZGF0YS5hcmVhUG9zaXRpb24gLSB0b29sdGlwU2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBzdWIgcG9zaXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvb2x0aXBTaXplIHRvb2x0aXAgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmNoYXJ0U2l6ZSBjaGFydCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5hcmVhUG9zaXRpb24gdG9vbHRpcCBhcmVhIHBvc2l0aW9uIChsZWZ0IG9yIHRvcClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmJhc2VQb3NpdGlvbiBiYXNlUG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkanVzdFN1YlBvc2l0aW9uVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCB0b29sdGlwU2l6ZSwgZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5kaXJlY3Rpb24gPT09IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRCkge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbih2YWx1ZSwgZGF0YS5jaGFydFNpemUgLSBkYXRhLmFyZWFQb3NpdGlvbiAtIHRvb2x0aXBTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5tYXgodmFsdWUsIC1kYXRhLmFyZWFQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY2FjaGluZyBrZXkuXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGtleVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDYWNoaW5nS2V5OiBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnQgKyAnLScgKyByYW5nZS5lbmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBwb3NpdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uVHlwZSBwb3NpdGlvbiB0eXBlIChsZWZ0IG9yIHRvcClcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZFBvc2l0aW9uT3B0aW9uVmFsdWU6IGZ1bmN0aW9uKHBvc2l0aW9uLCBwb3NpdGlvblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uICsgdGhpcy5wb3NpdGlvbk9wdGlvbltwb3NpdGlvblR5cGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG1haW4gcG9zaXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSB0b29sdGlwRGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSB0b29sdGlwIHNlY3RvciByYW5nZVxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgcG9zaXRpb25UeXBlOiBzdHJpbmcsIHNpemVUeXBlOiBzdHJpbmcsIGRpcmVjdGlvbjogKHN0cmluZyksXG4gICAgICogICAgICBhcmVhUG9zaXRpb246IG51bWJlciwgYXJlYVNpemU6IG51bWJlciwgY2hhcnRTaXplOiBudW1iZXIsXG4gICAgICogICAgICBiYXNlUG9zaXRpb246IChudW1iZXIpXG4gICAgICogfX0gbWFpbiBtYWluIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VNYWluUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odG9vbHRpcERpbWVuc2lvbiwgcmFuZ2UsIG1haW4pIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gdGhpcy5fY2FsY3VsYXRlTWFpblBvc2l0aW9uVmFsdWUodG9vbHRpcERpbWVuc2lvblttYWluLnNpemVUeXBlXSwgcmFuZ2UsIG1haW4pO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkZFBvc2l0aW9uT3B0aW9uVmFsdWUodmFsdWUsIG1haW4ucG9zaXRpb25UeXBlKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9hZGp1c3RNYWluUG9zaXRpb25WYWx1ZSh2YWx1ZSwgcmFuZ2UsIHRvb2x0aXBEaW1lbnNpb25bbWFpbi5zaXplVHlwZV0sIG1haW4pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdWIgcG9zaXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSB0b29sdGlwRGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBwb3NpdGlvblR5cGU6IHN0cmluZywgc2l6ZVR5cGU6IHN0cmluZywgZGlyZWN0aW9uOiAoc3RyaW5nKSxcbiAgICAgKiAgICAgIGFyZWFQb3NpdGlvbjogbnVtYmVyLCBhcmVhU2l6ZTogbnVtYmVyLCBjaGFydFNpemU6IG51bWJlcixcbiAgICAgKiAgICAgIGJhc2VQb3NpdGlvbjogKG51bWJlcilcbiAgICAgKiB9fSBzdWIgc3ViIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTdWJQb3NpdGlvblZhbHVlOiBmdW5jdGlvbih0b29sdGlwRGltZW5zaW9uLCBzdWIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gdGhpcy5fY2FsY3VsYXRlU3ViUG9zaXRpb25WYWx1ZSh0b29sdGlwRGltZW5zaW9uW3N1Yi5zaXplVHlwZV0sIHN1Yik7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fYWRkUG9zaXRpb25PcHRpb25WYWx1ZSh2YWx1ZSwgc3ViLnBvc2l0aW9uVHlwZSk7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fYWRqdXN0U3ViUG9zaXRpb25WYWx1ZSh2YWx1ZSwgdG9vbHRpcERpbWVuc2lvbltzdWIuc2l6ZVR5cGVdLCBzdWIpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGdyb3VwIHRvb2x0aXAgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSB0b29sdGlwRGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSB0b29sdGlwIHNlY3RvciByYW5nZVxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGdyb3VwIHRvb2x0aXAgcG9zaXRpb25cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVQb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcERpbWVuc2lvbiwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX21ha2VDYWNoaW5nS2V5KHJhbmdlKSxcbiAgICAgICAgICAgIG1haW4gPSB0aGlzLm1haW5EYXRhLFxuICAgICAgICAgICAgc3ViID0gdGhpcy5zdWJEYXRhLFxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uc1trZXldO1xuXG4gICAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0ge307XG4gICAgICAgICAgICBwb3NpdGlvblttYWluLnBvc2l0aW9uVHlwZV0gPSB0aGlzLl9tYWtlTWFpblBvc2l0aW9uVmFsdWUodG9vbHRpcERpbWVuc2lvbiwgcmFuZ2UsIG1haW4pO1xuICAgICAgICAgICAgcG9zaXRpb25bc3ViLnBvc2l0aW9uVHlwZV0gPSB0aGlzLl9tYWtlU3ViUG9zaXRpb25WYWx1ZSh0b29sdGlwRGltZW5zaW9uLCBzdWIpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnNba2V5XSA9IHBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdG9vbHRpcCBvcHRpb25zIGZvciBwb3NpdGlvbiBjYWxjdWxhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3thbGlnbjogP3N0cmluZywgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IG9wdGlvbnMgdG9vbHRpcCBvcHRpb25zXG4gICAgICovXG4gICAgdXBkYXRlT3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9zZXREYXRhKHRoaXMuY2hhcnREaW1lbnNpb24sIHRoaXMuYXJlYUJvdW5kLCB0aGlzLmlzVmVydGljYWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdG9vbHRpcCBib3VuZCBmb3IgcG9zaXRpb24gY2FsY3VsYXRpb24uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYm91bmQgdG9vbHRpcCBhcmVhIGJvdW5kXG4gICAgICovXG4gICAgdXBkYXRlQm91bmQ6IGZ1bmN0aW9uKGJvdW5kKSB7XG4gICAgICAgIHRoaXMuYXJlYUJvdW5kID0gYm91bmQ7XG4gICAgICAgIHRoaXMuX3NldERhdGEodGhpcy5jaGFydERpbWVuc2lvbiwgYm91bmQsIHRoaXMuaXNWZXJ0aWNhbCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cFRvb2x0aXBQb3NpdGlvbk1vZGVsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRvb2x0aXAgY29tcG9uZW50IGZvciBtYXAgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIFRvb2x0aXBCYXNlID0gcmVxdWlyZSgnLi90b29sdGlwQmFzZScpLFxuICAgIHNpbmdsZVRvb2x0aXBNaXhlciA9IHJlcXVpcmUoJy4vc2luZ2xlVG9vbHRpcE1peGVyJyksXG4gICAgdG9vbHRpcFRlbXBsYXRlID0gcmVxdWlyZSgnLi90b29sdGlwVGVtcGxhdGUnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIE1hcENoYXJ0VG9vbHRpcCBjb21wb25lbnQuXG4gKiBAY2xhc3MgTWFwQ2hhcnRUb29sdGlwXG4gKi9cbnZhciBNYXBDaGFydFRvb2x0aXAgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhUb29sdGlwQmFzZSwgLyoqIEBsZW5kcyBNYXBDaGFydFRvb2x0aXAucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBNYXAgY2hhcnQgdG9vbHRpcCBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgTWFwQ2hhcnRUb29sdGlwXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgbW9kZWxcbiAgICAgICAgICogQHR5cGUge01hcENoYXJ0TWFwTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcE1vZGVsID0gbnVsbDtcblxuICAgICAgICBUb29sdGlwQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvb2x0aXAgaHRtbC5cbiAgICAgKiBAcGFyYW0ge3tuYW1lOiBzdHJpbmcsIHZhbHVlOiBudW1iZXJ9fSBkYXR1bSB0b29sdGlwIGRhdHVtXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdG9vbHRpcCBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBIdG1sOiBmdW5jdGlvbihkYXR1bSkge1xuICAgICAgICByZXR1cm4gdG9vbHRpcFRlbXBsYXRlLnRwbE1hcENoYXJ0RGVmYXVsdChkYXR1bSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2luZ2xlIHRvb2x0aXAgaHRtbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0b29sdGlwIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2luZ2xlVG9vbHRpcEh0bWw6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgaW5kZXhlcykge1xuICAgICAgICB2YXIgZGF0dW0gPSB0aGlzLm1hcE1vZGVsLmdldERhdHVtKGluZGV4ZXMuaW5kZXgpLFxuICAgICAgICAgICAgc3VmZml4ID0gdGhpcy5vcHRpb25zLnN1ZmZpeCA/ICcgJyArIHRoaXMub3B0aW9ucy5zdWZmaXggOiAnJztcblxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZUZ1bmMoe1xuICAgICAgICAgICAgbmFtZTogZGF0dW0ubmFtZSB8fCBkYXR1bS5jb2RlLFxuICAgICAgICAgICAgdmFsdWU6IGRhdHVtLmxhYmVsLFxuICAgICAgICAgICAgc3VmZml4OiBzdWZmaXhcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcGFyYW1ldGVycyBmb3Igc2hvdyB0b29sdGlwIHVzZXIgZXZlbnQuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFkZGl0aW9uUGFyYW1zIGFkZGl0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB7e2NoYXJ0VHlwZTogc3RyaW5nLCBsZWdlbmQ6IHN0cmluZywgbGVnZW5kSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IHBhcmFtZXRlcnMgZm9yIHNob3cgdG9vbHRpcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTaG93VG9vbHRpcFBhcmFtczogZnVuY3Rpb24oaW5kZXhlcywgYWRkaXRpb25QYXJhbXMpIHtcbiAgICAgICAgdmFyIGRhdHVtID0gdGhpcy5tYXBNb2RlbC5nZXREYXR1bShpbmRleGVzLmluZGV4KSxcbiAgICAgICAgICAgIHBhcmFtcztcblxuICAgICAgICBwYXJhbXMgPSB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIGNvZGU6IGRhdHVtLmNvZGUsXG4gICAgICAgICAgICBuYW1lOiBkYXR1bS5uYW1lLFxuICAgICAgICAgICAgdmFsdWU6IGRhdHVtLmxhYmVsLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4ZXMuaW5kZXhcbiAgICAgICAgfSwgYWRkaXRpb25QYXJhbXMpO1xuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlZmF1bHQgYWxpZ24gb3B0aW9uIG9mIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfc2V0RGVmYXVsdFRvb2x0aXBQb3NpdGlvbk9wdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsaWduKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9BTElHTl9PUFRJT047XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyLlxuICAgICAqIEBwYXJhbSB7e21hcE1vZGVsOiBNYXBDaGFydE1hcE1vZGVsfX0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRvb2x0aXAgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLm1hcE1vZGVsID0gZGF0YS5tYXBNb2RlbDtcblxuICAgICAgICByZXR1cm4gVG9vbHRpcEJhc2UucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgIH1cbn0pO1xuXG5zaW5nbGVUb29sdGlwTWl4ZXIubWl4aW4oTWFwQ2hhcnRUb29sdGlwKTtcbm1vZHVsZS5leHBvcnRzID0gTWFwQ2hhcnRUb29sdGlwO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IHNpbmdsZVRvb2x0aXBNaXhlciBpcyBzaW5nbGUgdG9vbHRpcCBtaXhlciBvZiBtYXAgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG4vKipcbiAqIHNpbmdsZVRvb2x0aXBNaXhlciBpcyBzaW5nbGUgdG9vbHRpcCBtaXhlciBvZiBtYXAgY2hhcnQuXG4gKiBAbWl4aW5cbiAqL1xudmFyIHNpbmdsZVRvb2x0aXBNaXhlciA9IHtcblxuICAgIC8qKlxuICAgICAqIEZpcmUgY3VzdG9tIGV2ZW50IHNob3dBbmltYXRpb24uXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZVNob3dBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4ZXMsIGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gcmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzaG93JywgY2hhcnRUeXBlLCAnYW5pbWF0aW9uJyk7XG5cbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwgaW5kZXhlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmUgY3VzdG9tIGV2ZW50IGhpZGVBbmltYXRpb24uXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUhpZGVBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4ZXMsIGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gcmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdoaWRlJywgY2hhcnRUeXBlLCAnYW5pbWF0aW9uJyk7XG5cbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwgaW5kZXhlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBkYXRhIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6bnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0SW5kZXhlc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24oZWxUb29sdGlwLCBpbmRleGVzKSB7XG4gICAgICAgIGVsVG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXBJbmRleCcsIGluZGV4ZXMuZ3JvdXBJbmRleCk7XG4gICAgICAgIGVsVG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBpbmRleGVzLmluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGRhdGEgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVG9vbHRpcCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRJbmRleGVzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbihlbFRvb2x0aXApIHtcbiAgICAgICAgdmFyIGdyb3VwSW5kZXggPSBlbFRvb2x0aXAuZ2V0QXR0cmlidXRlKCdkYXRhLWdyb3VwSW5kZXgnKTtcbiAgICAgICAgdmFyIGluZGV4ID0gZWxUb29sdGlwLmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpO1xuICAgICAgICB2YXIgaW5kZXhlcyA9IG51bGw7XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc051bGwoZ3JvdXBJbmRleCkgJiYgIXR1aS51dGlsLmlzTnVsbChpbmRleCkpIHtcbiAgICAgICAgICAgIGluZGV4ZXMgPSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBJbmRleDogcGFyc2VJbnQoZ3JvdXBJbmRleCwgMTApLFxuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJzZUludChpbmRleCwgMTApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBzaG93ZWQgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRvb2x0aXAgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGF0dXMgd2hldGhlciBzaG93ZWQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U2hvd2VkQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbihlbFRvb2x0aXAsIHN0YXR1cykge1xuICAgICAgICBlbFRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLXNob3dlZCcsIHN0YXR1cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgc2hvd2VkIHRvb2x0aXAgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVG9vbHRpcCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBzaG93ZWQgdG9vbHRpcCBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1Nob3dlZFRvb2x0aXA6IGZ1bmN0aW9uKGVsVG9vbHRpcCkge1xuICAgICAgICB2YXIgaXNTaG93ZWQgPSBlbFRvb2x0aXAuZ2V0QXR0cmlidXRlKCdkYXRhLXNob3dlZCcpO1xuXG4gICAgICAgIHJldHVybiBpc1Nob3dlZCA9PT0gJ3RydWUnIHx8IGlzU2hvd2VkID09PSB0cnVlOyAvLyBpZTfsl5DshJzripQgYm9vbGVhbu2Yle2DnOydmCB0cnVl66W8IOuwmO2ZmO2VqFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxlZnQgcG9zaXRpb24gb2Ygbm90IGJhciBjaGFydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZUxlZnQgYmFzZSBsZWZ0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWduT3B0aW9uIGFsaWduIG9wdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW51c1dpZHRoIG1pbnVzIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVHYXAgbGluZSBnYXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBsZWZ0IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxlZnRQb3NpdGlvbk9mTm90QmFyQ2hhcnQ6IGZ1bmN0aW9uKGJhc2VMZWZ0LCBhbGlnbk9wdGlvbiwgbWludXNXaWR0aCwgbGluZUdhcCkge1xuICAgICAgICB2YXIgbGVmdCA9IGJhc2VMZWZ0O1xuXG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdsZWZ0JykgPiAtMSkge1xuICAgICAgICAgICAgbGVmdCAtPSBtaW51c1dpZHRoICsgbGluZUdhcDtcbiAgICAgICAgfSBlbHNlIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdjZW50ZXInKSA+IC0xKSB7XG4gICAgICAgICAgICBsZWZ0IC09IG1pbnVzV2lkdGggLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCArPSBsaW5lR2FwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9wIHBvc2l0aW9uIG9mIG5vdCBiYXIgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VUb3AgYmFzZSB0b3BcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ25PcHRpb24gYWxpZ24gb3B0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvb2x0aXBIZWlnaHQgdG9vbHRpcCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZUdhcCBsaW5lIGdhcFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRvcCBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb3BQb3NpdGlvbk9mTm90QmFyQ2hhcnQ6IGZ1bmN0aW9uKGJhc2VUb3AsIGFsaWduT3B0aW9uLCB0b29sdGlwSGVpZ2h0LCBsaW5lR2FwKSB7XG4gICAgICAgIHZhciB0b3AgPSBiYXNlVG9wO1xuXG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdib3R0b20nKSA+IC0xKSB7XG4gICAgICAgICAgICB0b3AgKz0gdG9vbHRpcEhlaWdodCArIGxpbmVHYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignbWlkZGxlJykgPiAtMSkge1xuICAgICAgICAgICAgdG9wICs9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wIC09IGNoYXJ0Q29uc3QuVE9PTFRJUF9HQVA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvb2x0aXAgcG9zaXRpb24gZm9yIG5vdCBiYXIgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tib3VuZDogb2JqZWN0fX0gcGFyYW1zLmRhdGEgZ3JhcGggaW5mb3JtYXRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmRpbWVuc2lvbiB0b29sdGlwIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hbGlnbk9wdGlvbiBwb3NpdGlvbiBvcHRpb24gKGV4OiAnbGVmdCB0b3AnKVxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBQb3NpdGlvbkZvck5vdEJhckNoYXJ0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gcGFyYW1zLmJvdW5kLFxuICAgICAgICAgICAgcG9zaXRpb25PcHRpb24gPSBwYXJhbXMucG9zaXRpb25PcHRpb24sXG4gICAgICAgICAgICBtaW51c1dpZHRoID0gcGFyYW1zLmRpbWVuc2lvbi53aWR0aCAtIChib3VuZC53aWR0aCB8fCAwKSxcbiAgICAgICAgICAgIGxpbmVHYXAgPSBib3VuZC53aWR0aCA/IDAgOiBjaGFydENvbnN0LlRPT0xUSVBfR0FQLFxuICAgICAgICAgICAgYWxpZ25PcHRpb24gPSBwYXJhbXMuYWxpZ25PcHRpb24gfHwgJycsXG4gICAgICAgICAgICB0b29sdGlwSGVpZ2h0ID0gcGFyYW1zLmRpbWVuc2lvbi5oZWlnaHQsXG4gICAgICAgICAgICBiYXNlTGVmdCA9IGJvdW5kLmxlZnQgKyBwb3NpdGlvbk9wdGlvbi5sZWZ0LFxuICAgICAgICAgICAgYmFzZVRvcCA9IGJvdW5kLnRvcCAtIHRvb2x0aXBIZWlnaHQgKyBwb3NpdGlvbk9wdGlvbi50b3A7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMuX21ha2VMZWZ0UG9zaXRpb25PZk5vdEJhckNoYXJ0KGJhc2VMZWZ0LCBhbGlnbk9wdGlvbiwgbWludXNXaWR0aCwgbGluZUdhcCksXG4gICAgICAgICAgICB0b3A6IHRoaXMuX21ha2VUb3BQb3NpdGlvbk9mTm90QmFyQ2hhcnQoYmFzZVRvcCwgYWxpZ25PcHRpb24sIHRvb2x0aXBIZWlnaHQsIGxpbmVHYXApXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBwb3NpdGlvbiB0byBldmVudCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwYXJhbXMuYm91bmQgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwYXJhbXMubW91c2VQb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBQb3NpdGlvblRvTW91c2VQb3NpdGlvbjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcy5ib3VuZCA9IHBhcmFtcy5ib3VuZCB8fCB7fTtcbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKHBhcmFtcy5ib3VuZCwgcGFyYW1zLm1vdXNlUG9zaXRpb24pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYWtlVG9vbHRpcFBvc2l0aW9uRm9yTm90QmFyQ2hhcnQocGFyYW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsZWZ0IHBvc2l0aW9uIGZvciBiYXIgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VMZWZ0IGJhc2UgbGVmdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbk9wdGlvbiBhbGlnbiBvcHRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFdpZHRoIHRvb2x0aXAgd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBsZWZ0IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxlZnRQb3NpdGlvbkZvckJhckNoYXJ0OiBmdW5jdGlvbihiYXNlTGVmdCwgYWxpZ25PcHRpb24sIHRvb2x0aXBXaWR0aCkge1xuICAgICAgICB2YXIgbGVmdCA9IGJhc2VMZWZ0O1xuXG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdsZWZ0JykgPiAtMSkge1xuICAgICAgICAgICAgbGVmdCAtPSB0b29sdGlwV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignY2VudGVyJykgPiAtMSkge1xuICAgICAgICAgICAgbGVmdCAtPSB0b29sdGlwV2lkdGggLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCArPSBjaGFydENvbnN0LlRPT0xUSVBfR0FQO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9wIHBvc2l0aW9uIGZvciBiYXIgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VUb3AgYmFzZSB0b3BcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ25PcHRpb24gYWxpZ24gb3B0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnVzSGVpZ2h0IG1pbnVzIHdpZHRoXG4gICAgICogQHJldHVybnMge251bWJlcn0gdG9wIHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRvcFBvc2l0aW9uRm9yQmFyQ2hhcnQ6IGZ1bmN0aW9uKGJhc2VUb3AsIGFsaWduT3B0aW9uLCBtaW51c0hlaWdodCkge1xuICAgICAgICB2YXIgdG9wID0gYmFzZVRvcDtcblxuICAgICAgICBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZigndG9wJykgPiAtMSkge1xuICAgICAgICAgICAgdG9wIC09IG1pbnVzSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ21pZGRsZScpID4gLTEpIHtcbiAgICAgICAgICAgIHRvcCAtPSBtaW51c0hlaWdodCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvb2x0aXAgcG9zaXRpb24gZm9yIGJhciBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e2JvdW5kOiBvYmplY3R9fSBwYXJhbXMuZGF0YSBncmFwaCBpbmZvcm1hdGlvblxuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuZGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFsaWduT3B0aW9uIHBvc2l0aW9uIG9wdGlvbiAoZXg6ICdsZWZ0IHRvcCcpXG4gICAgICogQHJldHVybnMge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcFBvc2l0aW9uRm9yQmFyQ2hhcnQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgYm91bmQgPSBwYXJhbXMuYm91bmQsXG4gICAgICAgICAgICBwb3NpdGlvbk9wdGlvbiA9IHBhcmFtcy5wb3NpdGlvbk9wdGlvbixcbiAgICAgICAgICAgIG1pbnVzSGVpZ2h0ID0gcGFyYW1zLmRpbWVuc2lvbi5oZWlnaHQgLSAoYm91bmQuaGVpZ2h0IHx8IDApLFxuICAgICAgICAgICAgYWxpZ25PcHRpb24gPSBwYXJhbXMuYWxpZ25PcHRpb24gfHwgJycsXG4gICAgICAgICAgICB0b29sdGlwV2lkdGggPSBwYXJhbXMuZGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgYmFzZUxlZnQgPSBib3VuZC5sZWZ0ICsgYm91bmQud2lkdGggKyBwb3NpdGlvbk9wdGlvbi5sZWZ0LFxuICAgICAgICAgICAgYmFzZVRvcCA9IGJvdW5kLnRvcCArIHBvc2l0aW9uT3B0aW9uLnRvcDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogdGhpcy5fbWFrZUxlZnRQb3NpdGlvbkZvckJhckNoYXJ0KGJhc2VMZWZ0LCBhbGlnbk9wdGlvbiwgdG9vbHRpcFdpZHRoKSxcbiAgICAgICAgICAgIHRvcDogdGhpcy5fbWFrZVRvcFBvc2l0aW9uRm9yQmFyQ2hhcnQoYmFzZVRvcCwgYWxpZ25PcHRpb24sIG1pbnVzSGVpZ2h0KVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvb2x0aXAgcG9zaXRpb24gZm9yIHRyZWVtYXAgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tib3VuZDogb2JqZWN0fX0gcGFyYW1zLmRhdGEgLSBncmFwaCBpbmZvcm1hdGlvblxuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuZGltZW5zaW9uIC0gdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwUG9zaXRpb25Gb3JUcmVlbWFwQ2hhcnQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgYm91bmQgPSBwYXJhbXMuYm91bmQ7XG4gICAgICAgIHZhciBwb3NpdGlvbk9wdGlvbiA9IHBhcmFtcy5wb3NpdGlvbk9wdGlvbjtcbiAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGNoYXJ0Q29uc3QuTUFYX0hFSUdIVF9XT1JMRCwgdGhpcy5sYWJlbFRoZW1lKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogYm91bmQubGVmdCArICgoYm91bmQud2lkdGggLSBwYXJhbXMuZGltZW5zaW9uLndpZHRoKSAvIDIpICsgcG9zaXRpb25PcHRpb24ubGVmdCxcbiAgICAgICAgICAgIHRvcDogYm91bmQudG9wICsgKChib3VuZC5oZWlnaHQgLSBsYWJlbEhlaWdodCkgLyAyKSAtIHBhcmFtcy5kaW1lbnNpb24uaGVpZ2h0ICsgcG9zaXRpb25PcHRpb24udG9wXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHRvb2x0aXBEaW1lbnNpb24gdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBhZGp1c3RlZCBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkanVzdFBvc2l0aW9uOiBmdW5jdGlvbih0b29sdGlwRGltZW5zaW9uLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgY2hhcnREaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignY2hhcnQnKSxcbiAgICAgICAgICAgIGFyZWFQb3NpdGlvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0UG9zaXRpb24oJ3Rvb2x0aXAnKTtcblxuICAgICAgICBwb3NpdGlvbi5sZWZ0ID0gTWF0aC5tYXgocG9zaXRpb24ubGVmdCwgLWFyZWFQb3NpdGlvbi5sZWZ0KTtcbiAgICAgICAgcG9zaXRpb24ubGVmdCA9IE1hdGgubWluKHBvc2l0aW9uLmxlZnQsIGNoYXJ0RGltZW5zaW9uLndpZHRoIC0gYXJlYVBvc2l0aW9uLmxlZnQgLSB0b29sdGlwRGltZW5zaW9uLndpZHRoKTtcbiAgICAgICAgcG9zaXRpb24udG9wID0gTWF0aC5tYXgocG9zaXRpb24udG9wLCAtYXJlYVBvc2l0aW9uLnRvcCk7XG4gICAgICAgIHBvc2l0aW9uLnRvcCA9IE1hdGgubWluKHBvc2l0aW9uLnRvcCwgY2hhcnREaW1lbnNpb24uaGVpZ2h0IC0gYXJlYVBvc2l0aW9uLnRvcCAtIHRvb2x0aXBEaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmJvdW5kIGdyYXBoIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5hbGxvd05lZ2F0aXZlVG9vbHRpcCB3aGV0aGVyIGFsbG93IG5lZ2F0aXZlIHRvb2x0aXAgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYWxpZ25PcHRpb24gcG9zaXRpb24gb3B0aW9uIChleDogJ2xlZnQgdG9wJylcbiAgICAgKiBAcmV0dXJucyB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB7fSxcbiAgICAgICAgICAgIHNpemVUeXBlLCBwb3NpdGlvblR5cGUsIGFkZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5tb3VzZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX21ha2VUb29sdGlwUG9zaXRpb25Ub01vdXNlUG9zaXRpb24ocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuaXNCYXJDaGFydChwYXJhbXMuY2hhcnRUeXBlKSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fbWFrZVRvb2x0aXBQb3NpdGlvbkZvckJhckNoYXJ0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgc2l6ZVR5cGUgPSAnd2lkdGgnO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uVHlwZSA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBhZGRQYWRkaW5nID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlZGljYXRlLmlzVHJlZW1hcENoYXJ0KHBhcmFtcy5jaGFydFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9tYWtlVG9vbHRpcFBvc2l0aW9uRm9yVHJlZW1hcENoYXJ0KHBhcmFtcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fbWFrZVRvb2x0aXBQb3NpdGlvbkZvck5vdEJhckNoYXJ0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgc2l6ZVR5cGUgPSAnaGVpZ2h0JztcbiAgICAgICAgICAgICAgICBwb3NpdGlvblR5cGUgPSAndG9wJztcbiAgICAgICAgICAgICAgICBhZGRQYWRkaW5nID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuYWxsb3dOZWdhdGl2ZVRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX21vdmVUb1N5bW1ldHJ5KHBvc2l0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiBwYXJhbXMuYm91bmQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHBhcmFtcy5pbmRleGVzLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb246IHBhcmFtcy5kaW1lbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVR5cGU6IHNpemVUeXBlLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblR5cGU6IHBvc2l0aW9uVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgYWRkUGFkZGluZzogYWRkUGFkZGluZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX2FkanVzdFBvc2l0aW9uKHBhcmFtcy5kaW1lbnNpb24sIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0byBzeW1tZXRyeS5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gdG9vbHRpcCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuYm91bmQgZ3JhcGggYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuaWQgdG9vbHRpcCBpZFxuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuZGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNpemVUeXBlIHNpemUgdHlwZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wb3NpdGlvblR5cGUgcG9zaXRpb24gdHlwZSAobGVmdCBvciB0b3ApXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmFkZFBhZGRpbmcgYWRkIHBhZGRpbmdcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBtb3ZlZCBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdmVUb1N5bW1ldHJ5OiBmdW5jdGlvbihwb3NpdGlvbiwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHBhcmFtcy5ib3VuZDtcbiAgICAgICAgdmFyIHNpemVUeXBlID0gcGFyYW1zLnNpemVUeXBlO1xuICAgICAgICB2YXIgcG9zaXRpb25UeXBlID0gcGFyYW1zLnBvc2l0aW9uVHlwZTtcbiAgICAgICAgdmFyIHNlcmllc05hbWUgPSBwYXJhbXMuc2VyaWVzTmFtZSB8fCBwYXJhbXMuY2hhcnRUeXBlO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0VmFsdWUocGFyYW1zLmluZGV4ZXMuZ3JvdXBJbmRleCwgcGFyYW1zLmluZGV4ZXMuaW5kZXgsIHNlcmllc05hbWUpO1xuICAgICAgICB2YXIgdG9vbHRpcFNpemVIYWxmLCBiYXJQb3NpdGlvbiwgYmFyU2l6ZUhhbGYsIG1vdmVkUG9zaXRpb25WYWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0b29sdGlwU2l6ZUhhbGYgPSBwYXJhbXMuZGltZW5zaW9uW3NpemVUeXBlXSAvIDI7XG4gICAgICAgICAgICBiYXJQb3NpdGlvbiA9IGJvdW5kW3Bvc2l0aW9uVHlwZV07XG4gICAgICAgICAgICBiYXJTaXplSGFsZiA9IGJvdW5kW3NpemVUeXBlXSAvIDI7XG4gICAgICAgICAgICBtb3ZlZFBvc2l0aW9uVmFsdWUgPSAoYmFyUG9zaXRpb24gKyBiYXJTaXplSGFsZiAtIHRvb2x0aXBTaXplSGFsZikgKiAyIC0gcG9zaXRpb25bcG9zaXRpb25UeXBlXTtcbiAgICAgICAgICAgIHBvc2l0aW9uW3Bvc2l0aW9uVHlwZV0gPSBtb3ZlZFBvc2l0aW9uVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBpbmRleGVzIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBwcmV2SW5kZXhlcyBwcmV2IGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBjaGFuZ2VkIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2hhbmdlZEluZGV4ZXM6IGZ1bmN0aW9uKHByZXZJbmRleGVzLCBpbmRleGVzKSB7XG4gICAgICAgIHJldHVybiAhIXByZXZJbmRleGVzICYmIChwcmV2SW5kZXhlcy5ncm91cEluZGV4ICE9PSBpbmRleGVzLmdyb3VwSW5kZXggfHwgcHJldkluZGV4ZXMuaW5kZXggIT09IGluZGV4ZXMuaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2luZGV4ZXM6IHtncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9LCBib3VuZDogb2JqZWN0fX0gcGFyYW1zIHRvb2x0aXAgZGF0YVxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2UG9zaXRpb24gcHJldiBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3dUb29sdGlwOiBmdW5jdGlvbihlbFRvb2x0aXAsIHBhcmFtcywgcHJldlBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBpbmRleGVzID0gcGFyYW1zLmluZGV4ZXMsXG4gICAgICAgICAgICBwcmV2SW5kZXhlcyA9IHRoaXMuX2dldEluZGV4ZXNDdXN0b21BdHRyaWJ1dGUoZWxUb29sdGlwKSxcbiAgICAgICAgICAgIHByZXZDaGFydFR5cGUsIHBvc2l0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc0NoYW5nZWRJbmRleGVzKHByZXZJbmRleGVzLCBpbmRleGVzKSkge1xuICAgICAgICAgICAgcHJldkNoYXJ0VHlwZSA9IGVsVG9vbHRpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2hhcnQtdHlwZScpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZUhpZGVBbmltYXRpb24ocHJldkluZGV4ZXMsIHByZXZDaGFydFR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxUb29sdGlwLmlubmVySFRNTCA9IHRoaXMuX21ha2VTaW5nbGVUb29sdGlwSHRtbChwYXJhbXMuc2VyaWVzTmFtZSB8fCBwYXJhbXMuY2hhcnRUeXBlLCBpbmRleGVzKTtcblxuICAgICAgICBlbFRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWNoYXJ0LXR5cGUnLCBwYXJhbXMuY2hhcnRUeXBlKTtcbiAgICAgICAgdGhpcy5fc2V0SW5kZXhlc0N1c3RvbUF0dHJpYnV0ZShlbFRvb2x0aXAsIGluZGV4ZXMpO1xuICAgICAgICB0aGlzLl9zZXRTaG93ZWRDdXN0b21BdHRyaWJ1dGUoZWxUb29sdGlwLCB0cnVlKTtcblxuICAgICAgICB0aGlzLl9maXJlQmVmb3JlU2hvd1Rvb2x0aXAoaW5kZXhlcyk7XG5cbiAgICAgICAgZG9tLmFkZENsYXNzKGVsVG9vbHRpcCwgJ3Nob3cnKTtcblxuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX21ha2VUb29sdGlwUG9zaXRpb24odHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjogdGhpcy5nZXRUb29sdGlwRGltZW5zaW9uKGVsVG9vbHRpcCksXG4gICAgICAgICAgICBwb3NpdGlvbk9wdGlvbjogdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uKSxcbiAgICAgICAgICAgIGFsaWduT3B0aW9uOiB0aGlzLm9wdGlvbnMuYWxpZ24gfHwgJydcbiAgICAgICAgfSwgcGFyYW1zKSk7XG5cbiAgICAgICAgdGhpcy5fbW92ZVRvUG9zaXRpb24oZWxUb29sdGlwLCBwb3NpdGlvbiwgcHJldlBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fZmlyZVNob3dBbmltYXRpb24oaW5kZXhlcywgcGFyYW1zLmNoYXJ0VHlwZSk7XG4gICAgICAgIHRoaXMuX2ZpcmVBZnRlclNob3dUb29sdGlwKGluZGV4ZXMsIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsVG9vbHRpcCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBiZWZvcmVTaG93VG9vbHRpcCBjYWxsYmFjayBvZiB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUJlZm9yZVNob3dUb29sdGlwOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLl9tYWtlU2hvd1Rvb2x0aXBQYXJhbXMoaW5kZXhlcyk7XG5cbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnYmVmb3JlU2hvd1Rvb2x0aXAnLCBwYXJhbXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIGFmdGVyU2hvd1Rvb2x0aXAgY2FsbGJhY2sgb2YgdXNlckV2ZW50LlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhZGRpdGlvblBhcmFtcyBhZGRpdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUFmdGVyU2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKGluZGV4ZXMsIGFkZGl0aW9uUGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLl9tYWtlU2hvd1Rvb2x0aXBQYXJhbXMoaW5kZXhlcywgYWRkaXRpb25QYXJhbXMpO1xuXG4gICAgICAgIHRoaXMudXNlckV2ZW50LmZpcmUoJ2FmdGVyU2hvd1Rvb2x0aXAnLCBwYXJhbXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGhpZGluZyB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvb2x0aXBFbGVtZW50IHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V4ZWN1dGVIaWRpbmdUb29sdGlwOiBmdW5jdGlvbih0b29sdGlwRWxlbWVudCkge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3ModG9vbHRpcEVsZW1lbnQsICdzaG93Jyk7XG4gICAgICAgIHRvb2x0aXBFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1ncm91cEluZGV4Jyk7XG4gICAgICAgIHRvb2x0aXBFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpO1xuICAgICAgICB0b29sdGlwRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b29sdGlwRWxlbWVudCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlVG9vbHRpcDogZnVuY3Rpb24odG9vbHRpcEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgaW5kZXhlcyA9IHRoaXMuX2dldEluZGV4ZXNDdXN0b21BdHRyaWJ1dGUodG9vbHRpcEVsZW1lbnQpO1xuICAgICAgICB2YXIgY2hhcnRUeXBlID0gdG9vbHRpcEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNoYXJ0LXR5cGUnKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzTW91c2VQb3NpdGlvbkNoYXJ0KGNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVIaWRpbmdUb29sdGlwKHRvb2x0aXBFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFydFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFNob3dlZEN1c3RvbUF0dHJpYnV0ZSh0b29sdGlwRWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZUhpZGVBbmltYXRpb24oaW5kZXhlcywgY2hhcnRUeXBlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ2hhbmdlZEluZGV4ZXModGhpcy5wcmV2SW5kZXhlcywgaW5kZXhlcykpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2SW5kZXhlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5faXNTaG93ZWRUb29sdGlwKHRvb2x0aXBFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5fZXhlY3V0ZUhpZGluZ1Rvb2x0aXAodG9vbHRpcEVsZW1lbnQpO1xuICAgICAgICAgICAgfSwgY2hhcnRDb25zdC5ISURFX0RFTEFZKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBzaG93IHRvb2x0aXAgY29udGFpbmVyLlxuICAgICAqL1xuICAgIG9uU2hvd1Rvb2x0aXBDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnRvb2x0aXBDb250YWluZXIuc3R5bGUuekluZGV4ID0gY2hhcnRDb25zdC5UT09MVElQX1pJTkRFWDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gaGlkZSB0b29sdGlwIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBvbkhpZGVUb29sdGlwQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50b29sdGlwQ29udGFpbmVyLnN0eWxlLnpJbmRleCA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peCBpbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIHRhcmdldCBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBtaXhpbjogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB0dWkudXRpbC5leHRlbmQoZnVuYy5wcm90b3R5cGUsIHRoaXMpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2luZ2xlVG9vbHRpcE1peGVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRvb2x0aXAgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb29sdGlwQmFzZSA9IHJlcXVpcmUoJy4vdG9vbHRpcEJhc2UnKTtcbnZhciBzaW5nbGVUb29sdGlwTWl4ZXIgPSByZXF1aXJlKCcuL3NpbmdsZVRvb2x0aXBNaXhlcicpO1xudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xudmFyIHRvb2x0aXBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdG9vbHRpcFRlbXBsYXRlJyk7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBUb29sdGlwIGNvbXBvbmVudC5cbiAqIEBjbGFzcyBUb29sdGlwXG4gKi9cbnZhciBUb29sdGlwID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoVG9vbHRpcEJhc2UsIC8qKiBAbGVuZHMgVG9vbHRpcC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFRvb2x0aXAgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIFRvb2x0aXBcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgVG9vbHRpcEJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwIGh0bWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IGNhdGVnb3J5XG4gICAgICogQHBhcmFtIHt7dmFsdWU6IHN0cmluZywgbGVnZW5kOiBzdHJpbmcsIGNoYXJ0VHlwZTogc3RyaW5nLCBzdWZmaXg6ID9zdHJpbmd9fSBpdGVtIGl0ZW0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvb2x0aXAgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwSHRtbDogZnVuY3Rpb24oY2F0ZWdvcnksIGl0ZW0pIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNDb29yZGluYXRlVHlwZUNoYXJ0KHRoaXMuY2hhcnRUeXBlKSkge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0b29sdGlwVGVtcGxhdGUudHBsQ29vcmRpbmF0ZXR5cGVDaGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gdG9vbHRpcFRlbXBsYXRlLnRwbERlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUodHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGNhdGVnb3J5VmlzaWJsZTogY2F0ZWdvcnkgPyAnc2hvdycgOiAnaGlkZScsXG4gICAgICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcnlcbiAgICAgICAgfSwgaXRlbSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGh0bWwgZm9yIHZhbHVlIHR5cGVzIGxpa2UgeCwgeSwgclxuICAgICAqIEBwYXJhbSB7e3g6ID9udW1iZXIsIHk6ID9udW1iZXIsIHI6ID9udW1iZXJ9fSBkYXRhIC0gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHZhbHVlVHlwZXMgLSB0eXBlcyBvZiB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUh0bWxGb3JWYWx1ZVR5cGVzOiBmdW5jdGlvbihkYXRhLCB2YWx1ZVR5cGVzKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVUeXBlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIChkYXRhW3R5cGVdKSA/ICc8ZGl2PicgKyB0eXBlICsgJzogJyArIGRhdGFbdHlwZV0gKyAnPC9kaXY+JyA6ICcnO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzaW5nbGUgdG9vbHRpcCBodG1sLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvb2x0aXAgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTaW5nbGVUb29sdGlwSHRtbDogZnVuY3Rpb24oY2hhcnRUeXBlLCBpbmRleGVzKSB7XG4gICAgICAgIHZhciBkYXRhID0gdHVpLnV0aWwucGljayh0aGlzLmRhdGEsIGNoYXJ0VHlwZSwgaW5kZXhlcy5ncm91cEluZGV4LCBpbmRleGVzLmluZGV4KTtcblxuICAgICAgICBkYXRhID0gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIHN1ZmZpeDogdGhpcy5zdWZmaXhcbiAgICAgICAgfSwgZGF0YSk7XG4gICAgICAgIGRhdGEudmFsdWVUeXBlcyA9IHRoaXMuX21ha2VIdG1sRm9yVmFsdWVUeXBlcyhkYXRhLCBbJ3gnLCAneScsICdyJ10pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlRnVuYyhkYXRhLmNhdGVnb3J5LCBkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlZmF1bHQgYWxpZ24gb3B0aW9uIG9mIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfc2V0RGVmYXVsdFRvb2x0aXBQb3NpdGlvbk9wdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxpZ24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbGlnbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ERUZBVUxUX0FMSUdOX09QVElPTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbGlnbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ERUZBVUxUX0hPUklaT05UQUxfQUxJR05fT1BUSU9OO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcGFyYW1ldGVycyBmb3Igc2hvdyB0b29sdGlwIHVzZXIgZXZlbnQuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFkZGl0aW9uUGFyYW1zIGFkZGl0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB7e2NoYXJ0VHlwZTogc3RyaW5nLCBsZWdlbmQ6IHN0cmluZywgbGVnZW5kSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IHBhcmFtZXRlcnMgZm9yIHNob3cgdG9vbHRpcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTaG93VG9vbHRpcFBhcmFtczogZnVuY3Rpb24oaW5kZXhlcywgYWRkaXRpb25QYXJhbXMpIHtcbiAgICAgICAgdmFyIGxlZ2VuZEluZGV4ID0gaW5kZXhlcy5pbmRleDtcbiAgICAgICAgdmFyIGxlZ2VuZERhdGEgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0TGVnZW5kSXRlbShsZWdlbmRJbmRleCk7XG4gICAgICAgIHZhciBwYXJhbXM7XG5cbiAgICAgICAgaWYgKCFsZWdlbmREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtcyA9IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBjaGFydFR5cGU6IGxlZ2VuZERhdGEuY2hhcnRUeXBlLFxuICAgICAgICAgICAgbGVnZW5kOiBsZWdlbmREYXRhLmxhYmVsLFxuICAgICAgICAgICAgbGVnZW5kSW5kZXg6IGxlZ2VuZEluZGV4LFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4ZXMuZ3JvdXBJbmRleFxuICAgICAgICB9LCBhZGRpdGlvblBhcmFtcyk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHZhbHVlIG9mIHZhbHVlTWFwXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlTWFwIC0gbWFwIG9mIHZhbHVlIGxpa2UgdmFsdWUsIHgsIHksIHJcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZm9ybWF0VmFsdWVNYXA6IGZ1bmN0aW9uKHZhbHVlTWFwKSB7XG4gICAgICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0RnVuY3Rpb25zKCk7XG4gICAgICAgIHZhciBjaGFydFR5cGUgPSB0aGlzLmNoYXJ0VHlwZTtcbiAgICAgICAgdmFyIGZvcm1hdHRlZE1hcCA9IHt9O1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2godmFsdWVNYXAsIGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZE1hcFt2YWx1ZVR5cGVdID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZSh2YWx1ZSwgZm9ybWF0RnVuY3Rpb25zLCBjaGFydFR5cGUsICd0b29sdGlwJywgdmFsdWVUeXBlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZE1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwIGRhdHVtLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxlZ2VuZExhYmVscyAtIGxlZ2VuZCBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnkgLSBjYXRlZ29yeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgLSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtTZXJpZXNJdGVtfSBzZXJpZXNJdGVtIC0gU2VyaWVzSXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcERhdHVtOiBmdW5jdGlvbihsZWdlbmRMYWJlbHMsIGNhdGVnb3J5LCBjaGFydFR5cGUsIHNlcmllc0l0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciBsZWdlbmQgPSBsZWdlbmRMYWJlbHNbY2hhcnRUeXBlXVtpbmRleF0gfHwgJyc7XG5cbiAgICAgICAgdmFyIGxhYmVsUHJlZml4ID0gKGxlZ2VuZCAmJiBzZXJpZXNJdGVtLmxhYmVsKSA/ICc6Jm5ic3A7JyA6ICcnO1xuICAgICAgICB2YXIgbGFiZWwgPSBzZXJpZXNJdGVtLnRvb2x0aXBMYWJlbCB8fCAoc2VyaWVzSXRlbS5sYWJlbCA/IGxhYmVsUHJlZml4ICsgc2VyaWVzSXRlbS5sYWJlbCA6ICcnKTtcbiAgICAgICAgdmFyIHZhbHVlTWFwID0gdGhpcy5fZm9ybWF0VmFsdWVNYXAoc2VyaWVzSXRlbS5waWNrVmFsdWVNYXAoKSk7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcnkgfHwgJycsXG4gICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZCxcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICB9LCB2YWx1ZU1hcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gdG9vbHRpcCBkYXRhXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9yZ0xlZ2VuZExhYmVscyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRMZWdlbmRMYWJlbHMoKTtcbiAgICAgICAgdmFyIGlzUGl2b3QgPSBwcmVkaWNhdGUuaXNUcmVlbWFwQ2hhcnQodGhpcy5jaGFydFR5cGUpO1xuICAgICAgICB2YXIgbGVnZW5kTGFiZWxzID0ge307XG4gICAgICAgIHZhciB0b29sdGlwRGF0YSA9IHt9O1xuXG4gICAgICAgIGlmICh0dWkudXRpbC5pc0FycmF5KG9yZ0xlZ2VuZExhYmVscykpIHtcbiAgICAgICAgICAgIGxlZ2VuZExhYmVsc1t0aGlzLmNoYXJ0VHlwZV0gPSBvcmdMZWdlbmRMYWJlbHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWdlbmRMYWJlbHMgPSBvcmdMZWdlbmRMYWJlbHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IuZWFjaEJ5U2VyaWVzR3JvdXAoZnVuY3Rpb24oc2VyaWVzR3JvdXAsIGdyb3VwSW5kZXgsIGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIGRhdGE7XG5cbiAgICAgICAgICAgIGNoYXJ0VHlwZSA9IGNoYXJ0VHlwZSB8fCBzZWxmLmNoYXJ0VHlwZTtcblxuICAgICAgICAgICAgZGF0YSA9IHNlcmllc0dyb3VwLm1hcChmdW5jdGlvbihzZXJpZXNJdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeSA9IHNlbGYuZGF0YVByb2Nlc3Nvci5nZXRUb29sdGlwQ2F0ZWdvcnkoZ3JvdXBJbmRleCwgaW5kZXgsIHNlbGYuaXNWZXJ0aWNhbCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzSXRlbSA/IHNlbGYuX21ha2VUb29sdGlwRGF0dW0obGVnZW5kTGFiZWxzLCBjYXRlZ29yeSwgY2hhcnRUeXBlLCBzZXJpZXNJdGVtLCBpbmRleCkgOiBudWxsO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghdG9vbHRpcERhdGFbY2hhcnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBEYXRhW2NoYXJ0VHlwZV0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9vbHRpcERhdGFbY2hhcnRUeXBlXS5wdXNoKGRhdGEpO1xuICAgICAgICB9LCBpc1Bpdm90KTtcblxuICAgICAgICByZXR1cm4gdG9vbHRpcERhdGE7XG4gICAgfVxufSk7XG5cbnNpbmdsZVRvb2x0aXBNaXhlci5taXhpbihUb29sdGlwKTtcbm1vZHVsZS5leHBvcnRzID0gVG9vbHRpcDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUb29sdGlwQmFzZSBpcyBiYXNlIGNsYXNzIG9mIHRvb2x0aXAgY29tcG9uZW50cy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbnZhciBUb29sdGlwQmFzZSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgVG9vbHRpcEJhc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBUb29sdGlwQmFzZSBpcyBiYXNlIGNsYXNzIG9mIHRvb2x0aXAgY29tcG9uZW50cy5cbiAgICAgKiBAY29uc3RydWN0cyBUb29sdGlwQmFzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcGFyYW1zLnZhbHVlcyBjb252ZXJ0ZWQgdmFsdWVzXG4gICAgICogICAgICBAcGFyYW0ge0JvdW5kc01ha2VyfSBwYXJhbXMuYm91bmRzTWFrZXIgYm91bmRzIG1ha2VyXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIGF4aXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGlzUGllQ2hhcnQgPSBwcmVkaWNhdGUuaXNQaWVDaGFydChwYXJhbXMuY2hhcnRUeXBlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhcnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIHByb2Nlc3NvclxuICAgICAgICAgKiBAdHlwZSB7RGF0YVByb2Nlc3Nvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IHBhcmFtcy5kYXRhUHJvY2Vzc29yO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZHMgbWFrZXJcbiAgICAgICAgICogQHR5cGUge0JvdW5kc01ha2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlciA9IHBhcmFtcy5ib3VuZHNNYWtlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uc1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZW1lXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRoZW1lID0gcGFyYW1zLnRoZW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNWZXJ0aWNhbCA9IHBhcmFtcy5pc1ZlcnRpY2FsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VyIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAqIEB0eXBlIHtVc2VyRXZlbnRMaXN0ZW5lcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlckV2ZW50ID0gcGFyYW1zLnVzZXJFdmVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbGFiZWwgdGhlbWVcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFiZWxUaGVtZSA9IHBhcmFtcy5sYWJlbFRoZW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbGFzc05hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jaGFydC10b29sdGlwLWFyZWEnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb29sdGlwIGNvbnRhaW5lci5cbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b29sdGlwQ29udGFpbmVyID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG9vbHRpcCBzdWZmaXguXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHRoaXMub3B0aW9ucy5zdWZmaXggPyAnJm5ic3A7JyArIHRoaXMub3B0aW9ucy5zdWZmaXggOiAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG9vbHRpcCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZW1wbGF0ZUZ1bmMgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUgfHwgdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlVG9vbHRpcEh0bWwsIHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb29sdGlwIGFuaW1hdGlvbiB0aW1lLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb25UaW1lID0gaXNQaWVDaGFydCA/IGNoYXJ0Q29uc3QuVE9PTFRJUF9QSUVfQU5JTUFUSU9OX1RJTUUgOiBjaGFydENvbnN0LlRPT0xUSVBfQU5JTUFUSU9OX1RJTUU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvb2x0aXBCYXNlIGJhc2UgZGF0YS5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxBcnJheS48b2JqZWN0Pj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcblxuICAgICAgICB0aGlzLl9zZXREZWZhdWx0VG9vbHRpcFBvc2l0aW9uT3B0aW9uKCk7XG4gICAgICAgIHRoaXMuX3NhdmVPcmlnaW5hbFBvc2l0aW9uT3B0aW9ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvb2x0aXAgaHRtbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcEh0bWw6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgZGVmYXVsdCBhbGlnbiBvcHRpb24gb2YgdG9vbHRpcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9zZXREZWZhdWx0VG9vbHRpcFBvc2l0aW9uT3B0aW9uOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogU2F2ZSBwb3NpdGlvbiBvcHRpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NhdmVPcmlnaW5hbFBvc2l0aW9uT3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3JnUG9zaXRpb25PcHRpb25zID0ge1xuICAgICAgICAgICAgYWxpZ246IHRoaXMub3B0aW9ucy5hbGlnbixcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMucG9zaXRpb25cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBEYXRhOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRvb2x0aXAgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdG9vbHRpcCBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpO1xuXG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuX21ha2VUb29sdGlwRGF0YSgpO1xuXG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24oZWwsIHRoaXMuYm91bmRzTWFrZXIuZ2V0UG9zaXRpb24oJ3Rvb2x0aXAnKSk7XG5cbiAgICAgICAgdGhpcy50b29sdGlwQ29udGFpbmVyID0gZWw7XG5cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXJlbmRlci5cbiAgICAgKi9cbiAgICByZXJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuX21ha2VUb29sdGlwRGF0YSgpO1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdG9vbHRpcCBjb21wb25lbnQuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbih0aGlzLnRvb2x0aXBDb250YWluZXIsIHRoaXMuYm91bmRzTWFrZXIuZ2V0UG9zaXRpb24oJ3Rvb2x0aXAnKSk7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbC51cGRhdGVCb3VuZCh0aGlzLmJvdW5kc01ha2VyLmdldEJvdW5kKCd0b29sdGlwJykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb20uXG4gICAgICovXG4gICAgem9vbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuX21ha2VUb29sdGlwRGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdG9vbHRpcCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0VG9vbHRpcEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG9vbHRpcEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXBFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBFbGVtZW50ID0gdG9vbHRpcEVsZW1lbnQgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LXRvb2x0aXAnKTtcbiAgICAgICAgICAgIGRvbS5hcHBlbmQodGhpcy50b29sdGlwQ29udGFpbmVyLCB0b29sdGlwRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwRWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogb25TaG93IGlzIGNhbGxiYWNrIG9mIGN1c3RvbSBldmVudCBzaG93VG9vbHRpcCBmb3IgU2VyaWVzVmlldy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIGNvb3JkaW5hdGUgZXZlbnQgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIG9uU2hvdzogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB0b29sdGlwRWxlbWVudCA9IHRoaXMuX2dldFRvb2x0aXBFbGVtZW50KCksXG4gICAgICAgICAgICBwcmV2UG9zaXRpb247XG5cbiAgICAgICAgaWYgKCFwcmVkaWNhdGUuaXNNb3VzZVBvc2l0aW9uQ2hhcnQocGFyYW1zLmNoYXJ0VHlwZSkgJiYgdG9vbHRpcEVsZW1lbnQub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgIHByZXZQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0b29sdGlwRWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogdG9vbHRpcEVsZW1lbnQub2Zmc2V0VG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXAodG9vbHRpcEVsZW1lbnQsIHBhcmFtcywgcHJldlBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9vbHRpcEVsZW1lbnQgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHJlbmRlcmVkIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICovXG4gICAgZ2V0VG9vbHRpcERpbWVuc2lvbjogZnVuY3Rpb24odG9vbHRpcEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0b29sdGlwRWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdG9vbHRpcEVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gUG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9vbHRpcEVsZW1lbnQgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHByZXZQb3NpdGlvbiBwcmV2IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW92ZVRvUG9zaXRpb246IGZ1bmN0aW9uKHRvb2x0aXBFbGVtZW50LCBwb3NpdGlvbiwgcHJldlBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwcmV2UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3NsaWRlVG9vbHRpcCh0b29sdGlwRWxlbWVudCwgcHJldlBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKHRvb2x0aXBFbGVtZW50LCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2xpZGUgdG9vbHRpcFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvb2x0aXBFbGVtZW50IHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2UG9zaXRpb24gcHJldiBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NsaWRlVG9vbHRpcDogZnVuY3Rpb24odG9vbHRpcEVsZW1lbnQsIHByZXZQb3NpdGlvbiwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIG1vdmVUb3AgPSBwb3NpdGlvbi50b3AgLSBwcmV2UG9zaXRpb24udG9wLFxuICAgICAgICAgICAgbW92ZUxlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gcHJldlBvc2l0aW9uLmxlZnQ7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5jYW5jZWxBbmltYXRpb24odGhpcy5zbGlkaW5nQW5pbWF0aW9uKTtcblxuICAgICAgICB0aGlzLnNsaWRpbmdBbmltYXRpb24gPSByZW5kZXJVdGlsLnN0YXJ0QW5pbWF0aW9uKHRoaXMuYW5pbWF0aW9uVGltZSwgZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbW92ZUxlZnQgKiByYXRpbyxcbiAgICAgICAgICAgICAgICB0b3AgPSBtb3ZlVG9wICogcmF0aW87XG4gICAgICAgICAgICB0b29sdGlwRWxlbWVudC5zdHlsZS5sZWZ0ID0gKHByZXZQb3NpdGlvbi5sZWZ0ICsgbGVmdCkgKyAncHgnO1xuICAgICAgICAgICAgdG9vbHRpcEVsZW1lbnQuc3R5bGUudG9wID0gKHByZXZQb3NpdGlvbi50b3AgKyB0b3ApICsgJ3B4JztcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG9uSGlkZSBpcyBjYWxsYmFjayBvZiBjdXN0b20gZXZlbnQgaGlkZVRvb2x0aXAgZm9yIFNlcmllc1ZpZXdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBvbkhpZGU6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciB0b29sdGlwRWxlbWVudCA9IHRoaXMuX2dldFRvb2x0aXBFbGVtZW50KCk7XG5cbiAgICAgICAgdGhpcy5faGlkZVRvb2x0aXAodG9vbHRpcEVsZW1lbnQsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvb2x0aXAgYWxpZ24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlnbiBhbGlnblxuICAgICAqL1xuICAgIHNldEFsaWduOiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBhbGlnbjtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25Nb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbk1vZGVsLnVwZGF0ZU9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgcG9zaXRpb24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3ZpbmcgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uID0gdHVpLnV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24sIHBvc2l0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25Nb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbk1vZGVsLnVwZGF0ZU9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0b29sdGlwIGFsaWduIG9wdGlvbi5cbiAgICAgKi9cbiAgICByZXNldEFsaWduOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFsaWduID0gdGhpcy5vcmdQb3NpdGlvbk9wdGlvbnMuYWxpZ247XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmFsaWduID0gYWxpZ247XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbC51cGRhdGVPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdG9vbHRpcCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICByZXNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5vcmdQb3NpdGlvbk9wdGlvbnMucG9zaXRpb247XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbC51cGRhdGVPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFRvb2x0aXBCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb29sdGlwQmFzZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIHRlbXBsYXRlcyBvZiB0b29sdGlwLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0ZW1wbGF0ZU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy90ZW1wbGF0ZU1ha2VyJyk7XG5cbnZhciBodG1scyA9IHtcbiAgICBIVE1MX0RFRkFVTFRfVEVNUExBVEU6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LWRlZmF1bHQtdG9vbHRpcFwiPicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cInt7IGNhdGVnb3J5VmlzaWJsZSB9fVwiPnt7IGNhdGVnb3J5IH19PC9kaXY+JyArXG4gICAgICAgICc8ZGl2PicgK1xuICAgICAgICAgICAgJzxzcGFuPnt7IGxlZ2VuZCB9fTwvc3Bhbj4nICtcbiAgICAgICAgICAgICc8c3Bhbj57eyBsYWJlbCB9fTwvc3Bhbj4nICtcbiAgICAgICAgICAgICc8c3Bhbj57eyBzdWZmaXggfX08L3NwYW4+JyArXG4gICAgICAgICc8L2Rpdj4nICtcbiAgICAnPC9kaXY+JyxcbiAgICBIVE1MX0NPT1JESU5BVEVfVFlQRV9DSEFSVF9URU1QTEFURTogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtZGVmYXVsdC10b29sdGlwXCI+JyArXG4gICAgICAgICc8ZGl2Pnt7IGNhdGVnb3J5IH19PC9kaXY+JyArXG4gICAgICAgICc8ZGl2PicgK1xuICAgICAgICAgICAgJzxzcGFuPnt7IGxlZ2VuZCB9fTwvc3Bhbj4nICtcbiAgICAgICAgICAgICc8c3Bhbj57eyBsYWJlbCB9fTwvc3Bhbj4nICtcbiAgICAgICAgJzwvZGl2Pnt7IHZhbHVlVHlwZXMgfX0nICtcbiAgICAnPC9kaXY+JyxcbiAgICBIVE1MX0dST1VQOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1kZWZhdWx0LXRvb2x0aXAgdHVpLWNoYXJ0LWdyb3VwLXRvb2x0aXBcIj4nICtcbiAgICAgICAgJzxkaXY+e3sgY2F0ZWdvcnkgfX08L2Rpdj4nICtcbiAgICAgICAgJ3t7IGl0ZW1zIH19JyArXG4gICAgJzwvZGl2PicsXG4gICAgSFRNTF9HUk9VUF9JVEVNOiAnPGRpdj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbGVnZW5kLXJlY3Qge3sgY2hhcnRUeXBlIH19XCIgc3R5bGU9XCJ7eyBjc3NUZXh0IH19XCI+PC9kaXY+JyArXG4gICAgICAgICcmbmJzcDs8c3Bhbj57eyBsZWdlbmQgfX08L3NwYW4+OiZuYnNwOzxzcGFuPnt7IHZhbHVlIH19PC9zcGFuPicgK1xuICAgICAgICAnPHNwYW4+e3sgc3VmZml4IH19PC9zcGFuPicgK1xuICAgICc8L2Rpdj4nLFxuICAgIEdST1VQX0NTU19URVhUOiAnYmFja2dyb3VuZC1jb2xvcjp7eyBjb2xvciB9fScsXG4gICAgSFRNTF9NQVBfQ0hBUlRfREVGQVVMVF9URU1QTEFURTogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtZGVmYXVsdC10b29sdGlwXCI+JyArXG4gICAgICAgICc8ZGl2Pnt7IG5hbWUgfX06IHt7IHZhbHVlIH19e3sgc3VmZml4IH19PC9kaXY+JyArXG4gICAgJzwvZGl2Pidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRwbERlZmF1bHQ6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9ERUZBVUxUX1RFTVBMQVRFKSxcbiAgICB0cGxDb29yZGluYXRldHlwZUNoYXJ0OiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfQ09PUkRJTkFURV9UWVBFX0NIQVJUX1RFTVBMQVRFKSxcbiAgICB0cGxHcm91cDogdGVtcGxhdGVNYWtlci50ZW1wbGF0ZShodG1scy5IVE1MX0dST1VQKSxcbiAgICB0cGxHcm91cEl0ZW06IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9HUk9VUF9JVEVNKSxcbiAgICB0cGxHcm91cENzc1RleHQ6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuR1JPVVBfQ1NTX1RFWFQpLFxuICAgIHRwbE1hcENoYXJ0RGVmYXVsdDogdGVtcGxhdGVNYWtlci50ZW1wbGF0ZShodG1scy5IVE1MX01BUF9DSEFSVF9ERUZBVUxUX1RFTVBMQVRFKVxufTtcbiJdfQ==
